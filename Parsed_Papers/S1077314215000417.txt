@&#MAIN-TITLE@&#Dynamic task decomposition for decentralized object tracking in complex scenes

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Decentralized tracking in multicamera environment is formalized as assignment problem.


                        
                        
                           
                           Assignment decomposes tracking task into subtasks under occlusion constraints.


                        
                        
                           
                           Assignment is found by minimizing a parameter-free objective function F.


                        
                        
                           
                           F derived via information theoretic measure of predicted uncertainty under assignment.


                        
                        
                           
                           Min-cost flow solver exploits graph encoding structure of F and occlusion constraints.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Multi-camera tracking

Object tracking

Distributed tracking

Camera selection

Resource allocation

Task assignment

Performance evaluation

@&#ABSTRACT@&#


               
               
                  The employment of visual sensor networks for video surveillance has brought in as many challenges as advantages. While the integration of multiple cameras into a network has the potential advantage of fusing complementary observations from sensors and enlarging visual coverage, it also increases the complexity of tracking tasks and poses challenges to system scalability. For real time performance, a key approach to tackling these challenges is the mapping of the global tracking task onto a distributed sensing and processing infrastructure. In this paper, we present an efficient and scalable multi-camera multi-people tracking system with a three-layer architecture, in which we formulate the overall task (i.e., tracking all people using all available cameras) as a vision based state estimation problem and aim to maximize utility and sharing of available sensing and processing resources. By exploiting the geometric relations between sensing geometry and people’s positions, our method is able to dynamically and adaptively partition the overall task into a number of nearly independent subtasks with the aid of occlusion reasoning, each of which tracks a subset of people with a subset of cameras (or agencies). The method hereby reduces task complexity dramatically and helps to boost parallelization and maximize the system’s real time throughput and reliability while accounting for intrinsic uncertainty induced, e.g., by visual clutter and occlusions. We demonstrate the efficiency of our decentralized tracker on challenging indoor and outdoor video sequences.
               
            

@&#INTRODUCTION@&#

The technology of people tracking in visual surveillance has developed fast over the past years. With the increasing demand of security and surveillance as well as other applications such as ambient assisted living, sports analysis, traffic control and smart museums, nowadays visual surveillance often involves monitoring large, open areas (eg., airports) with multiple networked cameras. The employment of visual sensor networks in surveillance systems has brought in as many challenges as advantages. While the integration of multiple cameras into a network has the potential advantage of fusing complementary observations from sensors and enlarging visual coverage, it also increases the complexity of tracking tasks and poses challenges to system scalability. Traditional methods of tracking all the targets with a joint likelihood can easily incur the curse of dimensionality as the number of targets increases. On the other hand, tracking with totally independent particle filters often results in the problem of hijacking [4]. Another issue arises from the enlarged area to be monitored and the increased number of views to be processed. Larger area means more computational resources to be allocated and more views means more data to be processed, hence engendering more computational overhead. How to curtail the computational load so as to maintain real-time tracking without losing frames is then a big issue. Besides, camera networks usually have limited resources such as communication bandwidth and sensors typically have limited or even no computational capabilities, the way of information gathering, sharing and processing among cameras is then of crucial importance. A possible approach to tackling these challenges would then be to dynamically map the demanding global task onto a decentralized or distributed sensing and processing infrastructure.

In this paper, we demonstrate that the overall tracking task can be split into nearly independent subtasks corresponding to the tracking of subsets of people with a subset of cameras, thereby reducing computational load and saving communication bandwidth due to branched image transfer. Our dynamic task decomposition strategy brings out a three-layer architecture for the tracking system (Fig. 1
                     ), in which cameras constitute the bottom layer and are dynamically grouped into clusters (or agencies, the middle layer) which track a subset of targets using existing base trackers. The top layer is a supervisor process which takes care of target detection and track termination, and task decomposition. For real-time consideration, we design a simple but effective cost function which measures the cost induced by decomposing a task. Two methods for task decomposition are proposed. One is based on exhaustive search, i.e., to enumerate all feasible combinations of agencies and subsets of targets under given constraints and find out the one that results in the least cost. The other method formulates it as a minimum cost flow problem.

The main contributions of this paper develop around a novel formulation of the many-to-many assignment problem in multi-target multi-camera tracking. It is based on a task decomposition cost that combines computational complexity of base trackers with camera utility measure in a parameter-free objective function. Camera utility goes beyond the concept of visual coverage of a target, and considers information theoretic measure of predicted estimation uncertainty capturing essential information from multi-view geometry of the camera network available via calibration. The assignment problem defined over the objective function is efficiently solved by a minimum cost flow method that exploits a graph encoding the structure of the function and occlusion constraints. Preliminary results have been published in conference proceedings [47,48].

The remainder of the paper is structured as follows. Section 2 gives a literature review of the related work. Section 3 presents the framework of our tracking method and how we decentralize the overall tracking task. Section 4 details how we implement dynamic task decomposition. In Section 5 we present comprehensive evaluation about the proposed algorithms by conducting a number of experiments and we draw conclusions in Section 6.

@&#RELATED WORK@&#

Visual tracking is a broad topic and has been studied for decades. While providing an exhaustive literature review is not possible, here we focus on the context of multi-camera multi-object tracking with overlapping fields of view (FOVs). We classify existing approaches into two main categories: centralized and distributed tracking approaches, and further divide the latter category roughly into three sub-categories: tracking-fusing approaches (i.e., each camera performs tracking independently and then the outputs from different cameras are fused), individually tracking approaches (i.e., each target is tracked separately) and group tracking approaches (i.e., targets are tracked in groups). A good related work discussion can also be found in [13].

These approaches track all the targets together in a centralized framework, whether they use Kalman filtering [32,33], particle filtering [34,39], or other methods such as a probabilistic occupancy map [35]. A major problem with these trackers is that they are not suitable for real time tracking in large, complex scenes where there are many people occluding each other. For example, the tracker proposed in [35] can track just up to six people according to the authors. The limited computational resources as well as system bandwidth within a camera network make it difficult for centralized trackers to track a large number of targets in real-time. Moreover, for particle filtering-based trackers, there is the curse of dimensionality as the number of targets goes up. Some approaches have been proposed to reduce computational cost and data flow, for example, by only evaluating high-quality particles [24] or dynamically deactivating some cameras [19]. Also some approaches are proposed to tackle the curse of dimensionality. [20,22] proposes a Hybrid Joint-Separable (HJS) filter, an approximate Bayesian tracker that propagates independent representations for each target with a joint likelihood to manage occlusions. The HJS filter has a computational complexity upperbound that grows quadratically (instead of exponentially as for the standard PF) with the number of targets. However, these approaches cannot solve the scalability problems with the centralized trackers in a fundamental way. As the number of targets and the number of cameras increase to a certain level, the performance of a centralized tracker (even the more efficient HJS filter) is likely to decline.

In order to perform reliable real-time tracking, balance system computational load and data flow, and thus enhance system scalability, we have to resort to a distributed tracking framework or a decentralized one (which can be seen as a special case of the distributed framework). Here we further divide these approaches into three sub-categories: tracking-fusing approaches, individually tracking approaches and group tracking approaches.

These approaches first track the targets in each camera independently, and then do a fusion of the tracking results. An representative approach is the in-network aggregation approach proposed in [16]. Each camera is assigned a set of particles and the posterior density is approximated separately using Gaussian Mixture Models (GMMs) whose order is selected by optimal matching according to KL-distance. Before sent to the base station, the mixture model parameters from different cameras are reduced using in-network aggregation to reduce communication overhead. Another example is the weighted average method proposed in [5], where targets are tracked by each camera independently and the belief of target states computed from each camera is fused with its neighboring cameras (cameras within a communication range) through a weighted average method. The belief weight for each camera is determined by its observation confidence and an occlusion indicator. Instead of using particle filtering as in [16,5], the Kalman-Consensus filter is employed by [17] in a Pan-tilt-zoom (PTZ) camera network which aims to selectively track certain targets at desired resolutions while keeping the entire area in view. Each camera works as an autonomous agents and has an embedded tracking module, a control module and a Kalman-Consensus filter which enables neighboring cameras to reach a consensus about the estimated states of the targets. Consensus is reached through point-to-point communications between neighboring cameras which are defined in dynamically generated topological graphs for each camera. The approaches [16,5,17] have the advantage of saving system bandwidth since every camera performs tracking independently (no image transfer is needed). However, these approaches require the cameras have processing power (i.e., smart cameras). Besides, the tracking performance of each camera is not guaranteed when there are a large number of people since it lacks 3D information about the scene, and consequently the results after fusion may be affected.

Typically these approaches assign the best camera(s) to each target and track each target independently [10,9,11,6]. An important issue is to design a camera utility function quantifying how well the camera(s) is able to track the object, which usually considers such factors as target orientation, resolution and distance from the camera. Another key issue is the assignment of cameras to targets, which can be modeled as a game [10,9], a market mechanism [7], a constraint satisfaction problem (CSP) [11], a distributed constraint satisfaction problem (DCSP) or even a Stable Marriage Problem [14], etc. A comparison of methods for camera selection and handoff can be found in [12]. More recently, [45] investigate the problem of online selection of monocular view sequence in calibrated camera network and derive an objective function for the quality of a view sequence given a task based on visual coverage and smoothness criterion. In this paper we go beyond the concept of visual coverage, and derive a solution for the many-to-many assignment problem in multi-target multi-camera tracking based on information theoretic criterion of predicted estimation quality induced by multi-view geometry.

While the methods [10,9,26,7,45] assign a single camera for each target, assigning multiple cameras to each target helps increase accuracy and robustness. Although we can assign all the cameras viewing the target to it, in practice not all cameras are equally need for the tracking task. Therefore we could instead select a subset of cameras for tracking each target, which may save computational resources and system bandwidth substantially. Tessens et al. [13] propose to select a subset of cameras for tracking each target independently in a distributed smart camera network. The selection of the subset is done by computing a suitability value which is based on the Dempster–Shafer (DS) theory of evidence. They also demonstrate that the reduction of observations does not decrease the performance. In [8], cameras are grouped into surveillance clusters to which surveillance tasks are allocated. The allocation problem is formulated as a distributed constraint satisfaction problem (DCSP) and solved by minimizing a cost function. In [23], a cluster-based Kalman filter approach is proposed. Once a new target is detected, cameras which can observe the same target communicate with each other to form a cluster and elect a cluster head. The cluster head aggregates all the local measurements of the target acquired by members of the cluster. The estimation of the target position is then made by the cluster head via Kalman filtering and is transmitted to a base station. Another example is the decentralized system composed of a number of hierarchical Fault Containment Units (FCUs) proposed in [15], where the target is tracked by an FCU comprised of a camera pair and is switched to another FCU in case of a tracking failure.

As discussed above, tracking all targets together in a centralized fashion is not suitable for tracking in complex scenes. On the other hand, tracking each target independently may suffer from the problem of hijacking, especially when there are serious occlusions among targets. The worst case is that the target is occluded in all views. If this continues for some time, the tracker is likely to fail. Therefore, a better choice would be to divide the targets into groups and track each group in a centralized way.

Most existing group tracking approaches [36–38] focus on the detection and evolving (merging, splitting, etc.) of groups. Here our goal is to track each target by dividing people into groups. Kembhavi et al. [18] propose to divide targets into interaction groups according to a similarity score and perform tracking with a joint filter for each group of targets. The approach helps circumvent the curse of dimensionality and performs better than using independent particle filters for each target or using a single joint filter. Most recently the decentralized particle filter [27] has been proposed to increase the level of parallelism for particle filtering and is used in [25] for joint tracking of individual targets and groups. However, the approaches [18,27] are built on single view tracking and thus are not suitable for tracking in complex scenes due to intrinsic uncertainties induced by occlusions and clutters. In this paper, we dynamically divide the targets into groups, each of which is tracked by an HJS filter [22] (a subtask). We divide targets into groups according to occlusion constraints (will be introduced later) not according to spatial proximity and appearance similarity among targets as in [18]. The reconfiguration of subtasks is managed by a supervisor process. Our tracking system is hereby decentralized, which has the advantage of less fusion information as compared to distributed ones [29].

The application scenario addressed in this paper suggests the choice of a probabilistic framework, since measurements may convey intrinsic uncertainty which cannot be eliminated due to occlusion, target similarity and background clutter. Besides, for efficiency reasons, illumination effects (e.g. shadows) are neglected and only coarse shape and appearance models can be used, leading to a noisy measurement process. Estimates are therefore inherently inaccurate and a deterministic framework would not adequately account for this.

In this paper, object tracking is interpreted as a state estimation problem. The dynamic components of interest of the monitored environment are described with a vector x of numbers, the state, which is evolving in continuous time and observed at discrete time instants t through a measurement vector 
                           
                              
                                 
                                    z
                                 
                                 
                                    t
                                 
                              
                           
                        . More specifically, in this paper the state is composed of the target’s 2D positions on the ground plane. The aim is then to estimate its posterior distribution 
                           
                              p
                              (
                              
                                 
                                    x
                                 
                                 
                                    t
                                 
                              
                              |
                              
                                 
                                    z
                                 
                                 
                                    1
                                    :
                                    t
                                 
                              
                              )
                           
                         at t conditioned on a sequence of observations 
                           
                              
                                 
                                    z
                                 
                                 
                                    1
                                    :
                                    t
                                 
                              
                           
                         obtained up to t. In order to support sequential estimation imposed by real time applications, signal 
                           
                              
                                 
                                    x
                                 
                                 
                                    t
                                 
                              
                           
                         is modeled as a first order Markov process, and observations 
                           
                              
                                 
                                    z
                                 
                                 
                                    1
                                    :
                                    t
                                 
                              
                           
                         are assumed to be conditionally independent given a sequence of states 
                           
                              
                                 
                                    x
                                 
                                 
                                    1
                                    :
                                    t
                                 
                              
                           
                        . This enables us to compute a new estimate 
                           
                              p
                              (
                              
                                 
                                    x
                                 
                                 
                                    t
                                 
                              
                              |
                              
                                 
                                    z
                                 
                                 
                                    1
                                    :
                                    t
                                 
                              
                              )
                           
                         from the actual observation 
                           
                              
                                 
                                    z
                                 
                                 
                                    t
                                 
                              
                           
                         and its previous estimate 
                           
                              p
                              (
                              
                                 
                                    x
                                 
                                 
                                    t
                                    -
                                    1
                                 
                              
                              |
                              
                                 
                                    z
                                 
                                 
                                    1
                                    :
                                    t
                                    -
                                    1
                                 
                              
                              )
                           
                         using stochastic propagation and Bayes law
                           
                              
                                 p
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       t
                                    
                                 
                                 |
                                 
                                    
                                       z
                                    
                                    
                                       1
                                       :
                                       t
                                    
                                 
                                 )
                                 ∝
                                 p
                                 (
                                 
                                    
                                       z
                                    
                                    
                                       t
                                    
                                 
                                 |
                                 
                                    
                                       x
                                    
                                    
                                       t
                                    
                                 
                                 )
                                 ∫
                                 p
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       t
                                    
                                 
                                 |
                                 
                                    
                                       x
                                    
                                    
                                       t
                                       -
                                       1
                                    
                                 
                                 )
                                 p
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       t
                                       -
                                       1
                                    
                                 
                                 |
                                 
                                    
                                       z
                                    
                                    
                                       1
                                       :
                                       t
                                       -
                                       1
                                    
                                 
                                 )
                                 
                                    
                                       dx
                                    
                                    
                                       t
                                       -
                                       1
                                    
                                 
                              
                           
                        
                     

Due to the highly non-linear relation between the targets’ ground positions 
                           
                              
                                 
                                    x
                                 
                                 
                                    t
                                 
                              
                           
                         and the resulting image measurements 
                           
                              
                                 
                                    z
                                 
                                 
                                    t
                                 
                              
                           
                        , especially under occlusion, the resulting posteriors 
                           
                              p
                              (
                              
                                 
                                    x
                                 
                                 
                                    t
                                 
                              
                              |
                              
                                 
                                    z
                                 
                                 
                                    1
                                    :
                                    t
                                 
                              
                              )
                           
                         are complex and no closed form solution is available for computing the recursion above. In such cases, sampling methods such as particle filtering [3] can be used effectively in combination with generic non-parametric likelihood models to propagate a sample based representation of the posteriors, e.g., for color based tracking [1,2]. However, since the number of samples (particles) required to properly represent generic posteriors increases exponentially with the size of x, i.e., with the number of targets, a fully joint formulation of the multi target problem becomes computationally prohibitively expensive even with a moderate number of targets. To break this curse-of-dimension under explicit occlusion reasoning, the Hybrid Joint-Separable (HJS) model has been proposed for color-based tracking [22], where instead of a fully joint representation of 
                           
                              p
                              (
                              
                                 
                                    x
                                 
                                 
                                    t
                                 
                              
                              |
                              
                                 
                                    z
                                 
                                 
                                    1
                                    :
                                    t
                                 
                              
                              )
                           
                        , the marginals for each target are propagated over time resulting in a computational complexity with quadratic upper-bound in the number of tracked targets, instead of exponential. We use [22] as the baseline tracking framework with systematic occlusion handling in this work.

The task of monitoring a large environment may be formalized as a single, joint state estimation problem. However, it is easy to imagine that applying this to real time monitoring in real world scenarios such as the one depicted in Fig. 10 where many people interact in a large, unstructured environment, may be unaffordable even with the aforementioned HJS tracking. Rather than attempt to track all people with a single HJS filter in a centralized fashion, a more feasible solution would be to instantiate several sub-filters with reduced, local competence (e.g. by dividing targets into groups associated with subsets of cameras in which they are best observable) which together may perform more efficiently not only in terms of overall computational complexity, but also in terms of real time behavior (different sub-filters could be executed on different processing units) as well as data flow management (image transfer could be routed intelligently in a distributed implementation).

From a theoretical point of view it is easy to show that tracking with independent sub-filters is exact when dynamical model 
                           
                              p
                              (
                              
                                 
                                    x
                                 
                                 
                                    t
                                 
                              
                              |
                              
                                 
                                    x
                                 
                                 
                                    t
                                    -
                                    1
                                 
                              
                              )
                           
                         and observation model 
                           
                              p
                              (
                              
                                 
                                    z
                                 
                                 
                                    t
                                 
                              
                              |
                              
                                 
                                    x
                                 
                                 
                                    t
                                 
                              
                              )
                           
                         factorize over the chosen set of camera-target associations, i.e., if 
                           
                              
                                 
                                    a
                                 
                                 
                                    i
                                 
                              
                           
                         is the subset of cameras (which we call an agency in the following) used to track a group of targets 
                           
                              
                                 
                                    g
                                 
                                 
                                    i
                                 
                              
                           
                         we have
                           
                              (1)
                              
                                 p
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       t
                                    
                                 
                                 |
                                 
                                    
                                       x
                                    
                                    
                                       t
                                       -
                                       1
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       
                                          ∏
                                       
                                       
                                          
                                             
                                                g
                                             
                                             
                                                i
                                             
                                          
                                       
                                    
                                 
                                 p
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       t
                                    
                                    
                                       
                                          
                                             g
                                          
                                          
                                             i
                                          
                                       
                                    
                                 
                                 |
                                 
                                    
                                       x
                                    
                                    
                                       t
                                       -
                                       1
                                    
                                    
                                       
                                          
                                             g
                                          
                                          
                                             i
                                          
                                       
                                    
                                 
                                 )
                                 ,
                                 
                                 p
                                 (
                                 
                                    
                                       z
                                    
                                    
                                       t
                                    
                                 
                                 |
                                 
                                    
                                       x
                                    
                                    
                                       t
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       
                                          ∏
                                       
                                       
                                          {
                                          
                                             
                                                a
                                             
                                             
                                                i
                                             
                                          
                                          ,
                                          
                                             
                                                g
                                             
                                             
                                                i
                                             
                                          
                                          }
                                       
                                    
                                 
                                 p
                                 (
                                 
                                    
                                       z
                                    
                                    
                                       t
                                    
                                    
                                       
                                          
                                             a
                                          
                                          
                                             i
                                          
                                       
                                    
                                 
                                 |
                                 
                                    
                                       x
                                    
                                    
                                       t
                                    
                                    
                                       
                                          
                                             g
                                          
                                          
                                             i
                                          
                                       
                                    
                                 
                                 )
                              
                           
                        
                     

While assuming independence among the motion patterns of targets may be acceptable at least for short predictions (the Bayes filter is first order in time), this is certainly not true for the observation model when people arrange in groups causing frequent and persistent occlusions. Under occlusion, the appearance of one target cannot but be explained in relation to that of the occluder, which requires therefore a joint analysis of captured images. On the other hand, the same scene may be seen occlusion-free from another viewpoint where indeed the resulting image can be elaborated independently for locating each target, thus, at lower computational cost and in parallel. This is the key observation leading to our task decomposition algorithm described in the next section: given known view geometry (camera calibration) and the targets’ estimated positions provided online by tracking, we determine (and continuously update) camera-target associations that maximize parallelization while guaranteeing consistent occlusion handling.


                        Fig. 2
                         gives an overview of the overall tracking system architecture supported by the proposed task decomposition framework. HJS base trackers are implemented by two types of processes: (i) HJS particle filter (PF) process implements stochastic propagation with an MRF collision avoidance dynamical model [22], and (ii) HJS likelihood process is connected to a specific camera and receives a set of propagated particles from a PF process, computes their HJS likelihoods [22] utilizing a color model for each target extracted automatically from images upon detection, and sends them back to the HJS PF for multi-view Bayesian integration and resampling. The HJS likelihood computation has a complexity that scales quadratically with the number of occluding targets, and is the computationally most demanding process. There can be several HJS likelihood process instances connected to the same camera serving different HJS PFs. All HJS likelihood processes can run in parallel
                           1
                           We use parallel HJS likelihood processes even with the centralized HJS PF experiments in Section 5.4.
                        
                        
                           1
                         as they are based on conditionally independent models given the predicted particles computed by the HJS PFs (this is a common assumption in multi-camera tracking and, further, a valid assumption given occlusion reasoning in the task decomposition method, Section 4.2). Detection of new targets is assumed to be carried out by an external multi-view people detection process, and in our implementation we use the motion-based method in [43] that utilizes the current estimates to allocate computations to, and only when, observations not explained by tracked targets, consequently, avoiding multiple detections of the same target. Detector signals the presence of a new target to the global task decomposition process. At a fixed frequency (3Hz in our experiments), the decomposition process receives the current tracking estimates from the HJS PFs, computes the new decomposition and, if required, sends reconfiguration instructions to the HJS PFs, i.e., which HJS likelihood processes each HJS PF can use for tracking.

While the proposed task decomposition framework can leverage on distributed processing using existing CCTV infrastructure (Fig. 2, left), interesting opportunities arise with next-generation smart cameras that are expected to provide high-performance front-ends to run dedicated embedded applications. Our experiments are based on a simulated smart camera environment (Fig. 2, right) where all HJS likelihood processes are executed on-board the camera and image transfer over the network is avoided. This definitely overcomes the scalability issue due to bandwidth requirements in centralized approaches to monitoring large environments. At the same time, it opens up new research directions for computer vision previously explored in sensor networks, such as how to optimize load distribution in camera networks with local processing power [44].

As mentioned in the previous section, a principled approach to distributed tracking may be derived by exploring dependency relations among environment dynamics (target trajectories) and measurements (utilized cameras). While such dependencies may appear in many different facets (group behavior, illumination effects such as shadows), the most essential one arises from occlusions. The approach proposed next accounts for this, providing a solution derived from knowledge about camera placement and estimated target positions under given constraints.

An example is shown in Fig. 3
                        : four targets have to be tracked with three cameras. Since all four targets may be visible in all three cameras, a trivial solution is to instantiate a single task equipped with all three cameras. However, closeness of targets B, C and D suggests that they should be grouped together, whereas target A might be handled separately. This can be derived from occlusion reasoning. The closeness of targets B, C and D indicates potential occlusions among them in all the three views within a certain time interval, as can be seen from the intersecting dashed red circles. Due to the potential occlusions, target B, C and D should be tracked together. With this division, no occlusions between target A and group (B, C, D) are allowed, a feature that depends on the relative placement of selected cameras. Camera 1 observes (B, C, D) occluded by A and can therefore not be used to track (B, C, D) only (i.e., if camera 1 is used to track (B, C, D), it must also track A at the same time). On the other hand, camera 1 could take care of tracking A only as (B, C, D) are visible but do not influence on the appearance of A. Cameras 2 and 3 could all be associated to both (A) and (B, C, D) as there are no occlusions among them. An appropriate choice would then instantiate two subtasks,
                           
                              
                                 
                                    
                                       Sub
                                    
                                    
                                       1
                                    
                                 
                                 =
                                 
                                    
                                       
                                          (
                                          A
                                          )
                                          ,
                                          (
                                          1
                                          ,
                                          2
                                          ,
                                          3
                                          )
                                       
                                    
                                 
                                 
                                 and
                                 
                                 
                                    
                                       Sub
                                    
                                    
                                       2
                                    
                                 
                                 =
                                 
                                    
                                       
                                          (
                                          B
                                          ,
                                          C
                                          ,
                                          D
                                          )
                                          ,
                                          (
                                          2
                                          ,
                                          3
                                          )
                                       
                                    
                                 
                              
                           
                        It can be concluded that grouping purely based on target proximity is not sufficient to find feasible subtasks and view geometry needs to be taken into account in the definition of subtasks: indeed, in Fig. 3 the circle of Target A does not overlap with any of B, C, D but nonetheless, camera 1 cannot be used to track (B, C, D) alone because A can occlude B, C or D, i.e., the independence assumption in Eq. (1) is violated.

This solution does not consider constraints about resources. In practice, we may have requirements about (1) the minimum number of cameras in an agency to ensure tracking performance; (2) maximum number of cameras in an agency for computational overhead consideration; (3) maximum number of agencies (which should not be larger than the number of targets) to ensure there are enough available processing units for every subtask to be mapped into. Besides, this solution is only the snapshot configuration in Fig. 3. Task decomposition cannot be carried out with a frequency comparable to the observation rate. A lower rate may be employed while accounting for potential occlusions within a given time interval. To sum up, a task decomposition algorithm must be able to: (1) detect potential interactions (i.e., occlusions) among targets, and (2) reason about efficiency (or cost) and suitability of a possible allocation, which will be detailed in the next sections.

As outlined in Section 3.2, the allocation of a set of agencies remains sustainable as long as the measurement model remains separable over the set of positions (or supports) that can be reached from the current estimates within a given time window. Verifying this at full resolution is not required: we may limit ourselves to detect potential occlusions while reasoning on the ground (on a 2D world observed with linear cameras).

To compute each targets’ support for occlusion reasoning on a given time interval one can use the dynamical model 
                           
                              p
                              (
                              
                                 
                                    x
                                 
                                 
                                    t
                                 
                              
                              |
                              
                                 
                                    x
                                 
                                 
                                    t
                                    -
                                    1
                                 
                              
                              )
                           
                         and stochastic propagation (see Section 3.1). To further reduce complexity, we can instead approximate the current estimate by a circular support centered around the estimated target position, i.e., around the MAP maximum a posteriori particle. Its predicted support is then obtained as the envelope of all the positions that can be reached within a time span at a predefined maximal velocity. This corresponds to drawing a circle around the current position with a radius equal to the product of maximum velocity and time span (the dashed red circles in Fig. 3). To detect potential occlusion in each view, we draw a circle around the camera viewpoint and project the support outline of each target to the circle. If the projection of outlines has intersection, then occlusion is detected (Fig. 4
                        ).

Since in most cases there are many feasible solutions for grouping cameras and targets and associating them to form subtasks even given a number of constraints, we need to quantify the cost for each configuration. The optimal solution is the one with lowest cost.

Efficient task allocation relies on the choice of an appropriate function to quantify the cost. It should account for computational load as well as for sensing and networking issues. While possible solutions to the latter issue in the context of active vision were preliminary investigated by the authors in [28], in this paper the focus is on the computational and sensing aspects. When we split a joint filter into agencies with competence on a subset of 
                           
                              
                                 
                                    K
                                 
                                 
                                    i
                                 
                              
                           
                         targets, the computational complexity reduces from 
                           
                              
                                 
                                    (
                                    ∑
                                    
                                       
                                          K
                                       
                                       
                                          i
                                       
                                    
                                    )
                                 
                                 
                                    2
                                 
                              
                           
                         to 
                           
                              ∑
                              
                                 
                                    K
                                 
                                 
                                    i
                                 
                                 
                                    2
                                 
                              
                           
                         with HJS particle filtering (in the case of joint base trackers from 
                           
                              
                                 
                                    e
                                 
                                 
                                    ∑
                                    
                                       
                                          K
                                       
                                       
                                          i
                                       
                                    
                                 
                              
                           
                         to 
                           
                              ∑
                              
                                 
                                    e
                                 
                                 
                                    
                                       
                                          K
                                       
                                       
                                          i
                                       
                                    
                                 
                              
                           
                        ). Beyond complexity, another factor that impacts on tracking performance is the number and spatial distribution of associated cameras. A higher number guarantees better visual coverage, but at the increased cost of analyzing more images (besides, power consumption and networking load due to image transfer). Two cameras that observe the same target from orthogonal directions convey more information about its position than two parallel or anti-parallel cameras do. Also, a target may be observed (partially) occluded in one view but maybe free of occlusion in another view, and the amount of information about its position that can be provided by different cameras may vary significantly even if occlusions are handled properly as in HJS tracking.

To account for all these factors in defining the camera utility component of the cost function, we combine the imaging geometry of an agency available with calibration with a generative model of object observation to predict the estimation uncertainty associated with localizing a subset of targets with the subset of cameras composing the agency. Interestingly, this allows establishing a link to the computational complexity component of the cost function via information theory, and we obtain a parameter-free cost function to be minimized for optimal task decomposition, which can be transformed into a graph-based assignment problem efficiently solved by a minimum cost flow method.

To do so, we perform three steps: first, we generate predicted observations of the targets in the different views based on given MAP ground positions provided by tracking; then, we estimate probabilistic ground occupancy maps from those predicted observations; and, finally, we compute the entropy of such ground occupancy maps to evaluate camera utility for each target.

We generate observations by projecting a coarse 3D shape model placed at the targets’ MAP ground position to each camera. This projection results in the generation of the outline of the projected 3D shape for the considered view. For each camera, these projections are done in order, from the closest target to the farthest. When an occlusion is detected in the projection, i.e., when an outline pixel falls within the silhouette of an already visited target, instead of retaining that pixel for the outline, we sample a new pixel randomly within the occluding objects’ silhouette (see Fig. 5
                           ). In this way we consistently inject noise in the generated observations induced by occlusion, which results in occupancy uncertainty and, consequently, in a penalization of the camera utility value (see Fig. 13(f)).

The synthetic contours generated this way for each camera in the agency can be back-projected to probabilistic ground occupancy maps by the method in [21]. The method implements a generalized-Hough like transform to back-project object contours to ground occupancy under a 3D rigid shape model hypothesis,
                              2
                              More precisely, the same 3D shape model is used for generating predicted observations (4.3.1) and back-projecting them to ground occupancy maps (4.3.2), as well as for detection [43] and color likelihood computation with the HJS base trackers [22].
                           
                           
                              2
                            combined with a kernel density estimation on the ground to accumulate evidence from the different views.
                              3
                              The method [21] was originally proposed for detection in multi-camera environment (indeed we use a previous version [43] of it for detection in the experiments): apparent motion extracted via frame differencing is used to generate ground occupancy maps of moving people under a 3D shape model hypothesis. Detection occurs when a peak above threshold is detected in the map. For the purpose of estimating camera utility, we use the outlines of 3D shape projections (4.3.1) instead of apparent motion to generate the maps.
                           
                           
                              3
                            The kernel bandwidth hereby accounts for inaccuracies induced due to modeling people with a 3D rigid shape. Further in the context of estimating agency utility, we can adapt the bandwidth to consider other uncertainty sources such as prediction time of stochastic propagation and length of time interval for which a decomposition is assumed to be valid, as well as for inaccurate calibration and poor frame synchronization across views as observed in PETS_2009_S2_L1 multi-view dataset (see experiment Section 5.4.3). Fig. 5 sketches the ground occupancy map generation process.

Important to note here that the above generation of ground occupancy maps from synthetized observations relies on a calibrated model of multi-view imaging process, and inherits all uncertainty modes induced by the imaging process associated with the agency and the relative locations of the targets to be assigned to it. These include distortions due to perspective and occlusion, and even the resolution with which observations and occupancy maps are rendered. The effect of these on the ground occupancy can be observed in Fig. 5.

From occupancy maps it is straightforward to compute, for each target 
                              
                                 
                                    
                                       t
                                    
                                    
                                       j
                                    
                                 
                              
                           , the entropy 
                              
                                 H
                                 (
                                 
                                    
                                       t
                                    
                                    
                                       j
                                    
                                 
                                 |
                                 
                                    
                                       a
                                    
                                    
                                       i
                                    
                                 
                                 )
                              
                            as a principled measure of predicted localization uncertainty under agency 
                              
                                 
                                    
                                       a
                                    
                                    
                                       i
                                    
                                 
                              
                           . Further, the relation of entropy to the volume of the high probability regions in the occupancy map (its typical set) is formalized by the Asymptotic Equipartition Property theorem [40]. In [41] this relation has been exploited for adapting the number of particles to be propagated over time by a particle filter to estimation uncertainty: the number of i.i.d. samples (particles) to consistently represent an estimate with entropy H is 
                              
                                 N
                                 =
                                 ρ
                                 
                                    
                                       e
                                    
                                    
                                       H
                                    
                                 
                              
                            where ρ is a constant density number of particles per unit (e.g. 
                              
                                 ρ
                                 =
                                 20
                                 ×
                                 20
                                 =
                                 400
                              
                            particles per square-meter). The computational cost for HJS particle filtering with adaptive sample size becomes then 
                              
                                 ρ
                                 
                                    
                                       ∑
                                    
                                    
                                       {
                                       
                                          
                                             a
                                          
                                          
                                             j
                                          
                                       
                                       ,
                                       
                                          
                                             g
                                          
                                          
                                             j
                                          
                                       
                                       }
                                    
                                 
                                 
                                    
                                       K
                                    
                                    
                                       j
                                    
                                 
                                 
                                    
                                       ∑
                                    
                                    
                                       
                                          
                                             t
                                          
                                          
                                             i
                                          
                                       
                                       ∈
                                       
                                          
                                             g
                                          
                                          
                                             j
                                          
                                       
                                    
                                 
                                 
                                    
                                       e
                                    
                                    
                                       H
                                       (
                                       
                                          
                                             t
                                          
                                          
                                             i
                                          
                                       
                                       |
                                       
                                          
                                             a
                                          
                                          
                                             j
                                          
                                       
                                       )
                                    
                                 
                              
                            with 
                              
                                 
                                    
                                       K
                                    
                                    
                                       j
                                    
                                 
                                 =
                                 Card
                                 (
                                 
                                    
                                       g
                                    
                                    
                                       j
                                    
                                 
                                 )
                              
                            denoting the cardinality of target set 
                              
                                 
                                    
                                       g
                                    
                                    
                                       j
                                    
                                 
                              
                           .
                              4
                              In HJS tracking with K occluding targets, for every particle, the likelihood is computed from K evaluations which is the dominating computational cost.
                           
                           
                              4
                            Since our base trackers operate with fixed number 
                              
                                 
                                    
                                       N
                                    
                                    
                                       0
                                    
                                 
                              
                            of particles, after algebraic steps we can conveniently split this function into a sum of two terms
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         N
                                                      
                                                      
                                                         0
                                                      
                                                   
                                                   
                                                      
                                                         ∑
                                                      
                                                      
                                                         
                                                            
                                                               g
                                                            
                                                            
                                                               j
                                                            
                                                         
                                                      
                                                   
                                                   Card
                                                   
                                                      
                                                         (
                                                         
                                                            
                                                               g
                                                            
                                                            
                                                               j
                                                            
                                                         
                                                         )
                                                      
                                                      
                                                         2
                                                      
                                                   
                                                
                                                
                                                   ︸
                                                
                                             
                                          
                                          
                                             HJS
                                             
                                             complexity
                                          
                                       
                                    
                                    +
                                    
                                       
                                          
                                             
                                                
                                                   ρ
                                                   
                                                      
                                                         ∑
                                                      
                                                      
                                                         {
                                                         
                                                            
                                                               a
                                                            
                                                            
                                                               j
                                                            
                                                         
                                                         ,
                                                         
                                                            
                                                               g
                                                            
                                                            
                                                               j
                                                            
                                                         
                                                         }
                                                      
                                                   
                                                   Card
                                                   (
                                                   
                                                      
                                                         g
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                   )
                                                   
                                                      
                                                         ∑
                                                      
                                                      
                                                         
                                                            
                                                               t
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                         ∈
                                                         
                                                            
                                                               g
                                                            
                                                            
                                                               j
                                                            
                                                         
                                                      
                                                   
                                                   (
                                                   
                                                      
                                                         e
                                                      
                                                      
                                                         H
                                                         (
                                                         
                                                            
                                                               t
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                         |
                                                         
                                                            
                                                               a
                                                            
                                                            
                                                               j
                                                            
                                                         
                                                         )
                                                      
                                                   
                                                   -
                                                   
                                                      
                                                         e
                                                      
                                                      
                                                         
                                                            
                                                               H
                                                            
                                                            
                                                               0
                                                            
                                                         
                                                      
                                                   
                                                   )
                                                
                                                
                                                   ︸
                                                
                                             
                                          
                                          
                                             camera
                                             
                                             utility
                                             
                                             term
                                          
                                       
                                    
                                 
                              
                           where 
                              
                                 
                                    
                                       e
                                    
                                    
                                       
                                          
                                             H
                                          
                                          
                                             0
                                          
                                       
                                    
                                 
                                 =
                                 
                                    
                                       N
                                    
                                    
                                       0
                                    
                                 
                                 /
                                 ρ
                              
                           . The first term is the computational cost of HJS base trackers (i.e., of the real computations performed with tracking), while the second term accounts for additional computations if the particle size is adapted to estimation uncertainty, which depends on the chosen set of cameras (agencies) observing the targets. While this second term is derived from computational cost, these computations are never executed but instead counted for the purpose of penalizing decompositions that result in predicted uncertainty that cannot be coped with using the constant number of particles of base trackers. Therefore, without impairing the effectiveness of the cost function, we can introduce two modifications to the camera utility term.
                              
                                 •
                                 We lower-bound the difference 
                                       
                                          
                                             
                                                e
                                             
                                             
                                                H
                                                (
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      i
                                                   
                                                
                                                |
                                                
                                                   
                                                      a
                                                   
                                                   
                                                      j
                                                   
                                                
                                                )
                                             
                                          
                                          -
                                          
                                             
                                                e
                                             
                                             
                                                
                                                   
                                                      H
                                                   
                                                   
                                                      0
                                                   
                                                
                                             
                                          
                                       
                                     in the inner summation to 0; this is equivalent to lower-bounding the minimum number of particles in the adaptation to 
                                       
                                          
                                             
                                                N
                                             
                                             
                                                0
                                             
                                          
                                       
                                    . Indeed, 
                                       
                                          
                                             
                                                N
                                             
                                             
                                                0
                                             
                                          
                                       
                                     particles are always used by the base trackers and this way we ignore negative contributions from ‘virtual savings’ when less particles would suffice. If not ignored, these negative contributions could compensate for higher predicted uncertainty of other targets, leading to sub-optimal decompositions.

We replace the summation weights 
                                       
                                          Card
                                          (
                                          
                                             
                                                g
                                             
                                             
                                                j
                                             
                                          
                                          )
                                       
                                     with 1; this is equivalent to changing the cost of additional particles to standard particle filtering cost, i.e., particle filtering without explicit occlusion handling. Note that we already take into account potential occlusions in the generation of ground occupancy maps, thus, in the entropy estimation used for computing the utility term. Most importantly, keeping these weights independent of groupings 
                                       
                                          
                                             
                                                g
                                             
                                             
                                                j
                                             
                                          
                                       
                                     allows us to avoid exhaustively searching for the minimum cost solution that would introduce a scalability issue (see also Fig. 11), instead, we can solve for task decomposition efficiently with the cost flow method in Section 4.5.

With these modifications, the cost function for task decomposition is
                              
                                 (2)
                                 
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             
                                                
                                                   g
                                                
                                                
                                                   j
                                                
                                             
                                          
                                       
                                    
                                    Card
                                    
                                       
                                          (
                                          
                                             
                                                g
                                             
                                             
                                                j
                                             
                                          
                                          )
                                       
                                       
                                          2
                                       
                                    
                                    +
                                    
                                       
                                          ρ
                                       
                                       
                                          
                                             
                                                N
                                             
                                             
                                                0
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             
                                                
                                                   t
                                                
                                                
                                                   i
                                                
                                             
                                          
                                       
                                    
                                    
                                       max
                                    
                                    
                                       
                                          
                                             0
                                             ,
                                             
                                                
                                                   e
                                                
                                                
                                                   H
                                                   (
                                                   
                                                      
                                                         t
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   |
                                                   
                                                      
                                                         a
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                   )
                                                
                                             
                                             -
                                             
                                                
                                                   e
                                                
                                                
                                                   
                                                      
                                                         H
                                                      
                                                      
                                                         0
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           To further elaborate on its information theoretic grounding, in Fig. 6
                            we give an alternative interpretation of camera utility defined this way, in terms of Bayes risk minimization of tracking failure.

A trivial solution for finding the best configuration of agencies and targets is through exhaustive search. Although the numbers of possible partitions of cameras and targets grow exponentially, it is computationally tractable when there are not too many cameras or targets. Let us denote the number of cameras by 
                           
                              
                                 
                                    N
                                 
                                 
                                    c
                                 
                              
                           
                        , the number of targets by 
                           
                              
                                 
                                    N
                                 
                                 
                                    t
                                 
                              
                           
                        , the maximum number of agencies by 
                           
                              
                                 
                                    MAX
                                 
                                 
                                    a
                                 
                              
                           
                        , the minimum and maximum number of cameras each agency can have by 
                           
                              
                                 
                                    MIN
                                 
                                 
                                    c
                                 
                              
                           
                         and 
                           
                              
                                 
                                    MAX
                                 
                                 
                                    c
                                 
                              
                           
                        . The idea is first to partition the camera set 
                           
                              {
                              
                                 
                                    C
                                 
                                 
                                    11
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    C
                                 
                                 
                                    1
                                    
                                       
                                          M
                                       
                                       
                                          1
                                       
                                    
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    C
                                 
                                 
                                    i
                                    1
                                 
                              
                              …
                              
                                 
                                    C
                                 
                                 
                                    
                                       
                                          iM
                                       
                                       
                                          i
                                       
                                    
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    C
                                 
                                 
                                    
                                       
                                          N
                                       
                                       
                                          c
                                       
                                    
                                    1
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    C
                                 
                                 
                                    
                                       
                                          N
                                       
                                       
                                          c
                                       
                                    
                                    
                                       
                                          M
                                       
                                       
                                          
                                             
                                                N
                                             
                                             
                                                c
                                             
                                          
                                       
                                    
                                 
                              
                              }
                           
                         to generate agencies (subsets of cameras), and partition the target set 
                           
                              {
                              
                                 
                                    t
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    t
                                 
                                 
                                    2
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    t
                                 
                                 
                                    
                                       
                                          N
                                       
                                       
                                          t
                                       
                                    
                                 
                              
                              }
                           
                         to generate groups of targets, where 
                           
                              
                                 
                                    C
                                 
                                 
                                    i
                                    1
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    C
                                 
                                 
                                    
                                       
                                          iM
                                       
                                       
                                          i
                                       
                                    
                                 
                              
                           
                         are the multiple copies of camera 
                           
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                              
                           
                         and 
                           
                              
                                 
                                    M
                                 
                                 
                                    i
                                 
                              
                              (
                              i
                              =
                              1
                              ,
                              …
                              ,
                              
                                 
                                    N
                                 
                                 
                                    c
                                 
                              
                              )
                           
                         is the maximum number of agencies camera 
                           
                              
                                 
                                    C
                                 
                                 
                                    i
                                 
                              
                           
                         can be assigned to (we introduce multiple copies to allow each camera to be assigned to more than one agency). Camera partitions that do not meet the constraints of 
                           
                              
                                 
                                    MAX
                                 
                                 
                                    a
                                 
                              
                              ,
                              
                              
                                 
                                    MIN
                                 
                                 
                                    c
                                 
                              
                           
                         and 
                           
                              
                                 
                                    MAX
                                 
                                 
                                    c
                                 
                              
                           
                         should be precluded. In this way, we get a camera partition set 
                           
                              
                                 
                                    S
                                 
                                 
                                    c
                                 
                              
                           
                         and a target partition set 
                           
                              
                                 
                                    S
                                 
                                 
                                    t
                                 
                              
                           
                        . Each camera partition contains a set of agencies and each target partition contains a set of target groups. Then for each camera partition and each target partition we enumerate all the possible configurations of subtasks (combinations of agencies and target groups) and check whether they meet our required occlusion constraint. If so, compute the cost according to Eq. (2). Finally the configuration with the least cost is selected. In practice, the partitions of cameras and targets and the combinations of agencies and target groups can be computed offline and stored in a lookup table.

Finding the optimal task decomposition solution can be modeled as an assignment problem [42] that we map into a minimum-cost flow problem [30]. First, the set of partitions of available cameras is computed as in Section 4.4. Each partition P consists of a set of 
                           
                              
                                 
                                    N
                                 
                                 
                                    a
                                 
                              
                           
                         agencies 
                           
                              A
                              =
                              {
                              
                                 
                                    a
                                 
                                 
                                    1
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    a
                                 
                                 
                                    
                                       
                                          N
                                       
                                       
                                          a
                                       
                                    
                                 
                              
                              }
                           
                        . The problem is to find a surjective mapping M from the set 
                           
                              T
                              =
                              {
                              
                                 
                                    t
                                 
                                 
                                    1
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    t
                                 
                                 
                                    
                                       
                                          N
                                       
                                       
                                          t
                                       
                                    
                                 
                              
                              }
                           
                         of targets to the set of agencies:
                           
                              
                                 M
                                 :
                                 T
                                 →
                                 A
                              
                           
                        which minimizes the cost function (2) which can be rewritten in the following way:
                           
                              
                                 
                                    
                                       
                                          min
                                       
                                       
                                          M
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   
                                                      
                                                         a
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                   ∈
                                                   A
                                                
                                             
                                          
                                          
                                          Card
                                          
                                             
                                                (
                                                
                                                   
                                                      M
                                                   
                                                   
                                                      -
                                                      1
                                                   
                                                
                                                (
                                                
                                                   
                                                      a
                                                   
                                                   
                                                      j
                                                   
                                                
                                                )
                                                )
                                             
                                             
                                                2
                                             
                                          
                                          +
                                          
                                             
                                                ρ
                                             
                                             
                                                
                                                   
                                                      N
                                                   
                                                   
                                                      0
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   
                                                      
                                                         t
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   ∈
                                                   T
                                                
                                             
                                          
                                          
                                             max
                                          
                                          
                                             
                                                
                                                   0
                                                   ,
                                                   
                                                      
                                                         e
                                                      
                                                      
                                                         H
                                                         (
                                                         
                                                            
                                                               t
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                         |
                                                         M
                                                         (
                                                         
                                                            
                                                               t
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                         )
                                                         )
                                                      
                                                   
                                                   -
                                                   
                                                      
                                                         e
                                                      
                                                      
                                                         
                                                            
                                                               H
                                                            
                                                            
                                                               0
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                                 .
                              
                           
                        For each partition we construct a weighted network whose minimum cost flow allows computation of the best mapping M. A weighted network 
                           
                              N
                              =
                              (
                              V
                              ,
                              E
                              ,
                              cap
                              ,
                              cost
                              )
                           
                         consists of a directed graph 
                           
                              G
                              =
                              (
                              V
                              ,
                              E
                              )
                           
                        , a capacity function 
                           
                              cap
                              :
                              E
                              →
                              
                                 
                                    R
                                 
                                 
                                    +
                                 
                              
                           
                         and a cost function 
                           
                              cost
                              :
                              E
                              →
                              R
                           
                        . The set of vertices 
                           
                              V
                              =
                              {
                              s
                              ,
                              t
                              ,
                              
                                 
                                    B
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    B
                                 
                                 
                                    2
                                 
                              
                              }
                              ∪
                              
                                 
                                    V
                                 
                                 
                                    t
                                 
                              
                              ∪
                              
                                 
                                    V
                                 
                                 
                                    a
                                 
                              
                              ∪
                              
                                 
                                    V
                                 
                                 
                                    s
                                 
                              
                           
                         is composed of two special vertices, the source s and the sink t, two nodes 
                           
                              
                                 
                                    B
                                 
                                 
                                    1
                                 
                              
                           
                         and 
                           
                              
                                 
                                    B
                                 
                                 
                                    2
                                 
                              
                           
                         that constrain the map to be surjective, and the following three subsets (see Fig. 7
                        ):
                           
                              
                                 
                                    
                                       
                                          
                                             V
                                          
                                          
                                             t
                                          
                                       
                                       =
                                       {
                                       
                                          
                                             T
                                          
                                          
                                             i
                                          
                                       
                                       |
                                       i
                                       =
                                       1
                                       …
                                       
                                          
                                             N
                                          
                                          
                                             t
                                          
                                       
                                       }
                                    
                                  a set of 
                                    
                                       
                                          
                                             N
                                          
                                          
                                             t
                                          
                                       
                                    
                                  vertices corresponding to the targets;


                                 
                                    
                                       
                                          
                                             V
                                          
                                          
                                             a
                                          
                                       
                                       =
                                       {
                                       
                                          
                                             A
                                          
                                          
                                             j
                                          
                                       
                                       |
                                       j
                                       =
                                       1
                                       …
                                       
                                          
                                             N
                                          
                                          
                                             a
                                          
                                       
                                       }
                                    
                                  a set of 
                                    
                                       
                                          
                                             N
                                          
                                          
                                             a
                                          
                                       
                                    
                                  vertices corresponding to the agencies;


                                 
                                    
                                       
                                          
                                             V
                                          
                                          
                                             s
                                          
                                       
                                       =
                                       {
                                       
                                          
                                             A
                                          
                                          
                                             i
                                             ,
                                             j
                                          
                                       
                                       |
                                       i
                                       =
                                       1
                                       …
                                       
                                          
                                             N
                                          
                                          
                                             a
                                          
                                       
                                       ,
                                       j
                                       =
                                       1
                                       …
                                       K
                                       -
                                       1
                                       }
                                    
                                  a set of 
                                    
                                       
                                          
                                             N
                                          
                                          
                                             a
                                          
                                       
                                       (
                                       K
                                       -
                                       1
                                       )
                                    
                                  auxiliary vertices, where 
                                    
                                       K
                                       =
                                       
                                          
                                             N
                                          
                                          
                                             t
                                          
                                       
                                       -
                                       
                                          
                                             N
                                          
                                          
                                             a
                                          
                                       
                                    
                                 .

The total number of vertices is 
                           
                              
                                 
                                    N
                                 
                                 
                                    v
                                 
                              
                              =
                              
                                 
                                    N
                                 
                                 
                                    t
                                 
                              
                              +
                              
                                 
                                    N
                                 
                                 
                                    a
                                 
                              
                              (
                              
                                 
                                    N
                                 
                                 
                                    t
                                 
                              
                              -
                              
                                 
                                    N
                                 
                                 
                                    a
                                 
                              
                              )
                              +
                              4
                           
                        . In the case 
                           
                              K
                              <
                              2
                           
                         the set 
                           
                              
                                 
                                    V
                                 
                                 
                                    s
                                 
                              
                           
                         is empty and the number of vertices is 
                           
                              
                                 
                                    N
                                 
                                 
                                    v
                                 
                              
                              =
                              
                                 
                                    N
                                 
                                 
                                    t
                                 
                              
                              +
                              
                                 
                                    N
                                 
                                 
                                    a
                                 
                              
                              +
                              4
                           
                        .

The set of edges 
                           
                              E
                              =
                              
                                 
                                    E
                                 
                                 
                                    s
                                 
                              
                              ∪
                              
                                 
                                    E
                                 
                                 
                                    m
                                 
                              
                              ∪
                              
                                 
                                    E
                                 
                                 
                                    b
                                 
                              
                              ∪
                              
                                 
                                    E
                                 
                                 
                                    
                                       
                                          a
                                       
                                       
                                          1
                                       
                                    
                                 
                              
                              ∪
                              
                                 
                                    E
                                 
                                 
                                    
                                       
                                          a
                                       
                                       
                                          2
                                       
                                    
                                 
                              
                              ∪
                              
                                 
                                    E
                                 
                                 
                                    t
                                 
                              
                           
                         is composed of the following six subsets:
                           
                              
                                 
                                    
                                       
                                          
                                             E
                                          
                                          
                                             s
                                          
                                       
                                       =
                                       {
                                       (
                                       s
                                       ,
                                       
                                          
                                             T
                                          
                                          
                                             i
                                          
                                       
                                       )
                                       |
                                       i
                                       =
                                       1
                                       …
                                       
                                          
                                             N
                                          
                                          
                                             t
                                          
                                       
                                       }
                                    
                                  a set of 
                                    
                                       
                                          
                                             N
                                          
                                          
                                             t
                                          
                                       
                                    
                                  edges connecting the source node to each target vertex in 
                                    
                                       
                                          
                                             V
                                          
                                          
                                             t
                                          
                                       
                                    
                                  (blue edges in Fig. 7);


                                 
                                    
                                       
                                          
                                             E
                                          
                                          
                                             m
                                          
                                       
                                       =
                                       {
                                       (
                                       
                                          
                                             T
                                          
                                          
                                             i
                                          
                                       
                                       ,
                                       
                                          
                                             A
                                          
                                          
                                             j
                                          
                                       
                                       )
                                       |
                                       i
                                       =
                                       1
                                       …
                                       
                                          
                                             N
                                          
                                          
                                             t
                                          
                                       
                                       ,
                                       j
                                       =
                                       1
                                       …
                                       
                                          
                                             A
                                          
                                          
                                             
                                                
                                                   N
                                                
                                                
                                                   a
                                                
                                             
                                          
                                       
                                       }
                                    
                                  a set of 
                                    
                                       
                                          
                                             N
                                          
                                          
                                             t
                                          
                                       
                                       ×
                                       
                                          
                                             N
                                          
                                          
                                             a
                                          
                                       
                                    
                                  edges connecting each target vertex to each agency vertex (yellow edges);


                                 
                                    
                                       
                                          
                                             E
                                          
                                          
                                             b
                                          
                                       
                                       =
                                       {
                                       (
                                       
                                          
                                             A
                                          
                                          
                                             j
                                          
                                       
                                       ,
                                       
                                          
                                             B
                                          
                                          
                                             1
                                          
                                       
                                       )
                                       |
                                       j
                                       =
                                       1
                                       …
                                       
                                          
                                             N
                                          
                                          
                                             a
                                          
                                       
                                       }
                                    
                                  a set of 
                                    
                                       
                                          
                                             N
                                          
                                          
                                             a
                                          
                                       
                                    
                                  edges connecting each agency vertex in 
                                    
                                       
                                          
                                             V
                                          
                                          
                                             a
                                          
                                       
                                    
                                  to the 
                                    
                                       
                                          
                                             B
                                          
                                          
                                             1
                                          
                                       
                                    
                                  node (green edges);


                                 
                                    
                                       
                                          
                                             E
                                          
                                          
                                             
                                                
                                                   a
                                                
                                                
                                                   1
                                                
                                             
                                          
                                       
                                       =
                                       {
                                       (
                                       
                                          
                                             A
                                          
                                          
                                             i
                                             ,
                                             j
                                          
                                       
                                       ,
                                       
                                          
                                             B
                                          
                                          
                                             2
                                          
                                       
                                       )
                                       |
                                       i
                                       =
                                       1
                                       …
                                       
                                          
                                             N
                                          
                                          
                                             a
                                          
                                       
                                       ,
                                       j
                                       =
                                       0
                                       …
                                       K
                                       -
                                       1
                                       }
                                    
                                 , where 
                                    
                                       
                                          
                                             A
                                          
                                          
                                             i
                                             ,
                                             0
                                          
                                       
                                       ≡
                                       
                                          
                                             A
                                          
                                          
                                             i
                                          
                                       
                                    
                                 , a set of 
                                    
                                       
                                          
                                             N
                                          
                                          
                                             a
                                          
                                       
                                       K
                                    
                                  auxiliary edges (brown edges);


                                 
                                    
                                       
                                          
                                             E
                                          
                                          
                                             
                                                
                                                   a
                                                
                                                
                                                   2
                                                
                                             
                                          
                                       
                                       =
                                       {
                                       (
                                       
                                          
                                             A
                                          
                                          
                                             i
                                             ,
                                             j
                                          
                                       
                                       ,
                                       
                                          
                                             A
                                          
                                          
                                             i
                                             ,
                                             j
                                             +
                                             1
                                          
                                       
                                       )
                                       |
                                       i
                                       =
                                       1
                                       …
                                       
                                          
                                             N
                                          
                                          
                                             a
                                          
                                       
                                       ,
                                       j
                                       =
                                       0
                                       …
                                       K
                                       -
                                       2
                                       }
                                    
                                  another set of 
                                    
                                       
                                          
                                             N
                                          
                                          
                                             a
                                          
                                       
                                       (
                                       K
                                       -
                                       1
                                       )
                                    
                                  auxiliary edges (purple edges);


                                 
                                    
                                       
                                          
                                             E
                                          
                                          
                                             t
                                          
                                       
                                       =
                                       {
                                       (
                                       
                                          
                                             B
                                          
                                          
                                             1
                                          
                                       
                                       ,
                                       t
                                       )
                                       ,
                                       (
                                       
                                          
                                             B
                                          
                                          
                                             2
                                          
                                       
                                       ,
                                       t
                                       )
                                       }
                                    
                                  two edges connecting nodes 
                                    
                                       
                                          
                                             B
                                          
                                          
                                             1
                                          
                                       
                                    
                                  and 
                                    
                                       
                                          
                                             B
                                          
                                          
                                             2
                                          
                                       
                                    
                                  to the sink node (red edges).

The total number of edges is 
                           
                              
                                 
                                    N
                                 
                                 
                                    e
                                 
                              
                              =
                              2
                              +
                              
                                 
                                    N
                                 
                                 
                                    t
                                 
                              
                              +
                              3
                              
                                 
                                    N
                                 
                                 
                                    a
                                 
                              
                              
                                 
                                    N
                                 
                                 
                                    t
                                 
                              
                              -
                              2
                              
                                 
                                    N
                                 
                                 
                                    a
                                 
                                 
                                    2
                                 
                              
                           
                        ; in the special case 
                           
                              K
                              <
                              2
                           
                         it is 
                           
                              
                                 
                                    N
                                 
                                 
                                    e
                                 
                              
                              =
                              2
                              +
                              
                                 
                                    N
                                 
                                 
                                    t
                                 
                              
                              +
                              
                                 
                                    N
                                 
                                 
                                    a
                                 
                              
                              +
                              
                                 
                                    N
                                 
                                 
                                    a
                                 
                              
                              
                                 
                                    N
                                 
                                 
                                    t
                                 
                              
                           
                        .

The capacity and cost functions are defined as follows:
                           
                              
                                 
                                 
                                 
                                 
                                    
                                       
                                          
                                             
                                                e
                                                ∈
                                                
                                                   
                                                      E
                                                   
                                                   
                                                      s
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                                cap
                                                (
                                                e
                                                )
                                                =
                                                1
                                             
                                          
                                       
                                       
                                          
                                             
                                                cost
                                                (
                                                e
                                                )
                                                =
                                                0
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                e
                                                ∈
                                                
                                                   
                                                      E
                                                   
                                                   
                                                      m
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                                cap
                                                (
                                                e
                                                )
                                                =
                                                1
                                             
                                          
                                       
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                                cost
                                                (
                                                e
                                                )
                                                =
                                                
                                                   
                                                      ρ
                                                   
                                                   
                                                      
                                                         
                                                            N
                                                         
                                                         
                                                            0
                                                         
                                                      
                                                   
                                                
                                                max
                                                
                                                   
                                                      
                                                         0
                                                         ,
                                                         
                                                            
                                                               e
                                                            
                                                            
                                                               H
                                                               (
                                                               
                                                                  
                                                                     t
                                                                  
                                                                  
                                                                     i
                                                                  
                                                               
                                                               |
                                                               
                                                                  
                                                                     a
                                                                  
                                                                  
                                                                     j
                                                                  
                                                               
                                                               )
                                                            
                                                         
                                                         -
                                                         
                                                            
                                                               e
                                                            
                                                            
                                                               
                                                                  
                                                                     H
                                                                  
                                                                  
                                                                     0
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                    
                                    
                                       
                                          
                                             
                                                e
                                                ∈
                                                
                                                   
                                                      E
                                                   
                                                   
                                                      b
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                                cap
                                                (
                                                e
                                                )
                                                =
                                                1
                                             
                                          
                                       
                                       
                                          
                                             
                                                cost
                                                (
                                                e
                                                )
                                                =
                                                1
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                e
                                                ∈
                                                
                                                   
                                                      E
                                                   
                                                   
                                                      
                                                         
                                                            a
                                                         
                                                         
                                                            1
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                                cap
                                                (
                                                e
                                                )
                                                =
                                                1
                                             
                                          
                                       
                                       
                                          
                                             
                                                cost
                                                (
                                                e
                                                )
                                                =
                                                2
                                                (
                                                j
                                                +
                                                1
                                                )
                                                +
                                                1
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                e
                                                ∈
                                                
                                                   
                                                      E
                                                   
                                                   
                                                      
                                                         
                                                            a
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                                cap
                                                (
                                                e
                                                )
                                                =
                                                K
                                                -
                                                j
                                             
                                          
                                       
                                       
                                          
                                             
                                                cost
                                                (
                                                e
                                                )
                                                =
                                                0
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                e
                                                =
                                                (
                                                
                                                   
                                                      B
                                                   
                                                   
                                                      1
                                                   
                                                
                                                ,
                                                t
                                                )
                                             
                                          
                                       
                                       
                                          
                                             
                                                cap
                                                (
                                                e
                                                )
                                                =
                                                
                                                   
                                                      N
                                                   
                                                   
                                                      a
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                                cost
                                                (
                                                e
                                                )
                                                =
                                                0
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                e
                                                =
                                                (
                                                
                                                   
                                                      B
                                                   
                                                   
                                                      2
                                                   
                                                
                                                ,
                                                t
                                                )
                                             
                                          
                                       
                                       
                                          
                                             
                                                cap
                                                (
                                                e
                                                )
                                                =
                                                
                                                   
                                                      N
                                                   
                                                   
                                                      t
                                                   
                                                
                                                -
                                                
                                                   
                                                      N
                                                   
                                                   
                                                      a
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                                cost
                                                (
                                                e
                                                )
                                                =
                                                0
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

A feasible 
                           
                              (
                              s
                              ,
                              t
                              )
                              -
                              flow
                           
                         is a function 
                           
                              f
                              :
                              E
                              →
                              R
                           
                         that satisfies:
                           
                              
                                 
                                 
                                 
                                    
                                       (1) 
                                             
                                                0
                                                ⩽
                                                f
                                                (
                                                e
                                                )
                                                ⩽
                                                cap
                                                (
                                                e
                                                )
                                             
                                          
                                       
                                       
                                          
                                             
                                                ∀
                                                e
                                                ∈
                                                E
                                             
                                          
                                       
                                    
                                    
                                       (2) 
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      e
                                                      ∈
                                                      in
                                                      (
                                                      v
                                                      )
                                                   
                                                
                                                f
                                                (
                                                e
                                                )
                                                =
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      e
                                                      ∈
                                                      out
                                                      (
                                                      v
                                                      )
                                                   
                                                
                                                f
                                                (
                                                e
                                                )
                                             
                                          
                                       
                                       
                                          
                                             
                                                ∀
                                                v
                                                ∈
                                                V
                                                ⧹
                                                {
                                                s
                                                ,
                                                t
                                                }
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where 
                           
                              in
                              (
                              v
                              )
                           
                         (
                           
                              out
                              (
                              v
                              )
                           
                        ) is the set of edges entering (leaving) vertex v.

The value of flow f is: 
                           
                              val
                              (
                              f
                              )
                              =
                              
                                 
                                    ∑
                                 
                                 
                                    e
                                    ∈
                                    out
                                    (
                                    s
                                    )
                                 
                              
                              f
                              (
                              e
                              )
                              -
                              
                                 
                                    ∑
                                 
                                 
                                    e
                                    ∈
                                    in
                                    (
                                    s
                                    )
                                 
                              
                              f
                              (
                              e
                              )
                           
                        , while the cost of the flow is: 
                           
                              cost
                              (
                              f
                              )
                              =
                              
                                 
                                    ∑
                                 
                                 
                                    e
                                    ∈
                                    E
                                 
                              
                              f
                              (
                              e
                              )
                              cost
                              (
                              e
                              )
                           
                        .

The minimum cost flow (MCF) problem consists in finding a flow function f with 
                           
                              val
                              (
                              f
                              )
                              =
                              V
                           
                        , for a given 
                           
                              V
                           
                        , having minimal cost. In our case the desired flow value is 
                           
                              V
                              =
                              
                                 
                                    N
                                 
                                 
                                    t
                                 
                              
                           
                        . The complexity of the problem is 
                           
                              O
                              (
                              V
                              
                                 
                                    N
                                 
                                 
                                    e
                                 
                              
                              log
                              (
                              
                                 
                                    N
                                 
                                 
                                    v
                                 
                              
                              )
                              /
                              max
                              (
                              1
                              ,
                              log
                              (
                              
                                 
                                    N
                                 
                                 
                                    e
                                 
                              
                              /
                              
                                 
                                    N
                                 
                                 
                                    v
                                 
                              
                              )
                              )
                              )
                           
                         which in our case is equivalent to 
                           
                              O
                              (
                              
                                 
                                    N
                                 
                                 
                                    a
                                 
                              
                              
                                 
                                    N
                                 
                                 
                                    t
                                 
                                 
                                    2
                                 
                              
                              log
                              (
                              
                                 
                                    N
                                 
                                 
                                    a
                                 
                              
                              K
                              )
                              )
                           
                        .

The capacity values are selected in such a way to guarantee that every target is assigned to an agency and every agency has at least one target assigned to it.

In fact, the unitary capacity of 
                           
                              
                                 
                                    E
                                 
                                 
                                    s
                                 
                              
                           
                         edges guarantees that, in order to reach the desired flow from source to sink, every target is assigned to an agency. On the other hand, the capacities of edges 
                           
                              (
                              
                                 
                                    B
                                 
                                 
                                    1
                                 
                              
                              ,
                              t
                              )
                           
                         and 
                           
                              (
                              
                                 
                                    B
                                 
                                 
                                    2
                                 
                              
                              ,
                              t
                              )
                           
                         require that exactly 
                           
                              
                                 
                                    N
                                 
                                 
                                    a
                                 
                              
                           
                         units of flow pass through node 
                           
                              
                                 
                                    B
                                 
                                 
                                    1
                                 
                              
                           
                         and, because of the unitary capacities of 
                           
                              
                                 
                                    E
                                 
                                 
                                    b
                                 
                              
                           
                         edges, every agency node has to contribute to that flow.

The costs of edges in 
                           
                              
                                 
                                    E
                                 
                                 
                                    m
                                 
                              
                           
                         account for the second term of the cost function (2), and in fact each target 
                           
                              
                                 
                                    t
                                 
                                 
                                    i
                                 
                              
                           
                         sends a unitary flow towards an agency 
                           
                              
                                 
                                    a
                                 
                                 
                                    j
                                 
                              
                              =
                              M
                              (
                              
                                 
                                    t
                                 
                                 
                                    i
                                 
                              
                              )
                           
                         contributing with the cost 
                           
                              
                                 
                                    ρ
                                 
                                 
                                    
                                       
                                          N
                                       
                                       
                                          0
                                       
                                    
                                 
                              
                              max
                              
                                 
                                    
                                       0
                                       ,
                                       
                                          
                                             e
                                          
                                          
                                             H
                                             (
                                             
                                                
                                                   t
                                                
                                                
                                                   i
                                                
                                             
                                             |
                                             
                                                
                                                   a
                                                
                                                
                                                   j
                                                
                                             
                                             )
                                          
                                       
                                       -
                                       
                                          
                                             e
                                          
                                          
                                             
                                                
                                                   H
                                                
                                                
                                                   0
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                         to the total cost.

The costs of edges in 
                           
                              
                                 
                                    E
                                 
                                 
                                    
                                       
                                          a
                                       
                                       
                                          1
                                       
                                    
                                 
                              
                           
                         contribute to the first term of the cost function (2): for each agency 
                           
                              
                                 
                                    a
                                 
                                 
                                    j
                                 
                              
                           
                         a cost term is added equal to the square of the number of targets assigned to the agency. Lets denote 
                           
                              
                                 
                                    n
                                 
                                 
                                    j
                                 
                              
                              =
                              Card
                              (
                              
                                 
                                    M
                                 
                                 
                                    -
                                    1
                                 
                              
                              (
                              
                                 
                                    a
                                 
                                 
                                    j
                                 
                              
                              )
                              )
                           
                         and rewrite 
                           
                              
                                 
                                    n
                                 
                                 
                                    j
                                 
                                 
                                    2
                                 
                              
                           
                         as the sum of the first 
                           
                              
                                 
                                    n
                                 
                                 
                                    j
                                 
                              
                           
                         odd numbers: 
                           
                              
                                 
                                    n
                                 
                                 
                                    j
                                 
                                 
                                    2
                                 
                              
                              =
                              
                                 
                                    ∑
                                 
                                 
                                    h
                                    =
                                    0
                                 
                                 
                                    
                                       
                                          n
                                       
                                       
                                          j
                                       
                                    
                                    -
                                    1
                                 
                              
                              2
                              h
                              +
                              1
                           
                        . Edges 
                           
                              
                                 
                                    E
                                 
                                 
                                    
                                       
                                          a
                                       
                                       
                                          1
                                       
                                    
                                 
                              
                           
                         encode this decomposition, in fact:
                           
                              •
                              as they have capacity one, if a flow value of 
                                    
                                       
                                          
                                             n
                                          
                                          
                                             j
                                          
                                       
                                    
                                  units reaches the node 
                                    
                                       
                                          
                                             A
                                          
                                          
                                             j
                                          
                                       
                                    
                                 , meaning that 
                                    
                                       
                                          
                                             n
                                          
                                          
                                             j
                                          
                                       
                                    
                                  targets have been assigned to agency 
                                    
                                       
                                          
                                             a
                                          
                                          
                                             j
                                          
                                       
                                    
                                 , it has to be split into 
                                    
                                       
                                          
                                             n
                                          
                                          
                                             j
                                          
                                       
                                    
                                  unitary flows: one has to follow the edge 
                                    
                                       (
                                       
                                          
                                             A
                                          
                                          
                                             j
                                          
                                       
                                       ,
                                       
                                          
                                             B
                                          
                                          
                                             1
                                          
                                       
                                       )
                                    
                                  having cost 1, the others 
                                    
                                       
                                          
                                             n
                                          
                                          
                                             j
                                          
                                       
                                       -
                                       1
                                    
                                  will follow different 
                                    
                                       
                                          
                                             E
                                          
                                          
                                             
                                                
                                                   a
                                                
                                                
                                                   1
                                                
                                             
                                          
                                       
                                    
                                  edges to reach the node 
                                    
                                       
                                          
                                             B
                                          
                                          
                                             2
                                          
                                       
                                    
                                 ;

as these edges have increasing costs 
                                    
                                       2
                                       (
                                       h
                                       +
                                       1
                                       )
                                       +
                                       1
                                    
                                  with 
                                    
                                       h
                                       =
                                       0
                                       ,
                                       …
                                       ,
                                       K
                                       -
                                       1
                                    
                                 , the minimum flow will follow the less costly edges for a total cost: 
                                    
                                       1
                                       +
                                       
                                          
                                             ∑
                                          
                                          
                                             h
                                             =
                                             0
                                          
                                          
                                             
                                                
                                                   n
                                                
                                                
                                                   j
                                                
                                             
                                             -
                                             2
                                          
                                       
                                       (
                                       2
                                       (
                                       h
                                       +
                                       1
                                       )
                                       +
                                       1
                                       )
                                       =
                                       1
                                       +
                                       
                                          
                                             ∑
                                          
                                          
                                             h
                                             =
                                             1
                                          
                                          
                                             
                                                
                                                   n
                                                
                                                
                                                   j
                                                
                                             
                                             -
                                             1
                                          
                                       
                                       (
                                       2
                                       h
                                       +
                                       1
                                       )
                                       =
                                       
                                          
                                             n
                                          
                                          
                                             j
                                          
                                          
                                             2
                                          
                                       
                                    
                                 .

An example is illustrated in Fig. 8
                        .

However, the graph in Fig. 7 allows computation of the optimal mapping from targets to agencies without taking into account the occlusion constraints.

We deal with dependencies among occluding targets by decomposing the MCF problem into subproblems. First we build an occlusion table which lists all the occlusion triples 
                           
                              (
                              
                                 
                                    a
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    t
                                 
                                 
                                    j
                                 
                              
                              ,
                              
                                 
                                    t
                                 
                                 
                                    k
                                 
                              
                              )
                           
                         which mean that target 
                           
                              
                                 
                                    t
                                 
                                 
                                    j
                                 
                              
                           
                         occludes target 
                           
                              
                                 
                                    t
                                 
                                 
                                    k
                                 
                              
                           
                         in one or more of the views in agency 
                           
                              
                                 
                                    a
                                 
                                 
                                    i
                                 
                              
                           
                        . Then we build a recursive algorithm that takes into consideration occlusion triples one by one.


                        Fig. 9
                        (a) gives an example of a weighted network for tracking 3 targets with 2 agencies.

Let the first occlusion triple be 
                           
                              (
                              
                                 
                                    a
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    t
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    t
                                 
                                 
                                    3
                                 
                              
                              )
                           
                        , i.e., target 
                           
                              
                                 
                                    t
                                 
                                 
                                    1
                                 
                              
                           
                         occludes target 
                           
                              
                                 
                                    t
                                 
                                 
                                    3
                                 
                              
                           
                         in agency 
                           
                              
                                 
                                    a
                                 
                                 
                                    1
                                 
                              
                           
                        , meaning that if target 
                           
                              
                                 
                                    t
                                 
                                 
                                    3
                                 
                              
                           
                         is tracked by agency 
                           
                              
                                 
                                    a
                                 
                                 
                                    1
                                 
                              
                           
                        , then target 
                           
                              
                                 
                                    t
                                 
                                 
                                    1
                                 
                              
                           
                         must also be tracked by 
                           
                              
                                 
                                    a
                                 
                                 
                                    1
                                 
                              
                           
                        . According to whether target 
                           
                              
                                 
                                    t
                                 
                                 
                                    3
                                 
                              
                           
                         is tracked by 
                           
                              
                                 
                                    a
                                 
                                 
                                    1
                                 
                              
                           
                         or not, we can divide the MCF problem into two subproblems. The first one manages the case of assigning 
                           
                              
                                 
                                    t
                                 
                                 
                                    3
                                 
                              
                           
                         to agency 
                           
                              
                                 
                                    a
                                 
                                 
                                    1
                                 
                              
                           
                         by removing all the edges going from 
                           
                              
                                 
                                    t
                                 
                                 
                                    3
                                 
                              
                           
                         and 
                           
                              
                                 
                                    t
                                 
                                 
                                    1
                                 
                              
                           
                         to the agencies other than 
                           
                              
                                 
                                    a
                                 
                                 
                                    1
                                 
                              
                           
                         (Fig. 9(b)). The second subproblem deal with the case of not assigning 
                           
                              
                                 
                                    t
                                 
                                 
                                    3
                                 
                              
                           
                         to 
                           
                              
                                 
                                    a
                                 
                                 
                                    1
                                 
                              
                           
                         by just removing the corresponding edge (Fig. 9(c)).

For each occlusion constraint a problem is decomposed into two smaller subproblems: in many cases this reduction procedure results in subproblems having no solutions. This fact is checked by counting the number of edges leaving 
                           
                              
                                 
                                    V
                                 
                                 
                                    t
                                 
                              
                           
                         nodes (
                           
                              
                                 
                                    T
                                 
                                 
                                    cc
                                 
                              
                              (
                              i
                              )
                           
                        ) and the number of edges entering 
                           
                              
                                 
                                    V
                                 
                                 
                                    a
                                 
                              
                           
                         nodes (
                           
                              
                                 
                                    A
                                 
                                 
                                    cc
                                 
                              
                              (
                              j
                              )
                           
                        ); if one of this counters goes to zero the problem has no solution and we can stop the procedure along that path.


                        Algorithms 1 and 2 show the pseudo code of the dynamic task decomposition and of the recursive procedure.
                           Algorithm 1
                           Task decomposition by minimum cost flow. 
                                 
                                    
                                       
                                       
                                       
                                          
                                             compute the camera partition set 
                                                   
                                                      
                                                         
                                                            S
                                                         
                                                         
                                                            c
                                                         
                                                      
                                                   
                                                ;// can be done offline
                                             
                                          
                                          
                                             generate occupancy maps for each target-camera pair
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            cost
                                                         
                                                         
                                                            min
                                                         
                                                      
                                                      =
                                                      ∞
                                                   
                                                
                                             
                                             
                                          
                                          
                                             
                                                for each camera partition 
                                                   
                                                      
                                                         
                                                            PC
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      ∈
                                                      
                                                         
                                                            S
                                                         
                                                         
                                                            c
                                                         
                                                      
                                                   
                                                 
                                                do
                                             
                                             
                                          
                                          
                                             
                                                compute 
                                                   
                                                      
                                                         
                                                            E
                                                         
                                                         
                                                            m
                                                         
                                                      
                                                   
                                                 costs from set of occupancy maps
                                             
                                          
                                          
                                             
                                                build the weighted network 
                                                   
                                                      WN
                                                   
                                                
                                             
                                             
                                          
                                          
                                             
                                                build the occlusion table 
                                                   
                                                      
                                                         
                                                            O
                                                         
                                                         
                                                            tab
                                                         
                                                      
                                                   
                                                , containing 
                                                   
                                                      
                                                         
                                                            O
                                                         
                                                         
                                                            n
                                                         
                                                      
                                                   
                                                 triples
                                             
                                          
                                          
                                             
                                                set the occlusion index 
                                                   
                                                      
                                                         
                                                            O
                                                         
                                                         
                                                            idx
                                                         
                                                      
                                                      =
                                                      1
                                                   
                                                
                                             
                                             
                                          
                                          
                                             
                                                initialize counters 
                                                   
                                                      
                                                         
                                                            T
                                                         
                                                         
                                                            cc
                                                         
                                                      
                                                   
                                                 to 
                                                   
                                                      
                                                         
                                                            N
                                                         
                                                         
                                                            a
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                          
                                          
                                             
                                                initialize counters 
                                                   
                                                      
                                                         
                                                            A
                                                         
                                                         
                                                            cc
                                                         
                                                      
                                                   
                                                 to 
                                                   
                                                      
                                                         
                                                            N
                                                         
                                                         
                                                            t
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                          
                                          
                                             
                                                {call recursive procedure}
                                             
                                          
                                          
                                             
                                                
                                                
                                                   
                                                      (
                                                      cost
                                                      ,
                                                      map
                                                      )
                                                      =
                                                   
                                                 Rec_MCF(
                                                   
                                                      WN
                                                      ,
                                                      
                                                         
                                                            O
                                                         
                                                         
                                                            idx
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            T
                                                         
                                                         
                                                            cc
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            A
                                                         
                                                         
                                                            cc
                                                         
                                                      
                                                   
                                                )
                                             
                                          
                                          
                                             
                                                
                                                if 
                                                
                                                   
                                                      cost
                                                      <
                                                      
                                                         
                                                            cost
                                                         
                                                         
                                                            min
                                                         
                                                      
                                                   
                                                 
                                                then
                                             
                                             
                                          
                                          
                                             
                                                
                                                
                                                   
                                                      
                                                         
                                                            cost
                                                         
                                                         
                                                            min
                                                         
                                                      
                                                      =
                                                      cost
                                                   
                                                
                                             
                                             
                                          
                                          
                                             
                                                
                                                
                                                   
                                                      
                                                         
                                                            map
                                                         
                                                         
                                                            best
                                                         
                                                      
                                                      =
                                                      map
                                                   
                                                
                                             
                                             
                                          
                                          
                                             
                                                
                                                end if
                                             
                                             
                                          
                                          
                                             
                                                end for
                                             
                                             
                                          
                                          
                                             return 
                                                   
                                                      
                                                         
                                                            map
                                                         
                                                         
                                                            best
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                          
                                       
                                    
                                 
                              
                           

Recursive procedure to deal with occlusions. 
                                 
                                    
                                       
                                       
                                       
                                          
                                             Rec_MCF(
                                                   
                                                      WN
                                                      ,
                                                      
                                                         
                                                            O
                                                         
                                                         
                                                            idx
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            T
                                                         
                                                         
                                                            cc
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            A
                                                         
                                                         
                                                            cc
                                                         
                                                      
                                                   
                                                )
                                             
                                          
                                          
                                             
                                                if one of the counters in 
                                                   
                                                      
                                                         
                                                            T
                                                         
                                                         
                                                            cc
                                                         
                                                      
                                                   
                                                 or 
                                                   
                                                      
                                                         
                                                            A
                                                         
                                                         
                                                            cc
                                                         
                                                      
                                                   
                                                 is zero then
                                             
                                             
                                          
                                          
                                             
                                                return 
                                                   
                                                      (
                                                      ∞
                                                      ,
                                                      ∅
                                                      )
                                                   
                                                
                                             
                                             
                                          
                                          
                                             
                                                else if 
                                                
                                                   
                                                      
                                                         
                                                            O
                                                         
                                                         
                                                            idx
                                                         
                                                      
                                                      =
                                                      =
                                                      
                                                         
                                                            O
                                                         
                                                         
                                                            n
                                                         
                                                      
                                                   
                                                 
                                                then
                                             
                                             
                                          
                                          
                                             
                                                {all occlusion triples have been managed; solve the MCF problem obtaining minimum cost and best map}
                                             
                                          
                                          
                                             
                                                
                                                
                                                   
                                                      (
                                                      cost
                                                      ,
                                                      map
                                                      )
                                                   
                                                 = MCF(
                                                   
                                                      WN
                                                   
                                                )
                                             
                                          
                                          
                                             
                                                return 
                                                   
                                                      (
                                                      cost
                                                      ,
                                                      map
                                                      )
                                                   
                                                
                                             
                                             
                                          
                                          
                                             
                                                else
                                             
                                             
                                          
                                          
                                             
                                                {subProblem 1}
                                             
                                          
                                          
                                             
                                                update counters 
                                                   
                                                      
                                                         
                                                            T
                                                         
                                                         
                                                            cc
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            A
                                                         
                                                         
                                                            cc
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                          
                                          
                                             
                                                build the modified network 
                                                   
                                                      
                                                         
                                                            WN
                                                         
                                                         
                                                            1
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                          
                                          
                                             
                                                
                                                
                                                   
                                                      (
                                                      
                                                         
                                                            cost
                                                         
                                                         
                                                            1
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            map
                                                         
                                                         
                                                            1
                                                         
                                                      
                                                      )
                                                      =
                                                   
                                                 Rec_MFC(
                                                   
                                                      
                                                         
                                                            WN
                                                         
                                                         
                                                            1
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            O
                                                         
                                                         
                                                            idx
                                                         
                                                      
                                                      +
                                                      1
                                                      ,
                                                      
                                                         
                                                            T
                                                         
                                                         
                                                            cc
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            A
                                                         
                                                         
                                                            cc
                                                         
                                                      
                                                   
                                                )
                                             
                                          
                                          
                                             
                                                restore counters 
                                                   
                                                      
                                                         
                                                            T
                                                         
                                                         
                                                            cc
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            A
                                                         
                                                         
                                                            cc
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                          
                                          
                                             
                                                {subProblem 2}
                                             
                                          
                                          
                                             
                                                update counters 
                                                   
                                                      
                                                         
                                                            T
                                                         
                                                         
                                                            cc
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            A
                                                         
                                                         
                                                            cc
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                          
                                          
                                             
                                                build the modified network 
                                                   
                                                      
                                                         
                                                            WN
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                          
                                          
                                             
                                                
                                                
                                                   
                                                      (
                                                      
                                                         
                                                            cost
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            map
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                      )
                                                      =
                                                   
                                                 Rec_MFC(
                                                   
                                                      
                                                         
                                                            WN
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            O
                                                         
                                                         
                                                            idx
                                                         
                                                      
                                                      +
                                                      1
                                                      ,
                                                      
                                                         
                                                            T
                                                         
                                                         
                                                            cc
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            A
                                                         
                                                         
                                                            cc
                                                         
                                                      
                                                   
                                                )
                                             
                                          
                                          
                                             
                                                restore counters 
                                                   
                                                      
                                                         
                                                            T
                                                         
                                                         
                                                            cc
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            A
                                                         
                                                         
                                                            cc
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                          
                                          
                                             
                                                
                                                if 
                                                
                                                   
                                                      
                                                         
                                                            cost
                                                         
                                                         
                                                            1
                                                         
                                                      
                                                      <
                                                      
                                                         
                                                            cost
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                   
                                                 
                                                then
                                             
                                             
                                          
                                          
                                             
                                                return 
                                                   
                                                      (
                                                      
                                                         
                                                            cost
                                                         
                                                         
                                                            1
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            map
                                                         
                                                         
                                                            1
                                                         
                                                      
                                                      )
                                                   
                                                
                                             
                                             
                                          
                                          
                                             
                                                
                                                else
                                             
                                             
                                          
                                          
                                             
                                                return 
                                                   
                                                      (
                                                      
                                                         
                                                            cost
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            map
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                      )
                                                   
                                                
                                             
                                             
                                          
                                          
                                             
                                                
                                                end if
                                             
                                             
                                          
                                          
                                             
                                                end for
                                             
                                             
                                          
                                       
                                    
                                 
                              
                           

@&#EXPERIMENTS AND RESULTS@&#

To evaluate the performance of our algorithm, we carried out a number of experiments with two challenging datasets that we make available with this publication, and with the standard PETS_2009_S2_L1 tracking benchmark using View_001 to View_004. We give a brief description of the implementation details of the overall tracking system and the resources utilized to carry out real-time tracking experiments on these datasets. We evaluate the proposed methods from three aspects: algorithm complexity, effectiveness of the cost measure, and tracking performance and real-time behavior with an experimental comparison to a state-of-the-art camera set selection method for distributed tracking [13].

With this paper, we make publicly available two high-quality multi-camera datasets FBK LAB and FBK HALLWAY for evaluating multiple people tracking in challenging multi-camera environment. Each dataset features 15Hz frame-synchronized jpeg recordings from four cameras observing the scene from a distance with orthogonal viewing directions. Both datasets come with high-quality calibration data and manually annotated references (ground location of people in a common reference aligned with calibration) for evaluation.

FBK LAB sequence (9K 4-view frames): acquired in a lab environment of about 
                           
                              5
                              ×
                              6
                           
                        
                        m, at resolution 
                           
                              640
                              ×
                              480
                           
                        . Through the sequence, people enter, walk around, sit down and exit the room randomly, causing frequent and persistent occlusions in all four views. The maximum number of people in the scene at the same time is 7. Annotations (one per second) are provided for the most challenging part of the sequence of about 3.5min.

FBK HALLWAY sequence (11K 4-view frames): acquired in a large open space equipped with chairs, desks and poster walls, at resolution 
                           
                              1280
                              ×
                              1024
                           
                        . The sequence shows people freely interacting in an exhibition and informal meeting space inside a large hallway, with people entering the area, moving, standing still, forming into groups and interacting with each other, sitting on chairs and leaving the area. The cameras capturing the scene are distant about 12–19m one from the other, and people’s bodies may appear in some views at resolutions as low as 
                           
                              15
                              ×
                              60
                           
                        
                        pixels. The maximum number of people present in the scene at the same time is 9. Annotations (one per second) are provided for the most challenging part of the sequence of about 5min.


                        Fig. 10
                         shows sample images from LAB and HALLWAY recordings.

To analyze the complexity of the algorithms in a realistic scenario, we did experiments on the time used for task decomposition. The experiments were done with the ground truth annotations of HALLWAY dataset using the parameters reported in Table 1
                        . We computed the average time used for task decomposition for different number of targets in the scene (measured time covers all steps of the decomposition, including rendering and computation of ground occupancy maps). Fig. 11
                         shows that for numbers of targets 
                           
                              
                                 
                                    N
                                 
                                 
                                    t
                                 
                              
                              ⩽
                              9
                           
                         in the experiments, the decomposition time for our minimum cost flow method grows almost linearly with the number of targets while for the exhaustive searching method the time grows exponentially. However, when the number of targets is smaller than 5, the exhaustive searching method uses less time because the number of target partitions is small and it takes time for the minimum cost flow method to build graphs. Since normally there is no need to do task decomposition when there are a small number of targets, in the following experiments we only used the minimum cost flow method for evaluation.

To verify the effectiveness of the proposed cost function in Eq. (2), we did an experiment with the ground truth data of the HALLWAY sequence. In the experiment the following constraints are imposed: 
                           
                              
                                 
                                    MAX
                                 
                                 
                                    a
                                 
                              
                              =
                              3
                              ,
                              
                              
                                 
                                    MIN
                                 
                                 
                                    c
                                 
                              
                              =
                              2
                              ,
                              
                              
                                 
                                    MAX
                                 
                                 
                                    c
                                 
                              
                              =
                              4
                              ,
                              
                              
                                 
                                    M
                                 
                                 
                                    i
                                 
                              
                              =
                              2
                              
                              (
                              i
                              ∈
                              {
                              1
                              ,
                              2
                              ,
                              3
                              ,
                              4
                              }
                              )
                           
                        .

We computed the best way of task decomposition for each ground truth entry, as is shown in Fig. 12
                        . At frame 2660 (Fig. 12(a)), targets 2, 3, 4, 5 and targets 6, 7, 8, 9 form into two groups (
                           
                              
                                 
                                    g
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                              
                                 
                                    g
                                 
                                 
                                    2
                                 
                              
                           
                         respectively) while target 1 stands isolate from them. Initially the system allocates 3 agencies to track them separately. From frame 2660 on, target 1 walks towards group 
                           
                              
                                 
                                    g
                                 
                                 
                                    2
                                 
                              
                           
                         by passing group 
                           
                              
                                 
                                    g
                                 
                                 
                                    1
                                 
                              
                           
                        . During this period, it is first tracked together with 
                           
                              
                                 
                                    g
                                 
                                 
                                    1
                                 
                              
                           
                         (Fig. 12(c)) when they are close and then it is tracked together with 
                           
                              
                                 
                                    g
                                 
                                 
                                    2
                                 
                              
                           
                         when it joins 
                           
                              
                                 
                                    g
                                 
                                 
                                    2
                                 
                              
                           
                         at frame 2885 (Fig. 12(e)). After some while, it leaves 
                           
                              
                                 
                                    g
                                 
                                 
                                    2
                                 
                              
                           
                         and is tracked separately again (Fig. 12(f)). Given the imposed occlusion constraint, from this experiment we can see that the proposed cost measure generates reasonable decompositions of the task. By the way, we should note that we do not just track people according to their closeness. The generation of agencies and groups of people as well as their optimal association is jointly determined by the cost function, the occlusion constraints together with the constraints about resources imposed (e.g., 
                           
                              
                                 
                                    MAX
                                 
                                 
                                    a
                                 
                              
                           
                        ). It could happen that when two targets are far away but are still tracked together under the imposed constraints. However, it does not decrease the performance as long as within the subtask there are no occluders from people tracked by other subtasks. Moreover, the radius R of the estimated supports of targets impacts on the potential occlusions among targets and on the camera utility rate used in the cost function and, thus, on the resulting optimal task decomposition. In this paper, we assume a constant speed for all targets within a small time interval (
                           
                              333
                              
                              ms
                           
                         in all our experiments) so the R is fixed (
                           
                              R
                              =
                              65
                              
                              cm
                           
                         for HALLWAY dataset used in this experiment, see Section 5.4.1).


                        Fig. 13
                         shows two interesting cases to discuss the benefits of deriving camera utility from computational cost associated with adapting the number of particles to uncertainty of ground occupancy predictions. By considering only computational cost with fixed-size particle filtering, the cheapest solution with the targets in (a)–(c) satisfying occlusion constraints is dividing the 5 targets into 3 groups such as in (b), (c): complexity 
                           
                              ∝
                              
                                 
                                    3
                                 
                                 
                                    2
                                 
                              
                              +
                              1
                              +
                              1
                              =
                              11
                           
                        . With solution (c) there is large predicted uncertainty making fixed-size particle tracking with these groupings unreliable, and a better solution with equal complexity is (b). However, our definition of cost measure goes beyond simply selecting the best cameras for performing tracking with the lowest computational cost: the optimal solution is found by a more expensive 
                           
                              
                                 
                                    2
                                 
                                 
                                    2
                                 
                              
                              +
                              
                                 
                                    3
                                 
                                 
                                    2
                                 
                              
                              =
                              13
                           
                         decomposition (a) which is much more convenient in terms of tracking failure risk. Our parameter-free cost measure self-regulates this trade-off between complexity and robustness. In (d)–(f) we can observe a similar case: occlusions-aware generation of ground occupancy maps ranks the solutions differently than if occlusions are ignored.

We demonstrate the tracking performance of our approach by measuring the standard MOT (Multiple Object Tracking) metrics as proposed in [31], which provides a systematic evaluation to compare the performance of different trackers in terms of tracking accuracy and consistent labeling. MOT Accuracy combines false alarms (false-positive rate in the result tables, in %), missed targets (miss rate, in %) and identity switches (mismatches, count); the higher the better. MOT Precision (in cm) measures the misalignment of the predicted track with respect to the ground truth trajectory; the lower the better. We used the original implementation of MOT evaluation tool provided by the authors of [31]. We further evaluate real time performance in terms of tracking rate, i.e., number of particle filter iterations (or position updates) per second per target, computed by the HJS PF process (tracking rate⩽nominal frame rate of dataset). We compare our approach (‘Proposed method’ in the result tables) with the centralized HJS tracker in [22], where a single HJS base tracker is executed to track all targets using all cameras (‘Centralized’) – also in this case, all (four) HJS likelihood processes run in parallel. To verify how close we are to nominal performance (‘Baseline’), we ran the centralized HJS tracker with 
                           
                              
                                 
                                    N
                                 
                                 
                                    0
                                 
                              
                              =
                              500
                           
                         in off-line mode, i.e., giving the tracker enough time and resources to fine-process every single frame of the sequence.

@&#IMPLEMENTATION DETAILS@&#

Parameters and configurations used for the experiments are listed in Table 1. We simulate the smart camera network plus host computer environment in Fig. 2 using two connected PCs as specified in the table. Additional parameters not listed in the table are: 
                              
                                 
                                    
                                       MAX
                                    
                                    
                                       c
                                    
                                 
                                 =
                                 4
                                 ,
                                 
                                 
                                    
                                       MAX
                                    
                                    
                                       a
                                    
                                 
                                 =
                                 3
                                 ,
                                 
                                 
                                    
                                       M
                                    
                                    
                                       i
                                    
                                 
                                 =
                                 3
                                 ,
                                 
                                 R
                                 =
                                 0.8
                              
                           
                           m, 
                              
                                 ρ
                                 =
                                 400
                              
                           /m2, decomposition update frequency 3Hz, grid size for ground occupancy maps is 0.10m, predicted target outlines for ground occupancy generation are rendered at half of image resolution. Detection and track termination parameters are empirically set for each sequence. We pre-loaded image sequences in memory (jpeg format) to eliminate access to physical storage that could impact real time behavior.

On the choice of 
                              
                                 
                                    
                                       MAX
                                    
                                    
                                       c
                                    
                                 
                                 ,
                                 
                                 
                                    
                                       MIN
                                    
                                    
                                       c
                                    
                                 
                                 ,
                                 
                                 
                                    
                                       MAX
                                    
                                    
                                       a
                                    
                                 
                              
                            parameters. 
                              
                                 
                                    
                                       MAX
                                    
                                    
                                       c
                                    
                                 
                              
                            and 
                              
                                 
                                    
                                       MIN
                                    
                                    
                                       c
                                    
                                 
                              
                            (max and min number of HJS likelihood processes per HJS PF process) are upper-bounded by the number 
                              
                                 
                                    
                                       N
                                    
                                    
                                       c
                                    
                                 
                              
                            of cameras capturing the environment, all our experiments have 
                              
                                 
                                    
                                       N
                                    
                                    
                                       c
                                    
                                 
                                 =
                                 4
                              
                            cameras. In theory, one can choose a higher value but that would mean that the same camera is ‘cloned’ in the agency, i.e., the same image is used multiple times to compute likelihoods for the targets in a base tracker, resulting in useless additional computations (no further information gain). In our task decomposition algorithms we eliminate agencies with clones when we compute the camera partition set 
                              
                                 
                                    
                                       S
                                    
                                    
                                       c
                                    
                                 
                              
                            (see Algorithm 1 and Section 4.4). 
                              
                                 
                                    
                                       MIN
                                    
                                    
                                       c
                                    
                                 
                              
                            is the expected minimum number of views to obtain reliable estimates from base trackers. It mostly depends on the acquisition setup (image resolution, distance and relative orientations with which the cameras observe the scene) and in our cases 2 (for LAB, small environment) and 3 (for HALLWAY and PETS_2009_S2_L1) are reasonable values. 
                              
                                 
                                    
                                       MAX
                                    
                                    
                                       a
                                    
                                 
                              
                           , the maximum number of base trackers instantiated by the decomposition, is upper-bounded by 
                              
                                 
                                    
                                       MAX
                                    
                                    
                                       a
                                    
                                 
                                 ⩽
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                    
                                 
                                 
                                    
                                       M
                                    
                                    
                                       i
                                    
                                 
                                 /
                                 
                                    
                                       MIN
                                    
                                    
                                       c
                                    
                                 
                              
                            where 
                              
                                 
                                    
                                       M
                                    
                                    
                                       i
                                    
                                 
                              
                            is the number of HJS likelihood processes associated to camera i. 
                              
                                 
                                    
                                       MAX
                                    
                                    
                                       a
                                    
                                 
                                 ,
                                 
                                    
                                       M
                                    
                                    
                                       i
                                    
                                 
                              
                            essentially depend on two factors: (i) the available processing resources to run the HJS PF and likelihood processes associated to the agencies, and (ii) the scenario, i.e., the expected maximum number of non-interacting groups of peoples one may expect in the monitored scene. In practice, one can set 
                              
                                 
                                    
                                       MAX
                                    
                                    
                                       a
                                    
                                 
                              
                            to meet the scenario and dimension the computing infrastructure to execute the resulting 
                              
                                 
                                    
                                       MAX
                                    
                                    
                                       a
                                    
                                 
                              
                            HJS PF processes and 
                              
                                 ∑
                                 
                                    
                                       M
                                    
                                    
                                       i
                                    
                                 
                              
                            HJS likelihood processes.


                           Table 2
                            shows the evaluation results with 5 runs of real time tracking. As can be seen, the average MOT Accuracy score of the proposed approach has more than 16% gain compared to the centralized approach, resulting from a significant reduction in miss and false-positive rate. This is due to the loss of frames with the centralized tracker. As the number of targets gets large, the centralized tracker is no more able to handle the computational burden and has to lose frames, thus producing unreliable tracking results (the MOT Accuracy score is very low sometimes as can be seen in the Table). However, the proposed approach is able to decompose the task into a number of subtasks (maximum 
                              
                                 
                                    
                                       N
                                    
                                    
                                       a
                                    
                                 
                                 =
                                 3
                              
                           ) and map them into different processors. Therefore, the evaluation scores are very stable. They are very close to baseline performance with only 4% of MOT Accuracy drop, while this difference reduces to about 2% with 1.3
                              
                                 ×
                              
                            faster processors. Fig. 14
                            compares tracking rate with the different experiments, confirming that with the decomposition a close to nominal performance is reached.

While task decomposition with the entropy based camera utility measure results in no notable difference of MOT Precision (around 6.5cm for all experiments in Table 2), if instead a simpler utility measure is used as in Fig. 15
                           , the localization error increases by about 40% (still below 10cm, though). Also, MOT Accuracy decreases by more than 3 points, indicating the importance of designing expressive utility measure that resembles key aspects of the imaging process impacting on performance.

With PETS_2009_S2_L1 multi-view dataset we observed two main issues which make the evaluation of multi-camera ground tracking approaches challenging. Firstly, overall calibration quality appears just sufficient for View_001 to View_004 (back-projection of scene points from those views – especially on the periphery of images – disagree with an error of up to several tens of centimeters), while calibration quality of View_005 to View_008 is too poor to be used with our approach to ground tracking – we use the 
                           
                              
                                 12
                                 ×
                                 13
                              
                           
                           m2 
                           central area around the crossing with View_001 to View_004 as the tracking domain in our experiments, see 
                           
                              Fig. 16
                           
                           
                           . Secondly, synchronization issues exist across the views (this was noted also in [46]) – many frame drops were observed in the different views which, combined with the low frame rate of the recordings (7Hz), poses additional challenges to prediction based tracking approaches such as particle filtering – we manually synchronized View_002 to View_004 by replicating the previous image whenever a frame drop was observed in relation to View_001. To obtain the references for evaluation, we (i) back-projected to ground coordinates the mid-point of the base segment of 2D bounding boxes provided with the dataset, and (ii) manually corrected the ground positions in the tracking area obtained this way by visual inspection in View_001 to View_004 using our annotation tool. We increased the kernel bandwidth in the ground occupancy map generation (see Table 1) to account for calibration and synchronization issues discussed above. For evaluation with this sequence, we change the threshold used to establish correspondence between tracking hypotheses and ground truth annotation from 0.5m (the standard value – used for LAB and HALLWAY experiments) to 0.8m in the MOT evaluation tool.


                           Table 3
                            reports our real time tracking results. We observe again a significant increase – more than 11% – in MOT Accuracy with the decentralized approach. Overall, there is unbalance between miss to false-positive rates, also in the baseline. This behavior could be attributed in part to calibration issues and, in particular, synchronization: while frames have been temporally aligned through frame copies to fill drops, this surely results in sub-optimal detection performance (which is based on motion – there is 0 motion on copied frames). Further, the focus of the paper is not on absolute tracking performance itself, but on the scalability issue of multi-camera tracking leveraging real-time performance by task decomposition leading to a decentralized solution of existing tracking approach. We also believe that from a practical perspective, in a realistic real time scenario it should be possible to eliminate calibration and synchronization issues at deployment time to ensure appropriate data quality ahead of tracking system installation. We took care of these aspects with the acquisition of FBK HALLWAY dataset, on which we provide a detailed evaluation next.

This sequence is more challenging than LAB due to the much larger tracking area and inter-camera distance (Table 1), higher number of people in the scene, and unconstrained daylight illumination. Table 4
                            shows experimental results of our proposed task decomposition method with a comparison to the camera selection method in [13] under real time tracking conditions. Our proposed method achieves high precision (below 10cm with inter-camera distance of up to about 19m, see Table 1) with well balanced miss to false-positive rates and an average MOT Accuracy above 85%, compared to 77% for centralized tracking, indicating that the tracker configured this way operates close to nominal performance. The average number of mismatches (instantaneous identity switches) is very low (25) compared to the total number (2139) of ground truth annotations used in the evaluation. This can be attributed to the strengths of the color based HJS base tracker featuring identity-preserving long term tracking even when appearance among targets is ambiguous and under occlusion, and this is preserved with the proposed decentralized solution. For the comparative analysis in Table 4 we replaced the camera utility term in Eq. (2) with the Dempster–Shafer (DS) based Camera Suitability Value proposed in [13]. We observed a drop in performance, combined with a higher variance over repeated experiments (10 independent runs). The method in [13] requires a coarse subdivision of the ground into five cells resulting in a significant quantization of the information available for view selection. Instead, our method is able to predict camera utility at a much finer spatial resolution. Another notable difference is the imaging model utilized: as with HJS tracking [22] our model considers visible and occluded regions of a hypothesis in the ground occupancy computation (see Section 4.2), while in [13] only the visible part of multi-target hypothesis is measured for camera utility prediction.

Furthermore, we provide tracking results for the second-best and third-best decomposition solution found by our method. While MOT Precision remains about the same, both MOT Accuracy and the ratio between miss and false positive rates improve progressively with the solution rank – ‘Centralized’ behaves in this sense like the worst solution, confirming the trend. It can be concluded that the entropy based camera utility term captures essential information from view geometry of the multi-camera environment available via calibration, and that the efficient graph-based minimum cost flow method build on top of it ranks consistently task decomposition hypotheses.

Further in terms of real time behavior, Fig. 18
                            shows a comparison of the tracking rate histograms with the different experiments in Table 4. From the histograms we can see that the decentralized tracker performs real time tracking, i.e., tracking at nominal frame rate, for more than 75% of the sequence while the centralized tracker only performs real time tracking for about 20% of the sequence. This can be explained by observing that for a large part of the sequence there are 9 people and the HJS base tracker has a complexity which grows quadratically with the number of targets which, although efficient, prevents from real time tracking all targets with a single HJS filter. However, by decomposing the joint task into several independent subtasks satisfying independence assumptions (Section 3.2) while guaranteeing proper occlusion handling and executing them on different processors, tracking of different groups of people can be performed in parallel and thus the loss of frames is minimized. From the histogram we can also see that the decentralized tracker does not always track in real time. This is because when people are close together the overall task cannot be decomposed into subtasks. Overall, the decentralized solution proposed in this paper achieves practical precision and accuracy with close-to-full frame rate tracking on this challenging sequence.

@&#CONCLUSION@&#

Visual tracking is challenging in large complex scenes where there are many people occluding each other. Some major issues include how to maintain reliable real-time tracking, balance system computational load and data flow, and thus enhance system scalability. In this paper, we proposed a distributed multi-target multi-object tracking system, which has a three-layer architecture. With the proposed cost measure, the approach is able to dynamically decompose the overall task into a number of nearly independent subtasks, each of which tracks a subset of targets with an agency. The association of agencies and groups of people is based on sensing geometry and the estimated target positions. Experimental results demonstrate that the method is able to reduce task complexity and boost parallelization while maintaining overall tracking accuracy comparable to that of a centralized implementation. Consequently, the proposed decentralized tracking framework leads to a scalable solution with superior real-time performance. The paper has also set the basis for further research on resource allocation in a holistic sense, by designing novel cost functions and associated subtask reconfiguration algorithms that are sensitive to asymmetric processing (dynamic load balancing for distributed processing) and communication infrastructures (dynamic routing for distributed image transfer).

@&#REFERENCES@&#

