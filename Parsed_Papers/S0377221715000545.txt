@&#MAIN-TITLE@&#A Lagrangian heuristic for an integrated lot-sizing and fixed scheduling problem

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A new model for a NP-hard lot-sizing and fixed scheduling problem is proposed.


                        
                        
                           
                           A Lagrangian relaxation heuristic is proposed.


                        
                        
                           
                           Novel smoothing heuristics are developed.


                        
                        
                           
                           Extensive numerical experiments validate the proposed approach.


                        
                        
                           
                           Impact of critical parameters is analyzed.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Production planning

Lot sizing

Scheduling

Lagrangian relaxation

Heuristic

@&#ABSTRACT@&#


               
               
                  This paper presents a novel approach for solving an integrated production planning and scheduling problem. In theory as well as in practice, because of their complexity, these two decision levels are most of the time treated sequentially. Scheduling largely depends on the production quantities (lot sizes) computed at the production planning level and ignoring scheduling constraints in planning leads to inconsistent decisions. Integrating production planning and scheduling is therefore important for efficiently managing operations. An integrated model and an iterative solution procedure were proposed in earlier research papers: The approach has limitations, in particular when solving the planning problem. In this paper, a new formulation is proposed to determine a feasible optimal production plan, i.e. lot sizes, for a fixed sequence of operations on the machines when setup costs and times are taken into account. Capacity constraints correspond to paths of the conjunctive graph associated to the sequence. An original Lagrangian relaxation approach is proposed to solve this NP-hard problem. A lower bound is derived and an upper bound is calculated using a novel constructive heuristic. The quality of the approach is tested on numerous problem instances.
               
            

@&#INTRODUCTION@&#

Production decisions in a manufacturing environment aim at determining the most effective way to use resources for the production of items while satisfying customers’ requirements. These decisions are generally separated into two levels: A planning level and a scheduling level. At the planning level, the objective is to determine a production plan, i.e. production quantities for every period of the horizon, that satisfy the demands and minimize the different costs (production costs, setup costs, holding costs ...). These production quantities correspond to the sizes of the lots processed in the shop floor. At the scheduling level, these lots are sequenced on the resources.

However, in practice and in theory, lot-sizing and scheduling decisions are still often taken sequentially. Mathematical planning models take into account aggregate capacity constraints. They do not guarantee that the proposed production plan is feasible when it is forwarded to the scheduling level, i.e. there exists a schedule which allows lots of the production plan to be produced on time (see Dauzère-Pérès and Lasserre, 2002). If capacity is overestimated, capacity constraints in the production plan do not represent the reality in terms of resource availability in the workshop. Thus, the estimated time for producing an item will be lower than the actual production time, which causes delays and dissatisfied customers. On the opposite, when capacity is underestimated, items will be completed earlier than planned, leading to large work-in-process inventories. It seems thus important to simultaneously deal with planning and scheduling decisions in order to determine a feasible and relevant production plan. This is particularly true when items are produced in lots.

Many studies have addressed production planning or scheduling problems but very little attention has been given to the integration of these two decision levels. It should be noted that one of the primary difficulties in solving integrated problems is the nature of the involved decision variables. The planning level determines flows of products and typical models involve continuous variables, whereas models at the scheduling level include discrete variables for defining sequences of products on resources.

The most common approach used for production planning in practice is MRP (Material Requirements Planning). Its assumptions are that production capacity is unlimited and lead times are generally assumed to be fixed. In MRP II (Manufacturing Resource Planning), aggregate capacities are taken into account but are usually not enough to ensure consistency between planning and scheduling decisions.

Lot-sizing problems have been studied in the literature extensively. However, most lot-sizing problems consider aggregate capacity constraints, which make sense when each lot is processed independently on the resources and lots do not have to be sequenced, i.e. if each lot could start simultaneously on all its resources. In this case, the total workload on the machines is then relevant to consider for capacity restrictions. However, when production is by lots, the duration of an elementary operation of a lot is usually no longer negligible. The sequencing of lots on the machines should not be ignored. Dauzère-Pérès and Lasserre (1994); 2002) and Ouenniche, Boctor, and Martel (1999) study the impact of sequencing decisions on multi-item lot-sizing and scheduling problems. Small time-bucket lot-sizing problems (Drexl and Kimms, 1997) consider short time periods and the sequencing of lots. A basic small bucket problem is the Discrete Lot-Sizing and scheduling Problem (DLSP) (Fleischmann, 1990). The main drawback of the DLSP is the so-called all-or-nothing production, which means that only one item may be produced per period and, in that case, the production quantity is equivalent to using full capacity. This drawback is overcome in the Continuous Setup Lot-Sizing Problem (CSLP), but still only one item per period may be produced. In the Proportional Lot-Sizing and scheduling Problem (PLSP) (Drexl and Haase, 1995), the remaining capacity in a given period is used for scheduling a second item. These models allow simultaneous lot sizing and scheduling but limit the number of products to be manufactured in one period. The General Lot-Sizing and scheduling Problem (GLSP) (Fleischmann and Meyr, 1997) takes into account multiple products but features a single capacitated machine. An extension of these problems to multiple machine environments is proposed by Kimms (1999) for the PLSP and Fandel and Stammen-Hegene (2006) for the GLSP. Another class of problems considers lot-sizing and scheduling problem with sequence-dependent setup costs and/or setup times (see for example Almada-Lobo, Klabjan, Carravilla, and Oliveira, 2007; 2010; Almeder, Klabjan, Traxler, and Almada-Lobo, 2015; Gupta and Magnusson, 2005; Haase and Kimms, 2000; Menezes, Clark, and Almada-Lobo, 2010; Meyr, 2000). The main characteristic of these models is that they consider a single resource. Multiple resources in parallel are considered in James and Almada-Lobo (2011) with sequence-dependent setup times and costs, but their model is still far from taking complex job-shop scheduling constraints into account.

Some researchers proposed different approaches for solving the integrated planning and scheduling problem. Dauzère-Pérès and Lasserre (1994); 2002) were among the first to propose an integrated planning and scheduling model. Their models consider complex scheduling problems and the exact capacity of the shop floor is taken into account. They propose a solution procedure that iterates between a planning module and a scheduling module. In the scheduling module, an optimal schedule is determined for fixed lot sizes while, in the planning module, the best lot sizes are calculated for a fixed sequence of operations. This procedure allows a feasible production plan to be determined. Sikora, Chhajed, and Shaw (1996) describe an integrated approach where lot-sizing and sequencing decisions are taken separately. Their approach solves the problem period by period, from the first to the last period of the horizon. At each period, the procedure iterates between sequencing the lots on the machines and determining the lot sizes for a single bottleneck machine (using a modified Silver-Meal heuristic) until the capacity of the period is used as much as possible. Their approach is applied on data of a specific manufacturing line which produces Printed Circuit Boards. Our approach aims at solving the problem globally, and interactions between different periods are allowed. Giglio and Minciardi (2002) propose a formulation for integrating mid-term production planning with short-term production scheduling. Their model also has two types of decision variables: Continuous variables for the lot-sizing and the timing of operations, and combinatorial variables for the assignment and the sequencing of operations over resources. Their approach assumes that all combinatorial variables are fixed, and the model is solved using standard tools. Discrete variables associated to setup costs and times are considered in our approach, and we propose a Lagrangian heuristic to solve large instances of the problem. Jodlbauer (2006) develops an approach to determine the schedule, lot sizes and sequences for a multi-item capacitated production system, based on a specific property of the setup cost function, which enables the number of setup activities to be replaced in the integer model. Backlogging is not allowed in his model and only one machine is considered.

Metaheuristic may also be used to solve the integrated problem. Kim, Park, and Ko (2003) propose an approach that simultaneously solves process planning and scheduling problems in flexible job shops using a symbiotic evolutionary algorithm. This problem is not really a production planning problem since production quantities are not determined and the objective is to minimize the absolute deviation of machine loads, makespan and mean flow time. Zhang and Yan (2005) propose a hybrid genetic algorithm for an integrated job-shop production planning and scheduling problem where the sequence of operations is given. However, their model is different than ours on various aspects, in particular periods are again independent. Moreover, their algorithm is not compared to an exact method, is only tested on very few problems instances and is slow compared to the one proposed in this paper.

We propose a new mathematical model where the objective is to minimize the sum of the production, inventory and setup costs subject to detailed scheduling constraints for a given sequence of operations on the resources. This NP-hard problem (see Section 2.1) is motivated by at least two reasons. First, this is actually a practical problem in some process industries where a preferred sequence of products can be used. The second and main motivation is to use the approach presented in this paper as building block in an iterative procedure that solves the planning problem for a fixed sequence and the scheduling problem for fixed lot sizes. We actually have successfully done it in Gomez-Urrutia, Aggoune, and Dauzère-Pérès (2014), in which the approach proposed in the present paper is used, and not presented, to solve the integrated problem.

The capacity constraints in our new model correspond to paths of the conjunctive graph associated to the sequence. A Lagrangian heuristic is used to solve this problem where capacity constraints are relaxed. The originality of our approach is twofold. First, since there exists an exponential number of capacity constraints, only Lagrangian multipliers related to the most violated constraints are explicitly updated. Second, the procedure used to construct a feasible solution is significantly different from the classical smoothing heuristics used in previous Lagrangian heuristics for lot-sizing problems.

The remainder of the paper is organized as follows. Section 2 recalls the mathematical model of Dauzère-Pérès and Lasserre (DPL) (Dauzère-Pérès and Lasserre, 1994; 2002) with setup costs and times, and presents a new model for a given sequence of jobs on the resources. The Lagrangian relaxation heuristic used for solving the integrated problem is detailed in Section 3. Experimental results are presented and analyzed in Section 4. The paper ends with some conclusions.

As in Dauzère-Pérès and Lasserre (2002), the production of N different items has to be planned on a horizon of T periods to satisfy demands at the lowest cost, where Dil
                         denotes the demand of item i at the end of period l. Detailed scheduling constraints are explicitly considered, namely each item has to be processed in a series of operations (routing) before being completed. Although this assumption could be relaxed by creating additional variables, we suppose that at most one lot of each item is associated to each period. Operations for the production of all items at all periods are considered in the scheduling problem, which is represented using a conjunctive graph (Balas, 1969; Roy and Sussman, 1964) where nodes correspond to operations and arcs to precedence constraints between two operations. Let 
                           O
                         be the set of all nodes (i.e. operations), and i(o) (resp. l(o)) be the item (resp. period) associated with node o. The set 
                           A
                         is the set of pairs of nodes associated to consecutive operations in the routing of the items, i.e. 
                           
                              (
                              o
                              ,
                              
                                 o
                                 ′
                              
                              )
                              ∈
                              A
                           
                         means that node (operation) o precedes node (operation) o′ in the routing. An important assumption in this paper is that the complete sequence of operations sharing the same resource is given. Let 
                           S
                         denote the set of pairs of nodes associated to consecutive operations on a resource, i.e. 
                           
                              (
                              o
                              ,
                              
                                 o
                                 ′
                              
                              )
                              ∈
                              S
                           
                         means that node (operation) o precedes node (operation) o′ in the sequence of a resource.

A small example of a conjunctive graph is illustrated in the graph of Fig. 1
                        . It corresponds to three products on three periods. The plain arcs correspond to pairs of operations in 
                           A
                         and the dashed arcs to pairs of operations in 
                           S
                        . The routes of the products in period 1 are (1, 2, 3), (4, 5) and (6, 7, 8), respectively, and so on for the periods 2 and 3. There are 3 resources. Operations 1, 5, 8, 9, 17, 13, 16, 21 and 24 are processed on the first resource, in that order, operations 4, 7, 2, 12, 10, 15, 20, 23 and 18 on the second resource and operations 6, 3, 14, 11, 22 and 19 on the third resource. Hence, 
                           A
                         = {(1,2), (2,3), (4,5), (6,7), (7,8), (9,10), (10,11), (12,13), (14,15), (15,16), (17,18), (18,19), (20,21), (22,23), (23,24)} and 
                           S
                         = {(1,5), (5,8), (8,9), (9,17), (17,13), (13,16), (16,21), (21,24), (4,7), (7,2), (2,12), (12,10), (10,15), (15,20), (20,23), (23,18), (6,3), (3,14), (14,11), (11,22), (22,19)}. The weight of an arc is the processing time of the operation associated to the node o from which it starts, i.e. it depends on the production quantity of product i(o) in period l(o). Note that nonlinear routings could also be considered in our approach as in the general scheduling model introduced in Dauzère-Pérès, Roux, and Lasserre (1998).

Note that, even though there exists a sequence (order of operations) for all items at all periods, the actual schedule (timing of operations) depends on the lot sizes (production quantities). Moreover, any lot size might be set to zero, to avoid a setup cost and setup times, and the duration of the corresponding operations in the schedule will then be equal to zero. Our problem can be seen as an extension of the classical Capacitated Lot-Sizing Problem (CLSP) with setup times which is strongly NP-hard (Chen and Thizy, 1990). Actually, checking that a feasible solution exists for this problem is already NP-Complete (Trigeiro, Thomas, and McClain, 1989).

Various extensions such as backlogging, multiple lots for each product per period or minimum and maximum lot sizes could be handled in the models presented below.

The variables are:

                           
                              •
                              
                                 Xil
                                 : Production quantity (lot size) of item i completed in period l,


                                 Yil
                                 : Setup variable which is equal to 1 if Xil
                                  > 0, and 0 otherwise,


                                 Iil
                                 : Non-negative inventory level of item i at the end of period l,


                                 to
                                 : Start time of operation o of job (io, lo
                                 ).

The following additional parameters are necessary:

                           
                              •
                              
                                 po
                                 : Processing time of operation o per unit of item i(o),


                                 so
                                 : Setup time of operation o,


                                 capal
                                 : Duration of period l (available capacity in the period),


                                 
                                    
                                       c
                                       
                                          i
                                       
                                       p
                                    
                                 : Production cost per unit of item i,


                                 
                                    
                                       c
                                       
                                          i
                                       
                                       
                                          i
                                          n
                                          v
                                       
                                    
                                 : Inventory cost per unit of item i at the end of a period,


                                 
                                    
                                       c
                                       
                                          i
                                       
                                       s
                                    
                                 : Setup cost for item i,


                                 
                                    L
                                 : Set of last operations in the routing of items, i.e. operation 
                                    
                                       o
                                       ∈
                                       L
                                    
                                  if there is no operation 
                                    
                                       
                                          o
                                          ′
                                       
                                       ∈
                                       O
                                    
                                  such that arc 
                                    
                                       (
                                       o
                                       ,
                                       
                                          o
                                          ′
                                       
                                       )
                                       ∈
                                       A
                                       ,
                                    
                                 
                              


                                 
                                    F
                                 : Set of first operations in the routing of items, i.e. operation 
                                    
                                       o
                                       ∈
                                       F
                                    
                                  if there is no operation 
                                    
                                       
                                          o
                                          ′
                                       
                                       ∈
                                       O
                                    
                                  such that arc 
                                    
                                       (
                                       
                                          
                                          ′
                                       
                                       o
                                       ,
                                       o
                                       )
                                       ∈
                                       A
                                    
                                 .

The DPL model with a fixed sequence of operations on the resources, noted M
                        DPL, is as follows:

                           
                              (1)
                              
                                 
                                    Minimize
                                    
                                       ∑
                                       
                                          i
                                          ,
                                          l
                                       
                                    
                                    
                                       c
                                       
                                          i
                                       
                                       p
                                    
                                    
                                       X
                                       
                                          i
                                          l
                                       
                                    
                                    +
                                    
                                       ∑
                                       
                                          i
                                          ,
                                          l
                                       
                                    
                                    
                                       c
                                       
                                          i
                                       
                                       
                                          i
                                          n
                                          v
                                       
                                    
                                    
                                       I
                                       
                                          i
                                          l
                                       
                                    
                                    +
                                    
                                       ∑
                                       
                                          i
                                          ,
                                          l
                                       
                                    
                                    
                                       c
                                       
                                          i
                                       
                                       s
                                    
                                    
                                       Y
                                       
                                          i
                                          l
                                       
                                    
                                 
                              
                           
                        Subject to

                           
                              (2)
                              
                                 
                                    
                                       I
                                       
                                          i
                                          l
                                       
                                    
                                    =
                                    
                                       I
                                       
                                          i
                                          l
                                          −
                                          1
                                       
                                    
                                    +
                                    
                                       X
                                       
                                          i
                                          l
                                       
                                    
                                    −
                                    
                                       D
                                       
                                          i
                                          l
                                       
                                    
                                    
                                    ∀
                                    i
                                    ,
                                    l
                                 
                              
                           
                        
                        
                           
                              (3)
                              
                                 
                                    
                                       t
                                       
                                          o
                                          ′
                                       
                                    
                                    ≥
                                    
                                       t
                                       o
                                    
                                    +
                                    
                                       p
                                       o
                                    
                                    
                                       X
                                       
                                          i
                                          (
                                          o
                                          )
                                          l
                                          (
                                          o
                                          )
                                       
                                    
                                    +
                                    
                                       s
                                       o
                                    
                                    
                                       Y
                                       
                                          i
                                          (
                                          o
                                          )
                                          l
                                          (
                                          o
                                          )
                                       
                                    
                                    
                                    ∀
                                    
                                       (
                                       o
                                       ,
                                       
                                          o
                                          ′
                                       
                                       )
                                    
                                    ∈
                                    A
                                 
                              
                           
                        
                        
                           
                              (4)
                              
                                 
                                    
                                       t
                                       o
                                    
                                    ≥
                                    
                                       t
                                       
                                          o
                                          ′
                                       
                                    
                                    +
                                    
                                       p
                                       
                                          o
                                          ′
                                       
                                    
                                    
                                       X
                                       
                                          i
                                          
                                             (
                                             
                                                o
                                                ′
                                             
                                             )
                                          
                                          l
                                          
                                             (
                                             
                                                o
                                                ′
                                             
                                             )
                                          
                                       
                                    
                                    +
                                    
                                       s
                                       
                                          o
                                          ′
                                       
                                    
                                    
                                       Y
                                       
                                          i
                                          
                                             (
                                             
                                                o
                                                ′
                                             
                                             )
                                          
                                          l
                                          
                                             (
                                             
                                                o
                                                ′
                                             
                                             )
                                          
                                       
                                    
                                    
                                    ∀
                                    
                                       (
                                       o
                                       ,
                                       
                                          o
                                          ′
                                       
                                       )
                                    
                                    ∈
                                    S
                                 
                              
                           
                        
                        
                           
                              (5)
                              
                                 
                                    
                                       t
                                       o
                                    
                                    +
                                    
                                       p
                                       o
                                    
                                    
                                       X
                                       
                                          i
                                          (
                                          o
                                          )
                                          l
                                          (
                                          o
                                          )
                                       
                                    
                                    +
                                    
                                       s
                                       o
                                    
                                    
                                       Y
                                       
                                          i
                                          (
                                          o
                                          )
                                          l
                                          (
                                          o
                                          )
                                       
                                    
                                    ≤
                                    
                                       ∑
                                       
                                          l
                                          =
                                          1
                                       
                                       
                                          l
                                          (
                                          o
                                          )
                                       
                                    
                                    c
                                    a
                                    p
                                    
                                       a
                                       l
                                    
                                    
                                    ∀
                                    o
                                    ∈
                                    L
                                 
                              
                           
                        
                        
                           
                              (6)
                              
                                 
                                    
                                       t
                                       o
                                    
                                    +
                                    
                                       p
                                       o
                                    
                                    
                                       X
                                       
                                          i
                                          (
                                          o
                                          )
                                          l
                                          (
                                          o
                                          )
                                       
                                    
                                    +
                                    
                                       s
                                       o
                                    
                                    
                                       Y
                                       
                                          i
                                          (
                                          o
                                          )
                                          l
                                          (
                                          o
                                          )
                                       
                                    
                                    ≥
                                    
                                       ∑
                                       
                                          l
                                          =
                                          1
                                       
                                       
                                          l
                                          (
                                          o
                                          )
                                          −
                                          1
                                       
                                    
                                    c
                                    a
                                    p
                                    
                                       a
                                       l
                                    
                                    
                                    ∀
                                    o
                                    ∈
                                    L
                                 
                              
                           
                        
                        
                           
                              (7)
                              
                                 
                                    
                                       X
                                       
                                          i
                                          l
                                       
                                    
                                    ≤
                                    
                                       (
                                       
                                          ∑
                                          
                                             k
                                             =
                                             1
                                          
                                          T
                                       
                                       
                                          D
                                          
                                             i
                                             k
                                          
                                       
                                       )
                                    
                                    
                                       Y
                                       
                                          i
                                          l
                                       
                                    
                                    
                                    ∀
                                    i
                                    ,
                                    l
                                 
                              
                           
                        
                        
                           
                              (8)
                              
                                 
                                    
                                       X
                                       
                                          i
                                          l
                                       
                                    
                                    ,
                                    
                                    
                                       I
                                       
                                          i
                                          l
                                       
                                    
                                    ≥
                                    0
                                    
                                    ∀
                                    i
                                    ,
                                    l
                                 
                              
                           
                        
                        
                           
                              (9)
                              
                                 
                                    
                                       Y
                                       
                                          i
                                          l
                                       
                                    
                                    ∈
                                    
                                       {
                                       0
                                       ,
                                       1
                                       }
                                    
                                    
                                    ∀
                                    i
                                    ,
                                    l
                                 
                              
                           
                        
                        
                           
                              (10)
                              
                                 
                                    
                                       t
                                       o
                                    
                                    ≥
                                    0
                                    
                                    ∀
                                    o
                                 
                              
                           
                        The objective function (1) minimizes the total cost. Constraints (2) are the inventory balance equations. Constraints (3) are the conjunctive constraints between operations in the routings, and constraints (4) the conjunctive constraints between operations sequenced on the same resources. Constraints (5) ensure that production quantity Xil
                         is completed before the end of period l, and constraints (6) that it is not completed before the start of period l. 
                           
                              
                                 ∑
                                 
                                    l
                                    =
                                    1
                                 
                                 
                                    l
                                    (
                                    o
                                    )
                                 
                              
                              c
                              a
                              p
                              
                                 a
                                 l
                              
                           
                         can be seen as the due date of operation 
                           
                              o
                              ∈
                              L
                              ,
                           
                         and 
                           
                              
                                 ∑
                                 
                                    l
                                    =
                                    1
                                 
                                 
                                    l
                                    (
                                    o
                                    )
                                    −
                                    1
                                 
                              
                              c
                              a
                              p
                              
                                 a
                                 l
                              
                           
                         as its release date. Constraints (7) link the continuous production variables X to the binary setup variables Y.

We propose a new model equivalent to M
                        DPL by modeling paths of the conjunctive graph associated with the fixed sequence. The makespan of a feasible schedule is equal to the length of the longest paths in the graph. In order to meet deadlines, i.e. to complete a production quantity in its period, the last operation of each path must be completed before its due date. Hence, the sum of processing and setup times of all operations in a path must not exceed the due date of the last operation of this path. And this must be true for all paths of the graph. These constraints can be seen as capacity constraints. Constraints of the model M
                        DPL are thus modified.

Let us introduce the following notation:

                           
                              •
                              
                                 
                                    C
                                 : Set of all paths in the conjunctive graph associated with the fixed sequence of operations,


                                 
                                    
                                       o
                                       
                                          c
                                       
                                       f
                                    
                                  and 
                                    
                                       o
                                       
                                          c
                                       
                                       l
                                    
                                 : Respectively the first and last operations of path c,


                                 r(o): Parameter associated to operation o, defined as:

                                    
                                       (11)
                                       
                                          
                                             r
                                             
                                                (
                                                o
                                                )
                                             
                                             =
                                             
                                                ∑
                                                
                                                   l
                                                   =
                                                   1
                                                
                                                
                                                   l
                                                   (
                                                   o
                                                   )
                                                   −
                                                   1
                                                
                                             
                                             c
                                             a
                                             p
                                             
                                                a
                                                l
                                             
                                             
                                             ∀
                                             o
                                             ∈
                                             L
                                          
                                       
                                    
                                 
                                 
                                    
                                       (12)
                                       
                                          
                                             r
                                             (
                                             o
                                             )
                                             =
                                             0
                                             
                                             ∀
                                             o
                                             ∉
                                             L
                                          
                                       
                                    
                                 
                              

The parameter r(o) can be seen as the release date of operation o, and is determined to satisfy the constraints of model M
                        DPL as described below.

Here are three examples of paths in 
                           C
                         in the graph of Fig. 1: (1, 2, 12, 13), (6, 3, 14, 15, 16, 21, 24) and (12, 10, 11, 22, 23, 18, 19).

An important assumption is that the last operation o of each path finishes in period l(o) (this is guaranteed by constraints (5) and (6) in M
                        DPL). This assumption is used to ensure consistency by avoiding inventory costs that will be ignored in the objective function. Indeed, if the last operation of the path finishes in period l(o) − 1, then it would be necessary to consider the inventory cost for period l(o).

Constraints of model M
                        DPL are modified as follows:

                           
                              •
                              The objective function (1), constraints (2) and (7) to (9) remain unchanged.

Constraints (3) and (4) are deleted because they are guaranteed by definition of the paths of the graph.

Constraints (6) are guaranteed by the choice of the values of r(o), i.e. by constraints (11).

Constraints (5) are replaced by:

                                    
                                       
                                          
                                             r
                                             
                                                (
                                                
                                                   o
                                                   
                                                      c
                                                   
                                                   f
                                                
                                                )
                                             
                                             +
                                             
                                                ∑
                                                
                                                   o
                                                   ∈
                                                   c
                                                
                                             
                                             
                                                (
                                                
                                                   p
                                                   o
                                                
                                                
                                                   X
                                                   
                                                      i
                                                      (
                                                      o
                                                      )
                                                      l
                                                      (
                                                      o
                                                      )
                                                   
                                                
                                                +
                                                
                                                   s
                                                   o
                                                
                                                
                                                   Y
                                                   
                                                      i
                                                      (
                                                      o
                                                      )
                                                      l
                                                      (
                                                      o
                                                      )
                                                   
                                                
                                                )
                                             
                                             ≤
                                             
                                                ∑
                                                
                                                   l
                                                   =
                                                   1
                                                
                                                
                                                   l
                                                   (
                                                   
                                                      o
                                                      
                                                         c
                                                      
                                                      l
                                                   
                                                   )
                                                
                                             
                                             c
                                             a
                                             p
                                             
                                                a
                                                l
                                             
                                             
                                             ∀
                                             c
                                             ∈
                                             C
                                             
                                             
                                                (
                                                15
                                                )
                                             
                                          
                                       
                                    
                                 
                              

We obtain the following model, denoted by M
                        CG:

                           
                              (13)
                              
                                 
                                    Minimize
                                    
                                       ∑
                                       
                                          i
                                          ,
                                          l
                                       
                                    
                                    
                                       c
                                       
                                          i
                                       
                                       p
                                    
                                    
                                       X
                                       
                                          i
                                          l
                                       
                                    
                                    +
                                    
                                       ∑
                                       
                                          i
                                          ,
                                          l
                                       
                                    
                                    
                                       c
                                       
                                          i
                                       
                                       
                                          i
                                          n
                                          v
                                       
                                    
                                    
                                       I
                                       
                                          i
                                          l
                                       
                                    
                                    +
                                    
                                       ∑
                                       
                                          i
                                          ,
                                          l
                                       
                                    
                                    
                                       c
                                       
                                          i
                                       
                                       s
                                    
                                    
                                       Y
                                       
                                          i
                                          l
                                       
                                    
                                 
                              
                           
                        Subject to

                           
                              (14)
                              
                                 
                                    
                                       I
                                       
                                          i
                                          l
                                       
                                    
                                    =
                                    
                                       I
                                       
                                          i
                                          l
                                          −
                                          1
                                       
                                    
                                    +
                                    
                                       X
                                       
                                          i
                                          l
                                       
                                    
                                    −
                                    
                                       D
                                       
                                          i
                                          l
                                       
                                    
                                    
                                    ∀
                                    i
                                    ,
                                    l
                                 
                              
                           
                        
                        
                           
                              (15)
                              
                                 
                                    r
                                    
                                       (
                                       
                                          o
                                          
                                             c
                                          
                                          f
                                       
                                       )
                                    
                                    +
                                    
                                       ∑
                                       
                                          o
                                          ∈
                                          c
                                       
                                    
                                    
                                       (
                                       
                                          p
                                          o
                                       
                                       
                                          X
                                          
                                             i
                                             (
                                             o
                                             )
                                             l
                                             (
                                             o
                                             )
                                          
                                       
                                       +
                                       
                                          s
                                          o
                                       
                                       
                                          Y
                                          
                                             i
                                             (
                                             o
                                             )
                                             l
                                             (
                                             o
                                             )
                                          
                                       
                                       )
                                    
                                    ≤
                                    
                                       ∑
                                       
                                          l
                                          =
                                          1
                                       
                                       
                                          l
                                          (
                                          
                                             o
                                             
                                                c
                                             
                                             l
                                          
                                          )
                                       
                                    
                                    c
                                    a
                                    p
                                    
                                       a
                                       l
                                    
                                    
                                    ∀
                                    c
                                    ∈
                                    C
                                 
                              
                           
                        
                        
                           
                              (16)
                              
                                 
                                    
                                       X
                                       
                                          i
                                          l
                                       
                                    
                                    ≤
                                    
                                       (
                                       
                                          ∑
                                          
                                             k
                                             =
                                             1
                                          
                                          T
                                       
                                       
                                          D
                                          
                                             i
                                             k
                                          
                                       
                                       )
                                    
                                    
                                       Y
                                       
                                          i
                                          l
                                       
                                    
                                    
                                    ∀
                                    i
                                    ,
                                    l
                                 
                              
                           
                        
                        
                           
                              (17)
                              
                                 
                                    
                                       X
                                       
                                          i
                                          l
                                       
                                    
                                    ,
                                    
                                       I
                                       
                                          i
                                          l
                                       
                                    
                                    ≥
                                    0
                                    
                                    ∀
                                    i
                                    ,
                                    l
                                 
                              
                           
                        
                        
                           
                              (18)
                              
                                 
                                    
                                       Y
                                       
                                          i
                                          l
                                       
                                    
                                    ∈
                                    
                                       {
                                       0
                                       ,
                                       1
                                       }
                                    
                                    
                                    ∀
                                    i
                                    ,
                                    l
                                 
                              
                           
                        Constraints (15) ensure that the last operation 
                           
                              o
                              
                                 c
                              
                              l
                           
                         in each path 
                           
                              c
                              ∈
                              C
                           
                         is completed before the end of its associated period 
                           
                              l
                              (
                              
                                 o
                                 
                                    c
                                 
                                 l
                              
                              )
                           
                        . Hence, only the constraints associated to paths 
                           
                              c
                              ∈
                              C
                           
                         such that 
                           
                              
                                 o
                                 
                                    c
                                 
                                 l
                              
                              ∈
                              L
                           
                         need to be considered.

Note that this model has one difference with model M
                        DPL. In M
                        CG, we assume that the last operation starts and finishes during the last period while, in M
                        DPL, the last operation only has to finish during the last period. This implies, because it is more constrained, that the optimal solution of M
                        CG could be larger than or (most often) equal to the one of M
                        DPL. This is why, to prevent this problem, constraints (6) are replaced by the following constraints in the numerical experiments of Section 4:

                           
                              (19)
                              
                                 
                                    
                                       
                                          
                                             
                                                t
                                                o
                                             
                                             ≥
                                             
                                                ∑
                                                
                                                   l
                                                   =
                                                   1
                                                
                                                
                                                   l
                                                   (
                                                   o
                                                   )
                                                   −
                                                   1
                                                
                                             
                                             c
                                             a
                                             p
                                             
                                                a
                                                l
                                             
                                             
                                             ∀
                                             o
                                             ∈
                                             L
                                          
                                       
                                    
                                 
                              
                           
                        
                     

Lagrangian relaxation (Fisher, 1981; Lemaréchal, 2001) aims at decomposing an optimization problem into a number of easier-to-solve subproblems by dualizing some complicating constraints. Many lot-sizing problems have been solved using Lagrangian relaxation (Diaby, Bahl, Karwan, and Zionts, 1992; Ozdamar and Barbarosoglu, 2000; Tempelmeier and Derstroff, 1996; Thizy and Van Wassenhove, 1985; Trigeiro et al., 1989).

Applying Lagrangian relaxation to solve our problem is justified by the fact that our mathematical model M
                     CG is an extension of the classical model of the Capacitated Lot-Sizing Problem (CLSP), except that there are much more capacity constraints (15), since they correspond to paths of a conjunctive graph, than the number (T, one per period) of capacity constraints in the CLSP. Since the number of constraints (15) is exponential, it is not possible to consider them simultaneously as for instance in the Lagrangian heuristic proposed in Thizy and Van Wassenhove (1985) and Trigeiro et al. (1989) for the classical CLSP. As it is explained in Section 3.3, we thus initialize all multipliers to zero and choose a set of multipliers to increase among the set of the most violated constraints. This method allows only the most relevant constraints to be handled, and the number of these constraints is never very large in our numerical experiments. Note that applying Lagrangian relaxation on model M
                     DPL is not interesting, in particular because of the variables to
                      that are determined independently of the variables Xil
                      and Yil
                      in the relaxed problems. We actually investigated this alternative before proposing model M
                     CG.

The general Lagrangean relaxation methodology can be summarized as follows:

                        
                           1.
                           Initialization of Lagrangian multipliers;

Resolution of the relaxed problem and update of the lower bound;

Construction of a feasible solution and update of the upper bound;

Update of Lagrangian multipliers by using subgradient optimization;

If stopping conditions are not met, go to Step 2, otherwise STOP.

The capacity constraints (15) of M
                     CG are relaxed into the objective function (13) with Lagrangian multipliers uc
                     . The resulting problem can then be decomposed into a set of independent uncapacitated single-item lot-sizing problems, each one can be solved in O(Tlog T) time (Aggarwal and Park, 1993; Federgruen and Tzur, 1991; Wagelmans, van Hoesel, and Kolen, 1992). The solutions of these subproblems are used to compute a lower bound on the optimal solution of M
                     CG. Since there is no guarantee that the Lagrangian solution is feasible, a procedure is applied to construct a feasible solution from the optimal solution of the relaxed problem. Finally, Lagrangian multipliers associated with the most violated constraints are updated using subgradient optimization.

The Lagrangian function is:

                           
                              (20)
                              
                                 
                                    
                                       
                                          
                                             Minimize
                                             
                                                ∑
                                                
                                                   i
                                                   ,
                                                   l
                                                
                                             
                                             
                                             
                                                (
                                                
                                                
                                                   c
                                                   
                                                      i
                                                   
                                                   p
                                                
                                                +
                                                
                                                   ∑
                                                   
                                                      c
                                                      ∈
                                                      C
                                                   
                                                
                                                
                                                   ∑
                                                   
                                                      
                                                         
                                                            
                                                               o
                                                               ∈
                                                               c
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               i
                                                               (
                                                               o
                                                               )
                                                               =
                                                               i
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               l
                                                               (
                                                               o
                                                               )
                                                               =
                                                               l
                                                            
                                                         
                                                      
                                                   
                                                
                                                
                                                   u
                                                   c
                                                
                                                
                                                   p
                                                   o
                                                
                                                
                                                )
                                             
                                             
                                             
                                                X
                                                
                                                   i
                                                   l
                                                
                                             
                                          
                                       
                                       
                                          +
                                       
                                       
                                          
                                             
                                                ∑
                                                
                                                   i
                                                   ,
                                                   l
                                                
                                             
                                             
                                             
                                                (
                                                
                                                
                                                   c
                                                   
                                                      i
                                                   
                                                   s
                                                
                                                +
                                                
                                                   ∑
                                                   
                                                      c
                                                      ∈
                                                      C
                                                   
                                                
                                                
                                                   ∑
                                                   
                                                      
                                                         
                                                            
                                                               o
                                                               ∈
                                                               c
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               i
                                                               (
                                                               o
                                                               )
                                                               =
                                                               i
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               l
                                                               (
                                                               o
                                                               )
                                                               =
                                                               l
                                                            
                                                         
                                                      
                                                   
                                                
                                                
                                                   u
                                                   c
                                                
                                                
                                                   s
                                                   
                                                      o
                                                   
                                                   t
                                                
                                                
                                                )
                                             
                                             
                                             
                                                Y
                                                
                                                   i
                                                   l
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                          +
                                       
                                       
                                          
                                             
                                                ∑
                                                
                                                   i
                                                   ,
                                                   l
                                                
                                             
                                             
                                                c
                                                
                                                   i
                                                
                                                
                                                   i
                                                   n
                                                   v
                                                
                                             
                                             
                                                I
                                                
                                                   i
                                                   l
                                                
                                             
                                             +
                                             C
                                          
                                       
                                    
                                 
                              
                           
                        with 
                           
                              C
                              =
                              
                                 ∑
                                 
                                    c
                                    ∈
                                    C
                                 
                              
                              
                                 (
                                 
                                    u
                                    c
                                 
                                 r
                                 
                                    (
                                    
                                       o
                                       
                                          c
                                       
                                       f
                                    
                                    )
                                 
                                 −
                                 
                                    u
                                    c
                                 
                                 
                                    ∑
                                    
                                       l
                                       =
                                       1
                                    
                                    
                                       l
                                       (
                                       
                                          o
                                          
                                             c
                                          
                                          l
                                       
                                       )
                                    
                                 
                                 c
                                 a
                                 p
                                 
                                    a
                                    l
                                 
                                 )
                              
                           
                        .

Thus, for Lagrangian multipliers uc
                         ≥ 0, 
                           
                              ∀
                              c
                              ∈
                              C
                              ,
                           
                         the relaxed model corresponds to objective function (20) and constraints (14), (16), (17) and (18). Note that, to ignore a path c of 
                           C
                         in (20), and thus in the relaxed model, it suffices to set its corresponding Lagrangian multiplier uc
                         to zero. This is why all Lagrangian multipliers are initialized to zero in the heuristic (see Section 3.3).

This relaxed problem is decomposed into N classical uncapacitated single-item problems. Each problem can be solved using the Wagner–Within algorithm (Wagner and Whitin, 1958) in O(T
                        2) time (where T is the number of periods). The computational complexity was improved to O(Tlog T) by Wagelmans et al. (1992). Their algorithm is efficient and easy to implement.

Since there is no guarantee that the Lagrangian solution satisfies the relaxed capacity constraints, we designed a procedure which modifies the solution to satisfy the violated constraints.

In classical lot-sizing problems, increasing or decreasing lot sizes in one period has no impact on the feasibility in other periods. Thus, most smoothing heuristics in Lagrangian relaxation approaches proposed in the literature (Trigeiro et al., 1989 for instance) successively transfer product quantities between lots in two different periods until a feasible solution is found. For each transfer, only the impacts on the two periods need to be measured. In our integrated problem, increasing or decreasing lot sizes in one period may influence the feasibility in all successive periods since the schedule considers lots on the entire horizon. Hence, it is necessary to develop different and more complex smoothing heuristics.

Let us recall that a solution is feasible if capacity constraints (15) in Model M
                        CG are satisfied. In the sequel, a path 
                           
                              c
                              ∈
                              C
                           
                         is called violated if its associated constraint (15) is violated, i.e. the length of the path is strictly larger than the sum of capacities from the first period to the period of the last operation in the path. Only reducing the size of production lots having at least one violated operation (operations belonging to a violated path) can help satisfying violated constraints.

Thus, we first search for violated paths to determine the potential products to shift and periods from where to transfer. For each node (or operation) of the graph, the earliest start time, latest start time and slack time (the time between its earliest and latest start times) are calculated. A violated path is thus a path with operations with zero slack times. The violated paths are not explicitly enumerated and only violated operations are listed when computing the longest paths in the conjunctive graph.

We propose two procedures to determine the product to shift, the origin and destination periods and the quantity to transfer. The first procedure is done by backward and forward shifting production on the planning horizon. For a given origin period t, the product to shift is the product with the largest sum of processing times of violated operations that must be completed before the end of period t. The destination period is the period with the smallest sum of processing times of violated operations. The quantity to transfer is calculated based on the slack time associated to the product to shift and the destination period.

The procedure stops when there are no more violating paths or if no product quantity is moved after four passes. Note that, in this last case, no feasible solution is found by the procedure. A drawback of this method is that the number of backward and forward shifting passes may be large and the construction of a feasible solution can be very time consuming.

The second and more original procedure searches for the item and the origin period with the largest sum of processing times of violated operations. The origin period might be anywhere on the planning horizon. The destination period must not have violated operations, and the quantity to transfer is chosen to minimize the objective function. Let 
                           
                              O
                              c
                           
                         be the set of violated operations and 
                           
                              
                                 P
                                 R
                              
                              c
                           
                         be the set of violated combinations of product and period i.e. (p, t) such that 
                           
                              ∃
                              o
                              ∈
                              
                                 O
                                 c
                              
                           
                         with i(o) = p and l(o) = t. The procedure is detailed below.

                           
                              •
                              While capacities constraints are not satisfied or no product in 
                                    
                                       
                                          P
                                          R
                                       
                                       c
                                    
                                  can be found:

                                    
                                       1.
                                       Determine 
                                             
                                                O
                                                c
                                             
                                           and 
                                             
                                                
                                                   P
                                                   R
                                                
                                                c
                                             
                                          .


                                          Product to shift and origin period.
We search for the combination (product, period) with the largest sum of processing times of its critical operations, i.e. the product ps and period to that maximize

                                             
                                                
                                                   
                                                      
                                                         max
                                                         
                                                            
                                                               (
                                                               p
                                                               ,
                                                               t
                                                               )
                                                            
                                                            ∈
                                                            
                                                               
                                                                  P
                                                                  R
                                                               
                                                               c
                                                            
                                                         
                                                      
                                                      
                                                         ∑
                                                         
                                                            
                                                               
                                                                  
                                                                     o
                                                                     ∈
                                                                     
                                                                        O
                                                                        c
                                                                     
                                                                     ;
                                                                  
                                                               
                                                            
                                                            
                                                               
                                                                  
                                                                     i
                                                                     (
                                                                     o
                                                                     )
                                                                     =
                                                                     p
                                                                     a
                                                                     n
                                                                     d
                                                                     l
                                                                     (
                                                                     o
                                                                     )
                                                                     =
                                                                     t
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                      
                                                         (
                                                         
                                                            p
                                                            o
                                                         
                                                         
                                                            X
                                                            
                                                               i
                                                               (
                                                               o
                                                               )
                                                               l
                                                               (
                                                               o
                                                               )
                                                            
                                                         
                                                         +
                                                         
                                                            s
                                                            o
                                                         
                                                         
                                                            Y
                                                            
                                                               i
                                                               (
                                                               o
                                                               )
                                                               l
                                                               (
                                                               o
                                                               )
                                                            
                                                         
                                                         )
                                                      
                                                      .
                                                   
                                                
                                             
                                          If no product is found then the procedure is stopped, else 
                                             
                                                
                                                   
                                                      P
                                                      R
                                                   
                                                   c
                                                
                                                =
                                                
                                                   
                                                      P
                                                      R
                                                   
                                                   c
                                                
                                                −
                                                
                                                   {
                                                   
                                                      (
                                                      p
                                                      s
                                                      ,
                                                      t
                                                      o
                                                      )
                                                   
                                                   }
                                                
                                             
                                          .


                                          Destination period. We select the period td (td ≠ to) with no violated operations for product ps and for which the transfer improves the most the objective function, i.e. the period t that maximizes the transfer gain per product unit G(ps, to, t) defined below:

                                             
                                                
                                                   
                                                      G
                                                      
                                                         (
                                                         p
                                                         s
                                                         ,
                                                         t
                                                         o
                                                         ,
                                                         t
                                                         )
                                                      
                                                      =
                                                      
                                                         
                                                            
                                                               cost
                                                               before
                                                            
                                                            −
                                                            
                                                               cost
                                                               after
                                                            
                                                         
                                                         
                                                            
                                                               Q
                                                               s
                                                            
                                                            
                                                               (
                                                               p
                                                               s
                                                               ,
                                                               t
                                                               )
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          where Qs
                                          (ps, t) is the maximum quantity of product ps that can be transferred to period t while keeping the operations of product ps at period t not more violated (using the slack time), costbefore is the total cost before the transfer and costafter is the total cost after the transfer of Qs
                                          (ps, t) from to to t.

If td does not exist (i.e. all periods have violated operations for product ps) then go to Step 2.


                                          Quantity to transfer. The quantity to transfer is min {X
                                          
                                             ps, to
                                          , Qs
                                          (ps, td)} (we cannot transfer more than the production quantity associated to period to).

The procedure stops when there is no more violated paths or if no product to move is found. In this last case, no feasible solution is found by the procedure.

Considering the two most violated paths {9, 10, 15, 16, 21, 24} and {9, 10, 15, 20, 21, 24} shown in bold in the example of Fig. 2
                        , 
                           
                              
                                 O
                                 c
                              
                              
                                 =
                                 {
                                 9
                                 ,
                                 10
                                 ,
                                 15
                                 ,
                                 16
                                 ,
                                 20
                                 ,
                              
                           
                         21, 24} and 
                           
                              
                                 
                                    P
                                    R
                                 
                                 c
                              
                              =
                              
                                 {
                                 
                                    (
                                    1
                                    ,
                                    2
                                    )
                                 
                                 ,
                                 
                                    (
                                    3
                                    ,
                                    2
                                    )
                                 
                                 ,
                                 
                                    (
                                    2
                                    ,
                                    3
                                    )
                                 
                                 ,
                                 
                                    (
                                    3
                                    ,
                                    3
                                    )
                                 
                                 }
                              
                           
                        . Hence, the product to shift and origin period will be chosen in 
                           
                              
                                 P
                                 R
                              
                              c
                           
                        . For example, if product 1 is selected with period 2 (the only possible origin period), then the destination period can be periods 1 or 3. If product 3 is selected with period 3 (the possible origin periods are periods 2 and 3), then the only destination period is period 1.

We used and compared the two procedures in the Lagrangian heuristic on 210 instances. The second procedure is faster and provides better upper bounds consistently.

For example, the Lagrangian heuristic with the second procedure finds a feasible solution of 29,078 in 15.2 seconds while, with the first procedure, the Lagrangian heuristic finds a feasible solution of 33,835 in 31.1 seconds. Moreover, a feasible solution cannot be found for 26 instances when the first procedure is used while the Lagrangian heuristic fails in only one case with the second procedure. This is why only the second procedure is used in the computational experiments of Section 4.

The updating of Lagrangian multipliers is done using subgradient optimization (Minoux, 1983), which is easy to implement and does not depend on the problem to be solved.

Since the number of relaxed constraints is huge, we do not update all Lagrangian multipliers. Only the most relevant constraints are considered, i.e. the constraints associated to the most violated paths in the graph. Let 
                           
                              C
                              H
                           
                         be the set of violated paths.

The steps of the Lagrangian multiplier updating procedure are:

                           
                              •
                              Initialization of all multipliers to 0 and 
                                    
                                       
                                          C
                                          H
                                       
                                       =
                                       ⌀
                                    
                                 ;

At each iteration:

                                    
                                       1.
                                       Search for the most violated path in the graph, i.e. a path 
                                             
                                                c
                                                v
                                                ∈
                                                C
                                             
                                           that maximizes:

                                             
                                                
                                                   
                                                      r
                                                      
                                                         (
                                                         
                                                            o
                                                            
                                                               c
                                                            
                                                            f
                                                         
                                                         )
                                                      
                                                      +
                                                      
                                                         ∑
                                                         
                                                            o
                                                            ∈
                                                            c
                                                         
                                                      
                                                      
                                                         (
                                                         
                                                            p
                                                            o
                                                         
                                                         
                                                            X
                                                            
                                                               i
                                                               (
                                                               o
                                                               )
                                                               l
                                                               (
                                                               o
                                                               )
                                                            
                                                         
                                                         +
                                                         
                                                            s
                                                            o
                                                         
                                                         
                                                            Y
                                                            
                                                               i
                                                               (
                                                               o
                                                               )
                                                               l
                                                               (
                                                               o
                                                               )
                                                            
                                                         
                                                         )
                                                      
                                                      −
                                                      
                                                         ∑
                                                         
                                                            l
                                                            =
                                                            1
                                                         
                                                         
                                                            l
                                                            (
                                                            
                                                               o
                                                               
                                                                  c
                                                               
                                                               l
                                                            
                                                            )
                                                         
                                                      
                                                      c
                                                      a
                                                      p
                                                      
                                                         a
                                                         l
                                                      
                                                   
                                                
                                             
                                          
                                       

If 
                                             
                                                c
                                                v
                                                ∉
                                                
                                                   C
                                                   H
                                                
                                             
                                           then 
                                             
                                                
                                                   C
                                                   H
                                                
                                                =
                                                
                                                   C
                                                   H
                                                
                                                ∪
                                                {
                                                c
                                                v
                                                }
                                             
                                          ;

Update the Lagrangian multipliers uc
                                           for the paths in 
                                             
                                                c
                                                ∈
                                                
                                                   C
                                                   H
                                                
                                             
                                           using the following step size at iteration k: λk
                                           = δk
                                          (UB − LB(uk
                                          )), where UB is the best upper bound found so far, uk
                                           is the array of Lagrangian multipliers at iteration k for all paths in 
                                             
                                                C
                                                H
                                             
                                           and LB(uk
                                          ) is the associated Lagrangian lower bound.

The parameter δk
                                           is divided by two if the Lagrangian lower bound has not increased for the last 15 iterations.

At the end of the algorithm, the number of constraints actually taken into account is not large. In our computational experiments, this number is never larger than 43.

The performance of the proposed algorithm was evaluated on a set of instances. All numerical tests were done on a personal computer with a Pentium Xeon 3.2 gigahertz CPU. We used the standard optimization software XPRESS-MP, to solve the integer linear programming model M
                     DPL with constraints (19) instead of (6).

In order to test the quality of our Lagrangian heuristic, we randomly generated problems with uniform distribution and for which several parameters were varied: Demand, capacity and setup cost. The behavior of the algorithm was tested using the following parameters:


                        Number of products: Instances with 6, 10 and 20 products were generated.


                        Horizon length: Instances with 20 periods were generated to test the quality of the solution, and instances with 30 and 50 periods were generated to test CPU times.


                        Demand variability: For each item, the default demand value is chosen in the interval [5,15]. In order to test our procedure, the value of this parameter is made either small (for example 4) or large (for example 100). We chose small intervals (such as [4,8]) to test homogeneous demands for all products and, on the opposite, large intervals (such as [10,100]) to test very different demands. The different intervals are: [4,8], [5,30], [10,50], [10,80] and [10,100].


                        Capacity Tightness: The required capacity is computed for each period from the processing times, setup times and demands. The available capacity is then set by multiplying it (identically for all periods) by an average utilization of 0.45 (tight), 0.55 (normal) or 0.7 (large). The default average utilization is 0.55.


                        Production and holding costs: These parameters are identical for all products. The production cost is equal to 4 and the holding cost to 1.


                        Setup cost: This parameter significantly influences lot sizes. This cost is varied from 5 to 100. The default value is 15.


                        Scheduling parameters: In our experiments, we consider the job shop scheduling problem (Jain and Meeran, 1999) since it is one of the most studied problem in the scheduling literature. We use the well-known 6 × 6 (6 jobs and 6 resources), 10 × 10 (10 jobs and 10 resources) and 20 × 5 (20 jobs and 5 resources) instances of Fisher and Thompson (Fisher and Thompson, 1963). The processing times per unit of item are the processing times in Fisher and Thompson (1963) and the setup times of all operations are set to 10.

For each set of parameters, five instances were generated and tested. Since the results were consistent, only the results of one instance per set of parameters are provided and analyzed in the following section.

@&#EXPERIMENTAL RESULTS@&#

Lagrangian parameters are determined empirically. The initial step size is equal to 3 and is divided by 2 if the lower bound is not improved after 5 iterations. The algorithm is stopped after at most 400 iterations.

For each instance, we give the lower bound (LB) and the upper bound (UB). The solution quality is measured by computing the dual gap defined by Millar and Yang (1994):

                           
                              
                                 
                                    gap
                                    =
                                    200
                                    ×
                                    
                                       
                                          UB
                                          −
                                          LB
                                       
                                       
                                          UB
                                          +
                                          LB
                                       
                                    
                                 
                              
                           
                        This formulation is used instead of 
                           
                              (
                              100
                              ×
                              
                                 
                                    UB
                                    −
                                    LB
                                 
                                 UB
                              
                              )
                           
                         which overestimates the gap quality and 
                           
                              (
                              100
                              ×
                              
                                 
                                    UB
                                    −
                                    LB
                                 
                                 LB
                              
                              )
                           
                         which underestimates it.

The quality of our solutions is checked by comparing with the results of the standard solver XPRESS-MP. It was run for different maximum computing times: 10 seconds, 10 minutes and 10 hours for each problem. Only instances that were not solved optimally in 10 seconds are run for 10 minutes, and only instances not solved optimally for 10 minutes were run for 10 hours. Note that if XPRESS-MP starts a final iteration just before the time limit, it waits until the iteration is completed before exiting. We give the lower bound and the best solution obtained by the standard solver.

For each instance, we compare the lower bound, the upper bound, the gap and the CPU time of the Lagrangian heuristic. When a bound is better than or equal to the one obtained with the other method, it is boldfaced and when an optimal solution is found, it is shown with an asterisk (*).


                           Table 1
                            compares the results between the Lagrangian heuristic and the standard solver when the demand varies in the intervals [4,8], [5,15], [5,30], [10,50], [10,80] and [10,100]. When the standard solver is stopped after a maximum CPU time of 10 seconds, the number of optimal solutions found by the Lagrangian heuristic is 38 out of 54 instances. This number is equal to 36 when the problems are solved with the standard solver. When optimal solutions are found, our procedure is faster and its CPU time does not exceed 0.1 seconds.

For the other instances, when the horizon length is small (5 or 10 periods), the standard solver gives better results than our procedure but the results are improved by the Lagrangian heuristic when the demand varies in the intervals [4,8] and [5,15]. Indeed, the gap does not exceed 2.9 percent whereas, for some instances, the gap with the standard solver is 23.1 percent. Note that the lower the demand is, the higher is the gap. This is due to the capacity calculation which takes into account demands. When demands are small, the capacity is also small and thus it becomes more difficult to satisfy capacity constraints.

Looking at Table 1 when the standard solver is stopped after a maximum of 10 minutes, and only on instances not solved optimally in 10 seconds, the results show the efficiency of our procedure. Indeed, the lower and upper bounds of the Lagrangian heuristic are good and obtained faster when the horizon is larger than or equal to T = 20 for the 10 × 10 and 20 × 5 job-shop cases.

To investigate the problem difficulty, the standard solver was run for a maximum of 10 hours on instances not solved optimally in 10 minutes. For the 10 × 10 and 20 × 5 job-shop cases, when T = 50 and the demands vary in the interval [4,8], the gap for the standard solver is around 10 percent whereas the gap of the Lagrangian heuristic obtained in less than 0.2 seconds is around 0.1 percent. We also observe that the gap does not decrease as compared to the results of the standard solver stopped after 10 minutes. This results confirm that the standard solver cannot solve some instances efficiently.


                           Table 2
                            shows the results when capacity tightness varies from 0.45 (tight) to 0.70 (large). Note that, when the standard solver is stopped after a maximum CPU time of 10 seconds, the Lagrangian heuristic solves to optimality 23 out of 45 instances and that this number is reduced to 1 for the standard solver. In particular, in the 10 × 10 and 20 × 5 job-shop cases, 22 out of 30 instances were solved to optimally with our procedure whereas no optimal solution is found by the standard solver. There is only one instance (6 × 6 job-shop with T = 30 case) where our procedure did not find a feasible solution. The analysis of the results shows that the Lagrangian heuristic outperforms the solver when the instances become very large. Indeed, in the 10 × 10 and 20 × 5 job-shop cases for T = 20–50, the lower and upper bounds of our approach are better.

The CPU time required by the Lagrangian heuristic does not exceed 7 seconds. Note that the solution quality becomes better as the capacity is tight. This is because there are more violated constraints when capacity decreases. This is also true for the solution obtained by the standard solver for the 6 × 6 and 10 × 10 job-shop cases when T = 20. For 10 × 10 job-shop cases and T = 30 and 50, and 20 × 5 job-shop cases and T = 20–50, the gap of the standard solver is stable, which means that even if the capacity is large, problems are difficult to solve. This last remark is confirmed when the standard solver is stopped after a maximum CPU time of 10 minutes, since it solves to optimality 6 out of 43 instances. The results obtained with our approach are better in most cases. However, note that for 6 × 6 job-shop instances, the upper bound of the standard solver is better than the one of the Lagrangian heuristic. In some cases, in particular when capacity is tight, the upper bound of the Lagrangian heuristic is rather bad. For example, for the 6 × 6 job-shop and T = 20 case, the value of the upper bound is 6417 and the upper bound obtained by the standard solver is equal to 6364. This result shows that improvements could still be done in the construction of a feasible solution.

The quality of our results is confirmed when a maximum CPU time of 10 hours is allowed for the standard solver, since the lower bounds of our approach remain better in most of the instances and the upper bounds are better for the 10 × 10 and 20 × 5 job-shop cases. Also, the solutions obtained by the standard solver ran for a maximum of 10 minutes and 10 hours are quite similar.

Note that the lower bound obtained by Lagrangian relaxation is the same for all values of the capacity tightness for a given type of instances. This is because the initial lower bound, obtained when all Lagrangian multipliers are equal to zero, is not improved in the Lagrangian heuristic. This is not the case when the demand is varied (Section 4.2.1) or when the setup cost is varied (Section 4.2.3).


                           Table 3
                            shows the results when setup cost varies from 5 to 100, and the horizon length varies from 5 to 50. The analysis of this table shows that the gaps of the Lagrangian heuristic and the standard solver increase with setup cost. The reason is that, when the setup cost increases, lot sizes also increase because it is better to group production in a minimum number of periods in order to avoid setup costs. The larger the lot size is, the more difficult it becomes to find a solution that satisfies capacity constraints. Let us first analyze the results when the standard solver is stopped after a maximum CPU time of 10 seconds. Note that, if the gaps of the Lagrangian heuristic and the standard solver are compared, our approach provides better or much better solutions (for example, in the 20 × 5 job-shop case with T = 50, the gap of the Lagrangian heuristic is 2.7 percent while the gap of the standard solver is 77.2 percent), in particular, when setup costs are equal to 100. But the gaps of the Lagrangian heuristic remain large for some instances (larger than 20 percent in the 6 × 6 job-shop case for T = 50). This gap is explained by the fact that the solution given by the Lagrangian heuristic gathers production in a minimum number of periods (since all capacity constraints are relaxed). Hence, the procedure that constructs a feasible solution needs to create a large number of setups in order to satisfy capacity, and the final cost is thus increased.

The solution quality of the standard solver ran for a maximum of 10 minutes and 10 hours is also compared in Table 3 and the gaps always remain very large, for example 70.8 percent for the 6 × 6 job-shop case with T = 100. Our approach finds a solution with a gap smaller than 9 percent in the 6 × 6 and 10 × 10 job-shop cases. The results obtained with our approach are often better (in particular lower bounds).

@&#CONCLUSIONS@&#

In this paper, we consider an integrated production planning and scheduling problem. Because the decisions taken at the planning level are often inconsistent with scheduling decisions, we propose a new model integrating lot-sizing decisions and scheduling constraints. This model determines a production plan for a given sequence of operations on the resources while taking into account setup times and costs. We proposed a Lagrangian heuristic to solve our model, which was tested on a set of instances where critical parameters were varied (demand, capacity, setup cost). The experimental results are very satisfactory since the heuristics provides better results in most cases and much faster than a standard optimization software. However, possible improvements of parts of the procedure are being investigated. First, the choice of the initial Lagrangian multipliers may be defined more appropriately. Also, the procedure that constructs feasible solutions can be improved to not only make solutions feasible but also optimize them.

The Lagrangian heuristic has been successfully used to solve the global planning and scheduling problem when the sequence of operations is not fixed. In Gomez-Urrutia et al. (2014), a metaheuristic is developed that takes information from the Lagrangian relaxation approach to improve the sequence before running the Lagrangian heuristic again. We are currently working on the generalization of our approach to the case of multi-level planning problems.

@&#REFERENCES@&#

