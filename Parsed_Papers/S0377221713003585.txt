@&#MAIN-TITLE@&#Heuristic algorithms for a vehicle routing problem with simultaneous delivery and pickup and time windows in home health care

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A problem of home health care logistics encountered in France is considered.


                        
                        
                           
                           It concerns material pickup and delivery among pharmacy, patients, hospital and lab.


                        
                        
                           
                           A genetic algorithm with permutation chromosome and local search is proposed.


                        
                        
                           
                           A tabu search with route assignment attributes and route re-optimization is designed.


                        
                        
                           
                           Efficiency of approaches is tested on instances derived from relevant benchmarks.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Home health care logistics

Vehicle routing

Pickup and delivery

Time windows

Metaheuristics

@&#ABSTRACT@&#


               
               
                  This paper addresses a vehicle scheduling problem encountered in home health care logistics. It concerns the delivery of drugs and medical devices from the home care company’s pharmacy to patients’ homes, delivery of special drugs from a hospital to patients, pickup of bio samples and unused drugs and medical devices from patients. The problem can be considered as a special vehicle routing problem with simultaneous delivery and pickup and time windows, with four types of demands: delivery from depot to patient, delivery from a hospital to patient, pickup from a patient to depot and pickup from a patient to a medical lab. Each patient is visited by one vehicle and each vehicle visits each node at most once. Patients are associated with time windows and vehicles with capacity. Two mixed-integer programming models are proposed. We then propose a Genetic Algorithm (GA) and a Tabu Search (TS) method. The GA is based on a permutation chromosome, a split procedure and local search. The TS is based on route assignment attributes of patients, an augmented cost function, route re-optimization, and attribute-based aspiration levels. These approaches are tested on test instances derived from existing VRPTW benchmarks.
               
            

@&#INTRODUCTION@&#

This paper considers a special vehicle routing problem with simultaneous delivery and pickup and time windows in home health care. Home hospitalization organizations have been created for patients requiring long and regular health cares in order to provide quality health service at their home while reducing the bed requirements at hospitals. Home hospitalization initially focused on nursing cares and has been extended to complex and technical cares such as chronic cares, rehabilitation, end-of-life palliative cares, and home chemotherapy. Home health care services are provided in France by Home Health Care (HHC) companies. Each day, a HHC company has various logistic activities including delivering drugs and medical devices from its pharmacy (also called depot in this paper) to patients at their home. It also takes some special drugs, such as chemotherapy drugs and blood products, from hospitals to patients. On the other hand, the HHC also needs to pick up materials from patients and deliver to different locations. Blood samples of the patients are collected and delivered to a medical lab. Medical wastes, unused drugs and medical devices are collected and brought back to the HHC or the depot. As HHC companies are usually small but serve rather large number of patients with dispersed locations, it is crucial to carefully design the routes of the HHC vehicles in order to reduce its operating cost while improving the service quality to patients.

Since an HHC patient may be a delivery and a pickup client simultaneously and have both pickup and delivery demands, the design of HHC vehicle routes is related to the vehicle routing problem with simultaneous pickup and delivery and time windows (VRPSDPTW) introduced by Hokey (1989). The VRPSDPTW is a hard and challenging problem in the field of vehicle routing problem (VRP). It considers clients that require simultaneous pickup and delivery service. Some common constraints must be satisfied in both HHC’s vehicle scheduling problem and the VRPSDPTW. For example, each client must be visited and served in a given time window; the load on a vehicle must always be below the vehicle capacity. However, the problem faced by the HHC company is more complex than the classical VRPSDPTW. The first reason is the complexity of its logistic operations with different types of pickup and delivery demands of patients. According to the origins and destinations, both pickup and delivery demands can be divided into two subclasses. The pickup demands include: (i) picking up the material from patients’ homes and deliver to a lab, e.g., biological samples and (ii) picking up some materials from the patients’ homes and bring back to the depot, e.g., medical waste. Similarly, there are two subclasses of delivery demands required by the patients: (i) delivering the products from the company’s depot to patients and (ii) delivering some materials from a hospital to patients’ homes, e.g., special drugs for cancer treatment. In the classical VRPSDPTW all delivery goods are loaded at the depot and all pickup goods have to be transported to the depot. In our HHC vehicle scheduling problem besides the depot, goods can be transported from a hospital to patients and from the patients to a lab. Clearly, the composition of vehicles’ loads in our case is more complex than VRPSDPTW. Furthermore, different from the classical VRPSDPTW, each route of our problem must satisfy some precedence constraints, e.g., for a patient who needs drugs provided by the hospital, the vehicle visiting the patient has to visit the hospital first. Such special constraints are similar to the pairing and precedence constraints in classical pickup and delivery problem (PDP), in which each customer request is defined by an origin location and a destination, the origin must visited before the destination by the same vehicle. However, the PDP is less complicated than our problem, since the origins as well as the destinations of transportation requests in the PDP are locations other than the depot, and a customer in the PDP only has either pickup or delivery request. Thus, in this paper the HHC vehicle scheduling problem is rather a special VRPSDPTW variant which has never been studied before. Since both the VRPSDPTW and PDP are NP-hard problems, our problem is more complex than these problems and is also NP-hard. To the best of our knowledge, we have not found any existing work dealing this special simultaneous pickup and delivery problem in HHC industry.

In this paper, we first perform a literature review, propose two mathematical formulations of our problem, and then develop two heuristic algorithms for this special vehicle scheduling problem. The rest of this paper is organized as follows. Section 2 introduces the relevant literature. Our problem is formally defined and two mathematical models are given in Section 3. Section 4 proposes a Genetic algorithm (GA) for our problem. Section 5 proposes a Tabu Search (TS) algorithm for solving the problem. Computational experiments are described in Section 6. Section 7 concludes the paper.

@&#LITERATURE REVIEW@&#

As stated before, two main bodies of vehicle routing literature are relevant to our problem. The first is the vehicle routing problem with simultaneous pickup and delivery and time windows, in which goods are transported by a fleet of vehicles between the depot and customers within their time windows. The second one is the pickup and delivery problem with time windows (PDPTW) problem, in which goods are transported between n pickup and n delivery locations, and the vehicle visiting each location must be within an associated time window. We survey the literature in two parts.

The VRPSDPTW is an extension of the VRPSDP, and has been much less studied than the VRPSDP. The VRPSDP can be seen as an extension of the vehicle routing problems with backhauls (VRPB). In the VRPB, the set of customers are divided in two subsets consisting of linehaul and backhaul costumers, where a linehaul customer requires a given quantity of product to be delivered from the depot, and a backhaul customer requires a given quantity of product to be picked up to the depot. In the VRPB, it is assumed that the vehicles only pick goods up (serve backhaul customers) after they have finished delivering their entire load (serve linehaul customers) (Toth and Vigo, 1997a; Goetschalckx and Jacobs-Blecha, 1989). One reason for this assumption is the difficulty to re-arrange delivery and pickup goods on the vehicles. The objective of the VRPB is to design a set of minimum cost routes so that on each route neither the total load of linehaul customers nor that of backhaul customers exceed the vehicle capacity. The VRPB is a NP-hard problem in strong sense and a number of algorithms are proposed for this problem. Exact methods for the VRPB are proposed by Yano et al. (1987), Toth and Vigo (1997a), and Mingozzi et al. (1999). Heuristics have been developed by Goetschalckx and Jacobs-Blecha (1989), Toth and Vigo (1999), Osman and Wassan (2002), Tavakkoli-Moghaddam et al. (2006), and Gajpal and Abad (2009b). If the linehaul and backhaul customers can be freely mixed within a route, the VRPB is transformed to the vehicle routing problem with mixed backhauls (VRPMB). Clearly, the vehicle capacity check in the VRPMB is more complicated than the VRPB. Exact solution methods for the VRPMB have only been developed for the single vehicle case (Eilam Tzoreff et al., 2002; Süral and Bookbinder, 2003; Baldacci et al., 2003). Heuristics for the VRPMB were given by Nagy and Salhi (2005), Salhi and Nagy (1999), Wade and Salhi (2004), and Reimann and Ulrich (2006). Based on the VRPMB, if we allow customers to have both pickup quantity and delivery quantity, then, there exist two special problems: the vehicle routing problem with divisible delivery and pickup (VRPDDP), and the vehicle routing problem with simultaneous delivery and pickup (VRPSDP). The difference between the VRPDDP and VRPSDP is the number of times a customer is visited. In the VRPDDP customers do not have to be visited exactly once, i.e., a customer can be visited twice, once for pickup and once for delivery service. The VRPSDP requires that each customer is visited only once by a vehicle. The VRPDDP instances can be transformed to VRPMB by modeling every customer’s pickup and delivery service as two separate customers. One exact method for the VRPSDP was designed by Dell’Amico et al. (2006). Dethloff (2002) proposes an extension of the cheapest insertion heuristic to the VRPSDP. Several tabu search algorithms for VRPSDP were proposed in Alfredo Tang Montané and Galvão (2006), Chen and Wu (2005), Bianchessi and Righini (2007), and Crispim and Brandão (2005). Recently, Ai and Kachitvichyanukul (2009), Gajpal and Abad (2009a), and Subramanian et al. (2010) have proposed several metaheuristics to solve VRPSDP.

Contrary to the VRPB, VRPMB, and VRPSDP, only a fewer researchers consider the time window constraints in these problems, especially for the VRPSDP. For example, an exact algorithm was designed for the VRPB with time windows in Gélinas et al. (1995). Duhamel et al. (1997), Reimann et al. (2002), Thangiah et al. (1996), and Zhong and Cole (2005) proposed heuristics for this problem. For the VRPMB with time windows, Hasama et al. (1998), Kontoravdis and Bard (1995), and Zhong and Cole (2005) designed heuristics, with the primary objective of minimizing the number of the vehicles and the second objective of minimizing traveling distances. For the most complex one, VRPSDPTW, only Angelelli and Mansini (2002) proposed an exact method and Mingyong and Erbao (2010) and Wang and Chen (2012) proposed genetic algorithms.

Compared with VRPSDPTW, there is an abundant body of research on the second related problem PDPTW. The PDPTW originates from the basic PDP (Savelsbergh and Sol, 1995). In the PDP, a customer order consists of two parts: a pickup at one location and a delivery at another location. The PDP has been intensively studied in the past three decades. For survey on the PDP, the reader is referred to Savelsbergh and Sol (1995), Berbeglia et al. (2007), and Parragh et al. (2008). For the PDPTW, several exact approaches have been designed. Dumas et al. (1991), Savelsbergh and Sol (1998), Xu et al. (2003), and Sigurd and Pisinger (2004) used branch and price schemes for the PDPTW. Cordeau (2006) and Ropke et al. (2007) developed branch and cut approach for the PDPTW. Ropke and Cordeau (2009) introduced a new branch and cut and price algorithm for the PDPTW. Meanwhile, many heuristics have been proposed for the PDPTW. Jaw et al. (1986), Madsen et al. (1995), Diana and Dessouky (2004), and Lu and Dessouky (2006) presented various insertion-based heuristics for solving the PDPTW. Toth and Vigo (1997b), Nanry and Wesley Barnes (2000), and Cordeau and Laporte (2003) solved the PDPTW by means of tabu search heuristics. Li and Lim (2001), Pankratz (2005), Ropke and Pisinger (2006), and Parragh et al. (2010) designed simulated annealing, genetic algorithm, adaptive large neighborhood search heuristic, and variable neighborhood search heuristic for solving the PDPTW. Extensive review of the PDPTW literature is out of the scope of in this paper and interested readers are referred to the surveys of Berbeglia et al. (2007) and Parragh et al. (2008).

Although a large number of literatures have studied the VRPSDPTW and PDPTW, to our best knowledge, no existing literature consider the problem, which contains following two vehicle service strategies simultaneously: (i) the transportation of goods from the depot to linehaul customers and from backhaul customers back to the depot and (ii) goods are transported between pickup and delivery locations. Our HHC vehicle scheduling problem includes both of these two service strategies and can be seen as a special VRPSDPTW variant.

This paper addresses the daily scheduling problem of vehicles of a home health care company for delivery of drugs and medical devices and for pickup of biological samples and medical wastes or unused drugs. This section provides a formal description of the problem and then presents two equivalent mixed integer programming formulations of the problem that will serve to assess the efficiency of the heuristic methods of this paper.

The problem can be defined as follows. Let G
                     =(V,
                     A) be a directed graph with a set V
                     ={0,1,…,
                     n,
                     n
                     +1}∪{h,
                     l} of nodes and a set A
                     ={(i,
                     j):i, j
                     ∈
                     V, i
                     ≠
                     j} of arcs. Nodes 0 and n
                     +1 represent the origin and destination depots which are in practice the pharmacy of the home health care company. Each vehicle starts at node 0 and ends at node n
                     +1. Nodes N
                     ={1,…,
                     n} correspond to patients’ homes. Node h and l represent the locations of a hospital and a medical lab.

Each patient i
                     ∈
                     N has four types of delivery and pickup requirements: d
                     
                        i1, d
                     
                        i2, p
                     
                        i1 and p
                     
                        i2, where d
                     
                        i1 represents the amount of materials (drugs/medical devices) to deliver from the depot 0 to patient i, d
                     
                        i2 the amount of materials (special drugs) to deliver from the hospital to patient i, p
                     
                        i1 the amount of materials to pick up from patient i and bring back to the depot n
                     +1, and p
                     
                        i2 the amount of materials (biological samples) to pick up from patient i and bring to the medical lab h. Each type of requirements is called a demand. Different materials are assumed to be compatible and can be loaded in the same vehicle. D
                     1
                     ⊆
                     N denotes the set of patients needing type 1 delivery service, i.e. patients i with d
                     
                        i1
                     > 0. Similarly, D
                     2, P
                     1, P
                     2 denote sets of patients needing type 2 delivery, type 1 and type 2 pickup services. A patient may require different types of demands. For example, for a patient i
                     ∈ 
                     D
                     2
                     ∩
                     P
                     2, the company has to pick up the quantity p
                     
                        i2 from node i and deliver to the lab and deliver the quantity d
                     
                        i2 from the hospital to this node. For notation convenience, we set zero-demands for nodes 0, n
                     +1, h, l.

A time window [a
                     
                        i
                     ,
                     b
                     
                        i
                     ] is associated with each node i
                     ∈
                     V, where a
                     
                        i
                      and b
                     
                        i
                      represent the earliest and latest time. A vehicle is allowed to arrive before a
                     
                        i
                      and wait until the patient becomes available, but arrivals after b
                     
                        i
                      are prohibited. The depot node also has a time window, representing the earliest and latest times when the vehicles may leave from and return to the depot. Each arc (i,
                     j)∈
                     A is associated with a routing cost c
                     
                        ij
                      and a travel time t
                     
                        ij
                     . The service time for a patient i is assumed to be included in the travel time t
                     
                        ij
                     .

A fleet K of identical vehicles, initially located at the depot, is available to serve the patients. Each vehicle has a capacity of Q.

The problem consists in determining a set of at most K routes of minimal overall cost in order to serve all delivery and pickup demands of all patients under the obvious time window and vehicle capacity constraints and the following assumptions.
                        Assumption A
                        Each route starts from and ends at the depot and visits each location at most once;

Each patient is visited by exactly one vehicle for all its demands;

Each route makes a hospital visit before visits to its D
                           2-patients;

Each route makes a lab visit after all visits to its P
                           2-patients.

A typical route is as follows. The vehicle starts the depot with all materials for its D
                     1-patients, visits some patients for D
                     1-delivery and any pickup, visits the hospital to load all materials for its D
                     2-patients, visits other patients, then goes to the lab to deliver materials of all P
                     2-patients, visits other patients before returning to the depot with all materials of its P
                     1-patients.

In the following, we propose two three-index MIP formulations. The first mathematical formulation termed MIP1 is derived from the model of Dell’Amico et al. (2006) and Ropke and Cordeau (2009). Four types of decision variables are used.
                        
                           
                              
                                 
                                    
                                       
                                          x
                                       
                                       
                                          ij
                                       
                                       
                                          k
                                       
                                    
                                 
                               binary variable equal to 1 if vehicle k travels directly from node i to node j;


                              
                                 
                                    
                                       
                                          B
                                       
                                       
                                          i
                                       
                                       
                                          k
                                       
                                    
                                 
                               time at which vehicle k begins to serve at node i;


                              
                                 
                                    
                                       
                                          y
                                       
                                       
                                          ij
                                       
                                       
                                          k
                                       
                                    
                                 
                               quantity of P
                              1- and P
                              2-pickup carried along arc (i,
                              j) by vehicle k;


                              
                                 
                                    
                                       
                                          w
                                       
                                       
                                          ij
                                       
                                       
                                          k
                                       
                                    
                                 
                               quantity of D
                              1- and D
                              2-delivery carried along arc (i,
                              j) by vehicle k.

The objective function (1) minimizes the total routing cost. Constraints (2) ensure that all the demands are satisfied. Constraints (3) guarantee that a vehicle visiting a P
                     2-patient also visits the lab. Constraints (4) are similar but for hospital visit. Constraints (5) and (6) force the route of each vehicle to start and end at the depot. Constraints (7) ensure the flow balance of the vehicles, i.e., if a vehicle visits a node it must leave this node. Constraints (8) indicate that each vehicle can only visit the hospital and the lab once. Constraints (9) impose the consistency of the visiting times. Constraints (10) and (11) are flow equations for pickup and delivery demands. Constraints (12) impose that all delivery demands of D
                     2 patients are loaded at the hospital. Constraints (13) impose the unloading of all pickup demands of P
                     2 patients at the lab. Constraints (14) ensure that each P
                     2 patient is visited before a lab visit; constraints (15) ensure the hospital visit before any visit to a D
                     2 patient. Finally, constraints (16) and (17) impose the time window and vehicle capacity constraints. This MIP1 model is nonlinear because of constraints(9), (14) and (15) that can be linearized as follows:
                        
                           (19)
                           
                              
                                 
                                    B
                                 
                                 
                                    j
                                 
                                 
                                    k
                                 
                              
                              ⩾
                              
                                 
                                    B
                                 
                                 
                                    i
                                 
                                 
                                    k
                                 
                              
                              +
                              
                                 
                                    t
                                 
                                 
                                    ij
                                 
                              
                              -
                              M
                              
                                 
                                    
                                       1
                                       -
                                       
                                          
                                             x
                                          
                                          
                                             ij
                                          
                                          
                                             k
                                          
                                       
                                    
                                 
                              
                              
                              ∀
                              i
                              
                              ∈
                              
                              V
                              ,
                              
                              j
                              
                              ∈
                              
                              V
                              ⧹
                              0
                              ,
                              
                              k
                              
                              ∈
                              
                              K
                           
                        
                     
                     
                        
                           (20)
                           
                              
                                 
                                    B
                                 
                                 
                                    l
                                 
                                 
                                    k
                                 
                              
                              ⩾
                              
                                 
                                    B
                                 
                                 
                                    i
                                 
                                 
                                    k
                                 
                              
                              +
                              
                                 
                                    t
                                 
                                 
                                    il
                                 
                              
                              -
                              M
                              
                                 
                                    
                                       1
                                       -
                                       
                                          
                                             
                                                ∑
                                             
                                             
                                                j
                                                ∈
                                                V
                                             
                                          
                                       
                                       
                                          
                                             x
                                          
                                          
                                             ij
                                          
                                          
                                             k
                                          
                                       
                                    
                                 
                              
                              
                              ∀
                              i
                              
                              ∈
                              
                              
                                 
                                    P
                                 
                                 
                                    2
                                 
                              
                              ,
                              
                              k
                              
                              ∈
                              
                              K
                           
                        
                     
                     
                        
                           (21)
                           
                              
                                 
                                    B
                                 
                                 
                                    i
                                 
                                 
                                    k
                                 
                              
                              ⩾
                              
                                 
                                    B
                                 
                                 
                                    h
                                 
                                 
                                    k
                                 
                              
                              +
                              
                                 
                                    t
                                 
                                 
                                    hi
                                 
                              
                              -
                              M
                              
                                 
                                    
                                       1
                                       -
                                       
                                          
                                             
                                                ∑
                                             
                                             
                                                j
                                                ∈
                                                V
                                             
                                          
                                       
                                       
                                          
                                             x
                                          
                                          
                                             ij
                                          
                                          
                                             k
                                          
                                       
                                    
                                 
                              
                              
                              ∀
                              i
                              
                              ∈
                              
                              
                                 
                                    D
                                 
                                 
                                    2
                                 
                              
                              ,
                              
                              k
                              
                              ∈
                              
                              K
                           
                        
                     
                  

The second mathematical formulation termed MIP2 uses decision variables 
                        
                           
                              
                                 x
                              
                              
                                 ij
                              
                              
                                 k
                              
                           
                        
                      and 
                        
                           
                              
                                 B
                              
                              
                                 i
                              
                              
                                 k
                              
                           
                        
                      as in MIP1 plus the following new decision variables:
                        
                           
                              
                              
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   z
                                                
                                                
                                                   ij
                                                
                                                
                                                   k
                                                
                                             
                                          
                                       
                                    
                                    quantity of P
                                       
                                          j
                                       -pickup with j
                                       ∈{1,2} carried by vehicle k when leaving node i;
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   v
                                                
                                                
                                                   ij
                                                
                                                
                                                   k
                                                
                                             
                                          
                                       
                                    
                                    quantity of D
                                       
                                          j
                                       -delivery with j
                                       ∈{1,2} carried by vehicle k when leaving node i.
                                 
                              
                           
                        
                     
                  


                     MIP2: 
                     
                        
                           Min
                           
                              
                                 ∑
                              
                              
                                 i
                                 ∈
                                 V
                              
                           
                           
                              
                                 ∑
                              
                              
                                 j
                                 ∈
                                 V
                              
                           
                           
                              
                                 ∑
                              
                              
                                 k
                                 ∈
                                 K
                              
                           
                           
                              
                                 c
                              
                              
                                 ij
                              
                           
                           
                              
                                 x
                              
                              
                                 ij
                              
                              
                                 k
                              
                           
                        
                     
                  

subject to constraints 2, (3)–(9), (14)–(16), (18) and
                        
                           (22)
                           
                              
                                 
                                    z
                                 
                                 
                                    j
                                    1
                                 
                                 
                                    k
                                 
                              
                              ⩾
                              
                                 
                                    
                                       
                                          
                                             z
                                          
                                          
                                             i
                                             1
                                          
                                          
                                             k
                                          
                                       
                                       +
                                       
                                          
                                             p
                                          
                                          
                                             j
                                             1
                                          
                                       
                                    
                                 
                              
                              
                                 
                                    x
                                 
                                 
                                    ij
                                 
                                 
                                    k
                                 
                              
                              
                              ∀
                              i
                              
                              ∈
                              
                              V
                              ,
                              
                              j
                              
                              ∈
                              
                              N
                              ∪
                              {
                              l
                              ,
                              h
                              }
                              ,
                              
                              i
                              
                              ≠
                              
                              j
                              ,
                              
                              k
                              
                              ∈
                              
                              K
                           
                        
                     
                     
                        
                           (23)
                           
                              
                                 
                                    z
                                 
                                 
                                    j
                                    2
                                 
                                 
                                    k
                                 
                              
                              ⩾
                              
                                 
                                    
                                       
                                          
                                             z
                                          
                                          
                                             i
                                             2
                                          
                                          
                                             k
                                          
                                       
                                       +
                                       
                                          
                                             p
                                          
                                          
                                             j
                                             2
                                          
                                       
                                    
                                 
                              
                              
                                 
                                    x
                                 
                                 
                                    ij
                                 
                                 
                                    k
                                 
                              
                              
                              ∀
                              i
                              
                              ∈
                              
                              V
                              ⧹
                              {
                              l
                              }
                              ,
                              
                              j
                              
                              ∈
                              
                              N
                              ∪
                              {
                              l
                              ,
                              h
                              }
                              ,
                              
                              i
                              
                              ≠
                              
                              j
                              ,
                              
                              k
                              
                              ∈
                              
                              K
                           
                        
                     
                     
                        
                           (24)
                           
                              
                                 
                                    v
                                 
                                 
                                    i
                                    1
                                 
                                 
                                    k
                                 
                              
                              ⩾
                              
                                 
                                    
                                       
                                          
                                             v
                                          
                                          
                                             j
                                             1
                                          
                                          
                                             k
                                          
                                       
                                       +
                                       
                                          
                                             d
                                          
                                          
                                             j
                                             1
                                          
                                       
                                    
                                 
                              
                              
                                 
                                    x
                                 
                                 
                                    ij
                                 
                                 
                                    k
                                 
                              
                              
                              ∀
                              i
                              
                              ∈
                              
                              V
                              ,
                              
                              j
                              
                              ∈
                              
                              N
                              ∪
                              {
                              l
                              ,
                              h
                              }
                              ,
                              
                              i
                              
                              ≠
                              
                              j
                              ,
                              
                              k
                              
                              ∈
                              
                              K
                           
                        
                     
                     
                        
                           (25)
                           
                              
                                 
                                    v
                                 
                                 
                                    i
                                    2
                                 
                                 
                                    k
                                 
                              
                              ⩾
                              
                                 
                                    
                                       
                                          
                                             v
                                          
                                          
                                             j
                                             2
                                          
                                          
                                             k
                                          
                                       
                                       +
                                       
                                          
                                             d
                                          
                                          
                                             j
                                             2
                                          
                                       
                                    
                                 
                              
                              
                                 
                                    x
                                 
                                 
                                    ij
                                 
                                 
                                    k
                                 
                              
                              
                              ∀
                              j
                              
                              ∈
                              
                              V
                              ⧹
                              {
                              h
                              }
                              ,
                              
                              i
                              
                              ∈
                              
                              N
                              ∪
                              {
                              l
                              ,
                              h
                              }
                              ,
                              
                              i
                              
                              ≠
                              
                              j
                              ,
                              
                              k
                              
                              ∈
                              
                              K
                           
                        
                     
                     
                        
                           (26)
                           
                              
                                 
                                    z
                                 
                                 
                                    i
                                    1
                                 
                                 
                                    k
                                 
                              
                              +
                              
                                 
                                    z
                                 
                                 
                                    i
                                    2
                                 
                                 
                                    k
                                 
                              
                              +
                              
                                 
                                    v
                                 
                                 
                                    i
                                    1
                                 
                                 
                                    k
                                 
                              
                              +
                              
                                 
                                    v
                                 
                                 
                                    i
                                    2
                                 
                                 
                                    k
                                 
                              
                              ⩽
                              Q
                              
                              ∀
                              i
                              
                              ∈
                              
                              V
                              ,
                              
                              k
                              
                              ∈
                              
                              K
                           
                        
                     
                  

Constraints (22) determine the vehicle loading for P
                     1-pickup. Constraints (23) track the vehicle loading for P
                     2-pickup and ensure that it becomes null after the lab visit at the optimum. Constraints (24) and (25) determine the vehicle loading for D
                     1 and D
                     2 delivery. Constraints (26) are vehicle capacity constraints. Again nonlinear constraints (22)–(25) can easily be linearized by standard reformulation techniques.

As explained in Sections 1 and 2, our problem is related to highly complex vehicle routing problems including VRPSDPTW and PDPTW problems. It can be easily proved that our problem is strongly NP-hard as it covers classical VRP problems as special case. It is expected that the above MIP formulation can only be used to solve small-size problems. This is evidence by numerical results of Section 6 in which we try to solve different test instances with the Cplex 12.3 solver. Even for instances of very small size with 30 patients and 40 demands, Cplex is not able to solve the problem optimally. For some of the small size instances, it even cannot get a feasible solution in reasonable time (about 48hours). For these reasons, we propose in the following a genetic algorithm and a tabu search method to address problems of large size.

The genetic algorithm proposed in this paper combines the following features: a permutation chromosome, exact fitness computation by splitting, improvement by local search, diversity of the population and mutli-start with partially replaced population. These ingredients were shown powerful in Prins (2004) in designing efficient GA for vehicle-routing like problems.

In this paper, the chromosome is a permutation of all patients that give order of visits in different routes. An exact split algorithm will be presented to split the permutation into sub-strings of patients to be visited by a vehicle and to insert hospitals and labs.
                        Algorithm 1
                        Outline of the GA
                              
                                 
                                    
                                    
                                       
                                          1: Generate an initial population Π of chromosomes
                                       
                                       
                                          
                                             Main GA exploration phase
                                          
                                       
                                       
                                          2: Select two parents P
                                             1 and P
                                             2 by binary tournament;
                                       
                                       
                                          3: Crossover (P
                                             1,
                                             P
                                             2) by OX operator;
                                       
                                       
                                          4: Evaluate the two resulting children by Splitting;
                                       
                                       
                                          5: Repeat 2–4 if no child is feasible. Otherwise, select randomly a feasible child C;
                                       
                                       
                                          6: Improve C by Local Search, with probability p
                                             
                                                m
                                             ;
                                       
                                       
                                          7: Insert C in Π to replace a randomly selected individual among the half worst of Π, if C is not the current worst and C has a distinct fitness value than those in Π;
                                       
                                       
                                          8: Repeat 2–7 for N
                                             1 iterations or till N
                                             2 iterations without improving the current best;
                                       
                                       
                                          
                                             End of the main GA phase
                                          
                                       
                                       
                                          9: Restart the main GA phase 2–8 with a partially replaced population, for N
                                             3 phases or till N
                                             4 phases without improving the best solution.
                                       
                                    
                                 
                              
                           
                        

The overall structure of the GA is illustrated in Algorithm 1. It starts with the generation of an initial population with insertion of good heuristic solutions to be presented. The central part of our GA is an incremental GA exploration phase in which only one chromosome is replaced at each iteration. It starts with the selection of two parents by binary tournament. The OX operator that was proved appropriate for VRP problems in Prins (2004) is then applied to generate two child chromosomes. These child chromosomes are evaluated by the exact split algorithm. The selection and crossover operations are repeated till obtaining a feasible child chromosome, i.e. a chromosome for which a feasible split solution exists. With some probability, this feasible child chromosome is further improved by Local Search to be presented. The new child chromosome is inserted in the current population under two conditions: (i) it is better than the current worst and (ii) it does not have identical fitness as an existing chromosome.

In our GA implementation, the main GA phase is performed for N
                     1
                     =3000 iterations or till N
                     2
                     =1500 iterations without improving the current best. The main GA phase is repeated for N
                     3
                     =10 phases or till N
                     4
                     =5 phases without improving the current best. To restart the GA phase, we keep the ψ best chromosomes with ψ
                     =3 and replace the others with randomly generated chromosomes. Through some preliminary experiments, the proposed GA gives better solution when increasing the local search probability p
                     
                        m
                      and the size of the population ∣Π∣, especially when p
                     
                        m
                      is smaller than 0.8 and ∣Π∣ is less than 35. The negative side is the increasing running time of GA. To balance the accuracy and the speed of GA, the local search is applied with a probability p
                     
                        m
                     
                     =0.8, and the size of the population is kept fixed at ∣Π∣=30 chromosomes.

It has been proven that perverting the diversity of GA population can diminish the risk of premature convergence (Sörensen and Sevaux, 2006). A simple and stricter rule is imposed in this paper to keep the diversity of the population, i.e., the fitness of any two feasible chromosomes must be different. For this reason, a child chromosome C is inserted during each main GA phase only if it has a different fitness than existing individuals. Diversity is also checked in the generation of the initial population and the partially replaced population for restart.

The remaining of this Section is devoted the detailed presentation of the fitness evaluation, generation of initial solutions, and local search.

In our GA, a chromosome C is a permutation (s
                        1,
                        s
                        2,…,
                        s
                        
                           n
                        ) of all patients (1,2,…,
                        n) and the fitness is the optimal criterion value of our problem such that each route visits a sub-string of patients of C and in the order of C with of course necessary visits to the hospital and lab. For example, the solution of a chromosome (3,5,1,2,4) could be (0,3,5,
                        h,1,
                        n
                        +1) and (0,2,4,
                        l,
                        n
                        +1).

Hereafter we propose a split procedure for fitness evaluation of our problem. It is a shortest path approach. It first builds an auxiliary graph H which contains nodes (s
                        0,
                        s
                        1,
                        s
                        2,…,
                        s
                        
                           n
                        ) with s
                        0
                        =0 and in which each arc corresponds to a feasible route. There is an arc (s
                        
                           i
                        ,
                        s
                        
                           j
                        ) from node s
                        
                           i
                         to s
                        
                           j
                         with i
                        <
                        j if there exists a feasible route visiting all patients (s
                        
                           i+1,…,
                        s
                        
                           j
                        ) in the given order. The length of the arc is the minimal total routing cost of such a route. The fitness of the chromosome is the shortest path from s
                        0 to s
                        
                           n
                         with at most K arcs.

In this approach, when considering an arc (s
                        
                           i
                        ,
                        s
                        
                           j
                        ), all possible and necessary insertions of the hospital h and the lab l in the route (0,
                        s
                        
                           i+1,…,
                        s
                        
                           j
                        ,
                        n
                        +1) are considered. For each insertion of (h,
                        l), the earliest visiting time of each node is determined, the corresponding time window constraint is checked and the insertion is abandoned if the time window constraint is violated. The length l
                        
                           ij
                         of the arc (s
                        
                           i
                        ,
                        s
                        
                           j
                        ) is the smallest earliest visiting time of node n
                        +1 among all feasible routes.

Once the auxiliary graph H is built, the fitness is determined by dynamic programming by determining iteratively the shortest path SP
                        
                           ik
                         from s
                        0 to s
                        
                           i
                         with at most k arcs. Clearly, the fitness is SP
                        
                           nK
                         determined by the following recursion:
                           
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         SP
                                                      
                                                      
                                                         jk
                                                         +
                                                         1
                                                      
                                                   
                                                   =
                                                   
                                                      
                                                         MIN
                                                      
                                                      
                                                         i
                                                         <
                                                         j
                                                      
                                                   
                                                   
                                                      
                                                         SP
                                                      
                                                      
                                                         ik
                                                      
                                                   
                                                   +
                                                   
                                                      
                                                         l
                                                      
                                                      
                                                         ij
                                                      
                                                   
                                                   ,
                                                   
                                                   ∀
                                                   k
                                                   =
                                                   1
                                                   ,
                                                   …
                                                   ,
                                                   K
                                                   -
                                                   1
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         SP
                                                      
                                                      
                                                         00
                                                      
                                                   
                                                   =
                                                   0
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     


                        Fig. 1
                         is an illustrative example. The first part of Fig. 1 shows a small instance with a depot (D), a hospital (h), a lab (l), three patients (a,
                        b,
                        c) and two identical vehicles with capacity Q
                        =10. The chromosome is (a,
                        b,
                        c). The distances between any two nodes are given beside the arc, and the demand of each patient is shown in brackets. There are no time window constraints. In the second part of Fig. 1, each arc in the auxiliary graph represents a possible vehicle route and its traveling distance. The route visiting patients a and b, i.e., arc (D,
                        b), has two possible positions for visiting the hospital and the one leading to shortest distance is chosen to represent this arc. Based on the second part, the shortest path with no more than two arcs is (D
                        −
                        a
                        −
                        c) and has a cost of 52. The corresponding solution consisting of two vehicle routes is given in the third part of Fig. 1.

The initial population is a combination of heuristic solutions and randomly generated chromosomes. It uses four simple constructive heuristics including three saving-based heuristics and a Nearest Neighbor (NN) heuristic. The heuristics make use of randomly set parameters but details will be given later.

The initial population is generated in two phases. Phase 1 starts with a population of the four heuristic solutions with randomly set parameters and randomly generated chromosomes. Phase 1 repeats till a feasible chromosome is obtained. Phase 2 tries to ensure the diversity of the population. It replaces two types of individuals with new random chromosomes: feasible chromosomes having the same fitness as another one and infeasible chromosomes. Phase 2 is repeated for N
                        5
                        =100 times or till the diversity is ensured.

When restarting the GA exploration phase, the current population is partially replaced by keeping the ψ best chromosomes, replacing the remaining ones with random chromosomes, and applying phase 2 to ensure the diversity.

We now give details of the four construction heuristics. The first simplest saving method, called saving
                        1, is as follows:
                           
                              
                                 Step 1:
                              assigns each patient to a separate route. Each patient of P
                                 1 and D
                                 1 is connected with the depot, forming a route beginning and ending at depot. Each P
                                 2 patient jis connected with the lab and the depot, forming a route (depot-j
                                 −
                                 l-depot). Similarly, each patient of D
                                 2 is connected with the hospital and the depot;

merges two routes associated with the maximal saving value, which is calculated as in the classical saving method by checking the time windows and vehicle capacity constraints. In the classical saving, when two routes (depot-…-i-depot) and (depot-j-…-depot) can be feasibly merged into a single route (depot-…-i
                                 −
                                 j-…depot), the saving value is c
                                 
                                    i0
                                 +
                                 c
                                 0j
                                 
                                 −
                                 λ
                                 1
                                 c
                                 
                                    ij
                                 , where λ
                                 1is a parameter randomly sampled in [0.8,1]. In our problem, the saving value is equal to the total distance of arcs to delete in the merged route minus the distances of arcs to add in the new giant route. If both two routes contain the hospital (lab), only the first hospital (the second lab) is kept in the new giant route. For example, the left part of Fig. 2
                                  show two routes (depot-h-…-i-depot) and (depot-h
                                 −
                                 j-…-depot), where i and j are D
                                 2 patients and the others are D
                                 1 or P
                                 1 patients. When merging two routes into one giant route (shown in the right part), three arcs are deleted (represented by dotted line), and one arc (i,
                                 j) is inserted into the new route. Thus, the saving value is Δ
                                 1
                                 =
                                 c
                                 
                                    i0
                                 +
                                 c
                                 
                                    hj
                                 
                                 +
                                 c
                                 0h
                                 
                                 −
                                 λ
                                 1
                                 c
                                 
                                    ij
                                 .

repeat merging routes until no improvement is possible. The final chromosome is obtained by concatenation of the resulting routes in the linguistic order of the first patient in each route.

Two other saving heuristic saving
                        2 and saving
                        3 are also implemented with different one-step look-ahead criterion to improve saving1. Saving
                        2 combines the immediate saving value Δ
                        1 of merging two routes and the maximum positive saving value Δ
                        1−max
                         of this giant route with other remaining routes in the next step. Saving
                        2 merges two routes with the largest Δ
                        2
                        =
                        Δ
                        1
                        +
                        λ
                        2
                        Δ
                        1−max among all merging with positive Δ
                        1 where λ
                        2 is the parameter, randomly sampled in [0.1,0.3]. Saving
                        3 is similar with Δ
                        2 replacing by Δ
                        3
                        =
                        Δ
                        1
                        +
                        λ
                        3
                        Δ
                        1−sum, where λ
                        3 is a third parameter, randomly sampled in [0.01,0.03] Δ
                        1−sum is the sum of top-10 positive savings of merging the giant route and remaining routes in the next step.

In the last heuristic NN, we only consider the depot and patients and neglect the lab and hospital. First, NN links the depot to its closest patient, i.e. the patient i with the smallest routing cost from 0 to i. Then, the NN adds a directed path connecting the last added node to the closest unvisited patient. The procedure repeats until all the patients are included in the path. The resulting sequence of patients is the chromosome of the NN heuristic.

This subsection starts with the split solution of a feasible chromosome and then improves it by several local moves including 1–1exchange, 1–0 relocation, 2-Opt exchange, and 2-Opt∗ exchange. The first-accept strategy is used, i.e., once a new better neighboring solution is identified, it replaces the current solution. For each solution, it first tries 1–1exchange and accept the first improving 1–1exchange. If no improvement is possible with 1–1exchange, it then tries the other local moves. The process repeats until no improvement is possible at all.

For 1–1exchange and 1–0 relocation, both intra-route and inter-route movements are tried. The 1–1exchange tries to exchange positions of any two patients. The 1–0 relocation is the operator for one patient and transfers a patient from its position in one route to another position either in the same or a different route. The 2-Opt exchange is only executed on a single route and it tries to improve the route by replacing two of its edges by two other edges. The 2-Opt∗ exchange is an inter-route method: two edges are selected from two different routes, respectively, and the end portions of two edges are exchanged, so as to generate two new routes.

Note that the inter-route 1–0 relocation and 2-Opt∗ may combine two routes into one and reduce the usage of the vehicles in the solution. In such case, the empty route is removed from the solution. Compared with classical VRPTW, in our work additional precedence constraints also must be checked during the LS procedure. During the search procedure, once a neighboring solution is identified, we checked whether it can satisfy the vehicle capacity, time windows, and precedence constraints. If not, it is aborted directly.

When the LS procedure stops, the resulting routes are concatenated in linguistic order to give the improved chromosome. The split procedure is applied to this new chromosome for evaluation of its fitness.

Tabu search (TS) is also one of the most powerful and competitive heuristics in the fields of VRP, VRPTW and other VRP variants Gendreau et al. (1994), Cordeau et al. (1997), Hertz et al. (2000), Côté and Potvin (2009), and Zachariadis et al. (2009). Essentially, TS iteratively explores the solution space by moving from the current solution to another solution in its neighborhood. Since the current solution may deteriorate during the search, some anti-cycling strategies are used to help the search process explore a broad portion of the solution space.

In this section, we design a TS algorithm for our problem. It is based on the general TS framework of Cordeau et al. (2001) with similar attribute set and augmented criterion function for constraint violations. The general framework of our TS is given in Algorithm 2. It starts with the best feasible solution of the GA initial population given in Section 4 and searches on the set of solutions in which each patient belongs to a route. The neighborhood is defined by relocation of a patient from one route to another route or location exchange of patients in different routes. Our tabu search also includes the re-optimization of all modified routes after each local move. The TS stops after L
                     1
                     =5000 iterations or after L
                     2
                     =2500 iterations without improvement of the best solution. Our TS restarts from the second best and empty tabu list if there is no improvement after L
                     3
                     =1000 iterations. Restarts bring TS to new search regions (Dell’amico et al., 1999).

In the following, we give detailed presentation of the augmented criterion function, the neighborhood structure, the route re-optimization, the attribute set, tabu duration and aspiration criterion.
                        Algorithm 2
                        Outline of the TS
                              
                                 
                                    
                                    
                                       
                                          1: Determine an initial solution Sol;
                                       
                                       
                                          2: Determine the best neighbor solution Sol′ that is not tabu or satisfies an aspiration criterion;
                                       
                                       
                                          3: Re-optimize each modified route of Sol′ and set Sol≔Sol′;
                                       
                                       
                                          4: Update tabu list and aspiration levels;
                                       
                                       
                                          5: Stop the TS if the stopping criterion is met;
                                       
                                       
                                          6: Restart the TS from the second best if a restart criterion is met;
                                       
                                       
                                          7: Go to 2.
                                       
                                    
                                 
                              
                           
                        

In our TS, both feasible and infeasible solutions are allowed. Each solution Sol partitions the set of patients into different routes and is completely represented by its set of routes k with each route represented by the sequence of nodes visited including the depot, the hospital and the lab.

For each route, the visiting times at different nodes can be easily determined by taking into account the visiting sequence and the earliest available time of each node. The vehicle load can be determined as follows. The vehicle starts at the depot with all demands of D
                        1 patients, drops all delivery demands d
                        
                           i1 and d
                        
                           i2 and loads all pickup demands p
                        
                           i1 and p
                        
                           i2 at each patient visit, loads all demands of D
                        2 patients of the route at the hospital, and drops all demands of P
                        2 patients of the route at the lab visit.

For each route k of a solution Sol, let w
                        
                           k
                        (Sol) be the total traveling distance (original objective value), d
                        
                           k
                         (Sol) be the total violation of vehicle capacity, e
                        
                           k
                        (Sol) be the total violation of time window, g
                        
                           k
                        (Sol) be the total violation of precedence constraints. The evaluation of w
                        
                           k
                         (Sol) is straightforward and the evaluation of the others is as follows:
                           
                              (27)
                              
                                 
                                    
                                       d
                                    
                                    
                                       k
                                    
                                 
                                 (
                                 Sol
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          ∈
                                          
                                             
                                                R
                                             
                                             
                                                k
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       (
                                       
                                          
                                             Load
                                          
                                          
                                             ik
                                          
                                       
                                       -
                                       Q
                                       )
                                    
                                    
                                       +
                                    
                                 
                              
                           
                        
                        
                           
                              (28)
                              
                                 
                                    
                                       e
                                    
                                    
                                       k
                                    
                                 
                                 (
                                 Sol
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          ∈
                                          
                                             
                                                R
                                             
                                             
                                                i
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       (
                                       
                                          
                                             m
                                          
                                          
                                             tk
                                          
                                       
                                       -
                                       
                                          
                                             b
                                          
                                          
                                             i
                                          
                                       
                                       )
                                    
                                    
                                       +
                                    
                                 
                              
                           
                        
                        
                           
                              (29)
                              
                                 
                                    
                                       g
                                    
                                    
                                       k
                                    
                                 
                                 (
                                 Sol
                                 )
                                 =
                                 
                                    
                                       N
                                    
                                    
                                       hk
                                    
                                 
                                 +
                                 
                                    
                                       N
                                    
                                    
                                       lk
                                    
                                 
                              
                           
                        where (x)+
                        =
                        max(0,
                        x), R
                        
                           k
                         is the set of nodes visited by vehicle k, Load
                        
                           ik
                         is the vehicle load when leaving node i, m
                        
                           ik
                         is the visiting time of node i in route k and b
                        
                           i
                         its latest visiting time, N
                        
                           hk
                         (N
                        
                           lk
                        ) is the number of D
                        2 (P
                        2) patients visited before a hospital visit (after a lab visit) in route k.

The following augmented criterion function f(Sol) is used in our TS:
                           
                              (30)
                              
                                 f
                                 (
                                 Sol
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          k
                                          ∈
                                          K
                                       
                                    
                                 
                                 (
                                 
                                    
                                       w
                                    
                                    
                                       k
                                    
                                 
                                 (
                                 Sol
                                 )
                                 +
                                 α
                                 ·
                                 
                                    
                                       d
                                    
                                    
                                       k
                                    
                                 
                                 (
                                 Sol
                                 )
                                 +
                                 β
                                 ·
                                 
                                    
                                       e
                                    
                                    
                                       k
                                    
                                 
                                 (
                                 Sol
                                 )
                                 +
                                 γ
                                 ·
                                 
                                    
                                       g
                                    
                                    
                                       k
                                    
                                 
                                 (
                                 Sol
                                 )
                                 )
                              
                           
                        where α, β, and γ are positive parameters to adjust the penalty of constraint violation. If Sol is a feasible solution, f(Sol) coincides with w(Sol). According to this definition, the TS search process will contain a mix of feasible and infeasible solutions, reducing the probability of becoming trapped in a local solution.

Our TS algorithm adjusts α, β, γ dynamically to facilitate the exploration of the search space. The TS algorithm starts or restarts from three initial parameters α
                        0, β
                        0 and γ
                        0, set at respectively 1, 1, 100. We set three intervals [α
                        
                           min
                        ,
                        α
                        
                           max
                        ], [β
                        
                           min
                        ,
                        β
                        
                           max
                        ] and [γ
                        
                           min
                        ,
                        γ
                        
                           max
                        ] to limit these parameters during search process in the following respective ranges [0.01,1000], [0.01,1000] and [0.01,5000]. At each TS iteration, penalty parameter for the vehicle capacity constraint α is modified as follows. If the solution generated after route re-optimization is feasible, α is divided by a factor 1+
                        φ
                        1. If the solution is infeasible and the vehicle capacity is violated, α is multiplied by a factor 1+
                        φ
                        1. If the solution is infeasible but the vehicle capacity is satisfied, parameter α is divided by a factor 1+
                        φ
                        2 (0<
                        φ
                        2
                        ⩽
                        φ
                        1). And, parameters β and γ are adjusted in the same rules. The following parameters φ
                        1
                        =0.2 and φ
                        2
                        =0.05 are used. Note these parameters, e.g., α, β, γ, φ
                        1 and φ
                        2, are tuned by the preliminary experiments, as well as some guidelines in previous studies on unified tabu search (Cordeau et al., 1997). The sensitivity analyses on the parameters were performed sequentially, leaving the remaining parameters unchanged.

Recall that each solution Sol in our TS partitions the set of patients into different routes and is completely represented by its set of routes with each route represented by the sequence of nodes visited including the depot, the hospital and the lab.

The neighborhood of a solution Sol is defined by two local moves. The first local move for a solution Sol removes a patient from one route k and inserts it into another nonempty route k′. The second local move consists in exchanging the route assignment of two patients i and j in different routes k and k′. The relocation move can be denoted as (i, k′) and route exchange move denoted as (i, j, k, k′)

More specifically, relocation move (i,
                        k′) of a patient on route k consists in (i) removing patient i from route k and (ii) inserting it in route k′ at a position that minimize the cost of route k′, i.e.
                           
                              
                                 
                                    
                                       w
                                    
                                    
                                       
                                          
                                             k
                                          
                                          
                                             ′
                                          
                                       
                                    
                                 
                                 (
                                 Sol
                                 )
                                 +
                                 α
                                 ·
                                 
                                    
                                       d
                                    
                                    
                                       
                                          
                                             k
                                          
                                          
                                             ′
                                          
                                       
                                    
                                 
                                 (
                                 Sol
                                 )
                                 +
                                 β
                                 ·
                                 
                                    
                                       e
                                    
                                    
                                       
                                          
                                             k
                                          
                                          
                                             ′
                                          
                                       
                                    
                                 
                                 (
                                 Sol
                                 )
                                 +
                                 γ
                                 ·
                                 
                                    
                                       g
                                    
                                    
                                       
                                          
                                             k
                                          
                                          
                                             ′
                                          
                                       
                                    
                                 
                                 (
                                 Sol
                                 )
                                 ,
                              
                           
                        and (iii) removing the hospital (lab) in route k if there is no more D
                        2 (P
                        2) patient in route k after the local move. Route exchange move (i, j, k, k′) of two patients on different routes k and k′ consists in (i) removing patients i and j from their routes, (ii) inserting patient i (j) in route k′ (k) at a position that minimize the cost of route k′ (k′), and (iii) removing any unnecessary hospital and lab visit in routes k and k′. The cost of the neighbor solution is the augmented cost function of the solution obtained after the local move.

Note that when inserting a patient in route k, we do not relocate or insert the hospital visit and the lab visit in the route even if it is necessary to satisfy the new patient. This is due to the relative long computation time needed to find the best position for inserting hospital or lab. Nevertheless, the relocation or insertion of hospital and lab visits are considered in the re-optimization of modified route once the next local move has been selected.

Other local moves such as intra-route crossover method and 2-opt
                        ∗ (Alfredo Tang Montané and Galvão, 2006) were also used in the literature for solving the VRPs and VRPSDP. We tested such local moves in our TS and did not observe significant improvement. Since most of our TS running time is spent by the neighborhood search, implement more local moves has a clear disadvantage of increasing very substantially the size of the neighborhood and the computation time. For this reason, we limit our TS to two local moves.

Each local move in our TS can modify two routes. A modified route might miss necessary hospital or lab visit, violate vehicle capacity, time window and precedence constraints. This subsection presents a method to rebuild and improve each modified route. The remaining part of this subsection concerns the re-optimization of a given modified route.

The re-optimization starts with a constructive method and then improves the route by local search. More specifically, it starts with a simple and effective constructive heuristic, the nearest insertion(NI) (Bentley, 1992). Our NI heuristic is a three-step method.
                           
                              Step1:
                              Delete all the existing trips in this route. Then create a partial route beginning and ending at the depot and visiting the farthest patient.

Insert the patient whose insertion generates the smallest increment on the cost w(Sol)+
                                 α
                                 ·
                                 d(Sol)+
                                 β
                                 ·
                                 e(Sol), i.e., travel cost plus penalty of the vehicle capacity and time window violation. This step is repeated until all patients are inserted.

Insert the lab and hospital into the route at feasible positions with the smallest increment on the cost w(Sol)+
                                 α
                                 ·
                                 d(Sol)+
                                 β
                                 ·
                                 e(Sol). Precedence constraints are satisfied and g(Sol)=0 at this step, i.e. the hospital is visited before all D
                                 2 patients and the lab is visited after all P
                                 2 patients.

The NI route is not necessarily good enough or even feasible for our problem. It is further improved by local search combing the first-accept strategy and three moves: 1–1exchange, 1–0 relocation, 2-Opt exchange. Before the local search, we check the feasibility of the NI route. If the NI route is feasible, infeasible solutions are not allowed in local search. If the NI route is not feasible, infeasible neighbor solutions are allowed in local search and the augmented criterion function f (Sol) is used.

In our TS, we associate with each solution Sol an attribute set At(Sol)={(i,
                        k)∣i
                        ∈
                        N, k
                        ∈
                        K} indicating for each patient i the vehicle k serving it. Of course, the attribution set is only a partial characterization of the solution used to define the tabu list. The relocation move (i,
                        k′) of a patient i in route kto a different route k′ is equivalent to replace an attribute (i,
                        k) from At (Sol) by a new attribute (i,
                        k′) with k
                        ≠
                        k′. The route exchange of two patients in different routes can be seen as replacing two attributes in At(Sol).

TS utilizes adaptive memory, called tabu list and tabu duration, to implement a diversification strategy. In our TS, when a patient i is removed from a route k, we assign a tabu status to the attribute (i,
                        k), and set a tabu duration θ to this attribute. That is to say, in the next θ iterations, inserting patient i back into route k is forbidden when we perform the neighborhood search. The size of the tabu list θ takes its values in [θ
                        min,
                        θ
                        max] and starts fromθ
                        0. Tabu list θ is also a self-adjusting parameter, and dynamically modifies during the TS search. After each improvement of the current best solution S
                        
                           best
                        , we set parameter θ equal to θ
                        
                           min
                        . After θ
                        
                           ϕ
                         consecutive times unimproved iteration, parameter θ is updated to be min(θ
                        +1,
                        θ
                        
                           max
                        ). In the preliminary experiments, we find θ
                        0
                        =7, θ
                        
                           ϕ
                        
                        =30 suit most test instances. It is not necessary to increase the value of θ
                        0 with the instance size (customer number). And, we set [θ
                        min,
                        θ
                        max]=[5,15] in our TS implementation.

The tabu status of a local move can be overridden by an aspiration criterion in our TS. We define an aspiration value for each attribute, which is equal to the cost of the best feasible solution found with that attribute. For each feasible solution found after the re-optimization of modified routes, we update the aspiration value of each attribute of this feasible solution. A relocation move (i,
                        k′) is considered at an iteration if (i,
                        k′) is not in the tabu list, or the neighbor solution is feasible and its cost is smaller than the aspiration value of (i,
                        k′). A route exchange move (i,
                        j,
                        k,
                        k′) is considered if (i,
                        k′) and (j,
                        k) are not in the tabu list, or the neighbor solution is feasible and its cost is smaller than the smallest aspiration value of (i,
                        k′) and (j,
                        k).

This section reports the results of a series of computational experiments for comparison of the genetic algorithm, the tabu search, and application of the commercial solver Cplex 12.3 for the two mathematical formulations MIP1 and MIP2 of Section 3, and other methods of the literature for some special cases of our problem.

To the best of our knowledge, this paper is the first study of this special vehicle scheduling problem in the home health care industry. There are no benchmark instances to evaluate the performances of our heuristic approaches. Therefore, we construct some test instances based on existing VRPTW benchmarks. Further, as our problem with only P
                     1 or D
                     1 patients reduces to the classic VRPMBTW, our approaches are also compared with existing VRPMBTW approaches on existing benchmark instances for the VRPMBTW.

As our problem is highly combinatorial, the performance of Cplex solver strongly depends on its parameterization. We tried different Cplex parameters including default settings, strong branching, depth-first search, MIP emphasis feasibility or optimality. No parameter setting led to satisfactory performance. For most of the small-size test instances of this Section, Cplex cannot find a feasible solution after 48hours. It does not make sense to compare our heuristic solutions with direct implementation of MIP models in Cplex. Instead, we use in this section MIPstart strategy by letting Cplex to start with the initial solution of our TS, i.e. the best initial solution of our GA. Cplex installs it as the incumbent and initial solution of its branch and cut procedure, which allows Cplex to eliminate portions of the search space and results in smaller branch and cut trees. Cplex starts from this initial solution and goes on solving the problem based on this solution, until exhausting the memory or predetermined maximum computation time. In our preliminary experiments, we also find that Cplex with MIP2 formulation always outperforms Cplex with MIP1. For this reason, this section limits to Cplex with MIP2 formulation. Further, the Cplex lower bounds are very poor and are not given in this paper.

All the algorithms of this paper are implemented in C. All heuristic algorithms (GA,TS,…) are carried out on a 3.2gigahertz Dual Core computer with a 2gegabytes memory under Linux. We set a time limit of 72hours and a memory limit of 20gegabytes for Cplex for each instance. After some preliminary experiments, the parameters of the proposed GA and TS have been set to the values reported earlier in this paper. For fair comparison with GA, our tabu search algorithm is implemented with two stopping criteria: (i) maximum number of iterations and maximum number of iterations without improvement, and (ii) same computation time as GA. The first tabu search is denoted TS1 and the second one TS2. GA, TS1 and TS2 run 10 times for each instance. The best results, the average results and average running time are used to assess the efficiency of these algorithms.

We first derive test instances from existing VRPTW benchmarks of Solomon (1987) and Gehring and Homberger (1999). Eighteen Solomon VRPTW instances are selected to generate our test instances. Each Solomon instance contains 100 customers over a service region defined on a 100×100 grid. These VRPTW instances are divided into three classes that differ by the geographical distribution of the customers: they are clustered in the C type instances, randomly located in the R type instances, and partly clustered, partly randomly located in the RC type instances. Meanwhile, each class is divided into two series: in the 100-series instances time windows are tighter, and in the 200-series instances time windows are wider. To test different characteristics of instances, we select 6 C type instances, 6 R type instances and 6 RC type instances. Among six instances of each type, both the 100-series instances and 200-series ones exist.

For each Solomon instance, we derive six new instances for our problem with 4Z demands as follows. First, we randomly choose Z customers from the Solomon instance as the P
                        1 patients in our new instance, each of which has a demand equal to 50% of the customer’s demand given in the Solomon instance. Then, Z P
                        2, Z D
                        1and ZD
                        2 patients are randomly selected from the Solomon instance. Clearly, one patient may be selected more than once and the number of patients is less than then number of requirements (4Z). If the basic Solomon instance is C101 and 37 patients and 40 demands exist in our new instance, it is denoted as C101-37-40. The coordinates of the depot is inherited in our instances, and the locations of lab and hospital are (10,15) and (40,50). For each patient, the time window in the Solomon instance is used directly. Time windows for the depot, lab and hospital are selected as follows to avoid infeasible solutions. The depot’s time window of the Solomon instance is multiplied by 1.2 and assigned to the depot, lab and hospital in our instance. If ‘violative’ patients still exist in our instance, the new time window is repeatedly multiplied again by 1.2 until all ‘violative’ patients are eliminated. In the preliminary experiment, we find that all ‘violative’ patients disappear after two tries.

For each Solomon instance, this constructing procedure is repeated six times, generating two small (40 demands), two moderate (80 demands), and two large (120 demands) instances. Concerning the vehicle capacity and vehicle number, their values have been reduced compared to the ones considered for the VRPTW, because they are loose for our problem. The detailed information about these two characteristics is illustrated in Tables 4–7.

Besides the Solomon instances, we also create the largest instances from VRPTW instances of Gehring and Homberger (1999). These instances are similar but larger than Solomon instances and have hundreds of customers. We choose 12 instances from this benchmark, each of which has 400 customers, and undergoes the procedure described above to generate 24 new instances for our study. Each of these instances contains 200 demands, and also named as the VRPTW instance’s label with patients number, and demands number.

In this subsection, Tables 1 and 2
                        
                         summarize the results obtained from the GA and TS on all VRPTW-based instances. The detailed computational results obtained on the small instances (containing 40 demands), moderate instances (80 demands), large instances (120 demands), and the largest instances (200 demands) are presented in four Tables 4–7 in Appendix, respectively.


                        Table 1 shows the average routing costs by grouping problem instances according to the number of demands and the type of the instance. The results are obtained from 10 independent runs for each problem instance of the three approaches (GA, TS1, and TS2) plus the one obtained with CPLEX. Column ‘Best’ is the average over all relevant problem instances of the best solutions among 10 independent runs of an approach for each instance. Column ‘AVG’ is the average travel cost over all problem instances and over all runs of the approach. Similarly, column ‘Worst’ represents the average value of the worst solution costs among relevant test instances. We calculate the standard deviation of 10 runs of each test instance, and Column ‘STD’ gives the average standard deviation among all relevant test instances. Column ‘CPU’ is the average CPU time in seconds of one run among relevant test instances. The last line in Table 1 provides the average values for all the test instances. Table 2 shows the percentage of the best solutions obtained by GA, TS1 and TS2 on each type of test instances.

Several conclusions can be drawn from these experimental results. First, the proposed GA and TS (both TS1 and TS2) perform well for test instances of different types and different sizes. For each combination of types and sizes, our heuristic algorithms significantly dominate the Cplex solver. For all 132 test instances, the Cplex solution costs and best GA solution costs deviate on average by 16.4%; the Cplex solution costs and TS1, TS2 best solution costs deviate on average up to 17.0% and 17.1%, respectively. Recall that both Cplex and TS start from the best solution of the initial GA population built by simple constructive heuristics, random generated solutions and the optimal split procedure. This implies that GA and TS can significantly improve the solutions of these heuristic solutions and our algorithmic approaches are highly competitive.

Concerning the solution quality of the GA and TS approaches, the performances of all three heuristics are satisfactory. For example, as shown in Table 2, out of 36 small size test instances, GA, TS1 and TS2 can get 72%, 78%, 72% best solutions, respectively. For 17 instances out of all 36 small size instances, GA, TS1 and TS2 all find the same solution (referred to Tables in Appendix). Among the total 132 test instances, GA, TS1 and TS2 are able to find 48%, 46%, 53% best solutions, respectively. Note that Cplex does not get any best solution and the Cplex solution is always far from the best solutions found by other approaches.

Meanwhile, we find that our approaches GA, TS1 and TS2 are robust and can find good solutions for different test instances in different runs. As shown in Table 1, for all the test instances, the average standard deviation of GA, TS1 and TS2 are 25.5, 24.8 and 24.1. Comparing GA and TS, we find that TS1 is slightly better the GA. For the total 132 test instances, the best solution costs of GA and TS1 deviate on average by 0.71%; their average and worst solution costs deviate by 0.79% and 0.97%, respectively. The superiority of TS1 is especially true for problem instances of the largest size. For example, as shown in Table 1, for the largest 24 instances, the best solution costs of GA and TS1 deviate on average by 1.29%; the deviation between their average and worst solution costs is 1.52% and 1.93%. Meanwhile, Table 2 shows that TS1 succeeds in finding 55% best solutions of the largest instances, while GA is able to find 17% best solutions. Nevertheless, for these instances, TS1’s improved solution quality is obtained at the cost of longer computation time. Over the 132 test instances, the CPU time of TS1 is on average 9.28% longer than that of GA.

With the same computation time between GA and TS2, the performance of TS2 is slightly better than that of the GA. Over 132 test instances, concerning their best solution, TS2 is slightly better than GA on the average best solution costs with a deviation of 0.76%. Meanwhile, TS2 can find more best solutions than GA, with 48% best solutions found by GA and 53% by TS2.

This subsection restrict our problem to only P
                        1 and D
                        1 patients and our problem reduces to the classic VRP with mixed backhauls and time windows (VRPMBTW). Our GA and TS are tested on the benchmarks for the VRPMBTW against existing best solutions. Gélinas et al. (1995) construct test data for the basic VRPBTW (all backhaul customers are serviced after all the linehaul customers) from Solomon VRPTW problems. They constructed VRPBTW instances by randomly choosing 10%, 30% and 50% of the 100 total customers in Solomon VRPTW benchmark to be backhaul customers instead. Hasama et al. (1998) designed 15 VRPMBTW test problems from the data of Gélinas et al. (1995) by relaxing the linehaul-before-backhaul constraint, and proposed a simulated annealing (SA) heuristic method for the VRPMBTW. We test our two heuristics, GA and TS2, on Hasama’s problem instances.

The results obtained by our algorithms and those provided the SA algorithm of Hasama et al. (1998) are detailed in Table 3
                        . Column ‘Name’ gives the label of the instance. Column ‘BH%’ presents the percentage of the backhaul among all customers. Columns 3 and 4 contain the best solutions found by Hasama’s SA algorithm, where ‘Cost’ shows the travel distance and ‘V’ shows the number of the vehicles used. The next six columns contain the best, the average and the worst solution cost, the standard deviation, the average CPU time (for one run) and minimum vehicle number used in 10 GA runs for each instance. The number of vehicles used in the minimum cost solution is also given in parenthesis if it is larger than V. Similar results are given for TS2.

From Table 3, our GA and TS2 algorithms dominate the SA algorithm of Hasama et al. (1998) in terms of solution quality. The primary objective of Hasama et al. (1998) is to minimize the number of vehicles used to serve the customers, and the second objective is to minimize the total travel distance. Therefore, we first compare the number of vehicles. Although our heuristics do not use this as their objective, the proposed GA still can reduces the number of vehicles needed for 4 out of the 15 instances, and TS2 reduces the number of vehicles for six instances. Concerning the travel distance, the solutions of our GA and TS2 are much better than the solution produced by Hasama et al. (1998). For each instance, GA and TS2 can get better solution. The average percentage deviations between the best solution costs of our GA and TS2 and Hasama’s SA are 6.35% and 6.27% respectively.

This paper investigates a special simultaneous pickup and delivery problem with time windows in HHC, an extension of the classical VRPSDPTW. The problem is of interest because of its theoretical complexity and of the important applications in the home health care industry. We formulate the problem as two integer programming models to minimize the total vehicle cost for serving all patients demands. We also propose two meta-heuristics, Tabu search and genetic algorithm, to solve this problem. As this problem is new and no benchmark exists, experiments are conducted by using a range of test instances, which are designed based on existing VRPTW benchmarks to reflect different realistic scenarios. In general, both TS and GA can provide good solutions in a reasonable time span, and TS requires relatively more computational time. Our proposed heuristic approaches are also tested on a set of VRPMBTW benchmarks against best known results. The results of our metaheuristics are clearly better than the best-known solutions in the existing literature.

This research can be extended in different directions. Firstly, the problem can be extended to a planning horizon of several days, e.g., a week, to combine planning of delivery/pickup and vehicle routing. In real-life applications, usually each patient requires a certain number of visits and services within this time horizon. The HHC has to choose the visiting days for each patient and to solve a vehicle scheduling problem for each day. In the vehicle scheduling problem of each day, some special constraints and conditions encountered in the HHC must be considered. This problem is a special periodic vehicle scheduling problem and even more complex than the problem studied in this paper. Meanwhile, in many real-world home health care logistic applications, some elements in the problem may not be known in advance, e.g., patients’ delivery/pickup demands, travel and service times of the vehicle. Such uncertain elements significantly affect the system performance. The vehicle scheduling problems in HHC under such uncertain conditions are also very important and interesting.

@&#ACKNOWLEDGEMENTS@&#

This research is partially funded by Saint Etienne Metropôle for providing a Post-Doc fellowship for the first author and by Natural Science Foundation of China (71131005 and 61104173). The authors are also grateful to OIKIA home health care company for sharing information for home health care logistics.

Supplementary data associated with this article can be found, in the online version, at http://dx.doi.org/10.1016/j.ejor.2013.04.044.


                     
                        
                           
                        
                     
                  

@&#REFERENCES@&#

