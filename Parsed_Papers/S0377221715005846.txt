@&#MAIN-TITLE@&#Integrated production and delivery on parallel batching machines

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           The problem of scheduling n jobs on m parallel batching machines is considered.


                        
                        
                           
                           The goal is to maximize the total profit earned.


                        
                        
                           
                           We show that the problem can be solved efficiently if each job has the same size.


                        
                        
                           
                           The problem becomes unary NP-hard if the jobs have different sizes.


                        
                        
                           
                           For the NP-hard cases, heuristics are given and their performance analyzed.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Parallel batching machines

Coordinated production-delivery

Fixed time departure

NP-hard

Heuristics

@&#ABSTRACT@&#


               
               
                  We consider the problem of scheduling a set of n jobs on m identical and parallel batching machines. The machines have identical capacities equal to K and the jobs have identical processing times equal to p. Job j has a size sj
                     , a due date dj
                      and a profit Rj
                     . Several jobs can be batched together and processed by a machine, provided that the total size of the jobs in the batch does not exceed the machine capacity K. The company will earn a profit of Rj
                      dollars if job j is delivered by time dj
                     ; otherwise, it earns nothing. A third party logistic (3PL) provider will be used to deliver the jobs. The 3PL provider picks up the jobs at times T
                     1 < T
                     2 < ⋅⋅⋅ < Tz
                     , and vk
                      (1 ≤ k ≤ z) vehicles will be provided for delivery at time Tk
                     . The vehicles have identical capacities equal to C. The objective is to find a production and delivery schedule so as to maximize the total profit that the company can earn. We show that the problem is solvable in polynomial time if the jobs have identical sizes, but it becomes unary NP-hard if the jobs have different sizes. We propose heuristics for various NP-hard cases and analyze their performances.
               
            

@&#INTRODUCTION@&#

A parallel batching machine can process several jobs simultaneously as a batch. Such machines are encountered in many manufacturing industries such as the semiconductor industry, casting industry, metal industry, aeronautical industry, pharmaceutical industry, and logistics freight (Mathirajan & Sivakumar, 2006). Since parallel batching machines are encountered in many industries, it has received tremendous attention in the literature, see Brucker et al. (1998), Mathirajan and Sivakumar (2006) and Potts and Kovalyov (2000) for a survey. Most scheduling problems in parallel batching machines are concerned with optimizing some classical objectives such as the makespan, total (weighted) completion time, maximum lateness, (weighted) number of late jobs, etc. With the advancement in the Make-To-Order (MTO) business model, these objectives are not sufficient to satisfy customer demands. A major concern in the MTO business model is the timely delivery of products to customers. This calls for a closer link between the production process and the delivery process. Integrated production and delivery scheduling have received a lot of attention in recent years, see Chen (2010) for a survey. However, these studies have been concerned with the classical scheduling model, where a machine can process only one job at a time. In this paper we consider production-delivery scheduling on parallel batching machines. To the best of our knowledge, no one has ever studied this problem before.

Consider a manufacturing plant that has m (m ≥ 1) identical and parallel batching machines, 
                        
                           M
                           =
                           {
                           
                              M
                              1
                           
                           ,
                           
                              M
                              2
                           
                           ,
                           …
                           ,
                           
                              M
                              m
                           
                           }
                        
                     . Each machine has a capacity K. There are n (n ≥ 1) jobs, 
                        
                           J
                           =
                           {
                           
                              J
                              1
                           
                           ,
                           
                              J
                              2
                           
                           ,
                           …
                           ,
                           
                              J
                              n
                           
                           }
                           ,
                        
                      each of which will be processed by one of the machines. Each job has a processing time p. Job Jj
                      has a size sj
                     , a due date dj
                      and a profit Rj
                     . Several jobs can be batched together and processed by a machine simultaneously, provided that the total size of all the jobs in the batch does not exceed K. If job Jj
                      is processed by one of the machines and delivered by its due date dj
                     , the company will earn a profit of Rj
                      dollars; otherwise, it earns nothing. The company hires a third party logistic (3PL) provider to deliver products to the customers. The 3PL provider comes to the manufacturing plant at times T
                     1, T
                     2
                     
                        
                           ,
                           …
                           ,
                        
                     
                     Tz
                      (T
                     1 < T
                     2 < ⋅⋅⋅ < Tz
                     ) to pick up the products and delivers to the customers. We assume that all jobs can start processing at time 0 and that Tz
                      is an integral multiple of p. At time Tk
                     , 1 ≤ k ≤ z, the 3PL provider provides vk
                      vehicles, each of which has capacity C. That is, each vehicle can deliver a number of jobs whose total size does not exceed C. We assume that sj
                      ≤ K and sj
                      ≤ C for each 1 ≤ j ≤ n. A job cannot be split and delivered by two or more vehicles. From the company point of view, the goal is to find a schedule so that it can earn a maximum profit; in other words, find a subset 
                        
                           
                              J
                              ′
                           
                           ⊆
                           J
                        
                      such that each job in 
                        
                           J
                           ′
                        
                      can be processed and delivered by its due date and 
                        
                           
                              ∑
                              
                                 
                                    J
                                    j
                                 
                                 ∈
                                 
                                    J
                                    ′
                                 
                              
                           
                           
                              R
                              j
                           
                        
                      is maximized.

The due date of each job is obtained by offsetting the customer’s actual due date by the delivery time from the manufacturing plant to the customer. There are two models concerning the capacity C of the vehicles. The first model assumes that each job takes one unit of the capacity, regardless of the size of the job. If the sizes of the jobs are identical, then we can assume, without loss of generality, that each job takes one unit of capacity. Even if the jobs have different sizes, this model assumes that each job is packaged into a standard-size pallet for delivery convenience, regardless of the job size. Thus, each vehicle can deliver at most C jobs in this model. The second model assumes that each job will take an amount of capacity equal to the size of the job. This model is only applicable to jobs with different job sizes. In this case, a vehicle may deliver less than C jobs even though the vehicle is completely filled. We shall call the first model “model 1” and the second model “model 2”.

While we formulate the problem that the company hires a 3PL provider to deliver products, the problem is also applicable to the situation where the company owns the vehicles and delivers the products by themselves. The company may have several manufacturing plants located in various places, and it has a fixed number of vehicles. Due to their integrated production-distribution planning, this particular manufacturing plant will be given vk
                      vehicles at time Tk
                      for its own disposal. Therefore, the problem is the same as what we have just described.

It will be more convenient to represent our problem by a 3-field notation (Graham, Lawler, Lenstra, & Kan, 1979). In the α-field, we use P to denote m identical and parallel machines, where m is arbitrary. Likewise, we use 1 to denote a single machine. In the β-field, we use “p-batch” to denote the parallel batching machines. We use “fdep” to denote shipping with fixed delivery departure dates, see Chen (2010) for an explanation of the notation “fdep”. We use “model1” and “model2” to denote “model 1” and “model 2”, respectively. For example, 
                        
                           P
                           ∣
                           fdep,
                           
                           p-batch
                           ,
                           
                              s
                              j
                           
                           =
                           1
                           ∣
                           ∑
                           
                              R
                              j
                           
                        
                      denotes the problem with all jobs having identical sizes. Since the jobs have identical sizes, “model 1” will be assumed for delivery capacity. The problem 
                        
                           P
                           ∣
                           fdep,
                           
                           p-batch,
                           
                           model2
                           ,
                           
                              R
                              j
                           
                           =
                           1
                           ∣
                           ∑
                           
                              R
                              j
                           
                        
                      denotes that the jobs have identical profits but different sizes, and “model 2” will be assumed for delivery capacity. The problem P∣ fdep, p-batch, model1 ∣∑Rj
                      denotes that the jobs have different sizes and different profits, but “model 1” is assumed for delivery capacity.

Our problem can also be viewed as a double bin-packing problem as follows. There are two types of bins. The first type of bins correspond to machines with each bin having a capacity of K. We call this type of bins the “machine-bins”. The second type of bins correspond to vehicles with each bin having a capacity of C. We call this type of bins the “vehicle-bins”. For each k, 1 ≤ k ≤ z, there are 
                        
                           m
                           ⌊
                           
                              
                                 
                                    T
                                    k
                                 
                                 −
                                 
                                    T
                                    
                                       k
                                       −
                                       1
                                    
                                 
                              
                              p
                           
                           ⌋
                        
                      type-k machine-bins, where T
                     0 is defined to be zero. In addition, there are vk
                      type-k vehicle-bins. Each job Jj
                      can be viewed as consisting of two pieces. The problem is to pack the first piece of Jj
                      into one of the type-e machine-bins (1 ≤ e ≤ z), and then pack the second piece into one of the type-f vehicle-bins, with the restriction that f ≥ e. If Tf
                      ≤ dj
                     , then we can obtain a profit of Rj
                      from job Jj
                     ; otherwise, we obtain nothing from job Jj
                     . Our problem is to pack a subset of jobs so that we can maximize the total profit from this subset of jobs.

There are two models of the problem. In “model 1”, the first piece of job Jj
                      has a size of sj
                      while the second piece of Jj
                      has a size of 1. In “model 2”, the first piece and the second piece have the same size of sj
                     .

This double bin-packing problem is rather unusual in that the packing is done twice, once on the machine-bins and once on the vehicle-bins. Moreover, the packing on the vehicle-bins cannot be on a lower type than the packing on the machine-bins. Furthermore, the packing on the vehicle-bins is restricted to be on any type-f vehicle-bins, where Tf
                      ≤ dj
                     . Also, the sizes of the pieces can be different in “model 1”. The objective is not the usual bin-packing objectives such as the number of bins used, or the number of pieces packed. Instead, there is another profit parameter that we want to maximize. We have not seen this kind of bin-packing problem in the literature. Therefore, we do not know if there is any result related to this bin-packing problem. As we shall see in the following, if the jobs have identical sizes, i.e., 
                        
                           
                              s
                              j
                           
                           =
                           1
                        
                      for each 1 ≤ j ≤ n, then the problem can be solved in polynomial time. On the other hand, if the jobs have non-identical sizes, then the problem is unary NP-hard, even though we have one type of machine-bins, a single vehicle-bin, 
                        
                           m
                           =
                           1
                        
                      and 
                        
                           
                              R
                              j
                           
                           =
                           1
                        
                      for each 1 ≤ j ≤ n. For various NP-hard cases, we provide fast heuristics and analyze their performances.

The rest of the paper is organized as follows. In the next section we will review existing literature concerning parallel batching machines and integrated production-delivery scheduling. In Section 3, we provide a polynomial-time algorithm to solve the case of identical sizes. In Section 4, we prove that the problem becomes unary NP-hard when the jobs have different sizes. In Section 5, we give a fast heuristic for “model 1” and analyze its performance. In Section 6, we give a fast heuristic for “model 2” and perform computational studies on the heuristic. Finally, we draw some concluding remarks in Section 7.

@&#LITERATURE REVIEW@&#

In the last two decades, there have been tremendous research in parallel batching machine scheduling problems. These research studied the problems of minimizing the makespan, total (weighted) completion time, maximum lateness, (weighted) number of late jobs, etc. At the same time, the problems of scheduling with job delivery also received a lot of attention, but these researches only dealt with job scheduling in the classical model (i.e., a machine can process only one job at a time). In the following two subsections we will review these two areas separately.

In parallel batching machine scheduling, a job has two parameters: processing time and size. Allowing both parameters to be arbitrary makes the problem very difficult to solve. Therefore, most researchers restrict one of the parameters to be identical and allow the other parameter to be arbitrary. The readers are referred to Brucker et al. (1998), Mathirajan and Sivakumar (2006) and Potts and Kovalyov (2000) for a survey of parallel batching machine scheduling.

The scheduling of batching machines was first studied in the 1980s. Ikura and Gimple (1986) presented an O(n
                        2) algorithm to find a due date feasible schedule on one machine, assuming that the jobs have identical processing times and identical sizes and that the release times and due dates of the jobs are agreeable. Lee, Uzsoy, and Martin-Vega (1992) provided efficient algorithms for minimizing the number of late jobs and maximum tardiness under a number of assumptions. They also presented and analyzed the worst-case ratio of a heuristic for minimizing the makespan on identical and parallel batching machines. Brucker et al. (1998) developed an 
                           
                              O
                              (
                              
                                 n
                                 
                                    b
                                    (
                                    b
                                    −
                                    1
                                    )
                                 
                              
                              )
                           
                         dynamic programming algorithm for minimizing the total completion time on one machine, where b is the capacity of the machine. For fixed b, their algorithm is a polynomial-time algorithm. For arbitrary b, the complexity is still open. When there are q distinct processing times, Chandru, Lee, and Uzsoy (1993a), Hochbaum and Landy (1997) and Brucker et al. (1998) gave dynamic programming algorithms for minimizing the total completion time. The most efficient one is the one given by Brucker et al. (1998), which is an O(b
                        2
                        q
                        22
                           q
                        )-time algorithm. For the problem of minimizing the maximum lateness, Brucker et al. (1998) showed that the problem is unary NP-hard. This result implies that minimizing the number of late jobs and the total tardiness are both unary NP-hard.


                        Chandru, Lee, and Uzsoy (1993b) studied the problem of minimizing the total completion time on single and parallel machines, where the jobs have identical sizes. They (Chandru et al., 1993b) provided a branch-and-bound procedure for a single machine, and several heuristics for both single and parallel machines. Wang and Uzsoy (2002) considered the problem of minimizing the maximum lateness on a single machine, where the jobs have identical sizes but arbitrary release times. They (Wang & Uzsoy, 2002) gave a genetic algorithm based on a random keys encoding scheme. Computational experiments indicated that the genetic algorithm has excellent average performance with reasonable computation time. Malve and Uzsoy (2007) considered the same problem as Wang and Uzsoy, except that the n jobs belong to q different job families that are processed on m identical and parallel machines. Jobs belonging to the same family have the same processing times and can be batched together. A genetic algorithm and a family of iterative improvement heuristics were given. Computational experiments show that the combination of iterative heuristics with the genetic algorithm consistently outperforms the iterative heuristics on their own.


                        Uzsoy (1994) was the first one to study the problem of scheduling jobs with non-identical sizes and non-identical processing times on a single machine so as to minimize the makespan. He showed that minimizing the makespan is NP-hard, and he gave a number of heuristics. Zhang, Cai, Lee, and Wong (2001) considered the problem of minimizing the makespan on a single machine. They analyzed the worst-case ratios of a number of heuristics proposed by Uzsoy (1994). They gave an approximation algorithm with a worst-case ratio of 3/2 for a set of jobs where the processing times of large jobs (jobs with sizes greater than 1/2 of the capacity of the machine) are not less than those of small jobs. For the general case, they gave a heuristic with a worst-case ratio of 7/4. Li, Li, Wang, and Liu (2005) studied the same problem as Zhang et al., except that the jobs have arbitrary release times. They (Li et al., 2005) gave a polynomial time approximation scheme (PTAS) for this problem. Dupont and Dhaenens-Flipo (2002) developed a branch-and-bound procedure to minimize the makespan.

Recently, there are some interests in scheduling jobs on identical and parallel machines. Koh, Koo, Ha, and Lee (2004) studied this problem for q families of jobs, where jobs in the same family have identical processing times and can be batched together. They (Koh et al., 2004) gave several simple heuristics and a genetic algorithm for minimizing the makespan, total completion time and total weighted completion time. Damodaran and Chang (2008) applied some of the bin-packing rules, combined with some of the scheduling rules in multiprocessor scheduling, to develop several heuristics to minimize the makespan. Kashan, Karimi, and Jenabi (2008) gave a hybrid genetic heuristic (HGH). Jia and Leung (2015) developed a max–min ant system algorithm and showed that it outperforms the HGH algorithm given by Kashan et al. (2008) and the best of the four heuristics given by Damodaran and Chang (2008).

Very recently, several researchers began the study of job scheduling on parallel machines with non-identical capacities to minimize the makespan. Xu and Bean (2007) gave a genetic algorithm to schedule a set of jobs on a set of machines with different capacities. Wang and Chou (2010) considered the same problem, except that jobs have different release times. They (Wang & Chou, 2010) gave a simulated annealing procedure and a genetic algorithm to solve the problem. Damodaran, Diyadawagamage, Ghrayeb, and Velez-Gallego (2012) gave a particle swarm optimization (PSO) algorithm to solve the problem. Jia, Li, and Leung (2014) gave a simple heuristic and a meta-heuristic, and showed that both algorithms outperform the PSO algorithm given by Damodaran et al. (2012) by a wide margin. Wang and Leung (2014) considered a set of equal-processing-time jobs. They showed that, unless 
                           
                              P
                              =
                              NP
                              ,
                           
                         there is no polynomial-time algorithm with an absolute worst-case ratio less than 2. They then gave a polynomial-time algorithm with an absolute worst-case ratio exactly 2. Finally, they gave a polynomial-time algorithm with an asymptotic worst-case ratio of 3/2.

Integrated production and distribution scheduling have received a lot of attention in the last two decades. Chen (2010) has classified these problems into five major classes. Our problem is in the fifth class in Chen’s classification, i.e., problems with fixed delivery departure dates. Therefore, we will review research papers in this class only.

The work that is most closely related to our work is the paper by Leung and Chen (2013). In Leung and Chen (2013), the authors considered a set of n orders to be processed by a single assembly line. Order j has a processing time pj
                         and a due date dj
                        . In the planning horizon, there are z vehicle departure time instants T
                        1, T
                        2
                        
                           
                              ,
                              …
                              ,
                           
                        
                        Tz
                        , where at time Ti
                        , 1 ≤ i ≤ z, there are vi
                         vehicles available for delivery. Each vehicle can deliver at most C orders. The vi
                         vehicles can deliver orders that are completed by time Ti
                        . A feasible schedule is one in which each order has completed processing and delivered by one of the available vehicles. If order j is delivered by one of the vehicles at time Ti
                        , then the lateness of order j, denoted by Lj
                        , is defined to be 
                           
                              
                                 L
                                 j
                              
                              =
                              max
                              
                                 {
                                 0
                                 ,
                                 
                                    T
                                    i
                                 
                                 −
                                 
                                    d
                                    j
                                 
                                 }
                              
                           
                        . The maximum lateness, Lmax
                        , is defined to be 
                           
                              
                                 L
                                 
                                    m
                                    a
                                    x
                                 
                              
                              =
                              max
                              
                                 {
                                 
                                    L
                                    j
                                 
                                 }
                              
                           
                        . Leung and Chen (2013) considered the problems of finding a feasible schedule that minimizes one of the following objective functions: (1) Lmax
                        , (2) the number of vehicles used subject to the condition that Lmax
                         is minimum, and (3) the weighted sum of Lmax
                         and the number of vehicles used. They (Leung & Chen, 2013) showed that all three problems are solvable in polynomial time.


                        Li, Ganesan, and Sivakumar (2005) considered a problem involving a computer assembly manufacturer trying to synchronize the schedule of assembly operations with delivery. They (Li et al., 2005) assumed that the vehicles have different capacities and the orders have different sizes. The goal is to minimize a weighted sum of total earliness, total tardiness and total transportation cost. Since the problem is unary NP-hard, they (Li et al., 2005) proposed a decomposition-based heuristic. Li, Ganesan, and Sivakumar (2006) studied the same problem but with a rescheduling consideration.


                        Wang, Batta, and Szczerba (2005) studied a problem of coordinating mail processing and distribution scheduling at a mail processing center. The vehicles have different capacities but the orders have identical sizes. The goal is to minimize the total unused truck capacity. They (Wang et al., 2005) showed that the problem is unary NP-hard and they proposed dispatching rules and heuristics. Stecke and Zhao (2007) considered a problem in the context of a make-to-order computer manufacturer with a commit-to-delivery business model. There are unlimited number of heterogeneous vehicles and each vehicle can only deliver one order. The goal is to minimize the total transportation cost, where the transportation cost for shipping an order is a convex decreasing function of the shipping time and a linear function of the order size.


                        Huo, Leung, and Wang (2010) considered the processing and delivery of perishable goods on a single machine. The perishable goods cannot be processed well in advance of delivery. Instead, they must be produced in a small window of time just before the delivery time. They (Huo et al., 2010) showed that the problem is unary NP-hard and proposed several approximation algorithms with the worst-case ratios analyzed.


                        Agnetis, Aloulou, and Fu (2014) considered coordinated production and interstage batch delivery scheduling problems, where a third-party logistic provider (3PL) delivers semi-finished products in batches from one production location to the next location. They considered two scenarios: (1) the manufacturer determines the production schedule in the first location, and (2) the 3PL determines the production schedule in the first location. There are two transportation modes: (1) regular transportation for which the vehicles leave at fixed departure times, and (2) express transportation for which the vehicles leave at any time. It is assumed that express transportation is more costly than regular transportation. Their objective is to minimize the total vehicle cost subject to the constraint that each job has to be delivered within time T after it has finished processing. They showed that some of the problems are solvable in polynomial time, while others are unary NP-hard. Agnetis, Aloulou, Fu, and Kovalyov (2015) gave faster algorithms for two polynomially solvable cases studied by Agnetis et al. (2014)
                     

In this section we will assume that the jobs have identical sizes. Without loss of generality, we may assume that the size of each job is one unit. We will give a polynomial-time algorithm to construct a schedule that maximizes the total profit. We assume that 
                        
                           
                              T
                              0
                           
                           =
                           0
                        
                      and 
                        
                           
                              v
                              0
                           
                           =
                           0
                        
                     . Thus, at each time Ti
                     , 0 ≤ i ≤ z, we can deliver viC jobs. The algorithm first computes the “deadline” 
                        
                           T
                           
                              D
                              j
                           
                        
                      of each job Jj
                     , which is simply the largest i such that Ti
                      ≤ dj
                     . It also computes the total capacity of the vehicles, Vi
                     , at time Ti
                     , which is simply viC.

The algorithm then enters a loop to construct the schedule. The schedule is constructed backwards, starting at time 
                        
                           T
                           =
                           
                              T
                              z
                           
                           ,
                        
                      and works towards time 0. In the first iteration, it let l be the smallest index such that T ≤ Tl
                     . The algorithm then tries to process unscheduled jobs in the time interval [
                        
                           T
                           −
                           ⌈
                           
                              
                                 T
                                 −
                                 
                                    T
                                    
                                       l
                                       −
                                       1
                                    
                                 
                              
                              p
                           
                           ⌉
                           p
                           ,
                        
                      
                     T]. There are 
                        
                           ⌈
                           
                              
                                 T
                                 −
                                 
                                    T
                                    
                                       l
                                       −
                                       1
                                    
                                 
                              
                              p
                           
                           ⌉
                        
                      time slots in this time interval and it can process a total of 
                        
                           m
                           K
                           ⌈
                           
                              
                                 T
                                 −
                                 
                                    T
                                    
                                       l
                                       −
                                       1
                                    
                                 
                              
                              p
                           
                           ⌉
                        
                      jobs. The algorithm puts all the unscheduled jobs whose deadline is larger than or equal to Tl
                      into the set A. The jobs in A are then considered in decreasing order of their profits, each time checking if it can be processed in one of the time slots and delivered by one of the vehicles between its deadline and Tl
                     . When all the jobs in A have been considered, we set T to be 
                        
                           T
                           −
                           ⌈
                           
                              
                                 T
                                 −
                                 
                                    T
                                    
                                       l
                                       −
                                       1
                                    
                                 
                              
                              p
                           
                           ⌉
                           p
                        
                      and start the next iteration. This process is repeated until T becomes 0. Our algorithm, to be called Algorithm Sch-Id-Size, is given below.


                     Algorithm Sch-Id-Size
                     
                        
                           1.
                           
                              
                                 
                                    J
                                    :
                                    =
                                    {
                                    
                                       J
                                       1
                                    
                                    ,
                                    
                                       J
                                       2
                                    
                                    ,
                                    …
                                    ,
                                    
                                       J
                                       n
                                    
                                    }
                                 
                               and R ≔ 0. The jobs are sorted in descending order of their profits; i.e., R
                              1 ≥ R
                              2 ≥ … ≥ Rn
                              . Moreover, they are doubly linked so that we can delete a job efficiently.    /*
                              
                                 J
                               is the set of all jobs and R is the profit earned. */

For j from 1 to n do

                                 
                                    Let i be the largest index such that Ti
                                        ≤ dj
                                        and let 
                                          
                                             T
                                             
                                                D
                                                j
                                             
                                          
                                        be Ti
                                       .    /*
                                       
                                          
                                             T
                                             
                                                D
                                                j
                                             
                                          
                                        is the deadline of Jj
                                       . */

For i from 1 to z do

                                 
                                    
                                       Vi
                                        ≔ viC.    /* 
                                       Vi
                                        is the capacity of the vehicles at time Ti
                                       . */


                              T ≔ Tz
                              .

Let l be the smallest index such that T ≤ Tl
                              , 
                                 
                                    S
                                    L
                                    :
                                    =
                                    m
                                    K
                                    ⌈
                                    
                                       
                                          T
                                          −
                                          
                                             T
                                             
                                                l
                                                −
                                                1
                                             
                                          
                                       
                                       p
                                    
                                    ⌉
                                 
                              .    /* Jobs will be processed in 
                                 
                                    ⌈
                                    
                                       
                                          T
                                          −
                                          
                                             T
                                             
                                                l
                                                −
                                                1
                                             
                                          
                                       
                                       p
                                    
                                    ⌉
                                 
                               time slots, starting at T. The first time slot is [
                                 
                                    T
                                    −
                                    p
                                    ,
                                 
                               
                              T], the second time slot is [
                                 
                                    T
                                    −
                                    2
                                    p
                                    ,
                                 
                              
                              
                                 
                                    T
                                    −
                                    p
                                 
                              ], and so on. In each time slot we can process mK jobs. */


                              
                                 
                                    A
                                    :
                                    =
                                    {
                                    
                                       J
                                       j
                                    
                                    ∣
                                    
                                       J
                                       j
                                    
                                    ∈
                                    J
                                    
                                    and
                                    
                                    
                                       T
                                       
                                          D
                                          j
                                       
                                    
                                    ≥
                                    
                                       T
                                       l
                                    
                                    }
                                    ,
                                 
                               
                              nA
                               ≔ |A|, sort the jobs in A in descending order of their profits; i.e., 
                                 
                                    
                                       R
                                       1
                                    
                                    ≥
                                    
                                       R
                                       2
                                    
                                    ≥
                                    .
                                    .
                                    .
                                    ≥
                                    
                                       R
                                       
                                          n
                                          A
                                       
                                    
                                 
                              .

For j from 1 to nA
                               do
                                 
                                    (a)
                                    If 
                                          
                                             S
                                             L
                                             =
                                             0
                                          
                                        then goto Step 8.


                                       
                                          
                                             
                                                T
                                                i
                                             
                                             :
                                             =
                                             
                                                T
                                                
                                                   D
                                                   j
                                                
                                             
                                          
                                       .

While (Ti
                                        ≥ Tl
                                       ) do

                                          
                                             If (Vi
                                                 > 0) then goto Step 7(e).


                                                
                                                   
                                                      i
                                                      :
                                                      =
                                                      i
                                                      −
                                                      1
                                                   
                                                .

Next j.


                                       
                                          
                                             
                                                V
                                                i
                                             
                                             :
                                             =
                                             
                                                V
                                                i
                                             
                                             −
                                             1
                                             ,
                                          
                                       
                                       
                                          
                                             S
                                             L
                                             :
                                             =
                                             S
                                             L
                                             −
                                             1
                                             ,
                                          
                                       
                                       
                                          
                                             R
                                             :
                                             =
                                             R
                                             +
                                             
                                                R
                                                j
                                             
                                             ,
                                          
                                        process job Jj
                                        in one of the time slots in [
                                          
                                             T
                                             −
                                             ⌈
                                             
                                                
                                                   T
                                                   −
                                                   
                                                      T
                                                      
                                                         l
                                                         −
                                                         1
                                                      
                                                   
                                                
                                                p
                                             
                                             ⌉
                                             p
                                             ,
                                          
                                        
                                       T] and deliver Jj
                                        by one of the vehicles at time Ti
                                       , delete Jj
                                        from 
                                          J
                                       .


                              
                                 
                                    T
                                    :
                                    =
                                    T
                                    −
                                    ⌈
                                    
                                       
                                          T
                                          −
                                          
                                             T
                                             
                                                l
                                                −
                                                1
                                             
                                          
                                       
                                       p
                                    
                                    ⌉
                                    p
                                 
                              .

If T > 0 then goto Step 5.

Return R.


                           The running time of Algorithm Sch-Id-Size is
                           
                              
                                 O
                                 (
                                 n
                                 
                                    (
                                    
                                       z
                                       2
                                    
                                    +
                                    log
                                    n
                                    )
                                 
                                 )
                              
                           
                           .
                        

In Step 1 of the algorithm, we sort the jobs in descending order of their profits, i.e., R
                           1 ≥ R
                           2 ≥ ⋅⋅⋅ ≥ Rn
                           . The jobs will be doubly linked so that we can delete a job efficiently. Thus, Step 1 takes O(nlog n) time. In Step 2 of the algorithm, we sort the delivery times in ascending order; i.e., T
                           1 ≤ T
                           2 ≤ ⋅⋅⋅ ≤ Tz
                           . For each job Jj
                           , we conduct a binary search to find the largest Ti
                            such that Ti
                            ≤ dj
                           . Thus, Step 2 takes 
                              
                                 O
                                 (
                                 z
                                 log
                                 z
                                 +
                                 n
                                 log
                                 z
                                 )
                              
                            time. Step 3 takes O(z) time and Step 4 takes constant time. Steps 5–9 constitute a loop that has at most z iterations. Step 5 takes O(log z) time. In Step 6, we traverse the doubly linked list of jobs in 
                              J
                            to pick up all the jobs with 
                              
                                 
                                    T
                                    
                                       D
                                       j
                                    
                                 
                                 ≥
                                 
                                    T
                                    l
                                 
                              
                           . This takes O(n) time. The most expensive part of Step 7 is Step 7(c), which takes O(z) time. Thus, Step 7 takes O(zn) time. Steps 8 and 9 take constant time. Thus, it takes O(zn) time for each iteration of the loop. Since there are at most z iterations, the total time taken in Steps 5 to 9 is O(z
                           2
                           n). Combining the time taken in Steps 1 to 4, the total time taken is 
                              
                                 O
                                 (
                                 n
                                 
                                    (
                                    
                                       z
                                       2
                                    
                                    +
                                    log
                                    n
                                    )
                                 
                                 )
                              
                           .□


                           Algorithm Sch-Id-Size correctly solves
                           
                              
                                 P
                                 ∣
                                 fdep
                                 ,
                                 p
                                 −
                                 batch
                                 ,
                                 
                                    s
                                    j
                                 
                                 =
                                 1
                                 ∣
                                 ∑
                                 
                                    R
                                    j
                                 
                              
                           
                           .
                        

For each 1 ≤ j ≤ n, job Jj
                            cannot be delivered after its due date, but it can be delivered earlier. Therefore, we schedule the jobs backwards, starting at time 
                              
                                 T
                                 =
                                 
                                    T
                                    z
                                 
                              
                           . Since we assume that Tz
                            is an integral multiple of p, there are Tz
                           /p time slots that can be used to process the jobs. We schedule the jobs step by step. Starting with 
                              
                                 T
                                 =
                                 
                                    T
                                    z
                                 
                                 ,
                              
                            the next stopping point will be 
                              
                                 T
                                 −
                                 ⌈
                                 
                                    
                                       T
                                       −
                                       
                                          T
                                          
                                             z
                                             −
                                             1
                                          
                                       
                                    
                                    p
                                 
                                 ⌉
                                 p
                              
                           . There are 
                              
                                 ⌈
                                 
                                    
                                       T
                                       −
                                       
                                          T
                                          
                                             z
                                             −
                                             1
                                          
                                       
                                    
                                    p
                                 
                                 ⌉
                              
                            time slots in the time interval [
                              
                                 T
                                 −
                                 ⌈
                                 
                                    
                                       T
                                       −
                                       
                                          T
                                          
                                             z
                                             −
                                             1
                                          
                                       
                                    
                                    p
                                 
                                 ⌉
                                 p
                                 ,
                              
                            
                           T], capable of processing 
                              
                                 m
                                 K
                                 ⌈
                                 
                                    
                                       T
                                       −
                                       
                                          T
                                          
                                             z
                                             −
                                             1
                                          
                                       
                                    
                                    p
                                 
                                 ⌉
                              
                            jobs. The jobs processed in these time slots will be delivered by the vehicles at Tz
                           . We collect all the jobs whose due date is at least Tz
                            in the set A, and consider them in descending order of their profits. Suppose we are considering Jj
                           . If there is sufficient processing capability and sufficient vehicle capacity at Tz
                           , we can schedule Jj
                            and we delete Jj
                            from the master list of jobs 
                              J
                           . We also update the processing capability and vehicle capacity. Otherwise, we will not delete Jj
                            from 
                              J
                            and consider the next job. We repeat this process until all jobs in A have been considered.

Note that when we consider whether there is a vehicle available to deliver job j, we start with time 
                              
                                 T
                                 
                                    D
                                    j
                                 
                              
                            and work towards time Tl
                            (
                              
                                 
                                    T
                                    l
                                 
                                 ≤
                                 
                                    T
                                    
                                       D
                                       j
                                    
                                 
                              
                           ). (This is shown in Step 7(c).) In other words, we try to use up the capacity at a later time before we use the capacity at an earlier time. This is because a job can always be delivered earlier, but cannot be delivered late.

After we consider all the jobs in A, we start another round at time 
                              
                                 T
                                 −
                                 ⌈
                                 
                                    
                                       T
                                       −
                                       
                                          T
                                          
                                             z
                                             −
                                             1
                                          
                                       
                                    
                                    p
                                 
                                 ⌉
                                 p
                              
                           . This process is repeated until we reach time 
                              
                                 T
                                 =
                                 0
                              
                           . We will prove, by contradiction, that the schedule produced will maximize the total profit earned.

Suppose the schedule produced does not maximize the total profit. Let 
                              
                                 J
                                 =
                                 {
                                 
                                    J
                                    1
                                 
                                 ,
                                 
                                    J
                                    2
                                 
                                 ,
                                 …
                                 ,
                                 
                                    J
                                    n
                                 
                                 }
                              
                            be the smallest (in terms of the number of jobs) counterexample. Let Jx
                            be the first job that Algorithm Sch-Id-Size schedules and produces a profit while the optimal algorithm does not schedule Jx
                           . In other words, from J
                           1 to 
                              
                                 J
                                 
                                    x
                                    −
                                    1
                                 
                              
                           , either Algorithm Sch-Id-Size and the optimal algorithm both schedule the job or both algorithms do not schedule the job. So, Jx
                            is the first job where there is a difference between the two algorithms. Clearly, Jx
                            is considered in the first iteration since 
                              J
                            is assumed to be the smallest counterexample. There must be another job Jy
                            that is scheduled by the optimal algorithm but not by Algorithm Sch-Id-Size, where y > x. Since y > x, we have Rx
                            ≥ Ry
                           . If we replace job Jy
                            by Jx
                            in the optimal schedule, the total profit of the optimal schedule will not decrease. By a sequence of interchanges, we can convert the optimal schedule into a schedule produced by Algorithm Sch-Id-Size. This contradicts our assumption that the schedule produced by Algorithm Sch-Id-Size does not maximize the total profit earned.□


                           The problem
                           
                              
                                 P
                                 ∣
                                 fdep
                                 ,
                                 p
                                 −
                                 batch
                                 ,
                                 
                                    s
                                    j
                                 
                                 =
                                 1
                                 ∣
                                 ∑
                                 
                                    R
                                    j
                                 
                              
                            
                           can be solved in
                           
                              
                                 O
                                 (
                                 n
                                 
                                    (
                                    
                                       z
                                       2
                                    
                                    +
                                    log
                                    n
                                    )
                                 
                                 )
                              
                            
                           time.
                        

The theorem follows from Lemmas 1 and 2.□

In this section, we assume that the jobs have non-identical sizes. We will show that 
                        
                           1
                           ∣
                           fdep,
                           
                           p-batch,
                           
                           model1
                           ,
                           
                              R
                              j
                           
                           =
                           1
                           ∣
                           ∑
                           
                              R
                              j
                           
                        
                      is unary NP-hard, even when there is only one delivery time and one vehicle.

                        Theorem 2
                        
                           The problem
                           
                              
                                 1
                                 ∣
                                 fdep
                                 ,
                                 p
                                 −
                                 batch
                                 ,
                                 model
                                 1
                                 ,
                                 
                                    R
                                    j
                                 
                                 =
                                 1
                                 ∣
                                 ∑
                                 
                                    R
                                    j
                                 
                              
                            
                           is unary NP-hard, even when there is only one delivery time and one vehicle.
                        

We shall reduce the unary NP-complete 3-Partition problem (Garey & Johnson, 1979) to a decision version of our problem. The 3-Partition problem can be stated as follows.


                           3-Partition: Given a list 
                              
                                 L
                                 =
                                 (
                                 
                                    b
                                    1
                                 
                                 ,
                                 
                                    b
                                    2
                                 
                                 ,
                                 …
                                 ,
                                 
                                    b
                                    
                                       3
                                       m
                                    
                                 
                                 )
                              
                            of 3m integers, where 
                              
                                 
                                    ∑
                                    
                                       j
                                       =
                                       1
                                    
                                    
                                       3
                                       m
                                    
                                 
                                 
                                    b
                                    j
                                 
                                 =
                                 m
                                 B
                              
                            and B/4 < bj
                            < B/2 for each 1 ≤ j ≤ 3m, is there a partition of L into m sublists L
                           1, L
                           2
                           
                              
                                 ,
                                 …
                                 ,
                              
                           
                           Lm
                            such that 
                              
                                 
                                    ∑
                                    
                                       
                                          b
                                          j
                                       
                                       ∈
                                       
                                          L
                                          i
                                       
                                    
                                 
                                 
                                    b
                                    j
                                 
                                 =
                                 B
                              
                            for each 1 ≤ i ≤ m?

Given an instance L of the 3-Partition problem, we construct an instance of the decision version of our problem as follows. There are 3m jobs, J
                           1, ...,J
                           3m
                           , and one machine. The processing time of each job is 
                              
                                 p
                                 =
                                 1
                              
                           . Job Jj
                            has size 
                              
                                 
                                    s
                                    j
                                 
                                 =
                                 
                                    b
                                    j
                                 
                                 ,
                              
                            due date 
                              
                                 
                                    d
                                    j
                                 
                                 =
                                 m
                                 ,
                              
                            and profit 
                              
                                 
                                    R
                                    j
                                 
                                 =
                                 1
                              
                           . The capacity of the machine is 
                              
                                 K
                                 =
                                 B
                              
                           . There is one job delivery time 
                              
                                 
                                    T
                                    1
                                 
                                 =
                                 m
                              
                           . The number of vehicles 
                              
                                 
                                    v
                                    1
                                 
                                 =
                                 1
                              
                            and the capacity of the vehicle is 
                              
                                 C
                                 =
                                 3
                                 m
                              
                           . The threshold of the total profit is 
                              
                                 Q
                                 =
                                 3
                                 m
                              
                           . It is easy to see that there will be a schedule with total profit greater than or equal to Q if and only if there is a solution for the 3-Partition problem.□

Motivated by the NP-hardness of the problem, we will propose a fast heuristic for model 1. Our heuristic, to be called Algorithm Heu1, is based on Algorithm Sch-Id-Size. The only difference is that we may not be able to process K jobs in one time slot on one machine, since the jobs now have different sizes. The jobs in A are considered in descending order of their profit versus size, i.e., 
                        
                           
                              
                                 R
                                 1
                              
                              
                                 s
                                 1
                              
                           
                           ≥
                           
                              
                                 R
                                 2
                              
                              
                                 s
                                 2
                              
                           
                           ≥
                           ⋯
                           ≥
                           
                              
                                 R
                                 
                                    n
                                    A
                                 
                              
                              
                                 s
                                 
                                    n
                                    A
                                 
                              
                           
                        
                     . When job Jj
                      is being considered for processing, we will try to pack it into one of the time slots by the First-Fit method used in bin-packing (Coffman, Garey, & Johnson, 1997). When we consider the delivery of Jj
                     , we use the same method as in Algorithm Sch-Id-Size to find a vehicle to deliver. Our algorithm is described below.


                     Algorithm Heu1
                     
                        
                           1.
                           
                              
                                 
                                    J
                                    :
                                    =
                                    {
                                    
                                       J
                                       1
                                    
                                    ,
                                    
                                       J
                                       2
                                    
                                    ,
                                    …
                                    ,
                                    
                                       J
                                       n
                                    
                                    }
                                 
                               and R ≔ 0.

For j from 1 to n do

                                 
                                    Let i be the largest index such that Ti
                                        ≤ dj
                                        and let 
                                          
                                             T
                                             
                                                D
                                                j
                                             
                                          
                                        be Ti
                                       .

For i from 1 to z do

                                 
                                    
                                       Vi
                                        ≔ viC.


                              T ≔ Tz
                              .

Let l be the smallest index such that T ≤ Tl
                              . Let there be 
                                 
                                    ⌈
                                    
                                       
                                          T
                                          −
                                          
                                             T
                                             
                                                l
                                                −
                                                1
                                             
                                          
                                       
                                       p
                                    
                                    ⌉
                                    m
                                 
                               time slots in the time interval [
                                 
                                    T
                                    −
                                    ⌈
                                    
                                       
                                          T
                                          −
                                          
                                             T
                                             
                                                l
                                                −
                                                1
                                             
                                          
                                       
                                       p
                                    
                                    ⌉
                                    p
                                    ,
                                 
                               
                              T].    /* Jobs will be processed in the time interval [
                                 
                                    T
                                    −
                                    ⌈
                                    
                                       
                                          T
                                          −
                                          
                                             T
                                             
                                                l
                                                −
                                                1
                                             
                                          
                                       
                                       p
                                    
                                    ⌉
                                    p
                                    ,
                                 
                               T]. Label the m time slots in the time interval [
                                 
                                    T
                                    −
                                    p
                                    ,
                                 
                               
                              T] as slots 1,2
                                 
                                    ,
                                    …
                                    ,
                                 
                              
                              m, the next m time slots in the time interval [
                                 
                                    T
                                    −
                                    2
                                    p
                                    ,
                                 
                              
                              
                                 
                                    T
                                    −
                                    p
                                 
                              ] as slots 
                                 
                                    m
                                    +
                                    1
                                 
                              
                              
                                 
                                    ,
                                    …
                                    ,
                                 
                              2m, and so on. */


                              
                                 
                                    A
                                    :
                                    =
                                    {
                                    
                                       J
                                       j
                                    
                                    |
                                    
                                       J
                                       j
                                    
                                    ∈
                                    J
                                    
                                    and
                                    
                                    
                                       T
                                       
                                          D
                                          j
                                       
                                    
                                    ≥
                                    
                                       T
                                       l
                                    
                                    }
                                    ,
                                 
                               
                              nA
                               ≔ |A|, sort the jobs in A in descending order of their profits versus sizes; i.e., 
                                 
                                    
                                       
                                          R
                                          1
                                       
                                       
                                          s
                                          1
                                       
                                    
                                    ≥
                                    
                                       
                                          R
                                          2
                                       
                                       
                                          s
                                          2
                                       
                                    
                                    ≥
                                    ⋯
                                    ≥
                                    
                                       
                                          R
                                          
                                             n
                                             A
                                          
                                       
                                       
                                          s
                                          
                                             n
                                             A
                                          
                                       
                                    
                                 
                              .

For j from 1 to nA
                               do
                                 
                                    (a)
                                    Consider scheduling job Jj
                                        by packing it into a time slot by the First-Fit method.

If Jj
                                        cannot be packed then next j.

For q from Dj
                                        down to l do
                                          
                                             (i)
                                             If 
                                                   
                                                      
                                                         V
                                                         q
                                                      
                                                      =
                                                      0
                                                   
                                                 then next q.


                                                
                                                   
                                                      
                                                         V
                                                         q
                                                      
                                                      :
                                                      =
                                                      
                                                         V
                                                         q
                                                      
                                                      −
                                                      1
                                                      ,
                                                   
                                                
                                                
                                                   
                                                      R
                                                      :
                                                      =
                                                      R
                                                      +
                                                      
                                                         R
                                                         j
                                                      
                                                      ,
                                                   
                                                 schedule Jj
                                                 in the time slot in which it was packed and deliver Jj
                                                 by one of the vehicles at time Tq
                                                , delete Jj
                                                 from 
                                                   
                                                      J
                                                      ,
                                                   
                                                 next j.

Delete Jj
                                        from the time slot in which it was packed.


                              
                                 
                                    T
                                    :
                                    =
                                    T
                                    −
                                    ⌈
                                    
                                       
                                          T
                                          −
                                          
                                             T
                                             
                                                l
                                                −
                                                1
                                             
                                          
                                       
                                       p
                                    
                                    ⌉
                                    p
                                 
                              .

If T > 0 then goto Step 5.

Return R.


                           The running time of Algorithm Heu1 is
                           
                              
                                 O
                                 (
                                 n
                                 z
                                 (
                                 z
                                 +
                                 log
                                 n
                                 )
                                 )
                              
                           
                           .
                        

The number of time slots is 
                              
                                 
                                    
                                       T
                                       z
                                    
                                    p
                                 
                                 m
                              
                           . Without loss of generality, we may assume that 
                              
                                 n
                                 >
                                 
                                    
                                       T
                                       z
                                    
                                    p
                                 
                                 m
                              
                           ; otherwise, each job can be scheduled in one time slot and there is no need to pack the jobs by the First Fit method. The most time-consuming part is the loop in Steps 5–9, which is iterated at most z times. Inside the loop, the most time-consuming part is Step 7 which is done at most n times. Each time Step 7 is executed, it takes 
                              
                                 O
                                 (
                                 log
                                 
                                    (
                                    
                                       
                                          T
                                          z
                                       
                                       p
                                    
                                    m
                                    )
                                 
                                 +
                                 z
                                 )
                              
                            time. It takes 
                              
                                 O
                                 (
                                 log
                                 
                                    (
                                    
                                       
                                          T
                                          z
                                       
                                       p
                                    
                                    m
                                    )
                                 
                                 )
                              
                            time to do the packing and O(z) time to find a vehicle to deliver. Since 
                              
                                 n
                                 >
                                 
                                    
                                       T
                                       z
                                    
                                    p
                                 
                                 m
                                 ,
                              
                            the overall running time is 
                              
                                 O
                                 (
                                 n
                                 z
                                 (
                                 z
                                 +
                                 log
                                 n
                                 )
                                 )
                              
                           .□

We now turn our attention to the performance of Algorithm Heu1. We first consider the simple case where all the jobs have the same profit; i.e., 
                        
                           
                              R
                              j
                           
                           =
                           1
                        
                      for all 1 ≤ j ≤ n. For this simple case, our objective is to maximize the number of jobs that can be processed and delivered. Since each job takes one unit of capacity in the delivery and since we consider using a vehicle in a later time before we consider a vehicle in an earlier time, the jobs are delivered optimally by the algorithm. Thus, our problem is reduced to maximizing the number of jobs that can be processed.

Step 6 of our algorithm sorts the jobs in ascending order of their sizes. That is, jobs will be scheduled in increasing order of their sizes. Consider one iteration of Steps 5–9. There are 
                        
                           ⌈
                           
                              
                                 T
                                 −
                                 
                                    T
                                    
                                       l
                                       −
                                       1
                                    
                                 
                              
                              p
                           
                           ⌉
                           m
                        
                      time slots that we consider. Each time slot can be viewed as a “bin” with capacity K. The jobs can be viewed as “pieces” with size sj
                     . The nA
                      pieces will be packed into the 
                        
                           ⌈
                           
                              
                                 T
                                 −
                                 
                                    T
                                    
                                       l
                                       −
                                       1
                                    
                                 
                              
                              p
                           
                           ⌉
                           m
                        
                      bins in increasing order of their piece sizes. The objective is to maximize the number of pieces that can be packed. This is a variant of the classical one-dimensional bin-packing problem studied by Coffman, Leung, and Ting (1978), see also the Ph.D. thesis of Leung (1977). Coffman et al. (1978) considered a fast heuristic, called First-Fit-Increasing (FFI) rule, which packs the pieces in ascending order of the piece sizes into the lowest indexed bin that can accommodate the piece. The FFI rule will terminate as soon as a piece is found that cannot fit in any bin. Coffman et al. (1978) showed that

                        
                           
                              
                                 
                                    
                                       n
                                       O
                                    
                                    
                                       n
                                       
                                          F
                                          F
                                          I
                                       
                                    
                                 
                                 ≤
                                 
                                    4
                                    3
                                 
                                 ,
                              
                           
                        
                     where nO
                      denotes the optimal number of pieces packed and nFFI
                      denotes the number of pieces packed by the FFI rule.

In each iteration of Steps 5–9, Algorithm Heu1 tries to pack nA
                      pieces by the FFI rule into 
                        
                           ⌈
                           
                              
                                 T
                                 −
                                 
                                    T
                                    
                                       l
                                       −
                                       1
                                    
                                 
                              
                              p
                           
                           ⌉
                           m
                        
                      bins. Thus, the same bound will apply to our problem. Hence, we have the following theorem.

                        Theorem 4
                        
                           Suppose that the jobs have identical profits, i.e.,
                           
                              
                                 
                                    R
                                    j
                                 
                                 =
                                 1
                              
                            
                           for all 1 ≤ j ≤ n. For a given instance of the scheduling problem, let PF(h1) and PF(opt) denote the total profits obtained by Algorithm Heu1 and an optimal algorithm, respectively. Then we have 
                           
                              
                                 
                                    
                                       
                                          
                                             P
                                             F
                                             (
                                             o
                                             p
                                             t
                                             )
                                          
                                          
                                             P
                                             F
                                             (
                                             h
                                             1
                                             )
                                          
                                       
                                       ≤
                                       
                                          4
                                          3
                                       
                                       .
                                    
                                 
                              
                           
                        

In each iteration of Steps 5–9, the number of jobs scheduled by the optimal algorithm versus the number of jobs scheduled by Algorithm Heu1 is 4/3. The jobs are scheduled optimally on the vehicles. Summing over all the iterations gives us the desired result.□

When the jobs have different profits (i.e. Ri
                      ≠ Rj
                      for some i ≠ j), the worst-case ratio is a lot higher. If 
                        
                           m
                           =
                           1
                           ,
                        
                      the ratio can be unbounded as the following example shows. Suppose we have two jobs J
                     1 and J
                     2. Job J
                     1 has profit 
                        
                           
                              R
                              1
                           
                           =
                           2
                        
                      and size 
                        
                           
                              s
                              1
                           
                           =
                           1
                        
                     . Job J
                     2 has profit 
                        
                           
                              R
                              2
                           
                           =
                           X
                        
                      and size 
                        
                           
                              s
                              2
                           
                           =
                           X
                           ,
                        
                      where X is a large integer. The capacity of the machine is 
                        
                           K
                           =
                           X
                        
                     . The processing time of the job is 
                        
                           p
                           =
                           1
                        
                     . There is one delivery time 
                        
                           
                              T
                              1
                           
                           =
                           1
                        
                      and one vehicle at T
                     1. The vehicle can deliver two jobs. According to Algorithm Heu1, job J
                     1 will be processed and delivered. The optimal solution will process and deliver job J
                     2. Therefore, we have 
                        
                           P
                           F
                           (
                           o
                           p
                           t
                           )
                           /
                           P
                           F
                           (
                           h
                           1
                           )
                           =
                           X
                           /
                           2
                        
                     . When X gets large, the ratio is unbounded.

When m ≥ 2, we can get a constant bound, as the following theorem shows.

                        Theorem 5
                        
                           Suppose that the jobs have different profits and that m ≥ 2. For a given instance of the scheduling problem, let PF(h1) and PF(opt) denote the total profits obtained by Algorithm Heu1 and an optimal algorithms, respectively. Then we have 
                           
                              
                                 
                                    
                                       
                                          
                                             P
                                             F
                                             (
                                             o
                                             p
                                             t
                                             )
                                          
                                          
                                             P
                                             F
                                             (
                                             h
                                             1
                                             )
                                          
                                       
                                       ≤
                                       3
                                       .
                                    
                                 
                              
                           
                        

In each iteration of Steps 5–9, there are at least 2 “bins”, since m ≥ 2. Let there be NB bins in one iteration. Let 
                              
                                 
                                    α
                                    i
                                 
                                 =
                                 
                                    R
                                    i
                                 
                                 /
                                 
                                    s
                                    i
                                 
                              
                            for each 1 ≤ i ≤ nA
                           , i.e., αi
                            is the profit per unit space for job Ji
                           . We have 
                              
                                 
                                    α
                                    1
                                 
                                 ≥
                                 
                                    α
                                    2
                                 
                                 ≥
                                 ⋯
                                 ≥
                                 
                                    α
                                    
                                       n
                                       A
                                    
                                 
                              
                           . Let 
                              
                                 k
                                 +
                                 1
                              
                            be the first index such that Algorithm Heu1 cannot pack job 
                              
                                 J
                                 
                                    k
                                    +
                                    1
                                 
                              
                           . That is, Algorithm Heu1 can pack jobs J
                           1, J
                           2
                           
                              
                                 ,
                                 …
                                 ,
                              
                           
                           Jk
                           , but not 
                              
                                 J
                                 
                                    k
                                    +
                                    1
                                 
                              
                           . Let pf(opt) and pf(h1) denote the total profits obtained by an optimal algorithm and Algorithm Heu1 in this iteration. There are two cases to consider.


                           Case 1:
                           
                              
                                 N
                                 B
                                 =
                                 2
                              
                           .

Consider the first job packed in the second bin. The size of that job plus the total space filled up in the first bin is more than the size of one bin, K. Therefore, Algorithm Heu1 fills up at least K units of space, while the optimal algorithm fills up at most 2K units of space. Therefore, we have

                              
                                 
                                    
                                       
                                          
                                             
                                                p
                                                f
                                                (
                                                o
                                                p
                                                t
                                                )
                                             
                                          
                                          
                                             =
                                          
                                          
                                             
                                                p
                                                f
                                                
                                                   (
                                                   h
                                                   1
                                                   )
                                                
                                                
                                                   
                                                   +
                                                   
                                                
                                                
                                                   (
                                                   p
                                                   f
                                                   
                                                      (
                                                      o
                                                      p
                                                      t
                                                      )
                                                   
                                                   
                                                      
                                                      −
                                                      
                                                   
                                                   p
                                                   f
                                                   
                                                      (
                                                      h
                                                      1
                                                      )
                                                   
                                                   )
                                                
                                                
                                                   
                                                   ≤
                                                   
                                                
                                                p
                                                f
                                                
                                                   (
                                                   h
                                                   1
                                                   )
                                                
                                                
                                                   
                                                   +
                                                   
                                                
                                                
                                                   α
                                                   k
                                                
                                                *
                                                
                                                   (
                                                   2
                                                   K
                                                   
                                                      
                                                      −
                                                      
                                                   
                                                   K
                                                   )
                                                
                                             
                                          
                                       
                                       
                                          
                                          
                                             =
                                          
                                          
                                             
                                                p
                                                f
                                                
                                                   (
                                                   h
                                                   1
                                                   )
                                                
                                                +
                                                
                                                   α
                                                   k
                                                
                                                *
                                                K
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           We also have pf(h1) ≥ αk
                           *K. Hence we have

                              
                                 
                                    
                                       
                                          
                                             p
                                             f
                                             (
                                             o
                                             p
                                             t
                                             )
                                          
                                          
                                             p
                                             f
                                             (
                                             h
                                             1
                                             )
                                          
                                       
                                       ≤
                                       2
                                       .
                                    
                                 
                              
                           
                        


                           Case 2: 
                           NB ≥ 3.

In this case, Algorithm Heu1 will fill up at least 
                              
                                 (
                                 N
                                 B
                                 −
                                 1
                                 )
                                 *
                                 K
                                 /
                                 2
                              
                            units of space, while the optimal algorithm fills up at most NB*K units of space. Thus, we have

                              
                                 
                                    
                                       
                                          
                                             
                                                p
                                                f
                                                (
                                                o
                                                p
                                                t
                                                )
                                             
                                          
                                          
                                             =
                                          
                                          
                                             
                                                p
                                                f
                                                (
                                                h
                                                1
                                                )
                                                +
                                                (
                                                p
                                                f
                                                (
                                                o
                                                p
                                                t
                                                )
                                                −
                                                p
                                                f
                                                (
                                                h
                                                1
                                                )
                                                )
                                             
                                          
                                       
                                       
                                          
                                          
                                             ≤
                                          
                                          
                                             
                                                p
                                                f
                                                
                                                   (
                                                   h
                                                   1
                                                   )
                                                
                                                +
                                                
                                                   α
                                                   k
                                                
                                                *
                                                
                                                   (
                                                   N
                                                   B
                                                   +
                                                   1
                                                   )
                                                
                                                *
                                                K
                                                /
                                                2
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           Since 
                              
                                 p
                                 f
                                 
                                    (
                                    h
                                    1
                                    )
                                 
                                 ≥
                                 
                                    α
                                    k
                                 
                                 *
                                 
                                    (
                                    N
                                    B
                                    −
                                    1
                                    )
                                 
                                 *
                                 K
                                 /
                                 2
                                 ,
                              
                            we have

                              
                                 
                                    
                                       
                                          
                                             p
                                             f
                                             (
                                             o
                                             p
                                             t
                                             )
                                          
                                          
                                             p
                                             f
                                             (
                                             h
                                             1
                                             )
                                          
                                       
                                       ≤
                                       1
                                       +
                                       
                                          
                                             N
                                             B
                                             +
                                             1
                                          
                                          
                                             N
                                             B
                                             −
                                             1
                                          
                                       
                                       =
                                       2
                                       +
                                       
                                          2
                                          
                                             N
                                             B
                                             −
                                             1
                                          
                                       
                                       ≤
                                       3
                                       .
                                    
                                 
                              
                           
                        

Summing over all the iterations will give us the desired result.□

While the worst-case bound of Algorithm Heu1 appears to be quite large, we believe it is much better in practice. Therefore, we conduct a computational experiment to assess its average-case behavior.

The algorithms are programmed in C++ and executed on a PC with an Intel Core 2 processor and 2 gigabyte RAM.

The machine capacity is set to 40 for all instances. The vehicle capacity of Model 1 is set to 15. The processing time of each job pj
                      is equal to p, where 
                        
                           p
                           =
                           3
                        
                     . The size and profit of each job Jj
                     , i.e., sj
                      and Rj
                     , are chosen from the discrete uniform distribution [1,40] and [1,100], respectively. The number of machines m is chosen to be 3 and 5. Two levels of the last delivery time of the vehicles, Tz
                     , are chosen, i.e., 
                        
                           
                              T
                              z
                           
                           =
                           10
                           p
                           =
                           30
                        
                      and 
                        
                           
                              T
                              z
                           
                           =
                           15
                           p
                           =
                           45
                        
                     . When 
                        
                           
                              T
                              z
                           
                           =
                           30
                           ,
                        
                      we generate 3 additional delivery times T
                     1, T
                     2 and T
                     3. 
                        
                           
                              T
                              4
                           
                           =
                           
                              T
                              z
                           
                        
                     . These additional delivery times are drawn from U[5, 28). When 
                        
                           
                              T
                              z
                           
                           =
                           45
                           ,
                        
                      we generate 5 additional delivery times T
                     1, T
                     2, T
                     3, T
                     4 and T
                     5. 
                        
                           
                              T
                              6
                           
                           =
                           
                              T
                              z
                           
                        
                     . These additional delivery times are drawn from U[6, 39). When 
                        
                           m
                           =
                           3
                           ,
                        
                      
                     vj
                      ∈ U[1, 3]. When 
                        
                           m
                           =
                           5
                           ,
                        
                      
                     vj
                      ∈ U[1, 7]. When 
                        
                           m
                           =
                           3
                           ,
                        
                      the number of jobs, n, is set to 300 for 
                        
                           
                              T
                              z
                           
                           =
                           30
                        
                      and 450 for 
                        
                           
                              T
                              z
                           
                           =
                           45
                        
                     . When 
                        
                           m
                           =
                           5
                           ,
                        
                      
                     n will be 500 for 
                        
                           
                              T
                              z
                           
                           =
                           30
                        
                      and 750 for 
                        
                           
                              T
                              z
                           
                           =
                           45
                        
                     . The due date of each job is generated after we generate the Tj
                     s. After we find out T
                     1, we then generate each due date in U[T
                     1, 1.4*Tz
                     ]. In addition, in each category of the problem by combining different levels of the parameters, five instances are generated.

We will be comparing the performance of Heu1 against an upper bound of the optimal solution. An upper bound can be obtained by allowing a job to be split across two machines. That is, if a job does not fit into a machine, then we put the first part of the job on one machine and the second part of the job on another machine. We still need to check if there is an available vehicle to deliver the job. Therefore, the algorithm to compute an upper bound is exactly the same as Algorithm Heu1, except that Step 7(a) is different.


                     Table 1
                      presents the experimental results for Heu1. Column 1 denotes the number of machines, and column 2 represents the number of jobs. Column 3 represents the value of Tz
                     , and column 4 denotes the sequence number of the instance. The performance of Heu1 is measured by 
                        
                           G
                           a
                           p
                           =
                           (
                           U
                           B
                           /
                           H
                           e
                           u
                           1
                           −
                           1
                           )
                           *
                           100
                           ,
                        
                      where UB is the upper bound of the optimal total profit and Heu1 is the total profit obtained by Algorithm Heu1. Columns 5–6 report the performance of Algorithm Heu1 when the job has unit profit, i.e., 
                        
                           
                              R
                              j
                           
                           =
                           1
                        
                      for all 1 ≤ j ≤ n. Column 5 is the total profit obtained by Algorithm Heu1, and column 6 reports the Gap of Algorithm Heu1. Columns 7–8 report the performance of Algorithm Heu1 when the jobs have unequal profit; i.e., Rj
                      ∈ U[1, 100]. Columns 7 and 8 are the total profit and the Gap obtained by Algorithm Heu1, respectively.

We first analyze the results for the unit-profit case. From Table 1, we see that the average Gap is excellent; it ranges from 0.39% to 6.72%. The results for the 3-machine case are better than those of the 5-machine case. Moreover, the results for the case of 
                        
                           
                              T
                              z
                           
                           =
                           10
                           p
                        
                      are better than the case of 
                        
                           
                              T
                              z
                           
                           =
                           15
                           p
                        
                     .

The results for the unequal-profit case are substantially higher than those of the unit-profit case; the average Gap ranges from 4.10% to 13.45%. The results show a similar pattern when compared with the unit-profit case. That is, the results for the 3-machine case are better than those of the 5-machine case, and the results for the case of 
                        
                           
                              T
                              z
                           
                           =
                           10
                           p
                        
                      are better than the case of 
                        
                           
                              T
                              z
                           
                           =
                           15
                           p
                        
                     .

Comparing the unit-profit case with the unequal-profit case, we see that the unit-profit case is uniformly better than the unequal-profit case. This supports our theoretical results as shown in Theorems 4 and 5, i.e., the unit-profit case has a smaller worst-case ratio than the unequal profit case.

In this section we will give a heuristic for model 2. Our heuristic, to be called Algorithm Heu2, is similar to Algorithm Heu1. The only difference is that after a job is packed into a time slot, it still needs to be packed into a vehicle. Therefore, a job needs to be packed twice, once into a time slot and once into a vehicle. The algorithm is described below.


                     Algorithm Heu2
                     
                        
                           1.
                           
                              
                                 
                                    J
                                    :
                                    =
                                    {
                                    
                                       J
                                       1
                                    
                                    ,
                                    
                                       J
                                       2
                                    
                                    ,
                                    …
                                    ,
                                    
                                       J
                                       n
                                    
                                    }
                                 
                               and R ≔ 0.

For j from 1 to n do

                                 
                                    Let i be the largest index such that Ti
                                        ≤ dj
                                        and let 
                                          
                                             T
                                             
                                                D
                                                j
                                             
                                          
                                        be Ti
                                       .


                              T ≔ Tz
                              .

Let l be the smallest index such that T ≤ Tl
                              . Let there be 
                                 
                                    ⌈
                                    
                                       
                                          T
                                          −
                                          
                                             T
                                             
                                                l
                                                −
                                                1
                                             
                                          
                                       
                                       p
                                    
                                    ⌉
                                    m
                                 
                               time slots in the time interval [
                                 
                                    T
                                    −
                                    ⌈
                                    
                                       
                                          T
                                          −
                                          
                                             T
                                             
                                                l
                                                −
                                                1
                                             
                                          
                                       
                                       p
                                    
                                    ⌉
                                    p
                                    ,
                                 
                               
                              T].    /* Jobs will be processed in the time interval [
                                 
                                    T
                                    −
                                    ⌈
                                    
                                       
                                          T
                                          −
                                          
                                             T
                                             
                                                l
                                                −
                                                1
                                             
                                          
                                       
                                       p
                                    
                                    ⌉
                                    *
                                    p
                                    ,
                                 
                               
                              T]. Label the m time slots in the time interval [
                                 
                                    T
                                    −
                                    p
                                    ,
                                 
                               
                              T] as slots 1,2
                                 
                                    ,
                                    …
                                    ,
                                 
                              
                              m, the next m time slots in the time interval [
                                 
                                    T
                                    −
                                    2
                                    p
                                    ,
                                 
                              
                              
                                 
                                    T
                                    −
                                    p
                                 
                              ] as slots 
                                 
                                    m
                                    +
                                    1
                                 
                              
                              
                                 
                                    ,
                                    …
                                    ,
                                 
                              2m, and so on. */


                              
                                 
                                    A
                                    :
                                    =
                                    {
                                    
                                       J
                                       j
                                    
                                    |
                                    
                                       J
                                       j
                                    
                                    ∈
                                    J
                                    
                                    and
                                    
                                    
                                       T
                                       
                                          D
                                          j
                                       
                                    
                                    ≥
                                    
                                       T
                                       l
                                    
                                    }
                                    ,
                                 
                               
                              nA
                               ≔ |A|, sort the jobs in A in descending order of their profits versus sizes, i.e., 
                                 
                                    
                                       
                                          R
                                          1
                                       
                                       
                                          s
                                          1
                                       
                                    
                                    ≥
                                    
                                       
                                          R
                                          2
                                       
                                       
                                          s
                                          2
                                       
                                    
                                    ≥
                                    ⋯
                                    ≥
                                    
                                       
                                          R
                                          
                                             n
                                             A
                                          
                                       
                                       
                                          s
                                          
                                             n
                                             A
                                          
                                       
                                    
                                 
                              .

For j from 1 to nA
                               do
                                 
                                    (a)
                                    Consider scheduling job Jj
                                        in A by packing it into a time slot by the First-Fit method.

If Jj
                                        cannot be packed into one of the time slots, then next j.


                                       
                                          
                                             
                                                T
                                                i
                                             
                                             :
                                             =
                                             
                                                T
                                                
                                                   D
                                                   j
                                                
                                             
                                          
                                       .

Arrange the vehicles at times Ti
                                        down to Tl
                                        in sequence. That is, the vi
                                        vehicles at time Ti
                                        will be the first vi
                                        vehicles, the 
                                          
                                             v
                                             
                                                i
                                                −
                                                1
                                             
                                          
                                        vehicles at 
                                          
                                             T
                                             
                                                i
                                                −
                                                1
                                             
                                          
                                        will be the next 
                                          
                                             v
                                             
                                                i
                                                −
                                                1
                                             
                                          
                                        vehicles, and so on, until the vl
                                        vehicles at Tl
                                        will be the last vl
                                        vehicles.

Pack Jj
                                        into one of the vehicles by the First-Fit method.

If Jj
                                        cannot be packed, then delete Jj
                                        from the time slot in which it was packed and next j.


                                       
                                          
                                             R
                                             :
                                             =
                                             R
                                             +
                                             
                                                R
                                                j
                                             
                                             ,
                                          
                                        schedule Jj
                                        in the time slot in which it was packed and deliver it by the vehicle in which it was packed, delete Jj
                                        from 
                                          J
                                       .


                              
                                 
                                    T
                                    :
                                    =
                                    T
                                    −
                                    ⌈
                                    
                                       
                                          T
                                          −
                                          
                                             T
                                             
                                                l
                                                −
                                                1
                                             
                                          
                                       
                                       p
                                    
                                    ⌉
                                    *
                                    p
                                 
                              .

If T > 0 then goto Step 4.

Return R.


                           The running time of Algorithm Heu2 is
                           
                              
                                 O
                                 (
                                 n
                                 z
                                 (
                                 z
                                 +
                                 log
                                 n
                                 +
                                 log
                                 V
                                 )
                                 )
                                 ,
                              
                            
                           where
                           
                              
                                 V
                                 =
                                 
                                    ∑
                                    
                                       i
                                       =
                                       1
                                    
                                    z
                                 
                                 
                                    v
                                    i
                                 
                              
                           
                           .
                        

Algorithm Heu2 is similar to Algorithm Heu1, except that it has to pack a job into a vehicle. There are V vehicles in the system and we can pack a job in O(log V) time. The result follows.□

We now turn our attention to the performance of Algorithm Heu2. Since a job is involved in bin packing twice, it will be very difficult to obtain a worst-case bound. Therefore, we resort to computational studies.

In this experiment, the parameter settings are the same as those used in model 1, except that the vehicle capacity is set to 480. The experimental results are shown in Table 2
                     . Columns 1–4 denote the number of machines, the number of jobs, the value of Tz
                      and the sequence number of the instance, respectively. Columns 5–6 report the performance of Algorithm Heu2 with the unit job profit. Column 5 reports the total profit obtained by Algorithm Heu2, and column 6 reports the Gap of algorithm Heu2. Columns 7–8 report the performance of Algorithm Heu2 when the jobs have unequal profit. Columns 7 and 8 are the total profit and the Gap obtained by Algorithm Heu2, respectively.

The computation of an upper bound for model 2 is slightly different from model 1. Not only can a job be split across two different machines, it can also be split across two different vehicles. Thus, we can use Algorithm Heu2 to compute an upper bound for model 2, except that Steps 6(a) and 6(e) need to be changed to reflect the possibility of job splitting.

From Table 2, we see that the average Gap of the unit-profit case ranges from 6.83% to 9.10%, and the average Gap of the unequal-profit case ranges from 13.61% to 14.71%. The results for the 3-machine case are slightly better than the 5-machine case; this is true for both the unit-profit case and the unequal-profit case. As in model 1, the results for the unit-profit case are uniformly better than the results for the unequal-profit case.

Comparing Table 1 with Table 2, we see that the results for model 1 are better than those of model 2. This is expected since model 1 assumes that each job takes one unit of capacity of the vehicle, whereas model 2 assumes that each job takes a capacity exactly the size of the job. Model 1 is involved with bin packing only once (i.e., assigning jobs to the machines), while model 2 is involved in bin packing twice (i.e., once when we assign jobs to the machines and once when we assign jobs to the vehicles). Therefore, the computation of the upper bound for the optimal solution is inflated twice in model 2, versus once in model 1. Thus, we expect the upper bound in model 2 to be larger than that of model 1. Hence, the results in model 2 are larger than model 1.

In this paper we gave a polynomial-time algorithm when the job sizes are identical. When the job sizes are different, we showed that the problem is unary NP-hard, even for one machine, one delivery time, and identical profits. We gave several heuristics and computational experiments showed that they perform very well in practice.

There are several research directions that we think are worthwhile to pursue. First, the complexity of the problem is still open when the jobs have different processing times but identical sizes. For example, what is the complexity of the problem when there is a single machine and jobs belong to q different families, where jobs belonging to the same family can be batched together? Second, can we prove a tighter worst-case bound for Algorithm Heu1 when the jobs have different profits? We believe that the actual bound is smaller than 3. Third, it will be interesting to develop fast heuristics for the case where the machines have different capacities or the case where the vehicles have different capacities. Fourth, the issue of online scheduling has not been studied at all. It will be interesting to develop an optimal or near-optimal online scheduler for a single machine.

@&#ACKNOWLEDGMENTS@&#

We would like to thank the three referees whose suggestions have greatly improve the readability of the paper. The work of the first author is supported by the National Natural Science Foundation of China under Grants 71101040, 71131002 and 71471052. The work of the second author is supported by the National Natural Science Foundation of China under Grant 71171184, the Science Foundation of Anhui University (33050044) and the Foundation of China Scholarship Council (201206505002).

@&#REFERENCES@&#

