@&#MAIN-TITLE@&#Evaluating the simulation times and mass balance errors of component-based models: An application of OpenMI 2.0 to an urban stormwater system

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We compared coupled OpenMI components with equivalent standard SWMM configuration.


                        
                        
                           
                           SWMM was decomposed by process and space to explore coupling performance penalties.


                        
                        
                           
                           Performance was evaluated in terms of simulation time and mass balance error.


                        
                        
                           
                           We illustrate performance penalties to consider when using component-based models.


                        
                        
                           
                           Strategies to address computational costs of component-based models are proposed.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

OpenMI

SWMM

Computational costs

Component-based modeling

@&#ABSTRACT@&#


               
               
                  In making the decision whether to use component-based modeling, its benefits must be balanced against computational costs. Studies evaluating these costs using the Open Modeling Interface (OpenMI) have largely used models with simplified formulations, small spatial and temporal domains, or a limited number of components. We evaluate these costs by applying OpenMI to a relatively complex Stormwater Management Model (SWMM) for the City of Logan, Utah, USA. Configurations of coupled OpenMI components resulting from decomposing the stormwater model by process (i.e., runoff coupled to routing) and then by space (i.e., groups of catchments coupled together) were compared to a reference model executed in the standard SWMM configuration. Simulation times increased linearly with the number of connections between components, and mass balance error was a function of the degree to which a component resolved time series data received. This study also examines and proposes some strategies to address these computational costs.
               
            

We developed the SWMMOpenMIComponent (a C# SWMM Component), SWMMOpenMINoGlobals (a modified, native C SWMM computational engine code underlying the component), and a modified OpenMI C# project. We forked the OpenMI 2.0 C# project, including the Software Development Kit (SDK), the command line interface, and the OpenMI Configuration Editor found at http://sourceforge.net/p/openmi/code/HEAD/tree/trunk/src/csharp for this study. In addition to implementing minor bug fixes to ensure that the code compiled, we implemented a new graphical user interface for creating connections with chained adapters in accordance with the OpenMI 2.0 specification, a new simulation monitoring dialog, and fixed the project file reading and writing classes to ensure that connections with adapters are read and written properly.

Caleb A. Buahin


                        caleb.buahin@aggiemail.usu.edu
                     

2015

PC running Microsoft Windows

The C# SWMM Component (SWMMOpenMIComponent) and its underlying modified native C SWMM library (SWMMOpenMINoGlobals) are freely available under the GNU Lesser General Public License (LGPL) license at https://github.com/cbuahin/SWMMOpenMIComponent. The source code for the modified version of the OpenMI C# project can be found at https://github.com/cbuahin/OpenMI under the LGPL license.

@&#INTRODUCTION@&#

Traditional model development in the earth systems modeling field has largely been characterized by monolithic codes with highly interdependent functions compiled into a single executing unit. Models developed using this approach are referred to as tightly coupled models (Sui and Maggio, 1999). This approach to model development provides a developer complete control over a modeling system and has the advantage of allowing the optimization of computational performance across an entire modeling system (Castronova and Goodall, 2013). However, tightly coupled models are often overly specialized to the specific applications for which they were developed. This can make them inflexible for applications to different use cases. Additionally, adapting to technological advancements and isolating and remediating errors can be challenging for tightly coupled models (Szyperski, 2002).

Component-based modeling, or loose model coupling, is an alternative model development paradigm that has been proposed to overcome the challenges identified with tightly coupled models. It involves decomposing a complex system into smaller functional units called “components” that have specified interfaces, which allows them to be coupled together to represent a larger and more complex system. A definition that captures the critical properties a component must possess was provided by Szyperski and Pfister (1997). They defined a component as a unit of composition with contractually specified interfaces and explicit context dependencies that can be deployed independently and is subject to composition by third parties. This general trend toward the use of components for software development is part of a movement within software engineering toward the assembly of complex systems by building from readily available, reusable parts (Gross, 2005). This approach to development promises greater reusability, extensibility, and maintainability as well as faster development times and more robust applications with lower development and long-term maintenance costs (Löwy, 2003). For earth systems modelers, component-based modeling provides a way to represent the complex dynamics that describe earth processes more holistically by allowing them to experiment with different model formulations and ultimately selecting those that are most appropriate for their specific study. It also facilitates interdisciplinary studies and integrated natural resources management efforts by allowing researchers to better explore relationships between domains of different sub-disciplines that are typically studied and modeled independently (Argent et al., 1999; Moore and Tindall, 2005; Peckham et al., 2013).

A key requirement for the successful adoption and use of component-based models is the definition of clear and well-defined standards, specifications, and frameworks that describe how components are to be developed to enable interoperability as well as the proper context for their use. However, the addition of a component-based modeling framework that implements these standards on top of the native computational codes of existing models is likely to introduce performance costs into a modeling system. These costs may include increased total simulation times resulting from function calls and data transformations introduced by the underlying component-based framework. Additionally, errors may arise because of the discontinuities at the connection points between components over which data is exchanged. In order for component-based modeling frameworks to be adopted and used effectively, these computational performance cost considerations must be investigated and understood under realistic modeling scenarios.

An understanding of the computational costs of component-based modeling will be instructive to model developers trying to assess the tradeoffs between the two modeling development paradigms for a particular model development effort. Large computing resource demands (e.g., large total simulation times) may preclude the use of component-based modeling frameworks for complex modeling studies spanning large spatial and/or temporal domains – e.g., climate and land use change evaluations. These demands may also make it more difficult to conduct integrated natural resource management, impact mitigation, model calibration, or forecasting studies using stochastic, optimization, or data assimilation methods, which typically require many simulations of a particular model with varied inputs. Accurate model predictions are important for applications where there are elevated societal risks associated with the processes being simulated (e.g., simulation of flood risk), and an assessment of model error introduced through coupling is important in evaluating the appropriateness of model coupling for these purposes.

Examples of component-based modeling frameworks and standards in the earth systems field include: the Earth System Modeling Framework (ESMF) (Hill et al., 2004), Model Coupling Toolkit (MCT) (Warner et al., 2008), Community Surface Dynamics Modeling System (CSDMS) (Peckham et al., 2013), Object Modeling System (OMS) (David et al., 2002), and the Open Modeling Interface (OpenMI) standard (Moore and Tindall, 2005; Gregersen et al., 2005, 2007). Of these frameworks, OpenMI has recently been formally adopted as an Open Geospatial Consortium (OGC) standard (Vanecek and Moore, 2014) and is becoming more widely used.

In this study, we evaluated the performance of OpenMI as the number of coupled model components increases. We employed the United States Environmental Protection Agency's (USEPA) Stormwater Management Model (SWMM) to develop a reference SWMM model for the stormwater conveyance system for the City of Logan, Utah, USA. This reference model was run in its standard, tightly coupled SWMM configuration and compared to several coupled model configurations using OpenMI 2.0. To derive the coupled model configurations for comparison, the native SWMM computational code was first wrapped as an OpenMI 2.0 compliant component library. The reference stormwater model was then decomposed by process (i.e., runoff coupled to routing) and then by space (i.e., individual catchments or groups of catchments with their associated hydraulic routing elements coupled to each other). Each of the model components that were coupled was represented using the SWMM OpenMI component library that we developed. We chose SWMM because it is widely used in practice for urban stormwater studies and can simulate backwater flows, pressurized flows, flow reversals, and non-dendritic stream and pipe network layouts (Rossman, 2010). SWMM's underlying formulations and setup options are similar to many hydrologic and hydrodynamic models and is, therefore, a useful model for exploring the general challenges to be expected when loosely coupling models.

Comparison of the coupled modeling configurations and the reference model was accomplished by using total simulation time and total mass balance error (TMBE) as evaluation metrics. In general, for many hydrologic, hydraulic, and hydrodynamic models, using long time-steps yields shorter total simulation times. However, longer time-steps can produce larger TMBE. We therefore sought to create an experiment that could help assess the tradeoffs between TMBE and total simulation time by varying time-steps for all the model configurations evaluated.

@&#BACKGROUND@&#

OpenMI was developed in an effort to provide a comprehensive modeling system to address the European Union's (EU) Water Framework Directive (WFD). The WFD aims to achieve good ecological status of surface waters through integrated river basin management by the year 2015 (Blind et al., 2005). The development of OpenMI resulted from a collaboration between researchers, practitioners, and some of Europe's well known commercial modeling software vendors with some sponsorship from the EU.

OpenMI was developed using an object-oriented approach with clear and logical inheritance relationships between classes. Interfaces underlie the OpenMI standard, as is the case with many component-based modeling frameworks. Interfaces define a logical grouping of method definitions that acts as a contract for inter-component communication and communication between components and their underlying frameworks; each component is free to provide details of its own interpretation of the method definitions provided by an interface (Fröhlich and Franz, 1999; Löwy, 2003). Frameworks provide the environment in which components interact with each other. To make migration to OpenMI 2.0 less tedious and give developers flexibility to optimize data exchange between components, the OpenMI developers proposed standard interface definitions that define direct runtime data exchange between components with no dependence on the framework in which they execute.

The interface defining a component in the OpenMI 2.0 specification is the IBaseLinkableComponent. This interface controls the underlying computational engine of a model component. It contains functions for initializing and validating the model component, applying input data, providing output data, performing time-stepping, among others. The IBaseLinkableComponent interface also has two lists of IBaseInput and IBaseOutput exchange items that define the data that can be consumed and supplied by the component respectively. Exchange items define: (1) the variable being exchanged and units (e.g., flow (cms), flux (kg/m2/s)) through the IValueDefinition and IUnit interfaces; (2) the geographic location at which the data are exchanged through the ISpatialDefinition and IElementset interfaces; (3) the time period over which data are exchanged through the ITime and ITimeset interfaces; and (4) the values to be exchanged through the IBaseValueSet interface. An IBaseInput exchange item has a provider property, which is an IBaseOutput exchange item of another component that supplies the IBaseInput's data. Correspondingly, an IBaseOutput exchange item has a list of consumers, which are the IBaseInput exchange items requesting data from that IBaseOutput. These linkages effectively establish the coupling between models.

OpenMI 2.0 was developed using a pull-based, pipe-and-filter architecture (Buschmann, 1996), which consists of communicating components (source components and target components) that exchange memory-based data in a predefined way and format (Gregersen et al., 2007). To initiate data exchange and computation in the coupled component chain, the component at the end of the component chain serves as a trigger called by the framework for initiating a simulation. This trigger component requests the data it needs from source components linked to it and blocks any requests to itself until the requested data is returned. Components linked to this trigger component may propagate their own requests with blocking through the chained system and then compute the data requested from them upon receipt of responses to their requests (Fig. 1
                        ). This process repeats itself autonomously until the trigger component finishes its simulation.

In the case of bidirectionally-linked components, where two linked components request data from each other, OpenMI prevents infinite recursion, as well as race conditions and deadlocking in multi-threaded implementations by blocking additional function calls to get values on a component's IBaseOutput exchange items if the component is already inside a function call to get values.

A type of an IBaseOutput exchange item called an IBaseAdaptedOutput can be used to mediate the data exchange between an IBaseOutput exchange item and an IBaseInput exchange item by transforming outputs into the type of data required by the IBaseInput exchange item. These transformations may include spatial and temporal data interpolation or extrapolation. IBaseAdaptedOutput exchange items can be chained together to provide proper order for data transformations as shown in Fig. 2
                        .

The data exchange over an OpenMI connection is inherently explicit in that each model component solves its own set of equations based on variable values that apply to the beginning of a time interval and returns variable values that apply to the end of the time interval or to the time interval as a whole (Fenske et al., 2011). This explicit time marching scheme is common to other loosely coupled frameworks and imposes the Courant-Fredrichs-Lewy (CFL) criteria (Courant et al., 1928) as a condition necessary (but not sufficient) for numerical stability and, therefore, model convergence. The purpose of the CFL criteria is to ensure that the distance traveled by a signal (e.g., a hydraulic wave) in one time-step does not exceed the size of the spatial discretization (i.e., the size of an element that it travels through). Model time-steps larger than the time-step calculated as a result of the CFL criteria may lead to model instability and non-convergence, decreasing the degree to which the conservation laws are obeyed and giving rise to mass balance errors.

Applications of OpenMI have explored coupling models with spatially disparate discretizations and domains with feedbacks between model components (Elag et al., 2011; Yamagata et al., 2012), leveraging web service technologies to access model boundary data and to couple models over remote servers (Goodall et al., 2011; Castronova et al., 2013; Goodall et al., 2013; Bulatewicz et al., 2014), and for inter-disciplinary model coupling studies (Goodall et al., 2013; Knapen et al., 2013). Studies investigating the computational performance of OpenMI implementations have largely focused on hypothetical scenarios with simplified model formulations, often using small spatial and temporal domains and a limited number of components as examples to demonstrate methods and approaches. For example, in their study of the feedbacks between two temporally misaligned OpenMI components comprised of a surface water model component overlaying a sediment media model component, Elag et al. (2011) assumed a laterally averaged transport model over a simplified rectangular mesh. The three-dimensional advection–diffusion equation was simplified to only advection in the x-direction and diffusion in the z-direction for the water model and only diffusive transport in the z-direction for the sediment media model. Yamagata et al. (2012) provide another such example of a hypothetical study. They coupled the MIKE-SHE (Abbott et al., 1986; Refsgaard et al., 2010) distributed hydrologic model and the finite element subsurface flow and transport model FEFLOW (Diersch, 2014). Their study considered a simplified spatial domain and attempted to reproduce analytical results from the test problem proposed by Hunt (1999). This test is characterized by drawdown due to constant pumping in a simplified homogeneous aquifer bounded by a constant head on one side and by a stream boundary on the other. The few examples of OpenMI being used for realistic studies over large spatial and temporal domains provide some data on OpenMI's performance as the number of components increases. Performance has been expressed in terms of total simulation time or model accuracy metrics, but rarely both (Shrestha et al., 2013; Goodall et al., 2013).


                        Castronova and Goodall (2013) provide an example application detailing how OpenMI performs as the complexity of coupled components increases for a model application over a large spatial and temporal domain using standardized performance tests. In their study, they compared the widely used Hydrologic Engineering Center's Hydrologic Modeling System (HEC-HMS) rainfall runoff model with an equivalent version comprised of four coupled OpenMI components. These four components included a precipitation data component, an infiltration component, a surface runoff component, and a channel flow routing component. Model outputs from the HEC-HMS and the OpenMI model configurations were identical because Castronova and Goodall's process formulations (e.g., Muskingum routing) were the same as the HEC-HMS formulations and the unidirectional coupling employed represented the same coupling HEC-HMS uses for computational elements internally. The models' computational performance was evaluated using an endurance metric, in which the simulation time-steps were decreased, and a load test metric where the number of model computational elements was increased. Their study showed no significant differences in computational performance between the two model development paradigms. However, the unidirectional data exchange (i.e., no feedbacks between components) used makes it difficult to translate their results to more complex hydraulic/hydrodynamic models that solve the mass and momentum conservation differential equations and require feedbacks between components. Additionally, the HEC-HMS model and its equivalent coupled OpenMI components used process formulations written using different programming languages. Therefore, a direct comparison of these two models could not be used to isolate the computational costs introduced by using the OpenMI implementation because the model code was not the same.


                        Talsma et al. (2012) conducted an OpenMI study that is similar in some respects to the study we present in here. In their study, up to six OpenMI components of the SOBEK hydraulic model (Stelling and Duinmeijer, 2003), which is similar to SWMM, were coupled, resulting in a maximum of 13 connection points. The six OpenMI components of the SOBEK model represented models from six adjacent water jurisdictional areas in Netherlands. The external and bidirectionally coupled OpenMI SOBEK components were compared to their equivalent, tightly coupled SOBEK model using total simulation time as the evaluation metric. Their results showed that, compared to the implicit time marching, tightly coupled SOBEK model counterpart, the computational effort of the external bidirectional coupling using OpenMI increased disproportionally with the number of model components (Talsma et al., 2012).

We extend the Talsma et al. (2012) study by significantly increasing the number of components involved in the coupling and assessing not only total simulation times but also total mass balance errors. Although not explicitly stated in their study, a cursory study of their model segmentation as well as the long time-step used in their simulations (10 min) seem to indicate that their model was comprised of a small number of long computational elements (i.e., hydraulic routing elements including conduits, pipes, etc.). Our study involved a more complex network of conduits with varying sizes and other hydraulic structures (e.g., storage units and weirs). It is also important to note that their study, the other studies summarized here, and most OpenMI applications found in literature have used the older OpenMI Version 1.4. In our study, the latest OpenMI 2.0 specification was used.

@&#METHODS@&#

The SWMM OpenMI component used in our study was developed using the OpenMI 2.0 C# Software Development Kit (SDK) supplied by the OpenMI Association (2014). This SDK was, however, incomplete and had to be completed for our study. We developed the SWMM OpenMI component to handle the runoff and routing processes of the SWMM model's native computational code. However, the code was designed so that its templates could be extended to include the other processes available in SWMM (e.g., water quality, snowmelt, groundwater, and evaporation processes). The complexity of the runoff computations is comparable to that of snowmelt, infiltration, and evaporation, which typically use algebraic equations. The routing portion's level of computational complexity is similar to that of the transport and fate of constituents in water, which typically use differential equations that require initial and boundary conditions as well as approximate numerical solutions. These two processes are good representations for the two general levels of computational complexity in the SWMM model and indeed many other hydrologic and hydrodynamic models.

In SWWM, sub-catchments are modeled as non-linear reservoirs, with storage represented by maximum depression storage. This storage includes ponding, surface wetting, and interception. The difference between inflows (rainfall and snowmelt) and outflows (infiltration and evapotranspiration) that exceeds a sub-catchment's maximum depression storage is equal to runoff and is converted to a volumetric flow rate using Manning's equation (Rossman, 2010). Flow routing in SWMM is accomplished by solving the Saint Venant's equations (Equations (1) and (2)) over the network formed from conduits (i.e., pipes, canals, and rivers) and sub-catchments connected together at their endpoints by nodes (i.e., junctions, outfalls, storage units, and flow dividers) (Rossman, 2006):
                           
                              (1)
                              
                                 
                                    
                                       
                                          ∂
                                          A
                                       
                                       
                                          ∂
                                          t
                                       
                                    
                                    +
                                    
                                       
                                          ∂
                                          Q
                                       
                                       
                                          ∂
                                          x
                                       
                                    
                                    =
                                    0
                                 
                              
                           
                        
                        
                           
                              (2)
                              
                                 
                                    
                                       
                                          ∂
                                          Q
                                       
                                       
                                          ∂
                                          t
                                       
                                    
                                    +
                                    
                                       
                                          ∂
                                          
                                             (
                                             
                                                
                                                   
                                                      
                                                         Q
                                                         2
                                                      
                                                   
                                                   A
                                                
                                             
                                             )
                                          
                                       
                                       
                                          ∂
                                          x
                                       
                                    
                                    +
                                    g
                                    A
                                    
                                       
                                          ∂
                                          H
                                       
                                       
                                          ∂
                                          x
                                       
                                    
                                    +
                                    g
                                    A
                                    
                                       S
                                       f
                                    
                                    +
                                    g
                                    A
                                    
                                       h
                                       L
                                    
                                    =
                                    0
                                 
                              
                           
                        where x is distance along a conduit, t is time, A is cross-sectional area of the conduit, Q is flow rate in the conduit, H is the hydraulic head of water in the conduit (elevation head plus any possible pressure head), S
                        
                           f
                         is the friction slope (head loss per unit length), h
                        
                           L
                         is the local energy loss per unit length of the conduit, and g is the acceleration due to gravity. SWMM uses an upwind, finite difference, explicit time marching scheme to solve these equations. At each time-step, the equations are solved iteratively until the difference in the current iteration's estimated heads and the previous iteration's heads at all nodes connecting conduits are less than a certain specified convergence criteria value.

The SWMM computational engine allows a modeler to set a constant time-step or to override the specified constant time-step using an adaptive time-step. This adaptive time-step is the smaller of a user specified maximum time-step or an under-relaxed time-step calculated for each conduit using Equation (3) to comply with the CFL stability criterion:
                           
                              (3)
                              
                                 
                                    Δ
                                    t
                                    =
                                    R
                                    ×
                                    
                                       L
                                       
                                          V
                                          +
                                          
                                             
                                                g
                                                y
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where R is the time-step relaxation factor, L is the length of the conduit, and V and y are velocity and depth in a conduit, respectively.

TMBE is estimated in SWMM as the sum of the initial storage volume (V
                        
                           i
                        ) and the total volume of model inflows (Q
                        
                           in
                        ) minus the sum of the final storage volume (V
                        
                           f
                        ) and total volume of model outflows (Q
                        
                           out
                        ) as illustrated in Equation (4).
                           
                              (4)
                              
                                 
                                    T
                                    M
                                    B
                                    E
                                    =
                                    
                                       (
                                       
                                          
                                             V
                                             i
                                          
                                          +
                                          
                                             Q
                                             
                                                i
                                                n
                                             
                                          
                                       
                                       )
                                    
                                    −
                                    
                                       (
                                       
                                          
                                             V
                                             f
                                          
                                          +
                                          
                                             Q
                                             
                                                o
                                                u
                                                t
                                             
                                          
                                       
                                       )
                                    
                                 
                              
                           
                        
                     

To develop an OpenMI component from an existing model, Gregersen et al. (2007) recommended converting the existing model's native code into a library that can then be called externally from an OpenMI compliant component wrapper library. This approach minimizes the number of OpenMI specification implementations in the existing model's native code and ensures that the compiled library can be run in both its standard, tightly coupled and modified, loosely coupled OpenMI configurations. This approach also makes it easy to update the component when a newer version of the model's native code becomes available. Most importantly, legacy codes that have been accumulated by scientists over many years, which are widely used by modelers and accepted by regulatory agencies, can be re-used without having to rewrite them completely to fit a particular coupling framework. Using the wrapper approach, however, presents some challenges. Legacy model codes have been written using a wide variety of programming languages and programming paradigms. It takes some amount of engineering to ensure that the right functions and objects needed for compatibility with a component-based framework are exposed while ensuring that modifications to a native model's code are minimal. Additionally, the mixing of programming languages and their underlying frameworks can lead to performance costs. The SWMM OpenMI component library used for this study was written using the C# programming language as a wrapper around the native SWMM C programming language code, which was compiled into a Windows dynamic linked library (DLL). The Microsoft.NET framework, on which the C# programming language is built, has a service called the Platform Invocation Service (PInvoke), which provides limited language interoperability capabilities. Function calls and marshalling of SWMM objects to and from the DLL compiled from the native SWMM code was accomplished using this service. Conduits (e.g., pipes, canals, streams), nodes (e.g., junctions, outfalls, dividers), and sub-catchment SWMM objects and their associated properties were exposed as input and output exchange items by creating wrapper classes within the C# code of the OpenMI component we developed. These classes call the native SWMM DLL to get and set the properties of their associated SWMM objects. Although not used in this study, the geographic features associated with the SWMM objects (i.e., points for nodes, lines for conduits, and polygons for sub-catchments) were also exposed as properties of their corresponding exchange items.

Minor modifications were made to the native SWWM code, including adding functions to marshal SWMM objects and their associated properties to the SWMM OpenMI component and vice–versa, and adding an indexed look-up container (i.e., hash map) to cache dynamic boundary conditions supplied by the underlying OpenMI component. The look-up container was added to ensure that boundary conditions could be retrieved efficiently and enforced at appropriate locations in the native SWMM code during the iterative solution procedure. The native SWMM code already contains functions to initialize a component, perform time-stepping, write model results, and dispose of model resources upon completion of a simulation. Therefore, there was no need to reproduce them.

Using the PInvoke service as a means of communication between the managed C# wrapper library code and the native SWMM C code introduces some performance costs. PInvoke has an overhead of between 10 and 30 × 86 instructions per function call; this is in addition to the fixed cost of marshaling objects (MSDN, 2015). These communication costs across the boundary between managed and unmanaged/native codes are not limited to only C# but to other managed languages (e.g., Java, python) and should be a consideration in the development of components. Although these costs are not necessarily due to the OpenMI standard, the interface specifications and implementations of OpenMI have been provided in C# and Java, which are both managed languages. One could implement the OpenMI standard using an unmanaged programming language like C++, but the same problem will be encountered if one wishes to create a component for a legacy model written using a managed programming language.

The configuration we used to couple any two OpenMI SWMM components adhered to mass and momentum conservation principles to be consistent with how SWMM internally couples two conduits. This was accomplished by first passing flow from an upstream component's conduit to a downstream component's junction node as an inflow boundary condition. This flow was then used to calculate head in the downstream component's junction node. The calculated head was then passed from the downstream component's junction node back to the upstream component's outlet node as the water surface elevation boundary condition (Fig. 3
                        ). This particular coupling configuration gives priority to balancing mass over momentum. The reverse case, where the downstream component supplies water surface elevation to the upstream component first, gives priority to balancing momentum over mass. Details about the differences between the two coupling configurations and their effects on simulated water surface elevations and flows have been discussed in detail by Becker and Talsma (2013).

The sequence of function calls used for the bidirectional coupling between the upstream Component A and the downstream Component B in Fig. 3 is shown in Fig. 4
                        . At the beginning of the simulation (time = to), Component A must obtain water surface elevation data from Component B before performing its time-step. However, Component B must request flow data at time to before proceeding to perform its time-stepping calculations. Component A is at time to, so it is able to supply flow to Component B without performing time-stepping calculations. Component B uses this data as its inflow boundary condition and proceeds to perform its time-stepping calls until its time (time = t2), just exceeds the time Component A requested water surface elevation (i.e., to). Component B then supplies the water surface elevation data at time to, so that Component A can perform its time-step. This process is repeated until the trigger component, Component A, finishes its simulation. For coupled components whose time-steps are misaligned, an adapter is used to perform the necessary interpolation/extrapolation to ensure data is supplied at the requested time.

The bidirectional, external coupling method that we employed to solve for flow and head at the nodes where two SWMM components are coupled is essentially equivalent to a single internal iteration of the native SWMM computational code between any two connected conduits. This single iteration between any two components is less than the number of iterations performed by the native SWMM model (the native SWMM code uses at least two iterations) and is the main cause of potential model non convergence and larger TMBE when running coupled SWMM components using OpenMI. We hypothesized that this problem could be addressed by using shorter time-steps, which led to a number of coupled modeling scenarios to test this hypothesis (described in Section 3.3).

The legacy of agricultural irrigation canals developed early in the history of the City of Logan continues to influence the management of its stormwater. As the Logan River exits Logan Canyon and flows westward through Cache Valley toward Cutler Reservoir, it is diverted at various points along its length into northward flowing irrigation canals as shown in Fig. 5
                        .

Streamflow in the ∼646-km2 Logan River watershed is characterized by high spring snowmelt runoff, which is typical of many semi-arid watersheds in the Western United States. Historical maximum average monthly discharge at the USGS gage 1010900 above State Dam at the mouth of Logan Canyon ranges between ∼4.64 m3/s and 1413 m3/s. The same canals that receive irrigation diversions from the Logan River also serve as major conveyance conduits for stormwater from within the city, with many stormwater outfalls piped directly into the canals. Logan, therefore, works collaboratively with private canal owners to ensure that stormwater is managed safely and effectively. Compounding the challenges associated with this arrangement is that, as the city continues to grow, impervious areas increase, leading to increases in peak flows and volumes associated with rainstorms. Modeling the stormwater conveyance system will allow planners to better understand the dynamics that govern the system and allow them to better plan management and mitigation measures for identified areas where capacity to convey stormwater is limited.

The processes simulated for this study included surface runoff from a short duration design storm, infiltration, and hydraulic routing. The domain for the reference model we developed for Logan City was comprised of 172 sub-catchments, with areas that ranged from 0.12 to 71 ha, covering a total area of ∼2929 ha. Runoff in these sub-catchments was simulated using the NRCS Curve Number method (NRCS, 1972), which accounts for infiltration. Curve Number values ranged between 51 and 98. Overland Manning's roughness values for the sub-catchments ranged between 0.001 and 0.1. The routing component included 403 conduits, with Manning's roughness values between 0.01 and 0.035. Conduit lengths totaled ∼78 km and ranged between 0.5 m and 2126.3 m (Fig. 5). The depths and diameters of the conduits ranged between 0.05 and 2.4 m. The routing component also included 397 junction nodes, 39 outfall nodes, 2 weirs, and 38 discharge orifices for 38 storage nodes. The model was executed using a 25-year, 24-h design storm (∼63.5 mm). The high intensity Natural Resources Conservation Service (NRCS) Type-II rainfall distribution curve (Cronshey, 1986) prescribed for Logan was also used to derive the rainfall time series at a 30-min resolution (Fig. 6
                        ).

Flows diverted from the Logan River into the canals were applied as external boundary conditions using the maximum allowable diversions to be conservative (i.e., the simulation represents the occurrence of the 25-year, 24-h storm during a time when the agricultural canals are diverting at their maximum rate). These flows were 1.81 m3/s, 1.36 m3/s, and 1.39 m3/s for the Hyde Park and Smithfield, Hyde Park and Logan North Field, and Logan Northwest Field canals respectively. These flows represent initial conditions in the canals, and it was assumed that there was initially no flow in the stormwater conduits. This high intensity storm coupled with the relative gentle slopes in the study area, varying conduit lengths, and flow constrictions at various locations in the city provided a relatively challenging computational application to explore OpenMI's scaling challenges. The simulation was run for 2 days from the beginning of the storm, with outputs produced at 5-min intervals.

In our first test, we compared the reference model to its corresponding OpenMI component configuration. This test with a single component, no coupling, and therefore no data exchanges, was performed to get a sense of the increase in total simulation time incurred from how the underlying OpenMI specifications were implemented. The source of the increase is from the initialization of the component, its exchange items, and their properties as well as disposal of resources at the end of a simulation.

In our second test, we isolated the runoff from the routing process of the SWMM model by decomposing a copy of the reference model into two model components, one with the sub-catchment runoff process and the other with the hydraulic routing process. The two resulting model components were then coupled using OpenMI. The purpose of this test was to evaluate the increase in total simulation time and TMBE when coupling models by the processes they simulate.

In the final test, we sub-divided the reference model's spatial domain into progressively smaller sub-domains comprised of sub-catchments and their associated conveyance conduits, with each one spanning roughly half the total sub-catchment area of their parent models as shown in Fig. 7
                        . We then coupled the resulting model components using OpenMI to evaluate the effect of the number of coupling connections on total simulation time and TMBE. Table 1
                         lists all the model configurations evaluated and their descriptions.

The explicit time marching scheme of both the SWMM computational engine and the OpenMI specification requires a careful selection of a small enough time-step to ensure model convergence and accuracy. Smaller time-steps help to resolve the discontinuities in flows resulting from the high intensity rainfall and flow boundary conditions applied to the canals and help minimize the spurious oscillations that arise in numerical models with such flows. To explore the tradeoffs between TMBE and total simulation time with changing time-steps, we executed all model configurations at constant time-steps of 0.5–1 s at time intervals of 0.1 s and from 1 to 10 s at a 1-s interval. Additionally, we executed all model configurations using SWMM's adaptive time-step option with a 10-s maximum time-step and time-step relaxation factors of 0.1–1.0 at intervals of 0.1 to see if any benefits could be gained. This setup required adding an IBaseAdaptedOutput to perform linear temporal interpolations of the flow and water surface elevation data exchanged between the components because of the resulting differences in time-steps between components.

The SWMM defaults of 1.5 mm for the convergence criteria and a maximum of eight iterations per time-step were used for all model configurations tested. We selected these settings because they produced, what was in our judgment, reasonably small TMBE as a percentage of the total outflow volume plus the final storage for the reference model (e.g., less than 1%). For the typical 5-s time-step, the TMBE as a percentage of the total outflow volume plus final storage for the reference model was only 0.23%.

The operating system on a computer allocates computing resources in an inconsistent fashion. The implication of this variability is that each simulation of the same model will result in a slightly different total simulation time. Therefore, we ran several simulations for each test model configuration to obtain an average of the total simulation time. Ten simulations were run for each configuration. We arrived at this number by timing ∼200 shorter test simulations to obtain a value for the standard deviation of the total simulation time to be expected on the machine used. These test simulations yielded a standard deviation of ∼0.015 s for total simulation time. We used the sample size determination method suggested by Brown and Berthouex (2002) for calculating the number of simulations required to match the standard deviation of the 200 test simulations we ran. At a confidence level of 95%, and an arbitrary confidence interval of 0.01 s, the number of simulations to run for each model was calculated as nine simulations. However, this value was rounded up to 10 simulations. All simulations were conducted on a computer with a Quad-Core, Intel® Xeon® 3.00 GHz processor running a 64-bit Windows 7 operating system. Only the SWMM model and OpenMI environment were installed on the machine.

@&#RESULTS AND DISCUSSION@&#

In the first test, we compared the reference model with its corresponding OpenMI implementation. In general, shorter time-steps resulted in longer total simulation times as expected because of the resulting increase in the number of time-stepping computations (Fig. 8
                     ). The longest total simulation times were 296 s and 345 s for the reference model and its corresponding OpenMI version, respectively. The shortest total simulation times were 25 s and 63 s for the reference model and its corresponding OpenMI version respectively. The OpenMI implementation increased total simulation times by an average of about 28 s over all the time-steps evaluated. The bulk of this increase is a result of the initialization, setup, and resource disposal portions of the SWMM OpenMI component as opposed to the time-stepping function calls. We confirmed this by profiling the simulation to examine the time spent in executing portions of the SWMM OpenMI component's code using Microsoft's Visual Studio Profiling Tools (Table 2
                     ).

The TMBE values for the reference model over all time-steps evaluated (Fig. 9
                     ) show a general increase in TMBE with increasing time-steps, as expected. TMBE values for the reference model executed in the standard, tightly coupled SWMM configuration, and the OpenMI component version of the full reference model were identical because there were no connections or data exchanges in the OpenMI version. The TMBE results for the OpenMI version of the full reference model are, therefore, not shown.

The largest TMBE occurred for the 10-s time-step simulation (−653,129 m3 or 21.6% of the total outflow volume plus final storage volume), while the smallest occurred for the 0.5-s time-step simulation (−1961 m3 or 0.08% of the total outflow volume plus final storage volume). The abrupt jump in the TMBE when the time-step was increased from 7 s to 8 s occurred because the model failed to converge at most of the time-steps when they were greater than 7 s. For example, the model with the 7-s time-step used an average of 2.56 iterations per time-step and converged 95.3% of the time as opposed to an average of 6.12 iterations per time-step converging only 47.8% of the time for the 8-s time-step. This is also responsible for the slight increase in total simulation time when the time-step increased from 7 to 8 s because more iterations had to be performed for the 8-s time-step simulation.

For the adaptive time-step simulations, results showed that once the CFL criteria had been satisfied, reducing the time-step further by decreasing the time-step relaxation factor did not produce any appreciable decrease in TMBE. The smallest TMBE for the adaptive time-step model configurations was −1900 m3 (0.078% of the total outflow volume plus final storage volume) at a time-step relaxation factor of 0.2, while the largest TMBE was −1924 m3 (0.081% of the total outflow volume plus final storage volume) at a time-step relaxation factor of 1.0. The largest TMBE for the adaptive time-step was still comparable to the best TMBE for the model with the constant time-step value of 0.5 s and had the additional benefit of a much shorter total simulation time (45% and 35% less time for the reference model and OpenMI respectively).

The difference in total simulation time between the coupled runoff and routing model and the reference model showed a significant amount of variability with changing time-steps (Fig. 10
                     ). This was largely because of the large number of OpenMI connections (332 individual OpenMI connections between the coupled model components) over which data had to be exchanged. The difference in total simulation times was more pronounced for smaller time-steps because more OpenMI data exchanges were performed. The TMBE of the coupled runoff and routing model components was, however, not significantly different from the reference model with an average difference of just 1.8% (Fig. 9). This was primarily because the rainfall data forcing the runoff model was at a temporal resolution of 30 min. Therefore, the longest time-step of 10 s was still small enough to resolve this rainfall.

As with the first test, the adaptive time-step option reduced total simulation time while maintaining comparable TMBEs with the best constant time-step simulation. The adaptive time-step with a relaxation factor of 1.0 for instance, yielded a TMBE of −2036 m3 (0.086% of the total outflow volume plus final storage volume) versus −2022 m3 (0.085% of the total outflow volume plus final storage volume) at the 0.5-s constant time-step, while decreasing total simulation time by 35%.

In the final test, where we decomposed the reference model spatially, the results showed total simulation time increased linearly with the number of OpenMI connections as shown in Fig. 11
                     . This occurs because of the resulting increase in data exchanges as the number of connections increase. These results are different than those obtained by Talsma et al. (2012) who observed that the simulation time increased disproportionately as the number of components increased. For example, the percentage increases in total simulation time over the tightly coupled model for their study were 591% for their 2-component simulation and 733% for their 6-component simulation (13 connections). In comparison, for our 0.5-s time-step, the percentage increase in total simulation over the tightly coupled simulation was 4% (6 connections) for the 2-component simulation and 17% for the 8-component simulation (18 connections). This improvement may be due to a number of factors. For one, the Sobek model uses an implicit time marching scheme, which requires solving a system of equations and is generally more computationally expensive than SWMM's explicit time marching scheme. Additionally, how a component is implemented and the degree to which data exchange is optimized by a developer can play role. Finally, the improved data exchange specification for OpenMI 2.0 over OpenMI 1.4 may also have played a role.

Using SWMM's adaptive time-step option helped reduce total simulation time for the loosely coupled models (Fig. 12
                     ). This reduction in total simulation time occurs because model components with computational elements having long flow lengths or elements with slow velocities yield longer time-steps. This reduces the number of time-stepping function calls and helps model components execute faster because of fewer interpolation computations and data exchanges.


                     Table 2 summarizes results from profiling the OpenMI simulation of the reference model, the 2-component, and the 161-component coupled OpenMI model configurations for the 0.5-s and 10-s time-steps. Results are grouped under: (1) percent of time spent reading input files, initializing and disposing components, and saving output files, (2) percent of the time spent calling the time-stepping function across the managed and unmanaged code boundary, and (3) time spent marshalling objects back and forth across the managed and unmanaged code boundary. The remainder of the time was largely spent on the data exchange between components in the managed portion of the code at runtime. From the results, it is clear that the source of the increased total simulation times as the number of components increases and time-steps decrease is largely the result of the process of marshalling objects back and forth across the managed and unmanaged code boundary and to a lesser extent data exchange between components in the unmanaged parts of the code. Evidence for this is indicated by the large increase in the proportion of time spent marshalling objects (up to 88.1% of total simulation time for the 161-component simulation at the 0.5-s time-step) and reduction in the proportion of total simulation time spent for the remaining functions as the number of coupled components increase and the time-step is reduced.

TMBE values for the spatially decomposed models are shown in Fig. 13
                     . The results showed that decomposing the reference model spatially at least doubled the TMBE of the full reference model in the best-case scenario. However, TMBE as a percentage of total outflow and final storage is a more useful metric for the subjective exercise of determining what the level of acceptability of model errors are. For the dynamic storm we simulated over a two-day period, only the simulations of the model configuration having 161 OpenMI SWMM components had an error greater than 1% (Fig. 14
                     ), a level below which simulations are likely adequate for many stormwater modeling applications.

For the adaptive time-step simulations, the results indicated that large reductions in total simulation time could be obtained while still obtaining TMBE values comparable to the best constant time-step simulations. As an example, the adaptive time-step simulation with a relaxation factor of 1.0 for the 8-model component simulation, reduced total simulation time by 69.7% over the simulation with the smallest constant time-step of 0.5 s and still achieved comparable TMBE (−5057 m3 versus −4811 m3 for the constant time-step).

Finally, to illustrate how the differences in TMBE come about, Fig. 15
                      shows the hydrographs for a section of the Logan Northwest Field Canal for all coupling configurations and the 0.5-s time-step (which produced the best results in all simulations). As the number of coupled components increases (i.e., roughly representing an increase in the level of spatial decomposition of catchments and associated conduits along the canal), the hydrographs reflect an earlier propagation of the flood wave through the canal than the reference model, as indicated by the earlier rising limbs and recession limbs of the hydrographs produced by the highly decomposed models. This happens because the single iteration at the OpenMI bi-directional connections is not enough to adequately propagate the effects of downstream water surface elevation boundary conditions upstream.

Our testing of the OpenMI 2.0 implementation indicates that the two primary sources for the increased total simulation time for model components in a loosely coupled modeling environment are the costs associated with initialization, setup, and disposal of model components and the costs from data transformations and transfers between components. The increased total simulation time costs associated with the former are dependent on the complexity and number of a model's exchange items. For instance, a two-dimensional hydrodynamic model component, which provides every cell in its computational grid as an exchange item, will likely increase this cost over a comparable SWMM model because more exchange items would have to be initialized and the two-dimensional information being passed would be more complex. However, for a particular model setup, this cost is largely fixed irrespective of the time-step and time domain of the model. For most hydrologic/hydrodynamic model components, this cost should be much less than the increased total simulation time costs from data transformations and transfers between components. This cost can be reduced by providing only those items and properties that are going to be involved in the data exchange process for a particular model component.

The increased total simulation time costs associated with data transformations and transfers between components depend on the complexity of model components and their associated exchange items, the number of model components, as well as the duration of the model time-steps. These form the bulk of increases in total simulation time as the number of components increases. Our results showed that the total simulation times scaled linearly with the number of OpenMI connections between model components. Barring reducing the number of connections between model components by consolidating models either by process or by spatial extents, the straightforward way to deal with the total simulation time increases is to increase the time-step of a model component. This decreases the overall number of time-stepping function calls and, therefore, the number of data transformations and transfers between model components. Results from profiling our model simulations suggest that marshalling objects across the managed and unmanaged code boundary in the data transfer process becomes particularly expensive as the number of coupled components increases. One potential approach to avoid this in C# would be to pass values as blittable types (i.e., types that have the same representation in managed and unmanaged code - e.g. integers, doubles, etc.) rather than marshalling entire objects as was done in this study. There are no marshalling costs for blittable types (MSDN, 2015). However, this may require extensive modifications to the native computational code of the model to ensure that proper context is given to the data being exchanged. Additionally, the ability to utilize the very useful self-introspection and method invocation capabilities provided by C# (and other managed programming languages) on marshalled objects will be lost.

Although increasing time-step reduces total simulation time, there is a tradeoff between time-step and TMBE. Increasing the time-step for time marching models like SWMM reduces their ability to resolve discontinuities in time varying data (e.g., mass, velocity, constituent concentrations) being transported across their space discretizations, resulting in a reduction of the conservation quality of a model. A general increase in TMBE with increasing time-step was observed in the results from all our tests. To be able to use longer time-steps without diminishing the accuracy of model results, unnecessarily short/small computational elements (e.g., conduits, cells) should be avoided when performing the space discretization.

Most explicit time marching models like the SWMM allow modelers to select an adaptive time-step option. This option calculates an optimal time-step to use to comply with the CFL stability criteria. Using this option can help decrease total simulation times by increasing the time-step for components with longer/larger computational elements or computational elements with slow velocities. Different time-steps are realized for different models components, and so a model component receiving data from another model component must therefore, have a short enough time-step to resolve the time varying data being supplied to it to minimize errors. Although we only used the linear interpolation method to interpolate data for the temporally misaligned model components, the use of other more efficient interpolation, extrapolation, and data aggregation methods with better conservation properties is an area of research we will continue to pursue.

Since the bidirectional coupling configuration we employed is essentially equivalent to a single iteration of SWMM's internal calculations, an iterative procedure applied across OpenMI connections that checks for model convergence at each connection would theoretically help minimize TMBE. In OpenMI, this can be accomplished by placing an iterative controller model component between OpenMI connections. The increased total simulation time resulting from this approach may, however, be prohibitive for most applications. For most cases, the adaptive time-step option coupled with a careful selection of a small enough maximum time-step and an appropriate interpolation method may be enough to obtain acceptable TMBE. The degree of acceptability of a TMBE is based on professional judgment or regulatory requirements and can be evaluated by calculating the volume of the error as a percentage of the total outflows plus final storage volume in a model.

The work we have presented here evaluates the costs associated with using an implementation of the OpenMI standard in terms of total simulation times and TMBE. It highlights the importance of striking a balance between the benefits promised by component-based modeling frameworks and the costs that are incurred from their use. It also illustrates the importance of considering time-stepping in model coupling, especially where spatial and/or temporal discontinuities may occur at the connections between coupled model components. These are critical considerations for loose model coupling applications using any combination of models and will be instructive for modelers investigating loose coupling for new model development. Although we have illustrated that the costs of loosely coupled modeling can be significant, users may still wish to apply this modeling strategy where experimentation with process formulations is required, where advanced data exchange between models is required, or where multidisciplinary process representations must be coupled. These benefits may outweigh the associated costs. We have illustrated some strategies for minimizing the costs, and future work will evolve around developing efficient data transformation algorithms to resolve scale disparities that arise between model components.

@&#ACKNOWLEDGMENTS@&#

This research was supported by National Science Foundation EPSCoR Grant IIA 1208732 awarded to Utah State University as part of the State of Utah EPSCoR Research Infrastructure Improvement Award. Any opinions, findings, and conclusions or recommendations expressed are those of the author(s) and do not necessarily reflect the views of the National Science Foundation.

@&#REFERENCES@&#

