@&#MAIN-TITLE@&#A formal approach for modeling context-aware Human–Computer System

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We propose a formal approach for specification of pervasive user interface.


                        
                        
                           
                           We define a Petri nets modeling language for pervasive Human–Computer System.


                        
                        
                           
                           We demonstrate that the accuracy of the generated interface depends on the context and task’s validity.


                        
                        
                           
                           We demonstrate the validity of our approach by a case study in a medical domain.


                        
                        
                           
                           We propose a system for monitoring diabetic patient in smart hospital.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Human–Computer System

Pervasive computing

Context-awareness

Context modeling

Petri nets

PNML

@&#ABSTRACT@&#


               
               
                  Ubiquitous environments are often considered as highly dynamic environments and contextual information can change at runtime. The user interface should provide the right information for a given user considering runtime context. Such an objective can be achieved only when we deduce the user’s requirements in terms of information and present it to the user according to his current context of use. The overall objective of our research is to generate a user interface adapted to the current context of use for critical fields. This paper explores some key issues related to the architecture of context-aware applications. A formal approach for the analysis of pervasive Human–Computer System (HCS) is presented. XML Petri nets are used to model the pervasive HCS. The proposed approach is illustrated with a case study which presents a hypoglycemic diabetic patient in a “smart hospital”.
               
            

@&#INTRODUCTION@&#

Pervasive computing offers the capacity to build systems that can adapt the delivered information in order to meet users’ requirements. This new type of interaction raises once again the issue of adapted interface. We switched from a user-centered system design to a context centered system design. Indeed, Human–Computer Systems (HCS) have evolved to become context-aware. Thus, the HCS switched from the triplet (System, Task, User) to the triplet (System, Task, Context). Designing, implementing and evaluating context-aware HCS is specifically adapted to user’s task by taking into consideration the context in which the user is operating.

Modeling the user’s task has a strong impact on the design of user interface. In recent years, there have been different approaches to the specification of the task and how it is related to the area of application. Several notations have been proposed (Concur Task Trees CTT [1], Collaborative Task Modeling Language CTML [2]). The latter differs in terms of presentation, expression, degrees of formality and granularity, but they are all based on the same principle: tasks are organized hierarchically in order to represent the task’s decomposition which is executed to meet a particular purpose. The process of task decomposition ceases once the atomic task ‘action’ is obtained.

In addition to the above-mentioned approaches, Petri nets (PN), which were proposed by Carl Adam Petri in 1962, are also considered as a promising tool for task modeling. PN are a mathematically based formalism dedicated to the modeling of parallelism and synchronization in discrete systems [3]. PNs are continuously expanding and are a suitable tool for HCS modeling. Initially, they were only used to describe tasks that were to be computerized. However, later, especially with the emergence of High Level Petri Nets, they were used to model Human–Computer Interaction.

With the rapid evolution of user interaction, new problems emerged. Indeed, the environments in which users interact via interfaces are becoming increasingly complicated and include various types of sensors that provide different data to users. Several tools were suggested to create, edit, manipulate, implement, view, validate and verify user’s interface.

Consideration of the user’s task represents an important criterion in an environment where the context has a direct impact on the user’s task. Users’ interface must change according to the context and task, at a specific moment. Modeling the ubiquitous environment and user’s task raise several issues. Pervasive environments are extremely dynamic and hold a vast amount of information. In critical fields, such as health, nuclear and transport systems, modeling pervasive systems must be rigorous with a minimum proportion of error risk. If the user’s interface shows wrong information, it may have a disastrous impact on human lives and on equipment. So, the use of formal approach in such fields is required to guarantee a valid interface starting at the modeling stage.

To demonstrate the strength of formal modeling tools in critical areas, we chose to test our approach in the medical field: the monitoring of diabetic patients in a smart hospital. This case study is very significant. Indeed, applications related to diabetes continue to increase due to the growth of the number of diabetic patients around the world. Hypoglycemia or mishandling by the medical team may cause the patient’s death. The aim of our approach is to reach a valid mobile interface to guide the user to best accomplish his task.

Our research focuses on this, and we aim to adapt the user interfaces to their context of use. We need (i) to model the context in a ubiquitous environment, (ii) to model the user’s task based on its environment and (iii) to identify the user’s requirements for the generation of the user’s interface adapted to the context in a critical field.

Section two of this article discusses some literature reviews of context-aware architectures and lays out the requirements that need to be respected in the functioning of a pervasive system. In section three, we present a review of context modeling. Our modeling approach for pervasive HCS is mentioned in section four. XML based tools for specifying and generating pervasive interfaces are often used, so, we introduce a state of the art of Petri nets through XML and we particularly focus on PNML. Our approach will be illustrated in section five with a case that concerns the monitoring of diabetic patients suffering from hypoglycemia in a smart hospital. Finally, in section six, we will examine how to verify the model properties’ built by composition based on PN for a valid generation of user interface.

Ubiquitous computing has become increasingly necessary to improve customized access to a wide range of mobile devices and services. Researchers are trying to overcome ergonomic inconsistencies caused by context variations (screens, locations, users, etc.). A number of context-aware systems have been developed to demonstrate the usefulness of context-aware computing technology. This section defines the notion of context and presents the different architectures of context-aware systems.

The concept of context is widely used in many fields, especially in the field of computing. Definitions of context and context-awareness are widely available in the literature. One of the earliest definitions of context-awareness was introduced by Schilit. It links location, user identity and environmental resources to a mobile system [4]. In 1996, other authors considered context as the objects of the environment and added the notion of time, temperature and season to the location of the user. Then, the context is considered as the location of the user and the state of their environment. Dey defines context as a set of information that characterizes the situation of an entity. An entity can be a person, a place or an object [5]. At the same time, some researchers agree with the definition set forth by Dey and propose the environment as a triplet of entities namely 
                           
                              <
                              Object
                              ,
                              person
                              ,
                              event
                              >
                           
                        . The notion of plasticity and interfaces adapted to users are also defined.

In 2004, Calvary substitutes the term “context” with “context of use” and proposes a user interface adapted to the context of use. Calvary suggests a new triplet namely 
                           
                              <
                              user
                              ,
                              platform
                              ,
                              environment
                              >
                           
                         
                        [6]. More recently, all context definitions have revolved around Dey’s definition [5]. However, some authors also added the notion of social context and take into account the emotions and mood of the user. Others base their work on Dey’s definition and consider the context as being all external application parameters that affect its behavior by defining new views of its data and services.

Following our study of the main definitions, we have concluded that the majority agree on the definition proposed by Dey. For our research, we will use Dey [5] and Calvary’s definitions which define context as the triplet 
                           
                              <
                              user
                              ,
                              platform
                              ,
                              environment
                              >
                           
                         
                        [6]: the user’s model represents the user of the pervasive system. It identifies the user’s nature, his personal information, his field of experience, his preferences, etc. The platform model defines the hardware and software platform supporting the interaction; and the environment model represents the physical and social conditions where the interaction takes place (e.g., noise level). It expresses the ambient environment around the interactive system and the geographic location of the pervasive system.

In conclusion, pervasive computing allows a system to interact with users through context-aware devices. A system is considered context-aware when it is based on the different contextual information detected or inferred from the environment, it evaluates this information and may decide on the best service to provide to the user. The following section presents a state of the art of different architectures of context-aware systems.

The majority of published works state that it is imperative to separate acquisition and modeling of the context from its use. All research agrees on an architecture that consists of five layers (Fig. 1
                        ), where each layer has its own well-defined function: context acquisition, context interpretation, context storage, context diffusion and finally the application layer.

Context acquisition represents the first step in the development of a context-aware application. To intercept context data, the sensing layer has a number of sensors. A sensor is a hardware or software source able to intercept or generate contextual information. The layer of context interpretation allows analysis and processing of the collected data provided by context acquisition. It aims to convert this data to a higher level, which is easier for systems to understand and manipulate. The use of multiple sources from the environment can lead to conflicting and contradictory results, which lead to incorrect situations. Once the layer has performed its analysis, it must action some form of “intelligence” to intercept and resolve these conflicts [7]. The context storage models and archives the data provided by the interpretation layer for subsequent use of the data collected and interpreted. To do this, an appropriate model should be defined in order to describe this information. Context storage is a critical step in the development of context-aware applications. There are several methods available in the literature for modeling context as the object-oriented model, the graphical models, ontologies and hybrid models. Section three will describe these different approaches. The context diffusion aims to adapt the application layer according to the information provided by the storage layer. It has technical communication to notify the application layer of possible changes in context. In other words, this layer has two main roles: (i) provide the application layer services and functions necessary for the development of a context-aware application, and (ii) notify the application layer of changes occurring within the context [7]. Finally, the application layer contains the adaptation engine responsible for defining the various adjustments and reactions that the system must make due to a change of context.

Having presented the general structure of a context-aware system, we introduce in the following section, the different architectures cited in the literature.

@&#RELATED WORKS@&#

There are several surveys on context-aware system architectures. Here are, in our opinion, the most significant ones:


                           Context Toolkit 
                           [8]
                           : proposed by Dey, provides a toolkit for the development of context-aware applications. It has a layered architecture that allows the separation of context acquisition, representation and the adaptation process. This architecture is based on: (i) Widget: a software component that provides applications with access to context information from their operating environment; (ii) Interpreter: used to interpret low-level context information and convert it into higher-level information; and (iii) Server: a connection between the applications and the widgets.


                           Simple Environment for Context-aware Systems SECAS 
                           [9]
                           : This architecture is based on three components: context management, adaptation layer and the application core. Context management is composed by the context provider, the context interpreter, the broker and the context repository. The adaptation layer considers three types of adaptation: content, behavior and user interface adaptation.


                           The Context Broker Architecture CoBrA 
                           [10]
                           : is an agent oriented architecture for context-aware applications. It is based on the context broker, which is an intelligent agent for maintaining and managing the context model. The context broker is composed by the Context Knowledge base, the Context Reasoning Engine, the Context Acquisition Module and the Privacy Management Module.


                           Context Mangement Framework CMF 
                           [11]
                           : is similar to the Context Toolkit platform. It is made up of: (i) a Resource Server, (ii) a Context recognition Service, (iii) a Context Manager, and (iv) an Application layer. In CMF, the context manager synchronizes between all modules.


                           Service Oriented Context-Aware Middleware SOCAM 
                           [12]
                           : is an architecture for the building and rapid prototyping of context-aware mobile services. SOCAM uses ontology for modeling context. It comprises the following components: Context Providers, Context Interpreter, Context Database, Service Location Service and Context-aware Mobile Services.


                           An Architecture-based Approach to Context-aware Adaptive Software Systems CAASS 
                           [13]
                           : is made up of three layers: the functional system, the context model and the system management. First, the context side represents the environment where the system is working and its status is captured using a context model. Second, the system side consists of the functional system and its management. The functional system is the system’s core functionality and also contains a set of resources that are needed to achieve this functionality. System management decides which adaptation actions are required in response to context changes. Finally, a set of control loops is used to capture the relationship between the system and its contexts.


                           Hycon 
                           [14]
                           : is divided into four layers: storage, server, terminal and sensor layer. The architecture includes interfaces for a sensor tier encapsulating the relevant sensors, and represents the hypermedia objects in structures based on XLink and RDF standards.


                           Java Context-Aware Framework JCAF 
                           [15]
                           : is a service-oriented architecture based on Java technology and follows the MVC (Model-View-Controller). This platform is composed as follows: the Context Client, the Context Service and the Context Monitor/Actuator.


                           A User-Adaptive and Context-Aware Architecture for Mobile and Desktop Training Applications CAAMDT-A 
                           [16]
                           : aims to design and develop a user-adaptive and context-aware architecture for mobile and desktop training applications. It relies on: (i) the Context Analyzer subsystem which collects data from a sensor, and then analyzes it to deliver higher level information and provide the UM & CM Service with all this information, (ii) the UM & CM Service subsystem receives information about the user from the Adaptation Engine and the User Interface as well as information about the context from the Context Analyzer. The UM & CM Service stores this information in the User Model and in the Context Model databases and provides the Context Analyzer and the Adaptation Engine with the information they require, (iii) the User Model database stores personal information explicitly provided by the user, (iv) the Context Model databases store information acquired or derived from the sensors, (v) the Adaptation Engine subsystem considers the user and context information provided by the UM & CM Service and applies inference rules to decide if (and which) adaptations or advice are needed, (vi) the User Interface subsystem implements the Adaptation Engine requests providing the user with proper textual, graphical and audio feedback and finally (vii) the Virtual Human subsystem is responsible for providing the user with advice and demonstrations by means of 3D virtual human animations.

@&#DISCUSSION@&#

After analysis of related work, it is then necessary to define comparison criteria to determine the advantages and disadvantages of each architecture:


                           The model of context: This is a very important criterion. Indeed, the use of any inappropriate model for context representation could lead to incorrect interpretation of contextual information. This could compromise the entire functioning of the architecture and provide the user with inadequate adaptations. Using a simplistic model as the key-value model could result in conflicts in the interpretation and the description of the current context of use.


                           The history management context: This is also an important criterion for the development of context-aware applications. In fact, context information must be stored for later use. This will allow a saving of time in the specification of adaptation strategies and the automatic generation of user interfaces.


                           Real-time adaptation: Information provided to the user should be immediate. The adaptation of the provided information must be in real-time. In fact, the user needs real-time information within the context of use and in accordance with their preferences.


                           User’s profiles: Pervasive Applications must be adapted to the user’s profiles. Adaptation needs to focus on user’s preferences (intellectual ability, physical condition, age, gender, etc.).


                           Current activity of the user: The architecture must be able to identify the current activity of the user, so as to provide him with the required contextual information at time.


                           Unexpected situations management: Context-aware architecture must have a module managing the unexpected situations. This part is very important since the ubiquitous environment is constantly changing. We must therefore consider any new adaptation incurred by adding a component dealing with unexpected situations (context, user, etc.).

For the SECAS platform, the stored data in the “context repository” are described in CC/PP, and this guarantees the consideration of the user’s preference. The “context provider” component manages contextual data relative to user profile and history. It seems however, that current user activity, real-time adaptation and unforeseen situation management are not considered in this architecture. We can also notice through the Context Toolkit and CoBra architectures, that the current activity of the user, user preference, real-time adaptation and unexpected situation management are omitted. For the CMF platform, the criterion for user preference is ensured by the use of fuzzy logic for the description of the contextual data. The SOCAM platform verifies more criteria than other architectures. However, real-time adaptation and the unexpected situation management are not considered. The main advantage of the CAASS architecture is the management of unexpected situations. Indeed, by using “script adaptation”, the system can identify unusual situations. The JCAF architecture only considers user preference. The HyCon platform offers an adaptation according to the physical device without relating to the user’s current activity or his preferences. In the CAAMDTA platform, real-time adaptation was not explicitly mentioned, but we have implied it from the operational nature of the system. User preference in the adaptation process is not highlighted in most architecture. The CAAMDTA platform provides a module that can infer high-level data relevant to the physiological status of users in accordance with their movements. The Table 1
                            shows the criteria according to each architecture.

After this technical review, it would appear that none of these structures matches our evaluation criteria. One of the most important criteria in our research is the model of context. In fact, once the contextual data has been captured, it must be represented in a suitable form to be analyzed and implemented. Misinterpretation of captured data can lead to incorrect interfaces. The question at this stage is: how can we model the context?

Over the years, a large number of context-aware applications have been developed for different fields. Based on different context models, these applications are able to gather, manage, evaluate and disseminate context information. Among the most common models, we cite: (i) Key-value pairs: these are the most simple data structures for modeling contextual information. Previously, Schilit used key-value pairs to model the context by giving the value of context information (e.g. location information) to an application as an environment variable. The key-value pairs are easy to manage, but cannot model the complex context data [4]; (ii) Markup language: this is a hierarchical data structure consisting of markup tags with attributes and content. Markup-based models use a variety of markup languages including XML [17]; (iii) Object oriented model: this approach benefits from the object oriented approaches to partially solve the problems arising from the dynamics of the context in ubiquitous environments. The details of context processing are encapsulated on an object level and, thus remain, hidden to other components. Access to contextual information is provided through specified interfaces only [18]; (iv) Logic based models: this process known as reasoning or inferencing, defines the conditions on which a concluding expression or fact may be derived from a set of other expressions or facts. In a logic based context model, the context is defined as facts, expressions and rules [19]; (v) Ontology based models: ontologies have been drawing more attention as a generic and explicit way to capture and specify the domain knowledge with its intrinsic semantics through consensual terminology and formal axioms and constraints. They provide a formal way to represent sensor data, context, and situations in a well-structured terminology, which makes them understandable, sharable, and reusable by both humans and machines. Ontologies support a set of modeling primitives defining classes, individuals, attribute properties, and object properties (i.e., relations between objects) [20]; (vi) Petri nets (PN): many context-aware systems modeling approaches based on PN have been proposed. They have shown promise regarding context representation [21]. A PN is a graphical modeling methodology used to model dynamical systems having discrete inputs, outputs, and states. The formal semantics, graphical nature, expressiveness, and the analytical property of PN allow efficient modeling and analysis of dynamic processes. It is a bipartite directed graph defined as a tuple (P, T, F, B) with P: a finite set of places, T: a finite set of transitions, F: forward incidence function and B: backward incidence function.

Context modeling approaches using PN differ depending on the purpose. Some authors are mainly interested in modeling the behavior of the context-aware application; others try to solve the problem of time and resources in applications. There are several extensions of Petri nets such as: (i) Synchronized PN: Reignier introduces an approach regarding the context’s representation and application’s behavior. (ii) Colored PN (CPN): Silva proposes combining 3D modeling tools with CPN for modeling 3D environments. In this model, place is used to indicate the current state of the user and the transition is used to deduce the movement of the user and the behavior of the components. Kwon extended CPN to describe context-aware systems. He decomposes the system into several major subsystems. He separates the contexts from the global model to produce models of independent context [21].

In order to choose the best approach for modeling context, we should focus on important criteria for pervasive environments.

This section provides a description of the requirements set by Bettini and Strang for contextual models [22,23]:


                        Heterogeneity and mobility: a context model should be able to express different types of context information from several types of sensors and a context management system should provide management of the information depending on its type. Many context-aware applications are also mobile or depend on mobile context information sources. Add to this the problem of heterogeneity, as the context information provided must be adaptable to the changing environment.


                        Partial validation: it is more suitable to partially validate contextual information because of the complexity of contextual interrelationships, which may be responsible for any modeling error.


                        Quality of information: the quality and flow information provided by a sensor varies over time. Thus, an appropriate context model should support the quality and the richness of the context data.


                        Incompleteness: due to their dynamic and heterogeneous nature, contextual information can vary and be incorrect. In addition to this, context information may be incomplete or contradictory. Thus, any method in modeling context must include the modeling of the context information’s quality to support a correct reasoning.


                        Usability of modeling formalisms: the ease with which designers can translate real world concepts to the modeling constructs and the ease with which the applications can, at runtime, use and manipulate context information.


                        Applicability of existing environments: from the implementation perspective, it is important that a context model must be applicable to existing infrastructure of ubiquitous environments.


                        Dependencies: there are various relationships between the context information, where the entities/facts may depend on each other. Indeed, a change in the value of a property can affect the values of other properties.


                        Reasoning: context-aware applications use context information to evaluate whether there is a change to the user and/or context; taking a decision as to whether any adaptation to that change is necessary often requires reasoning capabilities. It is therefore important that the context modeling techniques are able to support both consistency verification of the model and context reasoning techniques.


                        Formal language: the chosen modeling method should have formal semantics. Formal methods comprise formal specification using mathematics to specify the desired properties of the pervasive system. Formal specification is expressed in a language whose syntax and semantics are formally defined. This language comprises a syntax that defines specific notation used for specification representation. Formal methods are advantageous in facilitating data representation. Furthermore, the development of a formal specification provides insights and an understanding of the system’s requirements and the user’s interface design.


                        Formal verification: the model must be verified through rules or mathematical property. Verification of important properties of the interface ought to be carried out, once the phase of context modeling for reliable interfaces, begins. Formal verification can be helpful in proving the accuracy of pervasive systems; this ensures the validation of user interfaces before implementation.

Therefore, we can estimate that the requirements mentioned above are extremely important in the modeling of context-aware system in pervasive environment. It is essential to be able to effectively depict the relationships and dependencies between entities in a context, through clear and formalized methodologies.

@&#DISCUSSION@&#

Several approaches of context modeling are available. At this point, it becomes necessary to choose the most suitable modeling approach for the pervasive environment. This section presents a comparative study between different models based on the requirements of the pervasive environment.

Key-value models are extremely weak for the requirements of heterogeneity, dependencies, incompleteness, reasoning and the usability of modeling formalisms. They are ineffective in the description of complex contextual information. Partial validation of a task is very difficult. The simplicity of this approach is an advantage regarding the management of error risk. In this sense, the markup language ensures partial validation.

In object-oriented approaches, encapsulation data can be disadvantageous in the deduction of important environment properties and the relationships between the various entities of context. Logic-based models can provide a distributed composition, but partial validation is difficult to maintain.

Graphical models are mainly used to describe the structure and contextual knowledge that infer the relationships between them. Modeling techniques based on PN meet these requirements. Indeed, the relationship between contexts can be easily understood thanks to the graphic and formal nature of PN. Only PN based approaches support formal verification. This criterion is very important for the specification of user interface adapted to the context of use in critical fields.

Because of the similarities between the modeling approaches based on ontologies (concepts, facts) and objects (classes, instances), approaches based on ontologies are also effective regarding the requirement of distributed composition. Partial validation is possible, and a full set of validation tools exists. However, ontology based models present a serious disadvantage in terms of formal verification. No mathematical tool can be applied to this formalism. Indeed, ontologies are terminologies and taxonomies, they are not defined using mathematical formulas.

The following table summarizes our discussion on the relevance of different context modeling approaches for ubiquitous computing. For clarity, we have used the following digital coding: 0: bad, 1: good and 2 very good (see Table 2
                        ).

In conclusion, the requirements of a pervasive environment are best met by modeling context methods based on Petri nets, according to this study. Indeed, this approach totals up 18 points and outscores all other approaches. Our research objective is: how to describe the context and to model the user’s task. The PN based approaches exhibit all the required characteristics. The use of Petri nets for modeling aims to prepare the ground for formal verification and validation of the interfaces.These criteria are very important in our research work. The modeling of pervasive systems in a critical field requires rigorous validation of the interface in order to present the best solution to face an urgent situation. This saves a considerable amount of time in the development cycle, particularly during the validation phase. Indeed, Petri nets have a formal definition; they are highly capable of expressing aspects such as timing, concurrency, etc. They possess many techniques for an automatic verification of properties (boundedness, liveness, resectability, etc.). They also provide, in addition, an unconstrained graphic representation. Our choice was naturally oriented towards “small granularity” PN ensuring the accuracy of our model. The context model is decomposed in small granularity. In the next section, we present our formal approach for specification of pervasive user interfaces.

The overall objective of our research is to generate a user interface adapted to the current context of use. For that, it is necessary to conduct, an analysis of the pervasive HCS, then to model it. The specifications of the HCS must consider the context modeling. The proposed approach shown in Fig. 2
                     , states that once the data are collected from the sensor layer, they will be modeled and decomposed into a user, a platform and an environment model. The User’s model describes the different users of the application. The Platform’s model presents the different platforms that host our application. The Environment’s model describes the different information of the environment (i.e. geographical location, time, etc.). Since each component of the context is described by its own model, the status of these models determines, at any given time, the current state of the whole context. Indeed, the values of the triplet 
                        
                           <
                           user
                           ,
                           platform
                           ,
                           environment
                           >
                        
                      will characterize the current context. The decomposition of the context data in the three models facilitates the detection of any change that occurs on the environment. Petri nets (PN), formal methodology is used to model the context. The user’s task is also modeled via PN. Furthermore, according to the context in which the user operates, the user’s task may vary. Each user task is specific to a given context. Thus, a set of pairs (context, task) will be defined to compose the model of the pervasive HCS. All the (context, task) couple will be identified and stored in the database “Ctx_Tsk_DB”. At a given time, the status of the three models describing the context will determine its current global state Ci. In order to identify its proper task Tj, it will have to browse through Ctx_Tsk_DB [24]. Once the current context is detected, the couple (Ti, Cj) is transmitted to the adaptation engine. If its value is null, the adaptation engine will process an unexpected situation. Otherwise, the adaptation engine will be dealing with a planned situation. Ergonomic rules for the presentation of information are used during this step. Finally, the adaptation engine will activate the automatic generation of HCI adapted to the current context.

Our approach presents several advantages: first, according to the general definition of a context-aware system, our approach fulfills the requirements of main layers: (i) Context acquisition: we refer to this as “data capture”; (ii) Context interpretation: represented by the context model 
                        
                           <
                           user
                           ,
                           platformandenvironment
                           >
                        
                     ; (iii) Context storage: defined by the Ctx_Tsk_DB; (iv) Context diffusion: described by the adaptation engine; and (v) The application layer described by the automatic generation of user interface. It separates the acquisition and modeling of context from its use. Each component of our architecture fulfills a particular task. Second, due to the complexity of context data, we chose to decompose this data into three models and to consider the user’s task at the stage of modeling context. The originality of our approach lies in the proposal of the couple (context, task). The HCS became context aware and according to the context in which the user operates, the user’s task may vary. In fact, each user’s task is specific to a given context. That is why a set of pairs (context, task) were defined to compose the model of the pervasive HCS. Our model describes the behavior of contextual information. It decomposes the context’s components into small granularity to ensure the validity of the model. To do this, we use a set of “well-organized” elementary PN structures. Pervasive application presents a high level of dynamism so that many actions must be done in parallel. We deem that the aspect of parallelism in PN is very important especially in a critical field. Certain situations require the intervention of two or more users at the same time to meet a particular circumstance. The use of a formal method to describe the behavior of a context-aware system allows us to deduct the properties of the system and the users’ requirements in order to generate the appropriate interface at a given time. Context-aware approaches for user interface generation still have serious difficulties to dynamically and automatically adapt and generate interfaces, meeting users’ requirements. These approaches are not formal, and do not cover the validation of user interface. In comparison to the proposed approaches, seen in section two, our architecture is centered on context modeling and generated user interface. The choice of approach to be used for the modeling context is very important. Context information has a direct impact on the generated interface especially in critical fields, which justifies the use of formal methods in our approach. As shown in previous section, our system will be modeled using PNs. The next sub-section describes our modeling language based on Petri nets for pervasive HCS.

By way of literature, we have been trying to demonstrate the ability of PN to respond to important and applicable criteria for the specification of context-aware HCS. The use of Petri nets for modeling paves the way for formal verification and prior validation of pervasive interfaces, which would save a considerable amount of time in the development cycle of the interface.In the literature, we find multiple proof of the PN’s ability to model tasks. PN offer the same advantages in task modeling as they do in context modeling. In fact, in the beginning, PN were used only for the description of computerized tasks. However, the emergence of high-level Petri nets allowed us to take advantage of their power to model Human–Computer dialogue. We propose, below, a non-exhaustive list of criteria that convinced us to adopt Petri nets in our work: (i) Verification of the user interface’s properties: the model’s verification has the ability to ensure the properties that should be formally defined beforehand in a definite way. Petri nets ensure, by investigating the graph of the markings, that the user indeed has access to all the commands of the interface or that he can finish an action already begun; (ii) Consideration of the parallelism aspect: competition in modeling of the user tasks is a very important criterion. We can model competition by using true parallelism or interlacing. Petri nets, as temporal logic XTL [25] is an example which performs this property; (iii) Consideration of the synchronism aspect: Implementing the synchronization of the actions and processes is highly essential to model the Human–Computer dialogue. (iv) The sequencing of the actions and the temporal constraints: this criterion includes five sub-criteria allowing us to specify the relations between the actions: the sequence between two tasks (A then B); the choice between two tasks (A or B); the composition of two tasks in any order (A and B); the iteration (in a certain number of times); the expression of deadlines between tasks; (v) The generative capacities: the generative capacities remain the specificity of the formalisms. For example, the Petri nets, whose marking graph provides the system’s current status, its possible evolution, as well as its previous steps, allow the generation of contextual help by explaining to the user how it reached that current status, how that user can continue their task and what the optimal path, with the fewest possible steps, is. In our works, we use the Interpreted Petri nets to model context-aware HCS.

As mentioned before, we work on context-aware interfaces. Thus, we deal with Petri nets. Accordingly, we need to introduce the version of Petri nets used in our works. As mentioned in the section below, it is based essentially on elementary PN structures and on compositions between them.

Our approach to modeling Human–Computer Interaction provides a verifiable Petri net model on which we can validate important properties of the interface. The model design principles proposed in our work guarantee this postulate. Moreover, this approach is pedagogical, as well as approved and adopted by designers. This is ensured by its simplicity and the graphic aspect of the modeling.

We chose the formal technique of Petri nets for modeling the context-aware system. It is considered in the literature that this technique is efficient for the expression of synchronization, parallelism and competition. The Petri net used here is IPN (Interpreted Petri nets) [3]. This type of networks introduces the notions of event, condition and the notions of action. A passing condition (Cj), a trigger event (Evj) and a potential action (Aj) are associated with each transition Tj of an IPN (Fig. 3
                        ).

To model the context-aware HCS using Petri nets, we used places to represent the state of the system depending on the environment evolution. We refer to Rasmussen [26] in the human decision theory of the operator when solving a problem. This theory states that when solving a problem, the human operator goes through four phases: (i) detection, (ii) evaluation, (iii) decision and (iv) action. In our work, we modeled the evolution between these states with the PN transitions. We considered that the user task, as well as the context components, is composed by sets of “well-organized” elementary PN structures. The modeling of an elementary structure is illustrated in Fig. 4
                        . The validation of the condition i (transition T1) shows that the user will start the execution of the action relative to that condition. Later, the occurrence of the event “end action” (transition T2) expresses the fact that the user action was performed and ended. Place P2 expresses a waiting state for the end of the action’s execution, while places P1 and P3 model the user’s status before and after the execution of his action. For example, P1 models the user’s mental intention in order to act. P3 expresses his state at the end of the action execution.

All the user’s actions and the components of the context behavior (elementary or composed) are organized according to typical compositions: sequential, parallel, alternative, choice, iterative or of-closure. Below, are the principle of each one of these compositions.


                        Sequential composition: The composition of “n” sequential actions reflects the sequence of their execution. The sequential composition of n actions is ensured by combining the place “end” modeling the action i, with place “begin” of the action 
                           
                              i
                              +
                              1
                           
                         (Fig. 5
                        ). As an example of a sequential composition, we can imagine a situation where task analysis revealed that the user must perform three actions one after the other. Such an interaction will be modeled by a sequential composition of three elementary structures (modeling three elementary actions).


                        Parallel composition: Parallel composition expresses the possibility of simultaneous execution. Parallelism is ensured thanks to an input synchronization place. This place activates at the same time all the places of initialization of the parallel actions to be executed. Ensure the parallel composition of actions; it is necessary to synchronize the places of entry and those of exit of those actions (Fig. 6
                        ).


                        Alternative composition: The alternative composition of n actions reflected a performance always exclusive of these actions. To avoid an actual conflict, conditions are associated with transitions to unambiguously determine which action should be executed. The alternative composition of n networks is realized by composing them sequentially with an ALT structure and merging all the end places of these networks. ALT structure allows the validation of a single condition at a time. ALT structure comprises a set of transitions equal to the number of networks to be composed alternately. These transitions are from the same input place P0. Through the conditions associated with them, they allow unambiguously to initialize a single PN from the n modeled, which guarantees the absence of actual conflict (Fig. 7
                        ). The conditions Ci, i varying from 1 to n, depend on the current status of the context.


                        User choice composition: There are two kinds of user choice compositions: the exclusive choice and the inclusive choice. The exclusive choice composition is similar to the alternative composition, the difference is that the decision on which action to execute is not determined by the internal current state of the system but by the user’s choice: The user carries out an elementary action to decide which among the n actions is to be executed The composition of n Petri nets for an exclusive choice by the user may be made by sequentially composing an elementary structure of the user’s choice decision (Fig. 8
                        ) with the structure obtained by alternative composition of the n Petri nets.


                        Iterative composition: The iterative composition of n actions expresses their successive execution with possible iteration. The iteration is subjected to a condition “Iteration” calculated during the sequential execution of the n actions.The structure of iteration contains two transitions Ti and Tni. These transitions arise from the same place of entrance. Thanks to the conditions which are associated with them they allow passage without ambiguity and this guarantees the absence of effective conflict (Fig. 9
                        ).


                        Closure composition: The closure composition of a PN translates the looping of this PN. The closure composition of a PN is achieved by including the network in a structure CF of closure (Fig. 10
                        ). The closure composition will be used to build the global model of context. All elementary and composition structure are stored in the database of PN.

The proposed modeling language based on Petri nets aims to specify pervasive HCS. The context and the user’s task are modeled through PN. All these networks should be exploited for the specification of pervasive interfaces. Due to this, all our models must be translated into a computer language for the implementation of our interface. Currently, a large number of interface specification and generation tools are based on XML language. That is why we have to convert all HCS models (task, context, etc.) from PN to XML formalism.The following section presents a state of the art of Petri nets through XML.

Since the 2000s, a new variant of high-level Petri nets has emerged: XML nets. occurred rapidly due to the fast growth of Internet, mobile Medias, languages for modeling, etc. [27]. The XML nets ensure the exchange of electronic documents between heterogeneous platforms. The standardization of this language was perceived as an opportunity to obtain a better organization of work in the Petri nets community. Another author presented the concepts and the terminology of PNML: Petri Net Markup Language. He provided a standard exchange format for the Petri nets. PNML presents several benefits: it allows researchers and engineers to use the same terminology, to Develop future extensions on a stable common base and to provide a reference implementation which will facilitate the data exchange between the various tools of Petri nets thanks to a common format.

We will first present XML nets, a variant of high-level Petri nets, then, Petri Net Markup Language (PNML), an exchange XML format between Petri nets.

XML Nets represent a new variant of high-level Petri Nets. Its main strength lies in its power to use formal semantics with graphics nature for the exchange’s modeling of data based on XML. XML Nets identify and decompose the process into a set of XML fragments and assign them to the adequate organizational unit [27]. Besides, the XML nets are adapted to the Web Services Composition (WSC). They also present advantages for the management of supply chains and support all the activities in the inter-organizational management of the business processes.

However, XML Nets have no means of verifying Petri nets. In addition to this, the representation of complex systems leads to complex XML schemas that are difficult to exploit. Therefore, this modeling technique does not achieve our objectives. That is why we are interested in the standard PNML.

During the past decade, several theories and applications of exchange between Petri nets based on XML have emerged. Among which, we can distinguish the PNML standard (Petri Net Markup Language, ISO/ IEC 15909). The design of the PNML was governed by the following principles [28]: (i) readability: the format must be human readable and editable by any text editor; (ii) universality: the format should be able to represent any kind of Petri nets with its possible extensions and special features; and (iii) mutuality: the format should allow us to extract as much information as possible from a Petri net. Therefore, the format must extract the common principles and the common notations of Petri nets [29].

The use of XML guarantees the readability of the format. Universality can be guaranteed by labeling net objects and the net itself. The legal labels, their possible values, and the possible combination of values are defined by a Petri Net Type Definition (PNTD). Mutuality can be guaranteed by conventions, which are a set of standardized labels.

The main idea of PNML is that any kind of Petri net can be considered as a labeled graph. In particular, all information that is specific to a particular kind of Petri net can be captured in labels. The basic structure of a PNML document is defined in PNML Core Model [29]. This model imposes no limitation on labels so it can represent every type of Petri net.

A file that meets the requirements of PNML is called a Petri net file. It may contain several Petri nets. Each Petri net consists of objects, which, basically, represent the graph structure of the Petri net. Each object within a Petri net file has a unique identifier, which can be used to refer to this object. In basic PNML, an object is a place, a transition or an arc. For convenience, a place or a transition is called a node. In order to assign further meaning to an object, each object may have labels. Typically, a label represents the name of a node, the initial marking of a place, the guard of a transition, or the inscription of an arc. Two kinds of labels can be distinguished: annotations and attributes. An annotation comprises information that is typically displayed as text near the corresponding object. However, an attribute specifies a graphical property of an object such as color, style, form, or line thickness. Each object and annotation is equipped with graphical information. For some tools, it might be necessary to store tool specific information, which is not supposed to be used by other tools. In order to store this information, each object and label may be equipped with such tool specific information. Its format depends on the tool and is not specified by PNML. In order to guarantee compatibility among different Petri net types, the Conventions Document comprises the definitions of all standard labels; technically, the Conventions Document consists of a sequence of more or less independent label definitions. Each label definition in the Conventions Document must be assigned a unique name. For each label, the Conventions Document gives a reference to its meaning and states in which PNML elements it may occur. The Conventions Document guarantees that the same labels have the same meanings in all types of Petri nets which allows the exchange between them [30]. The example below (Fig. 11
                           ) shows the description of a Petri nets with two places and two transitions.

After presentation of our approach, we demonstrate its feasibility using a case study in the monitoring of a diabetic patient.

As a preliminary experiment in our approach, we conducted a case study of a medical system for the monitoring of a diabetic patient. The example is designed to monitor in real-time evolution of diabetic patients in a smart hospital. Monitoring is made via biological sensors implanted under the patient’s skin, which periodically control the patient’s glucose levels. Sensors implanted inside the human body to monitor parts of the body are called biosensors. These biosensors form a network and collectively monitor the health condition of their carrier or host. These biosensors monitor glucose levels. Glucose monitoring involves the collection of data about glucose levels and making decisions based on it. These biosensors are permanent for a better monitoring of diabetic patients. The ubiquitous system must continuously verify the changing state of each patient, save data and give guidance for medical intervention.

One of the problems that can arise from such a case study is to know how to notify the medical team for an urgent and immediate intervention, and how to proceed. Any intervention should take into account the status of the patient and the location of the medical team, whether nurse or doctor. The ubiquitous system will therefore generate real-time user interfaces adapted to their preferences, profiles, activities and geographical location. It will guide the user on how best to accomplish his task while taking into account the various constraints of the system.

The implementation of the case study will follow these steps (Fig. 12
                     ): The first step is to capture the context data. The context information acquired through the sensors can be classified into three categories: time, geographical location and glucose level. For the first two categories, the information is obtained from different sensors disseminated in the environment. For the last category, the value of glucose level comes from the patient’s biological sensors. For the user’s identity and the application’s platform, this information will be captured when starting the application. In the second step of the proposed approach, we must analyze and model the information of context.

According to the context definition given in the previous section, we consider the context as the triplet 
                        
                           <
                           user
                           ,
                           plat
                           -
                           form
                           ,
                           environment
                           >
                        
                     . Each component of this triplet is modeled by an independent PN. These components are:
                        
                           •
                           User’s PN (Fig. 13
                              A): this aims to identify the profile of the user (doctor or nurse). The marking of the network at a given time defines the type of the connected user.

Platform’s PN (Fig. 13B): describes the different platforms that can be utilized by users. User interface can be hosted on various platforms. In the case study, we assume that a user can connect using a tablet, a PC or a mobile phone.

Environment’s PN (Fig. 13C): this describes the different values of our environment. In this example, after the opening of the session, various sensors intercept in parallel (i) the glucose level (GL) of the patient, (ii) the geographical coordinates of the user and (iii) the time. Regarding geographical data, the user can be at the hospital, practice, home or outdoors. Time can have three different values: morning, afternoon or evening. Tokens present in different places will describe the state of the environment by specifying the values of time, geographical data and glucose level.

The environment’s PN must be careful of any changes that may occur to the environment. This action is possible by transitions “detection changing 1 and detection changing 2” in Fig. 13C, which will monitor any possible changes in the environment. If any changes occur, then the new data will be captured by our measuring sensors. The status of the three networks will be determined through the values of the captured data. When starting the application; the marking of the context’s PN will be determined through the information coming to the capture layer. So, the context interpretation layer will be supplied in real-time from the acquisition layer.

Modeled in Petri nets, the context model cannot “easily” be processed by our system to detect the status of the context. Thus, the context model is implemented in PNML. Based on XML language, the PNML files offer good results in the process of real-time generation of pervasive interfaces. Indeed, from context acquisition to the generation of graphic interfaces, we use languages and tools based on XML standard. The listing code Listing 1
                      shows a part of the PNML file relating to the context model.

In order to detect the current context, we use an algorithm that browses the PNML files and identifies the values of the tokens in the PN places. The main steps are as follows:
                        
                           1.
                           Create a DOM Parser by defining a DocumentBuilder and a document from the XML file (”UserPNML.xml);

Build the tree in order to get nodes and elements;

Parse the data Structures (tree) from the root element “net”;

Repeat until all elements inside the “token” tag are processed;

Test if the value inside the tag “text” is 1;

If so, return identity of the user.

Once the current context of the user is detected, the next step is to identify the appropriate user’s task in such a context. In our example, the current context is (doctor, touch_screen, morning, hospital, GL). The database Ctx_Tsk_DB stores all couples “context, task” couples (Table 3
                     ). At any given time, the execution of the three PN (user’s PN, environment’s PN and platform’s PN) determines the values of context. In each context, a user task is assigned. These pairs are stored in the database. If the value of “context, task” is in the database, then this is a known and modeled situation. If this value is not in our database, then this will be considered as an unexpected situation. The next figure defines part of the database relating to our case study.

At this stage, the appropriate user’s task is chosen according to the current context of use that is identified. In the next step, the adequate model for the user’s task is detected. As mentioned in the previous section, the user’s task will also be modeled using Petri nets. The overall pervasive HCS will be decomposed into basic tasks. Each task will be executed in a particular context. For our example, as the patient is hypoglycemic then task 1 (T1), sketched in Fig. 13D, is occurred. It is assigned to a particular context and can only be executed by a doctor who is in the hospital. The doctor must at first check the status of the patient and measure their glucose level:
                        
                           •
                           If the rate of GL⩽4mmol, then doctor/nurse must administer food containing sugar, wait 15min and repeat the measurement of glucose. In the next step, the adequate model for user’s task is detected;

If the rate of GL>4mmol, then doctor/nurse must give the patient an insulin injection;

If the status is normal, then the patient’s condition should be monitored for any possible change.

The above rules were provided by medical professionals. They define primary measures to be taken in case of a fall or a rise in glucose levels. The values of the tokens in the context’s PN trigger Task1. We consider the PN transition “Begin Action”. To these transitions, we associate the adequate parameter(s) of interface, either informational or control, which refer to the user’s requirements (see transition in Fig. 13). Thus, at the state “measuring glucose level”, the user has the relevant user requirements to adequately perform the action, i.e. Glucose Levels (GL). This value comes from the context model; more precisely from the environment’s PN. For instance, the informational parameter GL informs the user of the Patient’s usual glucose level. At the state “glucose administration”, the user has access to the phone number, the identity of the doctor in charge of this patient and other information related to the prescribed medicine (Pr). To make it easier to call the treating doctor, a button which indicates the control parameter (TD) will appear. At the state “give insulin”, the user shall have access to a menu of authorized food for the patient (AF) to choose from. The task model is also translated into a PNML file. This transformation is very important. We can deduce the specification of the pervasive interface from the task model. The PNML files for user task are slightly different from the PNML files for context. In fact, they add new tags relative to the informational or control parameter associated to each transition. The Listing 2
                      shows the PNML file of Task 1 (in Fig. 13D).

Once the informational and control parameters are identified, we can deduce the necessary components of the User Interface: (i) we associate an Informational graphical object to each informational parameter; (ii) we associate a Control graphical object to each control parameter. The graphical specification of the user requirements becomes possible. Ergonomics rules are used. These rules are ergonomic recommendations formalized in clausal form. The PNML file of the user task associated to the ergonomic rules leads to the specification of the pervasive interface. In order to select the appropriate graphical specification of the interface, we scan the PNML task. The system decides the most suitable graphical representation and the interaction of the interface’s objects according to the given user requirements. Below (Listing 3
                     ), we give a few examples of ergonomic rules used for graphical specification.

For informational parameters associated to a “tablet” type platform, we recommend a graphical ‘curve’ type object to represent the evolution of the patient’s glucose level. If the informational parameters are associated to a “screen touch” type platform, we recommend the use of a label. For the control parameter, we associate a control button.

These specifications are forwarded to the “automatic generation of HCI” layer. For our example, we assume that the patient’s Glucose Level is 3.2mmol and that the user is a doctor in the hospital using a mobile phone. The generated pervasive interface would look as follows (Fig. 14
                     ).

Assuming that at the time t
                     +1, the doctor switches the mobile device from a mobile phone to a tablet. The amount of information displayed on a mobile phone is not the same as on a tablet. Actually, from a technical point of view, tablets have a larger screen size than mobile phones. This will directly influence the displayed information in terms of volume and type of interaction to use. For example, in the case study, if the platform is a tablet (Fig. 15
                     ), then we associate the following informational parameter to the different state of Task 1: (i) patient’s personal record (PPR), (ii) medical analysis of patient (MAP), (iii) statistical analysis of patient (SAP) as a curve.

According to the change of context of use and especially depending on the platform, the task’s transition will contain more informational parameters. Thus, the PNML file will change.

This PNML file associated to the ergonomic rules will lead to the graphical interface shown in Fig. 16
                     .

From a technical point of view, we use a SOA (Service Oriented Architecture). First, we transform our PN model into a PNML representation. Algorithms are written in Java to parse the PNML file of context in order to detect the location of the tokens and consequently the current context. Once the triplet of context is identified through the xml code, we browse the Mysql database “context i, Task i” in order to identify the appropriate task for the current situation. We use Java Script Object Notation (JSON) web service to query the database and to extract the name of the appropriate task. The monitoring of the diabetic patient was developed using Android.

As the global model’s construction was based on a specific fusion technique of the places of elementary structures, the composition will therefore retain the properties verified on the basic structures. In other words, we can say that, by composing validated elementary structures, the overall model itself is validated. The elementary PN structures on which the HCS model is based, verify “the good” properties such as bounding, non-blocking, vivacity and persistence. At the level of the global model of the HCS, these properties are ensured through the following construction process.

First, we selected the good properties to be checked for the proper functioning of a given model. Then, we explain the process to be followed for verifying these properties on the model of the HCS.


                     Properties to be verified: The smooth running of a given HCS can mainly be ensured by the following three properties: (i) the absence of blocking: the proposed system must never jam as a result of any action of the user; (ii) the availability of services: the system must guarantee the availability of certain services relative to the current situation; and (iii) the absence of conflict and stability: the system must never pose a situation of actual conflict and it must ensure a certain stability of the various services it presents. It will, thus, be necessary to ensure the absence of any state of unpredictable evolution of the system and there should be no conflict in a given running situation.

These good running properties are guaranteed by some of the structural properties of the Petri nets. In fact, the property of boundedness guarantees a finite number of possible states of the system. The property of vivacity reflects the system’s potential to reach all possible modeled services and ensures the absence of any partial or complete blockage, which would ensure the absence of blocking of the implemented interface and thus allow accessibility to the various services it offers. Last, the property of persistence guarantees the absence of conflict in the network and subsequently the stability of the system and the absence of confusion or ambiguity in its various states.

@&#CONCLUSION@&#

We demonstrated through this work a formal approach dealing with pervasive interfaces’ generation. This approach uses Petri nets for HCS, context and task modeling. The real-time adaptation of the user interface in a pervasive environment is based on the user’s current needs and the context of use. This was performed by an original proposed process of composing elementary Petri nets. The use of this PN composition methodology allowed the verification of the relevant properties of the system before generation of the interfaces. We attempted to demonstrate the influence of the context on the modeling of the user’s task in a critical field and the strength of PN in critical system modeling. We also explained how to deduce the user’s requirements through the task model and thus to identify the graphic components of the interface. As proof of the concept, we evaluated a pedagogical case study on the monitoring of diabetic patients in a smart hospital. We have modeled the context’s components namely the user, the environment and the platform. The user’s task was also modeled using Petri nets. We have demonstrated the feasibility of our approach on a concrete example of a critical system where interfaces must be valid.

This approach has some limitations. The most important is the management of unexpected situations. In the proposed architecture, to deal with an unexpected situation, the user will be provided with previously studied information and will intervene manually on the system, but this situation should be handled automatically. In the near future, we will, first, detail the running of each component of our approach and, second, elaborate an experimental platform for the evaluation of the generated user interface.

@&#REFERENCES@&#

