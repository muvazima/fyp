@&#MAIN-TITLE@&#Field programmable gate array implementation of spectrum allocation technique for cognitive radio networks

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           To maximize the network utilization, spectrum allocation technique fairly allocates the channels to secondary users.


                        
                        
                           
                           SA problem is solved by Differential Evolution algorithm and compared the performance with PSO and FA.


                        
                        
                           
                           DE improved the quality of solution and time complexity by 29.9%, 242.32% and 19.04%, 46.3% compared to PSO and FA.


                        
                        
                           
                           We propose FPGA based coprocessor for DE-SA IP and interfaced to PowerPC.


                        
                        
                           
                           The coprocessor accelerates SA task by 76.79–105x and 5.19–6.91x compared to float and fixed DE-SA software.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Spectrum allocation

System on chip

Differential evolution

Cognitive radio

Hardware accelerator

@&#ABSTRACT@&#


               
               
                  Cognitive radio is an emerging technology in wireless communications for dynamically accessing under-utilized spectrum resources. In order to maximize the network utilization, vacant channels are assigned to cognitive users without interference to primary users. This is performed in the spectrum allocation (SA) module of the cognitive radio cycle. Spectrum allocation is a NP hard problem, thus the algorithmic time complexity increases with the cognitive radio network parameters. This paper addresses this by solving the SA problem using Differential Evolution (DE) algorithm and compared its quality of solution and time complexity with Particle Swarm Optimization (PSO) and Firefly algorithms. In addition to this, an Intellectual Property (IP) of DE based SA algorithm is developed and it is interfaced with PowerPC440 processor of Xilinx Virtex-5 FPGA via Auxiliary Processor Unit (APU) to accelerate the execution speed of spectrum allocation task. The acceleration of this coprocessor is compared with the equivalent floating and fixed point arithmetic implementation of the algorithm in the PowerPC440 processor. The simulation results show that the DE algorithm improves quality of solution and time complexity by 29.9% and 242.32%, 19.04% and 46.3% compared to PSO and Firefly algorithms. Furthermore, the implementation results show that the coprocessor accelerates the SA task by 76.79–105× and 5.19–6.91× compared to floating and fixed point implementation of the algorithm in PowerPC processor. It is also observed that the power consumption of the coprocessor is 26.5mW.
               
            

@&#INTRODUCTION@&#

Today wireless access systems are rapidly spreading with the emerging technologies in communication systems. Due to the rigid spectrum licensing policy, spectrum scarcity may arise in future. To solve this problem cognitive radio is proposed as an alternative technology that enables dynamic access of the spectrum. In this technology, cognitive radio (CR) users (secondary users) utilize the spectrum resources opportunistically. Cognitive radios have the ability to sense, to learn, and to adapt to the environment [1]. The cognitive radio cycle has four major functionalities namely: spectrum sensing, spectrum decision, spectrum mobility and spectrum sharing. In CR network, it is assumed that secondary users may use the licensed spectrum with out interference to primary users. The main task of spectrum sensing is to scan the spectrum and find the bands which are not used by primary users. Subsequently during spectrum decision phase, secondary users will use the vacant spectrum by the request while satisfying the interference constraints imposed by primary users and secondary users. This is also termed as spectrum allocation. A CR network can fully utilize the spectrum by using an efficient spectrum allocation algorithm, which assigns appropriate channels to secondary users while satisfying the throughput, number of channels and bit error rate requirements.

Recently, different approaches such as genetic algorithm, neural network and game theory have been used to solve the spectrum allocation task of the CR [2–7]. Artificial neural network is used to calculate the channel capacity and to associate a predictable and achievable performance with a set of environmental factors and radio parameters of cognitive radio [3]. A two-step resource allocation method [8], in which the first step is to allocate the spectrum resources to primary users and in the second step the spare service capacity of primary channels is distributed among the secondary users. This results an improvement in quality of service of secondary users without disturbing the primary users quality of service. This technique also reduced the allocation time and data loss to the primary and secondary users [8]. An optimized in-band control channel scheme with channel selection scheduling algorithm is reported that improves the spectrum efficiency with reliable control information. This method is adaptive to dynamic behavior of primary user activities with out any interference from secondary users [9]. An allocation algorithm called cost and connection degree based (CCB) algorithm for cognitive radio networks. Results show that the proposed algorithm performs more effectively when the network condition is bad by compared to Maximal Independent Set algorithm [10].

An analytical model for best fit channel selection using continuous time markov chains is reported to enhance the network wide performance while satisfying the quality of service of cognitive users. Using best fit channel selection, performance is improved due to the reduced spectrum fragmentation. The performance of this model is compared with longest idle time channel selection method in terms of spectrum opportunity utilization and probability of success under different degree of selfishness [11]. Recently, node-based, link-based and node-link based algorithms are proposed to solve channel assignment problem by satisfying the interference constraints and maximizing the number of nodes with assigned channels. From the extensive simulation results, it is shown that node-link based algorithm achieves the best localized initialization by using star structure and maximal matching, while maximizing the efficiency and connectivity of the network [12].

In literature, the spectrum allocation problem is solved with an assumption that during the spectrum assignment process, environmental condition of the network remains static [7]. SA task is formulated as an optimization problem and Evolutionary Algorithms like Genetic Algorithm (GA), Quantum Genetic Algorithm (QGA) and Particle Swarm Optimization (PSO) are being used to solve it [13]. Artificial Bee Colony (ABC) algorithm is also used to solve the same problem and compared the performance with GA [14]. Recently the use of Firefly Algorithm (FA) is also explored to solve the SA problem and it is reported that FA performs better in terms of time complexity and quality of solution compared to PSO and ABC algorithms [15]. The efficiency of SA algorithm is defined either in terms of quality of solution or time complexity or both. During last decade, Differential Evolution algorithm has gained popularity in solving NP hard problems due to its inherent nature of finding global optimum solution [16,17]. Recently the present authors have explored the use of DE in solving spectrum allocation problem [18]. However the study was limited to maximize Max-Sum-Reward (MSR) function for spectrum allocation. In reality the SA task not only depends on the MSR but also on MMR and MPF network utilization functions [7].

In this work, Differential Evolution (DE) algorithm is used to solve the SA problem by considering all the objectives and compared its time complexity along with quality of solution with PSO and Firefly algorithms. The spectrum allocation problem is solved by different optimization algorithms using desktop computers to maximize the network utilization. But there is limited literature on hardware implementation of SA to improve the execution speed and portability of the algorithm [18]. The solution of spectrum allocation depends on the factors like network architecture (distributed or centralized), spectrum allocation behavior (cooperative or non-cooperative) and spectrum access techniques (overlay or underlay) [19]. In this work we have solved the SA problem by considering the network architecture as distributed, spectrum allocation behavior as cooperative with overlay access technique.

Here, it is assumed that each secondary user use a distributed algorithm to determine its own spectrum assignment. In this scheme, a secondary user considers the locally available information from the neighborhood users and decides its spectrum assignment. As each secondary user implicitly have an embedded computing platform, the spectrum allocation (SA) task can be performed on it. However running the SA on embedded processor consumes most of the platform resources, thereby degrading the performance of other primary applications running on it. This demands for a dedicated hardware peripheral for performing the SA task. Hence the second objective of this work is to develop a coprocessor for performing DE based SA task to enhance the execution speed of the allocation algorithm. Different platforms such as Digital Signal Processors (DSP), Microcontrollers and Field Programmable Gate Arrays (FPGA) are available to implement the SA algorithm in hardware. However the choice of platform depends on the factors such as power consumption, computational time and reconfigurability of peripherals. A FPGA based hardware/software co-design architecture of Genetic Algorithm (GA) for reconfiguring cognitive radio parameters is proposed [2]. In this work the fitness module for obtaining the CR parameters is implemented in the processor and Genetic algorithm is in hardwired fabric of FPGA. It is reported that this approach accelerated the design speed 6us over processor implementation result [2]. A hardware device for channel allocation is developed to speed up the channel selection and allocation algorithm with respect to the current traffic requirement and interference constraints [20]. This device attained high efficiency in allocation of available channels (order of nanoseconds).

In this work, the authors have chosen Xilinx Virtex-5 FPGA as the platform for the implementation of SA task due to its features like improved DSP48E slices for complex math, six input look-up tables (LUTs) and its improved power efficiency. In order to implement the DE based SA algorithm in FPGA, the critical task is the development of a suitable architecture for the complete algorithm targeted to FPGA. In literature fixed point architectures of computationally complex algorithms such as gradient based motion estimation, maximum a posteriori (MAP) decoding algorithm of turbo and low-density parity-check codes, Discrete cosine transformation are proposed [21–23]. A detail analysis of the effect of quantization and saturation for gradient based motion estimation algorithm is presented [21]. The choice of number system either fixed or floating point depends on the trade-off between the accuracy, resource and power consumption. Adaptive decision feedback equalizer is implemented using block floating point (BFP) arithmetic and it has been shown that the BFP speeds up the design compared to usual floating point implementation [24].

Recently the authors have reported the architectural details of DE algorithm (both fixed and floating point arithmetic), implemented the same in FPGA and demonstrated its acceleration by minimizing a set of testbench functions [18,25]. A floating point DE IP is developed and interfaced to 32-bit PowerPC440 (PPC440) processor using processor local bus (PLB) of Virtex-5 FPGA [25]. The developed hardware DE IP is verified by optimizing numerical benchmark functions and concluded that the hardware DE IP accelerates the execution speed by 200× compared to its equivalent software implementation. A scalable coprocessor is proposed for accelerating the fixed point DE algorithm, and it is interfaced to hardcore PowerPC processor of Xilinx Virtex-5 FPGA [18]. It has gained a speed-up of 73.14–160.2× and 2.19–27.63× compared to software execution of floating and fixed point DE algorithm while optimizing benchmark test functions. As a case study, the DE IP is used to solve spectrum allocation problem using Max-Sum-Reward (MSR) objective function and achieved a speed-up of 76.79–105× and 5.19–6.91× with respect to floating and fixed point arithmetic of software implementation of DE algorithm. In [18] spectrum allocation problem is solved by maximizing only one objective i.e; Max-Sum-Reward (MSR) function to validate the DE core. In this work, authors proposed to implement all three network utilization objective functions Max-Sum-Reward (MSR), Max-Min-Reward (MMR) and Max-Proportional-Fair (MPF) along with fixed point DE algorithm as a coprocessor on Xilinx Virtex-5 FPGA development board along with the detail power and resource analysis. Here, user can select which utilization function need to be optimized and maximize the reward of the user and assigned to proper channel with out interference to primary users.

The rest of the paper is organized into eight different sections. Section 2 presents a brief introduction of the spectrum allocation algorithm and describes DE based spectrum allocation technique. Section 3 describes about comparison of the performance of DE-SA over PSO–SA and FA–SA. Section 4 presents software profiling of DE-SA algorithm. The proposed hardware architecture for the DE-SA IP is described in Section 5. Section 6 presents System on Chip implementation of the DE-SA algorithm with APU controller interface. Section 7 presents the experimental setup. Section 8 describes results and analysis followed by conclusions in Section 9.

In the spectrum allocation module, each CR user tries to get a vacant spectrum opportunistically by satisfying the constraints between the CR users and primary users. This is carried out by optimizing the network utility functions. In this section, spectrum allocation problem is formulated and DE based spectrum allocation is explained.

Assuming that a network consists of N secondary users (1…N) competing for M spectrum channels (1…M) and primary users K (1…K). A general spectrum allocation model consists of channel availability matrix 
                           
                              L
                              =
                              
                                 
                                    {
                                    
                                       
                                          l
                                       
                                       
                                          n
                                          ,
                                          m
                                       
                                    
                                    |
                                    
                                       
                                          l
                                       
                                       
                                          n
                                          ,
                                          m
                                       
                                    
                                    ∈
                                    {
                                    0
                                    ,
                                    1
                                    }
                                    }
                                 
                                 
                                    N
                                    ×
                                    M
                                 
                              
                           
                        , channel reward matrix 
                           
                              B
                              =
                              
                                 
                                    {
                                    
                                       
                                          b
                                       
                                       
                                          n
                                          ,
                                          m
                                       
                                    
                                    |
                                    
                                       
                                          b
                                       
                                       
                                          n
                                          ,
                                          m
                                       
                                    
                                    ∈
                                    {
                                    0
                                    ,
                                    1
                                    }
                                    }
                                 
                                 
                                    N
                                    ×
                                    M
                                 
                              
                           
                         and the interference constraint matrix 
                           
                              C
                              =
                              
                                 
                                    {
                                    
                                       
                                          c
                                       
                                       
                                          n
                                          ,
                                          p
                                          ,
                                          m
                                       
                                    
                                    |
                                    
                                       
                                          c
                                       
                                       
                                          n
                                          ,
                                          p
                                          ,
                                          m
                                       
                                    
                                    ∈
                                    {
                                    0
                                    ,
                                    1
                                    }
                                    }
                                 
                                 
                                    N
                                    ×
                                    N
                                    ×
                                    M
                                 
                              
                           
                         
                        [7]. In real-time scenario, the spectrum environment varies slowly, but users have to perform network-wide spectrum allocation operation quickly. So we consider both location and available spectrum are static, thus 
                           
                              L
                              ,
                              B
                           
                         and C are constant during allocation period. The spectrum assignment matrix 
                           
                              A
                              =
                              
                                 
                                    {
                                    
                                       
                                          a
                                       
                                       
                                          n
                                          ,
                                          m
                                       
                                    
                                    |
                                    
                                       
                                          a
                                       
                                       
                                          n
                                          ,
                                          m
                                       
                                    
                                    ∈
                                    {
                                    0
                                    ,
                                    1
                                    }
                                    }
                                 
                                 
                                    N
                                    ×
                                    M
                                 
                              
                           
                        , where 
                           
                              
                                 
                                    a
                                 
                                 
                                    n
                                    ,
                                    m
                                 
                              
                              =
                              1
                           
                         if channel m is allocated to secondary user n, and 
                           
                              
                                 
                                    a
                                 
                                 
                                    n
                                    ,
                                    m
                                 
                              
                              =
                              0
                           
                         otherwise. A must satisfy the interference constraints defined by C:
                           
                              (1)
                              
                                 
                                    
                                       a
                                    
                                    
                                       n
                                       ,
                                       m
                                    
                                 
                                 .
                                 
                                    
                                       a
                                    
                                    
                                       p
                                       ,
                                       m
                                    
                                 
                                 =
                                 0
                                 ,
                                 if
                                 
                                 
                                    
                                       c
                                    
                                    
                                       n
                                       ,
                                       p
                                       ,
                                       m
                                    
                                 
                                 =
                                 1
                                 ,
                                 ∀
                                 1
                                 ⩽
                                 n
                                 ,
                                 p
                                 ⩽
                                 N
                                 ,
                                 1
                                 ⩽
                                 m
                                 ⩽
                                 M
                              
                           
                        For the given L and C, spectrum allocation is to maximize network utilization 
                           
                              U
                              (
                              R
                              )
                           
                         and the optimal conflict free channel assignment matrix 
                           
                              
                                 
                                    A
                                 
                                 
                                    ∗
                                 
                              
                           
                        : 
                           
                              (2)
                              
                                 
                                    
                                       A
                                    
                                    
                                       ∗
                                    
                                 
                                 =
                                 
                                    
                                       argmax
                                    
                                    
                                       A
                                       ∈
                                       (
                                       L
                                       ,
                                       C
                                       )
                                    
                                 
                                 
                                 U
                                 (
                                 R
                                 )
                              
                           
                        Here, we consider three fitness functions as in [13].
                           
                              (a)
                              Max-Sum-Reward (MSR): It maximizes the spectrum utilization of the network regardless of fairness. This optimization problem is expressed as:
                                    
                                       (3)
                                       
                                          MSR
                                          :
                                          U
                                          (
                                          R
                                          )
                                          =
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   n
                                                   =
                                                   1
                                                
                                                
                                                   N
                                                
                                             
                                          
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   m
                                                   =
                                                   1
                                                
                                                
                                                   M
                                                
                                             
                                          
                                          
                                             
                                                a
                                             
                                             
                                                n
                                                ,
                                                m
                                             
                                          
                                          .
                                          
                                             
                                                b
                                             
                                             
                                                n
                                                ,
                                                m
                                             
                                          
                                       
                                    
                                 
                              

Max-Min-Reward (MMR): It maximizes the spectrum utilization of each user with the least allotted spectrum. This optimization problem is expressed as:
                                    
                                       (4)
                                       
                                          MMR
                                          :
                                          U
                                          (
                                          R
                                          )
                                          =
                                          
                                             
                                                min
                                             
                                             
                                                1
                                                ⩽
                                                n
                                                ⩽
                                                N
                                             
                                          
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   m
                                                   =
                                                   1
                                                
                                                
                                                   M
                                                
                                             
                                          
                                          
                                             
                                                a
                                             
                                             
                                                n
                                                ,
                                                m
                                             
                                          
                                          .
                                          
                                             
                                                b
                                             
                                             
                                                n
                                                ,
                                                m
                                             
                                          
                                       
                                    
                                 
                              

Max-Proportional-Fair (MPF): It maximizes the fairness for single-hop flows and the corresponding fairness-driven utility optimization problem expressed as:
                                    
                                       (5)
                                       
                                          MPF
                                          :
                                          U
                                          (
                                          R
                                          )
                                          =
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               ∏
                                                            
                                                            
                                                               n
                                                               =
                                                               1
                                                            
                                                            
                                                               N
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     
                                                                        ∑
                                                                     
                                                                     
                                                                        m
                                                                        =
                                                                        1
                                                                     
                                                                     
                                                                        M
                                                                     
                                                                  
                                                               
                                                               
                                                                  
                                                                     a
                                                                  
                                                                  
                                                                     n
                                                                     ,
                                                                     m
                                                                  
                                                               
                                                               .
                                                               
                                                                  
                                                                     b
                                                                  
                                                                  
                                                                     n
                                                                     ,
                                                                     m
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                                1
                                                /
                                                N
                                             
                                          
                                       
                                    
                                 
                              

The proposed DE-based spectrum allocation algorithm proceeds as follows:
                           
                              (a)
                              Initialize the DE algorithmic parameters and SA algorithm input parameters as shown in Table 1
                                 .

Given 
                                    
                                       L
                                       =
                                       
                                          
                                             {
                                             
                                                
                                                   l
                                                
                                                
                                                   n
                                                   ,
                                                   m
                                                
                                             
                                             |
                                             
                                                
                                                   l
                                                
                                                
                                                   n
                                                   ,
                                                   m
                                                
                                             
                                             ∈
                                             {
                                             0
                                             ,
                                             1
                                             }
                                             }
                                          
                                          
                                             N
                                             ×
                                             M
                                          
                                       
                                       ,
                                       B
                                       =
                                       
                                          
                                             {
                                             
                                                
                                                   b
                                                
                                                
                                                   n
                                                   ,
                                                   m
                                                
                                             
                                             |
                                             
                                                
                                                   b
                                                
                                                
                                                   n
                                                   ,
                                                   m
                                                
                                             
                                             ∈
                                             {
                                             0
                                             ,
                                             1
                                             }
                                             }
                                          
                                          
                                             N
                                             ×
                                             M
                                          
                                       
                                    
                                  and 
                                    
                                       C
                                       =
                                       
                                          
                                             {
                                             
                                                
                                                   c
                                                
                                                
                                                   n
                                                   ,
                                                   p
                                                   ,
                                                   m
                                                
                                             
                                             |
                                             
                                                
                                                   c
                                                
                                                
                                                   n
                                                   ,
                                                   p
                                                   ,
                                                   m
                                                
                                             
                                             ∈
                                             {
                                             0
                                             ,
                                             1
                                             }
                                             }
                                          
                                          
                                             N
                                             ×
                                             N
                                             ×
                                             M
                                          
                                       
                                    
                                 , dimension of the population is set to 
                                    
                                       D
                                       =
                                       
                                          
                                             ∑
                                          
                                          
                                             n
                                             =
                                             1
                                          
                                          
                                             N
                                          
                                       
                                       
                                          
                                             ∑
                                          
                                          
                                             m
                                             =
                                             1
                                          
                                          
                                             M
                                          
                                       
                                       
                                          
                                             l
                                          
                                          
                                             n
                                             ,
                                             m
                                          
                                       
                                    
                                  and 
                                    
                                       
                                          
                                             G
                                          
                                          
                                             MAX
                                          
                                       
                                    
                                  is set to 0.

Generate the initial population (
                                    
                                       
                                          
                                             X
                                          
                                          
                                             i
                                          
                                       
                                    
                                 ) randomly, 
                                    
                                       
                                          
                                             X
                                          
                                          
                                             i
                                          
                                       
                                       =
                                       [
                                       
                                          
                                             x
                                          
                                          
                                             1
                                             ,
                                             i
                                          
                                       
                                       ,
                                       …
                                       ,
                                       
                                          
                                             x
                                          
                                          
                                             3
                                             ,
                                             i
                                          
                                       
                                       ,
                                       …
                                       ,
                                       
                                          
                                             x
                                          
                                          
                                             D
                                             ,
                                             i
                                          
                                       
                                       ]
                                    
                                  where 
                                    
                                       
                                          
                                             x
                                          
                                          
                                             d
                                             ,
                                             i
                                          
                                       
                                       ∈
                                       0
                                       ,
                                       1
                                    
                                 , and 
                                    
                                       i
                                       ∈
                                       (
                                       1
                                       …
                                       NP
                                       )
                                    
                                 .

Generate the Channel availability matrix (A) by using 
                                    
                                       L
                                       ,
                                       B
                                    
                                  and C matrices as [7].

Calculate the fitness of each individual of the current population by using Eqs. (3)–(5).

Perform the mutation, crossover, selection and update the population steps as defined in Algorithm 1 [18].

Increment the 
                                    
                                       
                                          
                                             G
                                          
                                          
                                             MAX
                                          
                                       
                                    
                                  value, if it reaches the predefined maximum value then the assignment matrix obtained from the step (d) is the solution stop the process else go to step (d) and continue.

For simulation, a desktop computer with Intel Core(TM)2 Duo CPU at 3 GHz and 2 GB of RAM is used in the MATLAB environment. In this setup, it is assumed that every primary user has protection range 
                        
                           
                              
                                 d
                              
                              
                                 p
                              
                           
                        
                      as 2 and secondary user’s communication range is with in the bounds of 
                        
                           
                              
                                 d
                              
                              
                                 min
                              
                           
                           =
                           2
                        
                      and 
                        
                           
                              
                                 d
                              
                              
                                 max
                              
                           
                           =
                           4
                        
                     . In this section, the performance of PSO and DE algorithms are compared while solving the SA problem for a given cognitive radio networks. The impact of varying number of secondary users, primary users and channels on the network performance (
                        
                           MSR
                           ,
                           MMR
                        
                      and MPF) using both DE-SA and PSO–SA based algorithms are studied. For simulation setup, the network parameters are set as N = 5–50, K = 10, M = 5. Fig. 1
                     a shows that all the three utilization function values decreases with increase in number of secondary users N. This is because of the constraints between the secondary users to share the channel. Fig. 1b corresponds to N = 20, M = 5, K varies between 5 and 50. From this figure, it is observed that as the number of primary users increase, then there is no spectrum available to secondary users, which leads to decrease in all the utility function values. Fig. 1c corresponds to K = 20, N = 20 with varying M between 5 and 30. This figure reveals that by increasing the number of channels, more opportunities are available to secondary users and this leads to increase in all the three objective function values.

For performance comparison between PSO, DE and FA, all the algorithms are executed for 20 independent runs and the results are tabulated in Table 2
                      corresponds to 20 secondary users, 20 primary users and 20 channels. In this table Time denotes time complexity evaluated as [26], Reward corresponds to mean fitness value and 
                        
                           std
                           %
                        
                      defines standard deviation in percentage of the fitness value over 20 runs. From this table, it is observed that the DE algorithm improves the quality of solution and robustness in all the three cases. The robustness of the DE algorithm is observed from the standard deviation of the fitness values. In the case of MMR, the improvement in quality of solution (fitness value) is approximately 121% and 211%, where as the time complexity is improved by 48% and 236% compared to FA and PSO algorithm respectively. In case of the other two utility functions DE algorithm also perform better in terms of both quality of solution and time complexity compared to PSO and FA algorithms.

Profiling of an algorithm is an important task before implementing in to the hardware. Using profiling we can identify the computational intensive functions and instructions inside the algorithm [25]. For software profiling, DE-SA algorithm in both arithmetic running on Xilinx PowerPC440 processor with clock frequency of 200 MHz. In real time embedded applications like spectrum allocation (SA) for secondary users in cognitive radio where the objective function like Maximum-Sum-Reward (MSR) need to remains fixed in hardware. Here we considered 20 secondary users, 20 primary users, 20 spectrum bands and objective function as MSR. In software profiling of real time scenario, the floating point operations dominate percentage of execution time as shown in Table 3
                      with 
                        
                           
                              
                                 G
                              
                              
                                 MAX
                              
                           
                        
                      = 300, NP = 20. In order to eliminate the computational intensive floating point operations, the algorithm is implemented in fixed point and the results are tabulated in Table 3. From this table it is observed that the overall execution time consumed by DE algorithm is 98%, out of which fitness function (62.98%) and DE algorithm (25.42%) occupies significant percentage of time. FPGA is a good platform choice for accelerating the execution speed of the fitness function(s). With this, there is a possibility of overhead due to bus transaction between fitness function module in hardware and DE algorithm in software. This lead to degrade the acceleration performance. In order to avoid the performance degradation, both fitness function and DE algorithm are need to be implemented as a single hardware module.

The proposed hardware architecture of DE-SA is based on [18] and it is shown in Fig. 2
                     . It consists of seven main modules, i.e., Memory initialization, Mutation, Crossover, Selection, Random Number Generator, Spectrum Allocation fitness evaluation module and a Control Finite State Machine (FSM) Module to synchronize all six modules. The fitness evaluation module consists of three network utilization functions namely Max-Sum-Reward (MSR), Max-Min-Reward (MMR) and Max-Proportional-Reward (MPF) are embedded on it. The utilization function is selected by the user input (
                        
                           User
                           _
                           Sel
                        
                     ) to DEMUX logic. During the fitness evaluation, the selected utilization function results the fitness value and it is stored in fitness memory. The network data matrices are stored in internal memory and the current DE population matrix, that are used to compute the assignment and reward matrices. These matrices are given as input to the fitness module for calculating the fitness value. The FSM has idle, initialization, operation, waiting and reading states. In the idle state all the modules are in the reset condition. Next in the initialization state the FSM enables memory module when the inputs such as maximum number of generations 
                        
                           
                              
                                 G
                              
                              
                                 MAX
                              
                           
                        
                     , population size NP, dimension D, crossover rate Cr, scaling factor F, number of secondary users N, number of primary users K, number of channels M and choice of utilization function 
                        
                           User
                           _
                           Sel
                        
                      are available to DE-SA module. During the operation state, control FSM enables internal modules according to the different stages of the algorithm, i.e., crossover, mutation and selection. FSM will be in a wait state until the execution of current module else it will go to next module for execution. In the reading state FSM will read the fitness value and write into the output register.


                        MSR module is used to calculate the total sum reward of the network and its architecture is shown in Fig. 3
                        . For each population, the generated channel availability matrix A and channel reward matrix (B) are input to the fitness function. These two matrices are given to a multiplier. Essentially this is a MAC unit. The final accumulated result is stored in the 
                           
                              Reg
                              1
                           
                         of 32-bit size.

This module is used to calculate the minimum reward of the cognitive user in the network. The same A and B matrices are given as input to the multiplier and adder. The reward value of each secondary user for the selected channels is stored in 
                           
                              RegFile
                              1
                           
                         of 1Kbit memory. Minimum value of 
                           
                              RegFile
                              1
                           
                         is obtained by using a comparator and Mux logic. The resulted MMR reward value is stored in 32-bit 
                           
                              Reg
                              2
                           
                         as shown in Fig. 4
                        .


                        MPF module is used to calculate the fairness reward of the network. The architecture for implementing MPF utility function is shown in Fig. 5
                        . The same A and B matrices are input to the multiplier and adder module of the circuit. For each secondary user, reward value is calculated for the selected channels and it is stored in 
                           
                              Reg
                              2
                           
                        . This reward value is again multiplied by the reward value of another secondary user and the result is stored in 
                           
                              Reg
                              3
                           
                        . This process continues for N times, where N is the number of secondary users. Subsequently the 
                           
                              Reg
                              3
                           
                         value is input to Nth Root module to calculate the fair reward of the network.

The proposed PSoC platform for implementing the DE-SA IP is shown in Fig. 6
                     . It consists of a PPC440 embedded processor, DE-SA IP, Memory controller, UART (RS-232) serial communication, timer and interrupt. In this platform DE-SA IP is developed as a Fabric Coprocessor Module and it is connected to the PPC440 processor via Fabric coprocessor bus. A hardcore PowerPC440 is used because of its natural advantages over soft core processor and effective resource utilization [18]. The DE based SA algorithm is implemented as DE-SA IP core, which includes three fitness functions 
                        
                           MSR
                           ,
                           
                           MMR
                        
                      and MPF as shown in Fig. 6. Two asynchronous FIFOs (depth of 10 and width of 32 bits) are used to interface at the input and output of the DE-SA core. The input signal is processed as a stream and each stream has nine samples 
                        
                           
                              
                                 G
                              
                              
                                 MAX
                              
                           
                           ,
                           NP
                           ,
                           D
                           ,
                           Cr
                           ,
                           F
                           ,
                           
                              
                                 User
                              
                              
                                 S
                              
                           
                           el
                           ,
                           N
                           ,
                           M
                        
                      and K respectively. The output signal from FIFO-2 is received by the PPC440 processor. Further details of the interface and the peripherals are discussed in [18,27].

In this work, we have considered the basic DE algorithm for allocating the spectrum bands among the secondary users. Algorithmic parameters of DE-SA are tabulated in Table 1. Firstly, SA problem is solved by using PSO, FA and DE to analyze the suitability of algorithm. Table 2 and Fig. 1 reveals that DE outperforms compared to both FA and PSO algorithm in terms of quality of solution and time complexity. Due to this a hardware IP for DE based SA algorithm is developed to accelerate the execution speed of DE based SA algorithm.

For software implementation, DE based SA algorithm is ported into the PPC440 using 32-bit fixed point C code. For hardware implementation, the proposed algorithm is coded using HDL and an Intellectual Property (IP) is developed. Then the IP is simulated and tested in Xilix ISE and EDK 10.1.3 platform on Virtex-5 FPGA development board. The IP core frequency is set to 63.55 MHz, which is the maximum frequency obtained during implementation. In the proposed accelerator, inputs (the number of secondary users, primary users, number of channels and other DE algorithmic parameters such as population size, number of generations and dimension) are scalable and are set as user inputs to the processor. After receiving these inputs, DE-SA IP is invoked using Load/Store API call from the PPC440. Then the IP complete its execution and the channel availability matrix and the optimum fitness values are monitored through UART module.

@&#RESULTS AND ANALYSIS@&#

The execution time for completing the SA task in PowerPC440 processor of Xilinx Virtex-5 FPGA is referred as software (SW) execution time whereas the time for executing the SA task using the DE-SA IP is referred as hardware (HW) execution time. The average execution time of the DE-SA implemented in PowerPC440 processor for optimizing the three utility functions is tabulated in Table 4
                        . The tabulated results correspond to the mean time of 20 independent runs. Table 4 correspond to the network parameters as 5 secondary users, 5 primary users and 5 available channels (
                           
                              5
                              ×
                              5
                              ×
                              5
                           
                        ). In the table Std 
                           
                              %
                           
                         refers to the standard deviation of the execution time over 20 independent runs. It is observed that the acceleration factor remains almost constant between 11× and 19× with the increase in population size. This concludes that the fixed point implementation of the algorithm in processor speeds up the design by same amount irrespective of the algorithmic complexity of the DE algorithm. This observation is true for all the three utility functions for all the generation numbers. The robustness of the implementation is supported by the low standard deviation of the execution speed over many independent runs.

Similar kind of analysis is carried for the execution speed of the algorithm by increasing the network parameters. Table 5
                         correspond to the network parameter as (
                           
                              20
                              ×
                              20
                              ×
                              20
                           
                        ). As the network parameter increases, the complexity of SA task increases. From both the above tables, it is evident that (a) although the execution time increases in individual cases, but the acceleration factor remains almost constant with the increase in the network complexity and (b) the fixed point implementation is the optimum choice for this application.

Subsequently, the hardware IP of the SA algorithm is verified as shown in the Fig. 6. The hardware execution time (HW) for optimizing three utility functions are measured using the timer. For two different network parameters setting (
                           
                              5
                              ×
                              5
                              ×
                              5
                           
                         and 
                           
                              20
                              ×
                              20
                              ×
                              20
                           
                        ) the execution time is shown in Tables 6 and 7
                        
                        . The acceleration due to hardware implementation of the task is compared with the equivalent floating point and fixed point software implementation. The AF in the case of floating point software implementation is calculated as
                           
                              (6)
                              
                                 AF
                                 (
                                 Float
                                 )
                                 =
                                 Float
                                 
                                 SW
                                 /
                                 HW
                                 (
                                 in
                                 
                                 milli
                                 
                                 Sec
                                 )
                              
                           
                        
                     

Similarly the AF in the case of fixed point software implementation is calculated and tabulated in Table 6. This analysis for acceleration is carried out for all the utility functions with different population size and number of generations. The standard deviation (std%) of execution time in each case for 20 independent runs are also tabulated in the Table 6. From this table, it is observed that DE-SA hardware IP gives an acceleration of 87.41–105× and 5.19–5.9× over float and fixed software implementation while optimizing the MSR utility function. The acceleration factor is almost same with the increase in population size and number of generations. The acceleration of the hardware IP over fixed point software implementation is due to the hardware realization. Although the acceleration over floating point software implementation is quite obvious but a significant acceleration i.e; 
                           
                              
                                 
                                    1
                                 
                                 
                                    ̃
                                 
                              
                              
                              0
                              
                              0
                              
                              ×
                           
                         is observed. Almost similar trend in acceleration factor is observed while optimizing other two i.e; MMR and MPF utility functions.

The same analysis is performed by increasing the network parameters to 
                           
                              20
                              ×
                              20
                              ×
                              20
                           
                         and the results are tabulated in Table 7. By comparing the Tables 6 and 7 it is observed that with the increase in the network complexity, individually the hardware IP and the processor takes more execution time to complete the SA task, however the overall acceleration factor remains almost constant. The low standard deviation concludes about the robustness of the implementation.

The DE-SA algorithm is implemented in the FPGA as shown in the Fig. 6. The fitness values i.e; the converged values of the utility functions are compared with the results obtained from the software i.e, PowerPC processor. The convergence results of the three utility functions for different network configurations (i.e; 
                           
                              5
                              ×
                              5
                              ×
                              5
                              ,
                              10
                              ×
                              10
                              ×
                              10
                           
                         and 
                           
                              20
                              ×
                              20
                              ×
                              20
                           
                        ) are shown in Figs. 7–9
                        
                        
                        . In these figures, (HW) and (SW) correspond to the results obtained using the DE-SA hardware IP and the processor respectively. The results shown are the mean results obtained for 20 independent runs. From Fig. 7, it is observed that at the beginning of generation/iteration both SW and HW gives same value due to the same seed, and afterwards there is a slight variation in the reward values (fitness values). The variation is because they generate the different random numbers with iteration. This effects the performance of DE algorithm and its convergence. Similarly Figs. 8 and 9 analyze the convergence behavior of the HW and SW for optimizing the Max-Min-Reward (MMR) and Max- Proportional-Fair Reward (MPF) utility functions. The convergence graphs conclude that the SW and the developed IP functionally behaves the same.

The power analysis of the DE-SA IP is performed by using XPower Analyzer tool of Xilinx ISE 10.1. Table 8
                         shows the power consumed by each resource block of the FPGA (Xilinx Virtex-5) along with its resource utilization for this application.

The hierarchal power analysis of the developed DE-SA System on Chip (SoC) system is tabulated in Table 9
                        . From this table, it is observed that the proposed IP consumes 26.53 mW of total power (152.66 mW) consumed by the complete SoC system.


                        Table 10
                         shows the resource utilization by the individual utility functions namely, 
                           
                              MSR
                              ,
                              MMR
                              ,
                              MPF
                           
                         along with DE-SA that correspond to the DE algorithm with all the three network utility functions.

Furthermore the device utilization of the total SoC system along with the customized DE-SA IP is tabulated in Table 11
                        . Some of the resources like Bonded IOBs, BUFG and PLL_ADVs are used only in the SoC system but not in the IP. This table reveals that DSP48E slices are used by the IP only, hence all the computational task is performed in the IP core. The achieved maximum operating frequency of the core is 63.5 MHz although the complete SoC system can work at 200 MHz frequency.

@&#CONCLUSIONS@&#

This paper studied the performance of Differential Evolution algorithm for solving the spectrum allocation problem in cognitive radio network. The performance of the DE is compared with PSO and FA algorithms in terms of time complexity and quality of solution. DE based spectrum allocation achieved an improvement of quality of solution by 29.9% and 19.04%, time complexity by 242.32% and 46.3% compared to PSO–SA and FA–SA in allocating suitable spectrum to the secondary user with out interference to primary user. Subsequently, a hardware IP for solving spectrum allocation problem using DE algorithm is developed and verified its functionality in Xilinx Virtex-5 FX70T FPGA based System on Chip platform. The IP was interfaced to the PowerPC440 hardcore processor via auxiliary processor unit controller. The developed IP is scalable in terms of selecting number of primary users, secondary users and available channels. The acceleration factor was evaluated at different network and algorithmic configurations and found to be 5.19–6.91× and 76.79–105× over the fixed and floating point implementation of the SA algorithm in the PowerPC440 processor respectively. Resource utilization for the IP core is also reported. The maximum operating frequency and the power consumption of the IP were observed as 63.55 MHz and 26.53 mW respectively.

@&#ACKNOWLEDGMENT@&#

The authors are thankful to the University Grants Commission (UGC), Government of India for providing necessary support to carry out this research work.

@&#REFERENCES@&#

