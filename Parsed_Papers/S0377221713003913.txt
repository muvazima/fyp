@&#MAIN-TITLE@&#Machine-part cell formation using biclustering

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           In this paper we apply biclustering to part-machine grouping problem.


                        
                        
                           
                           Biclustering has been almost exclusively applied to DNA microarray analysis.


                        
                        
                           
                           We prove the validness of the proposed technique.


                        
                        
                           
                           Experimental results demonstrate that it outperforms similar ones for known datasets.


                        
                        
                           
                           It can be applied to various machine-part cell formation problems.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Flexible manufacturing systems

Data mining

Group technology

Cell formation

Biclustering

@&#ABSTRACT@&#


               
               
                  Cellular manufacturing is the cornerstone of many modern flexible manufacturing techniques, taking advantage of the similarities between parts in order to decrease the complexity of the design and manufacturing life cycle. Part-Machine Grouping (PMG) problem is the key step in cellular manufacturing aiming at grouping parts with similar processing requirements or similar design features into part families and by grouping machines into cells associated to these families. The PMG problem is NP-complete and the different proposed techniques for solving it are based on heuristics. In this paper, a new approach for solving the PMG problem is proposed which is based on biclustering. Biclustering is a methodology where rows and columns of an input data matrix are clustered simultaneously. A bicluster is defined as a submatrix spanned by both a subset of rows and a subset of columns. Although biclustering has been almost exclusively applied to DNA microarray analysis, we present that biclustering can be successfully applied to the PMG problem. We also present empirical results to demonstrate the efficiency and accuracy of the proposed technique with respect to related ones for various formations of the problem.
               
            

@&#INTRODUCTION@&#

Many modern flexible manufacturing techniques, e.g. Group Technology, are based on the formation of manufacturing cells, taking advantage of the similarities between parts. Cellular manufacturing (CM) is the cornerstone of such manufacturing techniques. Actually, it has been recognized as the second generation of Group Technology (Wang and Li, 1991) while in the first generation only part families were formed based on similar geometric shapes (see e.g. Kuo et al., 2001) without physically changing the machine layout. CM aims at producing small batches of a large variety of part types by grouping parts with similar processing requirements or similar design features into part families and by grouping machines into cells associated to these families. CM allows for reduced set-up times, smaller economic lot sizes, lower work-in-process inventories, reduced material-handling costs, simplified material flows, reduced tool requirements, faster throughput, increased quality, better control of shop floor, etc. (see e.g. Chu, 1997; Wemmerlöv and Johnson, 1997).

One of the first problems faced in implementing CM is the cell formation (CF). The key step of CF concerns the identification of the part families and the machine cells on which these parts are to be processed, which is also called Part-Machine Grouping (PMG) problem. Then, CF requires assignment labor and other resources to each machine cell, layout decisions, evaluation of capacity, minimization of load imbalances, material flows, etc. Most of CF procedures are applied to the binary part–machine incidence matrix (PMIM). A binary PMIM represents the relationship between each part and a set of machines (e.g., a part routing).

The key step of CF, the PMG problem, is a hard problem (see e.g. Papaioannou and Wilson, 2010). Since a brute force algorithm, based on testing all possible part families associated with all possible machine cells, is completely infeasible, the different CF procedures are based on heuristics and near-optimal solution approaches. In this paper, a new approach for solving the PMG problem is proposed which is based on biclustering. Biclustering is a methodology where rows and columns of an input data matrix are clustered simultaneously (see Busygin et al. (2008) and Madeira and Oliveira (2004) for recent surveys). A bicluster is defined as a submatrix spanned by both a subset of rows and a subset of columns, such that objects represented by the first are the most similar to each other when compared over the latter. As in clustering, similarity is calculated by using a (dis)similarity measure (see e.g. Boutsinas and Papastergiou, 2008).

Most interesting proposed biclustering models are proved to be NP-complete (see e.g., Tanay et al., 2002) by reduction to finding the maximum edge biclique in a bipartite graph. Thus, usually, the different biclustering algorithms are based on heuristics. We consider two different approaches in detecting biclusters. The first one is adopted by algorithms trying to detect “good” biclusters using an objective function to measure the quality of the biclusters. They start with a set of initial (usually randomly selected) biclusters or one large bicluster which is usually the whole input data matrix and then try to improve the quality of these biclusters by altering them (e.g. removing, adding, or permuting rows and columns). Such algorithms do not guarantee the detection of the best biclusters. They provide only an approximate answer, however they have a low time complexity. The second approach is adopted by algorithms trying to exhaustively enumerate all candidate biclusters in order to guarantee the detection of the best biclusters. Since there are (2|
                     
                        R|
                     
                     −1)*(2|
                     
                        C
                     
                     |
                     −1) possible biclusters in an input data matrix D(R,
                     C), they are based on a theory to reduce the search space.

The key idea of the proposed technique is based on the observation that a part family allocated to a machine cell forms straightforwardly a bicluster. In Section 2 we present related techniques for solving the PMG problem while in Section 3 we present the application of biclustering to the PMG problem. In Section 4 we present empirical results which demonstrate the efficiency and accuracy of the proposed technique. Finally, in Section 5, we discuss the application of the proposed technique to various formations of the PMG problem and we conclude.

@&#RELATED WORK@&#

There are many different procedures for CF in the literature (see Chu (1989), Lozano et al. (1999), Owsiński (2009), Papaioannou and Wilson (2010), Shafer (1998), Singh (1992), and Selim et al. (1998), for surveys) that can be categorized as array-based, similarity coefficient-based, (non)hierarchical clustering, neural network-based, fuzzy clustering, graph theoretic, mathematical programming and heuristic as water flow-like (Wu et al., 2010). CF procedures can also be divided into those that first form part families (or machine cells) and then assign machines (or parts) and those that form part families and machine cells simultaneously.

Most CF procedures adopt the former approach. For instance, non-hierarchical clustering methods are illustrated (e.g. Srinivasan and Narendran, 1991), which unlike traditional hierarchical clustering methods do not necessarily require specifying the number of clusters beforehand and the clusters emerge naturally based on a given data set. However, they require identification of seeds (“centroids”) for each potential cluster.

Also, graph theoretic methods usually represent machines as vertices of graphs while represent appropriately defined similarity coefficients as weights of arcs. For instance, Rajagopalan and Batra (1975) considered Jaccard’s similarity to represent the strength of the relationship between any pair of machines. Then, machines cells are formed through finding the maximal cliques of such graphs.

Also, artificial neural networks have been extensively applied to CF procedures, as well as to for a wide range of applications in manufacturing. It has been noted that artificial neural networks outperform traditional hierarchical methods for the PMG problem (Park and Suresh, 2003). In Venugopal (1998), a review of the literature devoted to artificial neural network applications to PMG problem is provided. More specifically, competitive learning methods, Kohonen’s self-organizing feature maps and adaptive resonance theory (ART) methods have been applied. For example, in Chu (1993) a competitive learning algorithm is used that is one of the simplest paradigms in unsupervised learning. The most important feature of this procedure is that the user can determine the desired number of machine cells. Rao and Gu (1995) introduced a three-layered neural network, extending the two layers of the ART network, to consider additional constraints in this problem. Venugopal and Narendran (1992) demonstrated the applicability of a competitive learning algorithm, ART1 and Kohonen’s self-organizing feature map. Dagli and Huggahalli (1995) revised ART1 before applying it to CF. Kaparthi et al. (1993) used a revision of ARTl (ARTl/KS) which reads the incidence matrix in reverse notation, (i.e. zeros as ones, and ones as zeros), to improve its performance.

The Fuzzy ART network (Carpenter et al., 1991) represents an improvement in the artificial neural network approach. In Suresh and Kaparthi (1994), the Fuzzy ART network was first applied to the CF problem. It is shown that the Fuzzy ART network outperforms traditional algorithms such as the Direct Clustering Algorithm –DCA (Chan and Milner, 1982) and Rank Order Clustering – ROC2 (King and Nakornchai, 1982) as well as those of ART1 (Carpenter and Grossberg 1987) for the PMG problem, under various performance measures (see Burke and Kamal 1992, 1995; Suresh and Kaparthi, 1994). Also, the execution time of Fuzzy ART was higher than ART1 and ART1/KS, but for larger datasets, execution times were significantly lower than DCA and ROC2 (Suresh and Kaparthi, 1994).

The Fuzzy ART neural network involves several changes to ART 1. It can process both analog and binary input vectors, it adopts a single weight vector connection and it introduces two more parameters, i.e., a choice parameter (α) and a learning rate (β), in addition to vigilance threshold (ρ). Although the same parameter combination could be used to solve two different problems, parameter combinations for obtaining the best solution can be different for different problems. Thus, parameter setting is very important (Peker and Kara, 2004) and the user, depending on the application domain, has to define intervals for parameter values in order to obtain efficient solutions. However, the Fuzzy ART neural network has emerged as viable method for the PMG problem and recent modifications (e.g. Dobado et al., 2002; Won and Currie, 2007; Yang and Yang, 2008) have been presented in order to improve its performance for the PMG problem.

The above methods have been used in forming the part families first (or the machine cells) and then assign machines (or parts). For example, Rajagopalan and Batra (1975) allocate parts to machines cells based on certain rules, as to allocate a component to the smallest machine cell having all the required machines. Also, Dobado et al. (2002) applied the Fuzzy Min–Max neural network (Simpson, 1993), a refined version of the Fuzzy ART neural network, to form part families while for the machine assignment problem a minimum cost flow model is used. Won and Currie (2007) used an ancillary procedure to assign each machine to its most preferred machine cell. The most preferred machine cell for a machine is the machine cell in which it processes the parts with the maximum of the flows (represented by the sum of the cell-values in the PMIM) than any other machine cell. Yang and Yang (2008) have to group parts into part families and machines into machine groups. However, their algorithm may probably generate different number of groups when running the algorithm separately by parts and by machines, respectively. Therefore, they use the following technique: suppose they have already grouped m machines into k machine cells, part i will be assigned to family k when the part operated on k machine cell is proportionately higher than that of any other.

However, the goal in the PMG problem is to cluster parts into families and machines into cells at the same time. The intractability of the PMG problem has led to the development of some heuristic procedures proposed in the literature which aim at forming part families and machine cells simultaneously. Most of these procedures involve a reorganization of the rows and columns of a PMIM to obtain a block diagonal form. Many such early procedures, see Chen and Irani (1993) for a literature review, inspired by the early work of Production Flow Analysis (Burbidge, 1963). For example, Rank Order Clustering Algorithm (King and Nakornchai, 1982) generates diagonalized groupings in a PMIM. It is based on representing rows and columns of the PMIM as binary words in order to rank them. Then, the algorithm rearranges rows and columns in an iterative manner and eventually produces a matrix in which columns and rows are positioned in an order of decreasing binary values. However, the algorithm is very time consuming for large PMIMs. Also, the Direct Clustering Algorithm (Chan and Milner, 1982) consists of going through the matrix sequentially, moving the rows with the ‘left-most’ 1s to the top and the columns with the ‘top-most’ 1s to the left of the matrix. In repeated trips the 1s will be squashed toward the diagonal of the matrix and a clustered pattern will eventually be formed extending from the top left corner of the matrix. The basic rule is that each part or machine number must be moved together with its respective row or column entries during matrix transformation as if the cells or the blocks are linked together by an imaginary rod. Also, the Bond Energy Algorithm (McCormick et al., 1972) permutes the rows and columns of the input data matrix in such a way as to push the numerically larger array elements together. This is because it is noted that the relations among array elements are more easily identifiable when the data matrices are permuted in order to form dense clumps of numerically large array elements. Informative permutations can be found via a measure of clumpiness of a matrix.

There are some two-way biclustering approaches (e.g. Busygin et al., 2002) that first use clustering to produce clusters on both dimensions of the input data matrix separately and then combine these one-dimension results to extract biclusters. This procedure is based on a similar key idea to that of the CF procedures that first form part families (or machine cells) and then assign machines (or parts). However, the most efficient and accurate biclustering algorithms are based on clustering rows and columns simultaneously. Moreover, the PMG problem has two essential dimensions – machines and parts (processes), although the vast majority of CF procedures overlook this duality. There are two essential aspects to the duality, one merely software-technical and related to reconstruction of the block-diagonal structure from clusters (realization of permutation), but the other one much deeper, associated with the relation to quality criteria (Owsiński, 2009).

In most proposed CF procedures, the quality of a solution of the PMG problem is based on the number of voids and exceptional elements (see Lee and Chiang (2002) for an exception). A void is a zero value cell appearing inside a bicluster and an exceptional element is a non-zero value cell appearing outside of extracted biclusters. A void (i,
                     j) means that part i does not require machine j which is assigned to its part family. It causes underutilization of machine j. An exceptional element (i,
                     j) means that part i requires machine j which is not assigned to its part family. It corresponds either to inter-cell moves of part i or the duplication of machine j. Thus, the quality of a solution of the PMG problem is based on the number of intra-cell voids or the inter-cell moves (e.g. Harhalakis et al. 1990; Ribeiro and Pradin 1993) or both (as in most similar works, e.g. Yang and Yang, 2008).

This paper proposes the application of biclustering to the PMG problem aiming at forming part families and machine cells simultaneously. The proposed methodology first enumerates candidate biclusters and then it applies a selection process in order to extract the final machine cells and part families. We consider the application of biclustering to a PMIM. Obviously, the application is straightforward for biclustering algorithms accepting a binary (Boolean) input data matrix. More specifically, we consider the application of biclustering to a binary input data matrix D(R,
                     C). The m rows, R
                     ={r
                     1,
                     r
                     2,…,
                     rm
                     }, represent m machines and the p columns, C
                     ={c
                     1,
                     c
                     2,…,
                     cp
                     }, represent p parts. We adopt this representation only for comparison reasons, since the reverse representation can be directly adopted instead. Cell values vij
                     
                     =1 (vij
                     
                     =0) denote that the part represented by column cj
                     , 1
                     
                     ⩽
                     
                     j
                     
                     ⩽
                     
                     p, should be (not) worked on the machine represented by row ri
                     , 1
                     
                     ⩽
                     
                     i
                     
                     ⩽
                     
                     m. At first, we adopt common formations, i.e., (I) we seek for minimizing the sum VE of intra-cell voids and inter-cell moves, and (II) we do not consider duplication of machines, thus the extracted biclusters have exclusive rows.

It has been noted that the nature of the PMG problem makes it desirable to seek solution techniques which identify naturally occurring machine cells and part families (Mosier, 1989). For instance, seeking for minimizing the inter-cell moves could lead to the simple-minded solution of forming only one machine cell, i.e. the whole shop. Also, seeking for minimizing the intra-cell voids could lead to the simple-minded solution of forming a lot of small machine cells. On the other hand, forced machine cell and part family formations (e.g. a machine cell size limitation) may have an effect more detrimental than beneficial. The proposed technique is based on an initial set of maximal biclusters, (i.e., part families assigned to machine cells), which are considered as naturally occurring. These biclusters have no intra-cell voids and a certain number of inter-cell moves. This initial set prevents from forming a lot of small machine cells. Then, these initial biclusters are merged trying to reduce VE the sum of intra-cell voids and inter-cell moves. Since merging only reduces VE cannot lead to the whole shop. The proposed technique is as follows:
                        
                           
                              
                              
                                 
                                    PMG(D(R,C),List=Ø)
                                 
                                 
                                    {
                                 
                                 
                                    1 B=apply_biclustering(D(R,C));
                                 
                                 
                                    2 WHILE R<>Ø DO
                                 
                                 
                                    
                                       {
                                 
                                 
                                    
                                       3 temp(Rs,Cs)=maxS(Rs,Cs)⊆T(Rt,Ct)∊B |Rs|*|Cs|∧Rs
                                       ⊆R;
                                 
                                 
                                    
                                       4 B=B−{temp(Rs,Cs)};
                                 
                                 
                                    
                                       5 R=R−{Rs};
                                 
                                 
                                    
                                       6 List=List+{temp(Rs,Cs)};
                                 
                                 
                                    
                                       }
                                 
                                 
                                    7 WHILE max(2|Cs
                                       ∩Ct|*(|Rs|+|Rt|)−|Cs|*|Rt|−|Ct|*|Rs|)>0 DO
                                 
                                 
                                    
                                       8 Merge(S(Rs,Cs)∊List, T(Rt,Ct)∊List);
                                 
                                 
                                    9 FOR all exceptional elements aij
                                       ∊D(R,C) DO
                                 
                                 
                                    
                                       10 Assign aij to the S(Rs,Cs)∊List with the larger decrease of VE;
                                 
                                 
                                    }
                                 
                              
                           
                        
                     
                  

First, a set of biclusters are extracted by a biclustering algorithm (line 1). The extracted set determines the accuracy of the proposed technique. Optimum results can be obtained by applying biclustering algorithms trying to exhaustively enumerate all candidate biclusters in order to guarantee the detection of the best biclusters. For instance, the Bimax (Prelić et al., 2006) algorithm extracts all biclusters that are inclusion-maximal, i.e., that are not entirely contained in any other bicluster. Also, the algorithm proposed in Boutsinas (2013), extracts all possible biclusters and it can be parameterized in order to extract all maximal biclusters.

Although, almost all biclustering algorithms extract a set of biclusters, some of them can extract one target bicluster which is usually the one considered the best according to some criterion. Even there are not such algorithms proposed in the literature for binary input data matrices, an iterated extraction of a target bicluster can be applied to the PMG problem. If one_bicluster() is such an algorithm then the following procedure can be used in line 1 of PMG():
                        
                           
                              
                              
                                 
                                    apply_biclustering(D(R,C))
                                 
                                 
                                    {
                                 
                                 
                                    tempR=R
                                 
                                 
                                    tempC=C
                                 
                                 
                                    
                                       WHILE ∃S(Rs,Cs)=one_bicluster(D(tempR,tempC)) DO
                                 
                                 
                                    
                                       
                                       tempR=tempR−Rs
                                    
                                 
                                 
                                    
                                       
                                       tempC=tempC−Cs
                                    
                                 
                                 
                                    
                                       
                                       % or alternatively:
                                 
                                 
                                    
                                       
                                       % D(r,c)=0, ∀ r∊tempR, c∊tempC
                                 
                                 
                                    
                                       
                                       return S(Rs,Cs)
                                 
                                 
                                    }
                                 
                              
                           
                        
                     
                  

The apply_biclustering (D(R,
                     C)) procedure returns a bicluster at a time. Then, it transforms the input data matrix either by removing its rows and columns included in the extracted bicluster or by substituting its cell values included in the extracted bicluster with 0. Obviously, the apply_biclustering() procedure converges, since at any iteration the extracted bicluster is removed from the initial input data matrix.

Then, a selection process is applied in order to extract the final machine cells and part families.

The larger biclusters are extracted (S(Rs
                     ,
                     Cs
                     )=
                     T(Rt
                     ,
                     Ct
                     )∊
                     B in line 3) first by calculating their area (|Rs|
                     *
                     |Cs| in line 3). A bicluster is extracted (line 6) if it does not overlap across rows with a previous extracted bicluster (Rs
                     
                     ⊆
                     R in line 3 and line 5). Moreover, a submatrix of an extracted bicluster could be selected if it is larger than the next larger extracted bicluster (S(Rs
                     ,
                     Cs
                     )⊂
                     T(Rt
                     ,
                     Ct
                     )∊
                     B in line 3). This is the case where the next larger bicluster overlaps across rows with a previous extracted bicluster. If we omit the common rows and the remaining submatrix is still the next larger bicluster, then it is selected.

Note that the nature of biclustering algorithms guarantee that the extracted biclusters do not include voids. Thus, the proposed technique then tries to merge biclusters and include exceptional elements aiming at minimum sum of intra-cell voids and inter-cell moves (lines 7 and 9). This process will be described after presenting some definitions.
                        Lemma 1
                        
                           The assignment of an exceptional element aij
                           
                           ∊
                           D(R,C) to a bicluster S(Rs,Cs) increase its voids to:
                        


                           
                              
                                 (|Rs
                                    |−x) if i
                                    ∊
                                    Rs
                                    
                                    ∧
                                    j
                                    ∉
                                    Cs
                                    
                                 

(|Cs
                                    |−
                                    y) if i
                                    ∉
                                    Rs
                                    
                                    ∧
                                    j
                                    ∊
                                    Cs
                                    
                                 

(|Rs
                                    |+|Cs
                                    |−
                                    z) if i
                                    ∉
                                    Rs
                                    
                                    ∧
                                    j
                                    ∉
                                    Cs
                                    
                                 


                           Merging two biclusters S(Rs,Cs) and T(Rt,Ct) into one leads to at most |Cs
                              −Ct|
                              *
                              |Rt
                              −Rs|+|Ct
                              −Cs|
                              *
                              |Rs
                              −Rt| more intra-cell voids and to at least |Cs
                              ∩Ct|
                              *
                              |Rs
                              ∪Rt| less inter-cell moves. Also, splitting one bicluster into two S(Rs,Cs) and T(Rt,Ct) leads to at most |Cs
                              −Ct|
                              *
                              |Rt
                              −Rs|+|Ct
                              −Cs|
                              *
                              |Rs
                              −Rt| less intra-cell voids and to at least |Cs
                              ∩Ct|
                              *
                              |Rs
                              ∪Rt| more inter-cell moves. Note that we consider the worst case scenario, where each time a part ci
                              ∊Cs (cj
                              ∊Ct) needs a machine ri
                              ∊Rt (rj
                              ∊Rs) it has to be moved to machine cell Rt (Rs) and then it moves back after processing. Also, note that, after merging, some previously exceptional elements could be included in the new bicluster and thus intra-cell voids could be less than |Cs
                              −Ct|
                              *
                              |Rt
                              −Rs|+|Ct
                              −Cs|
                              *
                              |Rs
                              −Rt| and avoided inter-cell moves could be more than |Cs
                              ∩Ct|
                              *
                              |Rs
                              ∪Rt|. A similar note holds for splitting.
                        


                           It is possible to reduce the sum of intra-cell voids and inter-cell moves VE by merging two extracted biclusters temp(Rs,Cs), T(Rt,Ct)∊List.
                        

Note that by Lemma 2, before merging VE
                           =
                           c
                           +|Cs
                           
                           ∩
                           Ct
                           |
                           *
                           |Rs
                           
                           ∪
                           Rt
                           |=
                           c
                           +|Cs
                           
                           ∩
                           Ct
                           |
                           *
                           (|Rs
                           |+|Rt
                           |), (since there are zero voids) while after merging VE
                           =
                           c
                           +|Cs
                           
                           −
                           Ct
                           |
                           *
                           |Rt
                           
                           −
                           Rs
                           |+|Ct
                           
                           −
                           Cs
                           |
                           *
                           |Rs
                           
                           −
                           Rt
                           |=
                           c
                           +|Cs
                           
                           −
                           Ct
                           |
                           *
                           |Rt
                           |+|Ct
                           
                           −
                           Cs
                           |
                           *
                           |Rs
                           |, where c is the sum of intra-cell voids and inter-cell moves concerning the rest of extracted biclusters. Then, ∃Rs
                           , Cs
                           , Rt
                           , Ct
                            such that: c
                           +|Cs
                           
                           ∩
                           Ct
                           |
                           *
                           (|Rs
                           |+|Rt
                           |)>
                           c
                           +|Cs
                           
                           −
                           Ct
                           |
                           *
                           |Rt
                           |+|Ct
                           
                           −
                           Cs
                           |
                           *
                           |Rs
                           |⇒|Cs
                           
                           ∩
                           Ct
                           |
                           *
                           (|Rs
                           |+|Rt
                           |)>|Cs
                           
                           −
                           Ct
                           |
                           *
                           |Rt
                           |+|Ct
                           
                           −
                           Cs
                           |
                           *
                           |Rs
                           |⇒|Cs
                           
                           ∩
                           Ct
                           |
                           *
                           (|Rs
                           |+|Rt
                           |)>|Cs
                           
                           −
                           Cs
                           
                           ∩
                           Ct
                           |
                           *
                           |Rt
                           |+|Ct
                           
                           −
                           Cs
                           
                           ∩
                           Ct
                           |
                           *
                           |Rs
                           |⇒|Cs
                           
                           ∩
                           Ct
                           |
                           *
                           (|Rs
                           |+|Rt
                           |)>(|Cs
                           |−|Cs
                           
                           ∩
                           Ct
                           |)
                           *
                           |Rt
                           |+(|Ct
                           |−|Cs
                           
                           ∩
                           Ct
                           |)
                           *
                           |Rs
                           |⇒|Cs
                           
                           ∩
                           Ct
                           |
                           *
                           (|Rs
                           |+|Rt
                           |)>|Cs
                           |
                           *
                           |Rt
                           |−|Cs
                           
                           ∩
                           Ct
                           |)
                           *
                           |Rt
                           |+|Ct
                           |
                           *
                           |Rs
                           |−|Cs
                           
                           ∩
                           Ct
                           |
                           *
                           |Rs
                           |⇒2|Cs
                           
                           ∩
                           Ct
                           |
                           *
                           (|Rs
                           |+|Rt
                           |)>|Cs
                           |
                           *
                           |Rt
                           |+|Ct
                           |
                           *
                           |Rs
                           | [1].

More specifically, [1] is true if double the number of common columns of the two biclusters is larger than the number of columns of the wider bicluster, which is obviously possible. Since, in the latter case: 2|Cs
                           
                           ∩
                           Ct
                           |>max(|Cs
                           |,|Ct
                           |)⇒2|Cs
                           
                           ∩
                           Ct
                           |
                           *
                           (|Rs
                           |+|Rt
                           |)>max(|Cs
                           |,|Ct
                           |)
                           *
                           (|Rs
                           |+|Rt
                           |)⇒2|Cs
                           
                           ∩
                           Ct
                           |
                           *
                           (|Rs
                           |+|Rt
                           |)>|Cs
                           |
                           *
                           |Rt
                           |+|Ct
                           |
                           *
                           |Rs
                           |.

Note that we considered that ∃Q(Rq
                           ,
                           Cq
                           ) such that Cq
                           
                           ∩
                           Cs
                           
                           ∩
                           Ct
                           
                           
                           ≠
                           ∅. In this case VE is even smaller due to even less inter-cell moves, since |Cq
                           
                           ∩
                           Cs
                           
                           ∩
                           Ct| parts should be moved both to temp(Rs
                           ,
                           Cs
                           ) and T(Rt
                           ,
                           Ct
                           ). Thus, clearly, the above result holds even if we consider that ∃Q(Rq
                           ,
                           Cq
                           ) such that Cq
                           
                           ∩
                           Cs
                           
                           ∩
                           Ct
                           
                           
                           ≠
                           ∅.□


                           The proposed technique is optimum concerning the minimum sum of intra-cell voids and inter-cell moves VE, with respect to the set of extracted biclusters.
                        

We prove the latter by cases. Note that since all the extracted biclusters have exclusive rows, Rs
                           
                           ∩
                           Rt
                           
                           =∅, ∀temp(Rs
                           ,
                           Cs
                           ), T(Rt,Ct
                           )∊
                           List. Suppose that a bicluster temp(Rs
                           ,
                           Cs
                           ) is extracted during an iteration in the loop at line 2. (I) Clearly, ∃T(Rt
                           ,
                           Ct
                           ), where Cs
                           
                           ≡
                           Ct
                           , since the two biclusters would form a larger one and thus temp(Rs
                           ,
                           Cs
                           ) would not be the larger maximal. (II) Suppose that we select (line 6) a non larger or non maximal extracted bicluster T(Rt
                           ,
                           Ct
                           ), instead of the larger maximal temp(Rs
                           ,
                           Cs
                           ). Clearly, ∃ri
                           
                           ∊
                           Rs
                           
                           ∧
                           ri
                           
                           ∉
                           Rt
                           
                           ∨
                           ci
                           
                           ∊
                           Cs
                           
                           ∧
                           ci
                           
                           ∉
                           Ct
                           . (IIa) all amn
                           ,(m
                           =
                           ri
                           
                           ∧
                           n
                           ∊
                           Cs
                           )∨(n
                           =
                           ci
                           
                           ∧
                           m
                           ∊
                           Rs
                           ) become exceptional elements; then inter-cell moves increase and thus VE increases, since still there are no voids. (IIb) ci
                            is assigned to another selected extracted bicluster Q(Rq
                           ,
                           Cq
                           ); this is a contradiction since Rq
                           
                           ∩
                           Rs
                           
                           =∅ must hold. (IIb) ri
                            is assigned to another selected extracted bicluster Q(Rq
                           ,
                           Cq
                           ); this is a contradiction if Q(Rq
                           ,
                           Cq
                           ) is larger than temp(Rs
                           ,
                           Cs
                           ) since then Q(Rq
                           ,
                           Cq
                           ) would not be selected earlier as a larger maximal. The assumption it is only true if Q(Rq
                           ,
                           Cq
                           ) is smaller than temp(Rs
                           ,
                           Cs
                           ) and thus Cq
                           
                           ⊂
                           Cs
                           . In this case, the inter-cell moves increase since Cs
                            parts must additionally be moved to Q(Rq
                           ,
                           Cq
                           ) while Cq
                           
                           <
                           Cs
                            need not be moved to temp(Rs
                           ,
                           Cs
                           ). Moreover, at the same time Cs
                           
                           −
                           Cq
                            voids have to be added to Q(Rq
                           ,
                           Cq
                           ) and thus VE increases.□

After selecting the proper extracted biclusters, the proposed technique tries to minimize the sum of intra-cell voids and inter-cell moves by first merging them (lines 7 and 8 of PMG()), according to Lemmas 2 and 3, and then by assignment of exceptional elements to obtained biclusters. Note, that the proposed technique guarantees the optimal sum of intra-cell voids and inter-cell moves, with respect to the set of initial extracted biclusters (line 1 of PMG()). Thus, any biclustering algorithm accepting a binary input data matrix can be used; however the accuracy of the proposed technique is directly related with the accuracy of the biclustering algorithm.

The proposed technique supports different quality criteria. For instance, if lines 7–10 were omitted then the minimum number of intra-cell voids is adopted as a quality criterion. Other quality criteria could be also adopted by properly processing of initially extracted biclusters (line 1 of PMG()), which are considered as naturally occurring.

The time complexity of the proposed technique is calculated by taking into consideration the time complexity of extracting initial biclusters (line 1), selecting the proper biclusters (lines 2–6) and optimizing the quality criterion (lines 7–10). The time complexity of biclustering algorithms varies (Boutsinas, 2013) with respect to the adopted biclustering models. For instance, the time complexity of the Bimax algorithm (Prelić et al., 2006) is O(min{|R|,|C|}
                        *
                        |R|
                        *
                        |C|
                        *
                        
                        n), where n is the number of extracted inclusion-maximal biclusters, while the time complexity of the algorithm presented in Boutsinas (2013) is O(|R|
                        *
                        |C|
                        *
                        |C
                        1
                        ∪C2
                        ∪ ⋯ ∪
                        C
                        k|), where C
                        1⋯C
                        k are the examined sets of candidate frequent itemsets (which can be further reduced by using more efficient techniques as Han et al., 2004; Boutsinas et al., 2008).

The time complexity of selecting the proper biclusters is O(nlogn), where n is the number of extracted biclusters, since selection demands their ordering with respect to their size (line 3). Finally, the time complexity of optimizing the quality criterion is O(m
                        2), where m is the number of selected biclusters, since the reduction of the quality criterion has to be calculated for every pair of selected biclusters. Clearly, m
                        ≪
                        |R|,
                        |C|. Thus, the complexity of the proposed technique is heavily dominated by the time complexity of the biclustering algorithm.

On the other hand, theoretically, the time complexity of only the best proposed CF procedures is of the same order with the proposed technique. For instance, the time complexity of propagating the input vector to the recognition layer and selecting a category in the standard Fuzzy ART algorithm is O(NM) in the best case and O(N
                        2
                        +
                        NM) in the worst case (Burwick and Joublin, 1998), where M is the number of dimensions of the input vectors and N is the number of categories. Thus, for the PMG problem (forming the machine cells and then assign parts), the time complexity is O(m|C|) in the best case and O(m
                        2
                        +
                        m|C|) in the worst case, where m is the number of machine cells. Of course, using the non-recursive implementation proposed in Burwick and Joublin (1998), i.e. testing the vigilance first, the complexity is O(m|C|) in the worst case. Also, it is noted (Burwick and Joublin, 1998) that using a qsort sorting algorithm, the complexity could be O(mlogm
                        +
                        m|C|), which is a lower complexity only if m is larger than some hundred.

However, when forming the part families (or the machine cells) first and then assign machines (or parts), the complexity of the assignment process should be also considered. For example, the worst case time complexity of the minimum cost flow model used in Dobado et al. (2002) is in the order of the complexity of linear programming, since the model is actually a simple linear programming model which has a network flow structure. Note that practical general-purpose methods (e.g. variants of Simplex) has an O(min(|R|
                        2,
                        |C|
                        2)) time complexity, although theoretically it was shown that exponential cases exist within the class of network problems (Megiddo, 1987). Even if specially structured minimum cost flow models are considered (Vaidyanathan and Ahuja, 2010), the complexity is O(m
                        +
                        |R|), where m is the number of machine cells. As another example, the worst case time complexity of the assignment procedure used in Rajagopalan and Batra (1975), Won and Currie (2007) and Yang and Yang (2008) is O(|R||C|), since for every machine (part) it has to process the parts (machines) of every part family (machine cell). Note that in Won and Currie (2007) an extra reassignment phase follows the first assignment, whose complexity must also be considered.

Finally, note that both the Fuzzy ART network and the proposed technique outperform the traditional CF procedures which form part families and machine cells simultaneously. For instance, the time complexity of the Direct Clustering Algorithm – DCA (Chan and Milner, 1982) and the Rank Order Clustering – ROC2 (King and Nakornchai, 1982) is O(|R||C|2
                        +|R|2|C|).

We performed empirical tests in order to confirm the above theoretical results concerning the efficiency and accuracy of the proposed technique. In order to obtain comparable to those of similar methods results, we select PMIMs used as test data sets in the literature. We also evaluate the accuracy of the proposed technique adopting widely used performance measures (Sarker, 2001). The most widely used such measure is “grouping efficiency”: η
                     =
                     qη
                     1
                     +(1−
                     q)η2
                      (Chandrasekaran and Rajagopalan, 1986a), where η
                     1
                     =(o
                     −
                     e)/(o
                     −
                     e
                     +
                     v) and η
                     2
                     =(mp
                     −
                     o
                     −
                     v)/(mp
                     −
                     o
                     −
                     v
                     +
                     e), 0⩽
                     q
                     ⩽
                     1 (q
                     =0.5 is generally suggested), and m is the number of machines, p is the number of parts, o is the number of 1s in the PMIM, e number of exceptional elements, v is the number of voids (adopting the representation used in Yang and Yang (2008)). We also use “grouping efficacy” (Kumar and Chandrasekharan, 1990): τ
                     =(o
                     −
                     e)/(o
                     +
                     v), “grouping measure” (Miltenburg and Zhang, 1991): ηg
                     
                     =(o
                     −
                     e)/(o
                     −
                     e
                     +
                     v)−(e/o) and “Bond energy” (McCormick et al., 1972):
                        
                           
                              BE
                              =
                              1
                              /
                              2
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                    
                                 
                              
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       j
                                    
                                 
                              
                              
                                 
                                    a
                                 
                                 
                                    ij
                                 
                              
                              (
                              
                                 
                                    a
                                 
                                 
                                    ij
                                    -
                                    1
                                 
                              
                              +
                              
                                 
                                    a
                                 
                                 
                                    ij
                                    +
                                    1
                                 
                              
                              +
                              
                                 
                                    a
                                 
                                 
                                    i
                                    -
                                    1
                                    j
                                 
                              
                              +
                              
                                 
                                    a
                                 
                                 
                                    i
                                    +
                                    1
                                    j
                                 
                              
                              )
                              .
                           
                        
                     
                  

The bond energy (BE) measure is to maximize the number of elements having a value of 1 close to each other. The higher the value of BE, the better the solution. However, it is not a good measure since it is sensitive to the relative positioning of rows and columns of the PMIM, i.e., a different arrangement of rows and columns may give different values of the measure (Kusiak and Chung,1991). For the experimental tests we performed, we calculate BE considering that rows and columns of each extracted bicluster are adjacent in the PMIM, while the order of rest rows and columns is the same with the initial PMIM.

Moreover, we use “Rank Index” (Kaparthi and Suresh, 1994) which actually measures the degree of similarity between the extracted biclusters and the biclusters implanted in synthetic PMIMs. It is calculated by checking every possible pair of parts (or machines) in order to see whether it belongs to the same implanted and extracted bicluster: 
                        
                           RI
                           =
                           (
                           s
                           +
                           d
                           )
                           /
                           (
                           (
                           
                              
                                 
                                    p
                                 
                              
                              
                                 
                                    2
                                 
                              
                           
                           )
                           
                           (
                           or
                           
                           (
                           s
                           +
                           d
                           )
                           /
                           (
                           
                              
                                 
                                    m
                                 
                              
                              
                                 
                                    2
                                 
                              
                           
                           )
                        
                     ), s is the number of pairs belonging in the same implanted and same extracted biclusters and d the number of pairs belonging in different implanted and different extracted biclusters.Another such measure is presented in Prelić et al. (2006) for DNA microarray data. It is based on a match score of rows and columns. The match score of two set of rows R
                     1, R
                     2 is given by the function: Sr(R
                     1,
                     R
                     2)=
                     |R
                     1
                     ∩
                     R
                     2
                     |/|R
                     1
                     ∪
                     R
                     2|, which characterizes the correspondence between them. Similarly, the match score of two set of columns C
                     1, C
                     2 is given by the function: Sc
                     (C
                     1,
                     C
                     2)=|C
                     1
                     ∩
                     C
                     2
                     |/|C
                     1
                     ∪
                     C
                     2|. The match score of a set of biclusters M
                     1 with respect to a set of biclusters M
                     2 is given by the function S
                     
                     *
                     (M
                     1,
                     M
                     2)=
                     SQUARE-ROOT((Σ
                     (
                     
                        R
                     
                     1
                     
                        ,C
                     
                     1)∊
                        M
                     
                     1
                     max
                     (
                     
                        R
                     
                     2
                     
                        ,C
                     
                     2)∊
                        M
                     
                     2 
                     Sr
                     (R
                     1,R
                     2))
                     *
                     (Σ
                     (
                     
                        R1,C1
                     
                     )∊
                        M
                     
                     1
                     max
                     (
                     
                        R
                     
                     2,
                     
                        C
                     
                     2)∊
                        M
                     
                     2
                     Sc
                     (C
                     1,C
                     2)))/|M
                     1|, which reflects the average of the maximum match scores for all biclusters in M
                     1 with respect to the biclusters in M
                     2. If M
                     2 denotes the set of implanted biclusters and M
                     1 the output of a biclustering algorithm S
                     
                     *
                     (M
                     1,
                     M
                     2) reflects to what extent the extracted biclusters represent true biclusters, and S
                     *(M
                     2,
                     M
                     1) quantifies how well each of the true biclusters is recovered by the extracted biclusters. Both scores take the maximum value of 1, if M
                     1
                     =
                     M
                     2.

Based on the above measures, to demonstrate the efficiency of the proposed technique with respect to related ones, we adopt the binary test data sets available in the open literature. These data sets, along with the scientific papers in which they have used as benchmarks, are shown in Table 1
                     .

The results are shown in Table 2
                      using the biclustering algorithm proposed in Boutsinas (2013), setting minimum support to 2% and 7% for extracting closed frequent itemsets. A frequent itemset is called closed if no superset has the same support. Results are similar using maximal itemsets, if there is no noise. A frequent itemset is called maximal if no superset is frequent, that is, has a support exceeding the minimum support. Maximizing the number of columns is efficient in the absence of noise. However, the structure of maximal biclusters is destroyed by noise. In this case, one has to maximize both columns and rows for better results. Filtering only the frequent itemsets can handle noisy data more efficiently.

Minimum support threshold is not so critical. In most of the experimental tests we performed, results are similar for values between 1% and 15%. In some cases, an increase of the minimum support threshold results in an increase of some measures and a decrease in some others. However, in special PMIM structures, as those with a great number of 1s, extracted closed frequent itemset results in biclusters with extremely small number of rows (1 or 2). In such cases, the minimum support threshold should be increaced for better results in some measures. For instance, this is the case of the sixth test data set. Setting minimum support to 30% grouping efficiency is increased (η
                     =0.781, τ
                     =0.527, ηg
                     
                     =0.484, BE
                     =69). As mentioned in the previous section, the minimum support threshold affects the runtime of the algorithm, since lower values result in processing more candidate itemsets. Thus, the algorithm is more efficient by filtering only the closed or the maximal frequent itemsets.

We used Borgelt’s implementation of Apriori algorithm (http://www.borgelt.net//software.html) used in the algorithm proposed in Boutsinas, 2013, setting the argument “-tc” in order to extract only the closed frequent itemsets. In general, one can use visualization and other advanced accessing techniques in order to process the extracted biclusters (Boutsinas, 2002).

The proposed technique is designed to extract non overlapped machine cells. However, part families can overlap. Practically, this means that a user can choose to assign common parts to anyone of the families they belong. But, performance measures are decreased, since exceptional elements and/or voids are processed more than once. If a conflict strategy were adopted extracting non overlapped part families, performance results would be better. For instance, performance results for 3_1 test data set, after eliminating overlaps, are (η
                     =0.830, τ
                     =0.700, ηg
                     
                     =0.653, BE
                     =16).

Despite such special settings, from Table 2 it seems that the proposed technique outperforms similar algorithms in most of the test cases, where the best observed, to our knowledge, in the literature results are shown. Note that under properly defined settings, the proposed technique outperforms similar algorithms in almost all the test cases.

Moreover, we performed empirical test using synthetic binary PMIMs with implanted biclusters, i.e. machine cells and the associated part families, as e.g. in Onwubolu and Mutingi (2001) or Kaparthi and Suresh (1994), where a binary block diagonalized PMIM is randomly generated in which then a predetermined degree of imperfection is added. The degree of imperfection was specified by (a) the ratio of’ the number of voids to the number of 1s (v/o) and (b) the ratio of the number of exceptional elements to the number of 1s (e/o). The obtained synthetic PMIM was randomly perturbed before use. Thus, the optimum solution is known a priori for each synthetic PMIM, (shown in Table 3
                     ). The results are shown in Table 4
                     ; the proposed technique recovered almost the optimum solution for all the synthetic PMIMs.

Note that most of the proposed CF procedures are known to be sensitive to the order in which the data is presented, thus the random perturbation is needed for comparative tests. However, many biclustering algorithms, including the one used in these tests, are not sensitive at all. Thus, a random perturbation was not necessary to be applied.

All the above experiments run on an Intel(R) Core(TM)2 Duo CPU 2.53gigahertz system with 4gigabytes RAM. All experiments ran for less than 2seconds (most of them less than 1second). An implementation of the proposed technique (BIBCE) is freely available for download at: http://150.140.136.40/lab/images/stories/uploads/files/BIBCE.rar.

@&#DISCUSSION AND CONCLUSION@&#

We proposed a new methodology for the PMG problem, which is based on applying biclustering algorithms to PMIMs in order to cluster machines and parts simultaneously. The extracted maximal biclusters are further processed in order to obtain the final machine cells and the associated part families.

Depending on the adopted biclustering algorithm, the proposed technique cannot be sensitive to the order in which the data is presented and it does not need any parameter setting phase. Also, the presented experimental results demonstrate the accuracy and efficiency of the proposed technique with respect to related ones.

Biclustering has been used in other research areas, and this paper shows how it is a useful technique in a specific type of the PMG problem that accepts as input a binary part–machine incidence matrix. However, it seems that biclustering can be efficiently applied to solve different machine-part cell formation problems with different considerations and thus it can considerably contribute to the cell-formation body of knowledge. The latter seems to be an important result of the presented in this paper research.

In a binary PMG problem, parts, that have similar operations and require a similar set of machines for the completion of those operations, are grouped into families. In the real world, the machine-part cell formation problems are more complicated. For instance, the operation sequences of parts including multiple visits to the same machine and/or availability of identical machines and/or the processing times and/or the production volumes of parts have to be considered, (e.g. Defersha and Chen, 2008; Nsakanda et al., 2006; Won and Currie, 2007; Xambre and Vilarinho, 2003).

Considering processing times for example, note that the grouping objective is not to simply maximize the similarity but also to maximize the machine utilization, the work load balancing, etc. It seems that biclustering can be efficiently applied to solve such formations. For instance, the maximization of machine utilization is reduced to the maximization of total in-cell processing time and the minimization of total out-cell processing time. It is obvious that a straightforward solution is to select from the set of extracted biclusters the larger ones having also the maximal sum of processing times. To test such solution, we applied a slightly modified version of the proposed technique to the test problems presented in Zolfaghari and Liang (2003), where processing times are explicitly considered in the PMG problem. More specifically, we simply modified line 3 of the PMG(), so that to select the larger biclusters with maximum total processing time:
                        
                           
                              3
                              temp
                              (
                              
                                 
                                    R
                                 
                                 
                                    s
                                 
                              
                              ,
                              
                                 
                                    C
                                 
                                 
                                    s
                                 
                              
                              )
                              =
                              
                                 
                                    
                                       max
                                    
                                    
                                       S
                                       (
                                       
                                          
                                             R
                                          
                                          
                                             s
                                          
                                       
                                       ,
                                       
                                          
                                             C
                                          
                                          
                                             s
                                          
                                       
                                       )
                                       ⊆
                                       T
                                       (
                                       
                                          
                                             R
                                          
                                          
                                             t
                                          
                                       
                                       ,
                                       
                                          
                                             C
                                          
                                          
                                             t
                                          
                                       
                                       )
                                       ∈
                                       B
                                    
                                 
                              
                              |
                              
                                 
                                    R
                                 
                                 
                                    s
                                 
                              
                              |
                              *
                              |
                              
                                 
                                    C
                                 
                                 
                                    s
                                 
                              
                              |
                              *
                              (
                              Σ
                              
                                 
                                    a
                                 
                                 
                                    mn
                                 
                              
                              ∈
                              S
                              (
                              
                                 
                                    R
                                 
                                 
                                    s
                                 
                              
                              ,
                              
                                 
                                    C
                                 
                                 
                                    s
                                 
                              
                              )
                              )
                              ∧
                              
                                 
                                    R
                                 
                                 
                                    s
                                 
                              
                              ⊆
                              R
                              ;
                           
                        
                     
                  

Considering operation sequences as another example, note that an exceptional element can indicate more than one unit of inter-cell move depending on the sequence of operation. Thus, the grouping objective is to minimize inter-cell moves incurred by the amount of actual flows due to different operation sequences. It seems that biclustering can be also efficiently applied to solve such formations. For instance, note that if subsequent operations were performed in the same machine cell, then in the corresponding bicluster machines induce a co-regulated cell value of the parts and vice-versa, i.e. the cell values of all the rows (parts) in the bicluster move up (up-regulated) or down (down-regulated) together within the columns (machines) of the bicluster and vice-versa. In Bergmann et al. (2003), the ISA biclustering algorithm is presented which extracts biclusters where columns induce a co-regulated cell value of the rows and vice-versa.

To test the above approach, we applied a slightly modified version of the proposed technique to the test problem presented in Harhalakis et al. (1990), where sequence of operations are explicitly considered in the PMG problem. More specifically, we used the ISA biclustering algorithm, as it is implemented in BicAT V2.2 software tool (Barkow et al. 2006), to extract the biclusters during the first step (line 1) of PMG(). Also, we modified line 3 of the PMG(), so that to select the larger biclusters with the less empty cell values:
                        
                           
                              3
                              temp
                              (
                              
                                 
                                    R
                                 
                                 
                                    s
                                 
                              
                              ,
                              
                                 
                                    C
                                 
                                 
                                    s
                                 
                              
                              )
                              =
                              
                                 
                                    
                                       max
                                    
                                    
                                       S
                                       (
                                       
                                          
                                             R
                                          
                                          
                                             s
                                          
                                       
                                       ,
                                       
                                          
                                             C
                                          
                                          
                                             s
                                          
                                       
                                       )
                                       ⊆
                                       T
                                       (
                                       
                                          
                                             R
                                          
                                          
                                             t
                                          
                                       
                                       ,
                                       
                                          
                                             C
                                          
                                          
                                             t
                                          
                                       
                                       )
                                       ∈
                                       B
                                    
                                 
                              
                              |
                              
                                 
                                    R
                                 
                                 
                                    s
                                 
                              
                              |
                              *
                              |
                              
                                 
                                    C
                                 
                                 
                                    s
                                 
                              
                              |
                              *
                              |
                              
                                 
                                    a
                                 
                                 
                                    mn
                                 
                              
                              :
                              
                                 
                                    a
                                 
                                 
                                    mn
                                 
                              
                              ∈
                              S
                              (
                              
                                 
                                    R
                                 
                                 
                                    s
                                 
                              
                              ,
                              
                                 
                                    C
                                 
                                 
                                    s
                                 
                              
                              )
                              ∧
                              
                                 
                                    a
                                 
                                 
                                    mn
                                 
                              
                              >
                              0
                              |
                              ∧
                              
                                 
                                    R
                                 
                                 
                                    s
                                 
                              
                              ⊆
                              R
                              ;
                           
                        
                     
                  

The results are shown in Table 5
                     ; the proposed technique improves solutions of two out of three test problems in the case of involving processing times, while it achieves the same performance in the case of involving sequence of operations. Note however, that the proposed technique is designed for the binary PMG problem. For instance, the merging of biclusters is not optimized for the case of non-binary cell values. Thus, it seems that a properly elaborated extension of the proposed technique, which goes far beyond the scope of this paper, can be efficiently applied to various formations of the PMG problem. We are currently working on solving such different machine-part cell formation problems with different considerations by applying biclustering techniques.

@&#ACKNOWLEDGMENTS@&#

The author wish to thank G. Ravasopoulos and D. Katsantas, Ph.D. candidates, for their help during experimental tests. Also, the author is grateful to the anonymous referees for their valuable suggestions to improve the earlier version of this paper.

@&#REFERENCES@&#

