@&#MAIN-TITLE@&#An exact method for the biobjective shortest path problem for large-scale road networks

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Recursive exact algorithm that implicitly enumerates all solutions.


                        
                        
                           
                           Fast method that works well on graphs of up to 1.2 million nodes and 2.8 million arcs.


                        
                        
                           
                           Consistently outperformed a top-performer benchmark algorithm for real road networks.


                        
                        
                           
                           Easily extensible to the multiobjective shortest path problem with three or more objectives.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Routing

Multiobjective combinatorial optimization (MOCO)

Biobjective shortest path

Multiobjective shortest path

Pulse algorithm

@&#ABSTRACT@&#


               
               
                  The Biobjective Shortest Path Problem (BSP) is the problem of finding (one-to-one) paths from a start node to an end node, while simultaneously minimizing two (conflicting) objective functions. We present an exact recursive method based on implicit enumeration that aggressively prunes dominated solutions. Our approach compares favorably against a top-performer algorithm on two large testbeds from the literature and efficiently solves the BSP on large-scale networks with up to 1.2 million nodes and 2.8 million arcs. Additionally, we describe how the algorithm can be extended to handle more than two objectives and prove the concept on networks with up to 10 objectives.
               
            

@&#INTRODUCTION@&#

Consider a directed graph 
                        
                           G
                           =
                           (
                           N
                           ,
                           A
                           )
                        
                      where 
                        
                           N
                           =
                           {
                           
                              v
                              1
                           
                           ,
                           …
                           ,
                           
                              v
                              i
                           
                           ,
                           …
                           ,
                           
                              v
                              n
                           
                           }
                        
                      is the set of nodes and 
                        
                           A
                           =
                           {
                           
                              (
                              i
                              ,
                              j
                              )
                           
                           |
                           
                              v
                              i
                           
                           ∈
                           N
                           ,
                           
                              v
                              j
                           
                           ∈
                           N
                           }
                        
                      is the set of arcs. For all arcs 
                        
                           (
                           i
                           ,
                           j
                           )
                           ∈
                           A
                        
                      let there be two nonnegative weights denoted by cij
                      and tij
                     . Henceforth, and without loss of generality, we refer to cij
                      and tij
                      as the cost and time of traversing arc 
                        
                           (
                           i
                           ,
                           j
                           )
                           ∈
                           A
                           ,
                        
                      respectively. The Biobjective Shortest Path Problem (BSP) is the problem of finding paths 
                        P
                      from the start node 
                        
                           
                              v
                              s
                           
                           ∈
                           N
                        
                      to the end node 
                        
                           
                              v
                              e
                           
                           ∈
                           N
                        
                      that minimize two different (often conflicting) objective functions. The BSP can be formally defined as follows:

                        
                           (1)
                           
                              
                                 min
                                 
                                    
                                       z
                                    
                                    (
                                    
                                       x
                                    
                                    )
                                    =
                                    (
                                    c
                                    (
                                    
                                       x
                                    
                                    )
                                    ,
                                    t
                                    (
                                    
                                       x
                                    
                                    )
                                    )
                                 
                              
                           
                        
                     s.t.,

                        
                           (2)
                           
                              
                                 
                                    x
                                 
                                 ∈
                                 X
                              
                           
                        
                     where x is a path 
                        P
                      represented by a vector of (binary) arc flows xij
                     , 
                        
                           (
                           i
                           ,
                           j
                           )
                           ∈
                           A
                        
                     ; 
                        
                           c
                           
                              (
                              
                                 x
                              
                              )
                           
                           ≜
                           
                              ∑
                              
                                 (
                                 i
                                 ,
                                 j
                                 )
                                 ∈
                                 A
                              
                           
                           
                              
                                 c
                                 
                                    i
                                    j
                                 
                              
                              
                                 x
                                 
                                    i
                                    j
                                 
                              
                           
                        
                      is the cost of path x; 
                        
                           t
                           
                              (
                              
                                 x
                              
                              )
                           
                           ≜
                           
                              ∑
                              
                                 (
                                 i
                                 ,
                                 j
                                 )
                                 ∈
                                 A
                              
                           
                           
                              
                                 t
                                 
                                    i
                                    j
                                 
                              
                              
                                 x
                                 
                                    i
                                    j
                                 
                              
                           
                        
                      is the time of path x; and 
                        X
                      is the set of all paths from vs
                      to ve
                     . In (1) we (simultaneously) minimize the cost and time components of the vector function z(x). Since the existence of a path that simultaneously minimizes both objectives in (1) cannot be guaranteed, alternatively we seek for a set of paths with an acceptable tradeoff between the two objectives. Henceforth, we use functions c( · ) and t( · ) to represent the cost and time for complete solutions (i.e., a path 
                        P
                      from vs
                      to ve
                     ) or partial solutions (i.e., a path 
                        P
                      from vs
                      to a certain node vi
                     ), respectively.

This work aims to expand the body of knowledge of exact methods for the BSP. Our work shares its intuition with the pulse algorithm proposed by Lozano and Medaglia (2013) for the Constrained Shortest Path Problem (CSP), which has been successfully used as an algorithmic block for the multi-activity shift scheduling problem (Restrepo, Lozano, and Medaglia, 2012) and has been extended to the weight constrained shortest path problem with replenishment (Bolívar, Lozano, and Medaglia, 2014). To emphasize the fact that this work is an extension of a flexible solution framework, we purposely keep the pulse name in this paper.

The rest of the paper is organized as follows. Section 2 introduces relevant concepts for the BSP. Section 3 presents a literature review of the main solution strategies for the BSP. Section 4 introduces the pulse algorithm and the intuition behind it. Section 5 presents the core components of the algorithm. Section 6 compares the proposed algorithm against a top-performer algorithm by Raith (2010). Finally, Section 7 concludes the paper and outlines future work.

This section introduces relevant concepts related to the biobjective shortest path problem. Let us recall that 
                        X
                      is the set of all paths x from vs
                      to ve
                     . The image of any solution 
                        
                           
                              x
                           
                           ∈
                           X
                        
                      on the objective space 
                        Z
                      is a vector denoted by 
                        
                           
                              z
                           
                           (
                           
                              x
                           
                           )
                           =
                           (
                           c
                           (
                           
                              x
                           
                           )
                           ,
                           t
                           (
                           
                              x
                           
                           )
                           )
                           ∈
                           Z
                        
                      , where c(x) and t(x) are the values of each objective function (cost and time, respectively).

In the BSP, we look for a set of solutions that cannot improve one component of the objective vector z(x) without deteriorating the other one. These solutions are referred to as efficient solutions and are formally defined as follows:

                        Definition 2.1
                        A solution 
                              
                                 
                                    x
                                 
                                 ∈
                                 X
                              
                            is efficient if there does not exist another solution 
                              
                                 
                                    
                                       x
                                    
                                    ′
                                 
                                 ∈
                                 X
                              
                            such that c(x′) < c(x) and t(x′) ≤ t(x) or c(x′) ≤ c(x) and t(x′) < t(x).

Efficient solutions could be either supported or non-supported. Supported solutions correspond to the optimal solutions of the mono-objective shortest path problem defined by the following linear (convex) combination of the objectives:

                        
                           (3)
                           
                              
                                 
                                    min
                                    
                                       
                                          x
                                       
                                       ∈
                                       X
                                    
                                 
                                 
                                    
                                       λ
                                       c
                                    
                                    c
                                    
                                       (
                                       
                                          x
                                       
                                       )
                                    
                                    +
                                    
                                       λ
                                       t
                                    
                                    t
                                    
                                       (
                                       
                                          x
                                       
                                       )
                                    
                                 
                              
                           
                        
                     where (λc, λt
                     ) ∈ Λ are the weights given to the cost and time within the weight set Λ = {(λc, λt
                     ) ∈ ℜ2|λc
                      ≥ 0, λt
                      ≥ 0, λc
                      + λt
                      = 1}. On the other hand, efficient solutions which are non-supported cannot be obtained by solving a shortest path problem with a weighted sum of the objectives as in (3).

Similar to the efficiency concept defined over the solution space, any given solution has a corresponding vector (point) in the objective space 
                        Z
                      that can be either dominated or non-dominated. The following set of definitions clearly states the concepts of dominance and their relation with efficiency.

                        Definition 2.2
                        The image z(x) of an efficient solution x is said to be a non-dominated vector. If the solution is not efficient, then its image is a dominated vector in the objective space. The set of all non-dominated vectors is denoted by 
                              
                                 Z
                                 N
                              
                           .

Let 
                              
                                 
                                    x
                                 
                                 ,
                                 
                                    
                                       x
                                    
                                    ′
                                 
                                 ∈
                                 X
                              
                            be two solutions representing feasible paths. If c(x′) < c(x) and t(x′) ≤ t(x) or c(x′) ≤ c(x) and t(x′) < t(x), then z(x) is said to be dominated by z(x′), and it is denoted by z(x′)⪯z(x).

Let 
                              
                                 
                                    x
                                 
                                 ,
                                 
                                    
                                       x
                                    
                                    ′
                                 
                                 ∈
                                 X
                              
                            be two solutions representing feasible, but different paths (x′ ≠ x). If c(x′) = c(x) and t(x′) = t(x), then x′ and x are said to be alternative paths.

The set of all efficient solutions XE
                            is called the true efficient set. Given an algorithm, the set of efficient solutions discovered so far at any given iteration is called the online efficient set and it is denoted by 
                              
                                 
                                    X
                                    ^
                                 
                                 E
                              
                           . If the algorithm is exact, once it meets its stopping criterion, 
                              
                                 
                                    X
                                    ^
                                 
                                 E
                              
                            coincides with XE
                           . We also make the distinction between the online set of non-dominated vectors 
                              
                                 
                                    Z
                                    ^
                                 
                                 N
                              
                            and the true non-dominated set 
                              
                                 Z
                                 N
                              
                           .

@&#LITERATURE REVIEW@&#

The BSP arises naturally on multiple real applications. In telecommunications, Clímaco and Pascoal (2012) presented network routing problems where it is necessary to find paths that minimize the total number of links while simultaneously minimize the bandwidth consumption. Pallotino and Scutellà (1998) stated that transportation problems often offer a tradeoff between two or more objectives, e.g., minimizing the arrival time to a final destination and the cost of the path. Müller-Hannemann and Weihe (2006) reported a railway routing problem that faces a compromise between monetary cost and travel time. Ehrgott, Wang, Raith, and Van Houtte (2012) presented a biobjective cyclist route choice model in which bike routes are designed based on the travel time and a suitability weight associated with each arc. Erkut and Verter (1998) presented a real-world hazmat transportation application, where the conflicting objectives are the path risk (i.e., probability of an accident) and its associated cost. Aside from its direct application, the BSP arises as a subproblem of combinatorial optimization models (Skriver and Andersen, 2000). In all the cases cited above, it is necessary to find a set of solutions that takes into account more than one objective simultaneously, rather than to find a single solution that focuses on a single objective.

Aside from its practical relevance, the BSP is also a challenging problem that is NP-hard (Serafini, 1986). Even though several researchers have proposed different methods for solving the BSP, there are two major solution strategies for the BSP: dynamic programming (DP) and ranking.

In the DP category, there are label correcting and label setting methods. Hansen (1980) and Martins (1984) were among the first authors who proposed a labeling approach for the BSP. The label correcting method is a straightforward extension of the mono-objective version (cf. Bertsekas, 1998), but with several labels at each node (Raith and Ehrgott, 2009). To find the efficient set of solutions, each node stores labels that represent tentative efficient paths. At the beginning, only the start node vs
                      is labeled. All labels at each node are extended through all the outgoing arcs, setting new labels over target nodes. When the label set of a node changes, the node is marked for reconsideration. When a node is reconsidered, all the dominated labels are deleted and the rest are extended. When the reconsideration heap is empty the algorithm finishes. Skriver and Andersen (2000) presented a label correcting algorithm that employs a node selection criterion for the reconsideration heap. Other versions, as the one presented by Guerriero and Musmanno (2001), employ a label selection criterion for the reconsideration heap. The label setting method works in a similar fashion. These algorithms always employ a label selection criterion and the main difference with label correcting is that only the selected label is extended through all the arcs. Raith and Ehrgott (2009) implemented a label setting algorithm using a binary heap for the labels storage. In this algorithm, the smallest lexicographically ordered label is selected from all nodes to be extended at each iteration. The extended label is compared with the labels at the target node of each arc and dominated labels are deleted. Several speedup strategies for DP approaches have been developed recently. Raith (2010) proposed bounded label correcting and setting algorithms. These bounded versions use the labels at the end node for the dominance test at each node (in addition to the node’s own labels). Iori, Martello, and Pretolani (2010) presented a label setting policy that treats labels according to an aggregate function calculated for each label. Demeyer, Goedgebeur, Audenaert, Pickavet, and Demeester (2013) used the same idea of a bounded labeling algorithm (Raith, 2010) in a unidirectional/bidirectional label setting algorithm. The bidirectional DP extends labels forward from the start node and backward from the end node. When forward and backward labels reach the same node, the labels are combined and added into the online non-dominated set. Both searches are aborted as soon as the there are no forward nor backward labels dominating solutions of the online non-dominated set (i.e., there are no promising labels to extend). Even though Demeyer et al. (2013) reported speedups of the bidirectional DP over the unidirectional version on the common testbed instances used by Raith (2010) and Demeyer et al. (2013), computational times are better for the labeling approach of Raith (2010). Müller-Hannemann and Schnee (2007) and Disser, Müller-Hannemann, and Schnee (2008) also proposed speedup techniques for DP algorithms that exploit particular characteristics of time-dependent networks used in railroad routing.

In the ranking category, the near shortest path (NSP) method finds all the paths within a certain deviation from the shortest path length found by solving the weighted sum problem associated with the BSP. Carlyle and Wood (2005) presented a method that, besides its remarkable performance for solving the near shortest path problem, it outperforms other specialized algorithms solving the k-shortest path problem. Raith and Ehrgott (2009) compared different solution strategies including label setting and label correcting approaches, the near shortest path method, and a two-phase method based on the approach of Ulungu and Teghem (1995). The two-phase method by Raith and Ehrgott (2009) starts with an initialization procedure with the best solution for each single objective. In phase one, the algorithm focuses on supported efficient solutions; while in phase two, it finds the missing non-supported efficient solutions.

Aside from these methods, Geisberger, Kobitzsch, and Sanders (2010) proposed an algorithm that solves several mono-objective shortest path problems to compute supported efficient solutions. Recent research has focused on speedup techniques and preprocessing steps to accelerate mono-objective shortest path algorithms over large networks. A comprehensive survey of these advances is presented by Bast et al. (2014).

The BSP can be seen as a special case of the Multiobjective Shortest Path Problem (MSP); nevertheless, the BSP is by far, the most studied problem among MSPs (Chinchuluun and Pardalos, 2007). Martins (1984) presented one of the first label setting algorithms for the MSP. Later on, Carraway, Morin, and Moskowitz (1990) proposed a generalized DP approach for the MSP that includes probabilities on the objectives (i.e., the probability of successfully traversing the arc). Guerriero and Musmanno (2001) presented a labeling method that outperforms the one by Martins (1984) on networks with two, three, and four objectives. More recently, Paixão and Santos (2013) considered two labeling techniques on a large set of test problems with 6, 8, and 10 objectives. Although most algorithms for the BSP are extensible in theory to the general case, just few of them have been tested with more than two objectives (Chinchuluun and Pardalos, 2007). Aside from the implementation and computational challenges, the exponential growth of the efficient set might be the most significant hurdle to extend most of the current state-of-the-art algorithms for the MSP. Such large efficient sets (with an exponentially large number of efficient solutions) might turn out simply impossible to handle from a practical standpoint. Under a large-efficient set scenario, some algorithms tackle the MSP by finding a high-quality approximation of the efficient set with less computation effort (than that of an exact method). Along this line, multiobjective evolutionary algorithms (MOEAs, cf. Coello, Lamont, and Veldhuizen, 2007) have proven to be a valuable source to solve a wide range of multiobjective combinatorial problems (cf. Coello and Lamont, 2004). For a survey on multiobjective combinatorial optimization, the reader is referred to Ehrgott and Gandibleaux (2003).

The pulse algorithm gets its name from a very simple, yet insightful analogy. Given a network, the algorithm sends a pulse from the start node vs
                      to the end node ve
                     . This pulse travels through the entire network storing the partial path
                     
                        P
                      (an ordered sequence of visited nodes) and its cumulative objective functions, 
                        
                           c
                           (
                           P
                           )
                        
                      and 
                        
                           t
                           (
                           P
                           )
                        
                     . Every pulse that reaches the end node ve
                     , is a feasible solution that might be efficient. Once a pulse reaches the end node, it recursively backtracks to continue its propagation through the rest of the nodes in the search for more efficient paths from vs
                      to ve
                     . If the pulse is let free, this recursive algorithm resembles a complete enumeration of all possible paths, which guarantees that the efficient set is always found. However, the practical value of the algorithm relies on the fact that it stops the exploration of any partial path whenever there is enough information that shows that the path will not lead to an efficient solution. This look-ahead mechanism prunes aggressively vast regions of the solution space and ultimately accelerates the exploration of the network. Algorithm 1
                      presents a high-level pseudocode of the pulse algorithm. For the initialization procedure, we run a one-to-all mono-objective shortest path algorithm, but more details are deferred until Section 5.2.

To avoid a complete enumeration and to control the pulse propagation, we use a set of strategies that prunes pulses without cutting off any efficient solution. Every time that a pulse arrives to a node, the algorithm uses a battery of strategies to determine whether the partial path being explored should be propagated or not. Most importantly, pruning a partial path does not discard just one solution, but all the solutions that contain this partial path. Hence, aggressive and effective strategies transform an explicit enumeration into an efficient implicit enumeration. This idea shares the spirit of algorithms like branch-and-bound that also perform implicit enumerations. Note that the algorithm propagation follows a depth-first search truncated by particular pruning strategies.

In particular, for the BSP, we define four pruning strategies: cycles, nadir point, efficient set, and label. Algorithm 2
                      presents the pulse recursive function which receives as parameters the node being visited vi
                     , the cumulative cost 
                        
                           c
                           (
                           P
                           )
                           ,
                        
                      the cumulative time 
                        
                           t
                           (
                           P
                           )
                           ,
                        
                      and the partial path 
                        P
                     . Lines 1–4 of Algorithm 2 apply the different pruning strategies to the incoming pulse; if the pulse is not pruned, line 5 stores the current 
                        
                           c
                           (
                           P
                           )
                        
                      and 
                        
                           t
                           (
                           P
                           )
                        
                      while line 6 adds the node vi
                      to the partial path. In lines 7–11, the pulse propagates over all nodes vj
                      ∈ Γ
                     +(vi
                     ), where Γ
                     +(vi
                     ) is the set of outgoing neighbors of vi
                     , adding cij
                      to the cumulative cost and tij
                      to the cumulative time.

Every time the pulse function is invoked at the end node ve
                     , a partial path 
                        P
                      becomes a complete solution x and we update the online efficient set 
                        
                           
                              X
                              ^
                           
                           E
                        
                     . Note that the information about 
                        
                           
                              X
                              ^
                           
                           E
                        
                      has a global scope and it is not an attribute of the traveling pulse within the recursion. Algorithm 3
                      presents the pulse function when it is invoked over the end node ve
                     . Since a new solution has been found, the algorithm verifies if the new solution is efficient and updates the online efficient set accordingly.

At this point it is important to highlight the main differences between the pulse algorithm and traditional labeling algorithms. First, note that while labeling algorithms usually follow a breadth-first search, the pulse algorithm follows a depth-first search, increasing the chances of finding complete efficient solutions faster. Additionally, due to the recursive nature of the algorithm there is no need to explicitly store the state space (e.g., labels in a priority queue) as done in labeling algorithms. Finally, even though the pulse algorithm uses a label pruning strategy, these labels are never extended, nor the correctness of the algorithm depends on an exhaustive dominance test. In contrast to labeling approaches, this allows us to limit the number of labels stored at each node.

The performance of the pulse algorithm is tightly coupled to the pruning strategies defined for the problem at hand. This section explains the different strategies implemented for the BSP.

Because all weights on the arcs are nonnegative, any efficient solution cannot contain cycles. To avoid cycles in a path, every time we invoke the pulse function at node vi
                        , the algorithm checks a function that indicates whether a node has been visited or not. If node vi
                         lies already on the partial path, 
                           P
                         is pruned by cycles.

Let 
                           
                              
                                 x
                              
                              
                                 c
                              
                              *
                           
                         and 
                           
                              
                                 x
                              
                              
                                 t
                              
                              *
                           
                         be the optimal solutions for the mono-objective shortest path problem with the cost and time objectives, respectively. The images for the optimal solutions in the objective space are 
                           
                              
                                 z
                              
                              
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       c
                                    
                                    *
                                 
                                 )
                              
                              =
                              
                                 (
                                 
                                    T
                                    ¯
                                 
                                 ,
                                 
                                    C
                                    ̲
                                 
                                 )
                              
                           
                         and 
                           
                              
                                 z
                              
                              
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       t
                                    
                                    *
                                 
                                 )
                              
                              =
                              
                                 (
                                 
                                    T
                                    ̲
                                 
                                 ,
                                 
                                    C
                                    ¯
                                 
                                 )
                              
                           
                        . The nadir point, denoted by 
                           
                              
                                 
                                    z
                                 
                                 N
                              
                              =
                              
                                 (
                                 
                                    T
                                    ¯
                                 
                                 ,
                                 
                                    C
                                    ¯
                                 
                                 )
                              
                              ,
                           
                         is a vector in the objective space that establishes an upper bound for each objective. Under alternative optimal solutions for the mono-objective shortest path problem, 
                           
                              T
                              ¯
                           
                         and 
                           
                              C
                              ¯
                           
                         are the smallest values among all alternative solutions of 
                           
                              
                                 x
                              
                              
                                 c
                              
                              *
                           
                         and 
                           
                              
                                 
                                    x
                                 
                                 
                                    t
                                 
                                 *
                              
                              ,
                           
                         respectively. Fig. 1
                         shows the minimizer vectors 
                           
                              
                                 z
                              
                              (
                              
                                 
                                    x
                                 
                                 
                                    c
                                 
                                 *
                              
                              )
                           
                         and 
                           
                              
                                 z
                              
                              (
                              
                                 
                                    x
                                 
                                 
                                    t
                                 
                                 *
                              
                              )
                              ,
                           
                         and z
                        
                           N
                         in the objective space. Note that the nadir point can also be seen as the anti-ideal point in the objective space, whereas z* is the ideal point.


Consequently, for any solution x with 
                           
                              c
                              
                                 (
                                 
                                    x
                                 
                                 )
                              
                              >
                              
                                 C
                                 ¯
                              
                           
                         or 
                           
                              t
                              
                                 (
                                 
                                    x
                                 
                                 )
                              
                              >
                              
                                 T
                                 ¯
                              
                              ,
                           
                         its image z(x) is dominated and x is not efficient. Fig. 1 shows how any point that falls in the dark gray region (i.e., 
                           
                              c
                              
                                 (
                                 
                                    x
                                 
                                 )
                              
                              >
                              
                                 C
                                 ¯
                              
                           
                         or 
                           
                              t
                              
                                 (
                                 
                                    x
                                 
                                 )
                              
                              >
                              
                                 T
                                 ¯
                              
                           
                        ) is either dominated by 
                           
                              
                                 z
                              
                              (
                              
                                 
                                    x
                                 
                                 
                                    c
                                 
                                 *
                              
                              )
                           
                         or 
                           
                              
                                 z
                              
                              (
                              
                                 
                                    x
                                 
                                 
                                    t
                                 
                                 *
                              
                              )
                           
                        .

Based on this idea of the nadir point, the algorithm aims to prune as early as possible any pulse exceeding either 
                           
                              C
                              ¯
                           
                         or 
                           
                              T
                              ¯
                           
                        . To do so, we calculate the minimum cost (regardless of time) and the minimum time (regardless of cost) it takes from any node vi
                         to reach the end node ve
                        . These lower bounds are obtained by reversing the network (i.e., reversing the direction of every arc), thus creating a new directed graph 
                           
                              
                                 
                                    G
                                 
                                 ′
                              
                              =
                              
                                 (
                                 N
                                 ,
                                 
                                    A
                                    ′
                                 
                                 )
                              
                           
                         where 
                           
                              
                                 A
                                 ′
                              
                              =
                              
                                 {
                                 
                                    (
                                    j
                                    ,
                                    i
                                    )
                                 
                                 |
                                 
                                    (
                                    i
                                    ,
                                    j
                                    )
                                 
                                 ∈
                                 A
                                 }
                              
                           
                         and the weights 
                           
                              
                                 c
                                 
                                    j
                                    i
                                 
                                 ′
                              
                              =
                              
                                 c
                                 
                                    i
                                    j
                                 
                              
                           
                         and 
                           
                              
                                 t
                                 
                                    j
                                    i
                                 
                                 ′
                              
                              =
                              
                                 t
                                 
                                    i
                                    j
                                 
                              
                           
                         for 
                           
                              
                                 (
                                 j
                                 ,
                                 i
                                 )
                              
                              ∈
                              
                                 A
                                 ′
                              
                           
                        . The starting node in 
                           
                              
                                 G
                              
                              ′
                           
                         is the end node of the original network, 
                           
                              
                                 v
                                 s
                                 ′
                              
                              =
                              
                                 v
                                 e
                              
                           
                        . We run a one-to-all shortest path algorithm for each objective from 
                           
                              v
                              s
                              ′
                           
                         to all nodes. Using this procedure we obtain the minimum time 
                           t
                         (vi
                        ) and minimum cost 
                           c
                         (vi
                        ) from any node vi
                         to the end node ve
                         in the original network. Knowing these lower bounds, we determine the maximum values 
                           
                              
                                 t
                                 ¯
                              
                              
                                 (
                                 
                                    v
                                    i
                                 
                                 )
                              
                           
                         and 
                           
                              
                                 c
                                 ¯
                              
                              
                                 (
                                 
                                    v
                                    i
                                 
                                 )
                              
                           
                         that a partial path 
                           P
                         to node vi
                         can show upon arrival as 
                           
                              
                                 t
                                 ¯
                              
                              
                                 (
                                 
                                    v
                                    i
                                 
                                 )
                              
                              :
                              =
                              
                                 T
                                 ¯
                              
                              −
                              
                                 t
                                 ̲
                              
                              
                                 (
                                 
                                    v
                                    i
                                 
                                 )
                              
                           
                         and 
                           
                              
                                 c
                                 ¯
                              
                              
                                 (
                                 
                                    v
                                    i
                                 
                                 )
                              
                              :
                              =
                              
                                 C
                                 ¯
                              
                              −
                              
                                 c
                                 ̲
                              
                              
                                 (
                                 
                                    v
                                    i
                                 
                                 )
                              
                           
                         for the time and cost objectives, respectively. If any partial path 
                           P
                         to node vi
                         shows that 
                           
                              t
                              
                                 (
                                 P
                                 )
                              
                              >
                              
                                 t
                                 ¯
                              
                              
                                 (
                                 
                                    v
                                    i
                                 
                                 )
                              
                           
                         or 
                           
                              c
                              
                                 (
                                 P
                                 )
                              
                              >
                              
                                 c
                                 ¯
                              
                              
                                 (
                                 
                                    v
                                    i
                                 
                                 )
                              
                              ,
                           
                         then partial path 
                           P
                         can be safely pruned because it will surely exceed either one or both upper bounds defined by the nadir point before reaching (or at) the end node. The procedure for calculating 
                           
                              
                                 t
                                 ¯
                              
                              
                                 (
                                 
                                    v
                                    i
                                 
                                 )
                              
                           
                         and 
                           
                              
                                 c
                                 ¯
                              
                              
                                 (
                                 
                                    v
                                    i
                                 
                                 )
                              
                           
                         is done at the initialization phase of Algorithm 1 (see line 4). Algorithm 4
                         shows the nadir point verification procedure.

It is worth noting that Tung and Chew (1992) proposed similar preprocessing procedures to strengthen dominance tests in DP approaches. Also Machuca, Mandow, Pérez de la Cruz, and Ruiz-Sepulveda (2012) explored the usage of exact and heuristic dual (lower) bounds to improve computational efficiency of label setting algorithms.

Given that the algorithm uses implicit enumeration, the true efficient set is unveiled only at the end of the algorithm’s execution. However, the online efficient set obtained at intermediate stages of the algorithm is useful to prune partial paths whose images are dominated by solutions in this set. This idea has been explored by some authors in DP approaches. For instance, Tung and Chew (1992) used the labels stored at the end node (i.e., the online non-dominated set) and lower bounds to strengthen the dominance tests at each node. Müller-Hannemann and Schnee (2007) also used lower bounds to accelerate a DP algorithm in the context of railroad transportation. Raith (2010) and Demeyer et al. (2013) do not use lower bounds, but include the labels stored at the end node in the dominance tests for several variants of labeling algorithms.

Henceforth, we will refer to the efficient set as the online efficient set 
                           
                              
                                 X
                                 ^
                              
                              E
                           
                         that is updated as the algorithm finds new solutions. Fig. 2
                         shows a typical evolution of the efficient set as the algorithm progresses. After the initialization, the efficient set starts with two points (i.e., 
                           
                              
                                 z
                              
                              (
                              
                                 
                                    x
                                 
                                 
                                    c
                                 
                                 *
                              
                              )
                           
                         and 
                           
                              
                                 z
                              
                              (
                              
                                 
                                    x
                                 
                                 
                                    t
                                 
                                 *
                              
                              )
                           
                        ) and there is a large promising region, spanning from the ideal up to the nadir point, where efficient solutions can map their images (see Fig. 2(a)). As the algorithm evolves, new solutions in 
                           
                              
                                 X
                                 ^
                              
                              E
                           
                         enlarge the dominated region (white space). At any stage of the algorithm, a new solution is labeled efficient if its image is in the non-dominated (gray) region. We can safely prune a partial path, if its image—after completing the path with the optimistic bounds—falls outside of the promising (non-dominated) region.


Consider 
                           
                              
                                 X
                                 ^
                              
                              E
                           
                         at a given intermediate stage of the algorithm. We can determine whether a partial path has the potential to become an efficient solution (or not) using the same lower bounds calculated for the previous strategy, namely, 
                           t
                         (vi
                        ) for time and 
                           c
                         (vi
                        ) for cost. Given a partial path 
                           P
                         to node vi
                        , if there is a solution 
                           
                              
                                 x
                              
                              ∈
                              
                                 
                                    X
                                    ^
                                 
                                 E
                              
                           
                         such that 
                           
                              c
                              
                                 (
                                 P
                                 )
                              
                              +
                              
                                 c
                                 ̲
                              
                              
                                 (
                                 
                                    v
                                    i
                                 
                                 )
                              
                              ≥
                              c
                              
                                 (
                                 
                                    x
                                 
                                 )
                              
                           
                         and 
                           
                              t
                              
                                 (
                                 P
                                 )
                              
                              +
                              
                                 t
                                 ̲
                              
                              
                                 (
                                 
                                    v
                                    i
                                 
                                 )
                              
                              ≥
                              t
                              
                                 (
                                 
                                    x
                                 
                                 )
                              
                              ,
                           
                         we can safely prune partial path 
                           
                              P
                              ,
                           
                         because even if it spends both the minimum cost and the minimum time to reach the end node, it will still be dominated by x. Algorithm 5
                         shows the efficient set verification process.

To guarantee that we only store efficient solutions, whenever a partial path reaches the end node (becomes a solution x) the efficient set 
                           
                              
                                 X
                                 ^
                              
                              E
                           
                         is updated as follows: if z(x) is dominated, solution x is discarded; if z(x) is non-dominated, x is added to the efficient set 
                           
                              
                                 X
                                 ^
                              
                              E
                           
                         and any solution dominated by z(x) is deleted from the set. In the case where alternative efficient solutions share the same objective vector, the algorithm only records one solution per objective vector. Note that as the algorithm approaches to the true efficient set, this pruning strategy becomes stronger. Algorithm 6
                         shows the procedure to update the efficient set once a new efficient solution is found.

It is important to highlight that the efficient set also contains the best solutions for each objective. Since the nadir point falls into this category, pruning by efficient set is a more general strategy that includes the test performed in the nadir point strategy. However, from a computational point of view, it is better to consider these two as separate strategies because the nadir point strategy is a simple check that requires considerably less computational effort. Note that each time that a solution is pruned by the nadir point strategy, the algorithm avoids the inspection of an often large list of efficient solutions required by the efficient set pruning strategy.

We can use labels to prove dominance relations over partial paths (subpaths from vs
                         to any node vi
                        ) in the same way we prove dominance over complete solutions (see Definition 2.3). For each node vi
                        , we store a fixed number of labels. Each label saves a tuple of values associated with cost and time. The labels at node vi
                         are denoted by 
                           
                              L
                              
                                 (
                                 
                                    v
                                    i
                                 
                                 )
                              
                              =
                              
                                 {
                                 
                                    (
                                    
                                       c
                                       
                                          i
                                          l
                                       
                                    
                                    ,
                                    
                                       t
                                       
                                          i
                                          l
                                       
                                    
                                    )
                                 
                                 |
                                 l
                                 =
                                 1
                                 ,
                                 …
                                 ,
                                 Q
                                 }
                              
                           
                         where cil
                         and til
                         are the cumulative cost and time for a partial path to vi
                         and Q denotes the number of labels at vi
                        . For an incoming pulse, the algorithm checks if the incoming partial path 
                           P
                         is dominated or not; that is, if any label dominates 
                           
                              
                                 z
                              
                              (
                              P
                              )
                              ,
                           
                         the pulse is discarded by label pruning. Labels safely prune partial paths that may lead to inefficient paths, because any partial path within an efficient solution must be efficient too (cf. Proposition 9.4 and Corollary 9.5; Ehrgott, 2005). When a partial path 
                           P
                         is not pruned by any of the strategies, the algorithm stores the cumulative cost 
                           
                              c
                              (
                              P
                              )
                           
                         and cumulative time 
                           
                              t
                              (
                              P
                              )
                           
                         in an empty slot of 
                           
                              L
                              (
                              
                                 v
                                 i
                              
                              )
                           
                         following a lexicographical order. If there are no empty slots, it overwrites any (randomly selected) label except those with the minimum cost and time. Algorithm 7
                         shows the label verification process.

We compared the computational performance of the pulse algorithm against the bounded label setting (bLSET) algorithm by Raith (2010) which is among the best performers for the BSP on real road networks. We implemented both algorithms in Java and compiled them with Eclipse SDK version 4.3 on a Windows 7 computer with a 2.6 GHz Intel Core i5 2540M (2 cores) CPU and 6 GB of RAM allocated to the memory heap size of the Java Virtual Machine. The initialization procedure was parallelized taking into account that we perform two independent shortest path executions, one for each objective. We coded the Dijkstra’s algorithm using the double buckets implementation (DIKBD) presented by Cherkassky, Goldberg, and Radzik (1996) to solve the mono-objective shortest path problem. After fine tuning the algorithm, we fixed the maximum number of labels stored at each node to Q = 20. We sort the outgoing arcs of a node when we reach it for the first time based on the sum of both cost and time best bounds. All the execution times are reported in seconds and any run time that is less than 0.01 seconds appears in the tables as “ < 0.01”. We established a maximum running time of one hour.

For this first experiment, we used the road networks from Washington (DC), Rhode Island (RI), and New Jersey (NJ) presented by Raith and Ehrgott (2009). For each road network, there is a set of nine instances which only difference is the randomly selected pair of start and end nodes. These are instances that range from 9559 nodes and 39,377 arcs to 330,386 nodes and 1,200,458 arcs. Table 1
                         presents the computational results for this set of networks. Column 1 shows the instance name; columns 2 and 3 present the number of nodes and arcs, respectively; column 4 shows the size of the non-dominated set; columns 5 and 6 show the computational time for our implementations of the bLSET and pulse algorithms (including the initialization time), respectively; and finally, column 7 shows the speedup calculated as the bLSET computational time over the pulse time. Times in bold highlight the faster algorithm.

Over these networks, the pulse algorithm outperforms the bLSET algorithm in 24 out of 27 instances, showing computational times consistently under 0.23 seconds in contrast to the bLSET algorithm that takes up to 34.6 seconds in NJ9, one of the largest instances in this testbed. For the DC instances, the pulse time remains under 0.005 seconds on seven out of the nine instances. In the larger RI instances, the pulse algorithm outperforms bLSET in all instances, achieving an average speedup of 37. Likewise, in the largest NJ instances the pulse algorithm outperforms bLSET in all instances, showing an average speedup of 57 times and achieving speedups of up to 150 times faster than the benchmark. Using the more conservative geometric mean (Bixby, 2002), the pulse is about 4, 24, and 19 times faster for DC, RI, and NJ instances, respectively. Note that it is on the larger instances where the pulse achieves the larger speedups.

To better assess the scalability of the pulse algorithm, we conducted a second experiment on very large-scale read road networks that are significantly larger than those in the testbed by Raith and Ehrgott (2009). For this experiment, we use networks presented in the 9th DIMACS challenge (Demetrescu, Goldberg, and Johnson, 2006), namely, those representing New York City (NY), San Francisco Bay Area (BAY), Colorado (COL), Florida (FLA), and Northwest USA (NW). These networks range from 264,346 nodes and 733,846 arcs to 1,207,945 nodes and 2,840,208 arcs. The objectives considered for these networks correspond to the physical distance and transit time between nodes. Full datasets are available at http://www.dis.uniroma1.it/challenge9/download.shtml. For each of the five networks, we generated 30 random pairs of start and end nodes for a total of 150 instances. For each instance, we verified that either bLSET or pulse were able to solve it to optimality within 3600 seconds. Additionally, we categorized the 30 instances generated from each network into three clusters according to the size of the non-dominated set. To do so, we sorted the instances in increasing order and allocated the first 10 instances into the small cluster (S), the next 10 into the medium cluster (M), and the remaining 10 into the large cluster (L).


                        Table 2
                         presents the computational results for this experiment. Column 1 presents the cluster’s name; column 2 presents the number of instances in the corresponding cluster; columns 3 and 4 show the number of nodes and arcs in the network, respectively; column 5 presents the average size of the non-dominated set; columns 6 and 7 show the average computational time and the number of instances solved to optimality using the bLSET algorithm; columns 8 and 9 show the same performance metrics for the pulse algorithm; column 10 shows the geometric mean of the individual speedups for the 30 instances of each network; and finally, column 11 shows the number of times that the pulse algorithm outperformed bLSET on each cluster. As for the initialization procedure, it is worth mentioning that it never spent more than 0.36 seconds, which for most of the cases is a negligible time.

Over these very-large instances, the pulse algorithm outperforms bLSET on 123 out of 150 instances, showing average speedups that range from 4.28 to 45.89 according to the geometric mean. Note that for the largest instances, the pulse algorithm achieves larger speedups and outperforms the bLSET algorithm in more cases. The pulse algorithm found the true efficient set on 144 out of 150 instances while bLSET found the true efficient set on 139 out of 150 instances. Moreover, on the six instances that the pulse algorithm missed the true efficient set, it was able to provide an approximation. On the other hand, bLSET was not able to solve 11 instances to optimality and it failed to provide any approximation of the true efficient set in 3600 seconds, meaning that no label ever reached the end node within the time limit. The quality of the approximation provided by the pulse algorithm is discussed in detail in Section 6.3.

This section presents an introspective assessment of the pulse algorithm. First, we use a solution quality metric to analyze the evolution of the online efficient set into the true efficient set. Second, we present several metrics to evaluate the relative effectiveness of the pruning strategies in a subset of instances.

Our first experiment in this section, analyzes the evolution of the online efficient set at different points in time. Fig. 3
                         presents the evolution of the solution quality for instances BAY1 and NW7. The solution quality of an instance is based on the dominated space metric by Zitzler and Thiele (1998), which measures the area in the objective space dominated by the non-dominated vectors. Based on this metric, we define the solution quality as the ratio between the dominated space of the online non-dominated set found by the algorithm within the time threshold and the dominated space of the true non-dominated set. A solution quality of 100 percent means that the algorithm found the true non-dominated set, and a value below 100 percent represents the fraction of the true dominated space covered by the online non-dominated set, that is, a proxy of the quality of the approximation of the true non-dominated set.


                        Fig. 3 (a) shows the evolution of the solution quality for instance BAY1. For this instance, bLSET obtains the true efficient set in 65 seconds. Although the pulse algorithm takes a longer time to achieve the true non-dominated set, given that computational budget the pulse algorithm is able to find an approximate non-dominated set with a quality of roughly 90 percent. For instance NW7, the online efficient set converges to the true efficient set in 68 seconds as shown on Fig. 3(b). What is remarkable is that in just three seconds the quality of the online non-dominated set is well above 90 percent, and 40 seconds later, over 99 percent. Moreover, Fig. 4
                         shows the evolution of the online non-dominated set for instance NW7. Each subfigure compares the true non-dominated set (black dots) with different online non-dominated sets (gray dots) at different times. From these figures, it can be seen how the algorithm swiftly approximates the true non-dominated set. The bulk of the non-dominated set is shaped during the first 10 seconds (see Fig. 4(a)–(d)), while the rest of the time is spent on slight changes to fully converge to the true non-dominated set (see Fig. 4(e)–(h)). What this experiment tells us is that the pulse algorithm rapidly provides a good approximation of the non-dominated set and that if we impose a time budget, the algorithm can provide heuristically a high-quality approximation of the true non-dominated set.


We conducted yet another experiment to evaluate the relative effectiveness of the pruning strategies. In Table 3
                        , for a subset of instances, we count the number of times each strategy prunes a partial path. Column 1 presents the name of the instance; and columns 2–4 show the relative effectiveness of each strategy as the fraction of paths pruned by the pulse algorithm.

For the first set of road networks by Raith and Ehrgott (2009), the nadir point strategy prunes on average 52.1 percent of the paths, while the label and efficient set pruning strategies account for 20.7 percent and 27.2 percent, respectively. On the second set of DIMACS instances, we observed a completely different behavior. In this set, the label strategy prunes on average 63 percent of the paths while the nadir point strategy just prunes 2.1 percent of the paths. We ascribe this behavior to the fact that on the first set of instances, the values of the arc attributes vary widely compared to those of the second set. With wide arc variations, the nadir point can effectively prune paths when the pulse propagates through arcs with large values for any given objective. Despite the fact that this result gives us a rough idea of which strategies are pruning more than others, this relative effectiveness metric has its own drawbacks. Under the exploration scheme followed by the pulse algorithm, it is not the same to prune a partial path at an early stage than a partial path that is close to become a complete solution. A partial path that is pruned close to completion does not reduce the solution space as much as an early partial path that can be the origin of millions of paths. Nevertheless, the pruning count provides us with some valuable insight into which operations are considered the hot spots and should be subject to a more efficient coding.

This section shows how the intuition of the proposed algorithm and its pruning strategies can be easily extended to handle more than two objectives. Formally, the MSP is defined as follows:

                           
                              (4)
                              
                                 
                                    min
                                    
                                       
                                          z
                                       
                                       
                                          (
                                          
                                             x
                                          
                                          )
                                       
                                       =
                                       (
                                       
                                          c
                                          1
                                       
                                       
                                          (
                                          
                                             x
                                          
                                          )
                                       
                                       ,
                                       …
                                       ,
                                       
                                          c
                                          k
                                       
                                       
                                          (
                                          
                                             x
                                          
                                          )
                                       
                                       ,
                                       …
                                       ,
                                       
                                          c
                                          p
                                       
                                       
                                          (
                                          
                                             x
                                          
                                          )
                                       
                                       )
                                    
                                 
                              
                           
                        s.t.,

                           
                              (5)
                              
                                 
                                    
                                       x
                                    
                                    ∈
                                    X
                                 
                              
                           
                        where 
                           X
                         is the set of all paths x from vs
                         to ve
                         and ck
                        (x) is the kth objective.

First, we discuss how the cycle, label, and efficient set pruning strategies can be extended with minor modifications. The cycle pruning strategy does not depend on the number of objectives at all, so no change is needed. The dominance tests performed in the label pruning strategy are easily extended by enlarging the labels dimension on each node (one dimension per each objective). The efficient set pruning strategy can be extended running the initialization procedure for each objective. In this case, a vector of lower (dual) bounds < uline > c < /uline >(vi
                        ) = ( 
                           c
                         
                        1(vi
                        ), …, 
                           c
                         
                        
                           k
                        (vi
                        ), …, 
                           c
                         
                        
                           p
                        (vi
                        )) is calculated for each node, where 
                           c
                         
                        
                           k
                        (vi
                        ) is the value of the shortest path (lower bound) for the kth objective from node vi
                         to the end node ve
                        .

In contrast, extending the nadir point pruning strategy is not straightforward, because calculating this point for three or more objectives is not as direct as in the biobjective case (Ehrgott, 2005). Instead, we calculate a pseudo nadir point
                        
                           
                              
                                 z
                              
                              
                                 N
                                 ^
                              
                           
                         and adapt the strategy for multiple objectives. Let 
                           
                              
                                 
                                    z
                                 
                                 
                                    N
                                    ^
                                 
                              
                              =
                              
                                 (
                                 
                                    z
                                    
                                       1
                                    
                                    
                                       N
                                       ^
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    z
                                    
                                       k
                                    
                                    
                                       N
                                       ^
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    z
                                    
                                       p
                                    
                                    
                                       N
                                       ^
                                    
                                 
                                 )
                              
                              ,
                           
                         where 
                           
                              
                                 z
                                 
                                    k
                                 
                                 
                                    N
                                    ^
                                 
                              
                              =
                              
                                 max
                                 
                                    
                                       k
                                       
                                          
                                          ′
                                       
                                    
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    p
                                 
                              
                              
                                 {
                                 
                                    c
                                    k
                                 
                                 
                                    (
                                    
                                       
                                          x
                                       
                                       
                                          
                                             k
                                             
                                                
                                                ′
                                             
                                          
                                       
                                       *
                                    
                                    )
                                 
                                 }
                              
                           
                         and 
                           
                              
                                 x
                              
                              
                                 k
                              
                              *
                           
                         is the optimal solution of the mono-objective shortest path problem for the kth objective. This vector 
                           
                              
                                 z
                              
                              
                                 N
                                 ^
                              
                           
                         contains the worst values for each objective among all vectors 
                           
                              
                                 z
                              
                              
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       1
                                    
                                    *
                                 
                                 )
                              
                              ,
                              …
                              ,
                              
                                 z
                              
                              
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       p
                                    
                                    *
                                 
                                 )
                              
                              ,
                           
                         henceforth called the minimizer vectors for each objective. For example, let us consider for p = 3 the minimizer vectors 
                           
                              
                                 z
                              
                              
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       1
                                    
                                    *
                                 
                                 )
                              
                              =
                              
                                 (
                                 4
                                 ,
                                 4
                                 ,
                                 7
                                 )
                              
                              ,
                           
                        
                        
                           
                              
                                 z
                              
                              
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       2
                                    
                                    *
                                 
                                 )
                              
                              =
                              
                                 (
                                 8
                                 ,
                                 2
                                 ,
                                 10
                                 )
                              
                              ,
                           
                         and 
                           
                              
                                 z
                              
                              
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       3
                                    
                                    *
                                 
                                 )
                              
                              =
                              
                                 (
                                 12
                                 ,
                                 7
                                 ,
                                 3
                                 )
                              
                           
                        . The pseudo nadir point is 
                           
                              
                                 
                                    z
                                 
                                 
                                    N
                                    ^
                                 
                              
                              =
                              
                                 (
                                 12
                                 ,
                                 7
                                 ,
                                 10
                                 )
                              
                           
                        . For the MSP, the pruning strategy discards a partial path from vs
                         to vi
                        , 
                           
                              
                                 P
                                 
                                    s
                                    ,
                                    i
                                 
                              
                              ,
                           
                         if 
                           
                              
                                 c
                                 k
                              
                              
                                 (
                                 
                                    P
                                    
                                       s
                                       ,
                                       i
                                    
                                 
                                 )
                              
                              +
                              
                                 
                                    c
                                    ̲
                                 
                                 k
                              
                              
                                 (
                                 
                                    v
                                    i
                                 
                                 )
                              
                              >
                              
                                 z
                                 
                                    k
                                 
                                 
                                    N
                                    ^
                                 
                              
                           
                         for all k = 1, …, p, where 
                           
                              
                                 c
                                 k
                              
                              
                                 (
                                 
                                    P
                                    
                                       s
                                       ,
                                       i
                                    
                                 
                                 )
                              
                           
                         is the cumulative value for the kth objective. Note that the main difference with the initial pruning strategy for the BSP is that the condition to prune must hold for all the objectives simultaneously. The following theorem demonstrates that this modification to the nadir pruning strategy does not cut off any solution of the true efficient set.

                           Theorem 6.1
                           
                              Let
                              
                                 
                                    
                                       z
                                       
                                          k
                                       
                                       
                                          N
                                          ^
                                       
                                    
                                    =
                                    
                                       max
                                       
                                          
                                             k
                                             
                                                
                                                ′
                                             
                                          
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          p
                                       
                                    
                                    
                                       {
                                       
                                          c
                                          k
                                       
                                       
                                          (
                                          
                                             
                                                x
                                             
                                             
                                                
                                                   k
                                                   
                                                      
                                                      ′
                                                   
                                                
                                             
                                             *
                                          
                                          )
                                       
                                       }
                                    
                                 
                               
                              be the kth component of the pseudo nadir point and
                              
                                 
                                    
                                       z
                                    
                                    
                                       (
                                       
                                          
                                             x
                                          
                                          
                                             1
                                          
                                          *
                                       
                                       )
                                    
                                    ,
                                    …
                                    ,
                                    
                                       z
                                    
                                    
                                       (
                                       
                                          
                                             x
                                          
                                          
                                             p
                                          
                                          *
                                       
                                       )
                                    
                                 
                               
                              be the minimizer vectors for each objective. For a partial path
                              
                                 
                                    P
                                    
                                       s
                                       ,
                                       i
                                    
                                 
                               
                              from node vs to node vi, if
                              
                                 
                                    
                                       c
                                       k
                                    
                                    
                                       (
                                       
                                          P
                                          
                                             s
                                             ,
                                             i
                                          
                                       
                                       )
                                    
                                    +
                                    
                                       
                                          c
                                          ̲
                                       
                                       k
                                    
                                    
                                       (
                                       
                                          v
                                          i
                                       
                                       )
                                    
                                    >
                                    
                                       z
                                       
                                          k
                                       
                                       
                                          N
                                          ^
                                       
                                    
                                 
                               
                              holds for all objectives k = 1, …, p, 
                                 
                                    P
                                    
                                       s
                                       ,
                                       i
                                    
                                 
                               
                              can be safely pruned without cutting off any efficient solution.
                           

Let 
                                 
                                    
                                       P
                                       
                                          s
                                          ,
                                          e
                                       
                                    
                                    =
                                    
                                       P
                                       
                                          s
                                          ,
                                          i
                                       
                                    
                                    ∪
                                    
                                       P
                                       
                                          i
                                          ,
                                          e
                                       
                                    
                                 
                               be any complete path beginning with partial path 
                                 
                                    P
                                    
                                       s
                                       ,
                                       i
                                    
                                 
                              . For any 
                                 
                                    P
                                    
                                       i
                                       ,
                                       e
                                    
                                 
                               it holds that 
                                 
                                    
                                       c
                                       k
                                    
                                    
                                       (
                                       
                                          P
                                          
                                             i
                                             ,
                                             e
                                          
                                       
                                       )
                                    
                                    ≥
                                    
                                       
                                          c
                                          ̲
                                       
                                       k
                                    
                                    
                                       (
                                       
                                          v
                                          i
                                       
                                       )
                                    
                                 
                               for all k = 1, …, p, because 
                                 c
                               
                              
                                 k
                              (vi
                              ) is a lower bound for the kth objective. Since 
                                 
                                    
                                       c
                                       k
                                    
                                    
                                       (
                                       
                                          P
                                          
                                             s
                                             ,
                                             i
                                          
                                       
                                       )
                                    
                                    +
                                    
                                       
                                          c
                                          ̲
                                       
                                       k
                                    
                                    
                                       (
                                       
                                          v
                                          i
                                       
                                       )
                                    
                                    >
                                    
                                       z
                                       
                                          k
                                       
                                       
                                          N
                                          ^
                                       
                                    
                                 
                               for all k = 1, …, p, 
                                 
                                    
                                       c
                                       k
                                    
                                    
                                       (
                                       
                                          P
                                          
                                             s
                                             ,
                                             e
                                          
                                       
                                       )
                                    
                                    =
                                    
                                       c
                                       k
                                    
                                    
                                       (
                                       
                                          P
                                          
                                             s
                                             ,
                                             i
                                          
                                       
                                       )
                                    
                                    +
                                    
                                       c
                                       k
                                    
                                    
                                       (
                                       
                                          P
                                          
                                             i
                                             ,
                                             e
                                          
                                       
                                       )
                                    
                                    ≥
                                    
                                       c
                                       k
                                    
                                    
                                       (
                                       
                                          P
                                          
                                             s
                                             ,
                                             i
                                          
                                       
                                       )
                                    
                                    +
                                    
                                       
                                          c
                                          ̲
                                       
                                       k
                                    
                                    
                                       (
                                       
                                          v
                                          i
                                       
                                       )
                                    
                                    >
                                    
                                       z
                                       
                                          k
                                       
                                       
                                          N
                                          ^
                                       
                                    
                                 
                               for all k = 1, …, p. Given that 
                                 
                                    
                                       z
                                       
                                          k
                                       
                                       
                                          N
                                          ^
                                       
                                    
                                    ≥
                                    
                                       z
                                       k
                                    
                                    
                                       (
                                       
                                          
                                             x
                                          
                                          
                                             
                                                k
                                                ′
                                             
                                          
                                          *
                                       
                                       )
                                    
                                 
                               for all k = 1, …, p and for all k′ = 1, …, p, then 
                                 
                                    
                                       c
                                       k
                                    
                                    
                                       (
                                       
                                          P
                                          
                                             s
                                             ,
                                             e
                                          
                                       
                                       )
                                    
                                    >
                                    
                                       z
                                       
                                          k
                                       
                                       
                                          N
                                          ^
                                       
                                    
                                    ≥
                                    
                                       z
                                       k
                                    
                                    
                                       (
                                       
                                          
                                             x
                                          
                                          
                                             
                                                k
                                                ′
                                             
                                          
                                          *
                                       
                                       )
                                    
                                 
                               for all k = 1, …, p and for all k′ = 1, …, p. Hence, the image in the objective space of any complete path 
                                 
                                    P
                                    
                                       s
                                       ,
                                       e
                                    
                                 
                               that begins with partial path 
                                 
                                    P
                                    
                                       s
                                       ,
                                       i
                                    
                                 
                               is dominated by all the minimizer vectors 
                                 
                                    
                                       z
                                    
                                    
                                       (
                                       
                                          
                                             x
                                          
                                          
                                             1
                                          
                                          *
                                       
                                       )
                                    
                                    ,
                                    …
                                    ,
                                    
                                       z
                                    
                                    
                                       (
                                       
                                          
                                             x
                                          
                                          
                                             p
                                          
                                          *
                                       
                                       )
                                    
                                 
                               and partial path 
                                 
                                    P
                                    
                                       s
                                       ,
                                       i
                                    
                                 
                               can be discarded.□

As a proof of concept, we conducted an experiment with the multiobjective version of the pulse algorithm over a testbed for the Resource-Constrained Shortest Path Problem (RCSP) proposed by Beasley and Christofides (1989). We adapted those instances considering the distance and the resource consumption over the arcs as different objectives for the MSP. From the 24 instances available, we discarded those with only two objectives, and for each one of the remaining instances, we considered 3, 5, and 10 objectives. Table 4
                         summarizes the results for this set of instances for the MSP. Columns 1–3 show the instance name, followed by the number of nodes and arcs. Columns 4 and 5 show the computational time and the size of the non-dominated set for each instance with three objectives. Similarly, columns 6 and 7, and columns 8 and 9, present the information for the instances with 5 and 10 objectives, respectively.

By adapting the pulse algorithm for the MSP, we were able to solve instances with up to 10 objectives. For 3, 5, and 10 objectives, all instances were solved in less than 0.13, 0.83, and 101.61 seconds, respectively. As the number of objectives grows, so does the size of the true non-dominated set and the computational time required to find it. This behavior is expected since it is difficult to prove dominance among vectors when several objectives are considered. For instance, to prune a partial path by the label or efficient set strategy, it needs to be dominated in all objectives (as many as ten). With larger efficient sets, it might be impractical to handle such amount of solutions; however, with the pulse algorithm, a high quality approximation of the non-dominated set can be obtained with limited computational budget and a manageable size.

@&#CONCLUSIONS AND FUTURE WORK@&#

We developed a new exact approach for the BSP that performs well on large-scale real road networks with up to 1,207,945 nodes and 2,840,208 arcs. The intuition of the algorithm is very easy to understand, backed on the simple idea of a pulse propagating through a network. To implement it, there are few considerations that must be taken into account, like the number of labels at each node and the criterion used to sort the outgoing arcs of each node. Although the algorithm is based on the idea of (implicit) enumeration, the proposed pruning strategies dramatically accelerate the exploration of the networks by exploring implicitly vast regions of the solution space. Our approach compares favorably against a top-performer algorithm by Raith (2010) in terms of the execution times. On the instance set from Raith and Ehrgott (2009), the proposed algorithm reaches speedups of up to 152 times and achieves an average speedup of 57 times over all instances. On the very-large scale instances from the DIMACS dataset, the pulse algorithm performed faster than bLSET on 123 out of 150 instances with a geometric mean of speedups of roughly 45 and 21 on the two largest problem sets. Aside from the good performance on the BSP experiments, we show the extensibility of the pulse algorithm to multiple objectives (p ≥ 3) on instances from the literature with up to ten objectives.

Profiling our algorithm, we noticed that the key strategies are pruning by efficient set and nadir point for the proposed instances by Raith and Ehrgott (2009); and label and efficient set strategies for the DIMACS instances. As the algorithm progresses, the efficient set strategy is strengthened as new solutions complement the quick check made by the nadir point strategy and partial paths are more likely to be dominated.

With the straightforward intuition behind the pulse, it is simple to extend our algorithm to several network problems. Some of the future work includes studying acceleration strategies to improve the algorithm’s performance, including non-additive cost functions, and further experimentation with multiple objectives. Finally, we would like to explore the stochastic variants of the BSP.

@&#ACKNOWLEDGMENTS@&#

We would like to thank Professor Matthias Ehrgott at University of Auckland (New Zealand) for his generosity in sharing with us his testbed for the BSP. We would also like to thank to the anonymous referees for their insightful comments that helped us to improve this paper.

@&#REFERENCES@&#

