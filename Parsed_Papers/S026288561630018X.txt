@&#MAIN-TITLE@&#Action recognition via spatio-temporal local features: A comprehensive study

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A timely review of action recognition based on spatio-temporal local features.


                        
                        
                           
                           Transfer techniques in image domain to video domain for action recognition.


                        
                        
                           
                           Evaluation of representation methods for action recognition.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Action recognition

Spatio-temporal local features

Feature coding

Bag-of-words

Sparse coding

Fisher kernel

VLAD

NBNN

Match kernels

Performance evaluation

@&#ABSTRACT@&#


               
               
                  Local methods based on spatio-temporal interest points (STIPs) have shown their effectiveness for human action recognition. The bag-of-words (BoW) model has been widely used and dominated in this field. Recently, a large number of techniques based on local features including improved variants of the BoW model, sparse coding (SC), Fisher kernels (FK), vector of locally aggregated descriptors (VLAD) as well as the naive Bayes nearest neighbor (NBNN) classifier have been proposed and developed for visual recognition. However, some of them are proposed in the image domain and have not yet been applied to the video domain and it is still unclear how effectively these techniques would perform on action recognition. In this paper, we provide a comprehensive study on these local methods for human action recognition. We implement these techniques and conduct comparison under unified experimental settings on three widely used benchmarks, i.e., the KTH, UCF-YouTube and HMDB51 datasets. We discuss insightfully the findings from the experimental results and draw useful conclusions, which are expected to guide practical applications and future work for the action recognition community.
               
            

@&#INTRODUCTION@&#

Human action recognition as an active topic in the computer vision community has been extensively researched in the last decades. Most of the existing methods, including both low-level feature extraction and high-level representations, in action recognition are extended from the text and image domains, i.e., the bag-of-word (BoW) model [1]. Local features have shown increasing effectiveness in visual recognition, and local methods based on spatio-temporal local features, e.g., three-dimensional histogram of oriented gradients (HOG3D) [2] and HOGHOF [3], become popular in action recognition since the inventions of spatio-temporal interest points detectors [4–7]. In contrast to holistic representations [8,9], local methods enjoy many advantages such as 1) avoidance of some preliminary steps, e.g., background subtraction and target tracking required in holistic methods, and 2) resistance to background variation and occlusions.

The most widely used local methods, e.g., the bag-of-word (BoW) model [1] and sparse coding (SC) [10–12], have obtained remarkable performance in image and object classification. Recently, refinements of BoW and SC as well as alternative techniques including the soft assignment coding (kernel codebooks) [13], Triangle assignment coding [14], localized soft-assignment coding (LSC) [15] and locality linear-constrained coding (LLC) [16], have been developed to forward the state-of-the-art. However, these developments mostly remain in the image domain, which makes transferring them to the video domain an urgent and promising task.

A simple non-parametric nearest neighbor (NN) based classifier, naive bayes nearest neighbor (NBNN) [17], was proposed in recently. By computing the ‘ Image-to-Class' rather than ‘ Image-to-Image’ distance, NBNN is able to avoid quantizing local features in the BoW model. In contrast to learning-based classifiers, the non-parametric NBNN classifier requires no training phase thus no risk of overfitting the parameters. Recently, enhanced versions of NBNN, including the NBNN kernels [18] and the local NBNN [19], have also been developed. The NBNN family have shown excellent effectiveness in image and object recognition.

The Fisher kernel (FK) has recently drawn increasingly attention in the image domain and produced remarkable results for image classification [20–22]. It is shown in a recent study on feature coding [23] that the improved Fisher kernel (IFK), which is also called Fisher vector (FV), outperforms all the other encoding methods on several image datasets. Another important encoding method is the vector of locally aggregated descriptors (VLAD) introduced by Jégou et al. [24,25]. VLAD can be regarded as a simplified non-probabilistic version of Fisher vector and has shown comparable results with IFK.

Match kernels between sets of local features have long been exploited in visual recognition [26,27]. Without relying on any mid-level feature representations, match kernels are able to compute the similarity between sets of unordered local features and have shown the effectiveness in image and object recognition. More importantly, match kernels provides a basic formulation of measuring two sets of local features, based on which local methods are connected. The newly proposed feature coding techniques have been widely used and demonstrated their effectiveness in the image domain, however, their performance on action recognition has not been comprehensively evaluated and compared. Motivated by this, in this paper, we transfer these prevailing techniques from the image domain to the video domain and put them under a unified evaluation framework with the same experimental settings. In contrast to the previous evaluations [5,28–30], we focus on the evaluation of state-of-the-art local methods, e.g., the BoW model, sparse coding, Fisher kernels, VLAD, NBNN and match kernels, based on spatio-temporal local features for human action recognition.

Recently, methods using tracking of trajectories has been used for action recognition which can always outperform those based on STIPs while requiring higher computational complexity [31]. In addition, it is found by Reddy and Mubarak [32] that motion based descriptors are not scalable with respect to the number of action categories, which can be reasonably assumed to also hold for trajectory-based sampling of descriptors. As we concentrate on the comparison of representation methods rather than the overall performance, we follow a standard paradigm for action recognition using local features [28,29], and apply the same feature detection and description steps to all the methods to be evaluated.

We systematically evaluate the performance of representative local methods, some of which have not been used for action recognition yet. Extensive experimental results have been reported on three widely used benchmark action datasets, i.e., KTH, UCF-YouTube and HMDB51. To the best of our knowledge, we, for the first time, pull local methods under a unified setting and conduct a comprehensive study both theoretically and experimentally for action recognition.

The main contributions of this paper lie in the following three aspects: 1) we have conducted a comprehensive study on state-of-the-art local methods for human action recognition, which serves as a baseline for research in this field; 2) we provide in-depth analysis and draw impartial conclusions from the findings in the experiments, which offers an important guide for further work on human action recognition; 3) we provide a timely review on the recent advancement of local methods based on spatio-temporal local features, which can be used as an up-to-date reference for the community of action recognition.

During the last decade, action recognition with local spatio-temporal interest points (STIPs) have been extensively explored. To give an overview of the advancement of local features for human action recognition, we will provide a review of recently developed local methods both within and beyond the BoW model. In the following, we will give a more detailed description of these methods.

The BoW model is a widely used algorithm for local representations and has proven to be successful in many action recognition tasks. However, local representations also suffer from many limitations. One of the most notorious deficiencies is that it fails to capture adequate structural and temporal information. In order to compensate for the loss of structures in local representations, a lot of methods try to improve local representations by exploring spatio-temporal structural information [33], including context information of each interest point [34,35], relationships between/among spatio-temporal interest points [36–39] and neighborhood-based features [40]. The relationship among visual words in the BoW model and their semantic meaning have also been explored to encode higher-level features [15,41–43]. New local descriptors have also been developed [44,45] to improve the performance of local methods.

Sun et al. [34] proposed to model the spatio-temporal context information in a hierarchical way by exploiting three levels of context, namely, point-level, intra-trajectory and inter-trajectory context. In their work, trajectories are first extracted using Scale Invariant Feature Transform (SIFT). The point-level context is the average of SIFT descriptors extracted at the salient points on the trajectory. Intra-trajectory and inter-trajectory context is modeled by the transition matrix of a Markov process and encoded as the trajectory transition and trajectory proximity descriptors.

In order to capture the most informative spatio-temporal relationship between local descriptors, Kovashka and Grauman [40] proposed to learn a hierarchy of spatio-temporal neighborhood features. The main idea is to construct a higher-level vocabulary from new features that consider the hierarchical neighboring information around each interest point.

Matikainen et al. [36] proposed to express pair-wise relationships between quantized features by combining the power of discriminative representations with key aspects of naive Bayes. The relationship between local features is modeled as the distribution of quantized location differences between each pair of interest points. Two basic features namely STIP-HOG and quantized trajectories are considered.

Gaur et al. [33] modeled the activity in a video as a “string of feature graphs” (SFGs) by treating a video as a spatio-temporal collection of primitive features (e.g., STIP features). They divide the features into small temporal bins and represent the video as a temporally ordered collection of such feature-bins, each bin consisting of a graphical structure representing the spatial arrangement of the low-level features. A video then becomes a string of such graphs and comparing two videos is to match two strings of graphs.

Claiming that the higher-order semantic correlation between mid-level features (e.g., from the BoW representation) is useful to fill the semantic gap, Lu et al. [42] proposed novel spectral methods to learn latent semantics from abundant mid-level features by spectral embedding with nonparametric graphs and hypergraphs. A new semantics-aware representation (i.e., histogram of high-level features) is derived for each video from the original BOW representation, and actions are classified by a SVM with a histogram intersection kernel based on the new representation.

Wang et al. [38] presented a novel local representation by augmenting local features with contextual features, which capture the interactions between interest points. Different from previous work on mining contextual information is considered as spatio-temporal statistics in the 3D neighborhood of each interest point. Multi-scale channels of contextual features are computed and, for each channel, a regular grid is used to encode spatio-temporal information in the local neighborhood of an interest point. Multiple kernel learning is employed to integrate the contextual features from different channels.

Aiming to encode rich temporal ordering and spatial geometry information of local visual words, Zhang et al. [41] proposed to model the mutual relationships among visual words by a novel concept named the spatio-temporal phrase (ST phrase). A ST phrase is defined as a combination of k words in a certain spatial and temporal structure including their order and relative positions. A video is represented as a bag of ST phrases which is shown to be more informative than the BoW model.

In order to capture the geometrical distribution of interest points, Yuan et al. [39] applied the 3D R transform on the interest points based on their 3D locations. The 3D R-transform is invariant to geometrical transformation and robust to noise. (2D)2 PCA is then employed to reduce the dimensionality of the 2D feature matrix from the 3D R transform, obtaining the so-called R features. To encode the appearance features, they combined the R features with the BoW representation. Finally, they proposed a context-aware fusion method to efficiently fuse these two features. Specifically, one feature is used to compute the context of each video and the other to calculate the context-aware kernel for action recognition.

In the BoW model, mid-level features are obtained by k-means clustering which however is unable to capture the semantic relation between low-level features due to that only appearance similarity is used. Liu et al. [15] proposed to use diffusion maps to automatically learn a semantic visual vocabulary from abundant quantized mid-level features. Each mid-level feature is represented by the vector of point-wise mutual information (PMI). Diffusion maps can capture the local intrinsic geometric relations between the mid-level feature points on the manifold.

With the argument that visual words from video sequences belonging to the same class in the BoW model are correlated and jointly reflect a specific action type, Wang et al.[43], by assuming that visual words share a common structure in a low-level space, presented a framework named semi-supervised feature correlation mining (SFCM) to exploit the shared structure. A discriminative and robust classifier for action annotation is trained by taking into account the global and local structural consistency.

Shapovalova et al. [46] proposed to model a video using a global bag-of-words histogram based on local features, combined with a bag-of-words histogram focused latent regions of interest. The latent regions of interest are spatio-temporal sub-regions of a video. The model parameters are learned by a similarity constrained latent SVM, in which the constraint is to enforce that the latent regions chosen across all videos of a class are coherent.

Le et al. [44] introduced an unsupervised deep learning algorithm, named Independent Subspace Analysis (ISA), which learns spatio-temporal features of interest points from unlabeled videos. Convolution and stacking are adopted in the deep learning model to scale the algorithm to large images and learn hierarchical representations.

As indicated by Wang et al. [28] that dense sampling tends to produce better results than sparsely detected spatio-temporal interest points. Wang et al. [35] presented an approach by dense trajectories. Dense points are sampled from each frame and tracked based on displacement information from a dense optical flow field. A novel descriptor based on motion boundary histograms was introduced in their work to encode the trajectory information. The remarkable performance of dense trajectories is largely due to the rich description of scene and contextual information of dense sampling, and the robust extraction of motion information of trajectories.

Also based on dense trajectories, Jiang et al. [47] presented a new video representation that integrates trajectory descriptors with the pair-wise trajectory locations as well as motion patterns. Global and local reference points are adopted to characterize motion information with the aim to be robust to camera movements.

Aiming to alleviate the quantization errors in the BoW model, sparse coding has also been introduced to action recognition to learn more compact and richer representations of human actions [12,48,49].

Rather than using the BoW model, Dean et al. [48] presented a new approach using the sparse coding algorithm to learning sparse, spatio-temporal features for activity recognition. A multi-stage approach is used to learn spatio-temporal features that can discriminate different actions.

In order to obtain a more accurate and discriminative representation, an approach by encoding local 3D spatial–temporal gradient features was proposed by Zhu et al. [49] in which the sparse coding framework is used for the final action representation. A local spatial-temporal feature is transformed to a linear combination of a few atoms in a trained dictionary. They also investigated the construction of the dictionary with a scenario of transfer learning.

Guha and Kreidieh [12] comprehensively explored sparse representations for human action recognition in video. Overcomplete dictionaries are learned from a set of local spatio-temporal descriptors in the training set. It is claimed that the obtained representation based on the dictionaries learned by sparse coding is more compact compared with the BoW model involving clustering and vector quantization. Three options of dictionaries, namely, shared, class-specific and concatenated, were investigated.

Recently, Fisher kernels have been applied to the video domain for human action recognition based on local features. Oneata et al. [50] evaluated the use of Fisher vectors as an alternative to the BoW model to aggregate a small set of low-level descriptors, in combination with linear classifiers for both action recognition and localization. Kantorov and Laptev [51] developed highly efficient video features called the MPEG flow video descriptor using motion information in video compression and represented actions by Fisher vectors. The method improves the speed of video feature extraction, feature encoding and action classification. Peng [52] proposed the two-layer stacked Fisher vectors (SFV) for action recognition. In the first layer, large subvolumes are densely sampled from input videos, from which local features are extracted and encoded using Fisher vectors (FVs). The second layer compresses the FVs of subvolumes obtained in the previous layer, and then encodes them again with Fisher vectors. Compared with standard FV, SFV allows refining the representation and abstracting semantic information in a hierarchical way.

Motion is regarded as the most reliable source of information for human action recognition, as it is related to the regions of interest. Jain et al. [45] introduced the Divergence–Curl–Shear (DCS) descriptor to encode scalar first-order motion features. This descriptor contains the motion divergence, curl and shear, which capture physical properties of the flow pattern. To handle the noisy motion from background and the unstable camera, an affine model is employed for motion compensation to improve the quality of descriptors. Dense trajectories are also used and the vector of locally aggregated descriptors (VLAD) is adopted for the final encoding of local features which is shown to be better than a standard BoW model. Although densely sampling shows increasing performance with the decrease of the sampling step size, it does not scale well with a large number of local patches and becomes even computationally intractable for large-scale video datasets. Vig et al. [53] proposed to select informative regions and descriptors by saliency-mapping algorithms. These regions are either used exclusively or given greater representational weights. By using the saliency-based pruning, up to 70% of descriptors can be discarded, while maintaining high performance on the Hollywood2 dataset.

Beyond the BoW, sparse coding, FV and VLAD frameworks, many new methods have also been proposed from action representation and recognition including multiple feature fusion, matching kernels and deep learning based features.

Cai et al. [54] propose Multi-View Super Vector (MVSV) for global action representation, which is composed of relatively independent components derived from a pair of descriptors. They develop a generative mixture model of probabilistic canonical correlation analyzers (M-PCCA), and utilize the hidden factors and gradient vectors of M-PCCA to construct MVSV for video representation. MVSV has outperformed FV and VLAD with descriptor concatenation and kernel fusion.

To encode the relationships among local feature descriptors, Wu at al. [55] construct a two-graph model based on the 3D SIFT descriptor to represent human actions by recording the spatial and temporal relationships among local features. A novel family of context-dependent graph kernels (CGKs) are further proposed to measure similarity between graphs. Finally, a generalized multiple kernel learning algorithm with a proposed ℓ
                        1,2-norm regularization is applied to combine these CGKs optimally together and simultaneously train a set of action classifiers.

Yang and Tian [56] introduce an effective coding scheme to aggregate low-level descriptors into a super descriptor vector (SDV). In order to incorporate the spatio-temporal information, a novel approach of super location vector (SLV) was proposed to model the space-time locations of local interest points in a much more compact way compared to the spatio-temporal pyramid representations.

Sun et al. [57] propose to combine SFA with deep learning techniques to learn hierarchical representations from the video data itself. A two-layered SFA learning structure with 3D convolution and max pooling operations is used to scale up the method to large inputs and capture abstract and structural features from the video. The method shows 1% improvement in comparison to state-of-the-art methods even without supervision or dense sampling on the KTH dataset.

Recently, Lan et al. [58] propose a novel feature enhancing technique called Multi-skIp Feature Stacking (MIFS), which stacks features extracted using a family of differential filters parameterized with multiple time skips and encodes shift-invariance into the frequency space.

Yang et al. [59] propose a multi-feature max-margin hierarchical Bayesian model (M
                        3HBM) for action recognition. M
                        3HBM jointly learns a high-level representation by combining a hierarchical generative model (HGM) and discriminative max-margin classifiers in a unified Bayesian framework.

@&#METHODS@&#

In this section, we describe the widely-used methods based on local features for visual recognition which will be evaluated in this work.

Local features in the training set are first clustered to create a codebook [60]. Video sequences are represented by coding local features with the visual words in the codebook. The coding methods to be used in the BoW model include the hard assignment, the soft assignment [13], the triangle assignment [14] and the localized soft assignment [61].

Before describing the details of all the coding methods, we first define the notations used in both the BoW model and sparse coding(SC). Let b
                        
                           i
                         denote a visual word or a basis vector, and B
                        
                           D
                           ×M
                         denote a codebook or a set of basis vectors, where D is the dimensionality of the local feature vectors and M is the number of codewords or bases. x
                        1,…,x
                        
                           i
                        ,…,x
                        
                           N
                         are local features from a video sequence, u
                        
                           i
                         ∈ R
                        
                           M
                         is the coding coefficient vector of x
                        
                           i
                         based on the codebook or basis vectors. u
                        
                           ij
                         is the coefficient associated with the word b
                        
                           j
                        .

In the hard assignment coding, the coefficient of each local feature is determined by assigning this feature x
                           
                              i
                            to its nearest codeword in the codebook using a certain distance metric. If the Euclidean distance is used, then 
                              
                                 (1)
                                 
                                    
                                       
                                          u
                                       
                                       
                                          i
                                          ,
                                          j
                                       
                                    
                                    =
                                    
                                       
                                          
                                             
                                                
                                                   
                                                   1
                                                   
                                                
                                                
                                                   if
                                                   j
                                                   =
                                                   arg
                                                   
                                                      
                                                         min
                                                      
                                                      
                                                         j
                                                         =
                                                         1
                                                         ,
                                                         ⋯
                                                         
                                                         ,
                                                         M
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            
                                                               x
                                                            
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      −
                                                      
                                                         
                                                            
                                                               b
                                                            
                                                         
                                                         
                                                            j
                                                         
                                                      
                                                   
                                                   
                                                      
                                                      
                                                         2
                                                      
                                                      
                                                         2
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                   0
                                                   
                                                
                                                
                                                   otherwise
                                                   .
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

In the soft assignment coding, The coefficient u
                           
                              i,j
                            is the degree of membership of a local feature x
                           
                              i
                            to the jth codeword. 
                              
                                 (2)
                                 
                                    
                                       
                                          u
                                       
                                       
                                          i
                                          j
                                       
                                    
                                    =
                                    
                                       
                                          exp
                                          
                                             −
                                             β
                                             
                                                
                                                   
                                                      
                                                         
                                                            x
                                                         
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   −
                                                   
                                                      
                                                         
                                                            b
                                                         
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                
                                                
                                                   2
                                                
                                                
                                                   2
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                                ∑
                                             
                                             
                                                k
                                                =
                                                1
                                             
                                             
                                                M
                                             
                                          
                                          exp
                                          
                                             −
                                             β
                                             
                                                
                                                   
                                                      
                                                         
                                                            x
                                                         
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   −
                                                   
                                                      
                                                         
                                                            b
                                                         
                                                      
                                                      
                                                         k
                                                      
                                                   
                                                
                                                
                                                   2
                                                
                                                
                                                   2
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           where β is the smoothing factor controlling the softness of the assignment.

The triangle assignment coding was proposed in [14]. The coding is defined by the following activation function: 
                              
                                 (3)
                                 
                                    
                                       
                                          u
                                       
                                       
                                          i
                                          j
                                       
                                    
                                    =
                                    max
                                    
                                       0
                                       ,
                                       μ
                                       (
                                       
                                          z
                                       
                                       )
                                       −
                                       
                                          
                                             z
                                          
                                          
                                             j
                                          
                                       
                                    
                                 
                              
                           where 
                              
                                 
                                    z
                                 
                                 
                                    j
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          
                                             x
                                          
                                       
                                       
                                          i
                                       
                                    
                                    −
                                    
                                       
                                          
                                             b
                                          
                                       
                                       
                                          j
                                       
                                    
                                 
                                 
                                    2
                                 
                              
                            and μ(z) is the mean of elements of z. This activation function forces the output to be 0 for any feature x
                           
                              i
                            whose distance to the codeword b
                           
                              j
                            is larger than the average of all distances. As a result, roughly half of the weights will be set to 0.

By combining the ideas of localization and the soft assignment coding, Liu et al.[61] proposed the localized soft-assignment coding (LSC). The activation function takes the form in Eq.(2), but with the locality constraint as follows: 
                              
                                 (4)
                                 
                                    d
                                    
                                       
                                          
                                             
                                                x
                                             
                                          
                                          
                                             i
                                          
                                       
                                       ,
                                       
                                          
                                             
                                                b
                                             
                                          
                                          
                                             j
                                          
                                       
                                    
                                    =
                                    
                                       
                                          
                                             
                                                
                                                   
                                                   d
                                                   
                                                      
                                                         
                                                            
                                                               x
                                                            
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      ,
                                                      
                                                         
                                                            
                                                               b
                                                            
                                                         
                                                         
                                                            j
                                                         
                                                      
                                                   
                                                   ,
                                                   
                                                
                                                
                                                   if
                                                   
                                                      
                                                         
                                                            b
                                                         
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                   ∈
                                                   
                                                      
                                                         N
                                                      
                                                      
                                                         k
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            
                                                               x
                                                            
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                   ∞
                                                   
                                                
                                                
                                                   otherwise
                                                   .
                                                
                                             
                                          
                                       
                                    
                                    ,
                                 
                              
                           where 
                              d
                              
                                 
                                    
                                       
                                          x
                                       
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       
                                          b
                                       
                                    
                                    
                                       j
                                    
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          x
                                       
                                    
                                    
                                       i
                                    
                                 
                                 −
                                 
                                    
                                       
                                          b
                                       
                                    
                                    
                                       j
                                    
                                 
                              
                              
                                 
                                 
                                    2
                                 
                                 
                                    2
                                 
                              
                           , and N
                           
                              k
                            denotes the k-nearest neighbors of x
                           
                              i
                            defined by the distance 
                              d
                              
                                 
                                    
                                       
                                          x
                                       
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       
                                          b
                                       
                                    
                                    
                                       j
                                    
                                 
                              
                           .

In sparse coding (SC), a local feature is represented by a linear combination of a sparse set of basis vectors. The coding coefficient is obtained by solving an l
                        1-norm regularized approximation problem [62]: 
                           
                              (5)
                              
                                 
                                    
                                       
                                          u
                                       
                                    
                                    
                                       i
                                    
                                 
                                 =
                                 arg
                                 
                                    
                                       min
                                    
                                    
                                       u
                                       ∈
                                       
                                          
                                             R
                                          
                                          
                                             n
                                          
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                x
                                             
                                          
                                          
                                             i
                                          
                                       
                                       −
                                       
                                          B
                                          u
                                       
                                    
                                    
                                       2
                                    
                                    
                                       2
                                    
                                 
                                 +
                                 λ
                                 
                                    
                                       
                                          u
                                       
                                    
                                    
                                       1
                                    
                                 
                                 ,
                              
                           
                        where λ controls the sparsity of the coefficient.

Instead of enforcing sparsity in SC, LLC [16] confines a local feature x
                           
                              i
                            to be coded by its local neighbors in the codebook. The locality constraint ensures that similar patches would have similar codes. The coding coefficient is obtained by solving the following optimization problem:


                           
                              
                                 (6)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      u
                                                   
                                                
                                                
                                                   i
                                                
                                             
                                             =
                                             arg
                                             
                                                
                                                   min
                                                
                                                
                                                   
                                                      u
                                                   
                                                   ∈
                                                   
                                                      
                                                         R
                                                      
                                                      
                                                         M
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         x
                                                      
                                                   
                                                   
                                                      i
                                                   
                                                
                                                −
                                                
                                                   B
                                                   u
                                                
                                             
                                             
                                                
                                                
                                                   2
                                                
                                                
                                                   2
                                                
                                             
                                             +
                                             λ
                                             
                                                
                                                   
                                                      
                                                         d
                                                      
                                                   
                                                   
                                                      i
                                                   
                                                
                                                ⊙
                                                
                                                   u
                                                
                                             
                                             
                                                
                                                
                                                   2
                                                
                                                
                                                   2
                                                
                                             
                                             ,
                                          
                                       
                                       
                                          
                                          
                                             s
                                             .
                                             t
                                             .
                                             
                                             
                                                
                                                   
                                                      1
                                                   
                                                
                                                
                                                   T
                                                
                                             
                                             
                                                
                                                   
                                                      u
                                                   
                                                
                                                
                                                   i
                                                
                                             
                                             =
                                             1
                                          
                                       
                                    
                                 
                              
                           where ⊙ denotes the element-wise multiplication, and d
                           
                              i
                            ∈ R
                           
                              M
                            is the locality adaptor that gives different freedom for each basis vector proportional to its similarity to the input descriptor x
                           
                              i
                           . Specifically, 
                              
                                 (7)
                                 
                                    
                                       
                                          
                                             d
                                          
                                       
                                       
                                          i
                                       
                                    
                                    =
                                    exp
                                    
                                       −
                                       
                                          
                                             d
                                             i
                                             s
                                             t
                                             (
                                             
                                                
                                                   
                                                      x
                                                   
                                                
                                                
                                                   i
                                                
                                             
                                             ,
                                             
                                                B
                                             
                                             )
                                          
                                          
                                             σ
                                          
                                       
                                    
                                 
                              
                           where dist(x
                           
                              i
                           ,B) =[dist(x
                           
                              i
                           ,b
                           1),…,dist(x
                           
                              i
                           ,b
                           
                              M
                           )]⊤, and 
                              
                                 d
                                 i
                                 s
                                 t
                                 
                                    
                                       
                                          
                                             x
                                          
                                       
                                       
                                          i
                                       
                                    
                                    ,
                                    
                                       
                                          
                                             b
                                          
                                       
                                       
                                          j
                                       
                                    
                                 
                              
                            is the Euclidean distance between x
                           
                              i
                            and b
                           
                              j
                           . σ is used for adjusting the weight decay speed for the locality adaptor. As an approximation of LLC, one can simply use the k nearest neighbors of x
                           
                              i
                            as the local bases, and solve a much smaller linear system.

Fisher kernels [63] was introduced to combine the advantages of both generative and discriminative models. Perronnin et al. [20] applied Fisher kernels to learn a visual vocabulary for image representation. An image is described with a gradient vector derived from its probability density function.

Specifically, X
                        ={x
                        
                           n
                        ,n
                        =1…N} denotes the set of low-level feature vectors extracted from an image and λ is the set of parameters of the Gaussian mixture model (GMM). λ
                        ={ω
                        
                           i
                        ,μ
                        
                           i
                        ,Σ
                        
                           i
                        ,i
                        =1…M} where ω
                        
                           i
                        , μ
                        
                           i
                         and Σ
                        
                           i
                         denote respectively the weight, mean vector and covariance matrix of Gaussian i and M denotes the number of Gaussians.

With the assumption that local features are independent, an image can be represented by the likelihood of all the local features as: 
                           
                              (8)
                              
                                 L
                                 (
                                 X
                                 |
                                 λ
                                 )
                                 =
                                 
                                    
                                       ∑
                                    
                                    
                                       n
                                       =
                                       1
                                    
                                    
                                       N
                                    
                                 
                                 log
                                 p
                                 (
                                 
                                    
                                       
                                          x
                                       
                                    
                                    
                                       n
                                    
                                 
                                 |
                                 λ
                                 )
                              
                           
                        where p(x
                        
                           n
                        |λ) is the probability density function that can be modeled by the GMM model. The image can be described by the gradient vector: 
                           
                              (9)
                              
                                 G
                                 =
                                 
                                    
                                       1
                                    
                                    
                                       N
                                    
                                 
                                 
                                    
                                       ∇
                                    
                                    
                                       λ
                                    
                                 
                                 L
                                 (
                                 X
                                 |
                                 λ
                                 )
                                 .
                              
                           
                        The gradient of the likelihood describes the contribution of the parameters to the generation process [21]. A kernel between two gradient vectors of images X and Y is 
                           
                              (10)
                              
                                 K
                                 (
                                 X
                                 ,
                                 Y
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             
                                                G
                                             
                                             
                                                λ
                                             
                                             
                                                X
                                             
                                          
                                       
                                    
                                    
                                       ⊤
                                    
                                 
                                 
                                    
                                       F
                                    
                                    
                                       λ
                                    
                                    
                                       −
                                       1
                                    
                                 
                                 
                                    
                                       G
                                    
                                    
                                       λ
                                    
                                    
                                       Y
                                    
                                 
                              
                           
                        where 
                           
                              
                                 F
                              
                              
                                 λ
                              
                              
                                 −
                                 1
                              
                           
                         is the Fisher information matrix 
                           
                              (11)
                              
                                 
                                    
                                       F
                                    
                                    
                                       λ
                                    
                                 
                                 =
                                 E
                                 [
                                 
                                    
                                       ∇
                                    
                                    
                                       λ
                                    
                                 
                                 L
                                 (
                                 X
                                 |
                                 λ
                                 )
                                 
                                    
                                       ∇
                                    
                                    
                                       λ
                                    
                                 
                                 L
                                 (
                                 Y
                                 |
                                 λ
                                 )
                                 ]
                                 .
                              
                           
                        The Fisher information matrix 
                           
                              
                                 F
                              
                              
                                 λ
                              
                           
                         is symmetric and positive definite, and has a Cholesky decomposition 
                           
                              
                                 F
                              
                              
                                 λ
                              
                           
                           =
                           
                              
                                 F
                              
                              
                                 λ
                              
                              
                                 ⊤
                              
                           
                           
                              
                                 F
                              
                              
                                 λ
                              
                           
                        . X is then can be represented by a normalized gradient vector: 
                           
                              (12)
                              
                                 
                                    
                                       G
                                    
                                    
                                       λ
                                    
                                    
                                       X
                                    
                                 
                                 =
                                 
                                    
                                       F
                                    
                                    
                                       λ
                                    
                                 
                                 
                                    
                                       G
                                    
                                    
                                       λ
                                    
                                    
                                       X
                                    
                                 
                              
                           
                        which is referred as the Fisher vector of X.

According to Perronnin et al.[20], the Fisher matrix has an approximated closed-form solution with which the Fisher vector can be represented as: 
                           v
                           (
                           i
                           )
                           =
                           [
                           
                              
                                 G
                              
                              
                                 μ
                                 ,
                                 i
                              
                           
                           ;
                           
                              
                                 G
                              
                              
                                 Σ
                                 ,
                                 i
                              
                           
                           ]
                        , where i indexes the i-th Gaussian of the Fisher vector and 
                           
                              (13)
                              
                                 
                                    
                                       G
                                    
                                    
                                       μ
                                       ,
                                       i
                                    
                                 
                                 =
                                 
                                    
                                       1
                                    
                                    
                                       N
                                       
                                          
                                             
                                                
                                                   ω
                                                
                                                
                                                   i
                                                
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       ∑
                                    
                                    
                                       n
                                       =
                                       1
                                    
                                    
                                       N
                                    
                                 
                                 
                                    
                                       γ
                                    
                                    
                                       n
                                    
                                 
                                 (
                                 i
                                 )
                                 
                                    
                                       
                                          
                                             
                                                
                                                   x
                                                
                                             
                                             
                                                n
                                             
                                          
                                          −
                                          
                                             
                                                μ
                                             
                                             
                                                i
                                             
                                          
                                       
                                       
                                          
                                             
                                                σ
                                             
                                             
                                                i
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (14)
                              
                                 
                                    
                                       G
                                    
                                    
                                       σ
                                       ,
                                       i
                                    
                                 
                                 =
                                 
                                    
                                       1
                                    
                                    
                                       N
                                       
                                          
                                             2
                                             
                                                
                                                   ω
                                                
                                                
                                                   i
                                                
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       ∑
                                    
                                    
                                       n
                                       =
                                       1
                                    
                                    
                                       N
                                    
                                 
                                 
                                    
                                       γ
                                    
                                    
                                       n
                                    
                                 
                                 (
                                 i
                                 )
                                 
                                    
                                       
                                          
                                             
                                                (
                                                
                                                   
                                                      
                                                         x
                                                      
                                                   
                                                   
                                                      n
                                                   
                                                
                                                −
                                                
                                                   
                                                      μ
                                                   
                                                   
                                                      i
                                                   
                                                
                                                )
                                             
                                             
                                                2
                                             
                                          
                                       
                                       
                                          
                                             
                                                σ
                                             
                                             
                                                2
                                             
                                          
                                       
                                    
                                    −
                                    1
                                 
                              
                           
                        where 
                           
                              
                                 γ
                              
                              
                                 i
                              
                           
                           (
                           n
                           )
                           =
                           
                              
                                 
                                    
                                       ω
                                    
                                    
                                       i
                                    
                                 
                                 
                                    
                                       p
                                    
                                    
                                       i
                                    
                                 
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       n
                                    
                                 
                                 |
                                 λ
                                 )
                              
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       j
                                       =
                                       1
                                    
                                    
                                       M
                                    
                                 
                                 
                                    
                                       ω
                                    
                                    
                                       i
                                    
                                 
                                 
                                    
                                       p
                                    
                                    
                                       j
                                    
                                 
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       n
                                    
                                 
                                 |
                                 λ
                                 )
                              
                           
                        . We use the improved Fisher kernel (IFK) proposed in [21] which has shown to significantly improve the original Fisher kernel.

The vector of locally aggregated descriptors (VLAD) was proposed by Jégou et al. [24,25] which is a simplified non-probabilistic version of the Fisher vector. To be consistent with the BoW method, B
                        ={b
                        
                           i
                        ,i
                        =1,…,M} is the codebook. Each local descriptor x
                        
                           n
                         is associated with its nearest visual word NN(x
                        
                           n
                        ) in the codebook. For each codeword b
                        
                           i
                        , the differences x
                        
                           n
                         −b
                        
                           i
                         of the vectors x
                        
                           i
                         assigned to b
                        
                           i
                         are accumulated: 
                           
                              (15)
                              
                                 
                                    
                                       
                                          v
                                       
                                    
                                    
                                       i
                                    
                                 
                                 =
                                 
                                    
                                       ∑
                                    
                                    
                                       
                                          
                                             
                                                x
                                             
                                          
                                          
                                             n
                                          
                                       
                                       :
                                       N
                                       N
                                       (
                                       
                                          
                                             
                                                x
                                             
                                          
                                          
                                             n
                                          
                                       
                                       )
                                       =
                                       i
                                    
                                 
                                 (
                                 
                                    
                                       
                                          x
                                       
                                    
                                    
                                       n
                                    
                                 
                                 −
                                 
                                    
                                       
                                          b
                                       
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 .
                              
                           
                        The concatenation v
                        =[v
                        1,…,v
                        
                           i
                        ,…,v
                        
                           M
                        ,] is the final compact representation of an image/video.

Match kernels between sets of local features have long been exploited [26,27]. The kernel function is computed to measure the similarity between two images/video sequences represented by sets of local feature vectors.

Given two feature sets, 
                           
                              
                                 F
                              
                              
                                 a
                              
                           
                           =
                           
                              
                                 
                                    F
                                 
                                 
                                    1
                                 
                                 
                                    (
                                    a
                                    )
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    F
                                 
                                 
                                    |
                                    
                                       
                                          F
                                       
                                       
                                          a
                                       
                                    
                                    |
                                 
                                 
                                    (
                                    a
                                    )
                                 
                              
                           
                         and 
                           
                              
                                 F
                              
                              
                                 b
                              
                           
                           =
                           
                              
                                 
                                    F
                                 
                                 
                                    1
                                 
                                 
                                    (
                                    b
                                    )
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    F
                                 
                                 
                                    |
                                    
                                       
                                          F
                                       
                                       
                                          b
                                       
                                    
                                    |
                                 
                                 
                                    (
                                    b
                                    )
                                 
                              
                           
                        , the summation kernel is defined as: 
                           
                              (16)
                              
                                 
                                    
                                       K
                                    
                                    
                                       S
                                    
                                 
                                 
                                    
                                       
                                          F
                                       
                                       
                                          a
                                       
                                    
                                    ,
                                    
                                       
                                          F
                                       
                                       
                                          b
                                       
                                    
                                 
                                 =
                                 
                                    
                                       1
                                    
                                    
                                       |
                                       
                                          
                                             F
                                          
                                          
                                             a
                                          
                                       
                                       |
                                    
                                 
                                 
                                    
                                       1
                                    
                                    
                                       |
                                       
                                          
                                             F
                                          
                                          
                                             b
                                          
                                       
                                       |
                                    
                                 
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       =
                                       1
                                    
                                    
                                       |
                                       
                                          
                                             F
                                          
                                          
                                             a
                                          
                                       
                                       |
                                    
                                 
                                 
                                    
                                       ∑
                                    
                                    
                                       j
                                       =
                                       1
                                    
                                    
                                       |
                                       
                                          
                                             F
                                          
                                          
                                             b
                                          
                                       
                                       |
                                    
                                 
                                 
                                    
                                       K
                                    
                                    
                                       F
                                    
                                 
                                 
                                    
                                       
                                          F
                                       
                                       
                                          i
                                       
                                       
                                          (
                                          a
                                          )
                                       
                                    
                                    ,
                                    
                                       
                                          F
                                       
                                       
                                          j
                                       
                                       
                                          (
                                          b
                                          )
                                       
                                    
                                 
                                 .
                              
                           
                        In [27], a kernel function (the max-sum kernel) for matching local features was proposed:


                        
                           
                              (17)
                              
                                 
                                    
                                       
                                          
                                             
                                                K
                                             
                                             
                                                M
                                             
                                          
                                          
                                             
                                                
                                                   F
                                                
                                                
                                                   a
                                                
                                             
                                             ,
                                             
                                                
                                                   F
                                                
                                                
                                                   b
                                                
                                             
                                          
                                          =
                                       
                                       
                                          
                                             
                                                1
                                             
                                             
                                                2
                                             
                                          
                                          
                                             
                                                ∑
                                             
                                             
                                                i
                                                =
                                                1
                                             
                                             
                                                |
                                                
                                                   
                                                      F
                                                   
                                                   
                                                      a
                                                   
                                                
                                                |
                                             
                                          
                                          
                                             
                                                max
                                             
                                             
                                                j
                                                =
                                                1
                                                ,
                                                …
                                                ,
                                                |
                                                
                                                   
                                                      F
                                                   
                                                   
                                                      b
                                                   
                                                
                                                |
                                             
                                          
                                          
                                             
                                                K
                                             
                                             
                                                F
                                             
                                          
                                          
                                             
                                                
                                                   F
                                                
                                                
                                                   i
                                                
                                                
                                                   (
                                                   a
                                                   )
                                                
                                             
                                             ,
                                             
                                                
                                                   F
                                                
                                                
                                                   j
                                                
                                                
                                                   (
                                                   b
                                                   )
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                          +
                                          
                                             
                                                1
                                             
                                             
                                                2
                                             
                                          
                                          
                                             
                                                ∑
                                             
                                             
                                                j
                                                =
                                                1
                                             
                                             
                                                |
                                                
                                                   
                                                      F
                                                   
                                                   
                                                      b
                                                   
                                                
                                                |
                                             
                                          
                                          
                                             
                                                max
                                             
                                             
                                                i
                                                =
                                                1
                                                ,
                                                …
                                                ,
                                                |
                                                
                                                   
                                                      F
                                                   
                                                   
                                                      a
                                                   
                                                
                                                |
                                             
                                          
                                          
                                             
                                                K
                                             
                                             
                                                F
                                             
                                          
                                          
                                             
                                                
                                                   F
                                                
                                                
                                                   j
                                                
                                                
                                                   (
                                                   b
                                                   )
                                                
                                             
                                             ,
                                             
                                                
                                                   F
                                                
                                                
                                                   i
                                                
                                                
                                                   (
                                                   a
                                                   )
                                                
                                             
                                          
                                          .
                                       
                                    
                                 
                              
                           
                        
                     

This match kernel has been used in object recognition [27] and action classification [64]. Lyu et al. [26] has proven it to be a non-mercer kernel, and proposed a normalized sum-match kernel which satisfies the mercer condition and is defined as follows: 
                           
                              (18)
                              
                                 
                                    
                                       K
                                    
                                    
                                       F
                                    
                                 
                                 
                                    
                                       
                                          F
                                       
                                       
                                          a
                                       
                                    
                                    ,
                                    
                                       
                                          F
                                       
                                       
                                          b
                                       
                                    
                                 
                                 =
                                 
                                    
                                       1
                                    
                                    
                                       |
                                       
                                          
                                             F
                                          
                                          
                                             a
                                          
                                       
                                       |
                                    
                                 
                                 
                                    
                                       1
                                    
                                    
                                       |
                                       
                                          
                                             F
                                          
                                          
                                             b
                                          
                                       
                                       |
                                    
                                 
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       =
                                       1
                                    
                                    
                                       |
                                       
                                          
                                             F
                                          
                                          
                                             a
                                          
                                       
                                       |
                                    
                                 
                                 
                                    
                                       ∑
                                    
                                    
                                       j
                                       =
                                       1
                                    
                                    
                                       |
                                       
                                          
                                             F
                                          
                                          
                                             b
                                          
                                       
                                       |
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                K
                                             
                                             
                                                F
                                             
                                          
                                          
                                             
                                                
                                                   F
                                                
                                                
                                                   i
                                                
                                                
                                                   (
                                                   a
                                                   )
                                                
                                             
                                             ,
                                             
                                                
                                                   F
                                                
                                                
                                                   j
                                                
                                                
                                                   (
                                                   b
                                                   )
                                                
                                             
                                          
                                       
                                    
                                    
                                       p
                                    
                                 
                                 ,
                              
                           
                        where p ≥ 1 is the kernel parameter.

Naive Bayes nearest neighbor (NBNN) is an approximation of the optimal MAP naive-Bayes classifier. Given an image Q represented as a set of local features, x
                        1,…,x
                        
                           N
                        , when the class prior p(C) is uniform, MAP becomes the maximum likelihood (ML) classifier: 
                           
                              (19)
                              
                                 Ĉ
                                 =
                                 
                                    arg
                                 
                                 
                                    
                                       max
                                    
                                    
                                       C
                                    
                                 
                                 p
                                 (
                                 C
                                 |
                                 Q
                                 )
                                 =
                                 
                                    arg
                                 
                                 
                                    
                                       max
                                    
                                    
                                       C
                                    
                                 
                                 p
                                 (
                                 Q
                                 |
                                 C
                                 )
                                 .
                              
                           
                        With the naive-Bayes assumption that x
                        1,…,x
                        
                           N
                         are i.i.d. given its class C, we have 
                           
                              (20)
                              
                                 p
                                 (
                                 Q
                                 |
                                 C
                                 )
                                 =
                                 p
                                 (
                                 
                                    
                                       
                                          x
                                       
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    
                                       
                                          x
                                       
                                    
                                    
                                       N
                                    
                                 
                                 |
                                 C
                                 )
                                 =
                                 
                                    
                                       ∏
                                    
                                    
                                       i
                                       =
                                       i
                                    
                                    
                                       N
                                    
                                 
                                 p
                                 (
                                 
                                    
                                       
                                          x
                                       
                                    
                                    
                                       i
                                    
                                 
                                 |
                                 C
                                 )
                              
                           
                        
                     


                        p(x
                        
                           i
                        |C) is further approximated using the Parzen density estimation and when the Parzen kernel keeps only the nearest neighbor and the same kernel bandwidth for all the classes, the resulting classifier takes the following simple form: 
                           
                              (21)
                              
                                 
                                    
                                       c
                                    
                                    ¯
                                 
                                 =
                                 
                                    arg
                                 
                                 
                                    
                                       min
                                    
                                    
                                       c
                                    
                                 
                                 =
                                 
                                    
                                       ∑
                                    
                                    
                                       
                                          x
                                       
                                       ∈
                                       
                                          X
                                       
                                    
                                 
                                 |
                                 |
                                 
                                    x
                                 
                                 −
                                 N
                                 
                                    
                                       N
                                    
                                    
                                       c
                                    
                                 
                                 (
                                 
                                    x
                                 
                                 )
                                 |
                                 
                                    
                                       |
                                    
                                    
                                       2
                                    
                                 
                                 ,
                              
                           
                        where NN
                        
                           c
                         is the nearest neighbor of x in class c.

The NBNN kernel is based on the normalized sum match kernel [26], to calculate the similarity between two sets of features X
                           ={x} and Y
                           ={y}:


                           
                              
                                 (22)
                                 
                                    
                                       
                                          
                                             K
                                             (
                                             X
                                             ,
                                             Y
                                             )
                                          
                                          
                                             =
                                          
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   c
                                                   ∈
                                                   C
                                                
                                             
                                             
                                                
                                                   K
                                                
                                                
                                                   c
                                                
                                             
                                             (
                                             X
                                             ,
                                             Y
                                             )
                                          
                                       
                                       
                                          
                                          
                                             =
                                          
                                          
                                             
                                                
                                                   1
                                                
                                                
                                                   |
                                                   X
                                                   |
                                                   |
                                                   Y
                                                   |
                                                
                                             
                                             
                                                
                                                   ∑
                                                
                                                
                                                   c
                                                   ∈
                                                   C
                                                
                                             
                                             
                                                
                                                   ∑
                                                
                                                
                                                   
                                                      x
                                                   
                                                   ∈
                                                   X
                                                
                                             
                                             
                                                
                                                   ∑
                                                
                                                
                                                   
                                                      y
                                                   
                                                   ∈
                                                   Y
                                                
                                             
                                             
                                                
                                                   k
                                                
                                                
                                                   c
                                                
                                             
                                             (
                                             
                                                x
                                             
                                             ,
                                             
                                                y
                                             
                                             )
                                             ,
                                          
                                       
                                    
                                 
                              
                           where C
                           ={c} and k
                           
                              c
                           (x,y) is the local kernel between local features x and y. In the NBNN kernel, k
                           
                              c
                           (x,y) is defined as:


                           
                              
                                 (23)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   k
                                                
                                                
                                                   c
                                                
                                             
                                             (
                                             
                                                x
                                             
                                             ,
                                             
                                                y
                                             
                                             )
                                          
                                          
                                             =
                                          
                                          
                                             
                                                
                                                   ϕ
                                                
                                                
                                                   c
                                                
                                             
                                             
                                                
                                                   (
                                                   
                                                      x
                                                   
                                                   )
                                                
                                                
                                                   
                                                      T
                                                   
                                                
                                             
                                             
                                                
                                                   ϕ
                                                
                                                
                                                   c
                                                
                                             
                                             (
                                             
                                                y
                                             
                                             )
                                          
                                       
                                       
                                          
                                          
                                             =
                                          
                                          
                                             
                                                
                                                   f
                                                
                                                
                                                   c
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         
                                                            d
                                                         
                                                         
                                                            
                                                               x
                                                            
                                                         
                                                         
                                                            1
                                                         
                                                      
                                                      ,
                                                      …
                                                      ,
                                                      
                                                         
                                                            d
                                                         
                                                         
                                                            
                                                               x
                                                            
                                                         
                                                         
                                                            |
                                                            C
                                                            |
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                      T
                                                   
                                                
                                             
                                             
                                                
                                                   f
                                                
                                                
                                                   c
                                                
                                             
                                             
                                                
                                                   
                                                      d
                                                   
                                                   
                                                      
                                                         y
                                                      
                                                   
                                                   
                                                      1
                                                   
                                                
                                                ,
                                                …
                                                ,
                                                
                                                   
                                                      d
                                                   
                                                   
                                                      
                                                         y
                                                      
                                                   
                                                   
                                                      |
                                                      C
                                                      |
                                                   
                                                
                                             
                                             .
                                          
                                       
                                    
                                 
                              
                           Two distance functions have been considered in the original work [18], namely, 
                              
                                 
                                    f
                                 
                                 
                                    1
                                 
                                 
                                    c
                                 
                              
                              
                                 
                                    
                                       d
                                    
                                    
                                       
                                          x
                                       
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    
                                       d
                                    
                                    
                                       
                                          x
                                       
                                    
                                    
                                       |
                                       C
                                       |
                                    
                                 
                              
                              =
                              
                                 
                                    d
                                 
                                 
                                    
                                       x
                                    
                                 
                                 
                                    c
                                 
                              
                            and 
                              
                                 
                                    f
                                 
                                 
                                    2
                                 
                                 
                                    c
                                 
                              
                              
                                 
                                    
                                       d
                                    
                                    
                                       
                                          x
                                       
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    
                                       d
                                    
                                    
                                       
                                          x
                                       
                                    
                                    
                                       |
                                       C
                                       |
                                    
                                 
                              
                              =
                              
                                 
                                    d
                                 
                                 
                                    
                                       x
                                    
                                 
                                 
                                    c
                                 
                              
                              −
                              
                                 
                                    d
                                 
                                 
                                    
                                       x
                                    
                                 
                                 
                                    ĉ
                                 
                              
                           , where 
                              
                                 
                                    d
                                 
                                 
                                    
                                       x
                                    
                                 
                                 
                                    c
                                 
                              
                            is the distance to its nearest neighbor in class c and 
                              
                                 
                                    d
                                 
                                 
                                    
                                       x
                                    
                                 
                                 
                                    ĉ
                                 
                              
                            denotes the closest distance to all classes except for c.

McCann and Lowe [19] developed an improved version of NBNN, named local naive Bayes nearest neighbor (LNBNN), which increases the classification accuracy and scales better with a large number of classes. The motivation of local NBNN is from the observation that only the classes represented in the local neighborhood of a descriptor contribute significantly and reliably to their posterior probability estimation. Instead of finding the nearest neighbor in each of the classes, local NBNN finds in the local neighborhood k nearest neighbors which may only come from some of the classes. The “localized” idea is shared with LSC in the BoW model and LLC in SC.

@&#EXPERIMENTS AND RESULTS@&#

To comprehensively investigate and evaluate local methods for human action recognition, we have conducted extensive experiments on three increasingly challenging benchmarks including the KTH, UCF-Youtube and HMDB51 datasets.


                        The KTH dataset 
                        [65] is a commonly used benchmark action dataset with 2391 video clips. Six human action classes, including walking, jogging, running, boxing, hand waving and handicapping, are performed by 25 subjects in four different scenarios: outdoors (s1), outdoors with scale variation (s2), outdoors with different clothes (s3) and indoors with lighting variation (s4). We follow the standard experimental setup [28], i.e., test set (9 subjects: 2, 3, 5, 6, 7, 8, 9, 10, and 22) and training set (the remaining 16 subjects).


                        The UCF YouTube dataset 
                        [15] contains 11 action categories: basketball shooting, biking/cycling, diving, golf swinging, horse back riding, soccer juggling, swinging, tennis swinging, trampoline jumping, volleyball spiking, and walking with a dog. This dataset is challenging due to large variations in camera motion, object appearance and pose, object scale, viewpoint, cluttered background and illumination condition. We follow the experimental settings in [15].


                        The HMDB51 dataset 
                        [66] contains 51 distinct categories with at least 101 clips in each for a total of 6766 video clips extracted from a wide range of sources. The action categories can be grouped in five types: 1) General facial actions: smile, laugh, chew, talk; 2) Facial actions with object manipulation: smoke, eat, drink; 3) General body movements: cartwheel, clap hands, climb, climb stairs, dive, fall on the floor, backhand flip, handstand, jump, pull up, push up, run, sit down, sit up, somersault, stand up, turn, walk, wave; 4) Body movements with object interaction: brush hair, catch, draw sword, dribble, golf, hit something, kick ball, pick, pour, push something, ride bike, ride horse, shoot ball, shoot bow, shoot gun, swing baseball bat, sword exercise, throw; 5) Body movements for human interaction: fencing, hug, kick someone, kiss, punch, shake hands, sword fight. All the results are reported by averaging the three training/test splits [66].

In this section, we give the implemental details and parameter settings of each method evaluated in our experiments.

We employ the periodic detector proposed by Dollár at al. [67] to detect the spatio-temporal interest points from the raw video sequences and follow the parameter settings in the evaluation work of [28]. As in [14], the three-dimensional histogram of oriented gradients (HOG3D) [2] is used to describe each STIP due to its computational efficiency. The chosen detector and descriptor have shown outstanding performance in [28,29]. For BoW and SC, we randomly select 100,000 local features from the training set to learn codebooks and dictionaries.

The spatio-temporal pyramid matching (STPM) [68] can be easily embedded in the methods to encode the structural information and presumably could improve the performance. As our focus is on the comparison between different methods rather than the overall performance, and we argue that STPM would equally contribute to each method, STPM is not used in our evaluation framework.

In BoW and SC, a final representation v of an action is obtained by pooling over the coefficients [11]. With average pooling, the j-th component of v is obtained by 
                              
                                 
                                    v
                                 
                                 
                                    j
                                 
                              
                              =
                              
                                 
                                    ∑
                                 
                                 
                                    i
                                    =
                                    1
                                 
                                 
                                    N
                                 
                              
                              
                                 
                                    u
                                 
                                 
                                    i
                                    j
                                 
                              
                              /
                              N
                           . With max pooling, v
                           
                              j
                            is obtained by 
                              
                                 
                                    v
                                 
                                 
                                    j
                                 
                              
                              =
                              
                                 
                                    max
                                 
                                 
                                    i
                                 
                              
                              
                                 
                                    u
                                 
                                 
                                    i
                                    j
                                 
                              
                           , where i
                           =1,2,⋯ ,N.

In the BoW model, the codebooks are created by the k-means clustering algorithm provided in VLFeat toolbox [60] with a single run and is fixed for encoding methods under the BoW framework. In LSC, we follow the parameter settings in the original work [61] with β set as 10. For hard assignment coding, we have also implemented square rooting with l2 normalization [22].

For sparse coding, we use the open-source optimization toolbox SPAMS (SPArse Modeling Software)
                              1
                           
                           
                              1
                              
                                 http://spams-devel.gforge.inria.fr/
                              
                            . The dictionary is learned by the algorithm in [62], and the sparse codes are learned using orthogonal matching pursuit (OMP) [62]. The parameter λ is set 0.15. The number of non-zero coefficients is 10in the OMP algorithm. For LLC, we use the released code with the same parameter settings.

As NBNN is non-parametric, no parameter is required to tune. While for the local NBNN classifier, the single parameter is the number of nearest neighbors k. We have investigated the effect of k in our experiments. With regard to the NBNN kernel, we have experimented the distance function 
                              
                                 
                                    f
                                 
                                 
                                    2
                                 
                                 
                                    c
                                 
                              
                              
                                 
                                    
                                       d
                                    
                                    
                                       
                                          x
                                       
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    
                                       d
                                    
                                    
                                       
                                          x
                                       
                                    
                                    
                                       |
                                       C
                                       |
                                    
                                 
                              
                            in our implementation.

For the match kernels, we use the linear kernel as the local kernel and the single parameter p is set as 9 according to the original work [26]. We also use the normalized kernel in building the SVM classifier: 
                              K
                              (
                              x
                              ,
                              y
                              )
                              ←
                              
                                 
                                    K
                                    (
                                    x
                                    ,
                                    y
                                    )
                                 
                                 
                                    
                                       
                                          K
                                          (
                                          x
                                          ,
                                          x
                                          )
                                       
                                    
                                    
                                       
                                          K
                                          (
                                          y
                                          ,
                                          y
                                          )
                                       
                                    
                                 
                              
                           .

We use the implementation of the Fisher vector provided by the VLFeat toolbox [60]. The effect of different numbers of Gaussians has also been investigated. We follow [20,21] by using the GMM to model the probability density function p(x|λ) in Eq. (8).

We also use the implementation of VLAD by the VLFeat toolbox [60]. Similar to IFK, L2-normalization with square rooting is used to improve the performance. We use the results (the means of GMM) of GMM in IFK as the codebook for VLAD.

With the final action representation, we use a support vector machine (SVM) [69] classifier for BoW, SC, the improved Fisher kernel, VLAD and the match kernels. The performance of different kernels has also been evaluated. Note that the χ
                           2 and intersection kernels are only applicable to histogram representations. For BoW and SC, we have also experimented with different kernels of SVMs. The recognition performance is measured by classification accuracy.

@&#RESULTS@&#

All the final results on the three datasets are summarized in Table 1
                        . The size of the codebook in BoW and the number of bases in SC which are hard to pre-determine while always affect the performance have been investigated and illustrated.

The best result is 94.1% obtained by the local NBNN classifier, which is comparative to the state-of-of-art results from more complicated methods. The confusion matrix of the best result is plotted in Fig. 1
                           . The NBNN classifier achieves the second best result – 93.9% – which is slightly lower than the local NBNN classifier. In addition, the NBNN kernel gives a result of 89.2%, which is still better than the baseline hard assignment coding in BoW.

In the BoW model, LSC achieves an accuracy of 92.5% which is impressive considering its simplicity. The triangle assignment coding with max pooling is better than both the hard and soft assignment coding techniques, which is consistent with the report in [14]. The effect of kernels on different methods has also been investigated and the results on KTH are reported in Table 2
                           . Note that our implementation of the baseline hard assignment coding with the χ
                           2 kernel is better than that in [28] (91.7% vs. 90.0%). Among all the kernels, the linear kernel produces the best performance on this dataset and the intersection kernel is also comparable with other kernels. The effect of codebook sizes on the BoW model is illustrated in Fig. 2
                           . Most of the methods peak around 4000 codewords except for LSC which keeps increasing up to 5000 codewords.

The SC-based methods yield relatively better results compared with the BoW model. The ordinary SC with max pooling achieves even better results than LLC. Both SC and LLC reach the best results around 3072 bases as shown in Fig. 3
                           . The number k of nearest neighbors in LLC is a key parameter in LLC and the performance with different values of k is shown in Fig. 4
                           . The performance becomes relatively stable with k > 100. The linear kernel outperforms radial basis function (RBF) kernel within SC as shown in Fig. 2. The results in [48] and [49] which use sparse coding on this dataset are 85,73% and 94.92%. A different experimental setting, i.e., using 599 video clips in total, is employed in [49] for validation.

The improved Fisher kernel (IFK) has achieved a high accuracy on this dataset which is better than both BoW and SC based methods. IFK even outperforms the NBNN kernel and is comparable with NBNN and local NBNN. The performance of VLAD is also impressive with an accuracy of 92.0%. The performance of IFK and VLAD with different numbers of Gaussians is shown in Fig. 5
                           . The match kernel performs poorly with an accuracy of 86.9%.

The results on the UCF-YouTube dataset are slightly different from those on the KTH dataset. Among the NBNN methods, the NBNN kernel produces the best result of 62.4% which is slightly better than local NBNN. The corresponding confusion matrix is plotted in Fig. 8
                           .

In the BoW model, the soft assignment coding with max pooling performs best which is better than the triangle assignment coding and LSC. The result – 61.2%– is comparable with theresult –62.4%– by the NBNN kernel. As shown in Fig. 6
                           , the best results happen around 5000 codewords for almost all the methods within the BoW framework. SC with max pooling outperforms LLC obtaining an accuracy of 59.4% which is also comparable with the best result. The effect of different numbers of bases in SC is illustrated in Fig. 7
                           , and most of the best results for SC and LLC occur with 4096 bases. The effect of kernels on the performance of BoW and SC is reported in Table 3
                           . On this dataset, the intersection kernel outperforms the linear kernel within BoW and the linear kernel is significantly better than the RBF kernel within SC. In addition, the performance variation of LLC with the number of neighbors is illustrated in Fig. 4. The performance of SVM with different kernels on this dataset is reported in Fig. 6.

The improved Fisher kernel has achieved the best performance – 63.0%– on this dataset which is slightly better than that – 62.6%– of VLAD . The effect of different numbers of Gaussians on this dataset is also shown in Fig. 5. The performance of the match kernels is inferior in this dataset, producing a low recognition rate of 54.5%.

The best result – 30.5% – is obtained by the improved Fisher kernel which is better than the rest of the evaluated methods with a large margin. The confusion matrix is plotted in Fig. 11
                           . VLAD has produced a relatively good result of 26.4% and is comparable with IFK. The performance with different numbers of Gaussians is illustrated in Fig. 5.

The triangle assignment coding with max pooling gives the best result within the BoW model. LSC produces a comparable result of 24.6% with the triangle assignment coding. SC with max pooling achieves an impressive result – 27.7%– which is better than all of the methods in BoWand SC. The performance of the NBNN family is similar to that on the UCF-YouTube dataset, where the NBNN kernel is better than both NBNN and local NBNN. The match kernel fails to provide reasonable results on this dataset.


                           Fig. 9
                            shows the performance of methods in BoW with different codebook sizes on the HMDB51 dataset. Most of the methods increase with codewords from 1000 to 5000, which is reasonable since this dataset is highly diverse with huge variations both intra and inter classes. As shown in Fig. 10
                           , both SC and LLC become stable with the number of bases greater than 2048 with the best results around 3072. Similarly, the performance of SVM with different kernels on this dataset is illustrated in Table 4
                           . The intersection kernel is comparable with the linear kernel.

@&#DISCUSSIONS@&#

In this section, we provide an in-depth discussion on the findings from experimental results and summarize the performance of different local methods which would be used a guidance for future research.

The BoW model describes the probability distribution of local features by using voting-based histogram [23]. Each bin of the histogram represents the occurrence of a codeword in a video. However, it tends to be coarse and less informative due to quantization errors using a histogram, especially with a hard assignment. To compensate the information loss, many sophisticated coding methods have been developed. The newly proposed encoding techniques such as the triangle assignment coding with max pooling and the localized soft-assignment coding (LSC) significantly improve the baseline hard assignment coding, and achieve the state-of-the-art performance, especially on the KTH dataset. This is mainly because that the information loss during the feature quantization has been compensated by the sophisticated encoding techniques. The square root BoW with L2 normalization can further improve the regular BoW with hard assignment which is consistent with the findings in the image domain for object recognition [22]. Compared with other sophisticated encoding algorithms, e.g., the IFK, the advantages of the BoW model lie in its theoretic simplicity and computational efficiency. It has been shown that the BoW is a special case of the Fisher kernel where the gradient computation is restricted to the mixture weight parameters of the GMM [71]. The BoW model with a hard assignment can be formulated in a match kernel framework with a linear kernel, which has been illustrated in [72].

Sparse coding (SC) is based on the reconstruction of local features with codewords by solving constrained least-square optimization problems. The obtained sparse codes of local features are pooled together to achieve a global representation of an action. Sparse coding and its variants via spatio-temporal local features have been extensively explored for action recognition [12]. With both average and max pooling strategies, SC outperforms most of the BoW based methods, which indicates its ability of encoding complex local features for action recognition. SC with max pooling has produced an impressive result of 27.9% on the HMDB51 dataset. The possible reason is that SC can better encode local features with less quantization errors while the max pooling makes it more insensitive to unusual local features. LLC does not outperform SC with max pooling on the three datasets, which is different from the performance on image classification tasks [16]. This is inconsistent with the report on object recognition in [16]. One reason could be that spatio-temporal features in video are much noisier than two-dimensional image features, which makes the locality constraint in LLC insignificant. In addition, LLC can produce reasonable results with more local neighbors k (over 100) than in the image domain (typically k
                           =5), which would be due to the fact that spatio-temporal local features in the video domain lie in a higher dimensional space. Therefore, to encode a local feature, more bases would be needed.

Note that, for all the methods using feature pooling, max pooling is significantly better than average pooling both in BoW and SC on the three datasets. This behavior is consistent with that in image classification [11]. Our experimental results have validated the effectiveness of max pooling for action recognition in the video domain. Interestingly, the locality constraint and max pooling have demonstrated to be more effective in the BoW model than in SC, e.g., LSC significantly improves the performance of BoW.

Naive Bayes nearest neighbor (NBNN) is non-parametric approach first proposed for object classification and achieve state-of-the-art performance by avoidance of quantization errors in the BoW model. The NBNN family produces impressive results on all the three datasets, with highest recognition rate by the local NBNN classifier on the KTH dataset. Local NBNN generally outperforms NBNN on the three datasets. This is consistent with the results in image and object recognition [17–19]. However, the superiority of the NBNN family become less significant on more realistic datasets, i.e., HMDB51, with a larger number of action categories. This would be due to that the assumption in NBNN that the smoothing parameter, namely the Parzen kernel bandwidth σ, is common for all categories does not, at least not fully, hold for large category numbers. Moroever, NBNN methods directly rely on the local features without mid-level feature encoding. On the realistic datasets, e.g., HMDB51, local features are extremely noisy and therefore the performance of the NBNN family, e.g., NBNN and local NBNN, would be seriously compromised since no training stage is used in NBNN and local NBNN. This can also explain that the NBNN kernel still shows good performance on realistic datasets because it employs a training stage which helps handle noisy features. Finally, the NBNN family is connected to the rest of local methods through the NBNN kernel which can also be formulated in terms of match kernels. Indeed, the local NBNN classifier can also be regarded as imposing the locality constraint on the original NBNN with max pooling if the distance to a neighbor is deemed as the inverse of similarity.

The Fisher kernel describes a video with a gradient vector derived from its probability function and the gradient vector indicates the directions in which parameters should be adjusted to fit the data [71]. The improved Fisher kernel (IFK) [21] has produced impressive results, especially on the realistic UCF-YouTube and challenging HMDB51 datasets. Compared to the BoW model, the FK is a more principled approach than the BoW to combine the generative and discriminative models. The Fisher vector encodes high-order statistics including the zeroth, first and second orders and describes how the set of descriptors deviates from an average distribution which is modeled by a parametric generative model [25]. Intuitively, the IFK has much higher dimensionality than the BoW model and therefore can encode much more information for representations which therefore produce better results.

The VLAD is a simplified non-probabilistic version of the FK [25] under the approximations that the soft assignment is replaced by a hard assignment and only the gradient with respect to the mean is considered [71]. The performance of vector of locally aggregated descriptor (VLAD) is competitive with the IFK while being more computational efficient and holds the same trends over all the datasets.

Due to the simplicity, the match kernels yield relatively low recognition rates but sometimes are comparable to some of the methods in the BoW model such as the hard assignment, the soft and triangle assignments with average coding, especially on the KTH and HMDB51 datasets. With regard to match kernels, we have also experimented the max-sum kernel K
                           
                              M
                           , however, it performs far worse than the normalized sum kernel 
                              
                                 
                                    K
                                 
                                 
                                    F
                                 
                              
                            and even fails to produce reasonable results on the UCF-YouTube dataset. This would be due to the fact that it does not meet the Mercer condition and cannot guarantee that the optimization in SVM is convex as also shown in[73]. However, the most important role played by match kernels is the basic formulation of similarity of feature sets which can explain the connections among local feature based methods, including the BoW model [72], LLC [16] in sparse coding, the NBNN kernel [18], Fisher kernels [71] and VLAD [25].

@&#SUMMARY@&#

To summarize, the IFK has shown superb performance for action recognition based on spatio-temporal local descriptors. This finding is consistent with that in image classification [23]. Although IFK does not always perform the best for the three datasets (slightly lower than local NBNN on KTH), its results on UCF-YouTube and HMDB51 are significantly better than other methods, showing the great potential of the IFK to handle complicated local features in realistic applications of human action recognition [23]. The VLAD has produced comparative performance, which is slightly lower than the IFK, showing significant advantages over the rest of the methods. The NBNN based methods have advantages on relatively simple datasets, e.g., the KTH dataset, because of the innate avoidance of quantization errors by using image-to-class (I2C) distances. However, on realistic datasets, e.g., UCF-YouTube and HMDB51, local features are extremely noisy, which makes the I2C distance less accurate and therefore the performance of NBNN based methods decreases. Although the BoW model and the sparse coding algorithm have been widely used and shown their effectiveness for image classification and action recognition, their performance tends to be inferior on realistic datasets for action recognition even with sophisticated encoding methods. Match kernels yield inferior performance but provide a basic formulation that theoretically connects different local methods.

@&#CONCLUSION@&#

In this paper, we have done a comprehensive study on local methods for human action recognition. The state-of-the-art techniques, which have been widely used and shown effectiveness in the image domain, have been transferred to action recognition. Extensive experiments have been conducted to systematically evaluate and compare these techniques on three benchmark datasets: KTH, UCF-YouTube and HMDB51. Moreover, we have also provided experimental and theoretical insights into the performance of each method and drawn useful conclusions from findings in the experiments. As many of the techniques are innovated in the image domain and have not yet been applied to action recognition, our work can serve as guidance for future research in action recognition.

@&#REFERENCES@&#

