@&#MAIN-TITLE@&#Derivation and inference of higher-order strictness types

@&#HIGHLIGHTS@&#


               
                  
                  
                     
                        
                           
                           We introduce syntax and semantics of a basic programming language.


                        
                        
                           
                           We define derivation rules for a higher-order strictness typing system.


                        
                        
                           
                           We proof soundness of our system with respect to the semantics.


                        
                        
                           
                           The proof is formalized by using a theorem prover.


                        
                        
                           
                           In inference algorithm is specified which infers principal strictness types.


                        
                        
                           
                           An extension of our system with recursive data types is given.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Strictness analysis

Lambda calculus

Typing

Operational semantics

Automated theorem proving

@&#ABSTRACT@&#


               
               
                  We extend an existing first-order typing system for strictness analysis to the fully higher-order case, covering both the derivation system and the inference algorithm. The resulting strictness typing system has expressive capabilities far beyond that of traditional strictness analysis systems. This extension is developed with the explicit aim of formally proving soundness of higher-order strictness typing with respect to a natural operational semantics. A key aspect of our approach is the introduction of a proof assistant at an early stage, namely during development of the proof. As such, the theorem prover aids the design of the language theoretic concepts. The new results in combination with their formal proof can be seen as a case study towards the achievement of the long term PoplMark Challenge. The proof framework developed for this case study can furthermore be used in other typing system case studies.
               
            

@&#INTRODUCTION@&#

In this paper we present a type-theoretic approach to strictness analysis covering both type derivation and type inference.
                        1
                     
                     
                        1
                        This paper is an extension of an improved version of an earlier conference paper [20] which covers type derivation only.
                      The typing system includes higher-order types as well as user-defined recursive data types. One of our objectives is to formally prove that the higher-order strictness typing is sound with respect to a natural operational semantics. More specifically, we propose to use proof assistants not only for the re-construction of hand-written proofs, but moreover to introduce the tool during the development of language theoretic concepts. By introducing the tool in this stage, the consistency of technical concepts can be verified whilst designing them. This is accomplished by checking properties linking these concepts. This paper and the accompanying proof files comprise examples of such concepts and properties. Inaccuracies or mistakes made during the development were most often detected in an early stage, avoiding time consuming and inevitably failing attempts to construct a correctness proof of the main properties. This approach was used for the soundness proof of a non-standard typing system for a simple functional programming language. We combine standard Hindley–Milner typing with strictness information, specifying termination properties of higher-order functions. Strictness information can be used to change inefficient call-by-need evaluation into efficient call-by-value evaluation. This gain in efficiency lies in the fact that construction of unevaluated expressions (the so-called closures) is circumvented.

Combining standard typing with some form of input/output analysis is quite common. We mention a few examples. Substructural type systems 
                     [24] regulate the order and number of uses of data by ensuring that some values be used at most once, at least once, or exactly once. E.g., linear typing systems (such as uniqueness typing) can be used to identify unique objects. These unique objects are suitable for compile-time garbage collection which is essential for incorporating destructive updates in functional languages (e.g., see [4,22]). Security-typed languages ([23], for instance) track information flow within programs to enforce security properties such as data confidentiality and integrity. This information can be used to prevent unintentional information leaks. Ref. [21] describes a dedicated typing system for predicting the heap space usage of first-order, strict functional programs. This information can be used in several ways, most notably to ensure that a program allocates sufficient free memory.

Another view on this paper is that it reports on a case study of computer aided verification of theories about syntactic objects. Syntactic theories such as operational semantics and type systems play an important role in the (static) analysis of computer programs and the construction of reliable implementations of programming languages. The usability and reliability of syntactic techniques can undoubtedly be improved by using automated proof assistants. This need is recognized by many researchers. Most notably, the PoplMark Challenge [1] calls for experiments on verifications of metatheory and semantics using proof tools. The concrete proposal is to formalize existing proofs of properties of type systems with different proof assistants. The long term goal is far more ambitious. It envisions “…a future in which the papers in conferences such as Principles of Programming Languages (POPL) and the International Conference on Functional Programming (ICFP) are routinely accompanied by mechanically checkable proofs of the theorems they claim.”

The contribution of our work is threefold. The first contribution is the formalization of a non-standard typing system for strictness analysis of functional programs covering both the derivation system and the type inference algorithm. A first-order version of this typing system was presented in [5]. Compared to traditional strictness analyzers, it has two main advantages. Firstly, it can be combined with ordinary typing: the compiler does not require an additional analysis phase. Secondly, it avoids fixed point computations, resulting in a much more efficient implementation. In this paper we augment first order typing with function types, in effect making it fully higher-order. Compared to common strictness analyses, the resulting system has an additional advantage: it permits the specification and derivation of strictness properties between the function arguments. We prove that our system is sound with respect to a given natural operational semantics. Thereafter, we discuss the extension of the system needed to deal with recursive data-types.

Secondly, it can be seen as a methodological experiment. We assess the usability of theorem provers for formalizing complex semantical issues, not only after the manual construction of the proofs, but especially during the development of basic theory. The complexity of the typing system in our case study is of a similar level as that of the PoplMark challenge. However, the main proof methods are not known in advance, as is the case in the challenges, but are to be developed during the proof process.

Finally, the PVS formalization can be used as a framework for developing other metatheoretical concepts. The framework can be used as a basis for developing other type based analyses together with their formal soundness proof, living up to the ambition of the long term PoplMark Challenge.

@&#OVERVIEW@&#


                        Section 2 introduces the core language used in this paper. Basic aspects of strictness are treated in Section 3 including semantic interpretations of (higher-order) strictness types. The derivation rules for deriving higher-order strictness types are given in Section 4. The soundness proof of this typing system is treated informally in Section 5. The formal proof is described in Section 6. Type inference is covered in Section 7. Recursive data structures are dealt with in Section 8. The paper concludes with a discussion of related work in Section 9 and with concluding remarks and ideas for future work in Section 10.

In this section we introduce the core functional language used throughout the paper. This language captures essential aspects such as basic values, abstraction, application, data constructors and destructors, and recursion.


                        
                           Definition 1
                           Let 
                                 V
                                 =
                                 {
                                 x
                                 ,
                                 y
                                 ,
                                 z
                                 ,
                                 
                                    
                                       x
                                    
                                    
                                       0
                                    
                                 
                                 ,
                                 
                                    
                                       x
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 …
                                 }
                               be an infinite set of term variables
                                 
                                    •
                                    The set 
                                          Λ
                                        of (lambda) expressions is defined by the following abstract syntax: 
                                          
                                             
                                                Λ
                                                ::=
                                                V
                                                |
                                                □
                                                |
                                                λ
                                                V
                                                .
                                                Λ
                                                |
                                                Λ
                                                
                                                Λ
                                                |
                                                〈
                                                Λ
                                                ,
                                                Λ
                                                〉
                                                |
                                                fst
                                                
                                                Λ
                                                |
                                                snd
                                                
                                                Λ
                                                |
                                                inl
                                                
                                                Λ
                                                |
                                                inr
                                                
                                                Λ
                                                |
                                                case
                                                
                                                Λ
                                                
                                                of
                                                
                                                Λ
                                                
                                                or
                                                
                                                Λ
                                                |
                                                μ
                                                V
                                                .
                                                Λ
                                                .
                                             
                                          
                                       
                                    

The set of free variables of M is denoted by 
                                          FV
                                          (
                                          M
                                          )
                                       . Let 
                                          
                                             
                                                x
                                             
                                             
                                                →
                                             
                                          
                                          =
                                          (
                                          
                                             
                                                x
                                             
                                             
                                                1
                                             
                                          
                                          ,
                                          …
                                          ,
                                          
                                             
                                                x
                                             
                                             
                                                n
                                             
                                          
                                          )
                                       . We write 
                                          
                                             
                                                Λ
                                             
                                             
                                                
                                                   
                                                      x
                                                   
                                                   
                                                      →
                                                   
                                                
                                             
                                          
                                        for the set of 
                                          λ
                                          -
                                          terms
                                        closed by 
                                          
                                             
                                                x
                                             
                                             
                                                →
                                             
                                          
                                       , i.e., 
                                          {
                                          M
                                          ∈
                                          Λ
                                          |
                                          FV
                                          (
                                          M
                                          )
                                          ⊆
                                          
                                             
                                                x
                                             
                                             
                                                →
                                             
                                          
                                          }
                                       . We write 
                                          
                                             
                                                Λ
                                             
                                             
                                                o
                                             
                                          
                                        instead of 
                                          
                                             
                                                Λ
                                             
                                             
                                                (
                                                )
                                             
                                          
                                        (expressions with no free variables, so called closed expressions).

The constructor 
                           □
                         represents all basic values (integers, Booleans, etc.). Pairs are constructed using the expression 
                           〈
                           
                              
                                 e
                              
                              
                                 x
                              
                           
                           ,
                           
                              
                                 e
                              
                              
                                 y
                              
                           
                           〉
                        , and destructed using projections 
                           fst
                           
                           e
                         and 
                           snd
                           
                           e
                        . The constructors 
                           inl
                         and 
                           inr
                         are sum left and right injections of the disjoint unions, whereas 
                           case
                         is the destructor for these expressions.

In the sequel, we use capital letters like 
                           M
                           ,
                           N
                           ,
                           X
                           ,
                           Y
                           ,
                           B
                           ,
                           …
                         as meta-variables to range over lambda expressions.

We will describe an evaluation in which computations are done by successive substitutions or replacements (call-by-name). With some adjustments to the syntax it would have been possible to incorporate proper sharing, with a call-by-reference semantics in the style of [14]. Since we do not consider this extension to be essential for strictness analysis, we will describe a system without sharing.

The value V of a closed expression M is defined via a standard natural ‘big step’ operational semantics expressed as judgements of the form 
                           M
                           ⇓
                           V
                        . This evaluation will yield an (also closed) expression in head-normal form. 
                           Definition 2
                           Let 
                                 M
                                 ∈
                                 
                                    
                                       Λ
                                    
                                    
                                       o
                                    
                                 
                              .
                                 
                                    •
                                    We write 
                                          M
                                          ⇓
                                          V
                                       , and say that M evaluates to V if this statement is derivable using the rules in Fig. 1
                                       .


                                       M is defined or convergent (notation 
                                          M
                                          ⇓
                                       ) if 
                                          M
                                          ⇓
                                          V
                                        for some value V. Otherwise M is undefined or divergent 
                                       
                                          (
                                          notation
                                          
                                          M
                                          ⇑
                                          )
                                       .

The set of undefined (closed) expressions (i.e., 
                                          {
                                          M
                                          ∈
                                          
                                             
                                                Λ
                                             
                                             
                                                o
                                             
                                          
                                          |
                                          M
                                          ⇑
                                          }
                                       ) is denoted by 
                                          O
                                       .


                              
                                 M
                                 ⇓
                                 V
                               
                              and 
                              
                                 M
                                 ⇓
                                 W
                                 ⇒
                                 V
                                 =
                                 W
                              .


                        
                           O
                         contains a canonical inhabitant 
                           μ
                           x
                           .
                           x
                        , commonly denoted as 
                           ⊥
                        , that will be used to introduce finite unfoldings. 
                           Definition 3
                           Let 
                                 
                                    
                                       F
                                    
                                    
                                       x
                                    
                                 
                                 ∈
                                 
                                    
                                       Λ
                                    
                                    
                                       x
                                    
                                 
                              . The nth (finite) unfolding (notation 
                                 
                                    
                                       F
                                    
                                    
                                       x
                                    
                                    
                                       n
                                    
                                 
                              ) is defined inductively by 
                                 
                                    
                                       
                                          
                                             F
                                          
                                          
                                             x
                                          
                                          
                                             0
                                          
                                       
                                       =
                                       ⊥
                                       ,
                                       
                                       
                                          
                                             F
                                          
                                          
                                             x
                                          
                                          
                                             n
                                             +
                                             1
                                          
                                       
                                       =
                                       
                                          
                                             F
                                          
                                          
                                             x
                                          
                                       
                                       [
                                       x
                                       ←
                                       
                                          
                                             F
                                          
                                          
                                             x
                                          
                                          
                                             n
                                          
                                       
                                       ]
                                    
                                 
                              
                           

The following property (the so-called syntactical continuity property, formally proved in [19]) relates the evaluation of closed fix-expressions to the evaluation of finite unfoldings, and vice versa. 
                           Proposition 1
                           
                              Let 
                              
                                 x
                                 ,
                                 y
                                 ∈
                                 V
                              , and 
                              
                                 
                                    
                                       C
                                    
                                    
                                       y
                                    
                                 
                                 ∈
                                 
                                    
                                       Λ
                                    
                                    
                                       y
                                    
                                 
                               
                              and 
                              
                                 
                                    
                                       F
                                    
                                    
                                       x
                                    
                                 
                                 ∈
                                 
                                    
                                       Λ
                                    
                                    
                                       x
                                    
                                 
                              . 
                                 
                                    
                                       
                                          
                                             C
                                          
                                          
                                             y
                                          
                                       
                                       [
                                       y
                                       ←
                                       μ
                                       x
                                       .
                                       
                                          
                                             F
                                          
                                          
                                             x
                                          
                                       
                                       ]
                                       ⇓
                                       
                                       ⇔
                                       
                                       ∃
                                       m
                                       ≥
                                       0
                                       :
                                       
                                          
                                             C
                                          
                                          
                                             y
                                          
                                       
                                       [
                                       y
                                       ←
                                       
                                          
                                             F
                                          
                                          
                                             x
                                          
                                          
                                             m
                                          
                                       
                                       ]
                                       ⇓
                                    
                                 
                              
                           

A disadvantage of a ‘big step approach’ is that reasoning about individual evaluation steps can be awkward. To circumvent this problem the following equivalence relation appears to be useful. 
                           Definition 4
                           Two expressions 
                                 M
                                 ,
                                 N
                                 ∈
                                 
                                    
                                       Λ
                                    
                                    
                                       o
                                    
                                 
                               are reduction equivalent (notation 
                                 M
                                 
                                    
                                       =
                                    
                                    
                                       β
                                    
                                 
                                 N
                              ) if for all 
                                 H
                                 ∈
                                 
                                    
                                       Λ
                                    
                                    
                                       o
                                    
                                 
                               
                              
                                 
                                    
                                       M
                                       ⇓
                                       H
                                       
                                       ⇔
                                       
                                       N
                                       ⇓
                                       H
                                    
                                 
                              
                           

Plain strictness is usually defined as follows. 
                        Definition 5
                        Let 
                              
                                 
                                    x
                                 
                                 
                                    →
                                 
                              
                              =
                              (
                              
                                 
                                    x
                                 
                                 
                                    1
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    x
                                 
                                 
                                    n
                                 
                              
                              )
                           . An expression 
                              E
                              ∈
                              
                                 
                                    Λ
                                 
                                 
                                    
                                       
                                          x
                                       
                                       
                                          →
                                       
                                    
                                 
                              
                            is strict in x
                           
                              i
                            (
                              1
                              ≤
                              i
                              ≤
                              n
                           ) if for all 
                              
                                 
                                    A
                                 
                                 
                                    →
                                 
                              
                              ∈
                              
                                 
                                    (
                                    
                                       
                                          Λ
                                       
                                       
                                          o
                                       
                                    
                                    )
                                 
                                 
                                    n
                                 
                              
                            
                           
                              
                                 
                                    
                                       
                                          A
                                       
                                       
                                          i
                                       
                                    
                                    ⇑
                                    
                                    ⇒
                                    
                                    E
                                    [
                                    
                                       
                                          x
                                       
                                       
                                          →
                                       
                                    
                                    ←
                                    
                                       
                                          A
                                       
                                       
                                          →
                                       
                                    
                                    ]
                                    ⇑
                                 
                              
                           
                        

A drawback of this notion of strictness is the lack of compositionality: strictness of a compound expression cannot always be determined by combining strictness of its constituents. For example the expression 
                        fst
                        
                        x
                      is strict in x and the expression 
                        〈
                        x
                        ,
                        y
                        〉
                      not (and, of course, also not strict in y). However the compound expression 
                        fst
                        
                        〈
                        x
                        ,
                        y
                        〉
                      
                     is strict in x. Our aim is to refine this notion of strictness in such a way that the evaluation properties of expressions are captured more accurately. For instance, the function 
                        fst
                      not only evaluates its argument to head-normal form, but successively also evaluates the first component of the resulting pair. Moreover, the expression 
                        〈
                        x
                        ,
                        y
                        〉
                      is strict in x if it appears in a context that not only needs a pair but also the value of the first component of that pair (or of the second component to become strict in y instead of x), as is the case in our example. These evaluation contexts will be expressed as strictness types.

A strictness type is a standard type annotated with the so-called strictness attributes. The idea is to formulate strictness of E in x by a typing statement 
                           
                              
                                 x
                                 :
                                 
                                    
                                       σ
                                    
                                    
                                       !
                                    
                                 
                                 ⊢
                                 E
                                 :
                                 
                                    
                                       τ
                                    
                                    
                                       !
                                    
                                 
                              
                           
                        The refinement mentioned is accomplished by admitting attributes to more than only the outermost level of a type. For example,
                           
                              1.
                              
                                 
                                    x
                                    :
                                    
                                       
                                          (
                                          
                                             
                                                σ
                                             
                                             
                                                !
                                             
                                          
                                          ×
                                          τ
                                          )
                                       
                                       
                                          !
                                       
                                    
                                    ⊢
                                    fst
                                    
                                    x
                                    :
                                    
                                       
                                          σ
                                       
                                       
                                          !
                                       
                                    
                                 
                              


                                 
                                    x
                                    :
                                    
                                       
                                          σ
                                       
                                       
                                          !
                                       
                                    
                                    ⊢
                                    〈
                                    x
                                    ,
                                    x
                                    〉
                                    :
                                    
                                       
                                          (
                                          
                                             
                                                σ
                                             
                                             
                                                !
                                             
                                          
                                          ×
                                          σ
                                          )
                                       
                                       
                                          !
                                       
                                    
                                 
                              


                              
                                 
                                    •
                                    Let 
                                          Φ
                                          =
                                          {
                                          α
                                          ,
                                          β
                                          ,
                                          
                                             
                                                α
                                             
                                             
                                                0
                                             
                                          
                                          ,
                                          
                                             
                                                α
                                             
                                             
                                                1
                                             
                                          
                                          ,
                                          …
                                          }
                                        be an infinite set of type variables, and 
                                          A
                                          =
                                          {
                                          !
                                          ,
                                          ?
                                          }
                                        the set of strictness attributes (ranged over by meta-variables 
                                          u
                                          ,
                                          v
                                       ), 
                                          T
                                          =
                                          Σ
                                          ∪
                                          Π
                                        denotes the set strictness types. Here 
                                          Σ
                                        and 
                                          Π
                                        are defined by the following abstract syntax. 
                                          
                                             
                                                Σ
                                                ::=
                                                
                                                   
                                                      Π
                                                   
                                                   
                                                      A
                                                   
                                                
                                                Π
                                                ::=
                                                Φ
                                                |
                                                1
                                                |
                                                Σ
                                                →
                                                Σ
                                                |
                                                Σ
                                                ×
                                                Σ
                                                |
                                                Σ
                                                +
                                                Σ
                                             
                                          
                                       The outermost attribute of 
                                          S
                                          ∈
                                          Σ
                                        is denoted by 
                                          [
                                          S
                                          ]
                                       . Moreover, 
                                          ⌊
                                          S
                                          ⌋
                                        denotes the type obtained from S by removing the outermost attribute. Hence, 
                                          
                                             
                                                ⌊
                                                S
                                                ⌋
                                             
                                             
                                                [
                                                S
                                                ]
                                             
                                          
                                          =
                                          S
                                       .

To avoid brackets, we will write 
                                          
                                             
                                                (
                                                …
                                                →
                                                …
                                                )
                                             
                                             
                                                u
                                             
                                          
                                        as 
                                          …
                                          
                                             
                                                →
                                             
                                             
                                                u
                                             
                                          
                                          …
                                        .

Let 
                                          |
                                          T
                                          |
                                        denote the ‘stripped’ version of T, i.e., T without any strictness attributes. We consider two types 
                                          
                                             
                                                T
                                             
                                             
                                                1
                                             
                                          
                                          ,
                                          
                                             
                                                T
                                             
                                             
                                                2
                                             
                                          
                                        as equivalent (notation 
                                          
                                             
                                                T
                                             
                                             
                                                1
                                             
                                          
                                          ~
                                          
                                             
                                                T
                                             
                                             
                                                2
                                             
                                          
                                       ) if 
                                          |
                                          
                                             
                                                T
                                             
                                             
                                                1
                                             
                                          
                                          |
                                          ≡
                                          |
                                          
                                             
                                                T
                                             
                                             
                                                2
                                             
                                          
                                          |
                                       . So, types are equivalent if their underlying standard types are identical.


                              
                                 
                                    •
                                    Strictness attributes are ordered as follows: 
                                          !
                                          ≤
                                          ?
                                       
                                    

This ordering on attributes induces the following coercion relation on 
                                          T
                                       . 
                                          
                                             
                                                
                                                   
                                                      
                                                         u
                                                         ≤
                                                         v
                                                         
                                                         and
                                                         
                                                         σ
                                                         ≤
                                                         τ
                                                      
                                                      
                                                         ⇒
                                                      
                                                      
                                                         
                                                            
                                                               σ
                                                            
                                                            
                                                               u
                                                            
                                                         
                                                         ≤
                                                         
                                                            
                                                               τ
                                                            
                                                            
                                                               v
                                                            
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         1
                                                         ≤
                                                         1
                                                      
                                                      
                                                   
                                                   
                                                      
                                                      
                                                         α
                                                         ≤
                                                         α
                                                      
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            
                                                               S
                                                            
                                                            
                                                               1
                                                            
                                                         
                                                         ≤
                                                         
                                                            
                                                               S
                                                            
                                                            
                                                               2
                                                            
                                                         
                                                         
                                                         and
                                                         
                                                         
                                                            
                                                               T
                                                            
                                                            
                                                               1
                                                            
                                                         
                                                         ≤
                                                         
                                                            
                                                               T
                                                            
                                                            
                                                               2
                                                            
                                                         
                                                      
                                                      
                                                         
                                                         ⇒
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               S
                                                            
                                                            
                                                               2
                                                            
                                                         
                                                         →
                                                         
                                                            
                                                               T
                                                            
                                                            
                                                               1
                                                            
                                                         
                                                         ≤
                                                         
                                                            
                                                               S
                                                            
                                                            
                                                               1
                                                            
                                                         
                                                         →
                                                         
                                                            
                                                               T
                                                            
                                                            
                                                               2
                                                            
                                                         
                                                         
                                                         and
                                                      
                                                   
                                                   
                                                      
                                                      
                                                      
                                                         
                                                            
                                                               S
                                                            
                                                            
                                                               1
                                                            
                                                         
                                                         ×
                                                         
                                                            
                                                               T
                                                            
                                                            
                                                               1
                                                            
                                                         
                                                         ≤
                                                         
                                                            
                                                               S
                                                            
                                                            
                                                               2
                                                            
                                                         
                                                         ×
                                                         
                                                            
                                                               T
                                                            
                                                            
                                                               2
                                                            
                                                         
                                                         
                                                         and
                                                      
                                                   
                                                   
                                                      
                                                      
                                                      
                                                         
                                                            
                                                               S
                                                            
                                                            
                                                               1
                                                            
                                                         
                                                         +
                                                         
                                                            
                                                               T
                                                            
                                                            
                                                               1
                                                            
                                                         
                                                         ≤
                                                         
                                                            
                                                               S
                                                            
                                                            
                                                               2
                                                            
                                                         
                                                         +
                                                         
                                                            
                                                               T
                                                            
                                                            
                                                               2
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       Note the contravariance in the first argument of 
                                          →
                                       .

The infimum of two attributes 
                                          u
                                          ,
                                          v
                                        (notation 
                                          u
                                          ⊓
                                          v
                                       ) is the minimum of 
                                          u
                                          ,
                                          v
                                        w.r.t. 
                                          ≤
                                       .

The predicate 
                                          inf
                                        on 
                                          (
                                          T
                                          ,
                                          T
                                          ,
                                          T
                                          )
                                        is defined by induction: 
                                          
                                             
                                                inf
                                                (
                                                
                                                   
                                                      σ
                                                   
                                                   
                                                      u
                                                   
                                                
                                                ,
                                                
                                                   
                                                      τ
                                                   
                                                   
                                                      v
                                                   
                                                
                                                ,
                                                
                                                   
                                                      ρ
                                                   
                                                   
                                                      w
                                                   
                                                
                                                )
                                                =
                                                u
                                                =
                                                v
                                                ⊓
                                                w
                                                
                                                and
                                                
                                                inf
                                                (
                                                σ
                                                ,
                                                τ
                                                ,
                                                ρ
                                                )
                                                inf
                                                (
                                                α
                                                ,
                                                α
                                                ,
                                                α
                                                )
                                                =
                                                true
                                                inf
                                                (
                                                1
                                                ,
                                                1
                                                ,
                                                1
                                                )
                                                =
                                                true
                                                inf
                                                (
                                                S
                                                →
                                                T
                                                ,
                                                
                                                   
                                                      S
                                                   
                                                   
                                                      1
                                                   
                                                
                                                →
                                                
                                                   
                                                      T
                                                   
                                                   
                                                      1
                                                   
                                                
                                                ,
                                                
                                                   
                                                      S
                                                   
                                                   
                                                      2
                                                   
                                                
                                                →
                                                
                                                   
                                                      T
                                                   
                                                   
                                                      2
                                                   
                                                
                                                )
                                                =
                                                S
                                                =
                                                
                                                   
                                                      S
                                                   
                                                   
                                                      1
                                                   
                                                
                                                =
                                                
                                                   
                                                      S
                                                   
                                                   
                                                      2
                                                   
                                                
                                                
                                                and
                                                
                                                T
                                                =
                                                
                                                   
                                                      T
                                                   
                                                   
                                                      1
                                                   
                                                
                                                =
                                                
                                                   
                                                      T
                                                   
                                                   
                                                      2
                                                   
                                                
                                                inf
                                                (
                                                S
                                                ×
                                                T
                                                ,
                                                
                                                   
                                                      S
                                                   
                                                   
                                                      1
                                                   
                                                
                                                ×
                                                
                                                   
                                                      T
                                                   
                                                   
                                                      1
                                                   
                                                
                                                ,
                                                
                                                   
                                                      S
                                                   
                                                   
                                                      2
                                                   
                                                
                                                ×
                                                
                                                   
                                                      T
                                                   
                                                   
                                                      2
                                                   
                                                
                                                )
                                                =
                                                inf
                                                (
                                                S
                                                ,
                                                
                                                   
                                                      S
                                                   
                                                   
                                                      1
                                                   
                                                
                                                ,
                                                
                                                   
                                                      S
                                                   
                                                   
                                                      2
                                                   
                                                
                                                )
                                                
                                                and
                                                
                                                inf
                                                (
                                                T
                                                ,
                                                
                                                   
                                                      T
                                                   
                                                   
                                                      1
                                                   
                                                
                                                ,
                                                
                                                   
                                                      T
                                                   
                                                   
                                                      2
                                                   
                                                
                                                )
                                                inf
                                                (
                                                S
                                                +
                                                T
                                                ,
                                                
                                                   
                                                      S
                                                   
                                                   
                                                      1
                                                   
                                                
                                                +
                                                
                                                   
                                                      T
                                                   
                                                   
                                                      1
                                                   
                                                
                                                ,
                                                
                                                   
                                                      S
                                                   
                                                   
                                                      2
                                                   
                                                
                                                +
                                                
                                                   
                                                      T
                                                   
                                                   
                                                      2
                                                   
                                                
                                                )
                                                =
                                                inf
                                                (
                                                S
                                                ,
                                                
                                                   
                                                      S
                                                   
                                                   
                                                      1
                                                   
                                                
                                                ,
                                                
                                                   
                                                      S
                                                   
                                                   
                                                      2
                                                   
                                                
                                                )
                                                
                                                and
                                                
                                                inf
                                                (
                                                T
                                                ,
                                                
                                                   
                                                      T
                                                   
                                                   
                                                      1
                                                   
                                                
                                                ,
                                                
                                                   
                                                      T
                                                   
                                                   
                                                      2
                                                   
                                                
                                                )
                                                inf
                                                (
                                                ·
                                                ,
                                                ·
                                                ,
                                                ·
                                                )
                                                =
                                                false
                                             
                                          
                                       The last rule should only be used if none of the other rules applies, i.e.if 
                                          
                                             
                                                t
                                             
                                             
                                                1
                                             
                                          
                                          ,
                                          
                                             
                                                t
                                             
                                             
                                                2
                                             
                                          
                                        and t
                                       3 are not equivalent.

The meaning of a (strictness) type S is formalized by interpreting S as a subset of 
                           
                              
                                 Λ
                              
                              
                                 o
                              
                           
                        . The ‘standard’ interpretation 
                           〚
                           S
                           〛
                         contains all expressions that either evaluate to a value of type 
                           |
                           S
                           |
                         or diverge. For example 
                           〚
                           
                              
                                 (
                                 
                                    
                                       1
                                    
                                    
                                       u
                                    
                                 
                                 ×
                                 
                                    
                                       1
                                    
                                    
                                       v
                                    
                                 
                                 )
                              
                              
                                 w
                              
                           
                           〛
                         (the standard interpretation does not depend on concrete attribute values) contains all expressions that are either in 
                           O
                         or evaluate to 
                           〈
                           □
                           ,
                           □
                           〉
                        , 
                           〈
                           □
                           ,-
                           〉
                         or to 
                           〈
                           -,
                           □
                           〉
                        . Here, we use 
                           -
                         to indicate that the corresponding expression diverges. 
                           Definition 8
                           Standard type interpretation


                           
                              
                                 
                                    •
                                    Let 
                                          A
                                          ,
                                          B
                                          ⊆
                                          
                                             
                                                Λ
                                             
                                             
                                                o
                                             
                                          
                                       . 
                                          
                                             
                                                
                                                   
                                                      1
                                                   
                                                   
                                                      ̲
                                                   
                                                
                                                =
                                                {
                                                M
                                                ∈
                                                
                                                   
                                                      Λ
                                                   
                                                   
                                                      o
                                                   
                                                
                                                |
                                                M
                                                ⇓
                                                □
                                                }
                                                A
                                                
                                                   
                                                      ×
                                                   
                                                   
                                                      ̲
                                                   
                                                
                                                B
                                                =
                                                {
                                                M
                                                ∈
                                                
                                                   
                                                      Λ
                                                   
                                                   
                                                      o
                                                   
                                                
                                                |
                                                ∃
                                                a
                                                ∈
                                                A
                                                ,
                                                b
                                                ∈
                                                B
                                                :
                                                M
                                                ⇓
                                                〈
                                                a
                                                ,
                                                b
                                                〉
                                                }
                                                A
                                                
                                                   
                                                      +
                                                   
                                                   
                                                      ̲
                                                   
                                                
                                                B
                                                =
                                                {
                                                M
                                                ∈
                                                
                                                   
                                                      Λ
                                                   
                                                   
                                                      o
                                                   
                                                
                                                |
                                                ∃
                                                a
                                                ∈
                                                A
                                                :
                                                M
                                                ⇓
                                                inl
                                                
                                                a
                                                
                                                or
                                                
                                                ∃
                                                b
                                                ∈
                                                B
                                                :
                                                M
                                                ⇓
                                                inr
                                                
                                                b
                                                }
                                                A
                                                
                                                   
                                                      →
                                                   
                                                   
                                                      ̲
                                                   
                                                
                                                B
                                                =
                                                {
                                                M
                                                ∈
                                                
                                                   
                                                      Λ
                                                   
                                                   
                                                      o
                                                   
                                                
                                                |
                                                ∀
                                                a
                                                ∈
                                                A
                                                :
                                                (
                                                M
                                                
                                                a
                                                )
                                                ∈
                                                B
                                                }
                                             
                                          
                                       
                                    

The interpretation 
                                          〚
                                          S
                                          〛
                                        is inductively defined in Fig. 2
                                       .

For strictness types, we will need two more interpretations: 
                           〚
                           ·
                           
                              
                                 〛
                              
                              
                                 ?
                              
                           
                         and 
                           〚
                           ·
                           
                              
                                 〛
                              
                              
                                 !
                              
                           
                        . Let S be a strictness type S. Then 
                           〚
                           S
                           
                              
                                 〛
                              
                              
                                 ?
                              
                           
                         denotes all expressions that inhabit type 
                           |
                           S
                           |
                        , including 
                           O
                        . 
                           〚
                           S
                           
                              
                                 〛
                              
                              
                                 !
                              
                           
                         denotes the set of expressions that diverge when used in a context with type S. For instance, 
                           〚
                           
                              
                                 1
                              
                              
                                 !
                              
                           
                           
                              
                                 〛
                              
                              
                                 ?
                              
                           
                         contains all expressions that either evaluate to 
                           □
                         or diverge. 
                           〚
                           
                              
                                 1
                              
                              
                                 ?
                              
                           
                           
                              
                                 〛
                              
                              
                                 ?
                              
                           
                         is the same set. 
                           〚
                           
                              
                                 1
                              
                              
                                 !
                              
                           
                           
                              
                                 〛
                              
                              
                                 !
                              
                           
                         is equal to 
                           O
                        , whereas 
                           〚
                           
                              
                                 1
                              
                              
                                 ?
                              
                           
                           
                              
                                 〛
                              
                              
                                 !
                              
                           
                         is empty, since type 
                           
                              
                                 1
                              
                              
                                 ?
                              
                           
                         used in the latter corresponds to a lazy context. Slightly more complicated is the following example in which we take 
                           
                              
                                 (
                                 
                                    
                                       1
                                    
                                    
                                       !
                                    
                                 
                                 +
                                 
                                    
                                       1
                                    
                                    
                                       ?
                                    
                                 
                                 )
                              
                              
                                 !
                              
                           
                         as S. Now 
                           〚
                           S
                           
                              
                                 〛
                              
                              
                                 ?
                              
                           
                         contains all expressions that either diverge or evaluate to 
                           inl
                           
                           I
                         or to 
                           inl
                           
                           R
                        , with 
                           I
                           ∈
                           〚
                           
                              
                                 1
                              
                              
                                 !
                              
                           
                           
                              
                                 〛
                              
                              
                                 ?
                              
                           
                           ,
                           R
                           ∈
                           〚
                           
                              
                                 1
                              
                              
                                 ?
                              
                           
                           
                              
                                 〛
                              
                              
                                 ?
                              
                           
                        . 
                           〚
                           S
                           
                              
                                 〛
                              
                              
                                 !
                              
                           
                        , however, contains besides all divergent expressions only expressions evaluating to 
                           inl
                           
                           I
                        , with 
                           I
                           ∈
                           〚
                           
                              
                                 1
                              
                              
                                 !
                              
                           
                           
                              
                                 〛
                              
                              
                                 !
                              
                           
                           =
                           O
                        . The case 
                           inl
                           
                           R
                         is impossible since this would require that 
                           R
                           ∈
                           〚
                           
                              
                                 1
                              
                              
                                 ?
                              
                           
                           
                              
                                 〛
                              
                              
                                 !
                              
                           
                           =
                           ∅
                        . 
                           Definition 9
                           Strictness type interpretation


                           The interpretations 
                                 〚
                                 S
                                 
                                    
                                       〛
                                    
                                    
                                       ?
                                    
                                 
                               and 
                                 〚
                                 S
                                 
                                    
                                       〛
                                    
                                    
                                       !
                                    
                                 
                               are defined by mutual induction in Fig. 3
                              .

The interpretations 
                           〚
                           ·
                           〛
                         and 
                           〚
                           ·
                           
                              
                                 〛
                              
                              
                                 ?
                              
                           
                         are almost identical. They only differ in the way function types are treated. The function 
                           λ
                           x
                           .
                           □
                        , for instance, is a member of 
                           〚
                           
                              
                                 α
                              
                              
                                 !
                              
                           
                           
                              
                                 →
                              
                              
                                 !
                              
                           
                           
                              
                                 1
                              
                              
                                 !
                              
                           
                           〛
                        , but not a member of 
                           〚
                           
                              
                                 α
                              
                              
                                 !
                              
                           
                           
                              
                                 →
                              
                              
                                 !
                              
                           
                           
                              
                                 1
                              
                              
                                 !
                              
                           
                           
                              
                                 〛
                              
                              
                                 ?
                              
                           
                        . The latter is due to the additional requirement that any expression 
                           E
                           ∈
                           〚
                           
                              
                                 α
                              
                              
                                 !
                              
                           
                           →
                           
                              
                                 1
                              
                              
                                 !
                              
                           
                           
                              
                                 〛
                              
                              
                                 ?
                              
                           
                         should also be a member of 
                           〚
                           
                              
                                 α
                              
                              
                                 !
                              
                           
                           
                              
                                 〛
                              
                              
                                 !
                              
                           
                           
                              
                                 →
                              
                              
                                 ̲
                              
                           
                           〚
                           
                              
                                 1
                              
                              
                                 !
                              
                           
                           
                              
                                 〛
                              
                              
                                 !
                              
                           
                        , which is not the case for 
                           λ
                           x
                           .
                           □
                        : if we substitute 
                           ⊥
                         (
                           ∈
                           〚
                           
                              
                                 α
                              
                              
                                 !
                              
                           
                           
                              
                                 〛
                              
                              
                                 !
                              
                           
                        ) for x we get 
                           □
                         as a result which is not an element of 
                           〚
                           
                              
                                 1
                              
                              
                                 !
                              
                           
                           
                              
                                 〛
                              
                              
                                 !
                              
                           
                           =
                           O
                        . We will elaborate further on this issue in Section 5.

The following property (based on finite unfoldings, see Definition 3) provides an induction scheme for proofs in which fixed point expressions are involved; e.g., see Theorem 1. 
                           Proposition 2
                           
                              Let 
                              
                                 T
                                 ∈
                                 T
                              , and 
                              
                                 x
                                 ∈
                                 V
                                 ,
                                 
                                    
                                       F
                                    
                                    
                                       x
                                    
                                 
                                 ∈
                                 
                                    
                                       Λ
                                    
                                    
                                       x
                                    
                                 
                              . Then, for all 
                              
                                 s
                                 ∈
                                 {
                                 !
                                 ,
                                 ?
                                 }
                               
                              
                                 
                                    
                                       (
                                       ∀
                                       n
                                       ∈
                                       N
                                       :
                                       
                                          
                                             F
                                          
                                          
                                             x
                                          
                                          
                                             n
                                          
                                       
                                       ∈
                                       〚
                                       T
                                       〛
                                       s
                                       )
                                       
                                       ⇒
                                       
                                       μ
                                       x
                                       .
                                       
                                          
                                             F
                                          
                                          
                                             x
                                          
                                       
                                       ∈
                                       〚
                                       T
                                       〛
                                       s
                                    
                                 
                              
                           

The proof of this property in which Proposition 1 plays a crucial role is quite complex. In PVS it necessitates approximately 1000 proof steps in addition to several non-trivial helper lemmas. The complexity is caused by the fact that our purely syntactical approach requires tedious manipulations of various constructs. In a formalization on paper this would have been barely feasible.

Both interpretations are closed under beta-equivalence. 
                           Proposition 3
                           
                              Let 
                              
                                 M
                                 
                                    
                                       =
                                    
                                    
                                       β
                                    
                                 
                                 N
                              . Then, for all strictness types T, and 
                              
                                 s
                                 ∈
                                 {
                                 !
                                 ,
                                 ?
                                 }
                              : 
                                 
                                    
                                       M
                                       ∈
                                       〚
                                       T
                                       〛
                                       s
                                       
                                       ⇔
                                       
                                       N
                                       ∈
                                       〚
                                       T
                                       〛
                                       s
                                    
                                 
                              
                           

In this section we present a type system for deriving strictness information of terms and formally prove that this system is sound. Soundness here means that if a term M can be typed with strictness type S, then indeed M is a member of both 
                        〚
                        S
                        
                           
                              〛
                           
                           
                              ?
                           
                        
                      and 
                        〚
                        S
                        
                           
                              〛
                           
                           
                              !
                           
                        
                     . In essence, strictness typing can be characterized as a backwards analysis (e.g., see [8]): strictness properties are determined by relating the effect of demands on the arguments to the effect of demands on the result. 
                        Definition 10
                        
                           
                              
                                 •
                                 A basis (or environment) is a finite set of declarations of the form 
                                       x
                                       :
                                       S
                                    , where 
                                       x
                                       ∈
                                       V
                                       ,
                                       S
                                       ∈
                                       T
                                    . For a given basis, all variables are assumed to be distinct. We will sometimes use the ‘functional notation’ 
                                       Γ
                                       (
                                       x
                                       )
                                     to obtain the type assigned to x by 
                                       Γ
                                    .

By 
                                       
                                          
                                             Γ
                                          
                                          
                                             ?
                                          
                                       
                                     we denote a lazy basis containing only declarations of the form 
                                       x
                                       :
                                       
                                          
                                             σ
                                          
                                          
                                             ?
                                          
                                       
                                    .

Two bases 
                                       
                                          
                                             Γ
                                          
                                          
                                             1
                                          
                                       
                                       ,
                                       
                                          
                                             Γ
                                          
                                          
                                             2
                                          
                                       
                                     are equivalent, denoted as 
                                       
                                          
                                             Γ
                                          
                                          
                                             1
                                          
                                       
                                       ~
                                       
                                          
                                             Γ
                                          
                                          
                                             2
                                          
                                       
                                    , if for each x one has 
                                       
                                          
                                             Γ
                                          
                                          
                                             1
                                          
                                       
                                       (
                                       x
                                       )
                                       ~
                                       
                                          
                                             Γ
                                          
                                          
                                             2
                                          
                                       
                                       (
                                       x
                                       )
                                    .

The 
                                       inf
                                     predicate for types extends to (equivalent) bases in a straightforward manner: Let 
                                       Γ
                                       ~
                                       
                                          
                                             Γ
                                          
                                          
                                             1
                                          
                                       
                                       ~
                                       
                                          
                                             Γ
                                          
                                          
                                             2
                                          
                                       
                                    . Then 
                                       inf
                                       (
                                       Γ
                                       ,
                                       
                                          
                                             Γ
                                          
                                          
                                             1
                                          
                                       
                                       ,
                                       
                                          
                                             Γ
                                          
                                          
                                             2
                                          
                                       
                                       )
                                     if 
                                       inf
                                       (
                                       Γ
                                       (
                                       x
                                       )
                                       ,
                                       
                                          
                                             Γ
                                          
                                          
                                             1
                                          
                                       
                                       (
                                       x
                                       )
                                       ,
                                       
                                          
                                             Γ
                                          
                                          
                                             2
                                          
                                       
                                       (
                                       x
                                       )
                                       )
                                     for all x.

A strictness typing statement is an expression of the form 
                              Γ
                              ⊢
                              M
                              :
                              S
                           , where 
                              Γ
                            is a basis. Such a statement is valid if it can be derived by using the rules in Fig. 4
                           .

We briefly focus on these derivation rules. One should recall that in each of these rules strictness can only appear if the context type, as given by the conclusion, is strict itself. As such, one could say that ‘strictness propagates outwards’.

The rule for variables (var) enforces that each strictness assumption 
                        x
                        :
                        
                           
                              σ
                           
                           
                              !
                           
                        
                      in the environment should be ‘consumed’ by a strict occurrence of x (otherwise, the premise of this rule cannot be valid). Since unit (unit) represents the result of a computation (an expression in head normal form), the complete basis has to be lazy. In the rule for application (app), the function expression is always evaluated (provided that the application itself appears in a strict context), explaining the 
                        [
                        R
                        ]
                      attribute on the arrow. The inequality 
                        [
                        R
                        ]
                        ≤
                        [
                        S
                        ]
                      ensures that the argument can only be strict if the context is strict. In essence, this abstraction rule (abs) reflects the characterisation of strictness as indicated at the beginning of Section 3.1. The data constructor rules (pair, inl, inr) all involve expressions in head normal form. Strictness properties for expressions appearing under these constructors are directly adopted from their corresponding context type. The typing rules for projections (fst, snd) have already been discussed at the beginning of the previous section. The case-rule (case) is more subtle. Recall that the evaluation of an expression 
                        case
                        
                        I
                        
                        of
                        
                        L
                        
                        or
                        
                        R
                      results in the evaluation of I first (explaining the attribute 
                        [
                        U
                        ]
                      on the corresponding sum type), followed by the evaluation of either L (applied to the left component of the result of I) or R (applied to the right component), but not both. So 
                        case
                        
                        I
                        
                        of
                        
                        L
                        
                        or
                        
                        R
                      can only be strict in a variable x if either I is strict in x or both L and R are strict in x. The latter is accomplished by supplying the type derivations L and R with the same basis Γ
                     2. In the case of a recursive definition (fix), say of x, all occurrences of x are not necessarily strict. Indeed, x itself will often appear in a lazy context. This explains the inequality 
                        S
                        ≤
                        T
                     .

To prepare for type inference, the type assignment system is formulated in a fully syntax directed fashion. As such, non-structural rules, such as contraction, subsumption and weakening (that are usually defined separately), have been incorporated in the structural rules of the system.

As an example, a strictness type derivation for the expression 
                        λ
                        x
                        .
                        λ
                        y
                        .
                        x
                      is given in Fig. 5
                     . More examples can be found in Section 6.

In this section we demonstrate that our typing system is sound. As previously stated, plain strictness is formulated solely in terms of undefinedness of a function argument as a consequence of undefinedness of the function result. However in our system strictness properties of function arguments can influence each other. Consider, for example, the function 
                        AP
                        =
                        λ
                        f
                        .
                        λ
                        x
                        .
                        f
                        
                        x
                     . Then strictness of 
                        AP
                      in x depends on the strictness properties of the other argument f. If 
                        AP
                      is applied to a strict function then the result will be strict in x. This is expressed by the following valid strictness typing for 
                        AP
                     
                     
                        2
                     
                     
                        2
                        For clarity, we have omitted the strictness attributes on the arrows. A full typing can be found in Lemma 2.
                      
                     
                        
                           
                              AP
                              ::
                              (
                              
                                 
                                    α
                                 
                                 
                                    !
                                 
                              
                              →
                              
                                 
                                    β
                                 
                                 
                                    !
                                 
                              
                              )
                              →
                              
                                 
                                    α
                                 
                                 
                                    !
                                 
                              
                              →
                              
                                 
                                    β
                                 
                                 
                                    !
                                 
                              
                           
                        
                     At this point it is important to see that Definition 5 is no longer adequate: whether 
                        AP
                        
                        F
                        
                        ⊥
                        ⇑
                      also depends on F. More specifically, F should be a strict function, and not just any arbitrary expression as in Definition 5. E.g., if we take 
                        λ
                        x
                        .
                        □
                      for F then 
                        AP
                        
                        F
                        
                        ⊥
                        ⇓
                        □
                     . 
                        Definition 12
                        
                           
                              
                                 •
                                 An expression environment is a function ρ from 
                                       V
                                     to 
                                       
                                          
                                             Λ
                                          
                                          
                                             o
                                          
                                       
                                    . Such an environment can be lifted to 
                                       Λ
                                     in the obvious way. The result of applying ρ to an expression E is denoted by 
                                       
                                          
                                             E
                                          
                                          
                                             ρ
                                          
                                       
                                    .

Let 
                                       Γ
                                     be a basis. An environment ρ is valid for 
                                    
                                       Γ
                                     (notation 
                                       ρ
                                       ⊩
                                       Γ
                                    ), if 
                                       ∀
                                       (
                                       x
                                       :
                                       S
                                       )
                                       ∈
                                       Γ
                                       :
                                       ρ
                                       (
                                       x
                                       )
                                       ∈
                                       〚
                                       S
                                       
                                          
                                             〛
                                          
                                          
                                             ?
                                          
                                       
                                    .

Similarly, ρ satisfies 
                                    
                                       Γ
                                     (notation 
                                       ρ
                                       ⊪
                                       Γ
                                    ) if 
                                       ∃
                                       (
                                       x
                                       :
                                       S
                                       )
                                       ∈
                                       Γ
                                       :
                                       ρ
                                       (
                                       x
                                       )
                                       ∈
                                       〚
                                       S
                                       
                                          
                                             〛
                                          
                                          
                                             !
                                          
                                       
                                    
                                 

Now the soundness of the type system (with respect to the semantics given in Definition 9) can be formulated as follows: 
                        Theorem 1
                        
                           
                              
                                 
                                    Γ
                                    ⊢
                                    E
                                    :
                                    S
                                    
                                    ⇒
                                    
                                    ∀
                                    ρ
                                    :
                                    ρ
                                    ⊩
                                    Γ
                                    
                                    ⇒
                                    
                                    {
                                    
                                       
                                          
                                             
                                             
                                             
                                                
                                                   
                                                      E
                                                   
                                                   
                                                      ρ
                                                   
                                                
                                                ∈
                                                〚
                                                S
                                                
                                                   
                                                      〛
                                                   
                                                   
                                                      ?
                                                   
                                                
                                             
                                             
                                                (
                                                1
                                                )
                                             
                                          
                                          
                                             
                                                ρ
                                                ⊪
                                                Γ
                                             
                                             
                                                
                                                ⇒
                                                
                                             
                                             
                                                
                                                   
                                                      E
                                                   
                                                   
                                                      ρ
                                                   
                                                
                                                ∈
                                                〚
                                                S
                                                
                                                   
                                                      〛
                                                   
                                                   
                                                      !
                                                   
                                                
                                             
                                             
                                                (
                                                2
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

Observe that conclusion (2) is essentially a reformulation of Definition 5. The problem about the strictness dependencies between arguments is solved by allowing only valid environments. Take, for instance, the expression 
                        fx
                      being the body of the 
                        AP
                      function in the above example. A possible strictness typing (in which we have substituted 
                        1
                      for both α and β) for this expression is 
                        
                           
                              f
                              :
                              
                                 
                                    1
                                 
                                 
                                    !
                                 
                              
                              
                                 
                                    →
                                 
                                 
                                    !
                                 
                              
                              
                                 
                                    1
                                 
                                 
                                    !
                                 
                              
                              ,
                              x
                              :
                              
                                 
                                    1
                                 
                                 
                                    !
                                 
                              
                              ⊢
                              f
                              
                              x
                              :
                              
                                 
                                    1
                                 
                                 
                                    !
                                 
                              
                           
                        
                     Soundness of this typing requires that any environment ρ for 
                        fx
                      should be both valid for and satisfying 
                        Γ
                        =
                        f
                        :
                        
                           
                              1
                           
                           
                              !
                           
                        
                        
                           
                              →
                           
                           
                              !
                           
                        
                        
                           
                              1
                           
                           
                              !
                           
                        
                        ,
                        x
                        :
                        
                           
                              1
                           
                           
                              !
                           
                        
                     . If such a ρ substitutes 
                        ⊥
                      for x it indeed satisfies 
                        Γ
                     , since 
                        ⊥
                        ∈
                        〚
                        
                           
                              1
                           
                           
                              !
                           
                        
                        
                           
                              〛
                           
                           
                              !
                           
                        
                     . However, the validity of ρ prohibits 
                        λ
                        x
                        .
                        □
                      to be substituted for f, because 
                        λ
                        x
                        .
                        □
                      is not a member of 
                        〚
                        
                           
                              1
                           
                           
                              !
                           
                        
                        
                           
                              →
                           
                           
                              !
                           
                        
                        
                           
                              1
                           
                           
                              !
                           
                        
                        
                           
                              〛
                           
                           
                              ?
                           
                        
                     , since 
                        λ
                        x
                        .
                        □
                        ∉
                        〚
                        
                           
                              1
                           
                           
                              !
                           
                        
                        
                           
                              〛
                           
                           
                              !
                           
                        
                        
                           
                              →
                           
                           
                              ̲
                           
                        
                        〚
                        
                           
                              1
                           
                           
                              !
                           
                        
                        
                           
                              〛
                           
                           
                              !
                           
                        
                     ; see Definition 9.

In this section we discuss the formalization of the strictness typing system and its soundness proof in PVS.

We will not assume any preliminary knowledge about PVS and, as in the previous sections, continue to use tool independent notations. The actual formalization is straightforward and barely uses PVS specific constructs. Therefore, it should be relatively easy to convert our PVS specification to other proof assistants like Coq or Isabelle.

Firstly, it must be determined how to represent the variable bindings occurring in abstraction and fixed point expressions. We have chosen the De Bruijn notation mainly because our previous work uses the same representation and the system in this paper does not require significant fine-tuning. In the De Bruijn notation variables are identified by indices: natural numbers indicating the number of abstractions which must be skipped in order to localize the corresponding binder. If the variable number exceeds the number of surrounding abstractions, the variable is considered free. 
                        Definition 13
                        
                           
                              
                                 •
                                 The set 
                                       
                                          
                                             Λ
                                          
                                          
                                             B
                                          
                                       
                                     of lambda terms with the De Bruijn indices is defined by the following abstract syntax: 
                                       
                                          
                                             
                                                
                                                   Λ
                                                
                                                
                                                   B
                                                
                                             
                                             ::=
                                             N
                                             |
                                             □
                                             |
                                             λ
                                             
                                                
                                                   Λ
                                                
                                                
                                                   B
                                                
                                             
                                             |
                                             
                                                
                                                   Λ
                                                
                                                
                                                   B
                                                
                                             
                                             
                                             
                                                
                                                   Λ
                                                
                                                
                                                   B
                                                
                                             
                                             |
                                             〈
                                             
                                                
                                                   Λ
                                                
                                                
                                                   B
                                                
                                             
                                             ,
                                             
                                                
                                                   Λ
                                                
                                                
                                                   B
                                                
                                             
                                             〉
                                             |
                                             fst
                                             
                                             
                                                
                                                   Λ
                                                
                                                
                                                   B
                                                
                                             
                                             |
                                             snd
                                             
                                             
                                                
                                                   Λ
                                                
                                                
                                                   B
                                                
                                             
                                             |
                                             
                                             inl
                                             
                                             
                                                
                                                   Λ
                                                
                                                
                                                   B
                                                
                                             
                                             |
                                             inr
                                             
                                             
                                                
                                                   Λ
                                                
                                                
                                                   B
                                                
                                             
                                             |
                                             case
                                             
                                             
                                                
                                                   Λ
                                                
                                                
                                                   B
                                                
                                             
                                             
                                             of
                                             
                                             
                                                
                                                   Λ
                                                
                                                
                                                   B
                                                
                                             
                                             
                                             or
                                             
                                             
                                                
                                                   Λ
                                                
                                                
                                                   B
                                                
                                             
                                             |
                                             μ
                                             
                                                
                                                   Λ
                                                
                                                
                                                   B
                                                
                                             
                                          
                                       
                                    
                                 

The predicate 
                                       
                                          
                                             closed
                                          
                                          
                                             n
                                          
                                       
                                       (
                                       M
                                       )
                                     checks whether none of the free variables of M exceeds n. The definition of this predicate is obvious.

With the De Bruijn notation one can avoid alpha-conversion during evaluation. However, the substitution itself is more complicated because one has to prevent that in 
                        M
                        [
                        x
                        ←
                        N
                        ]
                      the free variables of a N get captured by the binders of M. This mandates an adjustment of the free variables of M. Usually the correction of N is performed by an auxiliary function, whereas M is adjusted on-the-fly (e.g., see [13] for a formal definition of these operations).

The soundness property is formulated almost in exactly the same way as Theorem 1. We have proved (1) and (2) in this theorem simultaneously by induction on the derivation of 
                        Γ
                        ⊢
                        E
                        :
                        S
                     . The different cases require on average 200 proof steps each, which sums up to approximately 2200 steps all together.
                        3
                     
                     
                        3
                        The complete proof files can be downloaded from www.cs.ru.nl/~jakie/papers/strictnesstyping/.
                     
                  

One of the advantages of having a full formalization is that one can actually prove that examples are indeed correct explaining why we have formulated them as a lemma. 
                        Lemma 2
                        
                           
                              
                                 1.
                                 
                                    
                                       λ
                                       x
                                       .
                                       λ
                                       y
                                       .
                                       x
                                       :
                                       
                                          
                                             α
                                          
                                          
                                             !
                                          
                                       
                                       
                                          
                                             →
                                          
                                          
                                             !
                                          
                                       
                                       
                                          
                                             β
                                          
                                          
                                             ?
                                          
                                       
                                       
                                          
                                             →
                                          
                                          
                                             !
                                          
                                       
                                       
                                          
                                             α
                                          
                                          
                                             !
                                          
                                       
                                    .


                                    
                                       λ
                                       f
                                       .
                                       λ
                                       x
                                       .
                                       f
                                       
                                       x
                                       :
                                       (
                                       
                                          
                                             α
                                          
                                          
                                             !
                                          
                                       
                                       
                                          
                                             →
                                          
                                          
                                             !
                                          
                                       
                                       
                                          
                                             β
                                          
                                          
                                             !
                                          
                                       
                                       )
                                       
                                          
                                             →
                                          
                                          
                                             !
                                          
                                       
                                       
                                          
                                             α
                                          
                                          
                                             !
                                          
                                       
                                       
                                          
                                             →
                                          
                                          
                                             !
                                          
                                       
                                       
                                          
                                             β
                                          
                                          
                                             !
                                          
                                       
                                    .


                                    
                                       μ
                                       f
                                       .
                                       λ
                                       n
                                       .
                                       case
                                       
                                       n
                                       
                                       of
                                       
                                       λ
                                       x
                                       .
                                       inl
                                       
                                       □
                                       
                                       or
                                       
                                       λ
                                       x
                                       .
                                       f
                                       
                                       (
                                       inr
                                       
                                       x
                                       )
                                       :
                                       
                                          
                                             N
                                          
                                          
                                             !
                                          
                                       
                                       
                                          
                                             →
                                          
                                          
                                             !
                                          
                                       
                                       
                                          
                                             N
                                          
                                          
                                             !
                                          
                                       
                                    .


                                    
                                       μ
                                       f
                                       .
                                       λ
                                       x
                                       .
                                       λ
                                       y
                                       .
                                       case
                                       
                                       x
                                       
                                       of
                                       
                                       λ
                                       z
                                       .
                                       f
                                       
                                       (
                                       inr
                                       
                                       □
                                       )
                                       
                                       y
                                       
                                       or
                                       
                                       λ
                                       z
                                       .
                                       f
                                       
                                       y
                                       
                                       (
                                       inr
                                       
                                       □
                                       )
                                       :
                                       
                                          
                                             N
                                          
                                          
                                             !
                                          
                                       
                                       
                                          
                                             →
                                          
                                          
                                             !
                                          
                                       
                                       
                                          
                                             N
                                          
                                          
                                             !
                                          
                                       
                                       
                                          
                                             →
                                          
                                          
                                             !
                                          
                                       
                                       
                                          
                                             N
                                          
                                          
                                             !
                                          
                                       
                                    .

The proof of these typing statements can also be found in the PVS files. In Examples 3 and 4, N stands for the type 
                        1
                        +
                        1
                      which we use to represent natural numbers. The actual values of these numbers are not relevant: It suffices if we can distinguish 0 (represented as 
                        inl
                        
                        □
                     ) from all other numbers (represented as 
                        inr
                        
                        □
                     ). Example 3 resembles the factorial function (without the usual multiplication and subtraction), and Example 4 (showing a recursive function that is strict in both arguments) is taken from [6].

Automated theorem proving is very time consuming. We estimate that the construction of the entire proof (including the development of the necessary theoretic concepts) comprises about six man–months work, maybe even more. On the other hand, it revealed mistakes which had been made in the previous (first-order) version of the type system. Moreover, extending the language with higher-order constructs made the system significantly more complex. For example, the treatment of function types in Definition 7 showed to be non-intuitive. Various attempts were made preceding the final version. The PVS formalization helped us by enabling quick verification of modifications in definitions.

Our work can be considered as a contribution in the spirit of [1]. One of the PoplMark challenges is the treatment of variable binding. Most of the solutions that have been reported to this challenge are based on De Bruijn indices. Though [1] argues that this representation introduces too much overhead in formal proofs, and should therefore be avoided, this is not confirmed by our approach or by any of these solutions. The low-level variable representation does not lead to any significant increase in the complexity of the proofs. With a few simple, and easy-to-prove auxiliary lemmas, one can effectively hide all implementation details. The main proof itself is not affected. In fact, the implicit bindings of De Bruijn׳s representation allow environments to be represented as simple lists rather than lists of pairs.

We believe that, besides obtaining full confidence, one of the main advantages of possessing a formal proof is the possibility to replay the proof in a tool. For instance, if one cannot immediately follow the given explanations, in principle one can fall back on the fully elaborated formal version.

In this section we will describe how strictness variants of traditional typings can be inferred effectively.

The type derivation algorithm is based on the idea to split type reconstruction into two phases [25]: generation of requirements (in the form of type equations) and fulfilling these requirements (in the form of a solution for the equations, i.e., a suitable substitution for the type variables). The solution is computed by means of a procedure called unification; see [18].

Since the system is fully syntax directed (each syntactic construction has exactly one typing rule), the equations 
                           σ
                           ≃
                           τ
                         for an expression E can be generated by stepwise reconstruction of a type derivation for E, essentially leading to a type reconstruction for each subexpression of E.

We will illustrate this idea with an example. Consider the following expression: 
                           
                              
                                 λ
                                 p
                                 .
                                 case
                                 
                                 p
                                 
                                 of
                                 
                                 λ
                                 x
                                 .
                                 x
                                 
                                 or
                                 
                                 λ
                                 y
                                 .
                                 □
                              
                           
                        For the outermost abstraction, two auxiliary variables are introduced, say 
                           α
                           ,
                           β
                        . The variable α is assigned to p whereas β becomes the result type of the case expression. The latter consists of three components. In order to reconstruct the type, two more variables are needed, say 
                           γ
                           ,
                           δ
                        . Typing the pattern leads to the equation 
                           α
                           ≃
                           γ
                           +
                           δ
                        . Both branches of the case consist of a lambda expression. Each lambda expression will again require new auxiliary variables. To simplify our example slightly, we assume that 
                           λ
                           x
                           .
                           x
                         if typed with 
                           ζ
                           →
                           ζ
                         and 
                           λ
                           y
                           .
                           □
                         with 
                           η
                           →
                           1
                        , both 
                           ζ
                           ,
                           η
                         fresh. Typing these branches will lead to the equations 
                           γ
                           →
                           β
                           ≃
                           ζ
                           →
                           ζ
                         and 
                           δ
                           →
                           β
                           ≃
                           η
                           →
                           1
                        . Solving these three equations by unification gives the substitution 
                           
                              
                                 ⁎
                                 =
                                 {
                                 α
                                 ←
                                 1
                                 +
                                 η
                                 ,
                                 δ
                                 ←
                                 η
                                 ,
                                 ζ
                                 ←
                                 1
                                 ,
                                 β
                                 ←
                                 1
                                 ,
                                 γ
                                 ←
                                 1
                                 }
                              
                           
                        Applying this substitution gives the typing statement 
                           
                              
                                 λ
                                 p
                                 .
                                 case
                                 
                                 p
                                 
                                 of
                                 
                                 λ
                                 x
                                 .
                                 x
                                 
                                 or
                                 
                                 λ
                                 y
                                 .
                                 □
                                 :
                                 1
                                 +
                                 η
                                 →
                                 1
                              
                           
                        One can use this algorithm to show that type assignment has the principal typing property: if an expression E is typable, there exists a principal typing for E, i.e., a ‘schematic’ type of which all other typings can be obtained via instantiation of type variables.

The above typing for E is principal.
                           Principal Typing Theorem 1
                           
                              Principal typings can be computed effectively.

See [4].□

For strictness types we follow roughly the same procedure. Since strictness typing involves subtyping, we will generate both type equations and type inequalities.

Given an expression and a standard type, there can be several strictness variants of that typing. Therefore it is natural to consider strictness schemes. We use attribute variables (
                           a
                           ,
                           b
                           ,
                           …
                        ) to denote schematic strictness types, in the same way as we use type variables to indicate schematic standard types. A concrete strictness typing consists of a proper instantiation of the attribute variables.

We will need to state dependencies between strictness attributes. We will express these as (finite) sets of attribute inequalities called attribute environments. The following example illustrates the use of these environments. The possible types of the lambda expression 
                           λ
                           x
                           .
                           fst
                           
                           x
                         can be expressed schematically as 
                           
                              
                                 
                                    
                                       (
                                       
                                          
                                             α
                                          
                                          
                                             a
                                          
                                       
                                       ×
                                       
                                          
                                             β
                                          
                                          
                                             ?
                                          
                                       
                                       )
                                    
                                    
                                       c
                                    
                                 
                                 
                                    
                                       →
                                    
                                    
                                       d
                                    
                                 
                                 
                                    
                                       α
                                    
                                    
                                       b
                                    
                                 
                                 |
                                 
                                 b
                                 ≤
                                 a
                                 ,
                                 b
                                 ≤
                                 c
                                 ,
                                 d
                                 ≤
                                 b
                              
                           
                        The attribute environment denotes restrictions on instantiations. E.g., 
                           a
                           ≔
                           !
                           ,
                           b
                           ≔
                           !
                           ,
                           c
                           ≔
                           !
                           ,
                           d
                           ≔
                           !
                         and 
                           a
                           ≔
                           ?
                           ,
                           b
                           ≔
                           !
                           ,
                           c
                           ≔
                           !
                           ,
                           d
                           ≔
                           !
                         are valid instantiations, but, for example, 
                           a
                           ≔
                           ?
                           ,
                           b
                           ≔
                           ?
                           ,
                           c
                           ≔
                           !
                           ,
                           d
                           ≔
                           !
                         is not, since 
                           ?
                           ≰
                           !
                        .

It is possible to add these ‘polymorphic strictness types’ and attribute environments to the formal typing system. A similar extension has been done in the uniqueness type system, see [4]. We will refrain from such an extension here, since it produces administrative overhead and does not contribute to the understanding of the typing algorithm. Instead, we will regard our strictness schemes as an abbreviation for the respective concrete strictness types obtained by instantiation.

During strictness type reconstruction we sometimes need to denote the ‘minimum’ of two strictness types or strictness attributes. This operation occurs whenever the typing rule contains an infimum of bases. In case this minimum is not directly computable (when attributes are schematic, or types are not yet equivalent) we continue the computation with a schematic minimum 
                           S
                           ⊓
                           T
                        . Eventually, this leads to schematic attributes of the form 
                           
                              
                                 a
                              
                              
                                 1
                              
                           
                           ⊓
                           ⋯
                           ⊓
                           
                              
                                 a
                              
                              
                                 k
                              
                           
                        . For example, 
                           λ
                           x
                           .
                           〈
                           x
                           ,
                           x
                           〉
                         can be typed with 
                           
                              
                                 λ
                                 x
                                 .
                                 〈
                                 x
                                 ,
                                 x
                                 〉
                                 :
                                 
                                    
                                       α
                                    
                                    
                                       a
                                       ⊓
                                       b
                                    
                                 
                                 
                                    
                                       →
                                    
                                    
                                       f
                                    
                                 
                                 
                                    
                                       (
                                       
                                          
                                             α
                                          
                                          
                                             c
                                          
                                       
                                       ×
                                       
                                          
                                             α
                                          
                                          
                                             d
                                          
                                       
                                       )
                                    
                                    
                                       e
                                    
                                 
                                 |
                                 
                                 f
                                 ≤
                                 e
                                 ,
                                 e
                                 ≤
                                 c
                                 ,
                                 e
                                 ≤
                                 d
                                 ,
                                 c
                                 ≤
                                 a
                                 ,
                                 d
                                 ≤
                                 b
                                 .
                              
                           
                        The attribute 
                           a
                           ⊓
                           b
                         on the argument type together with the inequalities 
                           c
                           ≤
                           a
                           ,
                           d
                           ≤
                           b
                         indicate that this argument can only become 
                           !
                         if either c or d is taken 
                           !
                        .

The requirements generated during type reconstruction consist of strictness type equations but also of strictness type inequalities (due to subtyping constraints 
                           S
                           ≤
                           T
                         in the rules for var and fix) and strictness attribute inequalities (due to attribute constraints 
                           u
                           ≤
                           v
                        ).

We can describe the generation of requirements as a function 
                           S
                        . It takes an expression E and a goal type T as input and produces a pair 
                           〈
                           Γ
                           ,
                           R
                           〉
                         consisting of a basis 
                           Γ
                         and a collection of inequalities 
                           R
                        . The latter collection is a triple consisting of a set of type equations, a set of type inequalities, and a set of attribute inequalities. 
                           Definition 14
                           The strictness requirements generation function 
                              
                                 S
                               is defined inductively in Fig. 6
                              . Union of results is to be taken componentwise.


                        Some remarks: If the variable x in the rules for fix and abstraction does not occur in E there will be no declaration of x in the resulting basis. Hence, we cannot write the basis as 
                           Γ
                           ∪
                           {
                           x
                           :
                           X
                           }
                        . In the case of abstraction, the type X is taken to be 
                           
                              
                                 α
                              
                              
                                 ?
                              
                           
                        , with α fresh. For fix expressions, the inequality 
                           T
                           ≤
                           X
                         can be omitted. The infimum of 
                           Γ
                           ⊓
                           
                              
                                 Γ
                              
                              
                                 ′
                              
                           
                         consists of declarations 
                           x
                           :
                           S
                           ⊓
                           T
                         for each variable x appearing in both 
                           Γ
                         and 
                           
                              
                                 Γ
                              
                              
                                 ′
                              
                           
                        . For a variable x that appears only in 
                           Γ
                         (say with type S) and not in 
                           
                              
                                 Γ
                              
                              
                                 ′
                              
                           
                        , the infimum 
                           Γ
                           ⊓
                           
                              
                                 Γ
                              
                              
                                 ′
                              
                           
                         contains just 
                           x
                           :
                           S
                        . The case that x appears in 
                           
                              
                                 Γ
                              
                              
                                 ′
                              
                           
                         and not in 
                           Γ
                         is handled similarly. Analogously, if a variable x is not present in both 
                           Γ
                         and 
                           
                              
                                 Γ
                              
                              
                                 ′
                              
                           
                        , the set of type equations 
                           Γ
                           ≃
                           
                              
                                 Γ
                              
                              
                                 ′
                              
                           
                         will not contain an equation corresponding to x. Instead, 
                           ?
                           ≤
                           [
                           S
                           ]
                         should be added to the set attribute inequalities (where S is the type of x in either 
                           Γ
                         or 
                           
                              
                                 Γ
                              
                              
                                 ′
                              
                           
                        ).

The next step is to solve the inequalities obtained by 
                           S
                        . Our goal is to compute a ‘principal strictness typing’, i.e. a valid typing (possibly containing an attribute environment) of which all other concrete strictness typings can be obtained via instantiation.

The underlying ‘standard part’ of the requirements can easily be solved: the output of 
                           S
                         can be converted into a set of standard type equations 
                           σ
                           ≃
                           τ
                        , by ignoring all strictness attributes and by considering type inequalities and type infima as equations. Let E be an expression. Suppose we apply 
                           S
                         to 
                           〈
                           E
                           ,
                           
                              
                                 α
                              
                              
                                 a
                              
                           
                           〉
                        , with α and a fresh. It is not difficult to show that the most general solution for the resulting collection of equations (after applying the above procedure) leads to a principal standard typing of E.
                           Principal Strictness Typing Theorem 1
                           
                              Principal strictness typings can be computed effectively.

Let E be an expression.
                                 
                                    Step 1.
                                    Compute 
                                          〈
                                          Γ
                                          ,
                                          R
                                          〉
                                          =
                                          S
                                          (
                                          E
                                          ,
                                          
                                             
                                                α
                                             
                                             
                                                a
                                             
                                          
                                          )
                                       .

Determine (by unification) a solution ⁎0 for the standard type equations that result from 
                                          Γ
                                          ,
                                          R
                                       .

Lift ⁎0 to a strictness type substitution ⁎, i.e., for each 
                                          α
                                          =
                                          σ
                                       , the type σ is converted into a pseudo-strictness type by decorating all subtypes of σ with fresh attribute variables.

Extend the set of type attribute inequalities of 
                                          R
                                        with the inequalities that arise from the type equations and inequalities in 
                                          R
                                        after performing ⁎. Let 
                                          Δ
                                        be the result of this step.

Now 
                                          〈
                                          
                                             
                                                Γ
                                             
                                             
                                                ⁎
                                             
                                          
                                          ,
                                          
                                             
                                                (
                                                
                                                   
                                                      α
                                                   
                                                   
                                                      a
                                                   
                                                
                                                )
                                             
                                             
                                                ⁎
                                             
                                          
                                          ,
                                          Δ
                                          〉
                                        is a principal typing for E.□

To obtain more legible types, one could simplify the result of step 4 by determining the restriction of 
                           Δ
                         to attributes appearing in 
                           
                              
                                 Γ
                              
                              
                                 ⁎
                              
                           
                         and 
                           
                              
                                 (
                                 
                                    
                                       α
                                    
                                    
                                       a
                                    
                                 
                                 )
                              
                              
                                 ⁎
                              
                           
                        . We will not explain this procedure in more depth.

The principal strictness type can be seen as the ‘best strictness type’ (meaning ‘as strict as possible’) which is obtained by choosing ! for all attribute variables.

In this section we will illustrate strictness type inference with a fully elaborated example. In the course of the procedure we will need to introduce fresh type and strictness variables. We will use numbers for type variables instead of Greek letters, and Roman letters for strictness variables. The application of 
                           S
                         to an expression E and a fresh goal type 
                           
                              
                                 1
                              
                              
                                 a
                              
                           
                         will produce a basis and set of requirements. During this generation phase, a basis can grow, shrink or present declarations might change. The set of requirements, however, is only extended. To enhance readability, we do not explicitly collect all the generated requirements at each step. Instead, we only mention the newly created ones.

Consider the expression 
                           E
                           =
                           λ
                           x
                           .
                           〈
                           x
                           ,
                           x
                           〉
                        . We will show that the strictness type for E that was given before is indeed computed by our type inference algorithm.
                           
                              Step 1.
                              Compute 
                                    〈
                                    Γ
                                    ,
                                    R
                                    〉
                                    =
                                    S
                                    (
                                    E
                                    ,
                                    
                                       
                                          1
                                       
                                       
                                          a
                                       
                                    
                                    )
                                 
                                 
                                    
                                       
                                          ⇒
                                          S
                                          (
                                          λ
                                          x
                                          .
                                          〈
                                          x
                                          ,
                                          x
                                          〉
                                          ,
                                          
                                             
                                                1
                                             
                                             
                                                a
                                             
                                          
                                          )
                                          
                                          ⇒
                                          S
                                          (
                                          〈
                                          x
                                          ,
                                          x
                                          〉
                                          ,
                                          
                                             
                                                2
                                             
                                             
                                                b
                                             
                                          
                                          )
                                          
                                          
                                          ⇒
                                          S
                                          (
                                          x
                                          ,
                                          
                                             
                                                3
                                             
                                             
                                                c
                                             
                                          
                                          )
                                          
                                          
                                          ⇐
                                          〈
                                          x
                                          :
                                          
                                             
                                                5
                                             
                                             
                                                e
                                             
                                          
                                          ,
                                          〈
                                          -,
                                          {
                                          
                                             
                                                3
                                             
                                             
                                                c
                                             
                                          
                                          ≤
                                          
                                             
                                                5
                                             
                                             
                                                e
                                             
                                          
                                          }
                                          ,-
                                          〉
                                          〉
                                          
                                          
                                          ⇒
                                          S
                                          (
                                          x
                                          ,
                                          
                                             
                                                4
                                             
                                             
                                                d
                                             
                                          
                                          )
                                          
                                          
                                          ⇐
                                          〈
                                          x
                                          :
                                          
                                             
                                                6
                                             
                                             
                                                f
                                             
                                          
                                          ,
                                          〈
                                          -,
                                          {
                                          
                                             
                                                4
                                             
                                             
                                                d
                                             
                                          
                                          ≤
                                          
                                             
                                                6
                                             
                                             
                                                f
                                             
                                          
                                          }
                                          ,-
                                          〉
                                          〉
                                          
                                          ⇐
                                          〈
                                          x
                                          :
                                          
                                             
                                                5
                                             
                                             
                                                e
                                             
                                          
                                          ⊓
                                          
                                             
                                                6
                                             
                                             
                                                f
                                             
                                          
                                          ,
                                          〈
                                          {
                                          2
                                          ≃
                                          
                                             
                                                3
                                             
                                             
                                                c
                                             
                                          
                                          ×
                                          
                                             
                                                4
                                             
                                             
                                                d
                                             
                                          
                                          }
                                          ,-,
                                          {
                                          b
                                          ≤
                                          c
                                          ⊓
                                          d
                                          }
                                          〉
                                          〉
                                          
                                          ⇐
                                          〈
                                          -,
                                          〈
                                          {
                                          1
                                          ≃
                                          
                                             
                                                5
                                             
                                             
                                                e
                                             
                                          
                                          ⊓
                                          
                                             
                                                6
                                             
                                             
                                                f
                                             
                                          
                                          →
                                          
                                             
                                                2
                                             
                                             
                                                b
                                             
                                          
                                          }
                                          ,-,
                                          {
                                          a
                                          ≤
                                          b
                                          }
                                          〉
                                          〉
                                       
                                    
                                 
                              

Determine a substitution that solves the set of standard type equations that result from 
                                    Γ
                                    ,
                                    R
                                 . In this example this step is almost trivial: a possible solution, say ⁎0, is
                                    
                                       
                                          
                                             
                                                ⁎
                                             
                                             
                                                0
                                             
                                          
                                          =
                                          {
                                          3
                                          ←
                                          4
                                          ,
                                          3
                                          ←
                                          5
                                          ,
                                          3
                                          ←
                                          6
                                          ,
                                          2
                                          ←
                                          3
                                          ×
                                          3
                                          ,
                                          1
                                          ←
                                          3
                                          →
                                          3
                                          ×
                                          3
                                          }
                                       
                                    
                                 
                              

Lifting ⁎0 to a strictness substitution ⁎ normally requires new fresh strictness variables, However, in this example we can optimize this step by using the generated equations for variable 1 as well as for 2.
                                    
                                       
                                          ⁎
                                          =
                                          {
                                          3
                                          ←
                                          4
                                          ,
                                          3
                                          ←
                                          5
                                          ,
                                          3
                                          ←
                                          6
                                          ,
                                          2
                                          ←
                                          
                                             
                                                3
                                             
                                             
                                                c
                                             
                                          
                                          ×
                                          
                                             
                                                3
                                             
                                             
                                                d
                                             
                                          
                                          ,
                                          1
                                          ←
                                          
                                             
                                                3
                                             
                                             
                                                e
                                                ⊓
                                                f
                                             
                                          
                                          →
                                          
                                             
                                                (
                                                
                                                   
                                                      3
                                                   
                                                   
                                                      c
                                                   
                                                
                                                ×
                                                
                                                   
                                                      3
                                                   
                                                   
                                                      d
                                                   
                                                
                                                )
                                             
                                             
                                                b
                                             
                                          
                                          }
                                       
                                    
                                 
                              

Now the type inequalities are converted into attribute inequalities, and added to the attribute inequalities already present in 
                                    R
                                 . The resulting collection 
                                    Δ
                                  of inequalities is
                                    
                                       
                                          Δ
                                          =
                                          {
                                          c
                                          ≤
                                          e
                                          ,
                                          d
                                          ≤
                                          f
                                          ,
                                          b
                                          ≤
                                          c
                                          ⊓
                                          d
                                          ,
                                          a
                                          ≤
                                          b
                                          }
                                       
                                    
                                 
                              

Finally, we end up with the following typing for E. Note that we can write 
                                    b
                                    ≤
                                    c
                                    ⊓
                                    d
                                  as 
                                    b
                                    ≤
                                    c
                                    ,
                                    b
                                    ≤
                                    d
                                 
                                 
                                    
                                       
                                          λ
                                          x
                                          .
                                          〈
                                          x
                                          ,
                                          x
                                          〉
                                          :
                                          
                                             
                                                3
                                             
                                             
                                                e
                                                ⊓
                                                f
                                             
                                          
                                          
                                             
                                                →
                                             
                                             
                                                a
                                             
                                          
                                          
                                             
                                                (
                                                
                                                   
                                                      3
                                                   
                                                   
                                                      c
                                                   
                                                
                                                ×
                                                
                                                   
                                                      3
                                                   
                                                   
                                                      d
                                                   
                                                
                                                )
                                             
                                             
                                                b
                                             
                                          
                                          |
                                          
                                          c
                                          ≤
                                          e
                                          ,
                                          d
                                          ≤
                                          f
                                          ,
                                          b
                                          ≤
                                          c
                                          ,
                                          b
                                          ≤
                                          d
                                          ,
                                          a
                                          ≤
                                          b
                                       
                                    
                                 
                              

Thus far we have only considered non-recursive data structures. In this section we will describe an extension of the theory to lists. This extension can serve as a basis for the treatment of other recursive data types.

Lists are built up from constructors 
                        nil
                      (the empty list) and 
                        cons
                     . We incorporate these constructs in our syntax together with a destructor called 
                        list
                      leading to the following extension of Definition 1: 
                        
                           
                              Λ
                              ::=
                              ⋯
                              |
                              nil
                              |
                              cons
                              
                              Λ
                              
                              Λ
                              |
                              list
                              
                              Λ
                              
                              Λ
                              
                              Λ
                           
                        
                     By 
                        L
                        (
                        σ
                        )
                      we denote the (standard) type of lists of σ objects.

The evaluation rules for these construct are straightforward: hnf-evaluation of list objects stops at the outermost constructor. 
                        
                           
                              
                                 
                                    
                                 
                              
                           
                        
                     
                  

Besides plain hnf-evaluation, it is useful to distinguish other evaluation forms. The most common ones are spine evaluation and full evaluation. For instance, the function length computing the size of the list will enforce the complete evaluation of the list structure, but leave the elements unaffected. A function sum that sums all the elements of a list will not only evaluate the spine completely, but also all of its elements.

The evaluation contexts induced by these functions are again encoded in an appropriate strictness type. This leads to the following extension of Definition 6: 
                        
                           
                              Π
                              ::=
                              ⋯
                              |
                              
                                 
                                    L
                                 
                                 
                                    A
                                 
                              
                              (
                              Σ
                              )
                           
                        
                     Only part of the types that can be constructed according to this syntax is well-formed. This is due to the fact that for data structures, strictness ‘propagates outwards’: in order to evaluate inner components of a data structure, the structure itself has to be evaluated before these components can be accessed.

For example, for a list of 
                        1
                      elements we have 4 different valid strictness variants: 
                        
                           
                              (
                              
                                 
                                    L
                                 
                                 
                                    ?
                                 
                              
                              (
                              
                                 
                                    1
                                 
                                 
                                    ?
                                 
                              
                              )
                              )
                           
                           
                              ?
                           
                        
                     , 
                        
                           
                              (
                              
                                 
                                    L
                                 
                                 
                                    ?
                                 
                              
                              (
                              
                                 
                                    1
                                 
                                 
                                    ?
                                 
                              
                              )
                              )
                           
                           
                              !
                           
                        
                     , 
                        
                           
                              (
                              
                                 
                                    L
                                 
                                 
                                    !
                                 
                              
                              (
                              
                                 
                                    1
                                 
                                 
                                    ?
                                 
                              
                              )
                              )
                           
                           
                              !
                           
                        
                     , and 
                        
                           
                              (
                              
                                 
                                    L
                                 
                                 
                                    !
                                 
                              
                              (
                              
                                 
                                    1
                                 
                                 
                                    !
                                 
                              
                              )
                              )
                           
                           
                              !
                           
                        
                     , corresponding to no, hnf, spine and full evaluation, respectively.

The typing rules are extended according to our intended semantics. 
                        
                           
                              
                                 
                                    
                                 
                              
                           
                        
                     
                  

For a soundness proof, all definitions based on either expressions or on types have to be adjusted in order to deal with list constructs. All of these adjustments are reasonably straightforward, and can be found in the PVS formalization. However, the formalization does not yet contain a completely formalized proof; i.e., the list cases are still missing, mainly due to the increased complexity of the proof.

Again, we formulate some examples as lemmas which enables us to formally prove that the typing statements are indeed correct. 
                        Lemma 3
                        
                           
                              
                                 1.
                                 
                                    
                                       μ
                                       l
                                       .
                                       λ
                                       x
                                       .
                                       list
                                       
                                       x
                                       
                                       (
                                       inl
                                       
                                       □
                                       )
                                       
                                       λ
                                       h
                                       .
                                       λ
                                       t
                                       .
                                       l
                                       
                                       t
                                       :
                                       
                                          
                                             (
                                             
                                                
                                                   L
                                                
                                                
                                                   !
                                                
                                             
                                             (
                                             
                                                
                                                   α
                                                
                                                
                                                   ?
                                                
                                             
                                             )
                                             )
                                          
                                          
                                             !
                                          
                                       
                                       
                                          
                                             →
                                          
                                          
                                             !
                                          
                                       
                                       
                                          
                                             N
                                          
                                          
                                             !
                                          
                                       
                                    .


                                    
                                       μ
                                       s
                                       .
                                       λ
                                       x
                                       .
                                       list
                                       
                                       x
                                       
                                       (
                                       inl
                                       
                                       □
                                       )
                                       
                                       λ
                                       h
                                       .
                                       λ
                                       t
                                       .
                                       +
                                       
                                       h
                                       
                                       (
                                       s
                                       
                                       t
                                       )
                                       :
                                       
                                          
                                             (
                                             
                                                
                                                   L
                                                
                                                
                                                   !
                                                
                                             
                                             (
                                             
                                                
                                                   N
                                                
                                                
                                                   !
                                                
                                             
                                             )
                                             )
                                          
                                          
                                             !
                                          
                                       
                                       
                                          
                                             →
                                          
                                          
                                             !
                                          
                                       
                                       
                                          
                                             N
                                          
                                          
                                             !
                                          
                                       
                                    .


                                    
                                       ∀
                                       u
                                       ,
                                       v
                                       ,
                                       w
                                       ∈
                                       A
                                       ,
                                       v
                                       ≤
                                       w
                                       ,
                                       w
                                       ≤
                                       u
                                       :
                                       μ
                                       r
                                       .
                                       λ
                                       x
                                       .
                                       λ
                                       y
                                       .
                                       list
                                       
                                       x
                                       
                                       y
                                       
                                       λ
                                       h
                                       .
                                       λ
                                       t
                                       .
                                       r
                                       
                                       t
                                       
                                       (
                                       cons
                                       
                                       h
                                       
                                       y
                                       )
                                       :
                                       
                                          
                                             (
                                             
                                                
                                                   L
                                                
                                                
                                                   v
                                                
                                             
                                             
                                                
                                                   (
                                                   
                                                      
                                                         α
                                                      
                                                      
                                                         u
                                                      
                                                   
                                                   )
                                                   )
                                                
                                                
                                                   v
                                                
                                             
                                             
                                                
                                                   →
                                                
                                                
                                                   v
                                                
                                             
                                             
                                                
                                                   (
                                                   
                                                      
                                                         L
                                                      
                                                      
                                                         w
                                                      
                                                   
                                                   (
                                                   
                                                      
                                                         α
                                                      
                                                      
                                                         u
                                                      
                                                   
                                                   )
                                                   )
                                                
                                                
                                                   w
                                                
                                             
                                             
                                                
                                                   →
                                                
                                                
                                                   v
                                                
                                             
                                             (
                                             
                                                
                                                   L
                                                
                                                
                                                   w
                                                
                                             
                                             (
                                             
                                                
                                                   α
                                                
                                                
                                                   u
                                                
                                             
                                             )
                                             )
                                          
                                          
                                             v
                                          
                                       
                                    .

We use the same representation for natural numbers as in Example 2. The operation + is simply represented by 
                        ⊥
                     , because the only relevant aspect of + is this example us that it is strict in both arguments, and 
                        ⊥
                      can be typed as a strict binary operation. Example 1 is the length function (without addition), and Example 2 the sum function. Example 3 is the well-known reverse function that transfers each element of the first list argument to the second argument. One will usually call this function with an empty list as second argument. In that case, all elements of the first list will appear in reverse order in the final result. By using quantified attributes, we obtain a polymorphic strictness typing for reverse. In this typing the difference between the first and the second argument becomes apparent: Even simple hnf-evaluation of an application of reverse will result in the complete evaluation of the spine of the first argument. For the second argument this is not the case. This argument will only be evaluated when the whole spine of the reverse׳s result is needed.

We compared several existing techniques for strictness analysis by giving a brief outline of their main ideas.

In [12,2] a non-standard type inference is introduced using conjunction types. The main properties of the system are formulated and proved with respect to a denotational semantics of their language. The difference with our approach is that the strictness information is restricted to traditional head-normal form evaluation only, which, as we argued, hampers modularity. In [10] a typing framework is presented focusing on algorithmic aspects, by providing a checking algorithm for a variation of Jensen׳s system.

The system described by [6] is most similar to ours. For a language resembling the core functional language introduced in Section 2, the authors describe both a strictness and a totality analysis using a non-standard type inference system. The main difference with our approach is that conjunction types are used. In our system the strictness properties of all function arguments are captured by a single strictness type, whereas the system of [6] requires a conjunction of these properties. The advantage of our approach is that it can be incorporated directly in a standard Hindley–Milner type inference algorithm.

The system introduced by [9] is based on relevance typing. Similar to our system, and the backwards strictness analysis used in the Glasgow Haskell Compiler [11], the (evaluation) context in which variables are used determines whether these variables are relevant if such a context is evaluated. In [9] the emphasis is on exploiting strictness information by defining a transformation replacing ordinary function applications by a more efficient eager applications.

Strictness analysis by abstract interpretation introduces a non-standard semantics by translating functions into abstract versions over finite domains, notably over finite lattices. The bottom elements of these domains play the role of generic ‘undefined’ values. Recursive abstract functions are defined by a fixed-point construction. The main property of this alternative interpretation is to yield a decidable approximation of the (in general undecidable) strictness property, even in the higher-order case. This abstraction inevitably leads to information loss. The standard form of abstract interpretation uses the two-point lattice as ground domain. See [16,3] and [?] for more information. Due to the complexity of finding fixed points in abstract domains, abstract interpretation is not very useful for implementing strictness analysis in compilers for functional languages.


                     Abstract reduction analyses evaluation of expressions by mimicking reduction on sets of concrete values extended with special elements for undefinedness. This technique approximates ordinary computations closer than for instance abstract interpretation or strictness typing. Rewriting semantics is adjusted by specifying the behaviour of functions on non-standard elements. Abstract reduction sequences may not terminate. A special technique called reduction path analysis is used to cut off these sequences in a way that keeps most of the strictness information intact; see [17,7]. The main disadvantage of this approach is the lack of modularity; it requires the implementations of the involved functions to perform the analyses effectively.


                     Strictness typing is a purely syntactic (intentional) way of deriving strictness information. The resulting strictness information merely depends on the structure of the expressions, particularly on the occurrences of case clauses, and (as in the case of abstract interpretation) not on the computational behaviour on concrete values. The advantage of strictness typing over abstract interpretation is that the first method can be combined with standard typing. For more information, the reader is referred to [15].

@&#CONCLUSIONS AND FUTURE WORK@&#

In this paper we presented a strictness typing system which is fully higher-order. We describe a type derivation system as well as a type inference algorithm. Moreover, the typing system enables the specification of arbitrary evaluation contexts, which is essential for supporting modularity. Like many other meta-theoretical expositions we used De Bruijn indices to represent term variables. Despite the objections that have been raised against this low-level representation (e.g., see [1]), we encountered no real issues that significantly hampered our proofs.

We have demonstrated that proof assistants are not only useful in formalizing existing proofs but also to develop new language theoretic concepts. One major concern, however, remains the fact that the construction of a formalized proof remains very time consuming. Compared to a manual construction on paper, the development time using the proposed method probably takes (much more than) three times as long. It is difficult to opt whether this is worth the investment. Although the reader might not learn very much from the formalization itself, it is still useful because in the end it guarantees that the system is indeed fully correct.

@&#FUTURE WORK@&#

The formal proof does not yet cover soundness of the entire typing system: the proof work on recursive data types must be extended and completed. Moreover, a proof formalization of the Principal Strictness Typing Theorem is still a compelling challenge. In addition, the type system itself should be considered as a proof of concept, rather than as a system that is directly suited for being incorporated in a standard functional language, like Haskell. For this reason, we have developed a prototype implementation. However, this prototype is still very rudimentary, and will require quite some effort in order to make it ripe for testing and comparing with other strictness analyzers.

@&#REFERENCES@&#

