@&#MAIN-TITLE@&#A pattern-based method for refining and formalizing informal specifications in critical control systems

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Processing specifications is a crucial issue in critical complex systems.


                        
                        
                           
                           Establishing rigorous specifications highly impacts the engineering phases.


                        
                        
                           
                           A refinement technique for processing informal specifications is developed.


                        
                        
                           
                           The established technique relies on a set of basic refinement patterns.


                        
                        
                           
                           The refinement/formalization process outputs a set of logical CTL* formulas.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Requirement engineering

Requirement refinement

Specification

Formalizing

Critical control systems

Verification 

&

 validation

@&#ABSTRACT@&#


               
               
                  Processing specifications is an issue of crucial importance when developing critical complex systems. In particular, establishing rigorous specifications broadly impacts the subsequent engineering phases. This paper discusses a refinement technique for processing informal specifications expressed in a literal shape, with the aim to generate formal specifications appropriate to automatic processing. The developed technique carries out an iterative process which relies on a set of basic refinement patterns that we have established, and ends up with a formalization step which actually generates logical CTL* formulas. Furthermore, the method implements traceability facilities, which allow for a tidy backtracking of the whole process. The concepts introduced to set up the various mechanisms are discussed and a case study featuring an embedded railway control system is used to illustrate our technique.
               
            

When engineering complex systems, the quality of the design directly relies on that of the specifications considered. This fact is all the more relevant when we deal with critical systems. In that case, one of the main issues is to transform informal specifications into rigorous and preferably formal ones, considering that specifications are generally given in a literal form  [1]. The difficulty is due to the unavoidable semantic gaps inherent to the fuzzy nature of natural languages, on the one hand, and to the rigidity of formal languages, on the other hand. Semantic loss usually appears when an unsuccessful or incomplete formalization occurs, which may cause design errors. The part of the bugs due to requirement specification is very significant in complex systems. For instance, a study pertinent to computerized railway signaling systems showed that about 75% of accidents/incidents involving safety issues are due to specification issues  [2]. Similarly, another study that has been led by the automobile branch of Bosch revealed that 60% of bugs are due to the requirement specification phase; namely ambiguity, inaccuracy and inconsistency  [3].

To tackle the problems related to specification ambiguity, some sound requirement refinement mechanisms are needed. “Refining” consists in the process purifying useful information from requirement documents, ensuring that the refined information is correct, precise and rigorous, thus more formal. In this paper, a technique to refining specifications of critical complex control systems is discussed. It is worth noting here that although the work discussed in this paper is related to requirement engineering, it is a part of a global approach that has been developed in the framework of the FERROCOTS project  [4] which aims to establish a global engineering methodology for replacing the current embedded railway control architecture, based on cable panels, by Commercial-Off-The-Shelf (COTS) components. COTS generally means a standard component which can be reused in numerous applications, but in our case the COTS concept is related to the hardware supporting technology as well as to the implemented control logic. A main obstacle that we had to deal with within the FERROCOTS project is due to the lack of proper system specification and verification methods to develop this kind of critical embedded systems. That is why FERROCOTS advocates for an increasing use of standard and formal notations and automatic verification and validation (V&V) techniques, which also allows for guaranteeing a high reliability level of the system.

In the current research, we focus more precisely on the requirements related to the system’s dynamic, i.e., which describe its behavior. Indeed in our context, such requirements constitute in general the most critical and the most complex part of the specifications. However, it should be noted that rough specifications documents may hold further requirements pertaining to different aspects, such as interface, performance, etc. Although a number of semi-formal or standardized notations such as Unified Modeling Language (UML), SysML, Structured Analysis and Design Technique (SADT) can be encountered in some specification sheets, generally natural language remains predominant in the specifications documents. Our method implements a systematic process guiding the transformation from informal to formal specifications, and correctly refines the requirements extracted from raw text documents. Moreover, the refinement process has to guarantee a high traceability level; this feature is indeed strongly required to correctly achieve the various subsequent engineering steps. Besides the refinement process, the elaborated technique also implements an ultimate formalization step, which allows for deriving formal specifications in the end. It is worthwhile to recall here that, for safety reasons, relying on formal specifications is highly recommended when developing critical systems e.g., embedded railway control systems. From a practical point of view, the refinement process aims to transform raw specifications expressed in natural language into refined precise requirements, but still expressed as literal assertions. This process is based on three main refinement operations that we have developed, Clarify, Modify and Split. More precisely, such operations are established in the shape of refinement patterns, which provide mechanisms for reducing the risk of semantic loss. SysML notation will be used in the sequel to describe the various refinement operations. As for the formalization step, 
                        
                           
                              
                                 CTL
                              
                           
                           
                              ∗
                           
                        
                      logic, which is a super-set of both CTL and LTL temporal logics, is selected as the target formalization framework. Thus, the refined requirements are ultimately into 
                        
                           
                              
                                 CTL
                              
                           
                           
                              ∗
                           
                        
                      logic formulas. Let us note here that the obtained logical formulas provide a formal basis for various phases in the system engineering process, like the V&V step. It should also be mentioned that although the refinement process is not automatic, it offers supporting means to make this process systematic and outputs specifications workable by automatic tools.

The remainder of the paper is organized as follows: in Section  2, a global overview of the related works that can be found in the literature is given while classifying these works according to various criteria. The developed method will be discussed in Section  3 where first the refinement process will be detailed then the formalization step explained. In this section, the various preliminary notions and developed concepts necessary to set up our technique will be introduced and illustrated where necessary. Then, a discussion is carried out in Section  4 while some recommendations related to the method implementation are provided and argued, before a case study pertaining to an embedded railway control system is dealt with in Section  5. Finally, Section  6 offers some concluding remarks and draws some directions for the future work.

@&#RELATED WORKS@&#

In this section, we give an overview on the main existing research works pertaining to requirement refinement. This helps situate the contribution developed in this paper and derive some discussion about the technique relative to existing works. As mentioned in the introduction section, the idea behind developing formal specifications in the FERROCOTS project is to bring into play automatic tools and techniques for checking the requirements of critical railway control systems. The requirements that we consider are written in an informal form, while automation requires formal specifications. Then, we need to reformulate the input informal requirements, so that in the end each requirement (in the ideal case) is entirely formalized. Since refinement from an informal to a formal language is a highly subjective process prone to (incorrect) interpretations, we also want to keep a high traceability level of the refinement process, in such a way to ensure an easy backtrack of the process to make modifications when necessary.

Due to the quite strong (and not new) interest in finding techniques to transform informal statements into formal ones, this section does certainly not pretend to be exhaustive. Instead, we want to give a good grasp about the main available techniques and methodologies.

In Table 1
                     , the related works are sorted according to (1) Formal: after the methodology is applied, is the requirement formalized? (2) (resp. (3)) Informal (resp. Formal)? Refinement: refinements are done while the requirement is in an informal (resp. formal) form; (4) Documentation: associate the refinement with some documentation (typically to explain the interpretation choices); (5) Natural Language Processing (NLP): does the method implement semi-automatic processing of informal requirements.

One can observe that lots of works propose to directly formalize the requirements. These works essentially target software engineering and this is why direct formalization can actually be used. These works are identified by Type A in Table 1. Some of these techniques propose to make the refinement inside a formal framework. The requirement is then written incrementally: at each refinement step, at least one constraint is added. Then come the Goal-Oriented Requirement Engineering (GORE) methodologies and the likes (Type B or AB). GORE methodologies advocate focusing on the question why while analyzing and constructing requirements, i.e., to study a requirement based on its utility and purpose in the system. These methodologies are highly iterative and, then, natively support informal refinement and traceability. These methodologies are very generic regarding their applicability to a quite wide range of systems; they are generally designed to offer a unique framework: (ideally) all the aspects pertaining to requirement engineering should be handled by such methodologies. As an example, KAOS  [7], has a strong focus on software engineering, although it is far from being restricted to that area, and allows formalization and formal refinement using the extension proposed in  [8]. [1,16] are A(B)-type since the refinement part is only performed using an intermediate language, i.e., there is only one refinement step.

Automatic or semi-automatic techniques (Type D) can be applied on informal requirements using natural language processing techniques. These techniques can parse a text written in natural language (English is the most common) and are capable of identifying agents, roles, etc. They can build a class diagram or even a behavioral model. Although automation is a great feature, these techniques are not capable of taking design-decisions like when some ambiguities need to be fixed; consequently these techniques cannot automatically produce a sound formal form (otherwise this would mean that the “informal” requirement was in fact “formal”), but still they offer valuable tools for early analysis of requirements.

Finally, works whose type is ABC comply with our documentation requirement: in  [36], the authors use breadcrumbs, or a new (formal) knowledge about the system to modify the existent requirements whose behavior may have to be changed according to that new breadcrumb. Breadcrumbs are thought to be a kind of documentation and therefore must be kept along with the requirements. In  [37], a Goal Argumentation Method is proposed. It comprises a decision procedure, clarification techniques and an argumentation model. First, problems, weaknesses and ambiguities are checked using some predefined techniques. From this point, one has to explore the alternative solutions, and then pick one along with arguments in its favor. As for the clarification technique, it consists in labeling the words of the goal according to their type of fuzziness: ambiguous, over-general, vague, synonymous. For each type of fuzziness, some heuristics are proposed to help clarify the goal. Finally, an argumentation must be provided with an argumentation model, which is a graph-like structure storing the relations between arguments (implication, counter-implication, etc.).

As for 
                        ∼
                     , this symbol is used in Table 1 to denote an implicit or unclear feature of the work. For example, in  [35], requirements are sorted and refined using pattern storing while tracing the original requirement(s) it is clarifying. Thus, some kind of traceability is implemented, even if it remains limited.

A general observation that can be made regarding the listed techniques is that even if these research works are trying to use different notations or formal framework for formal specification, handling the semantic gaps between informal and formal specification still remains a major issue.

In this section, our refinement method
                        1
                     
                     
                        1
                        Although the developed method holds both a refinement process and a formalization phase, we say refinement method for simplicity.
                      will be discussed progressively, while introducing the various concepts that will be used. Firstly, the main features such a method has to fulfill will be listed while recalling the objectives underlying the establishment of our technique. Then, the refinement process, as well as the formalization process which, together, form the core part of our method will be detailed while progressively introducing the concepts deemed to be necessary to set up the various mechanisms.

Let us recall here that the development of our refinement was a part of a global engineering approach developed in the framework of the FERROCOTS project, which is dedicated to embedded railway control/command systems. Hence the targeted safety level is very high given the criticality nature of such systems. Moreover, in the light of the complexity of the systems dealt with a rigorous handling of the requirements needs to be ensured. In general, rigorous notations as well as formal methods are highly recommended to express and validate specifications when dealing with systems that require a high safety level, particularly in railways. The reason is that formal notations and methods offer a high level of rigor and rely on well-formalized means  [40], which prevent misinterpretation problems. Besides, this is explicitly highlighted as a priority for the Shift2Rail initiative,
                           2
                        
                        
                           2
                           
                              http://www.shift2rail.org.
                         which involves the major railway stakeholders (railway operators, manufacturers and infrastructure managers) in Europe and aims to improve competitiveness of the railway sector in the middle and long terms. Considering all these elements, a refinement method to process the specifications of critical complex systems should ideally fulfill some main features, as listed below: 
                           
                              •
                              The refinement procedure should be a progressive transformation process in order to reduce the semantic gaps and preserve the maximum confidence in the refinement. That is to say, transformation must be carried out smoothly, step by step, during the whole refinement process.

Due to the complexity of the systems targeted here, we need the resulting specification to be automatically verified. This implies using formal verification techniques, such as model-checking or simulation/testing, and these techniques need the support of a formal framework. Thus, the formal framework used to formalize the refined requirements should be practically usable (i.e., sound research background and availability of mature supporting tools).

The method has to provide mechanisms for requirement traceability. Indeed, the final obtained result, i.e., the formalized properties, highly relies on the choices that might have been done all along the refinement process. Clearly, the refinement process often has a certain degree of subjectivity basically due to interpretation operation. Hence, traceability mechanisms are required to track the steps of the refinement process in both a forward and backward directions, and ensure means to quickly find where the possible errors come from.

In the following sections, the various mechanisms implemented within our technique will be discussed.

Let us recall here that the input for our refinement method consists in rough specifications extracted from original requirement documents, which consist in literal assertions expressed in natural language. Also, it should be recalled that the scope of our work is restricted to the behavioral part of the specifications, i.e., those that describe how the system must behave. As mentioned earlier in the paper and in order to meet the various requirements listed above, we advocate that the whole procedure implements two parts: a refinement process which progressively purifies and arranges the requirements and a formalization step, strictly speaking, which transforms the output of the refinement process into logical formulas.

In this section, we discuss the refinement process. The aim of such a process is to rework the assertions extracted from the raw document, to dispel as much as possible the ambiguities that may be encountered by making the appropriate interpretation, also in some cases it could be useful to split the requirements for a better handling. As will be explained later, some steps of the refinement process could require the validation of domain experts, especially when some interpretation choices need to be done. But in any case, the choices made must be carefully explained and argued to ensure a good traceability level.

To implement our refinement process, three main refinement patterns have been established: Clarify, Split and Modify. These artifacts constitute the key elements of the process and implement various means to ensure traceability. In the following part, we will explain how the refinement patterns can be used. 
                           
                              •
                              
                                 Clarify pattern: requirements must be clarified if they contain ambiguity or fuzzy information. “Ambiguity” means a statement that can be understood or interpreted in different ways. In this case, the requirement has to be clarified. “Fuzzy” means that a statement is not clearly defined, such as some terms like “very fast, high”; in the refined requirements such qualification words must be avoided, instead more accurate terms can be used by quantifying things for example. The Clarify pattern must be applied until an accurate and understandable statement is obtained. The clarification can only be performed based on the engineers’ expertise (i.e., the knowledge of a previous similar system or the precise knowledge of how it is implemented yet or how it should be implemented). It has to be noticed that this pattern also allows for removing unnecessary/prolix information or regroup the sentences of the assertion in order to make the requirements literally more concise.


                                 Split pattern: requirements are split when they are composed of several more concise sub-requirements. The Split pattern has three types (AND split, OR split, XOR split). AND, OR, XOR denote the logic relations that have to be ensured between the sub-requirements obtained following a split operation.


                                 Modify pattern: requirements must be modified if they contain inconsistent information or errors. In that case, each problem must be handled individually, for traceability reasons. Any problem can be removed by adding some information, removing some information, or by changing at least a part of the requirement. Once again, engineers’ expertise is imperative here.

Note that there is a difference between the Clarify pattern and the Modify pattern. The precondition for using the Clarify pattern is that the requirement must be a correct one (ambiguity 
                           ≠
                         error), while Modify pattern is used when the requirement contains errors or contradictory parts. In order to describe the refinement process, a SysML/UML activity diagram illustrating the process is shown in Fig. 1
                        . The refinement process for a given requirement must be done until all its refined requirements become directly formalizable; this will be further explained in the sequel.

In what follows, we will discuss the various mechanisms backing our refinement process, while using the SysML standard notation.
                           3
                        
                        
                           3
                           
                              http://www.omgsysml.org.
                         SysML diagrams offer flexible artifacts, which extend the UML diagrams
                           4
                        
                        
                           4
                           Strictly speaking, SysML is a UML profile.
                         in such a way to deal with various aspects related to system engineering. In particular, the SysML requirement diagram is of great interest for the system specification phase. Here, the requirement diagrams will be used to describe both the refinement and formalization processes. The part regarding the formalization step will be discussed later on in the paper. However, even if SysML offers several stereotypes (i.e.,  refine, copy, containment and derive) in the SysML profile to describe the requirements’ relations, we still need to define some new stereotypes in order to set up the refinement patterns that we advocate to use. These stereotypes are shown in the profile diagram Fig. 2
                        .

In the new profile diagram operating at the metamodel level, the three refinement patterns (Clarify, Split and Modify) are correspondingly represented by new SysML stereotypes: ClarifyReq, SplitReq and ModifyReq. These stereotypes extend the Refine stereotype, defined in both UML Standard and SysML standard. Each stereotype has its own attributes. A detailed explanation will be given in the following.

We also give a class diagram shown in Fig. 3
                         illustrating different types of requirements generated during the refinement process. A requirement in a general sense can be refined as one or more requirements using the association class “Refine”, defined in the profile diagram shown in Fig. 2. A requirement can be either a raw requirement or a refined requirement. A raw requirement denotes a starting requirement directly taken from a requirement document. A refined requirement denotes a requirement handled by any refinement pattern. A formalizable requirement is a requirement that can be directly formalized as a property using the “Formalize” association-class. In our method, a property is a logic formula in 
                           
                              
                                 
                                    CTL
                                 
                              
                              
                                 ∗
                              
                           
                        . Obviously, formalizable requirement must be a refined requirement.

In the following, we will give the definition of each stereotype and its attributes, and we will explain how to use these stereotypes, while using some illustrative examples. 
                           Definition 3.1
                           ClarifyReq Stereotype


                           A requirement 
                                 
                                    
                                       R
                                    
                                    
                                       1
                                    
                                 
                               is ClarifyReq’ed as a requirement 
                                 
                                    
                                       R
                                    
                                    
                                       2
                                    
                                 
                               if 
                                 
                                    
                                       R
                                    
                                    
                                       1
                                    
                                 
                               is derived from 
                                 
                                    
                                       R
                                    
                                    
                                       2
                                    
                                 
                               by adding some precisions.

For the Clarify pattern, a ClarifyReq stereotype is proposed. It enables a requirement that is not precise enough (ambiguity or fuzzy information) to be more accurate. For example:


                        
                           
                              
                                 R
                              
                              
                                 1
                              
                           
                        : the train doors can be opened only when the train speed is slow.


                        
                           
                              
                                 R
                              
                              
                                 1
                              
                           
                         Contains fuzzy information “slow”, which does not contain significant meaning for the system specifications. In other words, it cannot be formalized. We can clarify the property “speed of train is slow” as “speed of 
                           
                              train
                           
                           ≤
                           2
                           
                           
                              km
                           
                           /
                           
                              h
                           
                        ”. So the clarified requirement is:


                        
                           
                              
                                 R
                              
                              
                                 2
                              
                           
                        : the train doors can be opened by the passengers only when the train speed 
                           ≤
                           2
                           
                           
                              km
                           
                           /
                           
                              h
                           
                        . Obviously, this speed limit (
                           2
                           
                           
                              km
                           
                           /
                           
                              h
                           
                        ) has to be defined with the expert.

Note that there is a special situation that we have introduced in Section  3.2, that is to remove some unnecessary or prolix information from the requirement to make it literally more concise. For example, for 
                           
                              
                                 R
                              
                              
                                 2
                              
                           
                        , “by the passengers” can be removed, as we do not care about who does the action, but only about the door control behavior.

Since three split refinement types (AND split, OR split, XOR split) have been proposed, we define an attribute “SplitWhatFromWhat” contained in the Split stereotype. This attribute is an enumeration class called SplitType containing three attributes (AND, OR, XOR) (see Fig. 2). These attributes have respectively the same function as the logic operators AND, OR and XOR in Boolean logic. Thus, for the Split stereotype, we give three definitions in the following. 
                           Definition 3.2
                           SplitReq (AND) Relation


                           A requirement 
                                 R
                               is SplitReq’ed (AND) as requirements 
                                 
                                    
                                       R
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    
                                       R
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                 …
                                 ,
                                 
                                    
                                       R
                                    
                                    
                                       n
                                    
                                 
                               iff each 
                                 
                                    
                                       R
                                    
                                    
                                       i
                                    
                                 
                               has to be satisfied in order to fulfill 
                                 R
                              .

This relationship enables a complex requirement to be decomposed into parts. A composite requirement may state that the system shall satisfy A and B and C, which can be decomposed into the requirements that the system shall do A, and the system shall do B, and the system shall do C. For this relation, all parts are required in order to fulfill the composite requirement. For example:


                        
                           
                              
                                 R
                              
                              
                                 3
                              
                           
                        : when the train speed 
                           ≤
                           2
                           
                           
                              km
                           
                           /
                           
                              h
                           
                        , the train door can be opened and the passenger access can be deployed.

Requirement 
                           
                              
                                 R
                              
                              
                                 3
                              
                           
                         can be split into two requirements 
                           
                              
                                 R
                              
                              
                                 4
                              
                           
                         and 
                           
                              
                                 R
                              
                              
                                 5
                              
                           
                        . Logically we say 
                           
                              
                                 R
                              
                              
                                 3
                              
                           
                           =
                           
                              
                                 R
                              
                              
                                 4
                              
                           
                           ⋅
                           
                              
                                 R
                              
                              
                                 5
                              
                           
                        .


                        
                           
                              
                                 R
                              
                              
                                 4
                              
                           
                        : when the train speed 
                           ≤
                           2
                           
                           
                              km
                           
                           /
                           
                              h
                           
                        , the train door can be opened.


                        
                           
                              
                                 R
                              
                              
                                 5
                              
                           
                        : when the train speed 
                           ≤
                           2
                           
                           
                              km
                           
                           /
                           
                              h
                           
                        , the passenger access can be deployed. 
                           Definition 3.3
                           SplitReq (OR) Relation


                           A requirement 
                                 R
                               is SplitReq’ed (OR) as requirements 
                                 
                                    
                                       R
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    
                                       R
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 …
                                 ,
                                 R
                                 n
                               iff at least one 
                                 
                                    
                                       R
                                    
                                    
                                       i
                                    
                                 
                               is satisfied to fulfill R.

This relationship enables a complex requirement to be split into several parts. If any of these parts is satisfied, then R is fulfilled. For example:


                        
                           
                              
                                 R
                              
                              
                                 6
                              
                           
                        : for the authorization of door opening, it is necessary that the driver push either of these two buttons for canceling the signal of door closing.

Requirement 
                           
                              
                                 R
                              
                              
                                 6
                              
                           
                         can be split into two requirements 
                           
                              
                                 R
                              
                              
                                 7
                              
                           
                         and 
                           
                              
                                 R
                              
                              
                                 8
                              
                           
                        . Logically we say 
                           
                              
                                 R
                              
                              
                                 7
                              
                           
                           +
                           
                              
                                 R
                              
                              
                                 8
                              
                           
                           ⇒
                           
                              
                                 R
                              
                              
                                 6
                              
                           
                        .


                        
                           
                              
                                 R
                              
                              
                                 7
                              
                           
                        : for the authorization of door opening, it is necessary that the driver push button_1 for cancelling the signal of door closing.


                        
                           
                              
                                 R
                              
                              
                                 8
                              
                           
                        : for the authorization of door opening, it is necessary that the driver push button_2 for canceling the signal of door closing. 
                           Definition 3.4
                           SplitReq (XOR) Relation


                           A requirement 
                                 R
                               is SplitReq’ed (XOR) as requirements 
                                 
                                    
                                       R
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    
                                       R
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                 …
                                 ,
                                 
                                    
                                       R
                                    
                                    
                                       n
                                    
                                 
                               iff only one 
                                 
                                    
                                       R
                                    
                                    
                                       i
                                    
                                 
                               is satisfied to fulfill 
                                 R
                              .

This relationship enables a complex requirement to be split into several parts. If and only if exactly one of these parts is satisfied, then 
                           R
                         is fulfilled. For example:


                        
                           
                              
                                 R
                              
                              
                                 9
                              
                           
                        : when an emergency is detected, only doors on one side of the train can be opened.

Requirement 
                           
                              
                                 R
                              
                              
                                 9
                              
                           
                         can be split into two requirements 
                           
                              
                                 R
                              
                              
                                 10
                              
                           
                         and 
                           
                              
                                 R
                              
                              
                                 11
                              
                           
                        . Logically we say 
                           
                              
                                 R
                              
                              
                                 10
                              
                           
                           ⊕
                           
                              
                                 R
                              
                              
                                 11
                              
                           
                           ⇒
                           
                              
                                 R
                              
                              
                                 9
                              
                           
                        .


                        
                           
                              
                                 R
                              
                              
                                 10
                              
                           
                        : when an emergency is detected, doors on left side of train must be opened and doors on right side must be closed.


                        
                           
                              
                                 R
                              
                              
                                 11
                              
                           
                        : when an emergency is detected, doors on right side of train must be opened and doors on left side must be closed.

For the Modification pattern, a ModifyReq stereotype is proposed. A ModifyReq stereotype has an attribute “How”, which is an enumeration type containing attributes Add, Remove, Change. Similarly to SplitReq stereotype, ModifyReq stereotype has three definitions as follows. 
                           Definition 3.5
                           ModifyReq (Add) Relation


                           A requirement 
                                 
                                    
                                       R
                                    
                                    
                                       1
                                    
                                 
                               is ModifyReq’ed (Add) as a requirement 
                                 
                                    
                                       R
                                    
                                    
                                       2
                                    
                                 
                              , if 
                                 
                                    
                                       R
                                    
                                    
                                       2
                                    
                                 
                               is derived from 
                                 
                                    
                                       R
                                    
                                    
                                       1
                                    
                                 
                               by adding new information to 
                                 
                                    
                                       R
                                    
                                    
                                       1
                                    
                                 
                              .


                        
                           Definition 3.6
                           ModifyReq (Remove) Relation


                           A requirement 
                                 
                                    
                                       R
                                    
                                    
                                       1
                                    
                                 
                               is ModifyReq’ed (Remove) as a requirement 
                                 
                                    
                                       R
                                    
                                    
                                       2
                                    
                                 
                              , if 
                                 
                                    
                                       R
                                    
                                    
                                       2
                                    
                                 
                               is derived from 
                                 
                                    
                                       R
                                    
                                    
                                       1
                                    
                                 
                               by removing some information from 
                                 
                                    
                                       R
                                    
                                    
                                       1
                                    
                                 
                              .


                        
                           Definition 3.7
                           ModifyReq (Change) Relation


                           A requirement 
                                 
                                    
                                       R
                                    
                                    
                                       1
                                    
                                 
                               is ModifyReq’ed (Change) as a requirement 
                                 
                                    
                                       R
                                    
                                    
                                       2
                                    
                                 
                              , if 
                                 
                                    
                                       R
                                    
                                    
                                       2
                                    
                                 
                               is derived from 
                                 
                                    
                                       R
                                    
                                    
                                       1
                                    
                                 
                               by replacing some information in 
                                 
                                    
                                       R
                                    
                                    
                                       1
                                    
                                 
                              .

These three relations allow us to remove errors in a requirement. For example:


                        
                           
                              
                                 R
                              
                              
                                 12
                              
                           
                        : when the train speed 
                           ≤
                           20
                           
                           
                              km
                           
                           /
                           
                              h
                           
                        , the train doors can be opened.

Requirement 
                           
                              
                                 R
                              
                              
                                 12
                              
                           
                         has wrong information “train speed 
                           ≤
                           20
                           
                           
                              km
                           
                           /
                           
                              h
                           
                        ”. Actually, it should be “train speed 
                           ≤
                           2
                           
                           
                              km
                           
                           /
                           
                              h
                           
                        ” based on the engineers’ expertise and on the railway standards. Hence, using the ModifyReq (Change) relation, 
                           
                              
                                 R
                              
                              
                                 12
                              
                           
                         can be modified as 
                           
                              
                                 R
                              
                              
                                 13
                              
                           
                        .


                        
                           
                              
                                 R
                              
                              
                                 13
                              
                           
                        : when the train speed 
                           ≤
                           2
                           
                           
                              km
                           
                           /
                           
                              h
                           
                        , the train doors can be opened.

In the sequel, we explain the various attributes associated with the refinement stereotypes discussed above.


                        Why attribute is a common attribute to the stereotypes associated with the refine super-class. It gives the reason why we need to perform the refinement. In general, this reason should be short and does not necessarily require a long argument. For example, if the requirement is “the train must move slowly into position X”, then the reason for this refinement can be a short explanation “‘slowly’ is not precise enough”, and we use the Clarify stereotype to refine this requirement.


                        Choice attribute (in ClarifyReq stereotype) gives information on the choice or the interpretation made by the domain experts about a fuzzy part of the requirement. When a problem is detected about a requirement, the argumentation will have to be complete enough to check the interpretation relevance. In the example above, “the train must move slowly when in situation X”, “slowly” is considered too imprecise and the expertise helps to know that the train velocity must be under 15 km/h in situation X. The minimum requirement for the field “Choice” can be written as: “In situation X, a train moves slowly if its velocity is under 15 km/h”. Any normative standard or any document justifying this speed must be specified.


                        SplitWhatFromWhat attribute (in SplitReq stereotype) is an enumeration type containing items AND, OR, XOR. This attribute must clearly indicate which split type will be used. For example, “X or Y are allowed if Z” can be decomposed as follows: “X is authorized if Z” and “Y is authorized if Z”; thus, the split type used is AND.


                        What attribute (in ModifyReq stereotype), as its name suggests, must inform about the part of the requirement that is modified and about what is added, removed or changed.


                        How attribute (in ModifyReq stereotype) is an enumeration type containing Add, Remove and Change attributes. Similar to SplitWhatFromWhat, it gives the choice of the modification type.

As explained earlier in the paper, the formalization step closes up the refinement procedure and allows for generating the logical formulas strictly speaking. When refining a given requirement, this step is performed as soon as the considered requirement is deemed to be “directly formalizable”. That amounts to say that 
                           R
                         does not need further refinement operations (Split, Modify, Clarify) and that 
                           R
                         is written in a form quite close to a logical formula, even though in a literal way. More concretely, this means that the involved variables can be deduced easily from the assertion, and the logical and dynamical (temporal) relationships between these variables can be inferred clearly.

In the same way as for the refinement process, the formalization step can be explained based on a SysML stereotype that we have developed:
                           Definition 3.8
                           Formalize Stereotype


                           We use Formalize stereotype to derive a logical property 
                                 P
                               from a directly formalizable requirement 
                                 R
                              .

Besides the attributes inherited from the upper classes (cf. Fig. 2), the Formalize stereotype has two specific attributes: 
                           
                              •
                              
                                 Variable attribute gives the mapping between the informal parts of the requirement and formal propositional variables or predicates. Abbreviations are allowed to make the variables more concise. For example, “Train_speed” can be written simply as “TS”.


                                 Formula attribute (in Formalize stereotype) gives the 
                                    
                                       
                                          
                                             CTL
                                          
                                       
                                       
                                          ∗
                                       
                                    
                                  formula denoting the formalization of the requirement.

We choose 
                           
                              
                                 
                                    CTL
                                 
                              
                              
                                 ∗
                              
                           
                        , which is a super-set of CTL and LTL, as a formalization framework. There are several reasons for the choice of the temporal logic 
                           
                              
                                 
                                    CTL
                                 
                              
                              
                                 ∗
                              
                           
                         as a target language for the formalization process for our requirement refinement method. Firstly, it can be handled by several model checking verification tools. Model checking is an automated technique that, given a finite-state model of a system and a formal property, systematically checks whether this property holds in that model  [41,42]. Traditionally temporal logics, which are propositional logics extended with special operators for time, are used to specify requirements on systems’ behavior as temporal properties. The advantage from using a temporal logic to express the properties that system behavior has to fulfill (requirements) is that such a notation allows for describing the behavior in a non unequivocal way, in the sense that it offers logical means based on mathematical foundations hence allowing rigor. In other terms, temporal logical properties can be interpreted in a unique way from the logical point of view, i.e., even if interpreted differently then the interpretations made are necessarily equivalent to each others. As for the expressiveness capabilities of 
                           
                              
                                 
                                    CTL
                                 
                              
                              
                                 ∗
                              
                           
                        , it is worthwhile to note that 
                           
                              
                                 
                                    CTL
                                 
                              
                              
                                 ∗
                              
                           
                         is a super-set of LTL and CTL  [43] temporal logics. It is known that some formulas expressed in CTL are inexpressible in LTL. Conversely, some formulas in LTL are inexpressible in CTL. This is a major drawback when considering using either of those logics as a framework. 
                           
                              
                                 
                                    CTL
                                 
                              
                              
                                 ∗
                              
                           
                        , whose expressiveness is strictly greater than both CTL and LTL logics, can be seen as a generalization of CTL by introducing some elements of LTL, and more. So, using 
                           
                              
                                 
                                    CTL
                                 
                              
                              
                                 ∗
                              
                           
                         allows us to express all the properties which can be written in LTL or in CTL.


                        
                           
                              
                                 
                                    CTL
                                 
                              
                              
                                 ∗
                              
                           
                         syntax can be defined while classifying the 
                           
                              
                                 
                                    CTL
                                 
                              
                              
                                 ∗
                              
                           
                         formulas into state and path formulas. State formulas are assertions about the atomic propositions in the states and their branching structure, while path formulas express temporal properties on paths. 
                           Definition 3.9
                           
                              
                                 
                                    
                                       
                                          CTL
                                       
                                    
                                    
                                       ∗
                                    
                                 
                               Syntax  [42]
                           


                           
                              
                                 
                                    
                                       
                                          CTL
                                       
                                    
                                    
                                       ∗
                                    
                                 
                               
                              state formulas over the set AP of atomic propositions, briefly called 
                                 
                                    
                                       
                                          CTL
                                       
                                    
                                    
                                       ∗
                                    
                                 
                               formulas, are formed according to the following grammar: 
                                 
                                    
                                       Φ
                                       ⩴
                                       
                                          true
                                       
                                       ∣
                                       a
                                       ∣
                                       
                                          
                                             Φ
                                          
                                          
                                             1
                                          
                                       
                                       ∧
                                       
                                          
                                             Φ
                                          
                                          
                                             2
                                          
                                       
                                       ∣
                                       ¬
                                       Φ
                                       ∣
                                       ∃
                                       φ
                                    
                                 
                               where 
                                 a
                                 ∈
                                 
                                    AP
                                 
                               and 
                                 φ
                               is a path formula. The syntax of a 
                                 
                                    
                                       
                                          CTL
                                       
                                    
                                    
                                       ∗
                                    
                                 
                               
                              path formula is given by the following grammar: 
                                 
                                    
                                       φ
                                       ⩴
                                       Φ
                                       ∣
                                       
                                          
                                             φ
                                          
                                          
                                             1
                                          
                                       
                                       ∧
                                       
                                          
                                             φ
                                          
                                          
                                             2
                                          
                                       
                                       ∣
                                       ¬
                                       φ
                                       ∣
                                       ○
                                       φ
                                       ∣
                                       
                                          
                                             φ
                                          
                                          
                                             1
                                          
                                       
                                       
                                          U
                                       
                                       
                                          
                                             φ
                                          
                                          
                                             2
                                          
                                       
                                    
                                 
                               where 
                                 Φ
                               is a state formula, and 
                                 
                                    
                                       φ
                                    
                                    
                                       1
                                    
                                 
                               and 
                                 
                                    
                                       φ
                                    
                                    
                                       2
                                    
                                 
                               are path formulas, 
                                 ○
                               is the “Next” operator, (
                                 
                                    U
                                 
                              ) is the “Until” operator. Note that by convention the Greek capital letters denote 
                                 
                                    
                                       
                                          CTL
                                       
                                    
                                    
                                       ∗
                                    
                                 
                               state formula, whereas lowercase Greek letters denote 
                                 
                                    
                                       
                                          CTL
                                       
                                    
                                    
                                       ∗
                                    
                                 
                               path formulas.

Thus, the “Until” operator (
                           
                              U
                           
                        ) allows us to derive the temporal modality “Finally (
                           ◊
                        )” (finally, sometimes in the future): 
                           ◊
                           φ
                           =
                           
                              true
                           
                           
                           
                              U
                           
                           φ
                         and the temporal modality “Globally (
                           □
                        )” (always, from now on forever) is defined as follows: 
                           □
                           φ
                           =
                           ¬
                           ◊
                           ¬
                           φ
                        , we can also derive other propositional logic operators like 
                           ∨
                           ,
                           →
                           ,
                           …
                         as for LTL or CTL. The universal path quantifier 
                           ∀
                         can be defined in 
                           
                              
                                 
                                    CTL
                                 
                              
                              
                                 ∗
                              
                           
                         by existential quantification 
                           ∃
                         and negation 
                           ¬
                        : 
                           ∀
                           φ
                           =
                           ¬
                           ∃
                           ¬
                           φ
                        . (Sometimes letters are used to represent logical operators, i.e., 
                           
                              A
                           
                         for the 
                           A
                        ll operator 
                           ∀
                        , 
                           
                              E
                           
                         for the 
                           Exist operator 
                           ∃
                        , 
                           
                              X
                           
                         for neXt operator 
                           ○
                        , 
                           
                              G
                           
                         for the 
                           Globally operator 
                           □
                        , 
                           
                              F
                           
                         for the 
                           Finally operator 
                           ◊
                        .)


                        
                           
                              
                                 
                                    CTL
                                 
                              
                              
                                 ∗
                              
                           
                         is obviously more expressive than LTL and CTL. We can get this result by comparing the syntax of each of these logics. In the following, we review the syntax of LTL and CTL. 
                           Definition 3.10
                           LTL Syntax  [42]
                           


                           LTL formula over the set AP of atomic propositions are formed according to the following grammar: 
                                 
                                    
                                       φ
                                       ⩴
                                       
                                          true
                                       
                                       
                                       ∣
                                       a
                                       ∣
                                       
                                          
                                             φ
                                          
                                          
                                             1
                                          
                                       
                                       ∧
                                       
                                          
                                             φ
                                          
                                          
                                             2
                                          
                                       
                                       ∣
                                       ¬
                                       φ
                                       ∣
                                       ○
                                       φ
                                       ∣
                                       
                                          
                                             φ
                                          
                                          
                                             1
                                          
                                       
                                       
                                          U
                                       
                                       
                                          
                                             φ
                                          
                                          
                                             2
                                          
                                       
                                       ,
                                       
                                       where  
                                       a
                                       ∈
                                       
                                          AP
                                       
                                       .
                                    
                                 
                              
                           

Other logic modalities in LTL such as 
                           ◊
                         and 
                           □
                         can be also derived (see the above…). For instance: 
                           □
                           ◊
                           φ
                         means “infinitely often” denoting that the (path) property stating that at any moment 
                           j
                         there is a moment 
                           i
                           ≥
                           j
                         at which a 
                           φ
                        -state is visited. The dual modality 
                           ◊
                           □
                           φ
                         (eventually forever) expresses that from some moment 
                           j
                         on, only 
                           φ
                        -states are visited. Like 
                           
                              
                                 
                                    CTL
                                 
                              
                              
                                 ∗
                              
                           
                        , CTL also has state and path formulas. 
                           Definition 3.11
                           CTL Syntax


                           
                              [42] CTL state formula over the set AP of atomic propositions are formed according to the following syntax: 
                                 
                                    
                                       Φ
                                       ⩴
                                       
                                          true
                                       
                                       ∣
                                       a
                                       ∣
                                       
                                          
                                             Φ
                                          
                                          
                                             1
                                          
                                       
                                       ∧
                                       
                                          
                                             Φ
                                          
                                          
                                             2
                                          
                                       
                                       ∣
                                       ¬
                                       Φ
                                       ∣
                                       ∃
                                       φ
                                       ∣
                                       ∀
                                       φ
                                    
                                 
                               where 
                                 a
                                 ∈
                                 
                                    AP
                                 
                               and 
                                 φ
                               is a path formula. CTL path formula are formed according to the following syntax: 
                                 
                                    
                                       φ
                                       ⩴
                                       ○
                                       Φ
                                       ∣
                                       
                                          
                                             Φ
                                          
                                          
                                             1
                                          
                                       
                                       
                                          U
                                       
                                       
                                          
                                             Φ
                                          
                                          
                                             2
                                          
                                       
                                    
                                 
                               where 
                                 φ
                              , 
                                 
                                    
                                       φ
                                    
                                    
                                       1
                                    
                                 
                               and 
                                 
                                    
                                       φ
                                    
                                    
                                       2
                                    
                                 
                               are state formulas.

For a short conclusion, the relationship among LTL, CTL, 
                           
                              
                                 
                                    CTL
                                 
                              
                              
                                 ∗
                              
                           
                         is depicted in Fig. 4
                        .

The semantics of 
                           
                              
                                 
                                    CTL
                                 
                              
                              
                                 ∗
                              
                           
                         formulas are defined with respect to Labelled Transition Systems (LTS) which can express the semantics of a various range of discrete notations (automata, Petri nets, etc.). 
                           Definition 3.12
                           LTS


                           A labelled transition system LTS is a six-tuple 
                                 M
                                 =
                                 
                                    (
                                    S
                                    ,
                                    
                                       Act
                                    
                                    ,
                                    →
                                    ,
                                    I
                                    ,
                                    
                                       AP
                                    
                                    ,
                                    L
                                    )
                                 
                              , where: 
                                 
                                    –
                                    
                                       
                                          S
                                        is a set of states,


                                       
                                          
                                             Act
                                          
                                        is a set of actions,


                                       
                                          →
                                          ⊆
                                          S
                                          ×
                                          
                                             Act
                                          
                                          ×
                                          S
                                        is the transition relation,


                                       
                                          I
                                          ⊆
                                          S
                                        is the set of initial states,


                                       
                                          
                                             AP
                                          
                                        is a set of atomic propositions, and 
                                          L
                                          :
                                          S
                                          →
                                          
                                             
                                                2
                                             
                                             
                                                
                                                   AP
                                                
                                             
                                          
                                        is a labelling function.

Let 
                           a
                           ∈
                           
                              AP
                           
                         be an atomic proposition, 
                           M
                         be a transition system without terminal states, state 
                           s
                           ∈
                           S
                        , 
                           Φ
                           ,
                           Ψ
                         be 
                           
                              
                                 
                                    CTL
                                 
                              
                              
                                 ∗
                              
                           
                         state formulas, and 
                           
                              
                                 φ
                              
                              
                                 1
                              
                           
                         and 
                           
                              
                                 φ
                              
                              
                                 2
                              
                           
                         be 
                           
                              
                                 
                                    CTL
                                 
                              
                              
                                 ∗
                              
                           
                         path formulas. 
                           Definition 3.13
                           
                              
                                 
                                    
                                       
                                          CTL
                                       
                                    
                                    
                                       ∗
                                    
                                 
                               Semantics  [42]
                           


                           The satisfaction relation 
                                 ⊧
                               is defined for state formulas by: 
                                 
                                    –
                                    
                                       
                                          s
                                          ⊧
                                          a
                                        iff 
                                          a
                                          ∈
                                          L
                                          
                                             (
                                             s
                                             )
                                          
                                       
                                    


                                       
                                          s
                                          ⊧
                                          ¬
                                          Φ
                                        iff not 
                                          
                                             (
                                             s
                                             ⊧
                                             Φ
                                             )
                                          
                                       
                                    


                                       
                                          s
                                          ⊧
                                          Φ
                                          ∧
                                          Ψ
                                        iff (
                                          s
                                          ⊧
                                          Φ
                                        and 
                                          s
                                          ⊧
                                          Ψ
                                       )


                                       
                                          s
                                          ⊧
                                          ∃
                                          φ
                                        iff (
                                          π
                                          ⊧
                                          φ
                                        for some 
                                          π
                                          ∈
                                          
                                             Paths
                                          
                                          
                                             (
                                             s
                                             )
                                          
                                       ), where Paths(s) denotes the set of maximal path fragments of the transition system.

For a given path 
                                 π
                              , the satisfaction relation 
                                 ⊧
                               for a given path formula is defined by: 
                                 
                                    –
                                    
                                       
                                          π
                                          ⊧
                                          Φ
                                        iff 
                                          
                                             
                                                s
                                             
                                             
                                                0
                                             
                                          
                                          ⊧
                                          Φ
                                       
                                    


                                       
                                          π
                                          ⊧
                                          
                                             
                                                φ
                                             
                                             
                                                1
                                             
                                          
                                          ∧
                                          
                                             
                                                φ
                                             
                                             
                                                2
                                             
                                          
                                        iff 
                                          π
                                          ⊧
                                          
                                             
                                                φ
                                             
                                             
                                                1
                                             
                                          
                                        and 
                                          π
                                          ⊧
                                          
                                             
                                                φ
                                             
                                             
                                                2
                                             
                                          
                                       
                                    


                                       
                                          π
                                          ⊧
                                          ¬
                                          φ
                                        iff not 
                                          π
                                          ⊧
                                          φ
                                       
                                    


                                       
                                          π
                                          ⊧
                                          ○
                                          φ
                                        iff 
                                          π
                                          
                                             [
                                             1
                                             .
                                             .
                                             ]
                                          
                                          ⊧
                                          φ
                                       
                                    


                                       
                                          π
                                          ⊧
                                          
                                             
                                                φ
                                             
                                             
                                                1
                                             
                                          
                                          
                                             U
                                          
                                          
                                             
                                                φ
                                             
                                             
                                                2
                                             
                                          
                                        iff 
                                          
                                             (
                                             ∃
                                             j
                                             ⩾
                                             0
                                             )
                                          
                                          
                                             (
                                             π
                                             
                                                [
                                                j
                                                .
                                                .
                                                ]
                                             
                                             ⊧
                                             
                                                
                                                   φ
                                                
                                                
                                                   2
                                                
                                             
                                             ∧
                                             
                                                (
                                                
                                                   (
                                                   ∀
                                                   0
                                                   ⩽
                                                   k
                                                   <
                                                   j
                                                   )
                                                
                                                
                                                
                                                   (
                                                   π
                                                   
                                                      [
                                                      k
                                                      .
                                                      .
                                                      ]
                                                   
                                                   ⊧
                                                   
                                                      
                                                         φ
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                   )
                                                
                                                )
                                             
                                             )
                                          
                                       
                                    

For example, to specify that “a system must always answer to a request”, one possible interpretation using 
                           
                              
                                 
                                    CTL
                                 
                              
                              
                                 ∗
                              
                           
                         is “
                           
                              AG
                           
                           
                              (
                              
                                 request
                              
                              →
                              
                                 AF
                              
                              
                              
                                 answer
                              
                              )
                           
                        ”, literally read as “For every execution and on every step of each execution, if a request (is sent), then for every subsequent execution there will be an answer”.


                        
                           
                              
                                 
                                    CTL
                                 
                              
                              
                                 ∗
                              
                           
                         is quite complex for model-checking in practice; so, when possible, it is often better to use the corresponding sub-logic instead of 
                           
                              
                                 
                                    CTL
                                 
                              
                              
                                 ∗
                              
                           
                        . We know at least one tool that can perform model-checking directly based on 
                           
                              
                                 
                                    CTL
                                 
                              
                              
                                 ∗
                              
                           
                         formula: Altarica  [44]. But the majority of tools handle either CTL or LTL or both (like NuSMV  [45], SPIN  [46]).

The requirement refinement method is a Top-Down process, which has numerous levels. Each level of the refinement is a further refinement of an upper-level requirement. In the top level of the refinement process, we have a raw requirement 
                           R
                        , while in the bottom level we get a set of formalizable requirements derived from 
                           R
                        . In the formalization step, each formalizable requirement is formalized as a property 
                           P
                        . Thus, a raw requirement shall “hold” a set of properties after the refinement and formalization processes. The set of properties can be verified and validated individually or in groups. If the properties are checked together, we must know the logic relations between these properties. For this reason, we give the formal definition of property relations according to different stereotypes that we have set up.

For the ClarifyReq stereotype, we define: 
                              Definition 3.14
                              Let a requirement 
                                    R
                                  hold a property 
                                    P
                                 . Then, if 
                                    R
                                  is derived from 
                                    
                                       
                                          R
                                       
                                       
                                          ′
                                       
                                    
                                  in its upper level and in the case when 
                                    R
                                  is ClarifyReq’ed by 
                                    
                                       
                                          R
                                       
                                       
                                          ′
                                       
                                    
                                 , then 
                                    
                                       
                                          R
                                       
                                       
                                          ′
                                       
                                    
                                  holds a property 
                                    
                                       
                                          P
                                       
                                       
                                          ′
                                       
                                    
                                 , we write 
                                    
                                       
                                          R
                                       
                                       
                                          ′
                                       
                                    
                                    
                                       
                                          ⟶
                                       
                                       
                                          
                                             hold
                                          
                                       
                                    
                                    
                                       
                                          P
                                       
                                       
                                          ′
                                       
                                    
                                 ; 
                                    
                                       
                                          P
                                       
                                       
                                          ′
                                       
                                    
                                  is inherited from 
                                    P
                                  and 
                                    
                                       (1)
                                       
                                          
                                             
                                                P
                                             
                                             
                                                ′
                                             
                                          
                                          ≈
                                          P
                                          .
                                       
                                    
                                 
                              

For the ModifyReq stereotype, we define: 
                              Definition 3.15
                              Let a requirement 
                                    R
                                  hold a property 
                                    P
                                 . Then, if 
                                    R
                                  is derived from 
                                    
                                       
                                          R
                                       
                                       
                                          ′
                                       
                                    
                                  in its upper level and in the case when 
                                    R
                                  is ClarifyReq’ed (Add, Remove, Change)by 
                                    
                                       
                                          R
                                       
                                       
                                          ′
                                       
                                    
                                 , then 
                                    
                                       
                                          R
                                       
                                       
                                          ′
                                       
                                    
                                  holds a property 
                                    
                                       
                                          P
                                       
                                       
                                          ′
                                       
                                    
                                 , we say 
                                    
                                       
                                          R
                                       
                                       
                                          ′
                                       
                                    
                                    
                                       
                                          ⟶
                                       
                                       
                                          
                                             hold
                                          
                                       
                                    
                                    
                                       
                                          P
                                       
                                       
                                          ′
                                       
                                    
                                 ; 
                                    
                                       
                                          P
                                       
                                       
                                          ′
                                       
                                    
                                  is inherited from 
                                    P
                                  and 
                                    
                                       (2)
                                       
                                          
                                             
                                                P
                                             
                                             
                                                ′
                                             
                                          
                                          ≈
                                          P
                                          .
                                       
                                    
                                 
                              

For SplitReq stereotype, we define: 
                              Definition 3.16
                              let 
                                    R
                                  be a set of requirements 
                                    
                                       {
                                       
                                          
                                             r
                                          
                                          
                                             1
                                          
                                       
                                       ,
                                       …
                                       ,
                                       
                                          
                                             r
                                          
                                          
                                             n
                                          
                                       
                                       }
                                    
                                 , 
                                    P
                                  be a set of properties 
                                    
                                       {
                                       
                                          
                                             p
                                          
                                          
                                             1
                                          
                                       
                                       ,
                                       …
                                       ,
                                       
                                          
                                             p
                                          
                                          
                                             n
                                          
                                       
                                       }
                                    
                                 , and 
                                    
                                       
                                          r
                                       
                                       
                                          1
                                       
                                    
                                    
                                       
                                          ⟶
                                       
                                       
                                          
                                             hold
                                          
                                       
                                    
                                    
                                       
                                          p
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       
                                          r
                                       
                                       
                                          n
                                       
                                    
                                    
                                    
                                       
                                          ⟶
                                       
                                       
                                          
                                             hold
                                          
                                       
                                    
                                    
                                       
                                          p
                                       
                                       
                                          n
                                       
                                    
                                 , 
                                    R
                                  is derived from 
                                    
                                       
                                          R
                                       
                                       
                                          ′
                                       
                                    
                                  in its upper level.

If 
                                    R
                                  is SplitReq’ed (AND) by 
                                    
                                       
                                          R
                                       
                                       
                                          ′
                                       
                                    
                                 , then 
                                    
                                       
                                          R
                                       
                                       
                                          ′
                                       
                                    
                                  holds a property 
                                    
                                       
                                          P
                                       
                                       
                                          ′
                                       
                                    
                                 , we write 
                                    
                                       
                                          R
                                       
                                       
                                          ′
                                       
                                    
                                    
                                       
                                          ⟶
                                       
                                       
                                          
                                             hold
                                          
                                       
                                    
                                    
                                       
                                          P
                                       
                                       
                                          ′
                                       
                                    
                                  and 
                                    
                                       (3)
                                       
                                          
                                             
                                                P
                                             
                                             
                                                ′
                                             
                                          
                                          =
                                          
                                             (
                                             
                                                
                                                   p
                                                
                                                
                                                   1
                                                
                                             
                                             ∧
                                             ⋯
                                             ∧
                                             
                                                
                                                   p
                                                
                                                
                                                   n
                                                
                                             
                                             )
                                          
                                          ,
                                          
                                          n
                                          >
                                          1
                                          .
                                       
                                    
                                 
                              

If 
                                    R
                                  is SplitReq’ed (OR) by 
                                    R
                                 ’, then 
                                    
                                       
                                          R
                                       
                                       
                                          ′
                                       
                                    
                                  holds a property 
                                    
                                       
                                          P
                                       
                                       
                                          ′
                                       
                                    
                                 , we write 
                                    
                                       
                                          R
                                       
                                       
                                          ′
                                       
                                    
                                    
                                       
                                          ⟶
                                       
                                       
                                          
                                             hold
                                          
                                       
                                    
                                    
                                       
                                          P
                                       
                                       
                                          ′
                                       
                                    
                                  and 
                                    
                                       (4)
                                       
                                          
                                             
                                                P
                                             
                                             
                                                ′
                                             
                                          
                                          =
                                          
                                             (
                                             
                                                
                                                   p
                                                
                                                
                                                   1
                                                
                                             
                                             ∨
                                             ⋯
                                             ∨
                                             
                                                
                                                   p
                                                
                                                
                                                   n
                                                
                                             
                                             )
                                          
                                          ,
                                          
                                          n
                                          >
                                          1
                                          .
                                       
                                    
                                 
                              

If 
                                    R
                                  is SplitReq’ed (XOR) by 
                                    R
                                 ’, then 
                                    
                                       
                                          R
                                       
                                       
                                          ′
                                       
                                    
                                  holds a property 
                                    
                                       
                                          P
                                       
                                       
                                          ′
                                       
                                    
                                 , we say 
                                    
                                       
                                          R
                                       
                                       
                                          ′
                                       
                                    
                                    
                                       
                                          ⟶
                                       
                                       
                                          
                                             hold
                                          
                                       
                                    
                                    
                                       
                                          P
                                       
                                       
                                          ′
                                       
                                    
                                  and 
                                    
                                       
                                          (5)
                                          
                                             
                                                
                                                   P
                                                
                                                
                                                   ′
                                                
                                             
                                             =
                                             
                                                (
                                                
                                                   
                                                      p
                                                   
                                                   
                                                      1
                                                   
                                                
                                                ∧
                                                ¬
                                                
                                                   
                                                      p
                                                   
                                                   
                                                      2
                                                   
                                                
                                                ∧
                                                ⋯
                                                ∧
                                                ¬
                                                
                                                   
                                                      p
                                                   
                                                   
                                                      n
                                                   
                                                
                                                )
                                             
                                             ∨
                                             ⋯
                                             ∨
                                             
                                                (
                                                ¬
                                                
                                                   
                                                      p
                                                   
                                                   
                                                      1
                                                   
                                                
                                                ∧
                                                ¬
                                                
                                                   
                                                      p
                                                   
                                                   
                                                      2
                                                   
                                                
                                                ∧
                                                ⋯
                                                ∧
                                                
                                                   
                                                      p
                                                   
                                                   
                                                      n
                                                   
                                                
                                                )
                                             
                                          
                                       
                                       
                                          
                                             n
                                             >
                                             1
                                             .
                                          
                                       
                                    
                                 
                              

Note that for the ClarifyReq and ModifyReq stereotypes, a property is directly transmitted to its upper-level requirement. These two requirements semantically “hold” the same logic formula even though they are literally different. We use logic operator “
                              ≈
                           ” to express such a relation.

As one can notice from the property relation definitions, these relations are established in a bottom-up process. This indicates that the upper-level requirement can only “hold” its property when the refinement process is accomplished. According to this discipline, we define a Bottom-up approach to infer the property relations for each refinement level, and a logic property is associated to each requirement of the refinement tree. We call this procedure a “Bottom-up Tracing Process”. The goal is to establish the logical formula brought by the original raw refinement. Let us illustrate the Bottom-up tracing process through the following example.

Assume we have a raw requirement 
                              
                                 
                                    R
                                 
                                 
                                    1
                                 
                              
                           . The refinement and formalization process for 
                              
                                 
                                    R
                                 
                                 
                                    1
                                 
                              
                            is shown in Fig. 5
                           . The refinement process can be described as follows:


                           
                              
                                 
                                    R
                                 
                                 
                                    1
                                 
                              
                            is first ModifyReq’ed as 
                              
                                 
                                    R
                                 
                                 
                                    1.1
                                 
                              
                           ; 
                              
                                 
                                    R
                                 
                                 
                                    1.1
                                 
                              
                            is ClarifyReq’ed as 
                              
                                 
                                    R
                                 
                                 
                                    1.2
                                 
                              
                           ; 
                              
                                 
                                    R
                                 
                                 
                                    1.2
                                 
                              
                            is SplitReq’ed (AND) as 
                              
                                 {
                                 
                                    
                                       R
                                    
                                    
                                       1.2.1
                                    
                                 
                                 ,
                                 
                                    
                                       R
                                    
                                    
                                       1.2.2
                                    
                                 
                                 }
                              
                           ; 
                              
                                 
                                    R
                                 
                                 
                                    1.2.1
                                 
                              
                            is SplitReq’ed (OR) as 
                              
                                 {
                                 
                                    
                                       R
                                    
                                    
                                       1.2.1.1
                                    
                                 
                                 ,
                                 
                                    
                                       R
                                    
                                    
                                       1.2.1.2
                                    
                                 
                                 }
                              
                           ; 
                              
                                 
                                    R
                                 
                                 
                                    1.2.2
                                 
                              
                            is SplitReq’ed (XOR) as 
                              
                                 {
                                 
                                    
                                       R
                                    
                                    
                                       1.2.2.1
                                    
                                 
                                 ,
                                 
                                    
                                       R
                                    
                                    
                                       1.2.2.2
                                    
                                 
                                 }
                              
                           . Each requirement in the set 
                              
                                 {
                                 
                                    
                                       R
                                    
                                    
                                       1.2.1.1
                                    
                                 
                                 ,
                                 
                                    
                                       R
                                    
                                    
                                       1.2.1.2
                                    
                                 
                                 ,
                                 
                                    
                                       R
                                    
                                    
                                       1.2.2.1
                                    
                                 
                                 ,
                                 
                                    
                                       R
                                    
                                    
                                       1.2.2.2
                                    
                                 
                                 }
                              
                            is then formalized respectively into a 
                              
                                 
                                    
                                       CTL
                                    
                                 
                                 
                                    ∗
                                 
                              
                            property. Thus, the set of properties is 
                              
                                 {
                                 
                                    
                                       P
                                    
                                    
                                       1.2.1.1
                                    
                                 
                                 ,
                                 
                                    
                                       P
                                    
                                    
                                       1.2.1.2
                                    
                                 
                                 ,
                                 
                                    
                                       P
                                    
                                    
                                       1.2.2.1
                                    
                                 
                                 ,
                                 
                                    
                                       P
                                    
                                    
                                       1.2.2.2
                                    
                                 
                                 }
                              
                           .

The Bottom-up tracing process for identifying property relations is shown in Fig. 6
                           . We describe the process as follows: 
                              
                                 1.
                                 
                                    
                                       
                                          {
                                          
                                             
                                                R
                                             
                                             
                                                1.2.1.1
                                             
                                          
                                          ,
                                          
                                             
                                                R
                                             
                                             
                                                1.2.1.2
                                             
                                          
                                          }
                                       
                                     is SplitReq’ed (OR) by 
                                       
                                          
                                             R
                                          
                                          
                                             1.2.1
                                          
                                       
                                    , then 
                                       
                                          
                                             R
                                          
                                          
                                             1.2.1
                                          
                                       
                                       
                                          
                                             ⟶
                                          
                                          
                                             
                                                hold
                                             
                                          
                                       
                                       
                                          
                                             P
                                          
                                          
                                             1.2.1
                                          
                                       
                                    , and 
                                       
                                          
                                             P
                                          
                                          
                                             1.2.1
                                          
                                       
                                       =
                                       
                                          
                                             P
                                          
                                          
                                             1.2.1.1
                                          
                                       
                                       ∨
                                       
                                          
                                             P
                                          
                                          
                                             1.2.1.2
                                          
                                       
                                    . According to (4).


                                    
                                       
                                          {
                                          
                                             
                                                R
                                             
                                             
                                                1.2.2.1
                                             
                                          
                                          ,
                                          
                                             
                                                R
                                             
                                             
                                                1.2.2.2
                                             
                                          
                                          }
                                       
                                     is SplitReq’ed (XOR) by 
                                       
                                          
                                             R
                                          
                                          
                                             1.2.2
                                          
                                       
                                    , then 
                                       
                                          
                                             R
                                          
                                          
                                             1.2.2
                                          
                                       
                                       
                                          
                                             ⟶
                                          
                                          
                                             
                                                hold
                                             
                                          
                                       
                                       
                                          
                                             P
                                          
                                          
                                             1.2.2
                                          
                                       
                                    , and 
                                       
                                          
                                             P
                                          
                                          
                                             1.2.2
                                          
                                       
                                       =
                                       
                                          (
                                          ¬
                                          
                                             
                                                P
                                             
                                             
                                                1.2.2.1
                                             
                                          
                                          ∧
                                          
                                             
                                                P
                                             
                                             
                                                1.2.2.2
                                             
                                          
                                          )
                                       
                                       ∨
                                       
                                          (
                                          
                                             
                                                P
                                             
                                             
                                                1.2.2.1
                                             
                                          
                                          ∧
                                          ¬
                                          
                                             
                                                P
                                             
                                             
                                                1.2.2.2
                                             
                                          
                                          )
                                       
                                    . According to (5).


                                    
                                       
                                          {
                                          
                                             
                                                R
                                             
                                             
                                                1.2.1
                                             
                                          
                                          ,
                                          
                                             
                                                R
                                             
                                             
                                                1.2.2
                                             
                                          
                                          }
                                       
                                     is SplitReq’ed (AND) by 
                                       
                                          
                                             R
                                          
                                          
                                             1.2
                                          
                                       
                                    , then 
                                       
                                          
                                             R
                                          
                                          
                                             1.2
                                          
                                       
                                       
                                          
                                             ⟶
                                          
                                          
                                             
                                                hold
                                             
                                          
                                       
                                       P
                                       1.2
                                    , and 
                                       
                                          
                                             P
                                          
                                          
                                             1.2
                                          
                                       
                                       =
                                       
                                          
                                             P
                                          
                                          
                                             1.2.1
                                          
                                       
                                       ∧
                                       
                                          
                                             P
                                          
                                          
                                             1.2.2
                                          
                                       
                                       =
                                       
                                          (
                                          
                                             
                                                P
                                             
                                             
                                                1.2.1.1
                                             
                                          
                                          ∨
                                          
                                             
                                                P
                                             
                                             
                                                1.2.1.2
                                             
                                          
                                          )
                                       
                                       ∧
                                       
                                          (
                                          
                                             (
                                             ¬
                                             
                                                
                                                   P
                                                
                                                
                                                   1.2.2.1
                                                
                                             
                                             ∧
                                             
                                                
                                                   P
                                                
                                                
                                                   1.2.2.2
                                                
                                             
                                             )
                                          
                                          ∨
                                          
                                             (
                                             
                                                
                                                   P
                                                
                                                
                                                   1.2.2.1
                                                
                                             
                                             ∧
                                             ¬
                                             
                                                
                                                   P
                                                
                                                
                                                   1.2.2.2
                                                
                                             
                                             )
                                          
                                          )
                                       
                                    . According to (3).


                                    
                                       
                                          
                                             R
                                          
                                          
                                             1.1
                                          
                                       
                                     is ClarifyReq’ed by 
                                       
                                          
                                             R
                                          
                                          
                                             1.2
                                          
                                       
                                    , 
                                       
                                          
                                             R
                                          
                                          
                                             1
                                          
                                       
                                     is ModifyReq’ed by 
                                       
                                          
                                             R
                                          
                                          
                                             1.1
                                          
                                       
                                    , then 
                                       
                                          
                                             R
                                          
                                          
                                             1.1
                                          
                                       
                                       
                                          
                                             ⟶
                                          
                                          
                                             
                                                hold
                                             
                                          
                                       
                                       
                                          
                                             P
                                          
                                          
                                             1.1
                                          
                                       
                                    , 
                                       
                                          
                                             R
                                          
                                          
                                             1
                                          
                                       
                                       
                                          
                                             ⟶
                                          
                                          
                                             
                                                hold
                                             
                                          
                                       
                                       
                                          
                                             P
                                          
                                          
                                             1
                                          
                                       
                                    , and 
                                       P
                                       1
                                       ≈
                                       
                                          
                                             P
                                          
                                          
                                             1.1
                                          
                                       
                                       ≈
                                       
                                          
                                             P
                                          
                                          
                                             1.2
                                          
                                       
                                    . According to (1) and (2).

Hence, the logical formula expressed by the original raw requirement 
                              
                                 
                                    R
                                 
                                 
                                    1
                                 
                              
                            is: 
                              
                                 (
                                 
                                    
                                       P
                                    
                                    
                                       1.2.1.1
                                    
                                 
                                 ∨
                                 
                                    
                                       P
                                    
                                    
                                       1.2.1.2
                                    
                                 
                                 )
                              
                              ∧
                              
                                 (
                                 
                                    (
                                    ¬
                                    
                                       
                                          P
                                       
                                       
                                          1.2.2.1
                                       
                                    
                                    ∧
                                    
                                       
                                          P
                                       
                                       
                                          1.2.2.2
                                       
                                    
                                    )
                                 
                                 ∨
                                 
                                    (
                                    
                                       
                                          P
                                       
                                       
                                          1.2.2.1
                                       
                                    
                                    ∧
                                    ¬
                                    
                                       
                                          P
                                       
                                       
                                          1.2.2.2
                                       
                                    
                                    )
                                 
                                 )
                              
                           .

@&#DISCUSSION@&#

Although the various operations that can be performed all along the developed technique have been clearly detailed and illustrated, still some precautions need to be taken while applying the technique. Moreover, some heuristic rules can be established in such a way as to guide and optimize the refinement process. The following discussion gives a list of observations to be considered for the sake of efficiency, as well as some further remarks. 
                        
                           1.
                           
                              Priority: for the refinement process, some priorities can be useful to reduce the steps of refinement. We prefer to use Clarify and Modify pattern first, Split pattern last. For example, if a requirement is first split into two sub-requirements, and then every sub-requirement is clarified. In this way, four steps are performed. On the contrary, if we clarify the requirement first and split it then, afterwards, three steps are enough.


                              Be careful to use modify pattern: in any case, modifying a requirement has to be carried out very carefully and the domain expertise is fundamental. Indeed, the modified requirement may not be completely correct regarding the system we want to check. An inconsiderate modification can have major and obvious negative consequences.


                              Verification: for the verification purpose, each property or a group of properties can be checked. Firstly, when a set of properties 
                                 P
                               is derived from its upper-level requirement, only using the Modify, Clarify, Split (AND) pattern, then each property in 
                                 P
                               can be checked individually. Secondly, if the Split (OR, XOR) pattern has to be used, then the generated properties have to be checked, while taking into account the logical relation OR, XOR that links the properties with each other.


                              Integrating informal and formal methods: the requirement refinement method is just a part of the whole specification techniques. It is used for abstracting the accurate information from requirement documents until they become close to a formal specification. It is useful to abstract the behavioral or functional aspects of control systems. For identifying other aspects of a system, such as structural aspects, informal or semi-formal techniques are appreciated. In practice, we always make use of different informal and formal methods together for a complete requirement specification.


                              Traceability: in  [47], the authors give a definition of requirement traceability. “Requirements traceability refers to the ability to describe and follow the life of a requirement, in both a forwards and backwards direction (i.e., from its origins, through its development and specification, to its subsequent deployment and use, and through periods of on-going refinement and iteration in any of these phases). With the refinement method, a stereotype is essentially a relationship between two requirements. The attributes (Why, How, SplitWhatFromWhat etc.) contained in our defined stereotypes keep the detailed information about the change from one requirement to another. In this manner, the requirement traceability can be guaranteed through the stereotypes we have defined.


                              Generalization: although system specifications may be quite different according to the application field, the method discussed here is quite generic, since the developed refinement mechanisms do not rely on the information carried in the specification, but rather on the quality of its expressiveness and its structure.

In this section, we briefly illustrate our approach through a case study selected from a real train control system requirement document. As one can observe, the original requirement shows different problems and remains hard to understand in a precise way. In what follows, we show how such a requirement can be handled using our refinement method. This allows for illustrating some established artifacts in a practical way.


                     
                        Example 5.1
                        Train Door Control System executes functions such as opening doors, closing doors, choosing side service and unlocking doors. The electrical control modules situated in the doors of each car on the train implements these functions, and interacts with a series of subsystems, e.g. central console, train position sensors, alarms. The system handles two kinds of signals, general commands from the central console located in the driving cabin and local commands from each car. When the passengers push the buttons to open the doors, the system must verify whether the doors are authorized to be opened. The conditions of generating the authorization of door opening are described as follows:
                              
                                 1.
                                 Some buttons can allow the driver to generate the authorization for door opening. (Note: For authorizing the door opening, the closing door signal must be canceled.) 
                                       
                                          (a)
                                          A push button for canceling the signal of closing the right-hand doors, which is located on the console.

A push button for canceling the signal of closing the left-hand doors, which is located on the console.

A push button for canceling the signal of closing the right-hand doors, which is located near the right side of the window in the driving cabin.

A push button for canceling the signal of closing the left-hand doors, which is located near the left side of the window in the driving cabin.

When the train speed is 
                                       ≤
                                       5
                                       
                                       
                                          km
                                       
                                       /
                                       
                                          h
                                       
                                    , if the doors are closed and locked, the doors can be authorized to be opened.

Let us consider the above requirement as the raw requirement denoted by 
                        R
                     . Thus, the refinement process can be performed in the following steps shown in Fig. 7
                     , using a SysML requirement diagram. Because of the limits of the modeling tool (Topcased
                        5
                     
                     
                        5
                        
                           http://www.topcased.org.
                     ), the attributes of each stereotype are hidden and the logic connectors are not allowed in the attributes’ text field. Here, we write the formalization as follows:


                     
                        
                           
                              R
                           
                           
                              1.2.1.1
                           
                        
                      holds a property 
                        
                           
                              P
                           
                           
                              1.2.1.1
                           
                        
                     , its variables are PB1R (push button 1 for canceling the signal of closing the right doors), PB2R (push button 2 for canceling the signal of closing the right-hand doors), TB (train speed 
                        ≤
                        5
                        
                        
                           km
                        
                        /
                        
                           h
                        
                     ), door, close, lock, AUORD (authorization for opening the right-hand doors).


                     
                        
                           
                              P
                           
                           
                              1.2.1.1
                           
                        
                      can be written as 
                        
                           AG
                        
                        
                           AUORD
                        
                        →
                        
                           TB
                        
                        ∧
                        
                           (
                           
                              (
                              ∀
                              x
                              
                              ∈
                              
                              
                                 door
                              
                              )
                           
                           
                              (
                              
                                 close
                              
                              
                                 (
                                 x
                                 )
                              
                              ∧
                              
                              
                                 lock
                              
                              
                              
                                 (
                                 x
                                 )
                              
                              )
                           
                           )
                        
                        ∧
                        
                           (
                           P
                           B
                           1
                           R
                           ∨
                           P
                           B
                           2
                           R
                           )
                        
                     .

For 
                        
                           
                              P
                           
                           
                              1.2.2.1
                           
                        
                     , it is similar to 
                        
                           
                              P
                           
                           
                              1.2.1.1
                           
                        
                     . As one can see from the diagram, the refinement is a systematic process. The stereotypes proposed ensure the requirement traceability.

@&#CONCLUSION@&#

In this paper, we have described a requirement refinement method for transforming requirements given in natural language into formal requirements for embedded control systems. Based on several refinement patterns we have defined, the refinement process is carried out in a systematic way, and allows us to obtain a set of refined requirements that can be formalized afterward to obtain logical properties. Furthermore, several mechanisms have been implemented in order to ensure the traceability for the refinement process, which is a crucial feature when engineering critical systems. The obtained properties can be brought to automatic model-checking and testing tools for the verification phase. The developed technique is based on some generic refinement patterns focusing on the assertions structure rather than the information they carry, which makes the technique independent from the application. Although the developed process is not automatic, it paves the way towards the introduction of some automatic tools to assist the refinement procedure. This is what we will focus on in our future work.

@&#ACKNOWLEDGMENT@&#

This research has been partially supported by Region Nord Pas de Calais and European fund FEDER under the FUI National project FERROCOTS, labeled by i-Trans (Nbr. 10030031M081).

@&#REFERENCES@&#

