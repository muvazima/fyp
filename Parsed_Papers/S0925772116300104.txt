@&#MAIN-TITLE@&#Covering points with minimum/maximum area orthogonally convex polygons

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We examine maximum area coverings of point sets using orthogonally convex polygons.


                        
                        
                           
                           If no such covering exists, we report in 
                                 O
                                 (
                                 n
                                 log
                                 ⁡
                                 n
                                 )
                               time.


                        
                        
                           
                           If covering exists, we build it in 
                                 O
                                 (
                                 
                                    
                                       n
                                    
                                    
                                       2
                                    
                                 
                                 )
                               time.


                        
                        
                           
                           Minimum area coverings can be constructed with very minor modifications


                        
                        
                           
                           Our approach uses dynamic programming with memoization.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Orthogonally convex

Polygon cover

Optimal area

Dynamic programming

@&#ABSTRACT@&#


               
               
                  In this paper, we address the problem of covering a given set of points on the plane with minimum and/or maximum area orthogonally convex polygons. It is known that the number of possible orthogonally convex polygon covers can be exponential in the number of input points. We propose, for the first time, an 
                        O
                        (
                        
                           
                              n
                           
                           
                              2
                           
                        
                        )
                      algorithm to construct either the maximum or the minimum area orthogonally convex polygon if it exists, else report the non-existence in 
                        O
                        (
                        n
                        log
                        ⁡
                        n
                        )
                     .
               
            

@&#INTRODUCTION@&#

Reconstruction of shapes from limited stored or discovered geometric and topological information is a frequently visited problem in computational geometry. For example, Jackson and Wismath [1] use “stab visibilities” for reconstructing an orthogonal polygon. Usually, coordinates of the vertices (corners) of an object are used for reconstructing it. O'Rourke [2] provides an 
                        O
                        (
                        n
                        log
                        ⁡
                        n
                        )
                      time algorithm for constructing a unique orthogonal polygon, if it exists, from a given vertex set. Löffler and Mumford [3] show that there is only one orientation for which a provided vertex set can be used to reconstruct a rectilinear graph. Rappaport [4] shows that if straight angles are allowed, the problem becomes NP-hard. A similar problem is studied by Biedl and Genç in [5] for reconstructing orthogonally convex polyhedra from putative vertex sets.

In this study, we focus on the reconstruction of polygons when the given points are confined to the interior of the edges. An edge covers a point, if the point can be rewritten as a convex combination of the two endpoints of the edge. Similarly, a polygon is said to cover a point set on the plane if each polygon edge covers exactly one point and each point is covered by exactly one polygon edge. The points are therefore required to be in the interior of the polygon edges. An orthogonal polygon is a polygon whose edges are orthogonal, namely, horizontal or vertical. The problem of deciding whether a given point set on the plane can be covered by an orthogonal polygon when the orientations of the edges are also specified in advance as part of the input has been shown to be NP-complete by Evrendilek et al. in [6]. In case the orientations are not dictated, the problem remains NP-complete as shown in [7].

The interior of an x-monotone polygon intersects every vertical line in at most one line segment. Biedl et al. in [8] studied reconstructing polygons from scanner data such that the provided points are in the interior of the polygon edges, and each edge is allowed to cover multiple points. One of their results was that there exists a unique orthogonal x-monotone polygon that can be reconstructed from a given point set in 
                        O
                        (
                        n
                        log
                        ⁡
                        n
                        )
                      time if the corresponding edge orientations are known.

An orthogonal polygon is orthogonally convex if its intersection with any orthogonal line is either empty or a single line segment. When the covering polygon is restricted to be orthogonally convex, Genç et al. determine in [9] if a given set of points on the plane can be covered by a polygon of this class in 
                        O
                        (
                        n
                        log
                        ⁡
                        n
                        )
                      time. It is also shown in [9] that the number of possible orthogonally convex polygons that can cover a given point set can be exponential in the number of the provided points.

In this paper, we give an 
                        O
                        (
                        
                           
                              n
                           
                           
                              2
                           
                        
                        )
                      algorithm to construct either the maximum or the minimum area orthogonally convex polygon which covers a given set of n points, should the provided point set admit one or more (possibly exponentially many) coverings.

There are a variety of domains in which the reconstruction of orthogonally convex polygons with minimum and/or maximum area may find application. It can be employed, for instance, in constructing 2D floor layouts with area constraints, and also as a finer grain substitute for bounding boxes of graphical objects as well as being theoretically interesting in its own right. As stated in [9], orthogonal convex hulls, studied in [10], may be disconnected or degenerate. The orthogonally convex cover, however, is a balanced representation and may be useful where the bounding box is too simple and the orthogonal convex hull is disconnected. In [8], the operation of range scanners situated in a room is described. Such scanners provide data with points in the interior of the polygon edges corresponding to the walls of the room. If the shape of a room is already known to be an orthogonally convex polygon, the construction of its 2D floor layout can be automated.

The rest of the paper is organized as follows: In Section 2, we provide the necessary formal background. Then, in Section 3, the problem of finding the maximum or minimum area orthogonally convex polygon cover of a given set of points is defined formally along with the general anatomy of this type of polygons. Subsequently in Section 4, an efficient algorithm is described, and finally, the last section presents concluding remarks.

All the definitions in this section are given for 2D Euclidean Space.

A polygonal chain is a connected and ordered set of line segments, such that only consecutive segments intersect and they intersect only at their end points. Likewise, a closed polygonal chain is a polygonal chain whose endpoints coincide. A polygon is a region on the plane enclosed by a closed polygonal chain. The edges of a polygon are the maximal line segments on the boundary of the polygon. The vertices of a polygon are the intersection points of its edges. A line segment is orthogonal if it is parallel to one of the coordinate axes. An orthogonal polygon is a polygon whose edges are orthogonal. An orthogonal polygon is orthogonally convex, if its intersection with any orthogonal line is either empty or a single line segment.

An orthogonal line segment is horizontal (resp. vertical) if it is parallel to the x-axis (resp. y-axis). A line segment covers a point, if the point is on the line segment.

Given two points p and q, we write 
                        p
                        
                           
                              ≥
                           
                           
                              x
                           
                        
                        q
                      if the x-coordinate of p is greater than or equal to the x-coordinate of q. 
                        p
                        
                           
                              ≥
                           
                           
                              y
                           
                        
                        q
                      is defined analogously. We require strict inequality for 
                        
                           
                              >
                           
                           
                              x
                           
                        
                      and 
                        
                           
                              >
                           
                           
                              y
                           
                        
                      respectively.

A polygonal chain is 
                        
                           
                              x
                           
                           
                              +
                           
                        
                     -monotone if for any two consecutive vertices 
                        
                           
                              v
                           
                           
                              i
                           
                        
                      and 
                        
                           
                              v
                           
                           
                              i
                              +
                              1
                           
                        
                     , 
                        
                           
                              v
                           
                           
                              i
                              +
                              1
                           
                        
                        
                           
                              ≥
                           
                           
                              x
                           
                        
                        
                           
                              v
                           
                           
                              i
                           
                        
                     , and it is 
                        
                           
                              x
                           
                           
                              −
                           
                        
                     -monotone if for any two consecutive vertices 
                        
                           
                              v
                           
                           
                              i
                           
                        
                      and 
                        
                           
                              v
                           
                           
                              i
                              +
                              1
                           
                        
                     , 
                        
                           
                              v
                           
                           
                              i
                           
                        
                        
                           
                              ≥
                           
                           
                              x
                           
                        
                        
                           
                              v
                           
                           
                              i
                              +
                              1
                           
                        
                     . We similarly define 
                        
                           
                              y
                           
                           
                              +
                           
                        
                     -monotone and 
                        
                           
                              y
                           
                           
                              −
                           
                        
                     -monotone. A polygonal chain is xy-monotone if it is monotone in both orthogonal directions.

We can now formally define the problem of finding the maximum area orthogonally convex polygon cover of a given set of points. The definition of the problem of finding the minimum area orthogonally convex polygon cover can be obtained by replacing the “maximums” with “minimums”.


                     
                        Definition 1
                        Given a set P of points in 2D, the problem of finding the maximum area orthogonally convex polygon cover is to construct an orthogonally convex polygon of maximum area in such a way that each edge of the polygon covers exactly a single point, and each point is covered by exactly a single edge of the polygon, if any such polygon exists.

This definition implies that no point in P is allowed to be on a vertex of the orthogonally convex polygon cover as otherwise it would have been covered by the two edges it is on.


                     Fig. 1
                      illustrates two different orthogonally convex polygons that both cover the same input point set. For the sake of completeness, and for a better understanding of the solution to this problem, we will introduce the terminology and outline the computations involving the construction of orthogonally convex polygons covering a provided point set in the next subsection.

Any orthogonally convex polygon can be divided into four xy-monotone polygonal chains, namely the staircases of the polygon, with respect to the topmost (t), the rightmost (r), the bottommost (b), and the leftmost (l) points in the point set to cover. We name these staircases the northwest (NW), the southwest (SW), the northeast (NE) and the southeast (SE) staircases as shown in Fig. 2
                        . The NW staircase, for example, starts at the leftmost point l at a vertical orientation, and through an alternating sequence of horizontal and vertical edges, ends horizontally at the topmost point t. We write 
                           q
                           
                              
                                 >
                              
                              
                                 NW
                              
                           
                           p
                         for any two points on NW to imply 
                           q
                           
                              
                                 >
                              
                              
                                 x
                              
                           
                           p
                         and 
                           q
                           
                              
                                 >
                              
                              
                                 y
                              
                           
                           p
                        .

The input set of points can be divided into four possibly overlapping quadrants with respect to t, r, b, and l as shown in Fig. 3
                        . The NW quadrant, for example, contains inclusively all the points to the left of the vertical line passing through t that are also above the horizontal line through l. It can be easily observed that there exist three distinct configurations based on the relative positions of t, r, b, and l: i) the NW and SE quadrants overlap, ii) the SW and the NE quadrants overlap, and iii) none of the quadrants overlap. These are shown in Fig. 3.

In case none of the quadrants overlap as shown to the right in Fig. 3, finding either the maximum or the minimum area orthogonally convex polygon is trivial. There can exist only one such polygon, if any, as all the points in any one quadrant are used in constructing only the corresponding staircase. The overall process, hence, amounts simply to constructing each of the four staircases. The polygonal chain in the first quadrant, for example, can be constructed by sweeping the points l through t in this quadrant in increasing order of their x-coordinates. The resulting chain, which is required to be 
                           
                              
                                 x
                              
                              
                                 +
                              
                           
                         and 
                           
                              
                                 y
                              
                              
                                 +
                              
                           
                        -monotone, starts with a vertical edge at l, and the edge orientation alternates at every subsequent point until t is finally covered by a horizontal edge. The challenge, however, is to handle the configuration when two quadrants overlap. We assume throughout the rest of the paper that NW and SE quadrants overlap since the other case is completely symmetrical. After taking the union of points in NW and SE quadrants, we simply try to label the points as to whether they belong to the NW or SE staircases. As the quadrants overlap in this case as shown to the left of Fig. 3, we might have many different covers depending on whether a point is used in the construction of the NW or the SE staircase. It is therefore possible for a point to belong to one staircase in one cover while it belongs to the other staircase in another cover. We will use the terms upper chain and lower chain to refer to the list of all the points that could potentially be used in any possible constructions of the NW and SE staircases respectively. This process of labeling all the points detailed in [9] can be performed by computing for each point whether it belongs to the upper or the lower chain by sweeping the plane in increasing x order: A point belongs to the upper chain if there are no other points to the left that are also above it while it is accordingly labeled to belong to the lower chain if there are no points to the right and below. As a result of the computation, some points may be labeled as belonging to both the upper and the lower chains. These are called overlapping points. The others that are labeled as belonging to only one chain, on the other hand, are called non-overlapping points. If there are any points left unlabeled, a covering is not feasible at all.

Once the union of points in the NW and SE quadrants are all labeled, two possibly overlapping xy-monotonous chains are generated: The points labeled as belonging to the upper chain from l to t, and the points labeled to belong to the lower chain from b to r as shown in Fig. 4
                        . These two chains are connected only at the overlapping points, and hence, induce a sequence of two different types of regions on the points labeled: While an overlapping region contains overlapping points only, a non-overlapping region has only non-overlapping points. Fig. 4 illustrates overlapping and non-overlapping regions. Each consecutive region, regardless of its type, is identified by two pairs of points marking the start and the end of the region encircled in dashed lines. Note that the edges in this figure are provided to outline the upper and lower chains. They are not necessarily the edges on the final solution, and hence, their implicitly declared orientations are not necessarily correct.

This entire structure is abstracted in a compact combinatorial form called a solution graph in [9]. The solution graph for the example in Fig. 4 is illustrated in Fig. 5
                        .

Each node denoted by a shaded rectangle represents an ordered pair of points marking the start and/or the end of a region. The very first rectangle on the left of Fig. 5, for example, is the node corresponding to the ordered pair of points 
                           (
                           l
                           ,
                           b
                           )
                         shown in Fig. 4. For any pair of points, the first point, by convention, is associated with the upper chain whereas the second is on the lower chain. As a single point can be covered either by a horizontal (H) or a vertical (V) edge, a node contains four possible combinations of orientations for the pair of points it represents. These are displayed inside the nodes in the form of 2-lettered identifiers, namely HH, HV, VH, and VV. While the first letter gives the orientation of the edge covering the point on the upper chain, the second letter corresponds to the orientation of the edge covering the point on the lower chain. A particular orientation combination AB at a particular node P is denoted by 
                           
                              
                                 P
                              
                              
                                 AB
                              
                           
                         where 
                           A
                           ,
                           B
                           ∈
                           {
                           H
                           ,
                           V
                           }
                        . Two nodes marking the start and the end of a region are connected by possibly multiple directed edges. Each edge originates from a single orientation combination in a node, and ends at a single orientation combination of the next node. An edge indicates that a non-intersecting pair of upper and lower staircases complying with the dictated orientation combinations at the start and the end of this edge can be constructed to cover all the points in the corresponding region. It should be noted in a solution graph that the edges always emanate from the orientation combination VH in the first region, and enters into HV in the last region since the orientations at the points l, b, t, and r in any valid orthogonal covering are V, H, H, and V respectively.

In this section, an efficient algorithm to compute the maximum and/or minimum area orthogonally convex polygon that covers the given point set on the plane is presented. Throughout the rest of the paper, the discussion focuses on constructing the cover with the maximum area. The one with the minimum area, however, can also be computed identically by simply replacing the function 
                        max
                        ⁡
                        (
                        )
                      with 
                        min
                        ⁡
                        (
                        )
                      where needed.

First, we run the algorithm from [9] to compute the solution graph SG and the number of solutions in 
                        O
                        (
                        n
                        log
                        ⁡
                        n
                        )
                      time. We assume that there exists at least one solution. In the subsections to follow, we solve the problem for the non-overlapping and overlapping regions. In Section 4.3, we combine them to solve the problem for the entire region.

First we look into the non-overlapping regions of the solution graph. The points in the non-overlapping regions are relatively easier to handle, because we know for each such point whether it belongs to the upper chain or the lower chain. For a given pair of orientations at the start of such a region, there is a unique covering of all the points by the upper and lower chains till the end of the region, and hence a fixed contribution by this very region to the overall area.

A non-overlapping region is described as a triplet 
                           (
                           P
                           ,
                           M
                           ,
                           Q
                           )
                         where P is an ordered pair of points 
                           (
                           l
                           ,
                           b
                           )
                        , Q is an ordered pair of points 
                           (
                           t
                           ,
                           r
                           )
                        , and M is a set of 
                           k
                           ≥
                           0
                         points 
                           {
                           
                              
                                 m
                              
                              
                                 i
                              
                           
                           |
                           i
                           =
                           1
                           .
                           .
                           k
                           }
                         sorted in non-decreasing x and y coordinates in this order such that l is the leftmost, b is the bottommost, r is the rightmost and t is the topmost of all points in 
                           P
                           ∪
                           M
                           ∪
                           Q
                        . An example configuration of a non-overlapping region is depicted in Fig. 6
                        . M in a non-overlapping region can always be separated into two sequences of xy-monotonous points corresponding to the upper and the lower chains. It should also be pointed out that either l and t on the upper chain, or b and r on the lower chain may coincide, but not both. Otherwise, it is not by definition a region at all.

Depending on the orientations of the edges covering l and b, we can cover an input point set in four different ways. Out of these four, some may result in two monotone chains that intersect. However, we are only interested in the cases where the upper and lower chains do not intersect. It is shown in [9] that intersections are easily detected in time linear in the number of the points in the region. Fig. 7
                         demonstrates these cases for the input set of Fig. 6 where all four cases happen to result in non-intersecting chains. We will name these four cases the HH, HV, VH, and VV cases, based on the orientations of the edges covering l and b.

The area computed in each case is the area of the region that lies between the upper and lower chains.

We define an overlapping region similar to a non-overlapping region using a 
                           (
                           P
                           ,
                           M
                           ,
                           Q
                           )
                         triplet. The difference is that this time we do not know which point in M belongs to which chain, except we still know, in the pair of points 
                           P
                           =
                           (
                           l
                           ,
                           b
                           )
                         and 
                           Q
                           =
                           (
                           t
                           ,
                           r
                           )
                        , that the points l and t belong to the upper chain, and b and r belong to the lower chain. Particularly, M consists of a single sequence of xy-monotone points while in a non-overlapping region it has two sequences of xy-monotonous points corresponding to the upper and the lower chains.

Depending on the orientations of the edges covering l, b, t, r, and the parity of the size of M which is either odd or even, there might be different ways of covering an overlapping region for which we may want to compute the maximum area. Instead of solving each case separately, we will first explain how to compute the maximum area orthogonally convex polygon cover for one type of an overlapping region, and then show how all other types of overlapping regions can be easily handled by referring to this base type. We introduce the following naming convention for referring to different types of overlapping regions: (orientation of l) (orientation of b)-(orientation of t) (orientation of r)-(parity of M). If the orientations of l, b, t, and r are known then the parity of both chains, and, therefore, the parity of M is determined. We consider VH-HV-even as the base type.

The following lemma shows that we can have exponentially many covers for a VH-HV-even input point set, and hence a brute force search will not provide for a polynomial time algorithm to compute the maximum area. Fig. 8
                         shows an example where the cardinality of M is 4.


                        
                           Lemma 1
                           
                              Given a VH-HV-even input point set 
                              
                                 (
                                 P
                                 ,
                                 M
                                 ,
                                 Q
                                 )
                               
                              for an overlapping region, there are a total of 
                              
                                 
                                    
                                       2
                                    
                                    
                                       |
                                       M
                                       |
                                       /
                                       2
                                    
                                 
                               
                              valid covers.
                           


                        
                           Proof
                           Any two consecutive points 
                                 
                                    
                                       m
                                    
                                    
                                       2
                                       i
                                       −
                                       1
                                    
                                 
                               and 
                                 
                                    
                                       m
                                    
                                    
                                       2
                                       i
                                    
                                 
                                 ∈
                                 M
                               where 
                                 i
                                 ∈
                                 [
                                 1
                                 .
                                 .
                                 
                                    
                                       |
                                       M
                                       |
                                    
                                    2
                                 
                                 ]
                               must both belong to the same chain, namely the upper or the lower chain. An intersection is, otherwise, introduced between the upper and lower chains. The result, hence, follows.  □

In all possible covers of a VH-HV-even input point set, in order to bound the area, it is assumed that the edges covering l and b intersect at 
                           (
                           l
                           .
                           x
                           ,
                           b
                           .
                           y
                           )
                         while similarly the edges through t and r intersect at 
                           (
                           r
                           .
                           x
                           ,
                           t
                           .
                           y
                           )
                        . This holds even when the starting and ending pair of points are actually orthogonally aligned, in other words, on the same vertical or horizontal line. One such case is when the horizontally oriented point t, and the vertically oriented point r have the same y-coordinate value.

It should be noted that the construction of orthogonally convex polygon covers for a VH-HV-even input point set need not perform the extra check for intersections as dictated by Lemma 1.

When the starting orientations at l and b are given, we may have exponentially many coverings of overlapping regions each with a different area, whereas a unique construction, if any, exists for non-overlapping regions. It is, therefore, the existence of overlapping regions that actually contributes to the potential of exponentially many coverings.

In order to simplify the presentation, we first describe, in the next sub-section a dynamic programming solution for the overlapping regions constrained to the base type: VH-HV-even. It is, then, generalized to work for all feasible types of overlapping regions.

The points in M indexed i through j inclusive where 
                              1
                              ≤
                              i
                              ≤
                              j
                              ≤
                              |
                              M
                              |
                              =
                              n
                            are identified by 
                              M
                              [
                              i
                              :
                              j
                              ]
                           . We use the abbreviations 
                              
                                 
                                    m
                                 
                                 
                                    i
                                 
                              
                            and 
                              M
                              [
                              i
                              ]
                            interchangeably for 
                              M
                              [
                              i
                              :
                              i
                              ]
                            to access the point at index i in M. The maximum among the areas of all the orthogonally convex polygon covers of a given VH-HV-even instance is represented by 
                              
                                 maxArea
                              
                              (
                              P
                              ,
                              M
                              [
                              1
                              :
                              n
                              ]
                              ,
                              Q
                              )
                           .

The two cases corresponding to the assignment of the last two consecutive points in M, by Lemma 1, both to the same one of the upper or the lower chains are depicted in Fig. 9
                           . The configuration on the left corresponds to the case when the last two points, 
                              M
                              [
                              n
                              ]
                            and 
                              M
                              [
                              n
                              −
                              1
                              ]
                           , are both assigned to the upper chain while the configuration on the right illustrates the alternative case when these points are assigned to the lower chain. In both components characterized by the rectangular area formed either at the top or right at one hand, and the maximum of the areas of the orthogonally convex polygons which now cover only the first 
                              n
                              −
                              2
                            points in M at the other hand. When 
                              M
                              [
                              n
                              ]
                            and 
                              M
                              [
                              n
                              −
                              1
                              ]
                            are both assigned to the upper chain, the area of the rectangle formed at the top, is given as
                              
                                 (1)
                                 
                                    
                                       
                                          A
                                       
                                       
                                          t
                                       
                                    
                                    =
                                    (
                                    r
                                    .
                                    x
                                    −
                                    M
                                    [
                                    n
                                    ]
                                    .
                                    x
                                    )
                                    ⁎
                                    (
                                    t
                                    .
                                    y
                                    −
                                    M
                                    [
                                    n
                                    −
                                    1
                                    ]
                                    .
                                    y
                                    )
                                 
                              
                            and the maximum of the areas of the orthogonally convex polygons covering the first 
                              n
                              −
                              2
                            points in M confined to the region at the bottom is given by
                              
                                 (2)
                                 
                                    
                                       
                                          A
                                       
                                       
                                          b
                                       
                                    
                                    =
                                    
                                       maxArea
                                    
                                    (
                                    P
                                    ,
                                    M
                                    [
                                    1
                                    :
                                    n
                                    −
                                    2
                                    ]
                                    ,
                                    (
                                    M
                                    [
                                    n
                                    −
                                    1
                                    ]
                                    ,
                                    (
                                    r
                                    .
                                    x
                                    ,
                                    M
                                    [
                                    n
                                    −
                                    1
                                    ]
                                    .
                                    y
                                    )
                                    )
                                    )
                                 
                              
                           
                        

Similarly, when 
                              M
                              [
                              n
                              ]
                            and 
                              M
                              [
                              n
                              −
                              1
                              ]
                            are both assigned to the lower chain, the area of the rectangle formed at the right, is given as
                              
                                 (3)
                                 
                                    
                                       
                                          A
                                       
                                       
                                          r
                                       
                                    
                                    =
                                    (
                                    r
                                    .
                                    x
                                    −
                                    M
                                    [
                                    n
                                    −
                                    1
                                    ]
                                    .
                                    x
                                    )
                                    ⁎
                                    (
                                    t
                                    .
                                    y
                                    −
                                    M
                                    [
                                    n
                                    ]
                                    .
                                    y
                                    )
                                 
                              
                            and the maximum of the areas of the possible covers for the points in the region to the left is specified as
                              
                                 (4)
                                 
                                    
                                       
                                          A
                                       
                                       
                                          l
                                       
                                    
                                    =
                                    
                                       maxArea
                                    
                                    (
                                    P
                                    ,
                                    M
                                    [
                                    1
                                    :
                                    n
                                    −
                                    2
                                    ]
                                    ,
                                    (
                                    (
                                    M
                                    [
                                    n
                                    −
                                    1
                                    ]
                                    .
                                    x
                                    ,
                                    t
                                    .
                                    y
                                    )
                                    ,
                                    M
                                    [
                                    n
                                    −
                                    1
                                    ]
                                    )
                                    )
                                 
                              
                           
                        

In each of the formulations of 
                              
                                 
                                    A
                                 
                                 
                                    b
                                 
                              
                            and 
                              
                                 
                                    A
                                 
                                 
                                    l
                                 
                              
                            in Equations (2) and (4) respectively, a hypothetical point is introduced. These are shown hollow in Fig. 9. In each of the cases, they become a part of the newly designated pairs of points formed to mark the end of the newly formed overlapping region with 
                              n
                              −
                              2
                            points in M. The dynamic programming formulation given below in (5), hence, easily follows.
                              
                                 (5)
                                 
                                    
                                       maxArea
                                    
                                    (
                                    P
                                    ,
                                    M
                                    [
                                    1
                                    :
                                    n
                                    ]
                                    ,
                                    Q
                                    )
                                    =
                                    
                                       {
                                       
                                          
                                             
                                                
                                                   max
                                                
                                                {
                                                
                                                   
                                                      A
                                                   
                                                   
                                                      t
                                                   
                                                
                                                +
                                                
                                                   
                                                      A
                                                   
                                                   
                                                      b
                                                   
                                                
                                                ,
                                                
                                                   
                                                      A
                                                   
                                                   
                                                      r
                                                   
                                                
                                                +
                                                
                                                   
                                                      A
                                                   
                                                   
                                                      l
                                                   
                                                
                                                }
                                             
                                             
                                                if 
                                                n
                                                >
                                                0
                                             
                                          
                                          
                                             
                                                (
                                                r
                                                .
                                                x
                                                −
                                                l
                                                .
                                                x
                                                )
                                                ⁎
                                                (
                                                t
                                                .
                                                y
                                                −
                                                b
                                                .
                                                y
                                                )
                                             
                                             
                                                if 
                                                n
                                                =
                                                0
                                             
                                          
                                       
                                    
                                 
                              
                           
                        


                           Fig. 10
                            presents a recursion diagram depicting the problem and its subproblems that need to be addressed through the dynamic programming formulation given in Equation (5). All such subproblems requiring computation are indicated by filled squares. The square at the top right corner corresponds to the main problem while any other square implies the existence of a subproblem for finding the maximum area with respect to the overlapping points in the rectangular region whose opposite corners are dictated by P and this very square. Each square that is not associated with a trivial case has two directed edges emanating from it corresponding to the two subproblems it needs to recursively solve. Other squares corresponding to the trivial cases, on the other hand, have no outgoing edges, and the regions induced by them does not contain any points in the interior. The total number of subproblems denoted by the filled squares in Fig. 10 is thus seen to be 
                              n
                              /
                              2
                              (
                              n
                              /
                              2
                              +
                              1
                              )
                            excluding the main problem. The number of subproblems corresponding to the trivial cases, however, is n.

Each subproblem in a valid instance of 
                              
                                 maxArea
                              
                              (
                              P
                              ,
                              M
                              [
                              1
                              :
                              n
                              ]
                              ,
                              Q
                              )
                            is identified by a tuple 
                              (
                              i
                              ,
                              j
                              )
                            where 
                              1
                              ≤
                              i
                              ,
                              j
                              ≤
                              n
                              /
                              2
                              +
                              1
                            and 
                              i
                              ≠
                              j
                           . The original problem always corresponds to the filled square at the top right corner, and is identified by 
                              (
                              n
                              /
                              2
                              +
                              1
                              ,
                              n
                              /
                              2
                              +
                              1
                              )
                           . A subproblem 
                              (
                              i
                              ,
                              j
                              )
                            is hence represented by a filled square at the point 
                              
                                 
                                    s
                                 
                                 
                                    i
                                    ,
                                    j
                                 
                              
                              (
                              x
                              ,
                              y
                              )
                            in Fig. 10 whose coordinates are given by the following:
                              
                                 (6)
                                 
                                    
                                       
                                          s
                                       
                                       
                                          i
                                          ,
                                          j
                                       
                                    
                                    =
                                    
                                       {
                                       
                                          
                                             
                                                (
                                                M
                                                [
                                                2
                                                j
                                                −
                                                1
                                                ]
                                                .
                                                x
                                                ,
                                                M
                                                [
                                                2
                                                i
                                                −
                                                1
                                                ]
                                                .
                                                y
                                                )
                                             
                                             
                                                if 
                                                1
                                                ≤
                                                i
                                                ,
                                                j
                                                <
                                                n
                                                /
                                                2
                                                +
                                                1
                                             
                                          
                                          
                                             
                                                (
                                                M
                                                [
                                                2
                                                j
                                                −
                                                1
                                                ]
                                                .
                                                x
                                                ,
                                                t
                                                .
                                                y
                                                )
                                             
                                             
                                                if 
                                                i
                                                =
                                                n
                                                /
                                                2
                                                +
                                                1
                                                ,
                                                1
                                                ≤
                                                j
                                                <
                                                n
                                                /
                                                2
                                                +
                                                1
                                             
                                          
                                          
                                             
                                                (
                                                r
                                                .
                                                x
                                                ,
                                                M
                                                [
                                                2
                                                i
                                                −
                                                1
                                                ]
                                                .
                                                y
                                                )
                                             
                                             
                                                if 
                                                1
                                                ≤
                                                i
                                                <
                                                n
                                                /
                                                2
                                                +
                                                1
                                                ,
                                                j
                                                =
                                                n
                                                /
                                                2
                                                +
                                                1
                                             
                                          
                                          
                                             
                                                (
                                                r
                                                .
                                                x
                                                ,
                                                t
                                                .
                                                y
                                                )
                                             
                                             
                                                if 
                                                i
                                                =
                                                n
                                                /
                                                2
                                                +
                                                1
                                                ,
                                                j
                                                =
                                                n
                                                /
                                                2
                                                +
                                                1
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

As there are only 
                              n
                              /
                              2
                              (
                              n
                              /
                              2
                              +
                              1
                              )
                            subproblems that need to be dealt with independently, the recurrence relation given in (5) can be implemented to run in time proportional to 
                              O
                              (
                              
                                 
                                    n
                                 
                                 
                                    2
                                 
                              
                              )
                            simply by memoization as shown in Algorithm 1
                           . In this algorithm, memo is a two dimensional global matrix whose entries, 
                              
                                 memo
                              
                              [
                              i
                              ,
                              j
                              ]
                            where 
                              1
                              ≤
                              i
                              ,
                              j
                              ≤
                              n
                              /
                              2
                              +
                              1
                           , range over all the possible subproblems inside the rectangular regions whose opposite corners are identified by the points 
                              (
                              l
                              .
                              x
                              ,
                              b
                              .
                              y
                              )
                           , and the filled square at 
                              
                                 
                                    s
                                 
                                 
                                    i
                                    ,
                                    j
                                 
                              
                              (
                              x
                              ,
                              y
                              )
                            as shown in Fig. 10. After the number of overlapping points associated with the subproblem 
                              (
                              i
                              ,
                              j
                              )
                           , denoted by size, is computed at line 4, two recursive calls are made at lines 9 and 11. While the former call to the subproblem 
                              (
                              k
                              −
                              1
                              ,
                              j
                              )
                            corresponds to the case when the last two points are taken by the upper chain, the latter call to the subproblem 
                              (
                              i
                              ,
                              k
                              −
                              1
                              )
                            is associated with the case when the points are taken by the lower chain where k is the smaller of i and j.


                           Algorithm 1 fills the two dimensional array memo in 
                              O
                              (
                              
                                 
                                    n
                                 
                                 
                                    2
                                 
                              
                              )
                            time, and returns the value of 
                              
                                 memo
                              
                              [
                              n
                              /
                              2
                              +
                              1
                              ,
                              n
                              /
                              2
                              +
                              1
                              ]
                            as the maximum among the areas of the orthogonally convex polygons that can cover the input point set. It can easily be observed at this point that we can also obtain the minimum area by simply replacing the call to max on line 12 with a min call.

The upper and lower chains can be computed by backtracking with an additional array or using an iterative algorithm and memoization.

Let us consider the last point, 
                              
                                 
                                    m
                                 
                                 
                                    n
                                 
                              
                           , in M. Clearly, this point belongs to the upper chain as it is demonstrated in Fig. 11
                           .

We reduce the problem to the base type by introducing a point 
                              (
                              r
                              .
                              x
                              ,
                              
                                 
                                    m
                                 
                                 
                                    n
                                 
                              
                              .
                              y
                              )
                            shown hollow in Fig. 11. The solution to this problem can therefore be expressed as:
                              
                                 (7)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   maxArea
                                                
                                                
                                                   VH-VV-odd
                                                
                                             
                                          
                                       
                                    
                                    =
                                    
                                       
                                          
                                             
                                                maxArea
                                             
                                             (
                                             P
                                             ,
                                             M
                                             [
                                             1
                                             :
                                             n
                                             −
                                             1
                                             ]
                                             ,
                                             (
                                             
                                                
                                                   m
                                                
                                                
                                                   n
                                                
                                             
                                             ,
                                             (
                                             r
                                             .
                                             x
                                             ,
                                             
                                                
                                                   m
                                                
                                                
                                                   n
                                                
                                             
                                             .
                                             y
                                             )
                                             )
                                             )
                                             +
                                             (
                                             r
                                             .
                                             x
                                             −
                                             t
                                             .
                                             x
                                             )
                                             ⁎
                                             (
                                             t
                                             .
                                             y
                                             −
                                             
                                                
                                                   m
                                                
                                                
                                                   n
                                                
                                             
                                             .
                                             y
                                             )
                                          
                                       
                                    
                                 
                              
                            where the first term is the area of the lower rectangle in Fig. 11 and the second term is the area of the upper rectangle in Fig. 11.

Once again, let us consider the last point, 
                              
                                 
                                    m
                                 
                                 
                                    n
                                 
                              
                           , in M. This point will either belong to the upper chain or the lower chain. This time, in either case, it is covered by a vertically oriented edge. If it belongs to the upper chain, however, it is easily seen that the horizontal edge through r intersects it at point 
                              (
                              
                                 
                                    m
                                 
                                 
                                    n
                                 
                              
                              .
                              x
                              ,
                              r
                              .
                              y
                              )
                            to connect with the rest of the lower chain. Therefore, this point cannot belong to the upper chain in any valid orthogonal polygon cover, but must belong to the lower chain. The proper assignment is demonstrated in Fig. 12
                           
                           
                           
                           
                           
                           
                           .

Similar to the previous case, the solution can be expressed as the sum of two components as depicted in Fig. 12, namely the area of the maximum area orthogonally convex polygon covering an overlapping region of type VH-HV-even with one less point now, and the area of the rectangle marked 
                              
                                 
                                    delta
                                 
                                 
                                    2
                                 
                              
                           . The maximum area in this case is hence given by:
                              
                                 (8)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   maxArea
                                                
                                                
                                                   VH-HH-odd
                                                
                                             
                                          
                                       
                                    
                                    =
                                    
                                       
                                          
                                             
                                                maxArea
                                             
                                             (
                                             P
                                             ,
                                             M
                                             [
                                             1
                                             :
                                             n
                                             −
                                             1
                                             ]
                                             ,
                                             (
                                             (
                                             
                                                
                                                   m
                                                
                                                
                                                   n
                                                
                                             
                                             .
                                             x
                                             ,
                                             t
                                             .
                                             y
                                             )
                                             ,
                                             
                                                
                                                   m
                                                
                                                
                                                   n
                                                
                                             
                                             )
                                             )
                                             +
                                             (
                                             r
                                             .
                                             x
                                             −
                                             
                                                
                                                   m
                                                
                                                
                                                   n
                                                
                                             
                                             .
                                             x
                                             )
                                             ⁎
                                             (
                                             t
                                             .
                                             y
                                             −
                                             r
                                             .
                                             y
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        

The remaining types of overlapping regions we must consider are the following: HH-HV-odd, HH-HH-even, HH-VV-even, VV-HV-odd, VV-HH-even, and VV-VV-even. The types which we do not consider here are those having the orientation pair HV at P or the orientation pair VH at Q. For these types of overlapping regions, the first overlapping point 
                              
                                 
                                    m
                                 
                                 
                                    1
                                 
                              
                            or the last overlapping point 
                              
                                 
                                    m
                                 
                                 
                                    n
                                 
                              
                            can be covered by neither the upper nor the lower chain without regard to the parity of 
                              |
                              M
                              |
                            
                           [9].

Instead of repeating mundane details for each remaining type, we will provide a figure demonstrating each transformation within this subsection. The references to the respective figures and the corresponding dynamic programming formulations for the remaining types as well as for those already described are summarized in Table 1
                           .

Each row in Table 1, corresponds to a 
                              
                                 
                                    maxArea
                                 
                                 
                                    type
                                 
                              
                              (
                              P
                              ,
                              M
                              [
                              1
                              :
                              n
                              ]
                              ,
                              Q
                              )
                            computation where type can assume one of the values listed in the first column. This computation is expressed in the last column by a formula of the form 
                              
                                 
                                    delta
                                 
                                 
                                    1
                                 
                              
                              +
                              
                                 maxArea
                              
                              (
                              
                                 
                                    P
                                 
                                 
                                    ′
                                 
                              
                              ,
                              M
                              [
                              i
                              :
                              j
                              ]
                              ,
                              
                                 
                                    Q
                                 
                                 
                                    ′
                                 
                              
                              )
                              +
                              
                                 
                                    delta
                                 
                                 
                                    2
                                 
                              
                           , where 
                              
                                 
                                    delta
                                 
                                 
                                    1
                                 
                              
                            and 
                              
                                 
                                    delta
                                 
                                 
                                    2
                                 
                              
                            are the areas of the respective regions marked as such in the corresponding figures referred to in the third column, 
                              
                                 
                                    P
                                 
                                 
                                    ′
                                 
                              
                            and 
                              
                                 
                                    Q
                                 
                                 
                                    ′
                                 
                              
                            refer to the starting and the ending pair of points respectively of the newly formed overlapping region of the base type, 
                              i
                              ∈
                              {
                              1
                              ,
                              2
                              }
                           , and 
                              j
                              ∈
                              {
                              n
                              −
                              1
                              ,
                              n
                              }
                           .

So far, the area computations involving only a single overlapping or non-overlapping region have been described. The goal, however, is to process the entire solution graph consisting of a sequence of overlapping or non-overlapping regions.

It should be noted here that the solution graph is indeed a weighted acyclic digraph where a weight associated with an edge corresponds simply to the maximum area of the region implied by that edge. The algorithm to construct the maximum area orthogonally convex polygon now lends itself to an easy description: Construct a weighted acyclic digraph, and then compute a maximum weight 
                           s
                           −
                           t
                         path in this acyclic digraph which can be solved in time linear in the number of edges.

As the number of orientation combinations at the start and the end of a single region is limited to four, there are only a constant number of edges in every region. A close inspection of Table 1 actually reveals that there might be at most four edges. The number of edges in the acyclic digraph is hence proportional to the number of regions, which could be at most 
                           O
                           (
                           n
                           )
                         when the input list contains n points. As a result, the algorithm will run in 
                           O
                           (
                           n
                           )
                         time once the weights associated with the edges have all been computed.

The computation of the edge weights in a single region is already known to take 
                           O
                           (
                           
                              
                                 n
                              
                              
                                 i
                              
                              
                                 2
                              
                           
                           )
                         time when processing an overlapping region with 
                           
                              
                                 n
                              
                              
                                 i
                              
                           
                         points. The total time to compute the weights of the edges in all the regions is thus proportional in the worst case to 
                           O
                           (
                           
                              
                                 n
                              
                              
                                 2
                              
                           
                           )
                         where n is the number of points in the input set.

The running time of the entire algorithm is dominated by the time it takes to compute the weights, and therefore, is given by 
                           O
                           (
                           
                              
                                 n
                              
                              
                                 2
                              
                           
                           )
                        .

@&#CONCLUSION@&#

In this paper, we introduced a fast algorithm to compute the minimum and maximum area orthogonally convex polygon coverings of a given point set such that each point is covered once and each edge covers exactly one point.

An orthogonal x-monotone polygon is an orthogonal polygon whose intersection with a vertical line is either empty or a single line segment. Extending the solution to orthogonal x-monotone polygons is left as an interesting open problem.

@&#REFERENCES@&#

