@&#MAIN-TITLE@&#An effective branch-and-price algorithm for the Preemptive Resource Constrained Project Scheduling Problem based on minimal Interval Order Enumeration

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           An effective branch-and-price algorithm (IOE) for the Preemptive Resource Constrained Project Scheduling Problem.


                        
                        
                           
                           A new branching mechanism based on interval orders.


                        
                        
                           
                           IOE is able to solve to optimality the entire set of J30, BL and Pack instances.


                        
                        
                           
                           We provide improved best-known lower bounds for 33 non-preemptive instances.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Project scheduling

Interval order

Column generation

Constraint propagation

Antichain

@&#ABSTRACT@&#


               
               
                  In this paper we address the Preemptive Resource Constrained Project Scheduling Problem (PRCPSP). PRCPSP requires a partially ordered set of activities to be scheduled using limited renewable resources such that any activity can be interrupted and later resumed without penalty. The objective is to minimize the project duration. This paper proposes an effective branch-and-price algorithm for solving PRCPSP based upon minimal Interval Order Enumeration involving column generation as well as constraint propagation. Experiments conducted on various types of instances have given very satisfactory results. Our algorithm is able to solve to optimality the entire set of J30, BL and Pack instances while satisfying the preemptive requirement. Furthermore, this algorithm provides improved best-known lower bounds for some of the J60, J90 and J120 instances in the non-preemptive case (RCPSP).
               
            

@&#INTRODUCTION@&#

This paper deals with the Resource Constrained Project Scheduling Problem (RCPSP). RCPSP aims at scheduling a set of activities subject to precedence and resource constraints, while minimizing the induced makespan (total duration of the project) value. The precedence constraints mean that some activities must be completed before others can start. The resource constraints specify that each activity requires constant amounts of renewable resources (with limited capacities) throughout the scheduling process. RCPSP has been extensively studied in its non-preemptive version where every activity has to be run as a whole without any kind of interruption. The Preemptive Resource Constrained Project Scheduling Problem (PRCPSP), on the other hand, corresponds to the case where each activity can be interrupted and later resumed without penalty. Preemption is beneficial in many real world areas. Such situations happen in textile industry, large software development projects, multiprocessor task scheduling in multistage hybrid flowshop environment, etc. Modelling and solving in these cases using Non-Preemptive RCPSP may lead to poor performances. It is well known that the PRCPSP is 
                        
                           N
                           P
                        
                     -hard (Ullman, 1976). Various extensions have been also investigated such as multi-criteria and multi-mode project scheduling (see Slowinski, 1981; Slowinski, Soniewicki, and Weglarz, 1994). Many other models are provided in Hartmann and Briskorn (2010).

There are not many works on PRCPSP. Demeulemeester and Herroelen (1996) have developed a branch-and-bound algorithm; Ballestín, Valls, and Quintanilla (2008) have looked at preemption from a heuristic perspective; and Peteghem and Vanhoucke (2010) have designed a genetic algorithm for multi-mode Preemptive RCPSP. For the sake of simplicity, authors often assume that all processing times are integral and that preemption only occurs at integer valued dates. It is, however, easily established that such a hypothesis can produce only an approximation of the optimal value. We refer to the surveys published by Kolisch and Padman (2001), Brucker, Drexl, Möhring, Neumann, and Pesch (1999), Herroelen and Leus (2005), Hartmann and Briskorn (2010). The very recent work of Haouari, Kooli, Néron, and Carlier (2014) uses an LP model based on PRCPSP to compute lower bound for the RCPSP. Also, Schutt, Feydy, Stuckey, and Wallace (2011) propose an effective algorithm for RCPSP based on Constraint Programming that allows many open instances to be closed and the lower bounds for RCPSP to be improved.

In this paper we consider the problem in its most general form and suppose that preemption is allowed for all activities and may occur at arbitrary rational dates, and that no penalties are related to preemption. Ours is a branch-and-price approach which involves constraint propagation, as well as the management of a specific rational Antichain linear program whose variables are associated with subsets of activities that may be simultaneously processed during the schedule. This Antichain linear program, first introduced by Mingozzi, Maniezzo, Ricciardelli, and Bianco (1998), provides us with a lower bound of both Preemptive and Non-Preemptive RCPSP. Mingozzi et al. (1998) have proposed a time-indexed linear formulation for RCPSP involving antichains. This linear program approach requires the implementation of a pricing or column generation scheme. Baar, Brucker, and Knust (1998) use this technique to deal with the large number of columns. Then Brucker and Knust (2000) combine constraint propagation by taking into account time windows and this linear programming formulation under a destructive approach. It was proved in Damay, Quilliot, and Sanlaville (2007) that if the input RCPSP instance satisfies certain ad hoc properties, then any optimal solution of the Antichain linear program may be turned into a feasible optimal preemptive schedule without any increase in the makespan value. To the best of our knowledge, only the work of Damay et al. (2007) deals with optimal solutions of PRCPSP without any restriction. Damay et al. propose a branch-and-bound method for PRCPSP based on the linear programming formulation of Mingozzi et al. (1998) and introducing additional disjunctions.

The strategy described here is to use the linear programming formulation of Mingozzi et al. (1998) in order to perform a tree search which may be viewed as being embedded into the process of enumerating all the minimal extensions of the precedence relation that define interval orders. The resulting process, capable of solving exactly all 30 activity instances in a preemptive way in the PSPLIB library and improving the best existing lower bounds for several 60/90/120 activity instances (without allowing preemption) in the same library, is seen to be particularly effective, with a powerful separation scheme based on a forbidden structure of interval orders.

The paper is organized as follows. We first recall the definition of Preemptive RCPSP in Section 2, and then introduce in Section 3 the theoretical tools related to the Antichain LP and to interval orders, which will be the basis of our new approach. Section 4 describes our IOE algorithm and its implementation, and Section 5 is devoted to the presentation of experimental results.

An instance I = (X, K, ≺) of the Resource Constrained Project Scheduling Problem is defined by:

                        
                           •
                           A set X = {1, …, n} of n activities: ∀i ∈ X, di
                               denotes the duration of activity i.

A set K = {1, …, m} of m resources: ∀k ∈ K, Rk
                               denotes the global resource amount for resource k and ∀i ∈ X, ∀k ∈ K, rik
                               denotes the requirement for resource k by activity i. These resources are given back to the system once the activity is over or interrupted.

∀i, j ∈ X, i≺j means that i precedes j: activity j cannot start before i is over (Precedence
constraints).

By convention we also introduce two activities 0 and n + 1 to respectively represent the start and the end of the schedule. Hence, activity 0 (resp. n + 1) is a predecessor (resp. successor) of all the other activities. Furthermore, we set d
                     0 = d
                     
                        n + 1 = 0 and r
                     0k
                      = r
                     
                        n + 1, k
                      = 0 for each k ∈ K.

In the case of Non-Preemptive RCPSP, scheduling only means computing the starting times ti
                     (i ∈ X) of the activities. A schedule σ = (ti, i ∈ X) is feasible if it satisfies the Precedence constraints and the Resource constraints. At any time t during the process, and for any resource k, the sum ∑
                        i ∈ Act(σ, t)
                     rik
                      does not exceed the global resource amount Rk
                     , Act(σ, t) = {i ∈ X, ti
                      ≤ t < ti
                      + di
                     } denoting the set of the activities running concurrently at time t according to schedule σ. So, solving Non-Preemptive RCPSP means computing σ with a minimal makespan (total duration of the project).

In cases where preemption is allowed, scheduling an activity i means first decomposing i into a sequence of sub-activities i
                     1, …, i
                     
                        h(i), with durations d
                     
                        i, 1, …, d
                     
                        i, h(i), such that: ∑
                        q = 1…h(i)
                     d
                     
                        i, q
                      = di
                     , and next scheduling all these sub-activities in the same way as for standard RCPSP. We also introduce for any feasible schedule σ, StartTime(σ, i) and EndTime(σ, i) to respectively denote the starting time and finishing time of activity i which is t
                     
                        i, 1 (respectively t
                     
                        i, h(i) + d
                     
                        i, h(i)). In this work we assume there are no restrictions either on the number of sub-activities or on their durations, which may be arbitrarily small.

Let us consider one resource with capacity R
                     1 = 3 and 8 activities with duration and resource requirements as described in Fig. 1
                     a. The activities have durations d
                     1 = 1, d
                     2 = 1, d
                     3 = 1, d
                     4 = 1, d
                     5 = 3, d
                     6 = 3, d
                     7 = 1 and d
                     8 = 1. The activity requirements are such that r
                     1, 1 = r
                     2, 1 = r
                     3, 1 = r
                     4, 1 = r
                     5, 1 = r
                     7, 1 = r
                     8, 1 = 1 and r
                     6, 1 = 2. We assume further that there are precedence constraints: 1≺3, 1≺4, 2≺5, 3≺6, 4≺6, 5≺7 and 5≺8.

A feasible preemptive (resp. non-preemptive) schedule with makespan 5.5 (resp. 6) is given in Fig. 1b. (resp. Fig. 1c).

Let I = (X, K, ≺) be some Preemptive RCPSP instance, defined according to the notation given in Section 2. We suppose (as we are clearly entitled to do) that the precedence relation ≺ is transitive. Then we define an antichain as being any subset a of X such that there does not exist i, j ∈ a such that i≺j. We say that such an antichain is valid if: ∀k ∈ K, ∑
                        i ∈ a
                     
                     rik
                      ≤ Rk
                     . It follows that a subset a⊆X of activities is a valid antichain if and only if the activities belonging to a may be simultaneously run inside some feasible schedule. We denote the set of all valid antichains as 
                        A
                     .

We are now able to express the following linear program, known as an Antichain Linear Program, associated with a Preemptive RCPSP instance I = (X, K, ≺), introduced in Mingozzi et al. (1998), also used in Damay et al. (2007), and which we shall denote as 
                           
                              P
                              A
                           
                        :

                           
                              (1)
                              
                                 
                                    
                                       
                                          Minimize
                                       
                                       
                                          ∑
                                          
                                             a
                                             ∈
                                             A
                                          
                                       
                                       
                                          z
                                          a
                                       
                                    
                                 
                              
                           
                        s. t.

                           
                              (2)
                              
                                 
                                    
                                       ∀
                                       i
                                       ∈
                                       X
                                       ,
                                       
                                          ∑
                                          
                                             a
                                             ∈
                                             A
                                             |
                                             i
                                             ∈
                                             a
                                          
                                       
                                       
                                          z
                                          a
                                       
                                       =
                                       
                                          d
                                          i
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (3)
                              
                                 
                                    ∀
                                    a
                                    ∈
                                    A
                                    ,
                                    
                                       z
                                       a
                                    
                                    ≥
                                    0
                                 
                              
                           
                        
                     

Let σ be any feasible schedule related to instance I, and for any valid antichain a let z(σ)
                           a
                         denote the total amount of time during which the activities simultaneously running in σ correspond precisely to the activities in a. We can see that 
                           
                              z
                              
                                 (
                                 σ
                                 )
                              
                              =
                              (
                              z
                              
                                 
                                    (
                                    σ
                                    )
                                 
                                 a
                              
                              ,
                              a
                              ∈
                              A
                              )
                           
                         is a feasible solution of 
                           
                              
                                 P
                                 A
                              
                              ,
                           
                         since constraints (2) express the fact that any activity i needs to have completed, or, equivalently, that the duration of all antichains containing i must be equal to the duration of i. It follows that the optimal value of 
                           
                              P
                              A
                           
                         provides us with a lower bound of the optimal value of I, which we denote as LB(I). The precedence constraints are partially relaxed and treated as disjunctions.

Let us consider the instance described in Fig. 1a. Fig. 1d shows an optimal solution z of the Antichain linear program with 
                           
                              
                                 z
                                 
                                    a
                                    1
                                 
                              
                              =
                              1
                              ,
                              
                                 z
                                 
                                    a
                                    2
                                 
                              
                              =
                              1
                              ,
                              
                                 z
                                 
                                    a
                                    3
                                 
                              
                              =
                              3
                           
                         and 
                           
                              
                                 z
                                 a
                              
                              =
                              0
                              
                              ∀
                              a
                              ∈
                              A
                              −
                              
                                 {
                                 
                                    a
                                    1
                                 
                                 ,
                                 
                                    a
                                    2
                                 
                                 ,
                                 
                                    a
                                    3
                                 
                                 }
                              
                           
                         where a
                        1 = {1, 7, 8}, a
                        2 = {2, 3, 4} and a
                        3 = {5, 6}. Also, we note that Fig. 1b shows a preemptive schedule with valid antichains {1, 2}, {3, 4, 5}, {5, 6}, {6, 7}, {6, 8} and {7, 8}.

Since set 
                           A
                         may be very large, even when the activity set X is small, 
                           
                              P
                              A
                           
                         needs to be handled using column generation (see Mingozzi et al., 1998; Baar et al., 1998). Column generation is a technique commonly used for solving a linear program (LP) containing an exponential number of variables. It involves first initializing this LP with a small number of initial variables (which may be obtained by applying some heuristic), iteratively solving the induced restrictedproblem to optimality, and then using the dual variables to generate new improving primal variables. The search for these improving primal variables is called the related pricing problem. The new variables are added to the restricted problem and the process goes on until no more improving variables can be found. The solution of the restricted problem is then the optimal solution. When this technique is associated with a branch-and-bound process (usually for integer formulation) it gives rise to a branch-and-price solution method ((see Mehrotra and Trick, 1995; Barnhart, Johnson, Nemhauser, Savelsbergh, and Vance, 1996) for an introduction to branch and price method).

For our needs, let us consider some active antichain subset 
                           
                              B
                              ⊆
                              A
                              ,
                           
                         together with some dual solution λ of the restricted linear programming formulation 
                           
                              P
                              
                                 A
                              
                              B
                           
                         defined by (we suppose that 
                           B
                         is such that this program admits a feasible solution):

                           
                              (4)
                              
                                 
                                    
                                       
                                          Minimize
                                       
                                       
                                          ∑
                                          
                                             a
                                             ∈
                                             B
                                          
                                       
                                       
                                          z
                                          a
                                       
                                    
                                 
                              
                           
                        s.t.

                           
                              (5)
                              
                                 
                                    
                                       ∀
                                       i
                                       ∈
                                       X
                                       ,
                                       
                                          ∑
                                          
                                             a
                                             ∈
                                             B
                                             |
                                             i
                                             ∈
                                             a
                                          
                                       
                                       
                                          z
                                          a
                                       
                                       =
                                       
                                          d
                                          i
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (6)
                              
                                 
                                    ∀
                                    a
                                    ∈
                                    B
                                    ,
                                    
                                       z
                                       a
                                    
                                    ≥
                                    0
                                 
                              
                           
                        
                     

The dual variables corresponding to constraints (5) being denoted by λi
                        , solving the related pricing problem PRICE(λ) means looking for some valid antichain a
                        0, such that

                           
                              (7)
                              
                                 
                                    
                                       
                                          ∑
                                          
                                             i
                                             ∈
                                             
                                                a
                                                0
                                             
                                          
                                       
                                       
                                          λ
                                          i
                                       
                                       >
                                       1
                                    
                                 
                              
                           
                        
                     

This problem is NP-complete. Indeed, if we consider the case where |K| = 1 and where there is no precedence constraint, we have a knapsack problem, which is NP-complete. However, this problem may be efficiently handled through a combination of greedy search and Integer Linear Programming (ILP). A well-fitted ILP formulation of the PRICE(λ) problem can be expressed as follows, where we have only one type of decision variables, yi
                         ∈ {0, 1}. This decision variable is defined so that yi
                         = 1 if and only if activity i ∈ a
                        0.

                           
                              (8)
                              
                                 
                                    
                                       
                                          Maximize
                                       
                                       
                                          ∑
                                          
                                             i
                                             ∈
                                             X
                                          
                                       
                                       
                                          λ
                                          i
                                       
                                       
                                          y
                                          i
                                       
                                    
                                 
                              
                           
                        s.t.

                           
                              (9)
                              
                                 
                                    
                                       ∀
                                       i
                                       ,
                                       j
                                       ∈
                                       X
                                       |
                                       i
                                       ≺
                                       j
                                       ,
                                    
                                    
                                       y
                                       i
                                    
                                    +
                                    
                                       y
                                       j
                                    
                                    ≤
                                    1
                                 
                              
                           
                        
                        
                           
                              (10)
                              
                                 
                                    
                                       ∀
                                       k
                                       ∈
                                       K
                                       ,
                                       
                                          ∑
                                          
                                             i
                                             ∈
                                             X
                                          
                                       
                                       
                                          r
                                          
                                             i
                                             k
                                          
                                       
                                       
                                          y
                                          i
                                       
                                       ≤
                                       
                                          R
                                          k
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (11)
                              
                                 
                                    ∀
                                    i
                                    ∈
                                    X
                                    ,
                                    
                                       y
                                       i
                                    
                                    ∈
                                    
                                       {
                                       0
                                       ,
                                       1
                                       }
                                    
                                 
                              
                           
                        
                     

Linear program 
                           
                              P
                              A
                           
                         only provides a lower bound of Preemptive RCPSP instance I. If vector 
                           
                              z
                              =
                              (
                              
                                 z
                                 a
                              
                              ,
                              a
                              ∈
                              A
                              )
                           
                         is a feasible solution of 
                           
                              
                                 P
                                 A
                              
                              ,
                           
                         it may not be possible to turn it into a feasible solution of I whose makespan is 
                           
                              
                                 ∑
                                 
                                    a
                                    ∈
                                    A
                                 
                              
                              
                                 z
                                 a
                              
                           
                         (due to precedence constraints which may lead to circuits). We can link the valid antichain set 
                           A
                         to an oriented graph structure 
                           
                              (
                              A
                              ,
                              
                                 E
                                 ≺
                              
                              )
                           
                         by specifying that there exists an arc 
                           
                              
                                 (
                                 a
                                 ,
                                 b
                                 )
                              
                              ∈
                              
                                 (
                                 A
                                 ,
                                 
                                    E
                                    ≺
                                 
                                 )
                              
                           
                         from antichain a to antichain b if there exist activities i ∈ a and j ∈ b such that i≺j.

Let z be some feasible solution of 
                           
                              P
                              A
                           
                         and 
                           
                              A
                              (
                              z
                              )
                              ⊆
                              A
                           
                         be the set 
                           
                              A
                              (
                              z
                              )
                              =
                              {
                              a
                              ∈
                              A
                           
                         such that za
                         ≠ 0} of active antichains according to z. Also, let 
                           
                              G
                              
                                 A
                                 (
                                 z
                                 )
                              
                           
                         be the subgraph of 
                           
                              (
                              A
                              ,
                              
                                 E
                                 ≺
                              
                              )
                           
                         induced by 
                           
                              A
                              (
                              z
                              )
                           
                        .

For the instance described in Fig. 1a, Fig. 1d shows an optimal solution z of the Antichain linear program where 
                           
                              A
                              
                                 (
                                 z
                                 )
                              
                              =
                              
                                 {
                                 
                                    a
                                    1
                                 
                                 ,
                                 
                                    a
                                    2
                                 
                                 ,
                                 
                                    a
                                    3
                                 
                                 }
                              
                           
                         with a
                        1 = {1, 7, 8}, a
                        2 = {2, 3, 4} and a
                        3 = {5, 6}. Note that since 1≺3, 3≺6 and 5≺7, we have 
                           
                              
                                 (
                                 
                                    a
                                    1
                                 
                                 ,
                                 
                                    a
                                    2
                                 
                                 )
                              
                              ,
                              
                                 (
                                 
                                    a
                                    2
                                 
                                 ,
                                 
                                    a
                                    3
                                 
                                 )
                              
                              ,
                              
                                 (
                                 
                                    a
                                    3
                                 
                                 ,
                                 
                                    a
                                    1
                                 
                                 )
                              
                              ∈
                              
                                 (
                                 A
                                 ,
                                 
                                    E
                                    ≺
                                 
                                 )
                              
                           
                         and 
                           
                              G
                              
                                 A
                                 (
                                 z
                                 )
                              
                           
                         contains a circuit.

The following result can easily be checked.

                           Theorem 3.1
                           
                              Let z be some feasible solution of
                              
                                 
                                    P
                                    A
                                 
                              . Then there exists a feasible schedule σ such that z(σ) = z if and only if the subgraph
                              
                                 
                                    G
                                    
                                       A
                                       (
                                       z
                                       )
                                    
                                 
                               
                              does not contain any circuit.
                           

Let us suppose that the oriented graph 
                                 
                                    G
                                    
                                       A
                                       (
                                       z
                                       )
                                    
                                 
                               does not contain any circuit. Then we may extend E
                              ≺ into a linear ordering, which means that we may label the antichains in 
                                 
                                    A
                                    (
                                    z
                                    )
                                 
                               as a sequence a
                              0, …, a
                              
                                 P − 1, in such a way that: if (ap, aq
                              ) ∈ E
                              ≺, then p < q. We associate with this labeling a sequence t
                              0, …, tP
                               of time values, by setting:

                                 
                                    •
                                    
                                       t
                                       0 = 0;

For any p = 0, …, P − 1, t
                                       
                                          p + 1 = tp
                                        + z(ap
                                       ).

Doing it allows us to derive a schedule σ in a natural way: for any activity i which belongs to valid antichain ap, p = 0, …, P − 1, we consider that i is running between time tp
                               and time t
                              
                                 p + 1.

Let us now suppose that σ exists. We may suppose that σ start at time 0 and ends at some time T = Makespan(σ), and we may associate with s some sequence t
                              0 = 0 < t
                              1 < ⋅⋅⋅ < tP
                               = T, in such a way that:

                                 
                                    •
                                    for any p = 0, …, P − 1, the activities which are running between tp
                                        and t
                                       
                                          p + 1 are exactly the activities which belong to some valid antichain ap
                                       .

Any antichain ap, p = 0, …, P − 1 is an active antichains a such that za
                               ≠ 0, which means that it belongs to 
                                 
                                    A
                                    (
                                    z
                                    )
                                    ,
                                 
                               and, conversely, any antichain 
                                 
                                    a
                                    ∈
                                    A
                                    (
                                    z
                                    )
                                 
                               appears at least once in the sequence ap, p = 0, …, P − 1. So, if a, b are two antichains in 
                                 
                                    A
                                    (
                                    z
                                    )
                                 
                               such that (a, b) ∈ E
                              ≺, then there exists p and q ∈ 0, …, P − 1 such that (ap, aq
                              ) ∈ E
                              ≺, and ap
                               must precede aq
                               according to σ, which also means that p < q. Clearly, this forbids the oriented graph 
                                 
                                    (
                                    A
                                    
                                       (
                                       z
                                       )
                                    
                                    ,
                                    
                                       E
                                       ≺
                                    
                                    )
                                 
                               from containing any circuit.□

It may be remarked that program 
                           
                              P
                              A
                           
                         provides an additional insight into Preemptive RCPSP. Let σ be any feasible Preemptive RCPSP schedule, and let 
                           
                              z
                              
                                 (
                                 σ
                                 )
                              
                              =
                              (
                              z
                              
                                 
                                    (
                                    σ
                                    )
                                 
                                 a
                              
                              ,
                              a
                              ∈
                              A
                              )
                           
                         be the related vector associated with σ and 
                           A
                        . If 
                           
                              A
                              (
                              z
                              (
                              σ
                              )
                              )
                           
                         is the related active antichain set, then we see that solving the restricted linear program 
                           
                              (
                              
                                 P
                                 
                                    A
                                 
                                 
                                    A
                                    (
                                    z
                                    (
                                    σ
                                    )
                                    )
                                 
                              
                              )
                           
                         using the Primal Simplex Algorithm yields another feasible schedule σ* with makespan no larger than the makespan of σ. Furthermore, Linear Programming Theory tells us that the number of active antichains related to σ* (that is to say the cardinality of 
                           
                              A
                              (
                              z
                              
                                 (
                                 
                                    σ
                                    *
                                 
                                 )
                              
                              )
                           
                        ) does not exceed the number of constraints of 
                           
                              (
                              
                                 P
                                 
                                    A
                                 
                                 
                                    A
                                    (
                                    z
                                    
                                       (
                                       
                                          σ
                                          *
                                       
                                       )
                                    
                                    )
                                 
                              
                              )
                              ,
                           
                         which is equal to the cardinality of the activity set X. Preemptive RCPSP can thus be seen as a combinatorial problem related to the search for some acyclic subgraph 
                           
                              G
                              B
                           
                         of the antichain graph 
                           
                              (
                              A
                              ,
                              
                                 E
                                 ≺
                              
                              )
                           
                         such that 
                           
                              Card
                              (
                              B
                              )
                              ≤
                              Card
                              (
                              X
                              )
                           
                         and the optimal value of the program 
                           
                              (
                              
                                 P
                                 
                                    A
                                 
                                 B
                              
                              )
                           
                         is minimal.

A partially ordered set (Z, ≺io) is an interval order if the elements i of Z may be represented as intervals Ii
                         of the real line, such that, for any pair i, j ∈ Z:

                           
                              
                                 
                                    
                                       (
                                       i
                                       
                                          ≺
                                          io
                                       
                                       j
                                       )
                                    
                                    ifandonlyif
                                    
                                       (
                                       x
                                       ∈
                                       
                                          I
                                          i
                                       
                                       and
                                       y
                                       ∈
                                       
                                          I
                                          j
                                       
                                       imply
                                       x
                                       <
                                       y
                                       )
                                    
                                 
                              
                           
                        
                     

It is known (see Roberts, 1976), that the partially ordered set (Z, ≺io) is an interval order if and only if (Z, ≺io) does not contain a suborder isomorphic to the structure described in Fig. 2
                        .

If we now consider our Preemptive RCPSP instance I = (X, K, ≺), we see that:

                           Theorem 3.2
                           
                              If the partial order (X, ≺) is an interval order, then the oriented antichain graph
                              
                                 
                                    (
                                    A
                                    ,
                                    
                                       E
                                       ≺
                                    
                                    )
                                 
                               
                              is acyclic.
                           

We suppose the converse, and consider some circuit Γ in 
                                 
                                    (
                                    A
                                    ,
                                    
                                       E
                                       ≺
                                    
                                    )
                                 
                               with minimal length. Then we must distinguish two cases:


                              First case: |Γ| = 2, which means that Γ contains two antichains a and b. Here we see that |a| ≥ 2 and |b| ≥ 2, and there must exist i, j′ ∈ a and j, i′ ∈ b such that i≺j and i′≺j′. From this it follows that ({i, j, i′, j′}, {i≺j, i′≺j′}) defines a forbidden structure for interval orders (Fig. 2), which entails a contradiction.


                              Second case: |Γ| ≥ 3. Since (X, ≺) is acyclic, Γ must contain three consecutive antichains a, b, c such that |Γ∩b| = 2 and there exist i ∈ a, j, i′ ∈ b and j′ ∈ c, such that i≺j and i′≺j′. But from the minimality of length(Γ) and from the fact that a, b and c are antichains it can be deduced that i, j, i′ and j′ must define a forbidden structure for interval orders (Fig. 2), which also entails a contradiction.□

This result significantly impacts the design of the algorithm which will be presented in the next section. Clearly, if σ is a feasible schedule for the Preemptive RCPSP instance I = (X, K, ≺), we remark that it is possible to extend the precedence relation ≺ into an interval order ≺
                           σ
                        , so that σ remains consistent with ≺
                           σ
                        . It is sufficient to define ≺
                           σ
                         by considering the interval order where each activity i ∈ X is represented by interval Ii
                         = [StartTime(σ, i), EndTime(σ, i)[.

Putting this last remark and Theorem 3.2 together shows us that for the Preemptive RCPSP instance I it is sufficient to enumerate the extensions ≺io of the order relation ≺, which are interval orders. We can in fact restrict ourselves to those extensions ≺io which are minimal for inclusion, that is to say where there exists no extension ≺′ of ≺ that is an interval order and where ≺′⊊≺io (this means that for any activity pair i, j in X: i≺′j implies i≺io
                        j and there exist i′, j′ ∈ X such that i′≺′j′ without i′≺io
                        j′). Furthermore, it is easy to establish the following straightforward result.

                           Proposition 3.1
                           
                              Let (X, ≺′) be an interval order extension of (X, ≺). Therefore, if (X, ≺) contains a forbidden structure of interval orders ({i, j, i′, j′}, {i≺j, i′≺j′}), then (X, ≺′) contains at least the constraints i≺′j′ or i′≺′j.

The structures 
                           
                              (
                              
                                 {
                                 i
                                 ,
                                 j
                                 ,
                                 
                                    i
                                    ′
                                 
                                 ,
                                 
                                    j
                                    ′
                                 
                                 }
                              
                              ,
                              
                                 {
                                 i
                                 
                                    ≺
                                    1
                                    ′
                                 
                                 j
                                 ,
                                 
                                    i
                                    ′
                                 
                                 
                                    ≺
                                    1
                                    ′
                                 
                                 
                                    j
                                    ′
                                 
                                 ,
                                 i
                                 
                                    ≺
                                    1
                                    ′
                                 
                                 
                                    j
                                    ′
                                 
                                 }
                              
                              )
                           
                         and 
                           
                              (
                              
                                 {
                                 i
                                 ,
                                 j
                                 ,
                                 
                                    i
                                    ′
                                 
                                 ,
                                 
                                    j
                                    ′
                                 
                                 }
                              
                              ,
                              
                                 {
                                 i
                                 
                                    ≺
                                    2
                                    ′
                                 
                                 j
                                 ,
                                 
                                    i
                                    ′
                                 
                                 
                                    ≺
                                    2
                                    ′
                                 
                                 
                                    j
                                    ′
                                 
                                 ,
                                 
                                    i
                                    ′
                                 
                                 
                                    ≺
                                    2
                                    ′
                                 
                                 j
                                 }
                              
                              )
                           
                         are known as minimal interval extensions of ({i, j, i′, j′}, {i≺j, i′≺j′}). These structures are described in Fig. 3
                        .

The next section is devoted to detailed description of how the enumeration of interval extensions is performed.


                     Sections 2 and 3 lead us to reformulate PRCPSP for any instance I = (X, K, ≺) as follows. It is a matter of computing an extension ≺io of the precedence relation ≺ that is an interval order and where the value of the optimal solution z
                     io of the related linear program 
                        
                           P
                           
                              A
                              io
                           
                        
                      corresponding to antichains 
                        
                           A
                           io
                        
                      of ≺io is the smallest possible.

Our algorithm IOE based on Interval Order Enumerations is a branch-and-bound algorithm which performs some enumeration of the extensions ≺io of ≺. We will now specify the components of the tree search process. First we describe the extensions of Preemptive RCPSP instance I = (X, K, ≺) which define the nodes of the related search tree. Then we describe in some detail how branching, bounding and related filtering are performed. We also explain the constraint propagation scheme and the branching strategy, before presenting a summary of the whole algorithm.

A node in the search tree induced by a branch-and-bound algorithm is usually defined by a set of additional constraints imposed on the initial problem. In the case of the Preemptive RCPSP instance I = (X, K, ≺), those constraints are:

                           
                              •
                              additional precedence constraints with the aim of obtaining an interval order extension of ≺. We denote by (X, →) the precedence graph containing the precedence relations of (X, ≺) and the additional precedence constraints.


                                 anti-precedence constraints, denoted by i↛j, meaning that i → j is forbidden.

The precedence graph (X, →) is managed so that it always remains transitive. If (X, →) is not an interval order, then it must contain some forbidden structure for interval orders ({i, j, i′, j′}, {i → j, i′ → j′}). In order to remove this forbidden structure, we enrich (X, →) with additional constraints. There are two alternatives (see Proposition 3.1):

                           
                              •
                              Case 1: i → j′

Case 2: i′ → j and i↛j′.

We can therefore identify any node v of the search tree using a pair Add→(v) and Add↛(v) where Add→(v) and Add↛(v) are respectively the sets of additional precedence constraints and anti-precedence constraints which constrain ≺io as follows:

                           
                              •
                              ≺∪Add→(v)⊆≺io
                              

≺io∩Add↛(v) = ∅.

Clearly, if the current order relation happens to define an interval order (X, →), the related node v is a terminal node (a leaf).

The forbidden structure for interval orders allows us to perform a binary branching process with immediate successors v
                        1 and v
                        2 by successively considering the two following alternatives:

                           
                              •
                              First alternative (successor v
                                 1): Add→(v
                                 1) = Add→(v)∪{i → j′} and Add↛(v
                                 1) = Add↛(v)

Second alternative (successor v
                                 2): Add→(v
                                 2) = Add→(v)∪{i′ → j} and Add↛(v
                                 2) = Add↛(v)∪{i↛j′}

Our branching scheme splits the set of feasible schedules into two disjoint subsets. Moreover, at each node of the search tree we are able to deduce additional information using constraint propagation to reduce computational effort.

We apply several kinds of inference rules in order to detect inconsistencies or to deduce additional precedence constraints and/or anti-precedence constraints. These rules are based on the earliest and latest start times of the activities in the desired schedule. We also use transitive closure and forbidden structures for interval orders of the current relation → at each node.

The first class of rules concerns transitivity, ensuring that at any time during the process, current relation → remains transitive:

                              
                                 (12)
                                 
                                    
                                       ∀
                                       i
                                       ,
                                       j
                                       ,
                                       l
                                       ∈
                                       X
                                       ,
                                       i
                                       →
                                       j
                                       and
                                       j
                                       →
                                       l
                                       ⇒
                                       i
                                       →
                                       l
                                    
                                 
                              
                           
                        

We use the Floyd–Warshall algorithm for computing the transitive closure for the initialization at the root node of our search tree. This algorithm runs in O(n
                           3) time. However, at the other nodes of the search tree, we update the transitive closure each time a new constraint i → j is found, according to the following equation, leading to O(n
                           2) time complexity.

                              
                                 (13)
                                 
                                    
                                       ∀
                                       
                                          i
                                          ′
                                       
                                       ,
                                       
                                          j
                                          ′
                                       
                                       ∈
                                       X
                                       ,
                                       
                                          i
                                          ′
                                       
                                       →
                                       i
                                       
                                       and
                                       
                                       j
                                       →
                                       
                                          j
                                          ′
                                       
                                       ⇒
                                       
                                          i
                                          ′
                                       
                                       →
                                       j
                                       
                                       and
                                       
                                       i
                                       →
                                       
                                          j
                                          ′
                                       
                                    
                                 
                              
                           
                        

Besides, any relation i → i induces an inconsistency, implying that the current search tree node must be pruned.

In this section we show how time windows based on the earliest and latest start times can be used to deduce further precedence constraints. Our branch-and-bound algorithm initially computes an upper bound UB at the root node, which is then updated each time an improvement is discovered during the tree search. The earliest start time ES
                              i
                            of an activity i is a lower bound for the starting time of i. Also, using a lower bound for the time period between the end of activity i and the upper bound UB, we define a latest start time LS
                              i
                            for any activity i. Using initializations ES0 = 0 and LS
                              n + 1 = UB, these values are computed for any activity i using recursion:

                              
                                 (14)
                                 
                                    
                                       
                                          ES
                                          i
                                       
                                       =
                                       
                                          max
                                          
                                             j
                                             ∈
                                             X
                                             |
                                             j
                                             →
                                             i
                                          
                                       
                                       
                                          (
                                          
                                             ES
                                             j
                                          
                                          +
                                          
                                             d
                                             j
                                          
                                          )
                                       
                                    
                                 
                              
                           
                           
                              
                                 (15)
                                 
                                    
                                       
                                          LS
                                          i
                                       
                                       =
                                       
                                          min
                                          
                                             j
                                             ∈
                                             X
                                             |
                                             i
                                             →
                                             j
                                          
                                       
                                       
                                          (
                                          
                                             LS
                                             j
                                          
                                          −
                                          
                                             d
                                             i
                                          
                                          )
                                       
                                    
                                 
                              
                           
                        

Doing this allows us to implement the following classical inference rules, which tend to keep the current precedence relation → from inducing the existence of a longest path with length greater than or equal to UB.

                              
                                 (16)
                                 
                                    
                                       ∀
                                       i
                                       ,
                                       j
                                       ∈
                                       X
                                       ,
                                       
                                          ES
                                          i
                                       
                                       +
                                       
                                          d
                                          i
                                       
                                       >
                                       
                                          LS
                                          j
                                       
                                       
                                       implies
                                       
                                       i
                                       ↛
                                       j
                                    
                                 
                              
                           
                           
                              
                                 (17)
                                 
                                    
                                       ∀
                                       i
                                       ,
                                       j
                                       ∈
                                       X
                                       ,
                                       
                                          LS
                                          i
                                       
                                       +
                                       
                                          d
                                          i
                                       
                                       ≤
                                       
                                          ES
                                          j
                                       
                                       
                                       implies
                                       
                                       i
                                       →
                                       j
                                    
                                 
                              
                           
                        

These equations insert into Add→(v) and Add↛(v) additional precedence relations at node v which should be satisfied in any schedule with makespan less than UB.

The last class of rules concerns the forbidden structures for interval orders (see Section 3.4). We wish to prevent the current relation → from containing any such structure when new precedence or anti-precedence constraints are introduced (in O(n
                           2) time complexity as for the transitive closure). The following proposition is straightforward.

                              Proposition 4.1
                              Let i, j ∈ X such that i → j. Then

                                    
                                       •
                                       
                                          
                                             
                                                ∀
                                                
                                                   i
                                                   ′
                                                
                                                ,
                                                
                                                   j
                                                   ′
                                                
                                                ∈
                                                X
                                                ,
                                                
                                                   i
                                                   ′
                                                
                                                →
                                                
                                                   j
                                                   ′
                                                
                                                and
                                                
                                                   i
                                                   ′
                                                
                                                ↛
                                                j
                                                ⇒
                                                i
                                                →
                                                
                                                   j
                                                   ′
                                                
                                             
                                          
                                       


                                          
                                             
                                                ∀
                                                
                                                   i
                                                   ′
                                                
                                                ,
                                                
                                                   j
                                                   ′
                                                
                                                ∈
                                                X
                                                ,
                                                i
                                                ↛
                                                
                                                   j
                                                   ′
                                                
                                                and
                                                
                                                   i
                                                   ′
                                                
                                                ↛
                                                j
                                                ⇒
                                                
                                                   i
                                                   ′
                                                
                                                ↛
                                                
                                                   j
                                                   ′
                                                
                                             
                                          
                                       

Also, for any i, j ∈ X such that i↛j. Then

                                    
                                       •
                                       
                                          
                                             
                                                ∀
                                                
                                                   i
                                                   ′
                                                
                                                ,
                                                
                                                   j
                                                   ′
                                                
                                                ∈
                                                X
                                                ,
                                                i
                                                →
                                                
                                                   j
                                                   ′
                                                
                                                and
                                                
                                                   i
                                                   ′
                                                
                                                →
                                                j
                                                ⇒
                                                
                                                   i
                                                   ′
                                                
                                                →
                                                
                                                   j
                                                   ′
                                                
                                             
                                          
                                       


                                          
                                             
                                                ∀
                                                
                                                   i
                                                   ′
                                                
                                                ,
                                                
                                                   j
                                                   ′
                                                
                                                ∈
                                                X
                                                ,
                                                
                                                   i
                                                   ′
                                                
                                                ↛
                                                
                                                   j
                                                   ′
                                                
                                                and
                                                i
                                                →
                                                
                                                   j
                                                   ′
                                                
                                                ⇒
                                                
                                                   i
                                                   ′
                                                
                                                ↛
                                                j
                                             
                                          
                                       

Here the role of constraints i↛j is obvious. They are useful for the insertion of additional precedence constraints into the Add→(v) set with a significant impact on the antichain set and on the optimal value of the related linear program. Of course, whenever the forbidden structure for interval orders appears, the current node is pruned.

The lower bound which derives from a current node v defined by a couple (Add→(v), Add↛(v)), is provided by the optimal value of the program 
                           
                              
                                 P
                                 A
                              
                              ,
                           
                         where valid antichains are considered as deriving from ( →, ↛). We denote this lower bound as LB(v). In each node 
                           
                              P
                              A
                           
                         is solved using column generation which induces a pricing problem (defined in Section 3.2). This pricing problem is handled heuristically or using the ILP model. Every column which has been generated at some time during the process is kept into memory.

In addition, an initial upper bound UB is obtained as part of a preprocessing step, and this is updated as soon as some feasible solution is computed by the IOE search process.

If the optimal solution z of the linear program 
                           
                              P
                              A
                           
                         is such that the subgraph 
                           
                              G
                              
                                 A
                                 (
                                 z
                                 )
                              
                           
                         does not contain any circuits, we consider that we have reached some terminal node of the search tree. If the related value 
                           
                              
                                 ∑
                                 
                                    a
                                    ∈
                                    A
                                    (
                                    z
                                    )
                                 
                              
                              
                                 z
                                 a
                              
                           
                         is smaller than the value of the current solution (current upper bound UB), we update this current solution.

In Section 4.1 we described the branching mechanism, which is based on the extraction of a forbidden structure of interval orders. Where there is more than one forbidden structure, we need to specify the strategy used in order to decide which forbidden structure ({i, j, i′, j′}, {i≺j, i′≺j′}) will define the branching.

We proceed by focusing on the shortest circuits of the subgraph 
                           
                              G
                              
                                 A
                                 (
                                 z
                                 )
                              
                           
                         and on the antichains in 
                           
                              A
                              (
                              z
                              )
                           
                         which are the most involved in these circuits. We recall that branching needs to be performed only if there exists some circuit in the subgraph 
                           
                              
                                 G
                                 
                                    A
                                    (
                                    z
                                    )
                                 
                              
                              ,
                           
                         where z is the optimal solution of 
                           
                              
                                 P
                                 A
                              
                              ,
                           
                         solved after constraint propagation has been applied. We distinguish two cases:

                           
                              •
                              
                                 First case: A circuit of length 2 exists. Then consider any antichains 
                                    
                                       a
                                       ,
                                       b
                                       ∈
                                       A
                                       (
                                       z
                                       )
                                    
                                  such that there exist i, j′ ∈ a and j, i′ ∈ b with i≺j and i′≺j′. This means that S = ({i, j, i′, j′}, {i≺j, i′≺j′}) is a forbidden structure for interval orders. For each such S involved in a circuit of length 2 we determine the weight wS
                                  as follows:

                                    
                                       (18)
                                       
                                          
                                             
                                                w
                                                S
                                             
                                             =
                                             
                                                ∑
                                                
                                                   {
                                                   a
                                                   ∈
                                                   A
                                                   
                                                      (
                                                      z
                                                      )
                                                   
                                                   |
                                                   i
                                                   ,
                                                   
                                                      j
                                                      ′
                                                   
                                                   ∈
                                                   a
                                                   }
                                                
                                             
                                             
                                                z
                                                a
                                             
                                             +
                                             
                                                ∑
                                                
                                                   {
                                                   a
                                                   ∈
                                                   A
                                                   
                                                      (
                                                      z
                                                      )
                                                   
                                                   |
                                                   j
                                                   ,
                                                   
                                                      i
                                                      ′
                                                   
                                                   ∈
                                                   a
                                                   }
                                                
                                             
                                             
                                                z
                                                a
                                             
                                          
                                       
                                    
                                 Branching should use the forbidden structure S such that wS
                                  is maximized. If there are several such structures with the same maximum, one of these is simply chosen at random.


                                 Second case: There are no circuits of length 2. From the proof of Theorem 3.2 we know that there exist three antichains 
                                    
                                       a
                                       ,
                                       b
                                       ,
                                       c
                                       ∈
                                       A
                                       (
                                       z
                                       )
                                    
                                  such that i ∈ a, j, i′ ∈ b and j′ ∈ c, with i≺j, i′≺j′ and ({i, j, i′, j′}, {i≺j, i′≺j′}) is a forbidden structure for interval orders. Therefore, there exist at least a forbidden structure S and an antichain 
                                    
                                       b
                                       ∈
                                       A
                                       (
                                       z
                                       )
                                    
                                  that contains two activities j and i′ from S. For any such structure S, we determine the weight wS
                                  as follows:

                                    
                                       (19)
                                       
                                          
                                             
                                                w
                                                S
                                             
                                             =
                                             
                                                ∑
                                                
                                                   {
                                                   a
                                                   ∈
                                                   A
                                                   
                                                      (
                                                      z
                                                      )
                                                   
                                                   |
                                                   j
                                                   ,
                                                   
                                                      i
                                                      ′
                                                   
                                                   ∈
                                                   a
                                                   }
                                                
                                             
                                             
                                                z
                                                a
                                             
                                          
                                       
                                    
                                 Again, branching should use the forbidden structure S such that wS
                                  is maximized. As in the first case, if there are several such structures with the same maximum, we choose one of them randomly.

We now present the general outline of our IOE branch-and-bound algorithm based on Interval Order Enumeration. It is implemented using a breadth first search strategy where the node list, denoted as L, is ordered by increasing optimal value of the antichain linear program, where antichains are computed with precedence graph (X, →). We also recall that each node v of the search tree is defined by Add→(v) and Add↛(v). Our IOE algorithm may be summarized as described in Algorithm 1
                        .

To the best of our knowledge, the only exact method in the literature is the basic branch-and-price algorithm proposed by Damay et al. (2007), whose aim is to assess the performance of a neighborhood search algorithm. The exact algorithm is used by the authors for determining optimal solutions for J30. In Damay et al. (2007), a node v of the search tree consists of a set of additional disjunctions, implying that, in a solution z, the corresponding activities may not be in the same antichain.

If Gz
                         is not acyclic, the search tree algorithm determines a minimal length circuit in order to develop the current node. Assume for example that a circuit ({1, 2, 7}, {3, 4, 8, 9}, {5, 6}) is detected in Gz
                         due to precedence constraints (2, 3), (4, 5) and (6, 1). Therefore, the corresponding disjunctions added to the three descendant nodes are respectively {1, 2}, {3, 4} and {5, 6}. This branching scheme gives rise to a huge number of nodes and does not deal with symmetries.

Our IOE algorithm is based on a new branching scheme in which the search space is reduced to interval order extensions. Furthermore, each node of our branch and bound tree has no more than two children, and constraint propagation is used extensively to deduce additional constraints.

The IOE Algorithm is illustrated using the instance shown in Fig. 1 (Fig. 4
                         shows the search tree). We are seeking a preemptive schedule with makespan UB ≤ 8. To this end, we initialize our branch and bound by creating a single node v
                        0 such that Add→(v
                        0) = ∅ and Add↛(v
                        0) = ∅ and L = (v
                        0). From the earliest and latest start times we deduce the additional precedence relations {1 → 7, 1 → 8} and Add→(v
                        0) = {1 → 7, 1 → 8}.


                        Evaluation of node v
                        0. The optimal solution value of the antichain linear program is 5 + 1/3 and then LB(v
                        0) = 5 + 1/3 with 
                           
                              
                                 (
                                 
                                    a
                                    1
                                 
                                 =
                                 
                                    {
                                    1
                                    ,
                                    2
                                    }
                                 
                                 ,
                                 
                                    z
                                    
                                       a
                                       1
                                    
                                 
                                 =
                                 2
                                 /
                                 3
                                 )
                              
                              ,
                              
                                 (
                                 
                                    a
                                    2
                                 
                                 =
                                 
                                    {
                                    2
                                    ,
                                    3
                                    ,
                                    4
                                    }
                                 
                                 ,
                                 
                                    z
                                    
                                       a
                                       2
                                    
                                 
                                 =
                                 1
                                 /
                                 3
                                 )
                              
                              ,
                              
                                 (
                                 
                                    a
                                    3
                                 
                                 =
                                 
                                    {
                                    1
                                    ,
                                    5
                                    }
                                 
                                 ,
                                 
                                    z
                                    
                                       a
                                       3
                                    
                                 
                                 =
                                 1
                                 /
                                 3
                                 )
                              
                              ,
                              
                                 (
                                 
                                    a
                                    4
                                 
                                 =
                                 
                                    {
                                    3
                                    ,
                                    7
                                    ,
                                    8
                                    }
                                 
                                 ,
                                 
                                    z
                                    
                                       a
                                       4
                                    
                                 
                                 =
                                 1
                                 /
                                 3
                                 )
                              
                              ,
                              
                                 (
                                 
                                    a
                                    5
                                 
                                 =
                                 
                                    {
                                    4
                                    ,
                                    7
                                    ,
                                    8
                                    }
                                 
                                 ,
                                 
                                 
                                    z
                                    
                                       a
                                       5
                                    
                                 
                                 =
                                 1
                                 /
                                 3
                                 )
                              
                              ,
                              
                                 (
                                 
                                    a
                                    6
                                 
                                 =
                                 
                                    {
                                    3
                                    ,
                                    4
                                    ,
                                    8
                                    }
                                 
                                 ,
                                 
                                    z
                                    
                                       a
                                       6
                                    
                                 
                                 =
                                 1
                                 /
                                 3
                                 )
                              
                              ,
                              
                                 (
                                 
                                    a
                                    7
                                 
                                 =
                                 
                                    {
                                    5
                                    ,
                                    6
                                    }
                                 
                                 ,
                                 
                                    z
                                    
                                       a
                                       7
                                    
                                 
                                 =
                                 2
                                 +
                                 2
                                 /
                                 3
                                 )
                              
                              ,
                              
                                 (
                                 
                                    a
                                    8
                                 
                                 =
                                 
                                    {
                                    6
                                    ,
                                    7
                                    }
                                 
                                 ,
                                 
                                    z
                                    
                                       a
                                       8
                                    
                                 
                                 =
                                 1
                                 /
                                 3
                                 )
                              
                           
                        . Since 3≺6 and 5≺8, (a
                        4, a
                        7, a
                        4) is a circuit which induces a forbidden structure for interval orders ({3, 5, 6, 8}, {3≺6, 5≺8}). We develop two successors :

                           
                              •
                              Node v
                                 1: Add→(v
                                 1) = Add→(v
                                 0)∪{5 → 6} and Add↛(v
                                 1) = Add↛(v
                                 0).

Node v
                                 2: Add→(v
                                 2) = Add→(v
                                 0)∪{3 → 8} and Add↛(v
                                 2) = Add↛(v
                                 0)∪{5↛6}.


                        Evaluation of node v
                        1. The optimal solution value of the antichain linear program is 7 and then LB(v
                        1) = 7 with 
                           
                              
                                 (
                                 
                                    a
                                    1
                                 
                                 =
                                 
                                    {
                                    1
                                    ,
                                    5
                                    }
                                 
                                 ,
                                 
                                    z
                                    
                                       a
                                       1
                                    
                                 
                                 =
                                 1
                                 )
                              
                              ,
                              
                                 (
                                 
                                    a
                                    2
                                 
                                 =
                                 
                                    {
                                    2
                                    ,
                                    3
                                    ,
                                    4
                                    }
                                 
                                 ,
                                 
                                    z
                                    
                                       a
                                       2
                                    
                                 
                                 =
                                 1
                                 )
                              
                              ,
                              
                                 (
                                 
                                    a
                                    3
                                 
                                 =
                                 
                                    {
                                    5
                                    }
                                 
                                 ,
                                 
                                    z
                                    
                                       a
                                       3
                                    
                                 
                                 =
                                 2
                                 )
                              
                              ,
                              
                                 (
                                 
                                    a
                                    4
                                 
                                 =
                                 
                                    {
                                    6
                                    }
                                 
                                 ,
                                 
                                    z
                                    
                                       a
                                       4
                                    
                                 
                                 =
                                 1
                                 )
                              
                              ,
                              
                                 (
                                 
                                    a
                                    5
                                 
                                 =
                                 
                                    {
                                    6
                                    ,
                                    7
                                    }
                                 
                                 ,
                                 
                                    z
                                    
                                       a
                                       5
                                    
                                 
                                 =
                                 1
                                 )
                              
                              ,
                              
                                 (
                                 
                                    a
                                    6
                                 
                                 =
                                 
                                    {
                                    6
                                    ,
                                    8
                                    }
                                 
                                 ,
                                 
                                    z
                                    
                                       a
                                       6
                                    
                                 
                                 =
                                 1
                                 )
                              
                           
                        .


                        Evaluation of node v
                        2. The optimal solution value of the antichain linear program is 5.5 and then LB(v
                        2) = 5.5 with 
                           
                              
                                 (
                                 
                                    a
                                    1
                                 
                                 =
                                 
                                    {
                                    1
                                    ,
                                    5
                                    }
                                 
                                 ,
                                 
                                    z
                                    
                                       a
                                       1
                                    
                                 
                                 =
                                 1
                                 )
                              
                              ,
                              
                                 (
                                 
                                    a
                                    2
                                 
                                 =
                                 
                                    {
                                    2
                                    ,
                                    3
                                    ,
                                    4
                                    }
                                 
                                 ,
                                 
                                 
                                    z
                                    
                                       a
                                       2
                                    
                                 
                                 =
                                 1
                                 )
                              
                              ,
                              
                                 (
                                 
                                    a
                                    3
                                 
                                 =
                                 
                                    {
                                    5
                                    ,
                                    6
                                    }
                                 
                                 ,
                                 
                                 
                                    z
                                    
                                       a
                                       3
                                    
                                 
                                 =
                                 2
                                 )
                              
                              ,
                              
                              
                                 (
                                 
                                    a
                                    4
                                 
                                 =
                                 
                                    {
                                    6
                                    ,
                                    7
                                    }
                                 
                                 ,
                                 
                                 
                                    z
                                    
                                       a
                                       4
                                    
                                 
                                 =
                                 1
                                 /
                                 2
                                 )
                              
                              ,
                              
                                 (
                                 
                                    a
                                    5
                                 
                                 =
                                 
                                    {
                                    6
                                    ,
                                    8
                                    }
                                 
                                 ,
                                 
                                    z
                                    
                                       a
                                       5
                                    
                                 
                                 =
                                 1
                                 /
                                 2
                                 )
                              
                              ,
                              
                                 (
                                 
                                    a
                                    6
                                 
                                 =
                                 
                                    {
                                    7
                                    ,
                                    8
                                    }
                                 
                                 ,
                                 
                                    z
                                    
                                       a
                                       6
                                    
                                 
                                 =
                                 1
                                 /
                                 2
                                 )
                              
                           
                        .

Considering LB(v
                        2) < LB(v
                        1), we first develop node v
                        2. Since 1≺3 and 2≺5, (a
                        1, a
                        2, a
                        1) is a circuit which induces a forbidden structure for interval orders ({1, 2, 3, 5}, {1≺3, 2≺5}). We develop two successors :

                           
                              •
                              Node v
                                 3: Add→(v
                                 3) = Add→(v
                                 2)∪{1 → 5} and Add↛(v
                                 3) = Add↛(v
                                 2).

Node v
                                 4: Add→(v
                                 4) = Add→(v
                                 2)∪{2 → 3} and Add↛(v
                                 4) = Add↛(v
                                 2)∪{1↛5}.


                        Evaluation of node v
                        3. The optimal solution value of the antichain linear program is 5.5 and then LB(v
                        3) = 5.5 with 
                           
                              
                                 (
                                 
                                    a
                                    1
                                 
                                 =
                                 
                                    {
                                    1
                                    ,
                                    2
                                    }
                                 
                                 ,
                                 
                                 
                                    z
                                    
                                       a
                                       1
                                    
                                 
                                 =
                                 1
                                 )
                              
                              ,
                              
                                 (
                                 
                                    a
                                    2
                                 
                                 =
                                 
                                    {
                                    3
                                    ,
                                    4
                                    ,
                                    5
                                    }
                                 
                                 ,
                                 
                                    z
                                    
                                       a
                                       2
                                    
                                 
                                 =
                                 1
                                 )
                              
                              ,
                              
                              
                                 (
                                 
                                    a
                                    3
                                 
                                 =
                                 
                                    {
                                    5
                                    ,
                                    6
                                    }
                                 
                                 ,
                                 
                                 
                                    z
                                    
                                       a
                                       3
                                    
                                 
                                 =
                                 2
                                 )
                              
                              ,
                              
                              
                                 (
                                 
                                    a
                                    4
                                 
                                 =
                                 
                                    {
                                    6
                                    ,
                                    7
                                    }
                                 
                                 ,
                                 
                                 
                                    z
                                    
                                       a
                                       4
                                    
                                 
                                 =
                                 1
                                 /
                                 2
                                 )
                              
                              ,
                              
                                 (
                                 
                                    a
                                    5
                                 
                                 =
                                 
                                    {
                                    6
                                    ,
                                    8
                                    }
                                 
                                 ,
                                 
                                    z
                                    
                                       a
                                       5
                                    
                                 
                                 =
                                 1
                                 /
                                 2
                                 )
                              
                              ,
                              
                                 (
                                 
                                    a
                                    6
                                 
                                 =
                                 
                                    {
                                    7
                                    ,
                                    8
                                    }
                                 
                                 ,
                                 
                                    z
                                    
                                       a
                                       6
                                    
                                 
                                 =
                                 1
                                 /
                                 2
                                 )
                              
                           
                        . We obtain a feasible schedule whose makespan is equal to the smallest lower bound. This schedule is then optimal and the search tree is stopped.

IOE is coded in C + + on linux CentOS, with an Intel(R) Xeon(R) 2.40 gigahertz processor. ILP formulation of the related pricing problem is handled by CPLEX 12 linear solver, and the global IOE process is embedded into the SCIP framework for branch-and-cut-and-price algorithms SCIP (n.d.). This framework consists of a template library which implements breadth first search generic branch-and-bound schemes involving linear programming together with pricing scheme.

Different benchmarks were used to evaluate the performance of our branch-and-bound algorithm. We used the PSPLib (Kolisch and Sprecher, 1997) that contains four classes J30, J60, J90 and J120 with 30, 60, 90 and 120 activities respectively. Each of the first three classes contains 480 instances, whereas class J120 has 600 instances. We also used the 40 instances (BL) with either 20 or 25 activities proposed by Baptiste and Pape (2000). In addition, we tested our algorithm using the 55 instances (Pack) with a number of activities varying from 17 to 35 proposed by Carlier and Néron (2003). We give a summary of our computational experiments below. Detailed results are available on http://www.isima.fr/~toussain/.

In order to get an initial upper bound we apply to instance I a greedy randomized algorithm designed for the Non-Preemptive RCPSP (see Quilliot and Toussaint, 2012; Artigues, Michelon, and Reusser, 2003) and which, in the case of 30 activity PSPLIB instances, approximates the optimal Non-Preemptive RCPSP optimal value to within 2 percent in average.

Our main achievement here is solving Preemptive RCPSP both exactly and rapidly on all J30, BL and Pack instances. The results are presented in Table 1
                        , where for each instance class (J30, BL and Pack) the mean, minimum, maximum and standard deviation are given for:

                           
                              •
                              
                                 Non Preemp. opt.: Optimal values for Non-Preemptive RCPSP, when available


                                 Preemp. opt.: Optimal values for Preemptive RCPSP (our results)


                                 #nodes: Number of nodes created (0 means that an optimal value was found by a heuristic in preprocessing and proved to be optimal by the first constraint propagation)


                                 cpu (s): cpu time in seconds

In the case of J30, we noticed that for 236 instances out of 480, the optimal values for the antichain linear program at the root node, for the Preemptive RCPSP and for the Non-Preemptive RCPSP coincide. Also, the optimal value of the antichain linear program approximates in average the Non-Preemptive RCPSP optimal value to within 6 percent on average.

The computational results for J60, J90 and J120 are presented in Table 2
                         where we give for each instance class (J60, J90 and J120):

                           
                              •
                              
                                 #inst: Number of class instances


                                 #svd_inst: Number of instances solved


                                 Avg_LB: Average lower bounds


                                 Avg_UB: Average upper bounds


                                 Avg Δ(UB/CP): Average deviation in percent from the critical path lower bound


                                 Avg Δ(UB/LB): Average deviation in percent from our best lower bound LB


                                 Avg cpu (s): Average CPU time in seconds


                                 Avg #nodes: Average numbers of visited search tree nodes

The results are given with a time limit of 3 hours. Our IOE algorithm is able to solve to optimality 383 out of 480 instances for J60, 299 out of 480 instances for J90, but only 21 out of 600 instances for J120. Though we were not able to handle all 60/90/120 activity instances of the PSLIB library in an exact fashion, we were nevertheless able to derive new lower bounds for 33 Non-Preemptive RCPSP instances of the PSPLIB library. The results are summarized in Table 3
                        , where

                           
                              •
                              
                                 Best non-preemp. UB: Best known upper bound for Non-Preemptive RCPSP (available in PSPLIB website)


                                 Preemp. LB: Lower bound for Preemptive RCPSP (our method)


                                 Deduced no preemp. LB: Lower bound for Non-Preemptive RCPSP which we deduce from Preemp. LB
                              


                                 Best known LB: The best known lower bound currently available from the PSPLIB website and updated with recent results of (see Schutt et al., 2011).

@&#CONCLUSIONS@&#

An effective branch-and-price algorithm for the Preemptive RCPSP scheduling problem based on minimal Interval Order Enumeration has been developed incorporating a number of constraint propagation techniques. As well as solving exactly small Preemptive RCPSP instances for three classes (J30, BL and Pack), it is also able to improve the lower bounds for 33 Non-Preemptive RCPSP instances. We are currently seeking to adapt this method to the Non-Preemptive RCPSP.

@&#ACKNOWLEDGEMENTS@&#

The authors would like to thank the anonymous reviewers for their helpful comments and suggestions that improved the quality of this paper.

This work was carried out within the framework of the Labex IMOBS3 and Labex MS2T: (Reference ANR-11-IDEX-0004-02), which were funded by the French Government, through the program Investments for the future managed by the National Agency for Research. It is also partially supported by the National Agency for Research, under ATHENA project: (Reference ANR-13-BS02-0006).

@&#REFERENCES@&#

