@&#MAIN-TITLE@&#Stochastic equilibrium assignment with variable demand: Theoretical and implementation issues

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Internal approach algorithms significantly outperform external approach ones.


                        
                        
                           
                           Internal algorithm efficiency is not affected by travel demand model parameters.


                        
                        
                           
                           Restarting technique significantly increases the MSA efficiency.


                        
                        
                           
                           Smoothing technique together with restarting technique let MSA-CA outperform MSA-FA.


                        
                        
                           
                           Non-separable and asymmetric arc cost functions do not much affect algorithms efficiency.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Stochastic equilibrium assignment

Fixed-point model

Variable demand

Method of successive averages

Internal approach

@&#ABSTRACT@&#


               
               
                  Recently, it has been pointed out that transport models should reflect all significant traveler choice behavior. In particular, trip generation, trip distribution, modal split as well as route choice should be modeled in a consistent process based on the equilibrium between transport supply and travel demand. In this paper a general fixed-point approach that allows dealing with multi-user stochastic equilibrium assignment with variable demand is presented. The main focus was on investigating the effectiveness of internal and external approaches and of different algorithmic specifications based on the method of successive averages within the internal approach. The vector demand function was assumed non-separable, non-symmetric cost functions were adopted and implementation issues, such updating step and convergence criterion, were investigated. In particular the aim was threefold: (i) compare the internal and the external approaches; (ii) investigate the effectiveness of different algorithmic specifications to solve the variable demand equilibrium assignment problem through the internal approach; (iii) investigate the incidence of the number of the links with non-separable and/or asymmetrical cost functions. The proposed analyses were carried out with respect to two real-scale urban networks regarding medium-size urban contexts in Italy.
               
            

@&#INTRODUCTION@&#

Assignment models play a central role in developing a complete model for a transportation system describing how demand and supply interact with each other. These models allow the calculation of performance measures and user flows for each supply element (network arc), resulting from origin-destination demand flows, path choice behavior, and the interactions between supply and demand. Their results, in turn, are the inputs for the design and/or evaluation of transportation projects.

In congested networks the interaction between supply and demand can be modeled through two main approaches: dynamic process or equilibrium (steady-state). The former can rely on a quite consolidated theoretical framework but not on significant applications to real cases. The latter, much more consolidated in literature and applications, holds an important role in strategic planning (long term) and is the most pursued and robust solution to tactical planning (short term). Within-day dynamics, mainly used for control and real time management of a transportation system, will be not addressed in this paper.

Most modeling approaches to the equilibrium between demand and supply assume that origin-destination demand flows are known hence path choice is the only behavior explicitly modeled. Such assignment models, known as assignment model with constant (rigid) demand, do not consider the role that some choice dimensions (such as trip production, and/or choice of departure time slice, destination, transport mode, parking type and area) may have on equilibrium configuration (and more broadly on the transport system evolution). In such a context, many government agencies and transport analysts (recently Smith, 2009; see also Commission for Integrated Transport, 2004; COMSIS, 1996; DfT, 2005) point out the need for assignment models with variable (elastic) demand since demand elasticity may be relevant for urban planning over a medium-long term horizon.

Assignment with variable demand models supply–demand interaction when path costs due to congested arc costs affect user behavior other than path choice (such as the decision to travel, to which destination, by which mode, etc.). Although the topic has been investigated since the ’70, several theoretical and operational issues are still worth of further methodological and operational analyses. Most applications are mainly based on simple implementation of the external approach which solves a two-level problem where the circular dependence between demand flows and costs is expressed externally to the flow-cost equilibrium. The problem is usually addressed through heuristic methods, mostly on deterministic path choice behaviors, and/or other simplifying assumptions (see Section 2 for an analysis of the state of art). On the other hand, very few papers implement the internal approach which is founded on an extension of the constant demand equilibrium assignment problem.

This paper presents a general fixed-point modeling framework, following the internal approach. It allows dealing with multi-user stochastic equilibrium assignment with variable demand. The approach pursued is general enough to be extended to every trip choice dimensions, to accommodate most existing demand models, even non-separable ones, and arc cost functions, even with non-symmetric Jacobian. Moreover, it allows easily defining conditions for solution existence and uniqueness, as well as analysis of algorithm convergence. To authors’ knowledge, existing fixed-point models (Cantarella, 1997) as well as variational inequality models (Meng, 2012, 2014) for SUE are available for separable demand functions only.

The main focus was on investigating the effectiveness of internal and external approaches and of different algorithmic specifications within each approach to solve the variable demand equilibrium assignment problem. It is worth highlighting that the vector demand function is assumed non-separable, say the whole vector of demand flows depends on the whole vector of satisfaction variables. This way trip distribution models may also be considered together with mode split ones when the demand function is specified. In addition implementation issues, such updating step and convergence criterion, are discussed.

In particular the aim was threefold.

                        
                           i)
                           Compare the internal and the external approaches.

The external approach searches the equilibrium between the demand flows resulting from the demand model, and the costs resulting from an equilibrium assignment with constant demand. Equilibrium between flows and costs is computed at the inner level for a given set of demand flows. The outer level computes equilibrium between the costs resulting from the inner level equilibrium assignment and demand flows obtained from demand functions. This approach is very common in practice, presumably since it can easily be implemented. In the internal approach the demand models are embedded within the network loading map, as described by the arc flow function (see Section 3).

For both approaches different algorithms based on the MSA were implemented, and two averaging schemes were tested: on arc flows (FA) and on arc costs (CA). The comparisons were also carried out through a sensitivity analysis carried out with respect to trip production index, distribution model parameters, mode choice parameters and path choice model dispersion parameter. Such an analysis aimed to understand the robustness of algorithmic efficiency if links congestion changes due to a travel demand increase or due to change in its geographical or modal distribution.

Investigate the effectiveness of different algorithmic specifications to solve the variable demand equilibrium assignment problem through the internal approach.

In particular, the following solutions were tested: (i) two different restarting techniques in order to improve convergence speed for both averaging schemes; (ii) a different convergence criterion aimed to improve MSA-CA efficiency; (iii) a technique to smooth the effect of the step length which gets increasingly smaller.

Finally, the incidence of the number of the links with non-separable and/or asymmetrical cost functions was investigated.

The proposed analyses were carried out with respect to two real-scale urban networks regarding two Italian medium-size urban areas: Salerno (population 150,000) and Benevento (population 60,000). The travel demand was assumed variable up to the destination choice. Path choice, mode choice and destination choice were modeled through discrete choice models founded on the random utility theory and estimated (calibrated) through real data, leading to non-separable demand functions. It must be highlighted that the analyses were performed on two real case studies and not on any of the “test” networks usually adopted in most of existing contributions on traffic assignment (especially with constant demand). Indeed, it is the authors’ opinion that variable demand assignment should rely on real travel demand origin-destination information and on consistent/coherent travel demand models: (i) to rely on realistic demand models, (ii) to test/compare assignment results with the network realistic conditions; (iii) to carry out consistent sensitivity analyses. For simplicity's sake and a better analysis of path choice sets explicit path enumeration was adopted; still results can be easily transferred to more complex case studies without explicit path enumeration, as it will be shown in a future paper.

The paper is organized as follows. In Section 2 an analysis of the state of art is carried out. Section 3 describes main definitions and notations, models, and algorithms, respectively. The operational framework is introduced in Section 4; results of applications to real-scale urban network are discussed in Section 5 to support comparison and to address main implementation issues. Section 6 reports the major findings and outlines some research perspectives.

@&#LITERATURE REVIEW@&#

The assignment problem has been the subject of extensive research for several decades. Exhaustive analyses of the state of the art of the models (and the algorithms) for uncongested network and user equilibrium assignment with constant demand are deeply discussed in the books by Sheffi (1985), Thomas (1991), Patriksson (1994), Oppenheim (1995), Bell and Iida (1997), Cascetta (2009).

Variable demand assignment problem has aroused concern since the deterministic user equilibrium was introduced by Wardrop (1952) and, successively, formalized through optimization models in the pioneering work of Beckman, McGuire, and Winsten (1956).

Generally, three main methods have been adopted for addressing variable demand assignment problems: optimization, variational inequality and fixed-point.

The former, if on the one hand can count on a larger set of solution algorithms, on the other hand can only address mono-modal assignment problem, with separable cost functions and simplistic hypothesis on the demand functions, on the route choice models and on the mutual influence between different transport modes.

The variational inequality's approach allows addressing the assignment problem with non-separable asymmetric cost functions. In this case if a formal model can be derived, solution algorithms convergence can be demonstrated for symmetric cost functions only.

Fixed-point approach have a simpler mathematical formulation, comply with less binding hypothesis, and it can cope with a wider variety of operational issues: separable, not separable and asymmetric cost functions; mono-modal and multi-modal assignment problems; different travel demand models (continuous and invariant); stochastic and deterministic path choice models; mono-user and multi-user contexts. Moreover, fixed-point's solution algorithms converge in the asymmetric cost function assignment problem, if based on arc-costs. By contrast, fixed-point models rely on a very small set of solution algorithms. In this paper efficient algorithm for large scale network applications are proposed.

From Beckmann's work (Beckmann et al., 1956) the topic has received much attention at the end of the ’70s till the middle ’80s and, again, in the middle of ’90s.


                     Irwin and Von Cube (1964), Manheim and Ruiter (1970), Wigan and Bamford (1973), although without any theoretical background, proposed the first applications that took into account the interaction between different transport modes and its effect on modal split or trip distribution. Already in the ’70s, Dafermos (1971, 1972, 1980, 1982) and Smith (1979), dealing with the extension of the optimization model to symmetric deterministic equilibrium and the formulation of asymmetric deterministic equilibrium with variational inequality models, described first extensions of Deterministic User Equilibrium (DUE) models to variable demand and multi-class assignment.

One of the first tempt to formalize the assignment problem with variable demand was proposed by Florian et al. (1975) that analyzed the destination and assignment problem and proposed an optimization model with linear constraints, and continuous and separable cost functions. The model was solved through an algorithm proposed by Tomlin (1971) and derived from Frank and Wolfe algorithm. In the same year Evans (1976) faced the same problem through an optimization models and proposed an algorithm based on partial linearization method.

For the first time, in Florian (1977) took into account the mode choice dimension and explicitly simulated the interaction between different transport modes without capacity constraints. The problem was decomposed in sub-problems solved through known techniques; the resulting algorithm converged, as demonstrated in Fisk and Nguyen (1979). In the same year, Erlander (1977, an application is proposed in 1982) coped with the distribution and assignment problem proposing an optimization model with entropy maximizing formulation. The same problem was faced by Abdulaal and LeBlanc (1979), an optimization model and an algorithm similar to Frank and Wolfe were proposed. Florian and Nguyen (1978) analyzed the combination of destination choice and mode choice and proposed an optimization model for which a modification of Frank and Wolfe and the one by Evans (1976) were proposed. The Frank and Wolfe algorithm is reported in Safwat and Magnanti (1988) to address an optimization model that include the trip production, the destination choice and the mode choice, and in LeBlanc and Farhangiam (1981) to deal with the traffic assignment and modal split-assignment problem.

In 1982, Dafermos presented the first variational inequality model applied to deterministic user equilibrium with variable demand. The main hypotheses are very general: links cost depend on the flow of the other transport modes and the demand functions depend on the systematic utility of all the possible destinations and of all transport modes available. The solution algorithm solves iteratively a mono-modal equilibrium problem with variable demand. In Florian and Spiess (1983) considered a two mode (bus and transit) equilibrium assignment model and formulated the problem as a variational inequality model. Nagurney (1984) tested the efficiency of the relaxation and projection methods for calculating the traffic equilibrium in multimodal networks. She tested three different classes of monotone travel cost functions and founded that the form of the travel cost functions affected the performance of both methods.

For the first time, fixed-point models for SUE assignment were introduced by Daganzo (1983), who also analyzed variable demand assignment (with the hyper-networks approach) and multi-class assignment.


                     Sheffi (1985), in his book, proposed a systematic overview for all choice dimensions, he followed the optimization approach and, through the definition of an augmented network model, he demonstrated that the equilibrium with variable demand can be solved through algorithms similar to those used to solve the equilibrium with fixed demand. Lam and Huang (1992) presented a combined trip distribution and assignment model with multiple user classes, asymmetrical arc cost functions were used and two different algorithms based on the Frank-Wolfe's and Evans' were developed.


                     Patriksson (1994) gave an exhausting framework of models and methods to solve the deterministic equilibrium with variable demand problem. He investigated several approaches founded on: optimization models, variational inequalities or methods that use augmented network models. In Oppenheim's book (1995) optimization models and solution algorithms were proposed as the choice dimensions involved change, the algorithms proposed are mainly founded on partial linearization method.

In 1997 Cantarella, starting from fixed-point models introduced by Daganzo (1983), developed a general treatment with fixed-point models of multi-modal/multi-class variable demand equilibrium assignment also for pre-trip/en-route path choice behavior, including stochastic as well as deterministic user equilibrium. The existence and the uniqueness of solution were demonstrated and simple convergent algorithms based on method of successive averages (MSA) were proposed.


                     Bell and Iida (1997) faced both stochastic and deterministic user equilibrium with variable demand. All the choice dimensions were taken into account, optimization models and variational inequalities models were proposed. In presence of deterministic route choice the authors referred to the model and to the algorithm proposed by Evans (1976), for stochastic route choice they suggested the approach proposed by Lam, Zhang, and Lo (1995) and an algorithm based on MSA method were suggested.


                     Ferrari (1999) proposed a single-mode equilibrium assignment model with variable demand which took into account the presence of arc capacity constraints. The model followed the variational inequality approach, and assumed non-separable cost functions and variable demand up to mode choice.


                     Bellei, Gentile, and Papola (2002) introducing a network pricing optimization problem, proposed a fixed point model to deal with multi-user multimodal assignment problem with variable demand. The demand was supposed variable up to trip production, the multimodal network was modeled through hypergraph and asymmetric arc cost functions were used.


                     Bar-Gera and Boyce (2003) presented a fixed point formulation for combined models and convergent algorithm for combined models is presented. In 2005 Garcia and Marin (2005) developed an approach to the multi-modal assignment problem with combined modes based on the variational inequality approach. Smith (2009) introduced two-direction methods for finding traffic equilibrium. The first paper showed that the common algorithm used for estimating variable demand may give unrealistic results. The second paper dealt with the solution of variable demand equilibrium models with and without signal control. Finally, Cantarella in Cascetta (2009) proposed a systematic framework founded on fixed point modes for the stochastic equilibrium and on variational inequalities for the deterministic equilibrium.

Recently, Meng et al. (2012, 2014) developed a VI modeling approach for the asymmetric stochastic equilibrium with variable demand (2012) which can be extended to cope with arc capacity constraints (2013). A comparison with this approach is out of the scope of this paper, it suffices to stress that proposed VI models for SUE require separable demand function, while the one proposed in this paper may also deal with non-separable demand functions. In addition when applying VI models it is much harder to assess features such as solution existence and uniqueness or algorithm convergence with respect to fixed-point models.

Starting from the depicted contributions, a relevant part of literature has been also devoted to application issues oriented to simulate the effect of different strategies to real case studies. Among them, the most interesting one are (for a complete review the reader may refer to Cantarella, de Luca, Di Gangi, &#38; Di Pace, 2013): Fernandez, Florian, De Cea, and Cabrera (1994); Nagurney, Ramanujam, and Dhanda (1998); Lundqvist and Abrahamsson (1999); May and Milne (2000); De Cea and Fernandez (2001); Clegg, Smith, Xiang, and Yarrow (2001); Yildirim and Hearn (2005); Zhou, Chen, and Wong (2009); D'Acierno, Gallo, and Montella (2006); Meng and Liu (2012). Alternative and interesting approaches are presented by Wong (1998) and Wichiensin, Bell, and Yang (2007). The former presents a continuum equilibrium model, the latter proposes a Bertrand–Nash equilibrium model that incorporates mode choices and fare settings.

As regards solution algorithms, variable demand assignment problem relies on algorithmic approaches derived from the constant demand problem.

Optimization and variational inequality models for deterministic user equilibrium are mostly solved through Frank and Wolfe's, Evans’ and (Korpelevic, 1977) algorithms or their modifications.

For fixed-point models most of the existing contributions and/or applications make use of algorithms based on the method of successive averages (MSA) proposed by Sheffi and Powell (1982) for solving SUE problems. The most followed approach averages on arc flows (MSA-FA) and sets the step size according to a predetermined decreasing sequence (1/k, with k being the iteration index). Alternative step size or alternative step techniques have been proposed for solving constant demand assignment problems (Bar-Gera and Boyce, 2006; Cascetta and Postorino, 2001; Liu, He, &#38; He, 2009; 
                     Nagurney and Zhang, 1996).


                     Cantarella (1997) proposed a ଁxed-point model in terms of arc costs (MSA-CA) for the asymmetric SUE problem with variable demand. He proved that the MSA updating arc travel cost instead of arc ଂow is convergent for solving the stochastic assignment problem.

Models for traffic assignment to transportation networks simulate how demand and supply interact in transportation systems. These models allow the calculation of performance measures and user flows for each supply element, resulting from origin-destination demand flows, path choice behavior, and the reciprocal interactions between supply and demand. Assignment models with variable demand combine two sub-models: the supply model, made up by the arc cost function and the arc-path consistency equations, and the demand model, including the path choice model and the demand flow model; these models may also be considered a combination of the arc cost function, part of the supply model, and the arc flow function, made up by the demand model and the arc-path consistency equations.

Users are assumed grouped into user classes. Each user class i is a set of users with common behavioral parameters and trip purpose traveling during the same time period between the same origin-destination (O-D) pair with common trip purpose and behavioral parameters.

Transportation supply is usually simulated through a congested network model, which expresses how user behavior affects network performances. The topological features of transportation supply are modeled through a graph, so that each journey is simulated by a sequence of nodes and arcs (or links), thus a route is modeled by a path in the graph. A generalized cost is associated to each arc; each path is associated with a path cost. Let

                              
                                 
                                    B
                                    
                                       i
                                     be the arc-path incidence matrix for user class i, with entries bi,aj
                                     = 1 if arc a belongs to path j connecting user class i, and bi,aj
                                     = 0 otherwise;


                                    h
                                    
                                       i
                                     ≥ 0 be the path flow vector for user class i, with entries hi,
                                    ;


                                    f ≥ 0 be the arc flow vector, with entries fa
                                    ;


                                    c be the arc cost vector, assumed with non-negative entries ca
                                     ≥ 0; arc cost is usually given by travel time or by a linear combination with monetary costs and possibly other level of service attributes;


                                    w
                                    i be the path cost vector for user class i, with non-negative entries w
                                       i,j
                                     ≥ 0.

The following three equations completely describe the transportation supply under steady-state assumption.

An arc-path flow consistency equation holds:

                              
                                 (1)
                                 
                                    
                                       f
                                       =
                                       
                                          ∑
                                          i
                                       
                                       
                                          
                                             B
                                             i
                                          
                                          
                                             h
                                             i
                                          
                                       
                                    
                                 
                              
                           Base flows, e.g. due to demand segments not explicitly modeled, may easily be included without affecting results reported in this paper. They are not explicitly introduced to simplify notations.

Moreover, generally arc costs depend on arc flows through the arc cost-flow (vector) function, which can be specified through traffic engineering models:

                              
                                 (2)
                                 
                                    
                                       c
                                       =
                                       c
                                       (
                                       f
                                       )
                                    
                                 
                              
                           The arc cost vector function is assumed continuous with continuous first derivatives with respect to arc flows (continuously differentiable). If arc costs do not depend on arc flows the resulting network is called non-congested.

A path-arc cost consistency equation holds:

                              
                                 (3)
                                 
                                    
                                       
                                          w
                                          i
                                       
                                       =
                                       
                                          B
                                          i
                                          T
                                       
                                       c
                                       
                                       ∀
                                       i
                                    
                                 
                              
                           Other specific path costs, which may not be additive over the arcs, may be defined. Non arc-wise additive or specific path costs are specific to the path and/or O-D pair. The presence of non-additive or specific path costs guarantees that any affine transformation does not affect the results of the model. They are not explicitly introduced to simplify notations.

Class-specific arc cost functions can easily considered too, provided that they are specified through an affine transformation of a common arc cost function: 
                              c
                           
                           
                              i
                           (f) = βi
                            ⋅ 
                              c
                           (f) + c
                           i;0 with clear meaning of introduced notations. In addition, value of time may be considered distributed among users.

The transportation demand model describes how network performance affects user behavior. User behavior concerns path choice as well as other choice dimensions such as transportation mode, trip destination, etc. So far the demand model can be considered to be made up by a path choice model, described below, and a demand flow model, described in the following. Let

                              
                                 
                                    di
                                     ≥ 0 be the demand flow for users belonging to class i; it is the result of the demand flow model implementation; in the following all the demand flows are assumed measured in a common unit, thus they can directly be summed up;


                                    p
                                    i ≥ 0 be the path choice probability vector that can be estimated through the path choice model, 1
                                    T
                                    p
                                    i = 1, for user class i.

The demand flow conservation equation assures that the sum of path flows equals the demand flow for each user class:

                              
                                 
                                    
                                       
                                          h
                                          i
                                       
                                       =
                                       
                                          d
                                          i
                                       
                                       
                                          p
                                          i
                                       
                                       
                                       ∀
                                       i
                                    
                                 
                              
                           
                        

The path choice model simulates user path choice behavior, it is generally specified by assuming that a user completely choose the path to the destination before starting the trip at the origin. This is most often the case of transportation systems providing a continuous service, or for scheduled transport services if users are assumed knowing the service timetable thus they may take decisions before beginning the trip. Proposed framework can easily be extended to deal with pre-trip/en route choice behavior where routing alternatives are represented by hyperpaths.

The path choice model is generally specified by applying random utility theory. Let

                                 
                                    
                                       Ui,j
                                        be the perceived utility associated by users of class i to path j, and it is assumed modeled through a (non-degenerate) random variable (some examples are given below);


                                       vi,j
                                        = E[Ui,j] be the expectation of the perceived utility of path j, called systematic utility;


                                       v
                                       
                                          i
                                        is the path systematic utility vector, with elements vi,j
                                       , for users of class i.

The path systematic utility depends on the path cost through the path utility function, generally a decreasing affine transformation:

                                 
                                    
                                       
                                          
                                             v
                                             
                                                i
                                                ,
                                                j
                                             
                                          
                                          =
                                          −
                                          
                                             β
                                             i
                                          
                                          
                                             w
                                             
                                                i
                                                ,
                                                j
                                             
                                          
                                          +
                                          
                                             v
                                             o
                                          
                                          
                                             ;
                                             ij
                                          
                                       
                                    
                                 
                              where:

                                 
                                    
                                       
                                          
                                             
                                                v
                                                o
                                             
                                             
                                                ;
                                                ij
                                             
                                          
                                        is the part of the systematic utility that depends on attributes other than arc costs (such as specific non-additive path costs, user socio-economic attributes, etc.), omitted below for simplicity's sake;

βi is an utility parameter, omitted in the following since assumed included in the scale parameter within the choice function, introduced below.

Thus in the following it holds:

                                 
                                    
                                       
                                          
                                             v
                                             
                                                i
                                                ,
                                                k
                                             
                                          
                                          =
                                          −
                                          
                                             w
                                             
                                                i
                                                ,
                                                k
                                             
                                          
                                       
                                    
                                 
                              The path choice probability vector depends on the systematic utility vector through the (stochastic) path choice function, 
                                 p
                              
                              i, which generally includes a scale parameter θi
                               to be calibrated against observations; its expression depends on the choice function.

                                 
                                    
                                       
                                          
                                             p
                                             i
                                          
                                          =
                                          
                                             p
                                             i
                                          
                                          
                                             (
                                             
                                                v
                                                i
                                             
                                             ;
                                             
                                                θ
                                                i
                                             
                                             )
                                          
                                          
                                          ∀
                                          i
                                       
                                    
                                 
                              Shape of choice function depends on the assumption about perceived utility distribution. Combining all the three above equations yields the path flow model:

                                 
                                    (4)
                                    
                                       
                                          
                                             h
                                             i
                                          
                                          =
                                          
                                             d
                                             i
                                          
                                          
                                             p
                                             i
                                          
                                          
                                             (
                                             −
                                             
                                                w
                                                i
                                             
                                             ;
                                             
                                                θ
                                                i
                                             
                                             )
                                          
                                          
                                          ∀
                                          i
                                       
                                    
                                 
                              
                           

Random utility models generally adopted to specify the path choice function are continuous (with continuous first partial derivatives) leading to continuous (with continuous first partial derivatives) path flow models. Under mild assumptions (invariant choice function) both the path choice function and the resulting path flow model can be proved monotone non-increasing with symmetric negative semi-definite Jacobian with respect to the path cost vector.

Generally demand flows are results of choice behavior regarding other dimensions than path, such as transportation mode, trip destination, period of the day, and the like, which in turns depend on path costs, for example existing transportation facilities affects accessibility thus destination choice.

The demand flow model describes the dependence between demand flows and path costs, it is the result of a combination of different models regarding travel characteristics, such as transportation mode, trip destination, period of the day and is generally specified through a hierarchical combination of several random utility models, with linear utility functions. Path cost affects demand function through the so called satisfaction variable, and such relationship depends on the particular choice dimensions taken into account. For example, if demand is variable with respect to destination choice, the demand flow depends only on the elements of the satisfaction vector for O-D pairs having the same origin zone. Let

                                 
                                    
                                       si
                                        be the path satisfaction for user class i, given by the expectation of the maximum path perceived utility over all the user in class i,


                                       s = [si
                                       ]
                                          i
                                        is the satisfaction vector, with elements si
                                       .

Path satisfaction depends on path systematic utility values through the path satisfaction function:

                                 
                                    
                                       
                                          
                                             s
                                             i
                                          
                                          =
                                          
                                             s
                                             i
                                          
                                          
                                             (
                                             
                                                v
                                                i
                                             
                                             )
                                          
                                          
                                          ∀
                                          i
                                       
                                    
                                 
                              
                              
                                 
                                    
                                       
                                          or
                                          
                                          s
                                          =
                                          s
                                          (
                                          v
                                          )
                                       
                                    
                                 
                              Its expression depends on perceived utility distribution, consistently with the path choice function; the satisfaction is consistent with utility, and thus it turns out to be non-positive for path choice behavior, costs having been assumed non-negative.

Choice behavior concerning other dimensions than path can be modeled through the (non-separable vector) demand function, assumed in the following upper bounded by a strictly positive value dUB;i > 0:

                                 
                                    
                                       
                                          
                                             d
                                             i
                                          
                                          =
                                          
                                             d
                                             i
                                          
                                          
                                             (
                                             s
                                             )
                                          
                                          ≤
                                          
                                             d
                                             UB
                                          
                                          
                                             ;
                                             i
                                          
                                          
                                          ∀
                                          i
                                       
                                    
                                 
                              
                              
                                 
                                    
                                       
                                          or
                                          
                                          d
                                          =
                                          d
                                          (
                                          s
                                          )
                                       
                                    
                                 
                              Since the demand function simulates the dependence between the whole vector of demand flows and the whole vector of satisfaction values, it will vary depending on the particular choice dimensions as introduced above. If the demand flow of a user class depends only on the satisfaction of the same user class, we have the special case of separable demand functions, which may arise in the case of variable trip production (also called trip frequency, trip emission, …) models.

Random utility models usually adopted lead to continuous (with continuous first partial derivatives) demand functions with respect to satisfaction vector. Under mild assumptions (invariant choice functions, utility functions linear with respect to satisfaction) the resulting vector demand function can be proved monotone non decreasing, with symmetric positive semi-definite Jacobian with respect to satisfaction vector.

By combining the two above equations with the utility function it yields the demand flow model:

                                 
                                    
                                       
                                          
                                             d
                                             i
                                          
                                          =
                                          
                                             d
                                             i
                                          
                                          
                                             (
                                             
                                                
                                                   [
                                                   
                                                      s
                                                      i
                                                   
                                                   
                                                      (
                                                      −
                                                      
                                                         w
                                                         i
                                                      
                                                      )
                                                   
                                                   ]
                                                
                                                i
                                             
                                             )
                                          
                                          
                                          ∀
                                          i
                                       
                                    
                                 
                              
                              
                                 
                                    (5)
                                    
                                       
                                          or
                                          
                                          d
                                          =
                                          d
                                          (
                                          s
                                          (
                                          −
                                          w
                                          )
                                          )
                                       
                                    
                                 
                              Parameters of demand flow model to be calibrated or directly estimated may include: parameters of utility functions, parameters of choice functions, any constraint on demand flows, such as the total flow originated by an origin.

Demand flow model (5) can easily be extended to include mode choice behavior (see Cantarella, 1997). For simplicity's sake this case is not further discussed in the following.

The (stochastic) arc flow function with constant demand is obtained by combining the supply model consistency Eqs. (1) and (3) with the path flow model (4):

                              
                                 (6)
                                 
                                    
                                       f
                                       
                                          (
                                          
                                             c
                                             ;
                                             d
                                          
                                          )
                                       
                                       =
                                       
                                          ∑
                                          i
                                       
                                       
                                          
                                             d
                                             i
                                          
                                          
                                             B
                                             i
                                          
                                          
                                             p
                                             i
                                          
                                          
                                             (
                                             
                                             −
                                             
                                                B
                                                
                                                   i
                                                
                                                T
                                             
                                             c
                                             )
                                          
                                          ∈
                                          
                                             S
                                             f
                                          
                                       
                                    
                                 
                              
                           where

                              
                                 
                                    S
                                    
                                       f
                                     = {f = ∑
                                       i
                                    d
                                       i
                                    
                                    B
                                    
                                       i
                                    
                                    p
                                    
                                       i
                                    : p
                                    
                                       i
                                     ≥ 0, 1
                                    T
                                    p
                                    
                                       i
                                     = 1 ∀i} is the feasible arc flow set, non-empty (if at least one path is available to each user), compact (since bounded and closed), and convex (since defined by linear equalities and inequalities):


                                    d = [di]i is the demand flow vector, with elements di
                                    .

This function is useful to specify equilibrium models, as shown in the next section; it also specifies the so-called stochastic network loading (SNL) that is the (stochastic) assignment to non-congested networks.

The (stochastic) arc flow function with variable demand (VD) is obtained by including the demand flow model (5) and Eq. (3) into Eq. (6):

                              
                                 (7)
                                 
                                    
                                       
                                          f
                                          VD
                                       
                                       
                                          (
                                          c
                                          )
                                       
                                       =
                                       
                                          ∑
                                          i
                                       
                                       
                                          d
                                          i
                                       
                                       
                                          
                                             (
                                             s
                                             
                                                (
                                                
                                                −
                                                
                                                   
                                                      B
                                                   
                                                   T
                                                
                                                c
                                                )
                                             
                                             )
                                          
                                          
                                             B
                                             i
                                          
                                          
                                             p
                                             i
                                          
                                          
                                             (
                                             
                                             −
                                             
                                                B
                                                
                                                   i
                                                
                                                T
                                             
                                             c
                                             )
                                          
                                       
                                       ∈
                                       
                                          S
                                          VD
                                       
                                       
                                          ;
                                          f
                                       
                                    
                                 
                              
                           where, set S
                           VD;
                              f
                            = {f = ∑
                              i
                            d
                              i
                           
                           B
                           
                              i
                           
                           p
                           
                              i
                           : p
                           
                              i
                           ≥ 0, 1
                           T
                           p
                           
                              i
                            = 1, 0 ≤ d
                              i
                            ≤ dUB;i, ∀i} is non empty, compact, and convex as in the previous case, demand flows being assumed upper bounded by a strictly positive value.

In any case, the arc flow function is made up by summing up over user classes independent terms. With random utility models generally adopted it is continuous with continuous first partial derivatives with respect to arc cost vector, and under mild assumptions monotone non increasing with symmetric negative semi-definite Jacobian.

The arc flow function can easily be computed when explicit path enumeration can be carried out. Algorithms derived from graph theory are available to avoid explicit path enumeration (see for instance Cascetta, 2009); in some cases these algorithms also provide the values of satisfaction.

A general model for multi-user equilibrium assignment to a transportation network with constant demand can be specified by the system of non-linear (vector) Eqs. (1)–(4), it can easily recognized that the number of equations is equal to the number of unknowns. To make easier the analysis of the model, it is common practice to combine all of them, taking into account of Eq. (6) into one single (vector) equation into the shape of a fixed-point model with respect to arc flows, given the demand flows:

                           
                              (8)
                              
                                 
                                    
                                       
                                          f
                                       
                                       *
                                    
                                    =
                                    f
                                    
                                       (
                                       
                                          c
                                          (
                                          
                                             
                                                f
                                             
                                             *
                                          
                                          )
                                          ;
                                          d
                                       
                                       )
                                    
                                    ∈
                                    
                                       S
                                       f
                                    
                                 
                              
                           
                        Clearly the same model is obtained by combining the arc flow function (6) with arc cost function (2). Other equivalent models may easily be obtained with respect to arc costs as well as path flows or costs.

If the feasible arc flow set is non-empty, compact and convex, and all involved (arc cost, path choice, path utility) functions are continuous existence of at least one solution can easily be proved through the Brouwer theorem.

Moreover, for an arc flow function monotone non-increasing with respect to arc flows, if arc cost function is monotone strictly increasing with respect to arc flows existence of at most one solution (weak uniqueness) can easily be proved by contradiction (weaker conditions are currently being investigated). Existence or uniqueness of arc flow vector also guarantees existence or uniqueness of arc cost vector, patch flow and cost vectors.

A general model for equilibrium assignment with variable demand can be specified by further combining (vector) Eq. (5), or including Eq. (2) into Eq. (7):

                           
                              (9)
                              
                                 
                                    
                                       
                                          f
                                       
                                       *
                                    
                                    =
                                    
                                       f
                                       VD
                                    
                                    
                                       (
                                       
                                          c
                                          (
                                          
                                             
                                                f
                                             
                                             *
                                          
                                          )
                                       
                                       )
                                    
                                    ∈
                                    
                                       S
                                       VD
                                    
                                    
                                       ;
                                       f
                                    
                                 
                              
                           
                        
                     

Model (9) for assignment with variable demand is based on the so-called internal approach since demand flow model is embedded within the arc flow function; it is a quite straightforward extension of model (8). As such, considerations about existence and uniqueness of solution can quite easily extended from assignment with constant demand. Existence or uniqueness of arc flow vector also guarantees existence or uniqueness of arc cost vector, patch flow and cost vectors, as well as demand flows.

Extension of model (8) to cope with assignment with variable demand can also be carried out through the so-called external approach where the relationship between demand flows and costs is expressed externally to the equilibrium between (arc and path) flows and costs. At the inner level, given demand flows, flows and costs are defined by constant demand (CD) equilibrium assignment, by solving any model equivalent to Eq. (8). At the outer level, the equilibrium between the costs resulting from the constant demand equilibrium assignment and the demand flows defined by demand flow model is searched. At this aim let f
                        CD; EQ be the equilibrium arc flow vector with constant demand, solution of model (8), assuming that both existence and uniqueness of solution are granted.

Model (8) for equilibrium assignment with constant demand implicitly defines a function between its solution, f
                        CD; EQ, and the demand flow vector, d (cfr the implicit function theorem)

                           
                              (10)
                              
                                 
                                    
                                       
                                          f
                                       
                                       CD
                                    
                                    
                                       ;
                                       EQ
                                    
                                    =
                                    φ
                                    
                                       (
                                       d
                                       )
                                    
                                 
                              
                           
                        
                     


                        Eq. (10) defines a system of non-linear equations for equilibrium assignment with variable demand when coupled with the arc cost function (2):

                           
                              
                                 
                                    c
                                    =
                                    c
                                    (
                                    
                                    
                                       
                                          f
                                       
                                       CD
                                    
                                    
                                       ;
                                       EQ
                                    
                                    )
                                 
                              
                           
                        the path-arc cost consistency Eq. (3):

                           
                              
                                 
                                    
                                       w
                                       i
                                    
                                    =
                                    
                                       B
                                       i
                                       T
                                    
                                    c
                                    
                                    ∀
                                    i
                                 
                              
                           
                        and the demand flow model (5)

                           
                              
                                 
                                    d
                                    =
                                    d
                                    (
                                    s
                                    (
                                    −
                                    w
                                    )
                                    )
                                 
                              
                           
                        
                     

The analysis of equilibrium assignment with variable demand can easily be carried out following the internal approach, as shown in the previous section, but no commercial software based on internal algorithms exists to authors’ knowledge. On the other hand, whilst models obtained following the external approach are difficult to analyze theoretically, they can be useful to specify external algorithms, starting from a simpler algorithm for equilibrium assignment with constant demand, already available in commercial SW. Both types of algorithms will be described below.

In any case, as already said at the end of Section 3.1, the arc flow function can easily be computed when explicit path enumeration can be carried out. Moreover, algorithms derived from graph theory are available to avoid explicit path enumeration; in most cases these algorithms also provide the values of satisfaction.

Algorithms for equilibrium assignment with constant demand will be first introduced since they may be part of algorithms for assignment with variable demand and are useful to introduce basic concepts. In this case demand flow vector, d, may be known or may be estimated as proposed in Section 3.1.3.

The most used algorithm for solving equilibrium assignment with constant demand is based on an application of the method of successive averages (MSA) through arc flow averaging (MSA-FA). It generates a sequence of feasible arc flow vectors f
                        
                           k
                        , starting from an initial feasible solution f
                        0 ∈ Sf
                        . At each iteration k the flow solution is obtained by combining the current solution at iteration k −1 with an auxiliary flow vector ̃f
                        
                           k
                         = 
                           f
                        (
                           c
                        (f
                        
                           k
                        
                        ‐
                        1)) obtained from a stochastic assignment to an uncongested network based on arc costs that correspond to the solution at iteration k − 1. A fixed point (and only a fixed-point) is found if the auxiliary flow vector ̃f
                        
                           k
                         is equal to the current solution f
                        
                           k
                        . The algorithm can be described by the following system of recursive equations, given a starting solution f
                        0 ∈ Sf
                         for k = 0.

                           
                              
                                 
                                    
                                       {
                                       
                                          
                                             
                                                
                                                   k
                                                   =
                                                   k
                                                   +
                                                   1
                                                
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         c
                                                      
                                                      k
                                                   
                                                   =
                                                   c
                                                   
                                                      (
                                                      
                                                         
                                                            f
                                                         
                                                         
                                                            k
                                                            −
                                                            1
                                                         
                                                      
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            f
                                                            ˜
                                                         
                                                      
                                                      k
                                                   
                                                   =
                                                   f
                                                   
                                                      (
                                                      
                                                         
                                                            
                                                               c
                                                            
                                                            k
                                                         
                                                         ;
                                                         d
                                                      
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         f
                                                      
                                                      k
                                                   
                                                   =
                                                   
                                                      
                                                         f
                                                      
                                                      
                                                         k
                                                         −
                                                         1
                                                      
                                                   
                                                   +
                                                   
                                                      (
                                                      
                                                         
                                                            1
                                                            k
                                                         
                                                      
                                                      )
                                                   
                                                   ·
                                                   
                                                      (
                                                      
                                                         
                                                            
                                                               f
                                                               ˜
                                                            
                                                         
                                                         k
                                                      
                                                      −
                                                      
                                                         
                                                            f
                                                         
                                                         
                                                            k
                                                            −
                                                            1
                                                         
                                                      
                                                      )
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

If the cost vector function 
                           c
                        (f) is continuous and strictly monotone increasing and if the arc flow function 
                           f
                        (c) is continuous and monotone non-increasing,
                           1
                        
                        
                           1
                           Monotonicity of the arc flow function is ensured if the distribution of path choice model random residuals does not depend on the congestion costs.
                         then the fixed-point problem has a unique solution. Under these assumptions, application of Blum's theorem (Blum, 1954; see also Cantarella, 1997; Daganzo, 1983) guarantees that, if the Jacobian of the cost functions is symmetric, the sequence of flow solutions f
                        
                           k
                         generated by the MSA-FA algorithm (almost certainly for Montecarlo based choice models) converges to the equilibrium arc flow vector. If the arc cost vector function does not have a symmetric Jacobian with respect to arc flow vector, MSA-FA may still be used but convergence is not theoretically assured. In practice, the algorithm may be stopped when the relative difference between the auxiliary flows and the current solution falls below a pre-assigned threshold ε, as measured using a suitable vector norm, for instance: ∑
                           a
                        |̃f
                           k
                           ,a
                         ― f
                           a
                           k
                        
                        ―
                        1|/f
                           a
                           k
                        
                        ―
                        1 < ε or max
                           a
                        | ̃f
                           k
                           ,a
                         ― f
                           a
                           k
                        
                        ―
                        1|/f 
                           a
                           j
                        
                        ―
                        1 < ε.

A different algorithm, useful for non-separable cost functions with asymmetric Jacobian, can be obtained by applying the method of successive averages to costs rather than flows (MSA-CA). This algorithm generates a sequence of cost vectors c
                        
                           k
                         starting from an initial cost vector c
                        0 = 
                           c
                        (f
                        0), obtained from a feasible arc flow vector f
                        0 ∈ Sf
                         and at k = 0, in a way similar to MSA-FA. The algorithm can be described by the following system of recursive equations:

                           
                              
                                 
                                    
                                       {
                                       
                                          
                                             
                                                
                                                   k
                                                   =
                                                   k
                                                   +
                                                   1
                                                
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         f
                                                      
                                                      k
                                                   
                                                   =
                                                   f
                                                   
                                                      (
                                                      
                                                         
                                                            
                                                               c
                                                            
                                                            
                                                               k
                                                               −
                                                               1
                                                            
                                                         
                                                         ;
                                                         d
                                                      
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            c
                                                            ˜
                                                         
                                                      
                                                      k
                                                   
                                                   =
                                                   c
                                                   
                                                      (
                                                      
                                                         
                                                            f
                                                         
                                                         
                                                            k
                                                            −
                                                            1
                                                         
                                                      
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         c
                                                      
                                                      k
                                                   
                                                   =
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         k
                                                         −
                                                         1
                                                      
                                                   
                                                   +
                                                   
                                                      (
                                                      
                                                         
                                                            1
                                                            k
                                                         
                                                      
                                                      )
                                                   
                                                   ·
                                                   
                                                      (
                                                      
                                                         
                                                            
                                                               c
                                                               ˜
                                                            
                                                         
                                                         k
                                                      
                                                      −
                                                      
                                                         
                                                            c
                                                         
                                                         
                                                            k
                                                            −
                                                            1
                                                         
                                                      
                                                      )
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

Assuming that existence and uniqueness of solution are guaranteed, convergence is assured if the arc flow function has a symmetric Jacobian with respect to arc cost vector, condition which may be assured under mild assumption (see previous equation), without any condition on the Jacobian of the cost vector function.

In practice, the algorithm may be stopped when the relative difference between the flows f
                        
                           k
                         and the flows f
                        
                           k
                         = 
                           f
                        (c̃; d) corresponding to the auxiliary costs c̃
                        
                           k
                         falls below a pre-assigned threshold ε, as measured using a suitable vector norm. It should be noted that in this way two SNL are to be computed at each iteration, greatly affecting computing time with respect to MSA-FA, since a second SNL is needed to check how far from the equilibrium the current arc flow pattern is. On the other hand, if the convergence criterion concerns arc costs there is no need of such a second SNL.

Internal algorithms for equilibrium assignment with variable demand are an extension of those for assignment with constant demand. Given a feasible arc flow vector f
                        0 ∈ Sf
                         at 
                           k
                         = 0, MSA-FA is specified by the following recursive equations:

                           
                              
                                 
                                    {
                                    
                                       
                                          
                                             k
                                          
                                          
                                             =
                                          
                                          
                                             
                                                k
                                                +
                                                1
                                             
                                          
                                       
                                       
                                          
                                             
                                                
                                                   c
                                                
                                                k
                                             
                                          
                                          
                                             =
                                          
                                          
                                             
                                                c
                                                (
                                                
                                                   
                                                      f
                                                   
                                                   
                                                      k
                                                      −
                                                      1
                                                   
                                                
                                                )
                                             
                                          
                                       
                                       
                                          
                                             
                                                
                                                   f
                                                   ˜
                                                
                                                k
                                             
                                          
                                          
                                             =
                                          
                                          
                                             
                                                
                                                   
                                                      f
                                                   
                                                   VD
                                                
                                                
                                                   (
                                                   
                                                      
                                                         c
                                                      
                                                      k
                                                   
                                                   ;
                                                   d
                                                   )
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                                
                                                   f
                                                
                                                k
                                             
                                          
                                          
                                             =
                                          
                                          
                                             
                                                
                                                   
                                                      f
                                                   
                                                   
                                                      k
                                                      −
                                                      1
                                                   
                                                
                                                +
                                                
                                                   (
                                                   
                                                      
                                                         1
                                                         k
                                                      
                                                   
                                                   )
                                                
                                                ·
                                                
                                                   (
                                                   
                                                      
                                                         f
                                                         ˜
                                                      
                                                      k
                                                   
                                                   −
                                                   
                                                      
                                                         f
                                                      
                                                      
                                                         k
                                                         −
                                                         1
                                                      
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

On the other hand, given a feasible arc flow vector f
                        0 ∈ Sf
                         and the corresponding cost vector c
                        0 = 
                           c
                        (f
                        0) at k = 0, MSA-CA is specified by the following recursive equations:

                           
                              
                                 
                                    {
                                    
                                       
                                          
                                             k
                                          
                                          
                                             =
                                          
                                          
                                             
                                                k
                                                +
                                                1
                                             
                                          
                                       
                                       
                                          
                                             
                                                
                                                   f
                                                
                                                k
                                             
                                          
                                          
                                             =
                                          
                                          
                                             
                                                
                                                   
                                                      f
                                                   
                                                   VD
                                                
                                                
                                                   (
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         k
                                                         −
                                                         1
                                                      
                                                   
                                                   ;
                                                   d
                                                   )
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                                
                                                   c
                                                   ˜
                                                
                                                k
                                             
                                          
                                          
                                             =
                                          
                                          
                                             
                                                c
                                                (
                                                
                                                   
                                                      f
                                                   
                                                   
                                                      k
                                                      −
                                                      1
                                                   
                                                
                                                )
                                             
                                          
                                       
                                       
                                          
                                             
                                                
                                                   c
                                                
                                                k
                                             
                                          
                                          
                                             =
                                          
                                          
                                             
                                                
                                                   
                                                      c
                                                   
                                                   
                                                      k
                                                      −
                                                      1
                                                   
                                                
                                                +
                                                
                                                   (
                                                   
                                                      
                                                         1
                                                         k
                                                      
                                                   
                                                   )
                                                
                                                ·
                                                
                                                   (
                                                   
                                                      
                                                         c
                                                         ˜
                                                      
                                                      k
                                                   
                                                   −
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         k
                                                         −
                                                         1
                                                      
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

Considerations about convergence made for MSA-FA and MSA-CA with constant demand have explicitly been extended to (continuous and differentiable) separable demand functions d
                           i
                         = di
                        (si) only, assumed bounded and monotone non-decreasing (as guaranteed under mild assumptions, Cantarella, 1997). Even though no formal proof has been provided yet, generalization to demand function with symmetric Jacobian seems quite straightforward. Convergence tests already presented for constant demand may easily be adapted to the above algorithms.

External cycle algorithms solve a formulation of variable demand equilibrium assignment models in which the circular dependence between demand flows and costs is expressed externally to the flow-cost equilibrium. A two-level problem is defined, in which equilibrium between flows and costs is computed at the inner level for a given set of demand flows. The outer level computes equilibrium between the costs resulting from the inner level equilibrium assignment and demand flows obtained from demand functions. Operationally they are based on the iterative application of an algorithm for equilibrium assignment with constant demand and of the computation of the demand model. Given a feasible arc flow vector f
                        0 ∈ Sf
                         and c
                        0 = c(f
                        0) at k = 0 with s
                        0 = s(―B
                        T
                        c
                        0) and d
                        0 = (d(s
                        0)), a simple external algorithm, quite often used in practical applications, is specified by the following recursive equations:

                           
                              
                                 
                                    {
                                    
                                       
                                          
                                             
                                                k
                                                =
                                                k
                                                +
                                                1
                                             
                                          
                                       
                                       
                                          
                                             
                                                
                                                   
                                                      f
                                                   
                                                   CD
                                                
                                                
                                                   
                                                      
                                                         ;
                                                         EQ
                                                      
                                                   
                                                   k
                                                
                                                =
                                                φ
                                                
                                                   (
                                                   
                                                      
                                                         d
                                                      
                                                      
                                                         k
                                                         −
                                                         1
                                                      
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                                
                                                   
                                                      c
                                                   
                                                   k
                                                
                                                =
                                                c
                                                
                                                   (
                                                   
                                                      
                                                         f
                                                      
                                                      k
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                                
                                                   
                                                      s
                                                   
                                                   k
                                                
                                                =
                                                s
                                                
                                                   (
                                                   −
                                                   
                                                      
                                                         B
                                                      
                                                      T
                                                   
                                                   
                                                      
                                                         c
                                                      
                                                      0
                                                   
                                                   )
                                                
                                                ,
                                                
                                                
                                                   
                                                      d
                                                   
                                                   k
                                                
                                                =
                                                d
                                                
                                                   (
                                                   
                                                      
                                                         s
                                                      
                                                      k
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The above algorithm solves the system of Eqs. (2), (3), (5), (10) already introduced at the end of Section 3.2. Under the assumptions of existence and uniqueness, if an external algorithm converges to a solution, this solution is the equilibrium solution sought. Yet conditions for assuring convergence of external algorithms have not been completely analyzed. On the other hand, external algorithms are easily implemented starting from existing implementations for assignment with constant demand, and they can accommodate a wide variety of demand functions.

As introduced before, the main aim of this paper is to investigate the effectiveness of different algorithms to solve the variable demand stochastic equilibrium assignment problem. In this section the pursued conceptual framework is proposed. In particular, several main steps may be identified (Fig. 1
                     ).

                        
                           
                              [step 1] Preliminary analyses
                           

The aim of these analyses was twofold: (i) to carry out a comparison between external and internal approaches and a sensitivity analysis with respect to the travel demand model parameters (ii) to implement basic MSA-FA and MSA-CA formulations as benchmark for the successive steps.


                              [step 2] Restarting techniques
                           

The convergence speed of the MSA algorithm may be rather slow close to the solution because the step length gets increasingly smaller (1/k). Thus, two restarting techniques were tested in order to improve convergence speed, since any MSA algorithm gives the same weight to each encountered solution such an approach should be preferred to refresh the algorithm “memory” and to prevent that the step (1/k) becomes too small.

 In the first technique (R1 - step2a) the iteration index k restarts from 1 after a prefixed maximum number of iterations k
                              max; values of k
                              max in the range 10–30 are reported in literature, but it is better to calibrate this parameter for each application; anyhow values less than 5 should be avoided. This approach greatly improves the efficiency of MSA algorithms, as shown by several numerical examples, but asymptotic convergence can no longer be proved since finite long sequences are generated.

 In the second technique (R2 - step2b) each time the iteration index k reaches k
                              max, the value of k
                              max is increased, usually by 1, then the iteration index k is restarted from 1; this way both theoretical and implementation issues can be addressed, increasingly long sequence are generated, but the step (1/k) does not become too small before a practical convergence is reached.


                              [step 3] Convergence criterion
                           

Both basic MSA-FA and MSA-CA are usually implemented testing the convergence on arc flows against a given threshold ε:

                                 
                                    
                                       
                                          
                                             
                                                
                                                   |
                                                
                                                
                                                   
                                                      
                                                         f
                                                         ˜
                                                      
                                                   
                                                   k
                                                
                                                −
                                                
                                                   
                                                      f
                                                   
                                                   
                                                      k
                                                      −
                                                      1
                                                   
                                                
                                                
                                                   |
                                                
                                             
                                             
                                                
                                                   f
                                                
                                                
                                                   k
                                                   −
                                                   1
                                                
                                             
                                          
                                          <
                                          ɛ
                                       
                                    
                                 
                              where ̃f
                              
                                 k
                               = 
                                 f
                              (c
                              
                                 k
                              ; d), c
                              
                                 k
                               = 
                                 c
                              (f
                              
                                 k
                              
                              ―
                              1) for MSA-FA, and ̃f
                              
                                 k
                               = 
                                 f
                              (c̃
                              
                                 k
                              ; d), c̃
                              
                                 k
                               = 
                                 c
                              (f
                              
                                 k
                              
                              ―
                              1) for MSA-CA in the case of constant demand, and similarly for variable demand. This criterion measures the equilibrium error, says how much the equilibrium condition (8) or (9) are not satisfied. But when using MSA-CA the value ̃f
                              
                                 k
                               = 
                                 f
                              (c̃
                              
                                 k
                              ; d) has to be computed to run the test only, thus doubling the number of arc flow function computation to be carried out at each iteration, and greatly affecting the efficiency of MSA-CA algorithm. MSA-CA efficiency was improved implementing a convergence criterion with respect to arc costs that allows overcoming the need for an additional arc flow function computation:

                                 
                                    
                                       
                                          
                                             
                                                
                                                   |
                                                
                                                
                                                   
                                                      
                                                         c
                                                         ˜
                                                      
                                                   
                                                   k
                                                
                                                −
                                                
                                                   
                                                      c
                                                   
                                                   
                                                      k
                                                      −
                                                      1
                                                   
                                                
                                                
                                                   |
                                                
                                             
                                             
                                                
                                                   c
                                                
                                                
                                                   k
                                                   −
                                                   1
                                                
                                             
                                          
                                          <
                                          ɛ
                                       
                                    
                                 
                              where c̃
                              
                                 k
                               = 
                                 c
                              (f
                              
                                 k
                              
                              −
                              1) and f
                              k = 
                                 f
                              (c
                              
                                 k
                              
                              −
                              1; d), and the value c̃
                              
                                 k
                               is to be computed anyway to run the algorithm. This way convergence on arc flows and/or demand flows is still guaranteed, but the error cannot be controlled during the iterations. Indeed, convergence with respect to costs under a given threshold does not correspond to convergence with respect to flows under the same threshold, due the non-linear relation between costs and flows.


                              [step 4] Smoothing technique
                           

A technique to smooth the effect of (1/k) was tested both for MSA-FA and MSA-CA.

                                 
                                    
                                       
                                          
                                             
                                                f
                                             
                                             k
                                          
                                          =
                                          
                                             
                                                f
                                             
                                             
                                                k
                                                −
                                                1
                                             
                                          
                                          +
                                          δ
                                          
                                             (
                                             
                                                1
                                                k
                                             
                                             )
                                          
                                          ·
                                          
                                             (
                                             
                                                
                                                   
                                                      f
                                                      ˜
                                                   
                                                
                                                k
                                             
                                             −
                                             
                                                
                                                   f
                                                
                                                
                                                   k
                                                   −
                                                   1
                                                
                                             
                                             )
                                          
                                          
                                          δ
                                          ∈
                                          
                                             ]
                                             0
                                             ,
                                             1
                                             [
                                          
                                       
                                    
                                 
                              
                              
                                 
                                    
                                       
                                          
                                             
                                                c
                                             
                                             k
                                          
                                          =
                                          
                                             
                                                c
                                             
                                             
                                                k
                                                −
                                                1
                                             
                                          
                                          +
                                          δ
                                          
                                             (
                                             
                                                1
                                                k
                                             
                                             )
                                          
                                          ·
                                          
                                             (
                                             
                                                
                                                   
                                                      c
                                                      ˜
                                                   
                                                
                                                k
                                             
                                             −
                                             
                                                
                                                   c
                                                
                                                
                                                   k
                                                   −
                                                   1
                                                
                                             
                                             )
                                          
                                       
                                    
                                 
                              
                           

Value of parameters does not affect asymptotic convergence of the algorithms, but may effect practical convergence, say the number of required iterations to reach a given error.


                              [step 5] Sensitivity analysis
                           

Starting from the most performing algorithmic approaches, a sensitivity analysis with respect to arc cost function types was carried out. In particular, the incidence of non-separable arc cost functions was investigated. Sensitivity analysis was performed introducing a non-separable and asymmetrical cost function on an increasing number of links (11 percent, 33 percent, 66 percent, 100 percent) and testing algorithmic convergence (heuristically for MSA-FA) and algorithmic efficiency for both MSA-FA and MSA-CA.

In order to describe the convergence of the algorithms the following indicators were analyzed:

                        
                           •
                           number of stochastic network loading, says arc flow function computation, #SNL;

computational time, C.T.;

the average of the differences between arc flows obtained at iteration k, and the arc costs average at iteration k − 1, Δf = Σ
                                 a
                              |̃fa
                                 k
                               − fa
                                 k
                              
                              −
                              1|/fa
                                 k
                              
                              −
                              1;

the average of the differences between arc costs obtained at iteration k, and the arc costs average at iteration k − 1, Δc = Σ
                                 a
                              |c̃a
                                 k
                               − ca
                                 k
                              
                              −
                              1|/ca
                                 k
                              
                              −
                              1;

the average of difference between demand flows obtained at iteration k and those obtained at iteration k − 1: Δdom = Σod|dod
                                 k
                               − d
                              od
                              
                                 k
                              −1|/d
                              od
                              
                                 k
                              
                              −
                              1.

@&#RESULTS@&#

This section shows results of the application of fixed-point models and algorithms described earlier. As said, model and algorithms were implemented and applied with respect to two transportation systems: Salerno – (SA NET) and Benevento (BN NET) urban area (middle-size cities in Italy). The study areas were schematized, for simplicity's sake, in 12 traffic zones for Salerno and 10 traffic zones for Benevento, transportation supply was modeled through a congested network model for which separable and non-separable cost functions were investigated. In particular (Tables 1 and 2), the network graph for Salerno municipality consist in 144 origin-destination pairs, 101 links and 351 paths, while for the Benevento municipality the network graph consist in 100 origin-destination pairs, 46 links and 280 paths. For both networks where used both standard BPR and “not-separable” BPRNS cost functions. Finally, two transportation modes non interacting, car and bus, were considered.

Demand flows were modeled as a result of a three-stage model, including: trip production, trip distribution, mode choice (the hierarchy of demand models is shown in Tables 1 and 2). This suit of models provides demand flows to the path choice model. With respect to demand estimation, trip production from each traffic zone was assumed proportional to the population of the zone through a trip production index. Destination and mode choice behavior was modeled through Multinomial Logit models (MNL), each of them including in the systematic utility functions the satisfaction attribute (say the logsum). The parameters of the demand models (see Table 2) were estimated through the results of the model calibrations for these case studies reported in de Luca and Cartenì (2013), Bifulco et al. (2010) and Cantarella et al. (in press). Finally path choice behavior was modeled through a MNL model with explicit enumeration of all elementary paths between any OD pair. The last hypothesis, quite unusual in urban contexts, was justified by the small number of overlapping paths belonging to the choice set of each origin-destination pair.

These two different real-case networks were chosen because of their differences in network topology and demand characteristics. Even if the number of traffic zones is quite similar, the number of links are 120 percent greater for Salerno network while the number of paths are 26 percent greater for Salerno network (see Tables 1 and 2).
                     
                  

Furthermore, the demand characteristics of this urban areas are very different (see Table 3
                     ): in Salerno the 37 percent of the daily trips are by car (29,896 car trips in the morning peak–hour of the average business day) while for Benevento the daily car trips are the 52 percent of the total (17,507 car trips in the morning peak–hour). Also the demand structure (spatial distribution) is different. As reported in Figs. 2
                     and 3
                     , in the morning peak–hour, the Salerno urban area is characterized by many trips production and attraction zones with a longitudinal trips structure (trips from Est–Center–Ovest and vice versa). By contrast, the Benevento municipality is characterized by many trip production zones in the cordon of the city and few destination zones in the center (with a radial distribution of trips from cordon to center and vice versa). These differences in demand structure cause differences in road congestion; for Benevento network few roads are used by many cars, while for Salerno network the road utilization is more uniform and so the average weighed congestion index (link flow/link capacity) is 100 percent lower than for Benevento (0.4 against 0.8 as reported in Table 3).

Starting from these considerations it was investigated if these differences in network topology and demand structure could impact on assignment algorithms performances and/or on the sensitivity analysis related to the variations of the model parameters.


                        
                           
                              
                                 [step 1]: Preliminary analyses
                              

Stage 1 implemented MSA-FA and MSA-CA algorithms as they are introduced in Section 3.3 and as they are usually implemented in the most popular software packages. Convergence criterion was carried out on arc flows and was investigated up to a threshold of ε = 1.0E−4.

 For both networks, as showed in Table 4
                                 , results confirmed that MSA-CA is much slower than MSA-FA algorithm in terms of number of SNL and, proportionally, in terms of computational time. Both algorithms allowed to get to similar and satisfactory Δc indicator and Δdom indicators, at convergence.

 The comparison between internal and external approaches (Fig. 4
                                 ) showed that to reach convergence the external algorithms required more than 6 times the number of total SNL computations of the corresponding internal algorithms (874 vs. 110 for MSA-FA, or 1328 vs. 212 for MSA-CA). Moreover, it should be reminded that the external approach required about 27 iterations (origin-destination demand flows estimation) at the outer level, thus a further computational effort. As a result computational time for internal algorithms is always significantly smaller than those for external ones (8 times for MSA-FA – about 10 times for MSA-CA).

 Together with the previous analyses, a sensitivity analysis was carried out with respect different: (i) travel demand flows, (ii) trip distribution model parameters, (iii) mode choice model parameters, (iv) path choice model dispersion parameter.
                                    2
                                 
                                 
                                    2
                                    For the path choice model, though a Multinomial Logit (MNL) was adopted and only travel time was considered in the systematic utility specification, different dispersion parameter (scale parameter) θ  can be assumed. In fact, for MNL the error term is distributed as a Gumbel variable with mean equal to 0 and variance equal to σ2 =  π2θ2/6.
                                  Algorithms were compared with respect to the number of SNL computations.

 As concerns demand volume, the trip production index was increased for each origin zone and for each demand volume both internal and external algorithms were implemented (Fig. 5
                                 ). Results showed that, as expected, SNL computation number increased as the total demand increased. The increase rate was similar for those algorithms based on the external approach and for [MSA-CA]b, while [MSA-FA]b showed a negligible increase rate. Generally, for both networks, internal approach was always better than the external one.

 As regards trip distribution, as expected, the number of SNL increased as the parameter's value increased, with external algorithms showing a much greater rate. For both approaches, MSA-CA showed worse performance than MSA-FA (Fig. 6
                                 ).

 As regards mode choice Fig. 7
                                 shows the effect of increasing the parameter β of the logsum attribute (satisfaction). The larger the value of this parameter the smaller the car choice probability and the traffic congestion are. As expected efficiency improved for all the algorithms since the model became less sensitive to costs. If SNL computations for internal algorithms decreased with a smaller rate, external algorithms did not outperform internal ones even in contexts with low congestion. As regards internal approach, the differences between MSA-FA and MSA-CA, as reasonable, slightly decreased, but MSA-CA continued to show worse performances than MSA-FA. Furthermore, as reported in diagram on the right of Fig. 7, the Benevento networks is more “rigid” (lower changes in number of SNL computations against increases in parameter β value) with respect to the path choice logsum attribute because of the greater use of the car mode (the 52 percent of the total against the 32 percent for Salerno network).

 Regarding the path choice dispersion parameter, the efficiency of any algorithm is not affected but for very low values (Fig. 8
                                 ) that lead toward equal path choice probabilities, as it may be expected from random utility theory. External algorithms continued to show a much higher number of SNL.

 In conclusion, for both networks, the internal approach clearly outperformed the external one, both from the theoretical and the operational viewpoints. Moreover, it showed a greater robustness with regard to the total travel demand and with regard to travel demand model parameters. In conclusion, the external approach was not further investigated in the following sections. MSA-FA and MSA-CA algorithms implemented in this section and within the internal approach will be used as benchmark.


                                 [step 2]: Restarting techniques
                              

Technique 2 (R2). As introduced in Section 3.3 all MSA algorithms may be implemented refreshing the algorithm “memory” in order to prevent that the step (1/k) becomes too small. At this aim the iteration index k restarts from zero after a prefixed maximum number of iterations, k
                                 max1. Such an approach has been proposed in literature for assignment with constant demand only by. Values of k
                                 max1 in the range 10–30 are reported in literature, but it is better to calibrate this parameter for each application; anyhow values less than 5 should be avoided.

 Results of our application indicated that k
                                 max1 = 5 is the value assuring most efficient for Salerno network, whereas k
                                 max1 = 4 for Benevento network. For smaller k
                                 max1 values it can be observed the arc flows and demand flows values between two successive iterations are very similar, thus convergence time is much higher. For greater k
                                 max1 values the number of SNL iterations increases almost linearly for both algorithms, with higher gradient for MSA-CA.

 As regards algorithmic performance, results in Table 5
                                 point out that restarting technique R1 leads to a significant increase of algorithmic efficiency for both averaging approaches. Performances, for both networks, increased more than 200 percent, Δc and Δdom indicators further decreased.

 Comparing [MSA-FA]R1 and [MSA-CA]R1, cost averaging algorithm's convergence was slower than flow averaging and showed differences similar to those observed in step 1. As expected the numbers of SNL for CA algorithms were roughly two times those for FA algorithms, while the obtainable gain with respect to benchmark algorithms was greater for MSA-FA. Dc and Δdom indicators were similar for both averaging approaches.

 Finally, it is useful to stress that the same k
                                 max1 value ensured the best efficiency for both averaging approaches.

 Then, restarting technique R2 was implemented. As introduced in Section 4, it was assumed that the algorithm restarting threshold was not fixed, but it increased at each re-start. This approach leads to a series of phases, each characterized by an increasing maximum number of iterations, k
                                 max1 in the first phase and k
                                 max1 + k
                                 max2 in the successive. The problem consisted in the identification/calibration of two threshold, k
                                 max1 and k
                                 max2. Results for both networks showed that the most effective combination is with k
                                 max1 equal to 2 and k
                                 max2 equal to 1 (Table 6
                                 ).

 First of all, it should be noted that MSA-FA approach confirmed to be the most performing one. Compared to technique R1, restarting technique R2 allowed to further enhance MSA-FA performance, with a noticeable decrease of Δc and Δdom indicators. On the other hand, MSA-CA showed similar performances for both restarting techniques.

 In conclusion, technique R2 seems advisable for flow averaging scheme, for cost averaging scheme it does not lead to any significant gain.


                                 [step 3]: Convergence criterion on arc costs
                              

Since MSA-CA showed to be always slower than MSA-FA by a factor ca. 2, the effects of convergence criterion on arc costs – proposed in Section 4 – was investigated. All was implemented taking into account the results obtained in the previous steps (Table 7
                                 ).
                              

 Results showed that MSA-CA algorithm converged and, in particular, its efficiency significantly improved, by a factor 2 as expected. Comparing MSA-FA with MSA-CA, similar performances were observed both in terms of SNL number and of computational time. As expected, the introduction of convergence tests not based on arc flows increased MSA-CA efficiency.

 Because of the different convergence criteria, the two algorithms might lead to different assignment results in terms of arc flows, arc costs and origin-destination flows. In fact MSA-FA produces a sequence of arc flows which minimizes arc flows differences at each iteration, MSA-CA produces a sequence of arc flows which tries to reduce arc costs differences at each iteration.

 For this reasons results at convergence should be compared in terms of arc flows (Δf), arc costs (Δc) and origin-destination demand flows (Δdom). In particular, MSA-FA at convergence led to Dc indicators similar to the threshold chosen as convergence criterion for MSA-CA. As regards origin-destination flows, for both networks, the error between two successive iterations was smaller than 1 percent.

At this stage MSA-CA and MSA-FA are equivalent.


                                 [step 4]: Smoothing techniques results
                              

Starting from the previous results, a smoothing technique was tested for both algorithms and different values for the smoothing parameter were investigated.

 Results (see Table 8) pointed out that the smoothing technique with parameter δ smaller than 1 led to further improvements for both algorithms. It is interesting to note that the best results can be obtained with parameter equal to 0.8 for Salerno network and equal to 0.7 for Benevento network, and that smoothing allowed the MSA-CA averaging scheme to outperform MSA-FA scheme and to sensibly improve performances with respect to [MSA-CA]R1,c-test.


                                 [step 5]: Algorithm's sensitivity
                              

Non separable and asymmetrical cost functions may lead to several theoretical problems in term of algorithm's convergence for MSA-FA, but not for MSA-CA algorithm, whose convergence may be proved even for asymmetrical and non-separable arc cost function. Since previous results allowed to conclude that MSA-CA algorithm efficiency is comparable to MSA-FA if restarting techniques are combined together with the smoothing technique, from an operational point of view it is interesting to investigate how algorithm performances may be affected by the introduction of non-separable cost functions. The analysis was carried both for MSA-FA and MSA-CA algorithms. MSA-FA was investigated, although no formal proof exists, since it usually converges in all the application in which it has been used.

 Applying the non-separable and asymmetric cost function introduced in Section 5.1, different simulations were carried out increasing the percentage links with asymmetric cost functions: 11 percent, 33 percent, 66 percent an 100 percent. Results for both algorithms are proposed in Table 9
                                 .
                              

 In general, it is interesting to note that non separable and asymmetric cost functions did not significantly affect algorithms performance. For small number of links non-significant differences can be observed with respect to comments proposed in the previous steps. As the percentage increases, algorithm performances, as expected, decreased. In fact the number of SNL doubled with 100 percent of links. However, the performances of the two averaging schemes were closed.

This paper describes a general fixed-point modeling framework to cope with assignment with variable demand, which includes both internal and external approaches. Major findings concern results of the comparison between internal and external approaches and between different specifications of MSA based algorithms.

Two different real-case studies were tested with differences both in network topology and in demand characteristics. This was made to investigate if these differences in network topology and demand structure could impact on assignment algorithms performances and/or on the sensitivity analysis related to the variations of the model parameters. No significant differences were observed with respect the two network.

As regards internal and external approaches, internal algorithms outperformed external ones, with respect to the computing time, besides the theoretical point of view. Moreover the internal approach algorithms convergence is less influenced by total travel demand and by the travel demand model parameters. On the other hand the external approach efficiency may be significantly affected by the travel demand models and by the estimated parameters. Anyhow, sensitivity analysis supported further theoretical considerations that the less stochastic the path choice behavior model the less performing any solution algorithm is.

As regards MSA algorithms (Fig. 9), traditional averaging schemes were largely outperformed by the use of restarting techniques (steps 2a and 2b). In fact, the number of SNL iterations (thus the computational time) for both averaging schemes significantly decreased of about 6 times. Between the two proposed restarting techniques, the technique R2 enhanced MSA-FA algorithm's performance only.

Although the significant decrease of computational time for both MSA-FA and MSA-CA, MSA-FA algorithm continued to outperform MSA-CA. Such a difference is clearly due to the convergence criterion, in fact significant enhancement were obtained introducing a convergence criterion based on arc costs for MSA-CA algorithm (step 3). In this case, MSA-FA and MSA-CA efficiency become comparable in terms of SNL computation and in terms of arc flows error and origin-destination flows errors.

If the differences hitherto observed were always in favor of MSA-FA, yet the combination of restarting and smoothing techniques (step 4) led to a further decrease of number SNL computations for both averaging schemes, moreover, and for the first time, MSA-CA formulation outperformed MSA-FA. This result is noteworthy since MSA-CA guarantee asymptotic convergence for asymmetric equilibrium also, thus it becomes a robust solution both from a theoretical and operational viewpoints.

Finally, the asymmetric equilibrium problem was addressed investigating the effect of an increasing number of arc with non-separable and asymmetric cost functions. The main result was that that non separable and asymmetric cost functions did not significantly affect algorithms performance. As the number of links with asymmetric cost functions increased, algorithms’ performances slightly decreased but the two averaging schemes showed comparable computational time. In this case, MSA-CA with convergence criterion on costs, restarting and smoothing, seems the most efficient from both theoretical and operational points of view.

Several open issues, already quoted in the paper, will be addressed in a future paper, such as: algorithms which avoid explicit path enumeration; effects of other demand and/or path choice models; application of averaging to demand cycle within external algorithms; convergence criteria based on demand flows. A comparison with VI modeling approach seems also worth of further research effort.

@&#ACKNOWLEDGMENTS@&#

This work was partially supported under PRIN 2009 national grant PRIN 2009, UNISA local grants no. ORSA107325 financial year 2010, and no. 127028 financial year 2012.

@&#REFERENCES@&#

