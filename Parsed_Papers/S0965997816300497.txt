@&#MAIN-TITLE@&#Approximation of large data from the finite element analysis allowing fast post-processing

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Efficient methods to visualize the results from finite element analysis and imple-mentation of these methods in post-processing results are described.


                        
                        
                           
                           The stored data from finite element analysis are replaced by continuous functions suitable for representation in computer graphics.


                        
                        
                           
                           Approximation of data in space and also the approximation in time is used.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Finite element method

Finite element mesh

Visualization

Approximation

Multigrid

Post-processor

@&#ABSTRACT@&#


               
               
                  The article describes efficient methods to visualize the results from finite element analysis and implementation of these methods in post-processing results. The work is based on premise that computer memory and performance are limited and amount of data processed by complex finite element analysis is enormous. Therefore, some kind of simplification and approximation of resulting data has to be used. Multigrid method was the inspiration for research work and development of post-processor.
                  The stored data from finite element analysis are discrete values. The paper deals with several ways of replacing them by continuous functions suitable for representation in computer graphics, which are different from the approximation functions used in finite element method. Special attention is devoted to approximation errors – difference between these functions. Finite element mesh is decomposed into subdomains with respect to approximation errors. The ways of creating mesh hierarchy are described in details and also the possibilities of nodal value interpolations in simplified mesh are discussed in the text.
                  Besides the approximation of data in space, also the approximation in time is used. Pseudo-code of the approximation algorithm key parts is shown. Various types of approximation functions were investigated to reach the lowest approximation error and the highest compression factor. Results are summarized in the article.
               
            

@&#INTRODUCTION@&#

Numerical methods, such as the finite element method (FEM), the finite difference method, the finite volume method and others, used in scientific and engineering problems, generate huge amount of data in the form of numbers in output files. Such output is not suitable for humans because too many numbers are getting immeasurable. It is necessary to represent the output in a graphic form. The graphic representation of output data from numerical methods is partially similar to the classical computer graphics but there are also significant differences. In the case of output file with the size more than approximately one gigabyte, the graphic representation generates large demands on the computer memory and time.

Extremely large output files are not created artificially. As an example can serve analysis of reactor vessels in nuclear power plants which is used in the process of prolongation of their service life. The vessels are approximately 40 years old and detailed thermo-hydro-mechanical analysis has to be performed. Usually, two-dimensional axisymmetric or fully three-dimensional models are considered and it means hundreds of thousands degrees of freedom are used. The number of time steps is between 10,000 and 15,000. The output files contain displacements, strain and stress components, temperature, relative humidity (or moisture content) and several internal parameters (e.g. creep strains, damage parameter, etc.) in all time steps. The output files with size in the order of gigabytes are generated. More details can be found in [1,2].

This work is based on premise, that computer memory and performance are limited. Without some kind of simplification and compression no program can efficiently process large amount of data generated by extensive finite element analysis. Data structures used for representation of large finite element meshes are described in [3]. Some techniques for compression of polygonal meshes can be found in [4,5]. However, these methods are not suitable for handling the results from the finite element analysis.

The multigrid method [6–9] was the inspiration for this work. Multigrid method allows to solve partial differential equations using the hierarchy of domain discretizations. The main idea of multigrid method is to make the convergence of iterative method faster due to global corrections of error that is made from time to time on the coarser mesh. There are many variations of multigrid method. However, all of them need existence of mesh hierarchy that represents domain discretizations of different mesh sizes.

Basic steps of multigrid method are:

                        
                           •
                           
                              Smoothing – The main goal of the smoothing phase is the high-frequency error reduction. It can be done e.g. by few iterations of the Gauss-Seidel method.


                              Restriction – Restriction of the residual from the finer to the coarser mesh.

Solution of the coarse problem.


                              Prolongation – Interpolation and projection of the correction computed on the coarser mesh to the finer mesh.

The main problem with a mesh hierarchy is that often none is available. Only the finest mesh exists. The coarser meshes must be either generated directly by a mesh generator [10,11] in the pre-processing phase or it must be created from the finer mesh. But generating coarser mesh from the finer one is very problematic or even impossible, because corresponding nodes between different levels should be preserved to be sure that multigrid method will work correctly without special modifications.

Therefore, it was decided to do visualization of the results from the finite element analysis on the fine mesh that is used for solution of FEM. Different methods of simplification and compression of the resulting data in space and time were developed and data were projected back to fine mesh. Results of the projection and comparison of methods are presented in this paper.

@&#IMPLEMENTATION@&#

Even if the mesh hierarchy is generated, one of the obstacles for using the same multigrid techniques as are often used in the finite element analysis is that only one mesh hierarchy is available. That is sufficient for finite element solver, because this hierarchy is used to solve only one set of equations. However, in the post-processor it is necessary to display various kinds of data, such as temperature, displacements, stress, strain, etc. These quantities are scalars, vectors or tensors of second order. Components of vectors and tensors could be considered in post-processing as a scalar and therefore scalars will be dealt in the following text. Every scalar is represented in the finite element analysis by a set of discrete values computed in nodes or Gauss points, but in the strong formulation of a problem, it is a function. For graphical purposes, it is possible and often suitable to replace the set of discrete values by a continuous function. In the following text, the set of discrete values describing a scalar will be denoted as the discrete function or original function, but approximation of the discrete values for graphical purposes by continuous function will be called approximation function (shape functions used in FEM are not used here).

Approximation functions should be as simple as possible to be representable by a small set of parameters. Therefore, the domain of approximation function should respect the character of the discrete function. It can't be the whole mesh, because one part of mesh could contain data replaceable by a simple linear function and other part could have much wilder character. It is therefore necessary to find alternative division of problem domain that will respect the shape of function in space and time better than the mesh hierarchy used in the multigrid method. Moreover, each quantity component must have its separately generated mesh hierarchy.

Domain space has to be divided into subdomains of the size which allows to replace discrete function with continuous, simpler, e.g. linear function that is easy to describe by fewer parameters. The goal is to automatically recognize areas in mesh, where the nature of function is smooth (the function is continuous together with the first derivatives and very coarse mesh can be used) and areas in which function rapidly changes its character (the first derivatives are large or the function is even discontinuous). These areas of interest become object of further subdivision, because for visualization purposes they need finer underlying mesh. For recursive division of 3D space the octree data structure is suitable (see Fig. 1
                        ). The other spatial dividing data structures used in computer graphics were investigated, but octree seemed to be the best choice due to its hierarchical form and low average depth.

Basic overview of the decomposition and approximation procedure is in Algorithm 1
                        . At first whole mesh is inserted into one big cube – octree root node. Then a condition that tells whether to divide current domain into eight subdomains is needed. Three conditions were designed. All have to be satisfied to proceed with decomposition.

                           
                              1.
                              First condition specifies minimum number of finite element nodes to be represented by single octree cell. There are two reasons. Firstly, some specification of minimum number is necessary to compute approximation function, e.g. least square trilinear algorithm needs at least 8 values. Secondly, if the number is too small and the approximation function does not fit ideally, subdivision of the octree will be too subtle and memory consumption will easily exceed the case with no approximation applied at all.

Second condition is based on maximal allowed relative error of chosen approximation function. Algorithm that replaces discrete data points with continuous approximation function also calculates relative error of the method. This number is then compared with some preset fixed value. According to the experiment results the most appropriate value of 1% was chosen.

Third condition describes maximum depth of octal tree. Each level of the tree exponentially increases memory consumption of data values stored in octree. Maximum depth is therefore artificially set to some acceptable value, e.g. 9. However, this depth should not be reached in common cases, it is ensured by condition 1.

If all conditions are met, domain represented by current octree node is divided into eight subdomains. Differences between original value of discrete function and value of approximation function in the same point are transferred to corresponding sub-nodes based on their location and whole process is recursively repeated in all octree sub-nodes. The difference Di
                         of the ith data value is defined by

                           
                              (1)
                              
                                 
                                    
                                       D
                                       i
                                    
                                    =
                                    
                                       V
                                       i
                                    
                                    −
                                    
                                       
                                          V
                                          ¯
                                       
                                       i
                                    
                                    ,
                                 
                              
                           
                        where Vi
                         is the original function value in the ith node and 
                           
                              
                                 V
                                 ¯
                              
                              i
                           
                         is the value of approximation function in the same location as the ith node.

Similar procedure – passing residuals between mesh levels – is applied in the multigrid method. Due to this approach the top levels of octree filter out main character of function (lower frequencies), bottom levels and leaves of the octree catch higher frequencies of function values.

Discrete values within an octree cell are replaced by a continuous function which is as simple as possible and can be represented in memory by a few parameters. It is therefore necessary to find suitable type of function and in the case of polynomial functions also the order of the function. Compression algorithm has to be very fast. Compromise between low error and memory consumption must be found. For the sake of simplicity at the beginning of the work the relations between neighboring octree nodes were neglected. Nodal values in each octree cell are approximated separately.

The compression procedure requires the surface representation of the mesh to be already created. The element connectivity and nodal coordinates has to be present in memory and accessible in constant O(1) time. Efficient methods to create this surface representation are described in [3].

The procedure is reading the FEM results divided to data sets from the external file and then processing the data sets one by one. By a data set is meant primarily the array of floating-point numbers corresponding to one component of one quantity, e.g. x component of displacement vector, temperature (which is scalar) or one component of stress tensor. Each floating-point number is the value of the quantity in single time step corresponding to one node or gauss-point. Whole array is loaded from file into computer memory, its values are distributed into growing octree and the approximation is calculated and saved in corresponding octree cells. After that the original data are deleted and algorithm continues with the next data component.

Compression has to be made on-the-fly during loading of data from the file to the memory between each data component. Starting compression after all results has been loaded to the memory would not make sense, because the main purpose of the compression step is to save overall memory consumption of the post-processor. Therefore, the format of data should ideally be designed in the way that each data component is separated in single data file or at least in one isolated data block in the file not mixed with other data. No particular order of data components is required. However, data formats used by common finite element software packages are usually designed in the way that the components of each quantity are grouped together. We rely mainly on GiD postprocess file format (.res) described in detail in [12] where data are divided to blocks according to physical quantity and time step. Each block is the list of value tuples introduced by a node number (or element number in case of values in gauss-points), e.g. X, Y and Z component triplet for displacement vector in node 42 in time step 3.0. To avoid multiple passes through the data file the value tuples are cached and processed right after reading the whole data block.

After loading a data block, compression is started. Algorithm 1 contains pseudo-code of recursive procedure that is the core of the compression algorithm. Fig. 2
                         contains overview of this algorithm in form of UML Activity diagram. The input is an array of nodal values in one component of one field defined on the mesh in single time step. In case of data stored in gauss-points the values has to be at first extrapolated to nodes using natural coordinates supplied in the data file. Nodal data are then passed as an input parameter dataValues to the function InsertDataValues that is called upon the octree root node which represents one big cube that surrounds the whole mesh. Each dataValue object is a structure consisting of floating-point number Value and integer NodeId that represents a key to the table of nodes in global mesh object. InsertDataValues is pure virtual function declared in abstract base class OctreeNode and its implementation differs in derived classes. Its implementation in OctreeLeafNode is straightforward and so follows description of its implementation in class OctreeInternalNode. Simplified class diagram of the key types involved in Algorithm 1 is shown in Fig. 3.
                        
                     

At first the algorithm computes parameters of continuous approximation function of discrete data values provided (variable approximation). In case of trilinear interpolation it uses least square method to calculate 8 parameters of a polynomial regression model and stores them in DataCatalog table which is a property of each octree node. Then the maximal relative approximation error is computed.

Approximation function for data values in the octree cell is assessed with the help of several metrics. First, absolute approximation error, which is the difference between the original nodal value and the value of approximation function, is evaluated in all nodes. Then, relative approximation error is obtained by dividing the absolute approximation error by global range of values (difference between global maximum and global minimum of original nodal values). The maximum relative approximation error in an octree cell is one of three parameters (see condition 2 above) that are used by the algorithm to decide whether to proceed with further subdivision of the octree cell. These three parameters control the overall quality of approximation, memory consumption and performance and need to be fine-tuned during testing on real-world data.

If the maximal approximation error is too high, the algorithm continues, calculates approximation error in each node and stores it in table residuals in relevant octant according to its position in current octree cell. residuals is a table of data value arrays and it is a local variable that will be disposed after each call to function InsertDataValues finishes. Algorithm then iterates over all child octants and checks for number of residuals assigned to them. If condition 1 stated above holds, algorithm is recursively called upon each child octree cell. If the octree cell is a leaf node, recursion is stopped and algorithm determines whether it should split current leaf octree cell into 8 sub-segments by checking conditions 2 and 3. In other words, if the current octree branch is not deep enough and maximal residual belonging to current child octree cell is higher than designated epsilon value, then this leaf cell is replaced with internal cell and function InsertDataValues is called upon this new OctreeInternalNode object. Residuals located in current octant are passed as an input to this function.

This continues until approximation of current data component is good enough in all octree cells. When the algorithm finishes, original discrete data can be deleted, because the created octree structure with approximation functions in its nodes is all that is needed to reconstruct the original data. Then the algorithm can proceed with reading and processing next data set. Note that these operations are to a considerable extent independent and processing of data sets can be parallelized. However, if the same octree data structure is reused for multiple data sets, then the access to DataCatalog and octree node expansion has to be synchronized using standard locking mechanisms.

Also note that passing residuals of approximation instead of original data between octree levels is important, because it allows to describe the main character of function (lower frequencies) on top levels and details (high-frequency changes) on bottom levels of the octree. This design is inspired by the Multigrid method basic principles.

Various approximation functions were investigated and tested. Besides polynomial functions also Discrete cosine transform [13] and Wavelet transform [14] were considered. Since the data compression algorithm has to be very fast, simple polynomial approximation functions were preferred. They are summarized below:

                              
                                 •
                                 
                                    Mean value – A single value (average value) replaces the set of discrete values. Arithmetic mean was used during testing because it is fast to compute unlike the median. Also, it takes into account whole spectrum of values in contrast of the mode value that is the value that occurs most often in the collection. It is suitable in statistics where the measurement errors have to be excluded. However, in the case of the results from the FEM the user wants to see extremes in data and these outlying results should be rather highlighted instead of truncated. That is the reason why is neither the arithmetic mean nor other statistically estimated mean value suitable for this purpose. Mean value approximation diagram is depicted in Fig. 4.
                                    
                                 


                                    Regression – Finds a polynomial that models relationship between a scalar dependent variable and one or more explanatory (independent) variables. In three-dimensional problem there are 3 independent variables. Polynomial regression models are often fitted using the least squares method. The implementation used in this work is based on solving linear system of equations using LU decomposition. Key thing is that the size of the system does not depend on the number of data values, but on the number of approximation function parameters. Therefore, the algorithm has linear computational complexity and scales well. Several polynomials were tested. In the functions below x, y, z are spatial coordinates, ci
                                     are parameters which determine the shape of the polynomial and v is the function value.
                                       
                                          ○
                                          
                                             Linear – Hyperplane, only 4 parameters per octree cell. Value v in the point with coordinates x, y, z is computed using linear interpolation function in the form
                                                
                                                   (2)
                                                   
                                                      
                                                         v
                                                         =
                                                         
                                                            c
                                                            1
                                                         
                                                         x
                                                         +
                                                         
                                                            c
                                                            2
                                                         
                                                         y
                                                         +
                                                         
                                                            c
                                                            3
                                                         
                                                         z
                                                         +
                                                         
                                                            c
                                                            4
                                                         
                                                         .
                                                      
                                                   
                                                
                                             
                                          


                                             Fig. 5
                                              contains example of creation of octree node hierarchy driven by this function.


                                             Quadratic – Parametric shape models known as Hyperquadrics. They have too many parameters per cell (10) and are not suitable to capture continuity between octree cells. Value v in the point with coordinates x, y, z is computed using quadratic interpolation function in the form
                                                
                                                   (3)
                                                   
                                                      
                                                         
                                                            
                                                               v
                                                            
                                                            
                                                               =
                                                            
                                                            
                                                               
                                                                  
                                                                     c
                                                                     1
                                                                  
                                                                  
                                                                     
                                                                        x
                                                                     
                                                                     2
                                                                  
                                                                  +
                                                                  
                                                                     c
                                                                     2
                                                                  
                                                                  
                                                                     
                                                                        y
                                                                     
                                                                     2
                                                                  
                                                                  +
                                                                  
                                                                     c
                                                                     3
                                                                  
                                                                  
                                                                     
                                                                        z
                                                                     
                                                                     2
                                                                  
                                                                  +
                                                                  
                                                                  
                                                                     c
                                                                     4
                                                                  
                                                                  
                                                                     x
                                                                     y
                                                                  
                                                                  +
                                                                  
                                                                     c
                                                                     5
                                                                  
                                                                  
                                                                     x
                                                                     z
                                                                  
                                                                  +
                                                                  
                                                                     c
                                                                     6
                                                                  
                                                                  
                                                                     y
                                                                     z
                                                                  
                                                               
                                                            
                                                         
                                                         
                                                            
                                                            
                                                            
                                                               
                                                                  +
                                                                  
                                                                  
                                                                     c
                                                                     7
                                                                  
                                                                  x
                                                                  +
                                                                  
                                                                     c
                                                                     8
                                                                  
                                                                  y
                                                                  +
                                                                  
                                                                     c
                                                                     9
                                                                  
                                                                  z
                                                                  +
                                                                  
                                                                     c
                                                                     10
                                                                  
                                                                  .
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          


                                             Trilinear – 8 parameters, the best compromise, consistent with neighboring octree cells, almost “seamless” transitions between octree cells. Also used in the FEM.

Value v in the point with coordinate x, y, z is computed using trilinear interpolation function in the form
                                                
                                                   (4)
                                                   
                                                      
                                                         v
                                                         =
                                                         
                                                            c
                                                            1
                                                         
                                                         
                                                            x
                                                            y
                                                            z
                                                         
                                                         +
                                                         
                                                            c
                                                            2
                                                         
                                                         
                                                            x
                                                            y
                                                         
                                                         +
                                                         
                                                            c
                                                            3
                                                         
                                                         
                                                            x
                                                            z
                                                         
                                                         +
                                                         
                                                            c
                                                            4
                                                         
                                                         
                                                            y
                                                            z
                                                         
                                                         +
                                                         
                                                            c
                                                            5
                                                         
                                                         x
                                                         +
                                                         
                                                            c
                                                            6
                                                         
                                                         y
                                                         +
                                                         
                                                            c
                                                            7
                                                         
                                                         z
                                                         +
                                                         
                                                            c
                                                            8
                                                         
                                                         .
                                                      
                                                   
                                                
                                             
                                          

The least squares method is applied to find parameters 
                                                
                                                   
                                                      c
                                                      1
                                                   
                                                   ,
                                                   …
                                                   ,
                                                   
                                                   
                                                      c
                                                      8
                                                   
                                                
                                             . The problem is solved by minimizing the sum of squared residuals G of the linear regression model
                                                
                                                   (5)
                                                   
                                                      
                                                         
                                                            
                                                               G
                                                            
                                                            
                                                               =
                                                            
                                                            
                                                               
                                                                  
                                                                     ∑
                                                                     
                                                                        i
                                                                        =
                                                                        1
                                                                     
                                                                     N
                                                                  
                                                                  
                                                                     (
                                                                     
                                                                        v
                                                                        i
                                                                     
                                                                     −
                                                                     (
                                                                  
                                                                  
                                                                     c
                                                                     1
                                                                  
                                                                  
                                                                     x
                                                                     i
                                                                  
                                                                  
                                                                     y
                                                                     i
                                                                  
                                                                  
                                                                     z
                                                                     i
                                                                  
                                                                  +
                                                                  
                                                                     c
                                                                     2
                                                                  
                                                                  
                                                                     x
                                                                     i
                                                                  
                                                                  
                                                                     y
                                                                     i
                                                                  
                                                                  +
                                                                  
                                                                     c
                                                                     3
                                                                  
                                                                  
                                                                     x
                                                                     i
                                                                  
                                                                  
                                                                     z
                                                                     i
                                                                  
                                                                  +
                                                                  
                                                                     c
                                                                     4
                                                                  
                                                                  
                                                                     y
                                                                     i
                                                                  
                                                                  
                                                                     z
                                                                     i
                                                                  
                                                               
                                                            
                                                         
                                                         
                                                            
                                                            
                                                            
                                                               
                                                                  +
                                                                  
                                                                  
                                                                     c
                                                                     5
                                                                  
                                                                  
                                                                     x
                                                                     i
                                                                  
                                                                  +
                                                                  
                                                                     c
                                                                     6
                                                                  
                                                                  
                                                                     y
                                                                     i
                                                                  
                                                                  +
                                                                  
                                                                     c
                                                                     7
                                                                  
                                                                  
                                                                     z
                                                                     i
                                                                  
                                                                  +
                                                                  
                                                                     c
                                                                     8
                                                                  
                                                                  
                                                                     
                                                                        )
                                                                        )
                                                                     
                                                                     2
                                                                  
                                                                  ,
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             where N is number of values which are interpolated. When the parameters of interpolation are known, value in any point of the approximated volume can be found simply by providing x, y and z coordinates of the point in the equation.


                                             Tri-quadratic – Too many describing parameters with no significant benefit over trilinear form.


                                             
                                                Quadrilinear form
                                              – Generalized trilinear form, extended by temporal dimension, only theoretical option, not implemented.


                           Fig. 6
                            depicts computation of nodal value via traversing octree from the root to the leaves and simultaneously summing up approximation errors. Root node of the octree contains all data components in all time steps where data value of an arbitrary element node can be computed. If an approximation is not sufficiently accurate in current octree node, correction can be made with the help of data stored in lower levels of the octree and summing up corrections together with initial value to compute final value for the node.

@&#RESULTS@&#

The benchmark is designed to compare maximal relative approximation error, average error and compression ratio when using different approximation methods. Two test data sets were chosen (Figs. 7
                            and 8
                           ), both contain displacement vector values with three components (u, v and w) and about 30 time steps. Maximal relative approximation error is the highest relative error of an approximation method in single element node across all data components and time steps. Average error is a weighted sum of approximation errors in all nodes and data components divided by the number of these approximations. Compression ratio is memory consumption of the proposed data representation divided by memory consumption of original post-processor that does not use any data approximation techniques. Results are summarized in Tables 1
                            and 2
                           . The mesh topology and result data sets that were used in this benchmark can be found at [15]. These files can be opened for reference in program GiD.


                           Fig. 9
                            contains visualization of the exact data values whereas Figs. 10
                            and 11
                            contains visualization of approximation of the same data series but for different types of approximation functions to highlight the imperfections of the approximation algorithm. The red lines represent the octree cells.

To reproduce these results the mesh definition files and files with results can be downloaded from [15]. The exact data values (without approximation) can be then visualized using software GiD. Visualization of approximated results can be constructed by the procedure that is described in chapter 3.2. The octree can be generated by application of the Algorithm 1 using following free parameters: Minimum number of data points per octree cell is 8 (MIN_LEAF_DATA_POINTS_COUNT) which is equal to minimum number of points necessary to apply trilinear interpolation. Minimum allowed relative approximation error is set at 1% (MIN_RELATIVE_ERROR_TO_EXPAND). Maximum depth of the octree is 9 (MAX_OCTREE_DEPTH). Trilinear approximation function parameters are calculated using standard least squares method.

Additional data compression can be gained by focusing on temporal dimension of function values. Memory allocation can be lowered by eliminating unimportant time steps. To achieve that, it is necessary to find those time steps, in which function values are steady or are changing linearly and can be therefore interpolated from other time steps.


                        Fig. 12
                         illustrates the idea of interpolation in time. Intermediate time steps can be interpolated from the key time steps if they have similar shape – they are nearly linear combinations of each other and therefore data in redundant time steps can be disposed. The decision whether to dispose time step or not is based on difference of two functions compared to experimentally designated threshold value. Mathematical background of this procedure is described later in this section.

Several options to store temporal data were considered.

                           
                              •
                              Sequence of octrees. Each one for single time step.

4D tree. Extension of octal tree on temporal dimension. Each internal node has 16 children.

Single ordinary octree containing data approximations with time component. Extending the approximation functions by temporal dimension, e.g. quadrilinear form instead of trilinear form.

Combination of octree for spatial decomposition and binary tree for temporal dimension division.

Octree for each time frame of an animation is memory inefficient as well as 4D tree [16]. 4D approximation functions have many parameters and also can't capture intricate evolution of function in time. Therefore, different solution was suggested – single octree representing spatial decomposition that is formed by merging sequence of octrees from all time steps. However, the sequence of octrees is just a virtual term. Algorithm 1 treats all data component from all time steps the same and when it finishes its job, only single octree is left with data approximation object for various data component and time steps stored in data catalog in each octree node independent to each other. By merging it is meant the unifying all time steps of a single data component in each octree node into single data sequence object that can be then a subject of the time compression algorithm. This process of merging virtual octrees for each time step into single “time-tree” is illustrated in Fig. 13
                        . Notice that the octree for each time step can have different structure and depth, because in each time step the original function can have different frequency spectrum for which the different sampling rate is needed.

However, not all approximation functions are preserved during merging. Each octree cell contains list of approximation functions only for key time steps, that are necessary to cover time development of discrete function in area represented by the octree cell. These key (or fixed) time steps are either specified by the user or identified automatically by the Algorithm 2
                        .

Original nodal value retrieving is the same octree traversal as was depicted in Fig. 6 except for the final phase – calculating value from approximation function in leaf octree nodes. If desired time instant is not present, then it must be interpolated from the key time steps. To find concrete time instant in the list of approximation functions the fast binary search algorithm is used.

Temporal-data-containing-octree is created by algorithm that works with already created octree having approximation functions for all time steps. At first it finds time steps that must be preserved. Those can be explicitly picked by the user or the algorithm itself determines automatically the first and the last time step as key times. Then the program traverses steps between key events of time interval. In each time step the algorithm iterates over space approximations for each loaded quantities and computes difference between each function and function created by interpolation of functions in key intervals. If this difference is lower than some preset fixed value, approximation function in current time step can be disposed because it can be created on demand in the future. Otherwise time interval is divided in current step and algorithm is recursively called on each of both intervals. It is therefore similar algorithm to approximation in space, but instead of octree a binary tree is used because there is only one temporal dimension instead of three spatial dimensions. Pseudo-code of approximation in time is shown in Algorithm 2.

In the case of approximation in time, we have two continuous functions that we want to compare to each other. First function is approximation function for the time step that can be potentially removed. This function is already created by spatial approximation algorithm described above. Second function is computed ad-hoc from key time steps to test if it can potentially replace the first function later. If the test succeeds (functions are similar enough) the first function can be removed entirely from octree data structure, because it can be computed from the functions in neighboring time steps.

The process of computing intermediate function from the key time steps is quite straightforward. With regard to the fact that all approximation functions have to be of the same polynomial type, each parameter of the interpolated function can be then computed as interpolation of the related parameters in two boundary functions in key time steps.

Approximation in time is made for each spatial octree node separately instead of globally for the whole mesh, because the quantity can change in time only in some parts of the mesh and in others can be constant.

The algorithm for approximation in time has to compare two continuous approximation functions to determine their similarity.

The difference d of two continuous square-integrable functions u and v is considered as scalar value computed as

                              
                                 (6)
                                 
                                    
                                       d
                                       =
                                       
                                          
                                             
                                                ∫
                                                Ω
                                             
                                             
                                                
                                                   
                                                      (
                                                      
                                                         u
                                                         −
                                                         v
                                                      
                                                      )
                                                   
                                                
                                                2
                                             
                                             
                                                d
                                                Ω
                                             
                                          
                                       
                                       .
                                    
                                 
                              
                           
                        

H0 norm is used because there are not first and higher derivatives in the output files. It will be difficult to obtain derivatives from discrete nodal values. Moreover, discrete values are approximated by polynomials such as trilinear functions which are continuous and they are smooth almost everywhere. For the graphical purposes, small differences between output data and the approximation functions are sufficient. In the case of sharply varying output data, even H0 norm reveals this fact and the approximation cannot be used and no compression is possible.

To decide if two functions are similar the relative difference has to be calculated and compared to some threshold value ɛ. Relative difference can be obtained by dividing function difference d by the norm of the original function u (v is the approximation function) in the form

                              
                                 (7)
                                 
                                    
                                       u
                                       =
                                       
                                          
                                             
                                                ∫
                                                Ω
                                             
                                             
                                                
                                                   u
                                                
                                                2
                                             
                                             
                                                d
                                                Ω
                                             
                                          
                                       
                                       .
                                    
                                 
                              
                           
                        

If u ≠ 0 relative difference 
                              
                                 d
                                 ^
                              
                            is then

                              
                                 (8)
                                 
                                    
                                       
                                          d
                                          ^
                                       
                                       =
                                       
                                          
                                             
                                                
                                                   ∫
                                                   Ω
                                                
                                                
                                                   
                                                      
                                                         (
                                                         
                                                            u
                                                            −
                                                            v
                                                         
                                                         )
                                                      
                                                   
                                                   2
                                                
                                                
                                                   d
                                                   Ω
                                                
                                             
                                          
                                          
                                             
                                                
                                                   ∫
                                                   Ω
                                                
                                                
                                                   
                                                      u
                                                   
                                                   2
                                                
                                                
                                                   d
                                                   Ω
                                                
                                             
                                          
                                       
                                       .
                                    
                                 
                              
                           
                        

To move from continuous to discrete world the integrals can be replaced by sums

                              
                                 (9)
                                 
                                    
                                       
                                          ∫
                                          Ω
                                       
                                       f
                                       
                                          (
                                          x
                                          )
                                       
                                       
                                          d
                                          x
                                       
                                       =
                                       
                                          ∑
                                          
                                             i
                                             =
                                             1
                                          
                                          m
                                       
                                       
                                          f
                                          
                                             (
                                             
                                                x
                                                i
                                             
                                             )
                                          
                                          
                                             w
                                             i
                                          
                                          ,
                                       
                                    
                                 
                              
                           where wi
                            is the weight of the ith test point with the meaning of volume surrounding the point, xi
                            is the location of the test point and m is the number of integration points. The test points in the formula are the data points situated in the area represented by approximation function f in the presented algorithm.

Relative error 
                              
                                 d
                                 ˜
                              
                            is then

                              
                                 (10)
                                 
                                    
                                       
                                          d
                                          ˜
                                       
                                       =
                                       
                                          
                                             
                                                
                                                   ∑
                                                   
                                                      i
                                                      =
                                                      1
                                                   
                                                   m
                                                
                                                
                                                   
                                                      
                                                         (
                                                         
                                                            u
                                                            
                                                               (
                                                               
                                                                  x
                                                                  i
                                                               
                                                               )
                                                            
                                                            −
                                                            v
                                                            
                                                               (
                                                               
                                                                  x
                                                                  i
                                                               
                                                               )
                                                            
                                                         
                                                         )
                                                      
                                                   
                                                   2
                                                
                                                
                                                   w
                                                   i
                                                
                                             
                                             
                                                
                                                   ∑
                                                   
                                                      i
                                                      =
                                                      1
                                                   
                                                   m
                                                
                                                
                                                   
                                                      
                                                         (
                                                         
                                                            u
                                                            
                                                               (
                                                               
                                                                  x
                                                                  i
                                                               
                                                               )
                                                            
                                                         
                                                         )
                                                      
                                                   
                                                   2
                                                
                                                
                                                   w
                                                   i
                                                
                                             
                                          
                                       
                                       .
                                    
                                 
                              
                           
                        

The value of 
                              
                                 d
                                 ˜
                              
                            is then compared to ɛ value. The value 
                              
                                 
                                    ɛ
                                 
                                 =
                                 0.001
                              
                            came from the experiments as the best-fitting value. If condition 
                              
                                 
                                    d
                                    ˜
                                 
                                 ≤
                                 
                                    ɛ
                                 
                              
                            holds, functions u and v are considered equal in terms of approximation in time. The value ɛ matches MAX_RELATIVE_ERROR parameter in Algorithm 2.

@&#RESULTS@&#

Results of the approximation in time are summarized in Table 3
                           . For spatial approximation the trilinear regression was chosen as the method with the best results in the previous benchmark. The Mechaxisym mesh was used in the test (see Fig. 7).

Files with mesh topology and FEM results that were used in this benchmark can be found at [15]. Time compression procedure covered in Algorithm 2 was applied to already created octree-based structure containing approximations of original data values. Generation of this octree is described in Section 3.2.

@&#CONCLUSION@&#

Least square trilinear interpolation leads to the best results of average approximation error and memory consumption. Compared to other approximation methods, it has smooth transitions between cells. The downside is the high maximal approximation error in some cases. All lossy compression techniques have problems with capturing of high frequent changes in data. To reduce this disadvantage the option to visualize approximation error on the mesh surface was implemented (see Fig. 14
                     ).

Using this feature user of the application can successfully post-process large amount of data and also highlight some problematic areas where approximation is not perfect and that need attention.

Today the fully-functional post-processor capable of showing exact or approximated results from finite element analysis is developed. Memory consumption is lowered due to spatial or even temporal function compression. Besides lower memory consumption and fast data components switching, the benefit of the implemented post-processor is also easier extrapolation of values from integration points. The results of the finite element method are often computed in the Gauss points that are located inside the volume of the elements. The advantage of the octree based visualization that uses approximation functions is the fact that extrapolation of values from the Gauss points to element nodes is not explicitly needed as in ordinary post-processor. When the approximation functions are created, results in arbitrary point can be computed simply by substitution coordinates into the approximation function.

Other advantage of this approach is the ability of the algorithm to compute data values inside the mesh even if they are not present in the data file. Same approach can be followed for temporal dimension, where the similar approximation procedure can compute missing time steps.

Our benchmark shows that approximation in time is an important improvement. At the cost of small increase of average approximation error about 0.04% our test examples show significant increase of memory compression up to 2.5%. In other words the memory consumption of the new data representation is 40 times lower compared to the original post-processor that did not implement any spatial or temporal compression methods in the cases we tested.

However, in some extreme cases (rough, unpredictable function shape) the maximal error can be quite high, up to 100%, and the memory footprint can be even higher compared to exact mode where no approximation is used. Fig. 9 shows exact (not approximated) values. Approximation errors are highest in the locations, where the quantity changes very wildly and octree structure is not smooth enough to capture high frequent changes in data. Our future work should eliminate these limitations. One possible way could be the use of a different approximation function that will better describe discontinuities in input data such as Discrete Cosine Transform used in e.g. JPEG picture format compression (the area close to the aims of this research work) or the Wavelet transform – nowadays, very popular candidate for time-frequency-transformations.

@&#ACKNOWLEDGMENT@&#

Financial support for this work was provided by project number 15-05935S of Czech Science Foundation. The financial support is gratefully acknowledged.

@&#REFERENCES@&#

