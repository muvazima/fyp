@&#MAIN-TITLE@&#An extensible pattern-based library and taxonomy of security threats for distributed systems

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We propose a novel type of abstract software pattern called a threat pattern.


                        
                        
                           
                           We propose a pattern-based taxonomy and library of threats for distributed systems.


                        
                        
                           
                           We propose a simple method to construct system-/technology-specific threat taxonomies.


                        
                        
                           
                           We construct such a taxonomy for peer-to-peer distributed systems.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Distributed systems security attacks

Threat patterns

Threat modeling

Pattern-based security threat taxonomy

Peer-to-peer system-specific threats

@&#ABSTRACT@&#


               
               
                  Security is one of the most essential quality attributes of distributed systems, which often operate over untrusted networks such as the Internet. To incorporate security features during the development of a distributed system requires a sound analysis of potential attacks or threats in various contexts, a process that is often termed "threat modeling". To reduce the level of security expertise required, threat modeling can be supported by threat libraries (structured or unstructured lists of threats), which have been found particularly effective in industry scenarios; or attack taxonomies, which offer a classification scheme to help developers find relevant attacks more easily. In this paper we combine the values of threat libraries and taxonomies, and propose an extensible, two-level "pattern-based taxonomy" for (general) distributed systems. The taxonomy is based on the novel concept of a threat pattern, which can be customized and instantiated in different architectural contexts to define specific threats to a system. This allows developers to quickly consider a range of relevant threats in various architectural contexts as befits a threat library, increasing the efficacy of, and reducing the expertise required for, threat modeling. The taxonomy aims to classify a wide variety of more abstract, system- and technology-independent threats, which keeps the number of threats requiring consideration manageable, increases the taxonomy's applicability, and makes it both more practical and more useful for security novices and experts alike. After describing the taxonomy which applies to distributed systems generally, we propose a simple and effective method to construct pattern-based threat taxonomies for more specific system types and/or technology contexts by specializing one or more threat patterns. This allows for the creation of a single application-specific taxonomy. We demonstrate our approach to specialization by constructing a threat taxonomy for peer-to-peer systems.
               
            

@&#INTRODUCTION@&#

Over the last decade distribution has become one of the main characteristic features of software systems, prompted in large measure by the expanding needs of businesses, scientific organizations and individuals who wish to collaborate across geographical distances, share data and resources or simply perform computations remotely. To support such features, however, the corresponding systems must often span untrusted networks – with the Internet being a prime example – making them susceptible to a wide range of attacks both at the individual host and network levels. Security attributes, therefore, are among the most important quality attributes for distributed systems operating in untrusted environments, and have consequently received much attention over the years [1–4]. To incorporate these attributes during the development of a distributed system, whether using a systematic approach (i.e. a methodology [5]) or in some ad-hoc fashion, requires the introduction of a number of security measures, which, in turn, are the result of analyzing the potential attacks or threats to a system in a given context. This analysis process is often termed threat modeling 
                     [6,7], and is performed during the requirements analysis stage, the design stage, or both. In all cases the process generally requires developers to conjecture possible attacks to different assets or parts of a system, to assess their risk and likelihood, and to determine at a high level how they could potentially be mitigated.

Conducting threat modeling usually requires a sound knowledge of a system's technical domain and sufficient security expertise to consider both generic and specific attacks for various system- and/or technology-specific contexts. These security knowledge requirements can leave most “off-the-street” developers estranged (cf. [8]), with the net result that threat modeling is not performed or, when performed, is performed sub-optimally or with significant effort involved (cf. [9]). As Dhillon [9] points out, a threat library that collects common threats to a given system-/technology-specific context can greatly enhance the efficacy of the threat modeling process and hence put it back, so to speak, on the project map. A threat library such as the one used at EMC [9], or even by Microsoft for web applications [10], can also go a long way in educating developers about common threats, rendering future threat modeling tasks easier.

Despite their value, threat libraries encompass only a set of specific, pre-defined threats, making the discovery of new threats or the same threats in different architectural contexts more difficult. In this respect the use of threat or attack taxonomies such as Microsoft's STRIDE [7] (an acronym for Spoofing, Tampering, Repudiation, Information disclosure, Denial of service and Escalation of privileges), can be more useful, since they allow an arbitrary number of threats to be considered that fall within one or more categories. However, most taxonomies are either at a very high level of abstraction and hence require significant security expertise to identify appropriate threats (cf. [9] for STRIDE), or, in general, are simply not appropriate for threat modeling or indeed any form of security assessment in the first place [11]. Those that are appropriate for security assessment and at the right level of abstraction are not necessarily useful during the earlier stages of the SDLC (e.g. they consider post-design vulnerabilities), do not provide appropriate categories for threat modeling, or are relevant only to specific contexts (see [11] for a broad overview and references). Finally, the taxonomies referred to above – excepting STRIDE – are for vulnerabilities and attacks, not threats, which is a subtle but important difference (e.g. unsafe code execution is a threat realized by multiple attacks in different contexts).

In this paper we combine the values of threat libraries and threat taxonomies and propose what we term (with some risk of using terminology loosely) a pattern-based threat taxonomy for (general) distributed systems. In our approach, each threat is encapsulated in a new type of pattern (see [12]) called a threat pattern, which can be customized and instantiated in particular architectural contexts to define specific threats to a system. This allows developers to quickly consider a range of relevant threats in various architectural contexts as befits a threat library, increasing the efficacy of, and reducing the expertise required for, threat modeling. Threat patterns can also be related to corresponding misuse patterns [13], which can detail the attacks realizing a particular threat and educate developers. The (base) taxonomy aims to classify a wide variety of more abstract, system- and technology-independent threats, which keeps the number of threats requiring consideration during a threat modeling process manageable, increases the taxonomy's applicability, and makes it both more practical and more useful for security novices and experts alike. Employing patterns also helps to establish a common domain vocabulary, promoting the use of consistent threat names and concepts by developers in their everyday security-related work.

Despite the breadth of our taxonomy, each distributed system type, and even the technologies employed to realize a system, can create a variety of specific threats, which may not be explicitly present among our proposed threat patterns, or, more precisely, may not be present at the base level of abstraction. To solve this problem, we propose a simple and effective method to extend threat taxonomies by specializing one or more threat patterns to new system-/technology-specific contexts. This allows for the construction of application-specific taxonomies by taking the union of the set of relevant system-/technology-specific taxonomies, which in turn allows developers to consider the widest range of applicable threats in any given architectural context. We demonstrate our approach to specialization by constructing a threat taxonomy for peer-to-peer systems.

The latter example also demonstrates the purely “taxonomic” feature of our proposal, where each pattern in the taxonomy for distributed systems acts as a “category” for more specialized patterns and pattern instances. This feature allows known threats to be classified in a way that has value during system development, i.e. specific attacks such as CodeRed worm, SQL slammer exploit and, indeed, thousands of others, can be seen more abstractly as collections of individual threats (scanning, probing, injection, etc.), which require mitigation irrelevant of whether they are launched against a system automatically (malicious software) or manually (malicious hackers).

The rest of this paper is structured as follows. In Section 2 we introduce the concept of a threat pattern, relate it to the existing misuse patterns of Fernandez and colleagues [13], and discuss threat taxonomies (Section 2.1); we also define the architectural contexts of the threat patterns (Section 2.2). In Section 3 we present our (base) threat taxonomy for distributed systems and discuss pattern specialization and instantiation. In Section 4 we specialize a number of (base) threat patterns to construct a taxonomy for peer-to-peer systems. In Section 5 we consider related work; and in Section 6 we conclude and discuss future research directions.

In this section we provide the necessary background for the rest of the paper by defining threat patterns and pattern-based threat taxonomies (Section 2.1) as well as architectural contexts (Section 2.2).

The concept of a pattern in software engineering has received much attention over the last 15years, both in academia and the industry, owed in large measure to the pioneering work of Gamma and colleagues in the field of object-oriented design [14]. Patterns have been found useful in diverse areas such as software architecture, fault-tolerance, parallel programming and security, with each area boasting a sizable catalog of patterns available for developers to use. Within security in particular, solutions in the form of security patterns have appeared steadily in the literature to cover most major security-related concerns (see [15]). The pattern concept has also been found useful for the reverse side of the security solution landscape, namely, for security attacks, in the form of attack patterns 
                        [16] and misuse patterns 
                        [13,17,18]. Attack patterns capture the steps required to perform a specific security attack (exploit) in a generic fashion; misuse patterns, on the other hand, detail a complex attack on a system related to particular architectural components, capturing the structure and dynamics of the attack, forensic information and much else besides. Misuse patterns in particular, like security patterns, are full software patterns, which capture a set of principal design decisions [19] or define constraints determining a family of architectures that satisfy them [20]. In the case of security patterns this implies architectural impact [15], and in the case of misuse patterns, a strong architectural relation.

Not all software patterns, however, have direct architectural impact, or concrete architectural relation. From a more abstract point of view, a pattern can be seen simply as “the abstraction from a concrete form which keeps recurring in specific non-arbitrary contexts” [12]. One can thus define a type of software pattern that has a more generic architectural relation conforming to the latter characterization, which we term an abstract software pattern. The security solution analog of this general type of pattern was proposed by Fernandez et al. [21] in the form of abstract security patterns. In this section, we define the threat analog: threat patterns, which are the core constituents of our threat taxonomy.

A conceptual model relating the various patterns for security mentioned thus far, as well as many of the main concepts contained in the rest of this paper, can be seen in Fig. 1
                        , with the more important elements appearing in different colors or, if viewed without color, different shades of gray (purely to differentiate them from other elements and from each other). For associations that appear as being (solely) vertically aligned in the figure, an arrow to the left implies they should be read “upwards” (e.g. each security patterns addresses one or several specific security policies), and an arrow to the right implies they should be read “downwards” (e.g. each general threat pattern is for a given general architectural context). In what follows, words appearing in italic font refer to (class) elements in the model.

Threat patterns, as the name implies, encapsulate security threats in a generic fashion. More precisely, threat patterns can be defined as triples of the form:
                           
                              
                                 
                                    A
                                    T
                                    SP
                                 
                              
                           
                        
                     

Where A
                        ={ai
                        :i∈ℕ} is a set of architectural contexts – determining the abstract relations of each threat to a part of a distributed software architecture – which can be influenced by one or more (distributed) system-/technology-specific contexts (see Fig. 1); T is a generic threat description; and SP
                        ={pi
                        :i∈ℕ} is a set of mitigating generic security policies, which can be refined by more specific policies and realized by appropriate security solutions (such as security patterns).

Being abstract software patterns, threat patterns can be seen as having a similar relation to misuse patterns as abstract security patterns to concrete security patterns [21], namely, misuse patterns realize threat patterns by providing detailed descriptions of an attack that realizes the threat encapsulated in a corresponding threat pattern in a given architectural context. The relationship between threat patterns and attack/misuse patterns thus mirrors the relationships between threats and attacks more generally, i.e. attacks realize threats by exploiting vulnerabilities on assets 
                        [22] (as shown in Fig. 1). In our model assets are taken to mean both important parts of a system or, equivalently, an application, that require protection (information or resources), as well as particular software units.

A concrete example of the relations between assets, vulnerabilities, threats and attacks is when there is an injection threat to a database management system (DBMS) (asset as software unit requiring protection) storing banking information (asset as application information requiring protection) with an input validation weakness (vulnerability) that can be exploited via a particular SQL injection attack (realizing the threat). As can be seen from this example, the threats we are considering are technical threats applicable to the architectural level, to which high-level threats can be mapped – e.g. “reading the balance of a bank account” maps to an “unauthorized access” threat pattern in a particular architectural context.

Threat patterns can be grouped together in threat classes, which together classify the patterns and form a (pattern-based) threat taxonomy. There can be one such taxonomy for each system-/technology-specific context, with a single taxonomy for the (general) distributed system context, which we term a base threat taxonomy. Derived taxonomies for different system-/technology-specific contexts (e.g. peer-to-peer systems, agent-based systems, web-service and Java technologies) can also be constructed by specializing threat patterns from the base taxonomy. Since one cannot expect to encompass all threats in a single taxonomy, derived taxonomies may also augment the base taxonomy with new patterns or additional threat classes as required. Derived taxonomies can be combined to form a single application-specific taxonomy, which will contain a mixture of base (general, unspecialized) and specialized threat patterns.

Taxonomies can also be stratified into different levels according to the purpose of the threat patterns (this is not shown in Fig. 1). Our base threat taxonomy, in particular, is stratified into two levels, the first of which aggregates security threat patterns with respect to the system itself (at the architectural level); and the second of which aggregates meta-security threat patterns, which are simply (threat) patterns encapsulating threats to the designed security infrastructure of a system (more precisely, threats to the security countermeasures corresponding to the policies introduced as mitigating factors for the first level threats). The details of the threat classes used in both levels are given in Section 3.

Having thus far defined threat patterns and informally discussed the main concepts and their relations as shown in the conceptual model (Fig. 1), perhaps a few remarks are in order regarding the more formal aspects of the model itself. Regarding the coverage and completeness of the generalization relations, the generalizations stemming from the asset, security policy and taxonomy elements are complete; while all others are incomplete. The generalizations stemming from the asset and security policy elements are disjoint; while all the other generalizations are overlapping, although the degree of overlap is not always well-defined (e.g. attack patterns are patterns, but cannot be classified precisely as software patterns, since they lack explicit architectural relation). Regarding the associations, the mitigates associations (between threats and security policies, and threat patterns and generic security policies) should be interpreted more broadly as “stop, lessen or mitigate”, since a policy may altogether stop a given threat, depending, of course, on how it is implemented. Another noteworthy association is the influences association between system/environment contexts and architectural contexts, which should be interpreted as carrying over into the derivative (subclass) elements, so that the system/technology-specific contexts influence (and indeed define) the derived architectural context as appropriate for the given situation. All other associations in the model can be interpreted straightforwardly.

As explained in Section 2.1 above, for threat patterns to be (abstract) software patterns in any real sense, they must have some form of architectural relation. In this section we summarize part of a conceptual framework for a form of system characterization called architectural decomposition, proposed in [23], which we use to define the architectural contexts of our threat patterns. The aforementioned framework allows distributed software architectures to be decomposed into different areas of functionality using five decomposition layers, and further characterized by means of a set of corresponding abstractions capturing the main aspects of the architecture's realization. When the framework is applied to decomposing an actual distributed software architecture (during its development or otherwise), certain parts of the architecture will fall into the various layers, and potentially implement one or more realization abstractions. The architectural context for a given pattern is defined precisely by the relevant decomposition layers and corresponding realization abstractions. This gives each pattern its necessary architectural relation, which is also important for pattern specialization (Section 3.3), and allows each threat to be related to the parts of the architecture that are themselves related to the different layers and abstractions, which is necessary for pattern instantiation (Section 3.4).

In what follows, we briefly describe the conceptual framework's decomposition layers – in Table 1, Section 2.2.1 – and realization abstractions – in Section 2.2.2 (the reader is referred to [23] for additional details). The presentation order of layers and abstractions in the table and the bullet points follows their hierarchical structure: each functionality decomposition layer relies on the general distributed system aspects or concerns encompassed by the layers below it, and, similarly, the realization abstractions are ordered such that each abstraction in each layer relies on ones below it. For the decomposition layers (Table 1), the right-most column on a given row indicates the threat classes from the base taxonomy (with accompanying sub-section numbers in brackets), which have threat patterns with that layer (row) as a context. While the threat classes are not actually introduced until later, in Section 3, they are included in the table for reference. The letters in brackets after the decomposition layer's name in the first table column is a shorthand that will be used later in presenting the base taxonomy (Sections 3.1 to 3.2).


                           
                        

User interaction:
                              
                                 •
                                 
                                    Input ports: software elements of any granularity by or through which an application can receive user input.


                                    Output ports: software elements by or through which a user can obtain information from an application.

Data/storage management:
                              
                                 •
                                 
                                    Data structures: from an application's point of view, most data is used in the form of particular data structures defined during detailed design and implementation, but also during earlier stages.


                                    Storage abstractions: data can be stored in objects or encapsulated in some other fashion, e.g. in file abstractions.


                                    Database systems: data can be stored in a database, which can be thought of as coarse grained architectural components.


                                    File systems: the data used by an application will ultimately be stored in files on persistent media (block devices), regardless of the storage abstractions placed on top. Files are usually part of a file system managed by the operating system.

Resource management:
                              
                                 •
                                 
                                    Resources: resources are any software components that are managed (created, destroyed, monitored, etc.) for use by other components. Examples can include schedulable processes, active software components with a certain lifecycle, data stores, as well as virtual machines or hardware units.


                                    Algorithms: resources are allocated and shared via particular algorithms, which can address issues in resource contention, detecting deadlocks or be concerned with electing new locations for data replication. They can also relate to the management of dynamic (run-time) configurations of components in a system.

Distribution control
                              
                                 •
                                 
                                    Software component interfaces: all active software components have interfaces to interact with each other, which may include programmatic functions, APIs or some implicit means of making a component perform some function.


                                    Operations: every active component can also perform certain operations, which can be divided into various levels of granularity, such as large-grained responsibilities (sharing load among worker threads), functions (an object's methods), syscalls, etc.


                                    Execution abstractions: active software components usually map to certain concrete software units in some technology: e.g. objects, beans, and applets.


                                    Processes (OS): the execution abstractions in a system are ultimately executed as processes (or in processes) by an underlying operating system, whose semantics of the processes may differ from any abstractions placed on top.

Communication
                              
                                 •
                                 
                                    Messages: messages are the unit of transport data in a networked process collaboration, and may include remote function calls and their parameters, XML documents and others.


                                    Message channels: messages are carried over logical message channels, which can be considered separately from the messages themselves, and be of different granularities and levels of abstraction (network links, publish/subscribe infrastructures, etc.)


                                    Protocols: the actual passing of messages is accomplished via the use of protocols, with some examples being the TCP/IP protocol suite and security (cryptographic) protocols such as SSL.


                                    Networking infrastructure (S/W): the messaging infrastructure is ultimately implemented on top of a physical network infrastructure consisting of routers, switches, hubs, etc., which are controlled and configured by software and hence can form part of the system configuration itself.

Addressing:
                              
                                 •
                                 
                                    Addresses/identifiers: for components to be usable and/or reachable by others, they must be addressable, which can be achieved by assigning entities identifiers, addresses and/or names.


                                    Protocols/algorithms: the protocols or algorithms used in assigning addresses can be considered abstractly as a “lookup()” function that returns the address of a component.


                                    Routing data structures (tables): information for routing messages to the correct address during communication is often stored in tables or other data structures, at the application level or in the network infrastructure.

In this section we present the threat patterns in the two levels of the base taxonomy for distributed systems (Sections 3.1 and 3.2 respectively).

The patterns constituting the taxonomy are the result of selectively synthesizing, generalizing and condensing in abstract form the relevant security knowledge contained in a number of existing attack and vulnerability taxonomies [24–31], threat libraries [9,10] and attack repositories (CAPEC — capec.mitre.org, [32]; OSVDB through the work of [33]), guided by the current authors' own security expertise. While we cannot claim that our collection of patterns is exhaustive, we believe that they collectively span most threats against (general) distributed systems, both at the network and host levels.

As mentioned in Section 2.1, the base taxonomy is stratified into two levels, with the first aggregating security threat patterns encapsulating threats to the system itself; and the second aggregating meta-security threat patterns, which encapsulate threats to the designed security infrastructure of the system. The first level of the taxonomy organizes the threat patterns into eight threat classes, which can be described as follows (the threats described refer to varieties of encapsulated threats):
                        
                           •
                           
                              Identity attacks: threats in which an attacker attempts to fabricate or misuse identities in a system;


                              Network communication attacks: threats to the communications between distributed components;


                              Network protocol attacks: threats specifically to the network protocols used for communication;


                              Passing illegal data: threats in which input data is manipulated by an attacker for some malicious purpose;


                              Stored data attacks: threats specific to on-storage data (excluding unauthorized access);


                              Remote information inference: threats which are concerned with extracting information from a component or part of a distributed system remotely, i.e. over a network;


                              Loss of accountability: threats impacting accountability attributes;


                              Uncontrolled operations: containing threats which are concerned with exploiting existing system functionality in ways that would not normally be allowed, including race conditions, access to data, etc.

The second level of the taxonomy organizes threat patterns into four meta-security threat classes, which can be similarly described as follows:
                        
                           •
                           
                              Cryptography attacks: threats to countermeasures using cryptography;


                              Countermeasure design: threats to the way certain countermeasures are (or may be) designed;


                              Configuration/administration: threats related to the configuration and/or administration of the security infrastructure.

The Network protocol attacks threat class from the first taxonomy level is also part of the second level (with the threat patterns being applicable to secure protocol design).

In relation to high-level taxonomies such as STRIDE, our threat classes are based on the nature of the threat (e.g. network protocol attack), not its impact (e.g. escalation of privilege).

In the two ensuing sub-sections we present the patterns according to the levels and order of threat classes defined above. Following this presentation, we outline a simple method to specialize the threat patterns for different system-/technology-specific contexts (Section 3.3), and briefly discuss pattern instantiation (Section 3.4).

The first level threat patterns aim to encompass most common threats to general distributed systems. We present the patterns according to their threat classes (Section 3) in succession, beginning with patterns for Identity attacks in Section 3.1.1 and ending with patterns for Uncontrolled operations in Section 3.1.8 (see Tables 2–9). We use the following scheme for presentation: the name of the pattern appears in the left-most column in each table, followed by a brief description of the threat in the next column; then the architectural context (which is affected by the system-specific context for distributed systems by default), with the decomposition layer denoted by its shortened form (as introduced in Section 2.2) and the realization abstractions following in brackets; and finally a mitigating (generic) security policy in the right-most column, with a more specific policy in brackets if applicable.

Our table-row-based presentation replaces (without any loss of essential information) the more traditional pattern presentations employing a structured textual template, and can be related to the latter by mapping the description column (for each row) to a “solution”-equivalent section; the architectural context to a “context” section; and the mitigating policies column to a directly equivalent “mitigation” section. Since the threat patterns are abstract, we do not need to consider forces, architectural models, etc., which is what would be required of misuse patterns that realize a given threat pattern in particular contexts.

As an aside, having introduced the first level threat classes at the outset of Section 3, the reader can refer to Table 1 (right-most column) as a complementary organizational aid to quickly find which classes contain threat patterns with a given functionality decomposition layer as a context.


                           
                        


                           
                        


                           
                        


                           
                        


                           
                        


                           
                        


                           
                        


                           
                        

In this section we describe the second level (meta-security) threat patterns of the base taxonomy. In contrast to the first level threats, which can generally be realized with a single attack, second level threats are more high-level and can encompass multiple attacks to the corresponding security infrastructure. We use a variation of the presentation scheme established for the patterns in Section 3.1, where each meta-security threat pattern is described in the format name – description – corresponding policy realizations, in Sections 3.2.1 to 3.2.3, Tables 10 to 12, respectively. In all cases the architectural context is determined by the realization of the corresponding security policy.


                           
                        


                           
                        


                           
                        

The patterns presented thus far have all pertained to a general context for distributed systems, where the individual architectural contexts have been defined abstractly by the set of related decomposition layers and corresponding realization abstractions, as they are presented in Section 2.2. In what follows we present a simple method for specializing the threat patterns to different system-/technology-specific contexts, in order to construct a system-/technology-specific (derived) taxonomy.

As a first step in our method, one has to determine how the target system-/technology-specific context affects a given threat pattern's architectural context. This can be done purely based on the general characteristics of the given system or technology: each decomposition layer is considered in turn and characterized, along with any relevant realization abstractions. Subsequently, one can take two complementary approaches to specialization:

The first (deductive) approach consists in further detailing the effect of the new system-/technology-specific context by, for example, selecting several possible (generic) realizations for the abstractions – with relevance to the system or application – to determine as full an architectural context as possible without reference to the application's actual architecture, and considering how the threat in each selected pattern changes in the new context using domain and security expertise. For example, a Corruption threat can be considered with respect to storage abstractions in a distributed file sharing context in which files are hashed. Corruption then implies that not only the file, but also the hash values, are affected, possibly leading to a new attack. Instantiation of the pattern can be avoided if the architectural context is kept sufficiently general, e.g. for a system type; if one begins to consider the threat for a particular system, then, naturally, this leads to instantiation (Section 3.4), not specialization.

The second (inductive) approach aims to draw domain and security knowledge from the existing literature on the subject, and consists in identifying specializations of threat patterns based on well-known and documented attacks. These attacks are then related to one or more threat patterns in the base taxonomy, and a corresponding architectural context, together with a mitigating policy, is determined accordingly.

In both approaches to specialization, the pattern's architectural context and potentially mitigating policies should be refined and/or expanded by propagating the threat down the hierarchy of decomposition layers and realization abstractions and considering its applicability to each of them in turn.

The final list of specialized threat patterns will constitute part of a system-/technology-specific taxonomy in its own right; a full taxonomy can be obtained by taking the union of relevant threats from the base threat taxonomy (i.e. the more general context) and the specialized patterns, with the more general patterns selectively replaced by the specialized versions (whenever this does not reduce the scope of possible attacks). In this sense, the constructed taxonomy can be seen simply as an extension of the base taxonomy to a more specific context.


                        Section 4 contains several examples of pattern specialization that make the latter descriptions somewhat more concrete.

Threat patterns are instantiated in their architectural context with relation to the actual software architecture of the system or application, i.e. with consideration of which components and what parts of the architecture are involved. This gives an abstract description of the threat in the given context (as befits an abstract pattern) that can be made more concrete by instantiating related misuse patterns encapsulating the corresponding attacks in detail. A proper illustration of this requires a concrete distributed software architecture and is outside the scope of this paper. As a simple example, however, we can consider a client–server architecture using a Broker pattern for implementation [35], in which users (clients) use the server for entering their bank details. A threat pattern instance in this case is a message secrecy violation threat in the message channel abstraction (architectural context) realized by the Broker, with any encryption (mitigating policy) to be applied to the Broker's messaging components.

In previous sections we have referred to the fact that different taxonomies can be derived from the base taxonomy by specialization of individual threat patterns for more specific architectural contexts. In this section we construct such a (derived) taxonomy for peer-to-peer architectures. Before this, we present some background on peer-to-peer systems in Section 4.1, outlining some of their general system-specific characteristics. This will be used in Section 4.2 to set the architectural context of the patterns.

As we explained in Section 1, constructing threat taxonomies for different system-/technology-specific contexts allows a single application-specific taxonomy to be created, which can be used to improve the efficacy of threat modeling during development. We discuss this point again briefly in Section 4.4 in relation to contexts other than peer-to-peer systems. Finally, we conclude this section by briefly discussing the use of pattern-based taxonomies as classification schemes (Section 4.5).

Peer-to-peer systems are distributed systems in which there is no central point of control and software components on participating nodes can play the role of both a client and a server [36]. While well-known content-distribution and file sharing applications such as Napster and KaZaa are usually cited as paradigmatic, peer-to-peer architectures are used in a wide variety of other systems as well, including instant messaging (IM) applications, collaborative applications and scientific computing environments. One of the main distinguishing architectural features of a peer-to-peer system is the use of a network overlay that facilitates communication between components (henceforth simply peers) by providing application-level routing on top of an existing networking infrastructure (e.g. on top of the TCP/IP protocol suite and the Internet) [37,38].

Peer-to-peer systems can be broadly classified according to two orthogonal dimensions [39]: the degree of centralization with respect to addressing (centralized, decentralized, hybrid), and the structure of the overlay with respect to routing and communication (structured and unstructured). In centralized peer-to-peer systems, a central server is used for addressing (peer lookup functionality), after which peers can communicate between each other freely. In decentralized peer-to-peer systems the lookup functionality is spread across the peers. Hybrid peer-to-peer systems use super-peers to perform the lookup functionality (and potentially other functions), acting as localized servers. Regarding the overlay structure, structured peer-to-peer systems enforce some kind of mapping (usually using Distributed Hash Tables or DHTs) between keys or identifiers and resources stored on peers to facilitate efficient lookup, with the overall routing structures being distributed throughout the overlay; unstructured peer-to-peer systems, on the other hand, use network flooding strategies for routing and lookup queries. This division of peer-to-peer systems allows the theoretical combinations of structured, centralized and structured, hybrid systems, but we should point out that in practice current structured (DHT-based) systems are uniformly decentralized.

Peer-to-peer systems can also be classified according to their application domain [40]: communication and collaboration, distributed computation, Internet services support, database systems and content distribution.

Besides the custom operations performed by peers, there are several abstract operations that are common to most peer-to-peer systems [37,41], including: join, leave, search/lookup (for a particular resource/item) and route (for a particular lookup query or communication stream).

Following the method for pattern specialization in Section 3.3, when specializing threat patterns one first needs to determine the derived architectural context by considering in what way the system-/technology-specific context affects the patterns' architectural context. Given the description in Section 4.1 above, and the decomposition layers outlined briefly in Section 2.2, the manner in which the peer-to-peer specific context affects the decomposition layers, and the corresponding abstractions which pertain most to such systems, can be briefly delineated as follows:
                           
                              •
                              
                                 User interaction: users are peer nodes or represented by peer nodes, therefore all input and output occurs locally or between peers. Identities of peers are usually defined by the overlay, and can be used as identifiers for routing (see below).


                                 Data/storage management: for content-based peer-to-peer systems, all peers store parts or the whole of some data or resource. Peers may store meta-data about the content, and may share the content globally.


                                 Resource management: all resources are managed either in a decentralized manner (by the peers) or using a centralized server.


                                 Distribution control: is decentralized, with each peer providing the same interface or at most certain super-peers providing additional functions. Operations may include join, leave, search and, for content-based systems, store and share.


                                 Communication: uses an overlay network, structured or unstructured, on top of an existing networking infrastructure. Since messages are routed via the peers themselves, they are more vulnerable to communication attacks.


                                 Addressing: is performed by the overlay, mapping identifiers to peers, which often (though not always) assumes a one-to-one logical to physical mapping.

Once the architectural context is set, we can (1) make hypothetical choices for how the realization abstractions are implemented and determine how the base patterns are affected in the new context; and (2) consult the existing literature for documented threats in the given system-/technology-specific context and relate them to relevant base taxonomy threat patterns within the given architectural context. In the three examples below we take the second of these two complementary approaches, presenting first the context (decomposition layer and corresponding realization abstractions), the base threat pattern that is specialized, followed by an explanation of the (specialized) threat.
                           
                              •
                              
                                 Addressing decomposition layer – Addresses/identifiers (propagated down to Protocols/algorithms and Routing data structures (tables)) – Route poisoning threat pattern: a set of peers that are compromised may begin to manipulate the routing information of a single peer, thus filling its tables with incorrect information. This would effectively “eclipse” the peer from the network. If this is done to enough peers, it would also be possible to split the overlay network into (potentially controllable) segments. This is suitably called an Eclipse attack in the literature.


                                 Communication decomposition layer – Message channel abstraction – Message flooding threat pattern: besides flooding the network with fabricated messages from the outside, a peer that has been compromised may also send out false queries within the overlay. This would be particularly unsatisfactory in an unstructured peer-to-peer system, and would clearly cause the performance of the underlying network to degrade, possibly leading to denial of service. This is called Query flooding.


                                 Resource management – Protocols abstraction (which can be propagated down to be related to Distribution control – Operations abstraction) – Resource exhaustion threat pattern: A peer can continually join and leave the peer-to-peer system, hence calling the join and leave operations on one or more peers or a centralized server and causing routing tables to be updated, messages to be sent out etc. In the literature on peer-to-peer systems, this problem is called Churn.

In like manner the process of relating known threats to base patterns and attempting to (manually) specialize base patterns in the new architectural contexts can be continued with all other threats, until an exhaustive list of threats is obtained.

In general, the choice of exactly which base patterns to specialize for a given context is up to the developers or the team constructing the taxonomy. In the present case, since peer-to-peer systems are a sub-class of distributed systems, we have chosen to specialize only the threat patterns which refer to the peer-to-peer overlay and which would not be readily recognizable from the base patterns by developers lacking domain and/or security knowledge. All other base threat patterns still apply in the peer-to-peer context (without requiring explicit customization).

The final list of specialized threat patterns, shown in Table 13
                         organized according to the threat classes proposed in Section 2, adheres to the common attacks in peer-to-peer systems identified in the work of Yue et al. [42], Urdaneta et al. [43] and Wallach [44], as well as in different recommendations and RFCs by standards bodies [45–47,41]. We did not consider so-called rational attacks [48] (free-riding, incentive avoidance and others), consisting of strategized attempts by users or their representative nodes to (effectively) swindle the peer-to-peer system for gain. Such attacks can indeed become causes for security breaches (in the form of denial-of-service), but the threats posed by them will correspond to one of the threats described below.

The complete threat taxonomy for peer-to-peer systems consists of the simple union of the list of specialized threat patterns with the patterns from the base taxonomy. Although with respect to a threat modeling process the specialized patterns can replace their base counterparts in the relevant contexts, the base patterns still apply in other contexts (e.g. the patterns from the Network communication attacks class are applicable to the underlying network infrastructure), hence they are also included. If they were not to be included, the scope of possible attacks would be reduced, which would in turn lessen the value of the final taxonomy.

As in Sections 3.1 and 3.2, Table 13 presents the patterns in the now established table-row-based format, adding a further Threat pattern specialized column (“section”, in the terminology of traditional textual templates) and updating the Architectural context to be the Derived architectural context.

We should point out that the security policies suggested in Table 13 should only be taken as indicative – a number of solutions have been devised to deal with the various peer-to-peer specific threats, for which the reader is referred to [47,41,46,43,42] for an overview. While presenting corresponding misuse patterns for the threat patterns outlined above is outside the scope of this paper, the reader can refer to [22] for a fine-grained model template that describes Overlay route manipulation in more concrete detail and that can be converted to a misuse pattern with relative ease.

In like manner to the peer-to-peer taxonomy one could construct taxonomies for various technologies and/or other types of systems. For example, if a web application (system-/technology-specific) context is set, then one can begin constructing a taxonomy by considering Network protocol attacks against the TCP/IP stack (see [49,50]), e.g. SYN flooding [51] (specializing the Protocol initial/end state exploitation pattern), or Network communication attacks against the HTTP protocol, e.g. response splitting [52] (specializing the Message integrity violation and Session state poisoning patterns), in the Communication functionality decomposition layer. While specializing some (general) threats would require domain expertise, many (web-based) threats are simple extensions that would require little change to the base patterns, e.g. SQL injection, XPath injection and others, which simply set different contexts for the Injection pattern.

If an application employs a peer-to-peer architecture for communication and a web application front-end for initial user registration (to give a hypothetical use case), then the peer-to-peer taxonomy from Section 4.3 could be combined – as a simple union – with the web application taxonomy to create a single application-specific taxonomy, which would allow developers to consider a highly relevant set of threats for each part of the application as required. Doing so has clear benefits for (security-wise) inexperienced developers performing threat modeling or any security analysis process aiming to encompass the widest possible range of threats.

Of course, we should emphasize that web applications and peer-to-peer systems are just two relatively general examples – pattern-based taxonomies can also be constructed for other, more specialized system types, such as cyberphysical, industrial control systems (see, for example, [53,54]) for water, energy or other industrial processes. In the latter case there may be a need to specialize patterns multiple times to construct derived taxonomies for the different contexts.

As a final note regarding the construction of derived taxonomies, we should point out that in real-life situations it may not always be realistic to expect development teams to use our proposed method to specialize threat patterns. Ideally, in these cases security experts with domain knowledge in the target systems and technologies would prepare the necessary patterns and hence construct the taxonomies beforehand. In all cases, however, once a taxonomy for a particular system-/technology-specific context has been constructed, it is reusable across related systems/projects, reducing the work required in the longer term.

In the introduction and earlier sections we referred to the fact that our base threat taxonomy, which plays the simultaneous role of a threat library, can be used to classify known threats for distributed systems. This can be seen from the list of specialized threat patterns for peer-to-peer systems in Table 13, where each specialized threat pattern is categorized under the more general base pattern. The complete threat library for peer-to-peer systems, which includes this time the threat patterns as patterns, can also be used as a classification scheme (in accord with the purpose of a “pure” taxonomy) for specific peer-to-peer threats, where pattern instances, for example, Eclipse attacks against DHT tables, overlay route manipulation for a given algorithm, etc., can be categorized accordingly. The same is true of other threats: SQL injection, XPath injection, LDAP injection, parameter manipulation and many others can all be classified as Injection threats, since they are either specializations or instances of the latter.

@&#RELATED WORK@&#

The literature contains a large number of proposals for attack and vulnerability taxonomies, many of which have already been surveyed in [11]. Many of these taxonomies, including more recent ones such as AVOIDIT [31], strive towards the goals set out by Hansman and Hunt [26], namely, to provide a taxonomy useful for classifying existing attacks in the broadest sense of the term. This can be useful for penetration testing or security evaluation when a system has already been implemented, or at least designed in sufficient detail, and incorporates particular technologies that may contain vulnerabilities and/or be susceptible to known exploits; however, they are not useful for security analysis during earlier development stages, and hence not for threat modeling. Moreover, we do not believe that worms, viruses, etc. can be labeled as specific attacks in their own right; rather, they are automatic means of launching collections of specific attacks, such as port scanning (on specific ports), OS fingerprinting and others. It is these specific attacks that should be protected against during development, by considering them, for example, in the context of a threat modeling process as threats that are instances of our threat patterns.

Besides security analysis, attack taxonomies can also be used for intrusion detection, where knowledge about attacks is formalized in a fashion suitable for automation. Such taxonomies are contained in the work of Herzog et al. [27] (in the context of security ontologies), which is especially comprehensive, and Álvarez and Petrović [55]. Besides proposing a different classification scheme and not aiming for applicability to automated intrusion-detection, our taxonomy also differs in its being based on patterns, allowing it to be used simultaneously as a threat library in which threats are related to architectural contexts.

Despite their different applicability, we have used the security knowledge contained in a number of existing attack and vulnerability taxonomies as a basis for our own work – in particular, for creating our threat patterns, as explained at the outset of Section 3.

With respect to approaches combining both a classification scheme and software patterns, a closely related effort can be found in the MITRE organization's Common Attack Pattern Enumeration and Classification (CAPEC — see http://capec.mitre.org) list, which classifies attack patterns hierarchically, extending the work of Hoglund and McGraw [16]. Attack patterns, as we noted in Section 2 are related to threat patterns by a “realizes” relationship, which implies that the CAPEC attack patterns are complementary to our threat patterns. Besides the distinction in patterns, the CAPEC attack classification into mechanisms – data leakage attacks, resource depletion, injection, spoofing, time and state attacks, abuse of functionality, probabilistic techniques, exploitation of authentication, exploitation of privilege/trust, data structure attacks, resource manipulation and network reconnaissance attacks – differs from our scheme, even if with some overlap. Several of these classes, such as “abuse of functionality”, are much too broad, while most next level classes grouping attack patterns are much too specific (as attack patterns generally are), e.g. “WSDL scanning”, which applies only to systems based on web-services. This approach leads to hundreds of specific patterns (in fact, CAPEC catalogs more than 400), classified in the most general ways, rendering the classification bewildering for developers with little security expertise, and cumbersome for those who are experts already. In contrast, our taxonomy of threat patterns provides enough abstraction to encompass most common threats to distributed systems, but avoids a high level of generality in the classes and a high level of specificity in the patterns, rendering the classification more manageable and usable. The level of abstraction is not only (arguably) generally beneficial, but is also essential for security analysis processes and for threat modeling in particular, where threats can be considered early in the SDLC independently of any implementation details. Using our taxonomy for some form of security analysis does not, however, prohibit the complementary use of CAPEC (during later development stages), since attack patterns can be seen as particular realizations of our threat patterns, e.g. the WSDL scanning attack pattern referred to previously can be seen as a realization of the Scanning threat pattern in our taxonomy. The aforementioned overlap in the classification scheme (by attack mechanism) is, in fact, a benefit in this respect, since it could be used to relate our threat patterns with the attack mechanisms that are used to realize them.

A brief discussion of other related approaches to encapsulating threats or attacks can be found in [13].

In this paper we presented an extensible, two-level pattern-based taxonomy of security threats for distributed systems, encompassing both threats to a system (first taxonomy level, Section 3.1) and threats to corresponding countermeasure realizations (meta-security threats) (second taxonomy level, Section 3.2). Each threat in our taxonomy is encapsulated as an abstract software pattern that can be specialized for different system types and/or technologies, increasing the flexibility and applicability of the taxonomy. We demonstrated this in Section 4 by specializing a number of (first level) threat patterns in the base taxonomy to construct a taxonomy for peer-to-peer systems. Similar extensions could be constructed for different technology-specific contexts, such as web services [56] and web applications [10]; and distributed system types, such as multi-agent systems (MAS) [57], industrial control systems [58,59], grid systems [60] and cloud systems [61–63] – which constitute distinct taxonomies in their own right, consisting of the base and specialized threat patterns. By combining the taxonomies we can also construct a single, application-specific (tailored) threat taxonomy, which, in effect, is simply an extension of the base taxonomy.

The base threat taxonomy itself can be said to possess nearly all the properties set out by Igure and Williams [11] required of a taxonomy suitable for security assessment, namely:
                        
                           •
                           
                              Application specificity: as discussed above, our base taxonomy is extensible by specialization, which allows the construction of application-specific taxonomies.


                              Layering or hierarchy: our base taxonomy is divided into threat classes and threat patterns, the latter of which can be specialized and instantiated in various contexts to create arbitrary sub-hierarchies. The taxonomy is also stratified into two levels, for system (security) threats and security infrastructure (meta-security) threats.


                              Use of system-specific attack types: specialization of base taxonomy patterns allows threats for different system-/technology-specific contexts to be captured.


                              Relation to system components: the architectural contexts of each threat pattern ensure architectural relation for a given decomposition of an application's software architecture.


                              Classes need not be mutually exclusive: as seen in Section 4.3, some attacks can be classified as realizing patterns from more than one threat class in the base taxonomy, which can be useful in practice, e.g. when searching for all attacks realizing a given threat.

Naturally, it should be kept in mind that the purpose of our threat taxonomy is to allow developers to consider threats during application design, rather than to find vulnerabilities during later development stages.

With respect to related approaches (Section 5), our threat patterns are neither too generic, nor too specific, nor too detailed; can be easily related to an application's software architecture; and encapsulate related mitigating policies – making them useful in a variety of security analysis processes both for existing and new systems. In both cases the patterns can be used as constituents of a threat library, which, as evidenced by Dhillon [9], greatly enhances the efficacy of threat modeling and reduces the expertise required to perform it; and an abstract threat taxonomy in the spirit of Microsoft's STRIDE, which helps developers to find relevant threats in different contexts via high-level categories. Specialization of the patterns to construct tailored taxonomies can help to ensure that a maximum number of threats are available for consideration during a threat modeling process, further reducing its expertise and effort requirements.

A valuable future direction with respect to using our taxonomy in threat modeling processes would be to precisely correlate the threat patterns with appropriate CAPEC attack patterns, whether directly or via misuse patterns (which aggregate attack patterns as part of their solution), allowing developers to consider possible realizations of a threat in a given context during development. This would also be beneficial for testing and evaluation purposes, where corresponding misuse and/or attack patterns used at the design stage can form the basis of a plan for penetration testing (cf. [64]).

The integration of our taxonomy into a complete security methodology for distributed systems (see [5]) is another, related research direction. Utilizing application-specific taxonomies that encompass various system-/technology-specific contexts would be particularly valuable for methodologies capable of being tailored in some fashion (see [65]) for different types of specific distributed systems (collaborative, peer-to-peer, web-service based, etc.) (cf. [15]), and is something that we intend to explore in the future.

@&#REFERENCES@&#

