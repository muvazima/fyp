@&#MAIN-TITLE@&#Design and implementation of monitoring and management system based on wireless sensor network hop estimation with the moving target Kalman prediction and Greedy-Vip

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           The design and implementation of Jujube real-time monitoring and management system


                        
                        
                           
                           Data management system which includes remote monitoring subsystem and jujube germplasm resources professional subsystem


                        
                        
                           
                           Providing functions of jujube germplasm information storage and query of remote monitoring data with GIS technology


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Environment resources

Wireless sensor network

Monitoring system

Hop

Geographic information system

@&#ABSTRACT@&#


               
               
                  Recent advances in wireless sensor networks (WSNs) technologies and their incorporation with geographic information system (GIS) technologies offer vast opportunities for development and application of environment monitoring data communication. This paper analyzes the method of predicting the location of moving target with the Kalman filter and Greedy-ViP approach to establish WSN flat network routing and the data management system. Simulation results demonstrate that the predicted information collection node locations by the proposed method are consistent with the majority of real ones, the hops tend to straight lines, the hops count is the least, lower repetition rate of the nodes on different hops, and the environment monitoring data can be saved and queried.
               
            

@&#INTRODUCTION@&#

Plant germplasm resource is also known as a genetic resource. Protection of germplasm resources is to prevent the carrier of genetic information loss and species extinction. Due to rapid population growth, over-exploitation of crop germplasm resources, invasion of alien species and environmental pollution and so on, the loss of crop germplasm resources becomes increasingly serious. Most researches on germplasm focus on seed conservation and germplasm resource information storage using database technology [9]. They can only realize the browsing and query of static information but are short of dynamic real-time monitoring of crop growth environment.

Wireless sensor networks (WSNs) are useful in applications such as environmental data acquisition, target tracking and monitoring. WSN nodes are battery-powered, so WSNs are necessary to effectively capture and transfer data, and also take into account the energy conservation [1]. The node plays the role of data communications and routing in multi-hop WSNs. The electricity shortages of nodes or services change, may lead to the structural changes of the network topology and the network restructuring. And the network routing often needs to re-choose [1]. Taking into account that the energy consumed by the sensor collecting signals each time can be controlled around in 1nJ, the energy needed by the processor running a directive can be controlled within 1nJ, the RF communication mechanisms need to consume about 100nJ when transferring 1bit data in approximately 10–100m [2,3], so it has an important significance for saving network energy to reduce the burden of network communication.

Collecting and transmitting data is an important task for WSNs. Efficient data dissemination approach helps to improve communication efficiency of the large-scale WSNs [4]. Cooperative communication in data transmission can also improve electrical energy utilization efficiency of WSNs, and ensure the stability and reliability of the network [5].

The researchers proposed a number of communication protocols, such as class-based negotiation protocol, directional published class protocol, multi-hop class protocol, communication protocol routing class and data-centric routing algorithm. WSN routing protocols are generally divided into four categories, including flat routing protocol, hierarchical routing protocol, geographic-based routing protocol, the routing protocol based on data flow model and quality of service. The geographic-based routing protocol, considering the location information of nodes, can determine the direction and regions of the packet transmission, and substantially reduce the transmission range of the data packet. This kind of routing protocol has considered the network topology changes, due to the changes of nodes [6].

The routing design method, based on monitoring object characteristics or movement characteristics, can effectively improve the communication efficiency and performance of networks, and extend the life of networks. In this paper, the moving objectives are as the network-aware monitoring objects. According to the motion characteristics of the monitoring object and the discrete Kalman filtering methods, the method can predict the position of moving objects. It estimates the next monitoring node, and establishes the hop between the perception nodes and sink nodes, based on the Greedy-ViP routing algorithm. This method is different from the study of the delay-constrained information coverage problem in mobile wireless networks, which takes advantage of the node mobility for information collection when a node moves into the proximity of stationary base stations [7]. And it is also different from intelligent agent-based routing method for mobile sinks in data collection, which has better performance [8]. We use the static nodes to make the collected moving target information to transmit to the sink nodes. The rest of the paper is organized as follows. Section 2 reviews the Kalman filter algorithm. Section 3 includes three parts: the first part introduces virtual-location-based Greedy-ViP WSN communication routing method; the second part first shows extensive simulation results of the Greedy and Greedy-ViP algorithms, then it presents the extensive simulation results of the Kalman-filter-based moving target prediction, finally it shows extensive simulation results of the hop of the moving target detection; and the third part demonstrates the performance of the proposed algorithms. The design and implementation of the data management system are described in Section 4. Section 5 concludes this paper and suggests some future work.

Kalman filter [19] is useful in applications of the discrete data forecasting of the wireless monitoring and target tracking. The extended Kalman filter based measurement of orientation determination for an inertial measurement unit that is integrated with a tri-axial magnetic sensor was exploited, the results of computer simulations and experimental testing show that the performance of the algorithm is good [10]. Because the extended Kalman filter method does not require more time consuming, it can be exploited in Wireless Local Area Network for indoor positioning [11], and the method combined with K-NN algorithm is also employed in indoor tracking [12]. In the field of applied electronics, Kalman filter even can be used to do the channel estimation and tracking method for the wireless OFDM systems [13].

State estimation is an important part of the Kalman filter. In the case of having random interference and noise, the linear minimum variance estimation method is used to calculate the best estimate of the states [14].

Kalman filter estimates the process state based on the feedback system consisting of time updates and status updates. The equations of this system are as follows.
                        
                           (1)
                           
                              
                                 
                                    
                                       x
                                       ∧
                                    
                                    k
                                    −
                                 
                                 =
                                 A
                                 *
                                 
                                    
                                       x
                                       ∧
                                    
                                    
                                       k
                                       −
                                       1
                                    
                                 
                                 +
                                 B
                                 *
                                 
                                    u
                                    
                                       k
                                       −
                                       1
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (2)
                           
                              
                                 
                                    P
                                    k
                                    ‐
                                 
                                 =
                                 A
                                 *
                                 
                                    P
                                    
                                       k
                                       ‐
                                       1
                                    
                                 
                                 *
                                 
                                    A
                                    T
                                 
                                 +
                                 Q
                              
                           
                        
                     
                     
                        
                           (3)
                           
                              
                                 
                                    K
                                    k
                                 
                                 =
                                 
                                    P
                                    k
                                    ‐
                                 
                                 *
                                 
                                    H
                                    T
                                 
                                 *
                                 
                                    
                                       
                                          H
                                          *
                                          
                                             P
                                             k
                                             ‐
                                          
                                          *
                                          
                                             H
                                             T
                                          
                                          +
                                          R
                                       
                                    
                                    
                                       −
                                       1
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (4)
                           
                              
                                 
                                    
                                       x
                                       ∧
                                    
                                    k
                                 
                                 =
                                 
                                    
                                       x
                                       ∧
                                    
                                    k
                                    −
                                 
                                 +
                                 
                                    K
                                    k
                                 
                                 *
                                 
                                    
                                       
                                          z
                                          k
                                       
                                       −
                                       H
                                       *
                                       
                                          
                                             x
                                             ∧
                                          
                                          k
                                          −
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (5)
                           
                              
                                 
                                    P
                                    k
                                 
                                 =
                                 
                                    
                                       I
                                       −
                                       
                                          K
                                          k
                                       
                                       *
                                       H
                                    
                                 
                                 *
                                 
                                    P
                                    k
                                    ‐
                                 
                              
                           
                        
                     
                  

Where, 
                        
                           
                              x
                              ^
                           
                           k
                           −
                        
                      is a priori state estimate of time k. 
                        
                           
                              x
                              ^
                           
                           
                              k
                              −
                              1
                           
                        
                      is a posteriori state estimate of time k. P
                     k
                     ‐ is a priori estimate error covariance of time k. P
                     k‐1 is a posteriori estimate error covariance of time k
                     −1. u
                     
                        k
                        −1 is an input control function of time k
                     −1. Q is a process noise covariance. The n
                     ∗
                     n matrix A is the state at time step k to the state at step k
                     +1, in the absence of either a driving function or process noise. The n
                     ∗
                     l matrix B relates the control input u to the state x. K
                     
                        k
                     , H, and R are measurement noise covariances. I is the identity matrix. z
                     
                        k
                      is the observed measurement of time k.

The time update equations can forward calculate the current state variables and error covariance estimates, which is for a priori estimate of the next time state. The measurement equation can combine priori estimates and new measurement variables to construct improved posteriori estimations. The time update equations make priori estimates to timely map to the measurement update equation. The measurement update equation corrects priori estimates to obtain posteriori estimations of the status. The time update equations can forward calculate the state estimation and covariance estimated from the time k
                     −1 to the time k.

If the relationship between estimated processes and measure processes is nonlinear, it can linearize the expectation and variance, which form an extended Kalman filter [14].

WSN can be used to monitor and track moving targets. There are two methods to establish hops when networks real-timely transfer the moving target information to the sink nodes. One is to establish routings fast. The other is to establish the routing between this node and sink node before the moving target reaching the feasible sensing nodes. The second approach needs to effectively predict the movement path of the target, so it can use the Kalman Filter to predict the position of the moving target in the next moment, with starting the corresponding node and establishing the hop through some routing algorithms.

Geographical Adaptive Fidelity (GAF) protocol can be adapted to the motion of nodes or target, but the energy saving effect is not good in the sparse network [15]. Taking into account energy conservations, Geographical and Energy Aware Routing (GEAR) protocol limit the information diffusion region within a smaller range to reduce the number of intermediate nodes and reduce the energy consumption of routing establishment and data transfer [16].

WSNs with random deployment of nodes or less accuracy deployment of nodes, due to empty holes in undeployed node regions, may result in failure of the network routing. Virtual position based Greedy-ViP method can solve this problem to some extent. It reflects the transmission direction of the adjacent nodes, and improves the success rate of the data routing in sparse network without improving significantly the computational costs [17,18].

The virtual coordinate of node N is the average of the coordinates of all adjacent neighbors within its communication radius. If the node N has a neighbor set of n, namely, V
                     
                        N
                     
                     ={V
                     
                        N,1(x
                     
                        N,1,y
                     
                        N,1),...
                     V
                     
                        N,n
                     (x
                     
                        N,n
                     ,y
                     
                        N,n
                     )}, where V
                     
                        N,i
                     (x
                     
                        N,i
                     ,y
                     
                        N,i
                     ), i
                     =1,2,⋯
                     n, is ith node of node N, (x
                     
                        N,i
                     ,y
                     
                        N,i
                     ) is its coordinate, then the virtual coordinates of node A can be expressed as Eq. (6) 
                     [18].
                        
                           (6)
                           
                              
                                 
                                    
                                       x
                                       A
                                       v
                                    
                                    
                                       y
                                       A
                                       v
                                    
                                 
                                 =
                                 
                                    1
                                    n
                                 
                                 
                                    
                                       ∑
                                       
                                          i
                                          =
                                          1
                                       
                                       n
                                    
                                    
                                       
                                          x
                                          
                                             A
                                             ,
                                             i
                                          
                                       
                                    
                                 
                                 
                                 ,
                                 
                                 
                                    1
                                    n
                                 
                                 
                                    
                                       ∑
                                       
                                          i
                                          =
                                          1
                                       
                                       n
                                    
                                    
                                       
                                          y
                                          
                                             A
                                             ,
                                             i
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                  

Greedy-based routing algorithm and Greedy-ViP-based routing algorithm will choose a different node as its hop handling the same area.

In this paper, take the Greedy and Greedy-ViP routing algorithm as examples, using the Kalman filter method to predict the position of moving objects, establishing the hop between the sensing nodes and sink nodes, transferring the sensing object information to the sink node.

According to the location information of the sensor node, it can make coordinate virtualized, and calculate the virtual coordinates of each node. Using the Kalman filter method and WSN routing, it can establish the optimal hop between the moving target and sink node. Specific steps are as follows.

Step1: Obtaining the location coordinates of the nodes in the region, (x
                     
                        i
                     ,y
                     
                        i
                     ),i
                     =1,2,⋯,M, where M is the number of nodes in the region.

Step2: Calculating the Euclidean distance between node i and node j, 
                        
                           d
                           
                              i
                              j
                           
                           =
                           
                              
                                 
                                    
                                       
                                          
                                             x
                                             i
                                          
                                          −
                                          
                                             x
                                             j
                                          
                                       
                                    
                                    2
                                 
                                 −
                                 
                                    
                                       
                                          
                                             y
                                             i
                                          
                                          −
                                          
                                             y
                                             j
                                          
                                       
                                    
                                    2
                                 
                              
                           
                        
                     , where i,j
                     =1,2,⋯,M, i
                     ≠
                     j. Establishing the distance matrix 
                        D
                     , δ
                     
                        i,j
                     
                     =
                     d(i,j). The matrix 
                        D
                      is positive symmetric definite matrix with the infinite main diagonal elements.

Step3: Calculating the virtual coordinates of node i according to Eq. (6).

Step4: Calculate the Euclidean distance between node i and node j virtual coordinates, 
                        
                           
                              d
                              v
                           
                           
                              i
                              j
                           
                           =
                           
                              
                                 
                                    
                                       
                                          
                                             x
                                             i
                                             v
                                          
                                          −
                                          
                                             x
                                             j
                                             v
                                          
                                       
                                    
                                    2
                                 
                                 −
                                 
                                    
                                       
                                          
                                             y
                                             i
                                             v
                                          
                                          −
                                          
                                             y
                                             j
                                             v
                                          
                                       
                                    
                                    2
                                 
                              
                           
                        
                     , where i,j
                     =1,2,⋯,M, i
                     ≠
                     j. Establishing the distance matrix D
                     
                        v
                      of virtual coordinates, δ
                     
                        i,j
                     
                     
                        v
                     
                     =
                     d
                     
                        v
                     (i,j). The matrix D
                     
                        v
                      is positive symmetric definite matrix with the infinite main diagonal elements.

Step5: Predicting the position of the moving target, according to the location, direction, speed of the current moving target, and the Kalman filter method. Finding the nearest node to the predicted position as a sensor node of moving target.

Step6: Establishing the hop between the sensor nodes and sink node, according to Greedy algorithm and Greedy-ViP algorithm.

Step7: Selecting the hop with least hops as the optimal hop. If the communication hops are the same, then select the hop with shortest length as the optimal hop.

If there are sparse numbers of nodes in a region, we can use Greedy and Greedy-ViP algorithm to jointly build multiple hops between the nodes and the sink nodes, for the network selection.
                        
                           (1)
                           Select the routing method with the least number of hops;

If the number of hops are the same, then select the hop with the shortest route.

Therefore, it can define Greedy-ViP optimal rate, namely, the ratio of the optimal hops by Greedy-ViP-based algorithm.

We randomly deployed nodes in the network area of 100∗100. The nodes deployed in the region are the same type. The node communication radius is 15. The number of nodes is increased from 50 to 300, increasing 10 per time. The starting node is in the lower-left corner of the region, and the destination node is in the upper-right corner of the region. The two methods to establish the hop are shown in Fig. 1
                     , when 200 nodes randomly deployed in the region. It can be seen that the hops established by the two algorithms are different.

The routing success rate and the Greedy-ViP optimal rate are different when the communication distance and node density are different. With a large number of experiments, the result is shown in Table 1
                     .

The relationship among the number of nodes deployed in the region, the distance between the starting node and the destination node, and the routing success rate are shown in Fig. 2
                     .

As can be seen from Fig. 2, it is difficult to establish the route when the distance between two nodes is long. As the node density increases, the routing success rate increases also. However, the distance between the starting node and destination node slightly influences the routing success rate, when the node density is larger. The reason is that each hop of multi-hop routing path has a probability of success and failure, and the success rate of the total hop is a conditional probability. Therefore, the path hops decrease and the success rate of the total hop increases, when the distance between the starting node and destination node is shorter. If the node density becomes large, the number of adjacent nodes in the node's communication radius increases and the success probability of each jump increases. So, the success rate of the total hop increases also. If node density is more than 200, the influence of the distance can be ignored.

The relationship among the number of nodes deployed in the region, the distance between the starting node and the destination node, and the Greedy-ViP optimal rate are shown in Fig. 3
                     .

It can be seen that the hop length has less effect on Greedy-ViP optimal rate. If the node density is less than 150, the Greedy-ViP optimal rate is greater than 50%, indicating that Greedy-ViP algorithm outperforms the Greedy algorithm when the nodes are spare. If the node density is greater than 150, Greedy-ViP optimal rate is higher when the distance between the start node and the destination node is greater. However, it is better to choose the route established by the Greedy algorithm as its hop when Greedy-ViP optimal rate is less than 50%.

A large number of experiments show that the two algorithms have low probability of successfully establishing route for multi-hop, when the number of nodes in the region is less than 80. It is better to choose the Greedy-ViP algorithm to establish route, when the probability of successfully establishing route is about 65%, and when the number of nodes in the region is around 90. It is better to choose the Greedy algorithm to establish route, when the probability of successfully establishing route is approximately 95%, and when the number of nodes in the region is above 150.

However, the success rates of the Greedy algorithm and Greedy-ViP algorithm to establish route have little difference, when the node density in the region reaches a certain level, such that the node density is about 290. If the node density in the region reached 390 or more, the two algorithms have no obvious difference. Because the Greedy-ViP algorithm is more complex than the Greedy algorithm, it is better to select the Greedy algorithm in this condition.

In the simulation of location prediction of moving target based on the Kalman filter, we set the speed of the moving target fixed and initially set the motion path, so that the coordinates of moving node have a certain relation with the time. The relationship between the X-axis and the Y-axis coordinates of location of moving node is shown as Eq. (7).
                        
                           (7)
                           
                              
                                 Y
                                 =
                                 −
                                 0.00005
                                 
                                    X
                                    4
                                 
                                 +
                                 0.0015
                                 
                                    X
                                    3
                                 
                                 −
                                 0.1235
                                 
                                    X
                                    2
                                 
                                 +
                                 3.875
                                 X
                                 +
                                 3.9123
                              
                           
                        
                     
                  

If the system noise factor is set to 1, 1.5, 2, 2.5, 3, 4, 5, the relationship among real movement route, Kalman filter estimation and smoothed estimation of moving target is shown in Fig. 4
                     .

As can be seen from Fig. 4, the real movement route of the moving target is a smooth curve. In the part with smaller curvature of the real route, the route predicted by the Kalman filter is smooth and approximates the real route. However, in the part with greater curvature of the real route, the route predicted by the Kalman filter is a polyline and is large different from the real route. The reason is that the Kalman filter is a linear prediction method and the prediction performance of the curve line is poor. By smoothing the Kalman filter prediction, the result is very close to the real route.

The relationship between system errors and interference noise of the Kalman filter is shown in Table 2
                      and Fig. 5
                     .

We randomly deployed 200 nodes in the network area of 100∗100, including four sink nodes, whose coordinates are (0, 100), (100, 0), (200, 100), and (100,200). The route of the moving target is in keeping with Eq. (7). At some point, we make the nearest node to the moving target as the information collection node, use the Greedy algorithm and Greedy-ViP algorithm to establish the hop, and adopt the Kalman filter method to predict the location of the moving target. The experimental result is shown in Fig. 6
                     .

As can be seen from Fig. 6, the vast majority of locations of the information collection nodes predicted by the Kalman filtering method match the real information collection nodes. The error between Kalman filtering prediction route and the real route is large, in the place with large curvature. However, it has little influence on selecting the nearest information collection nodes. So the Kalman filter can be used to predict the locations of information collection nodes.

The location of each information collection node, corresponding hop between the information collection node and sink node is shown in Table 3
                     .

It can successfully establish the hop at each node. The hop tends to a straight line, and the hops are minimum between the information collection node and sink node. Low repetition rate of the nodes on different hops makes communication energy consumption of network nodes tend to balance.

Environment resources data monitoring and management system can realize functions of data reception, data analysis, and information release and also manage user database and knowledge base. We employed a management system in ground environment monitoring experiments. The system mainly consists of the following subsystems.

Remote monitoring subsystem can be able to receive and store data collected by sensor network. It can also control and maintain remote monitoring equipments. This subsystem can be divided into five modules.

Data reception: receive sensor data. Each node collects 8 environment parameters and system voltage, and current power. The sensor data are shown in Table 4
                        .

Data storage: store collected data and provide a simple data browser.

Terminal controlling: configure parameters for sensor nodes. Managers can control each sensor node's working status, such as decision of camera angle, data acquiring period and so on. Table 4 compares the sensor data collected at different times in the same node (the inner IP address is 10.01.00.28). The collected time is 03:01:07 and 03:16:07 respectively on April 15th. Fig. 7
                         shows the collected images of the same node in different angles.

Terminal fault management: record and process equipment failures.

Information security management module: by end-to-end message encryption, prevent information be intercepted.

The development environment of this subsystem is MySql+Apache+PHP. This subsystem consists of three modules which are project affairs management module; storage and query of environment resources information module and GIS-based data analysis module.

Combined with GIS technology this module shows the information of each monitoring point. And each point represents a sensor node in the monitoring field. We can directly click each monitoring point to view their collected data. The module invokes data from database and then displays the corresponding information according to users' needs. It can also provide early warning and decision-making results after the specific calculation in model library. The specific functions are as follows:
                              
                                 (1)
                                 Information display and query:

Display the monitoring regional map. When clicked on a monitoring point, it will pop up a small window showing the location and collected information of the corresponding sensor node. The information types include numeric data, images and video.
                              
                                 (2)
                                 Remote alarm:

When a monitoring data exceeds the early warning boundary, the system will automatically send SMS or e-mail to platform users.

This section is developed using mapabc Ajax API interface with Flash showing effect and the development language is Javascript. When clicked on a monitoring point, it will show its location and the corresponding links of the point's monitoring information, images and video information shown as Fig. 8
                           .

In addition to the display and query capabilities, in the next step the system will do some statistical analysis and model analysis.

The statistical analysis based on time dimension means analyzing sensor data of one node collected in different times. Fig. 9
                            shows the collected data in different times. The monitoring data is consistent with the actual data just as the temperature shown in the following figure.


                           Fig. 10
                            shows data acquiring from different nodes in 2012.4.17, 10:30. All these data show the actual situation in monitoring area.

According to above comparisons, we can do further analysis with environment models. Comparing monitoring data of different nodes, we can find a more suitable environment condition. These works need to combine with related knowledge and we should be improved in this regard.

Considering the environment monitoring data communication needs and the intrinsic property of the WSNs this paper presents the WSN hop optimization design method, based on monitoring object characteristics integrated with database technologies, and has high targeted application background. The wireless sensor routing algorithms and improvements are variety. In this paper, a WSN dynamic hop establishment method, based on the moving target Kalman prediction, Greedy algorithm and Greedy-ViP algorithm, is proposed. Simulation results demonstrate that the predicted information collection node locations by the proposed method are consistent with the majority of real information collection node locations, the hops established by Greedy and Greedy-ViP algorithm tend to a straight line, and the communication hop count between the data collection node and the sink node is the least. Low repetition rate of the nodes on different hops makes communication energy consumption of network nodes tend to balance. The proposed method can effectively improve the performance and efficiency of the WSN.

@&#ACKNOWLEDGEMENT@&#

This work was supported in part by the National Natural Science Foundation of China (Grant No. 51104157), the Ph.D. Programs Foundation of Ministry of Education of China (Grant No. 20110095120008), the China Postdoctoral Science Foundation (Grant No. 20100481181), the Fundamental Research Funds for the Central Universities (Grant No. 2011QNA30), and Jiangsu Overseas Research & Training Program for University Prominent Young & Middle-aged Teachers and Presidents.

@&#REFERENCES@&#

