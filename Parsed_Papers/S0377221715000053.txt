@&#MAIN-TITLE@&#A parallelised distributed implementation of a Branch and Fix Coordination algorithm

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Large-scale stochastic mixed-integer programming (SMIP) instances are hard to solve.


                        
                        
                           
                           Branch and Fix Coordination (BFC) algorithm can solve such SMIP instances.


                        
                        
                           
                           The decomposition appears to play an important role.


                        
                        
                           
                           Parallelizing BFC obtains solutions in instances than commercial solvers do not.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Stochastic mixed-integer problems

Branch and fix coordination algorithm

Parallel programming

@&#ABSTRACT@&#


               
               
                  Branch and Fix Coordination is an algorithm intended to solve large scale multi-stage stochastic mixed integer problems, based on the particular structure of such problems, so that they can be broken down into smaller subproblems. With this in mind, it is possible to use distributed computation techniques to solve the several subproblems in a parallel way, almost independently. To guarantee non-anticipativity in the global solution, the values of the integer variables in the subproblems are coordinated by a master thread. Scenario ‘clusters’ lend themselves particularly well to parallelisation, allowing us to solve some problems noticeably faster. Thanks to the decomposition into smaller subproblems, we can also attempt to solve otherwise intractable instances. In this work, we present details on the computational implementation of the Branch and Fix Coordination algorithm.
               
            

@&#INTRODUCTION@&#

Many infrastructure problems nowadays are solved using optimisation and equilibrium models (Li, Gabriel, Shim, and Azarm, 2011; Rømo et al., 2009). These problems often imply handling investments, which can be represented by yes/no decisions (“Should a pipeline be built or not?”) and modelled with binary variables. Mixed Integer Programming problems (MIPs), and specially those containing binary variables, are common in problems of transportation (Christiansen, Fagerholt, and Ronen, 2004), energy (Wallace and Fleten, 2003), real-state, etc. In these cases, strategic investment decisions influence a project’s development over long timespans. For example, expensive building projects induce costs and deliver returns for many years after the decision of building was made. Once built, under-utilisation impacts the economic prospects of the project.

Dealing with these long-lasting investments in the real world, almost invariably, involves uncertainty in the parameters of the model we are trying to create. Prices, supplies and consumptions might differ significantly from estimates, unexpected events could make these estimates imprecise, or new legislation can turn once attractive investment into expensive ones (Alonso-Ayuso, Escudero, and Ortuño, 2003; Kall and Wallace, 1994).

Uncertainty, therefore, further complicates already hard-to-solve MIPs with the introduction of additional variables/parameters: MIPs are complex because of the large number of combinatorial choices they imply; stochastic problems are complicated because of the amount of scenarios they involve if a lot of variability happens over long time spans. As a result, stochastic MIPs are likely to result in complex problems, even while working exclusively with linear constraints (SMILPs).

In view of this, the Branch and Fix Coordination (BFC) algorithm was developed to tackle a certain class of SMILPs, namely, those in which both integer and continuous variables appear in (generally) every stage of the problem, all integer variables are binary, and no multi-scenario constraints appear (Alonso-Ayuso et al., 2003; Escudero, Garín, Merino, and Pérez, 2010b). BFC is based on the well-known Branch and Bound (B&B) algorithm, with the main difference that the search tree evaluates many subproblems at each step, and the decisions to branch, prune or bound are done taking all subproblems into consideration. The first version of the BFC was developed by the groups of Alonso-Ayuso et al. (2003) to take advantage of scenario-wise decomposition schemes for solving special cases of two-stage SMILPs (for more applications see also Escudero, Garín, Merino, and Pérez, 2007; 2009b; 2010a). The algorithm was generalised to multi-stage SMILPs with binary and continuous variables in any stage (Escudero, Garín, Merino, and Pérez, 2009a; 2009c; Escudero et al., 2010b). Further refinements such as the parallelisation of the algorithm or contemplating explicitly non-symmetric trees have proven to be successful in reducing running times (Aldasoro, Escudero, Merino, and Pérez, 2013; Escudero, Garín, Merino, and Pérez, 2012).

In this paper, we present a particular implementation of the BFC routine, which uses parallel processing to solve many subproblems at the same time in a way that makes the process arguably faster and more efficient. The resulting application is able to solve problems with dimensions which are orders of magnitude larger than those reported in past papers, and also coordinating significantly more clusters and variables without apparent loss of efficiency. Moreover, this implementation improves over the existing ones with added flexibility (allowing for more branching options and data storage), as well as doing away with some bounding strategies in favour of looser but faster searches.

The framework currently in place allows for a mostly seamless transition into solving fully-decomposed problems, which can then be stored in several files without the need to load the full problem anywhere in the solution process.

The paper is organised as follows: first, we present some formulations useful for the description of the algorithm in Section 2. After that, in Section 3, we state the problems needed to be solved at several steps of this particular BFC implementation, which is itself described in Section 4, along with some details on the parallelisation we use. Later in Section 5, we show several problem instances, whose analysis suggests that BFC is competitive when compared to commercial MIP solvers.

Consider the Deterministic Equivalent Model (DEM) of a stochastic mixed integer linear programming problem with only binary and continuous variables X, Y, and its matrix form, [AX + BY]. For most SMILPs, we can easily identify blocks in these matrices that represent constraints specific to a scenario tree node, or constraints that link one node in the tree to its parent nodes, children nodes, and so on. We can use this idea of blocks, and the constraints and variables they involve, to represent different variations of the problem by indexing sections of the constraint matrices which have special interest to us with a set of nodes which in turn corresponds to a row of blocks in the matrix.

                        
                           
                              
                                 
                                    [
                                    
                                       
                                          
                                             
                                                A
                                                
                                                   G
                                                   1
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                                A
                                                
                                                   G
                                                   2
                                                
                                             
                                          
                                       
                                       
                                          
                                             ⋮
                                          
                                       
                                    
                                    ]
                                 
                                 X
                                 +
                                 
                                    [
                                    
                                       
                                          
                                             
                                                B
                                                
                                                   G
                                                   1
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                                B
                                                
                                                   G
                                                   2
                                                
                                             
                                          
                                       
                                       
                                          
                                             ⋮
                                          
                                       
                                    
                                    ]
                                 
                                 Y
                              
                           
                        
                     
                  

Suppose 
                        G
                      is the set of all nodes g of a (not necessarily symmetric) scenario tree, and 
                        
                           G
                           2
                        
                      the set of all subsets of 
                        G
                      (i.e. its power set). Further, let 
                        
                           G
                           1
                        
                      be the subset of one-element sets in 
                        
                           
                              G
                              2
                           
                           ,
                        
                      i.e., 
                        
                           
                              G
                              1
                           
                           
                              :
                              =
                              {
                              m
                              ∈
                           
                           
                              G
                              2
                           
                           
                              :
                              |
                              m
                              |
                              =
                              1
                              }
                           
                        
                     ; clearly, there is a one-to-one correspondence between the nodes in 
                        G
                      and the sets in 
                        
                           G
                           1
                        
                     .

At each node g, we have binary variables x
                     
                        g, i
                      and continuous variables y
                     
                        g, j
                     . We use the paired sets of indices 
                        
                           
                              I
                              g
                           
                           ,
                           
                              J
                              g
                           
                        
                      so that 
                        
                           
                              X
                              g
                           
                           =
                           
                              {
                              
                                 x
                                 
                                    g
                                    ,
                                    i
                                 
                              
                              :
                              i
                              ∈
                              
                                 I
                                 g
                              
                              }
                           
                        
                      and 
                        
                           
                              Y
                              g
                           
                           =
                           
                              {
                              
                                 y
                                 
                                    g
                                    ,
                                    j
                                 
                              
                              :
                              j
                              ∈
                              
                                 J
                                 g
                              
                              }
                           
                           ,
                        
                      and in turn 
                        
                           X
                           =
                           {
                           
                              X
                              g
                           
                           :
                           g
                           ∈
                           G
                           }
                           ,
                        
                      and 
                        
                           Y
                           =
                           {
                           
                              Y
                              g
                           
                           :
                           g
                           ∈
                           G
                           }
                        
                     .

First, let us present a simplified formulation of a general stochastic problem in compact formulation. Here, we only differentiate between groups of constraints that (a) affect variables belonging to one node, or (b) affect in general all variables (for example, recourse constraints, among others). We then index each set of rows using either the set 
                        
                           G
                           ∈
                           
                              G
                              1
                           
                        
                      corresponding to the node the set of rows involves, or the entire node set 
                        G
                     . This gives AG
                      and BG
                     , for each 
                        
                           G
                           ∈
                           
                              G
                              1
                           
                           ∪
                           
                              {
                              G
                              }
                           
                           ,
                        
                      in which each G is a member of a set of sets. The DEM of this problem is

                        
                           (1a)
                           
                              
                                 min:
                                 
                                 f
                                 
                                    (
                                    X
                                    ,
                                    Y
                                    )
                                 
                                 =
                                 
                                    ∑
                                    
                                       g
                                       ∈
                                       G
                                    
                                 
                                 
                                    w
                                    g
                                 
                                 
                                    (
                                    
                                       
                                          a
                                          g
                                       
                                       
                                          X
                                          g
                                       
                                       +
                                       
                                          b
                                          g
                                       
                                       
                                          Y
                                          g
                                       
                                    
                                    )
                                 
                              
                           
                        
                     
                     
                        
                           (1b)
                           
                              
                                 s.t.
                                 
                                 
                                    A
                                    G
                                 
                                 X
                                 +
                                 
                                    B
                                    G
                                 
                                 Y
                                 ≤
                                 
                                    C
                                    G
                                 
                                 ,
                                 
                                 G
                                 ∈
                                 
                                    G
                                    1
                                 
                                 ∪
                                 
                                    {
                                    G
                                    }
                                 
                                 ;
                              
                           
                        
                     
                     
                        
                           (1c)
                           
                              
                                 
                                    x
                                    
                                       g
                                       ,
                                       i
                                    
                                 
                                 ∈
                                 
                                    {
                                    0
                                    ,
                                    1
                                    }
                                 
                                 ,
                                 
                                 i
                                 ∈
                                 
                                    I
                                    g
                                 
                                 ,
                                 g
                                 ∈
                                 G
                                 ;
                              
                           
                        
                     
                     
                        
                           (1d)
                           
                              
                                 
                                    y
                                    
                                       g
                                       ,
                                       j
                                    
                                 
                                 ∈
                                 R
                                 ,
                                 
                                 j
                                 ∈
                                 
                                    J
                                    g
                                 
                                 ,
                                 g
                                 ∈
                                 G
                                 ;
                              
                           
                        
                     
                  

with properly defined weights wg
                      for each node.

In problem (1), all constraints which affect the variables of more than one node of the scenario tree appear as 
                        
                           
                              A
                              G
                           
                           X
                           +
                           
                              B
                              G
                           
                           Y
                           ≤
                           
                              C
                              G
                           
                        
                      in expression (1b). However, they do not necessarily need to be aggregated like this. By using this indexing idea, we can just as easily group nodes into relevant sets which correspond to scenarios, or to groups of scenarios, or to stages in the scenario tree, and use these sets to index parts of the constraint matrices. This helps us to write different formulations and variations of a SMILP DEM in a condensed notation.

Let 
                        
                           S
                           i
                        
                      be the set of nodes g which belong to stage i (i.e. 
                        
                           S
                           1
                        
                      contains only the root node(s), 
                        
                           S
                           2
                        
                      contains the immediate children to the root nodes, and so on). If the tree has S stages, make 
                        
                           S
                           =
                           {
                           
                              S
                              1
                           
                           ,
                           ⋯
                           ,
                           
                              S
                              S
                           
                           }
                        
                      the family of all stage sets. Also, for the set of leaf nodes 
                        
                           g
                           ∈
                           
                              S
                              S
                           
                           ,
                        
                      create a partition 
                        
                           L
                           =
                           {
                           
                              L
                              c
                           
                           }
                        
                      so that all nodes in a given 
                        
                           L
                           c
                        
                      have a common root. This makes it possible to define a cluster 
                     (Escudero, Garín, Merino, and Pérez, 2010a) as we use it in this work:

                        Definition 1
                        Cluster


                        For each element 
                              
                                 
                                    L
                                    c
                                 
                                 ∈
                                 L
                                 ,
                              
                            a cluster 
                              
                                 C
                                 c
                              
                            is a set of nodes which contains all elements of 
                              
                                 L
                                 c
                              
                            and their parent nodes up to the root. Then 
                              
                                 C
                                 =
                                 {
                                 
                                    C
                                    c
                                 
                                 }
                              
                            is the set of all clusters in a scenario tree.

With the families 
                        S
                      and 
                        C
                      thus defined, we can write constraints for all the nodes in one stage, or all the nodes of one scenario, or all the nodes in a given set of scenarios, and index them with sets regardless of the formulation chosen for the model.

For example, if we consider the stochastic scenario tree in Fig. 1
                     a, the set of nodes will be 
                        
                           G
                           =
                           {
                           
                              g
                              1
                           
                           ,
                           ⋯
                           ,
                           
                              g
                              6
                           
                           }
                           ,
                        
                      and consequently 
                        
                           
                              G
                              1
                           
                           =
                           
                              {
                              
                                 {
                                 
                                    g
                                    1
                                 
                                 }
                              
                              ,
                              ⋯
                              ,
                              
                                 {
                                 
                                    g
                                    6
                                 
                                 }
                              
                              }
                           
                        
                     .

The only possible cluster for this tree is 
                        
                           C
                           =
                           {
                           
                              {
                              
                                 g
                                 1
                              
                              ,
                              
                                 g
                                 2
                              
                              ,
                              ⋯
                              ,
                              
                                 g
                                 6
                              
                              }
                           
                           }
                           ,
                        
                      with 
                        
                           S
                           =
                           {
                           
                              {
                              
                                 g
                                 1
                              
                              }
                           
                           ,
                           
                              {
                              
                                 g
                                 2
                              
                              ,
                              
                                 g
                                 3
                              
                              }
                           
                           ,
                           
                              {
                              
                                 g
                                 4
                              
                              ,
                              
                                 g
                                 5
                              
                              ,
                              
                                 g
                                 6
                              
                              }
                           
                           }
                        
                     . In this manner, the formulation would be equivalent to that in problem (1).

On the other hand, if we define a different set of nodes 
                        
                           G
                           =
                           {
                           
                              g
                              1
                           
                           ,
                           ⋯
                           ,
                           
                              g
                              9
                           
                           }
                           ,
                        
                      such as the ones shown in Fig. 1b, with 
                        
                           S
                           =
                           {
                           
                              {
                              
                                 g
                                 1
                              
                              ,
                              
                                 g
                                 2
                              
                              ,
                              
                                 g
                                 3
                              
                              }
                           
                           ,
                           
                              {
                              
                                 g
                                 4
                              
                              ,
                              
                                 g
                                 5
                              
                              ,
                              
                                 g
                                 6
                              
                              }
                           
                           ,
                           
                              {
                              
                                 g
                                 7
                              
                              ,
                              
                                 g
                                 8
                              
                              ,
                              
                                 g
                                 9
                              
                              }
                           
                           }
                        
                      and 
                        
                           C
                           =
                           {
                           
                              {
                              
                                 g
                                 1
                              
                              ,
                              
                                 g
                                 4
                              
                              ,
                              
                                 g
                                 7
                              
                              }
                           
                           ,
                           
                              {
                              
                                 g
                                 2
                              
                              ,
                              
                                 g
                                 5
                              
                              ,
                              
                                 g
                                 8
                              
                              }
                           
                           ,
                           
                              {
                              
                                 g
                                 3
                              
                              ,
                              
                                 g
                                 6
                              
                              ,
                              
                                 g
                                 9
                              
                              }
                           
                           }
                        
                      being the only possible set of clusters, we can formulate the split-variable formulation of (1), MP1, once we define 
                        A
                      as 
                        
                           A
                           =
                           {
                           
                              {
                              
                                 g
                                 1
                              
                              ,
                              
                                 g
                                 2
                              
                              ,
                              
                                 g
                                 3
                              
                              }
                           
                           ,
                           
                              {
                              
                                 g
                                 4
                              
                              ,
                              
                                 g
                                 5
                              
                              }
                           
                           }
                        
                      as the set of all (non-trivial) non-anticipativity classes of equivalence. Notice that the weights wg
                      should be modified accordingly for the problems to be equivalent.

                        
                           (2a)
                           
                              
                                 
                                    
                                       
                                          MP
                                          1
                                       
                                    
                                    
                                       :
                                    
                                    
                                       
                                    
                                 
                                 
                                    
                                       min
                                    
                                    
                                       :
                                    
                                    
                                       
                                          f
                                          
                                             (
                                             X
                                             ,
                                             Y
                                             )
                                          
                                          =
                                          
                                             ∑
                                             
                                                g
                                                ∈
                                                G
                                             
                                          
                                          
                                             w
                                             g
                                          
                                          
                                             (
                                             
                                                
                                                   a
                                                   g
                                                
                                                
                                                   X
                                                   g
                                                
                                                +
                                                
                                                   b
                                                   g
                                                
                                                
                                                   Y
                                                   g
                                                
                                             
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (2b)
                           
                              
                                 s.t.
                                 
                                 
                                    A
                                    G
                                 
                                 X
                                 +
                                 
                                    B
                                    G
                                 
                                 Y
                                 ≤
                                 
                                    C
                                    G
                                 
                                 ,
                                 
                                 G
                                 ∈
                                 C
                                 ∪
                                 
                                    G
                                    1
                                 
                                 ∪
                                 S
                                 ;
                              
                           
                        
                     
                     
                        
                           (2c)
                           
                              
                                 
                                    X
                                    g
                                 
                                 =
                                 
                                    X
                                    h
                                 
                                 ,
                                 
                                    Y
                                    g
                                 
                                 =
                                 
                                    Y
                                    h
                                 
                                 ,
                                 
                                 ∀
                                 g
                                 ,
                                 h
                                 ∈
                                 
                                    A
                                    n
                                 
                                 ,
                                 
                                    A
                                    n
                                 
                                 ∈
                                 A
                                 ;
                              
                           
                        
                     
                     
                        
                           (2d)
                           
                              
                                 
                                    x
                                    
                                       g
                                       ,
                                       i
                                    
                                 
                                 ∈
                                 
                                    {
                                    0
                                    ,
                                    1
                                    }
                                 
                                 ,
                                 
                                 i
                                 ∈
                                 
                                    I
                                    g
                                 
                                 ,
                                 g
                                 ∈
                                 G
                                 ;
                              
                           
                        
                     
                     
                        
                           (2e)
                           
                              
                                 
                                    y
                                    
                                       g
                                       ,
                                       j
                                    
                                 
                                 ∈
                                 R
                                 ,
                                 
                                 j
                                 ∈
                                 
                                    J
                                    g
                                 
                                 ,
                                 g
                                 ∈
                                 G
                                 .
                              
                           
                        
                     
                  

Formulation MP1 is flexible enough to describe both the usual stochastic formulations, but also to describe formulations in between those, such as that shown in Fig. 1c. For large scenario trees, there are as many such possible mixed formulations (analogous to the splitting-compact representation used in Escudero et al., 2010a), as stages in the tree.

The definitions of families 
                        
                           L
                           ,
                        
                     
                     
                        A
                      and, more important to us, 
                        
                           C
                           ,
                        
                      are closely linked to the selection of a break stage (effectively equivalent to that in Escudero et al., 2012 for most scenario trees).

                        Definition 2
                        Break stage


                        For a given DEM, we define stage s* as the break stage of the problem if s* is the earliest stage in which no node g in s* or any latter stage is subject to non-anticipativity constraints (NACs) in order to be equivalent to the compact formulation (e.g. a formulation with s* = 1 is equivalent to the compact formulation).

A variable x
                           
                              g, i
                            (y
                           
                              g, j
                           ), where 
                              
                                 i
                                 ∈
                                 
                                    I
                                    g
                                 
                              
                            (
                              
                                 j
                                 ∈
                                 
                                    J
                                    g
                                 
                              
                           ), is said to be coordinated 
                              1
                           
                           
                              1
                              This concept is related to the common variables defined in Escudero et al. (2010b). In some contexts, however, there might be common but non-coordinated variables, hence the distinction made here.
                            if 
                              
                                 g
                                 ∈
                                 
                                    S
                                    s
                                 
                                 ,
                                 s
                                 <
                                 
                                    s
                                    *
                                 
                              
                           .

Formulation MP1 represents the tree in Fig. 1c, with a break stage s* = 2, and consequently 
                        
                           S
                           =
                           {
                           
                              {
                              
                                 g
                                 1
                              
                              ,
                              
                                 g
                                 2
                              
                              }
                           
                           ,
                           
                              {
                              
                                 g
                                 3
                              
                              ,
                              
                                 g
                                 4
                              
                              }
                           
                           ,
                        
                      {g
                     5, g
                     6, g
                     7}}, 
                        
                           C
                           =
                           {
                           
                              {
                              
                                 g
                                 1
                              
                              ,
                              
                                 g
                                 3
                              
                              ,
                              
                                 g
                                 5
                              
                              ,
                              
                                 g
                                 6
                              
                              }
                           
                           ,
                        
                      {g
                     2, g
                     4, g
                     7}}, and the NAC classes as 
                        
                           A
                           =
                           {
                           
                              {
                              
                                 g
                                 1
                              
                              ,
                              
                                 g
                                 2
                              
                              }
                           
                           }
                        
                     .

The choice of the break stage determines which stages have explicit NACs (stages 1 through s* − 1) and which are handled implicitly using a compact formulation. Moreover, the selection of the break stage is important for the computational implementation of the BFC algorithm. It determines the number of subproblems we will solve, simultaneously, and the size thereof. The impact of this is well-discussed in Escudero et al. (2010b), where the optimal partition of the tree is analysed for a particular-serial-computational implementation of the algorithm. As we argue in the results section, the break stage and the resulting decomposition affect the quality of the bounds obtained and the effective speed at which we can solve subproblems (see also Escudero et al., 2010a for further comparisons). This sometimes makes a given problem dramatically faster to solve with a particular decomposition than with another one.

While solving a problem using BFC, several versions and/or parts of said problem require solving in order to calculate candidate solutions and bounds. These include both individual clusters’ problems and various relaxed versions of the total DEM. For this section, as well as all experiments, we assume the problem models and instances are devoid of all multi-scenario constraints except for the NACs.

The subproblems corresponding to each cluster are independent except for the existence of the NACs. Though variables from all clusters interact in the objective function, the assumption of linearity guarantees separability. In view of this, by relaxing all NACs in a particular (mixed) formulation, we can create 
                           
                              |
                              C
                              |
                           
                         independent subproblems which can be solved as:

                           
                              (3a)
                              
                                 
                                    
                                       
                                          
                                             CP
                                             
                                                1
                                                c
                                             
                                          
                                       
                                       
                                          :
                                       
                                       
                                          
                                       
                                    
                                    
                                       
                                          min
                                       
                                       
                                          :
                                       
                                       
                                          
                                             
                                                f
                                                c
                                             
                                             
                                                (
                                                X
                                                ,
                                                Y
                                                )
                                             
                                             =
                                             
                                                ∑
                                                
                                                   g
                                                   ∈
                                                   
                                                      C
                                                      c
                                                   
                                                
                                             
                                             
                                                w
                                                g
                                             
                                             
                                                (
                                                
                                                   
                                                      a
                                                      g
                                                   
                                                   
                                                      X
                                                      g
                                                   
                                                   +
                                                   
                                                      b
                                                      g
                                                   
                                                   
                                                      Y
                                                      g
                                                   
                                                
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (3b)
                              
                                 
                                    s.t.
                                    
                                    
                                       A
                                       G
                                    
                                    X
                                    +
                                    
                                       B
                                       G
                                    
                                    Y
                                    ≤
                                    
                                       C
                                       G
                                    
                                    ,
                                    
                                    G
                                    ∈
                                    
                                       G
                                       c
                                       1
                                    
                                    ∪
                                    
                                       C
                                       c
                                    
                                    ;
                                 
                              
                           
                        
                        
                           
                              (3c)
                              
                                 
                                    
                                       x
                                       
                                          g
                                          ,
                                          i
                                       
                                    
                                    ∈
                                    
                                       {
                                       0
                                       ,
                                       1
                                       }
                                    
                                    ,
                                    
                                    i
                                    ∈
                                    
                                       I
                                       g
                                    
                                    ,
                                    g
                                    ∈
                                    
                                       C
                                       c
                                    
                                    ;
                                 
                              
                           
                        
                        
                           
                              (3d)
                              
                                 
                                    
                                       y
                                       
                                          g
                                          ,
                                          j
                                       
                                    
                                    ∈
                                    R
                                    ,
                                    
                                    j
                                    ∈
                                    
                                       J
                                       g
                                    
                                    ,
                                    g
                                    ∈
                                    
                                       C
                                       c
                                    
                                    ;
                                 
                              
                           
                        
                     

where, to avoid ambiguity, we put 
                           
                              
                                 G
                                 c
                                 1
                              
                              =
                              
                                 {
                                 G
                                 ∈
                                 
                                    G
                                    1
                                 
                                 :
                                 G
                                 ∩
                                 
                                    C
                                    c
                                 
                                 ≠
                                 ∅
                                 }
                              
                           
                        .

It generally happens that, at a given point in the BFC solution process, some of the binary variables x
                        
                           g, i
                         will be fixed or even relaxed in one or more nodes belonging to one or more clusters. To express this, we define paired sets of indices for nodes and variables with some fixing, 
                           
                              (
                              
                                 G
                                 f
                              
                              ,
                              
                                 I
                                 g
                                 f
                              
                              )
                              ,
                           
                         with 
                           
                              
                                 G
                                 f
                              
                              ⊆
                              G
                           
                         and 
                           
                              
                                 I
                                 g
                                 f
                              
                              ⊆
                              
                                 I
                                 g
                              
                           
                         for some 
                           
                              g
                              ∈
                              
                                 G
                                 f
                              
                              ,
                           
                         and identically for pairs 
                           
                              (
                              
                                 G
                                 r
                              
                              ,
                              
                                 I
                                 g
                                 r
                              
                              )
                           
                         for relaxed binary variables and 
                           
                              (
                              
                                 G
                                 b
                              
                              ,
                              
                                 I
                                 g
                                 b
                              
                              )
                           
                         for non-fixed, non-relaxed binary variables. If we define 
                           
                              
                                 
                                    H
                                 
                                 f
                              
                              =
                              
                                 {
                                 
                                    (
                                    g
                                    ,
                                    i
                                    )
                                 
                                 :
                                 g
                                 ∈
                                 
                                    G
                                    f
                                 
                                 ,
                                 i
                                 ∈
                                 
                                    I
                                    g
                                    f
                                 
                                 }
                              
                           
                         for the fixed variables (and analogously 
                           
                              
                                 
                                    H
                                 
                                 r
                              
                              ,
                              
                                 
                                    H
                                 
                                 b
                              
                           
                         for the relaxed and binary variables), then, for cluster c, 
                           2
                        
                        
                           2
                           Because a B&B node can have all fixed, relaxed and binary variables, sets 
                                 
                                    
                                       G
                                       r
                                    
                                    ,
                                    
                                       G
                                       f
                                    
                                 
                               and 
                                 
                                    G
                                    b
                                 
                               are not necessarily disjoint. However, since a given pair (g, i) represents one specific variable in the problem, which can only be in one of the three states, sets 
                                 
                                    
                                       
                                          H
                                       
                                       f
                                    
                                    ,
                                    
                                       
                                          H
                                       
                                       r
                                    
                                    ,
                                    
                                       
                                          H
                                       
                                       b
                                    
                                 
                               are mutually disjoint.
                         the subproblem to be solved is:

                           
                              (4a)
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   CP
                                                   2
                                                
                                                c
                                             
                                             
                                                (
                                                
                                                   
                                                      H
                                                   
                                                   f
                                                
                                                ,
                                                
                                                   
                                                      H
                                                   
                                                   r
                                                
                                                ,
                                                
                                                   
                                                      H
                                                   
                                                   b
                                                
                                                )
                                             
                                          
                                       
                                       
                                          :
                                       
                                       
                                          
                                       
                                    
                                    
                                       
                                          min
                                       
                                       
                                          :
                                       
                                       
                                          
                                             
                                                f
                                                c
                                             
                                             
                                                (
                                                X
                                                ,
                                                Y
                                                )
                                             
                                             =
                                             
                                                ∑
                                                
                                                   g
                                                   ∈
                                                   
                                                      C
                                                      c
                                                   
                                                
                                             
                                             
                                                w
                                                g
                                             
                                             
                                                (
                                                
                                                   
                                                      a
                                                      g
                                                   
                                                   
                                                      X
                                                      g
                                                   
                                                   +
                                                   
                                                      b
                                                      g
                                                   
                                                   
                                                      Y
                                                      g
                                                   
                                                
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (4b)
                              
                                 
                                    s.t.
                                    
                                    
                                       A
                                       G
                                    
                                    X
                                    +
                                    
                                       B
                                       G
                                    
                                    X
                                    ≤
                                    
                                       C
                                       G
                                    
                                    ,
                                    
                                    G
                                    ∈
                                    
                                       G
                                       c
                                       1
                                    
                                    ∪
                                    
                                       C
                                       c
                                    
                                    ;
                                 
                              
                           
                        
                        
                           
                              (4c)
                              
                                 
                                    
                                       x
                                       
                                          g
                                          ,
                                          i
                                       
                                    
                                    =
                                    
                                       x
                                       
                                          g
                                          ,
                                          i
                                       
                                       f
                                    
                                    ,
                                    
                                    
                                       (
                                       g
                                       ,
                                       i
                                       )
                                    
                                    ∈
                                    
                                       
                                          H
                                       
                                       f
                                    
                                    ,
                                    g
                                    ∈
                                    
                                       C
                                       c
                                    
                                    ;
                                 
                              
                           
                        
                        
                           
                              (4d)
                              
                                 
                                    
                                       x
                                       
                                          g
                                          ,
                                          i
                                       
                                    
                                    ∈
                                    
                                       {
                                       0
                                       ,
                                       1
                                       }
                                    
                                    ,
                                    
                                    
                                       (
                                       g
                                       ,
                                       i
                                       )
                                    
                                    ∈
                                    
                                       
                                          H
                                       
                                       b
                                    
                                    ,
                                    g
                                    ∈
                                    
                                       C
                                       c
                                    
                                    ;
                                 
                              
                           
                        
                        
                           
                              (4e)
                              
                                 
                                    
                                       y
                                       
                                          g
                                          ,
                                          j
                                       
                                    
                                    ∈
                                    R
                                    ,
                                    
                                    j
                                    ∈
                                    
                                       J
                                       g
                                    
                                    ,
                                    g
                                    ∈
                                    
                                       C
                                       c
                                    
                                    ;
                                 
                              
                           
                        
                     

with 
                           
                              x
                              
                                 g
                                 ,
                                 i
                              
                              f
                           
                         fixed to either 0 or 1 parameters for all 
                           
                              
                                 (
                                 g
                                 ,
                                 i
                                 )
                              
                              ∈
                              
                                 
                                    H
                                 
                                 f
                              
                           
                        .

When we solve the entire problem, binary variables must be treated as either integers, relaxed, or fixed to values provided by the clusters’ solutions or by the branching process. The corresponding model is thus:

                           
                              (5a)
                              
                                 
                                    
                                       
                                          
                                             
                                                MP
                                                2
                                             
                                             (
                                             
                                                
                                                   H
                                                
                                                f
                                             
                                             ,
                                             
                                                
                                                   H
                                                
                                                r
                                             
                                             ,
                                             
                                                
                                                   H
                                                
                                                b
                                             
                                             )
                                          
                                       
                                       
                                          :
                                       
                                       
                                          
                                       
                                    
                                    
                                       
                                          min
                                       
                                       
                                          :
                                       
                                       
                                          
                                             f
                                             
                                                (
                                                X
                                                ,
                                                Y
                                                )
                                             
                                             =
                                             
                                                ∑
                                                
                                                   g
                                                   ∈
                                                   G
                                                
                                             
                                             
                                                w
                                                g
                                             
                                             
                                                (
                                                
                                                   
                                                      a
                                                      g
                                                   
                                                   
                                                      X
                                                      g
                                                   
                                                   +
                                                   
                                                      b
                                                      g
                                                   
                                                   
                                                      Y
                                                      g
                                                   
                                                
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (5b)
                              
                                 
                                    s.t.
                                    
                                    
                                       A
                                       G
                                    
                                    X
                                    +
                                    
                                       B
                                       G
                                    
                                    Y
                                    ≤
                                    
                                       C
                                       G
                                    
                                    ,
                                    
                                    G
                                    ∈
                                    C
                                    ∪
                                    
                                       G
                                       1
                                    
                                    ;
                                 
                              
                           
                        
                        
                           
                              (5c)
                              
                                 
                                    
                                       X
                                       g
                                    
                                    =
                                    
                                       X
                                       h
                                    
                                    ,
                                    
                                       Y
                                       g
                                    
                                    =
                                    
                                       Y
                                       h
                                    
                                    ,
                                    
                                    g
                                    ,
                                    h
                                    ∈
                                    
                                       A
                                       s
                                    
                                    ,
                                    
                                       A
                                       s
                                    
                                    ∈
                                    A
                                    ;
                                 
                              
                           
                        
                        
                           
                              (5d)
                              
                                 
                                    
                                       x
                                       
                                          g
                                          ,
                                          i
                                       
                                    
                                    =
                                    
                                       x
                                       
                                          g
                                          ,
                                          i
                                       
                                       f
                                    
                                    ,
                                    
                                    
                                       (
                                       g
                                       ,
                                       i
                                       )
                                    
                                    ∈
                                    
                                       
                                          H
                                       
                                       f
                                    
                                    ;
                                 
                              
                           
                        
                        
                           
                              (5e)
                              
                                 
                                    
                                       x
                                       
                                          g
                                          ,
                                          i
                                       
                                    
                                    ∈
                                    
                                       {
                                       0
                                       ,
                                       1
                                       }
                                    
                                    ,
                                    
                                    
                                       (
                                       g
                                       ,
                                       i
                                       )
                                    
                                    ∈
                                    
                                       
                                          H
                                       
                                       b
                                    
                                    ;
                                 
                              
                           
                        
                        
                           
                              (5f)
                              
                                 
                                    
                                       x
                                       
                                          g
                                          ,
                                          i
                                       
                                    
                                    ∈
                                    
                                       [
                                       0
                                       ,
                                       1
                                       ]
                                    
                                    ,
                                    
                                    
                                       (
                                       g
                                       ,
                                       i
                                       )
                                    
                                    ∈
                                    
                                       
                                          H
                                       
                                       r
                                    
                                    ;
                                 
                              
                           
                        
                        
                           
                              (5g)
                              
                                 
                                    
                                       y
                                       
                                          g
                                          ,
                                          j
                                       
                                    
                                    ∈
                                    R
                                    ,
                                    
                                    j
                                    ∈
                                    
                                       J
                                       g
                                    
                                    ,
                                    g
                                    ∈
                                    G
                                    ;
                                 
                              
                           
                        
                     

with 
                           
                              x
                              
                                 g
                                 ,
                                 i
                              
                              f
                           
                         fixed to either 0 or 1 parameters for all 
                           
                              
                                 (
                                 g
                                 ,
                                 i
                                 )
                              
                              ∈
                              
                                 
                                    H
                                 
                                 f
                              
                           
                        .

Every time a cluster problem CP2
                           
                              
                                 
                                    
                                    c
                                 
                                 
                                    (
                                    
                                       
                                          H
                                       
                                       f
                                    
                                    ,
                                    
                                       
                                          H
                                       
                                       r
                                    
                                    ,
                                    
                                       
                                          H
                                       
                                       b
                                    
                                    )
                                 
                              
                            is solved, it delivers a solution for the variables Xg, Yg
                           , 
                              
                                 g
                                 ∈
                                 
                                    C
                                    c
                                 
                              
                           . Unless the coordinated variables are equal for all clusters (either by chance or due to fixing), these values will likely not be optimal for the complete problem MP1 but rather will provide a lower bound which can be easily calculated by adding up the solutions of all the clusters:

                              
                                 (6)
                                 
                                    
                                       
                                          
                                             f
                                             ̲
                                          
                                          c
                                       
                                       =
                                       
                                          ∑
                                          
                                             
                                                C
                                                c
                                             
                                             ∈
                                             C
                                          
                                       
                                       
                                          f
                                          c
                                       
                                       
                                          (
                                          
                                             X
                                             
                                                *
                                                c
                                             
                                          
                                          ,
                                          
                                             Y
                                             
                                                *
                                                c
                                             
                                          
                                          )
                                       
                                       ,
                                    
                                 
                              
                           where X*
                              c
                           , Y*
                              c
                            are the optimal solutions for all the binary and continuous variables in CP2
                           
                              
                                 
                                    
                                    c
                                 
                                 
                                    (
                                    
                                       
                                          H
                                       
                                       f
                                    
                                    ,
                                    
                                       
                                          H
                                       
                                       r
                                    
                                    ,
                                    
                                       
                                          H
                                       
                                       b
                                    
                                    )
                                 
                              
                           .

The bound

                              
                                 (7)
                                 
                                    
                                       
                                          
                                             f
                                             ̲
                                          
                                          LP
                                       
                                       =
                                       f
                                       
                                          (
                                          
                                             X
                                             
                                                *
                                                c
                                             
                                          
                                          ,
                                          
                                             Y
                                             
                                                *
                                                c
                                             
                                          
                                          )
                                       
                                       ,
                                    
                                 
                              
                           is obtained by solving MP2
                           
                              
                                 (
                                 
                                    
                                       H
                                    
                                    f
                                 
                                 ,
                                 
                                    
                                       H
                                    
                                    r
                                 
                                 ,
                                 ∅
                                 )
                              
                            with 
                              
                                 (
                                 
                                    G
                                    f
                                 
                                 ,
                                 
                                    I
                                    f
                                 
                                 )
                              
                            determined by the progressive fixing of the binary variables according to the BFC process. All non-coordinated (hence non-fixed) binary variables are relaxed, as well as those coordinated binary variables which have not been fixed to a 0/1 value.

For the BFC, the lower bound of a particular partition of the variables in 
                              
                                 (
                                 
                                    
                                       H
                                    
                                    f
                                 
                                 ,
                                 
                                    
                                       H
                                    
                                    r
                                 
                                 ,
                                 
                                    
                                       H
                                    
                                    b
                                 
                                 )
                              
                            is then

                              
                                 (8)
                                 
                                    
                                       
                                          
                                             f
                                             ̲
                                          
                                          *
                                       
                                       =
                                       max
                                       
                                          (
                                          
                                             
                                                f
                                                ̲
                                             
                                             c
                                          
                                          ,
                                          
                                             
                                                f
                                                ̲
                                             
                                             LP
                                          
                                          )
                                       
                                       .
                                    
                                 
                              
                           
                        

However, if all coordinated binary variables Xg
                            have been fixed to the same values for all nodes g in all clusters, the solutions X*
                              c
                            from all cluster subproblems CP2
                           
                              c
                            are feasible and non-anticipative for MP2. We then make 
                              
                                 
                                    H
                                 
                                 f
                              
                            such that 
                              
                                 
                                    G
                                    f
                                 
                                 :
                                 =
                                 G
                                 ,
                                 
                                    I
                                    g
                                    f
                                 
                                 :
                                 =
                                 
                                    I
                                    g
                                 
                              
                            and fix all non-coordinated binary variables to the clusters’ solutions, and solve MP2 as an LP. If all continuous variables Y are feasible and non-anticipative too, we have a candidate solution for the original problem which can be used in the branch-and-bound part of the BFC algorithm described in the next section. If a feasible solution cannot be found, MP2 is solved as a MIP with 
                              
                                 
                                    G
                                    f
                                 
                                 :
                                 =
                                 
                                    {
                                    g
                                    ∈
                                    
                                       S
                                       s
                                    
                                    |
                                    s
                                    <
                                    
                                       s
                                       *
                                    
                                    }
                                 
                                 ,
                              
                           
                           
                              
                                 
                                    G
                                    r
                                 
                                 =
                                 ∅
                              
                            and 
                              
                                 
                                    G
                                    b
                                 
                                 =
                                 
                                    {
                                    g
                                    ∈
                                    
                                       S
                                       s
                                    
                                    |
                                    s
                                    ≥
                                    
                                       s
                                       *
                                    
                                    }
                                 
                              
                           .

One can think of the BFC algorithm as a branch-and-bound routine in which each node of the search tree contains the status of all variables in all subproblems, and decisions are made considering all the clusters at the same time. Some of the variables before stage s* are common for many clusters (i.e. those which are subject to NACs), so they should all branch coordinately: at the same moment and to the same values during the search.

The goal of the algorithm is to maintain the non-anticipativity of these coordinated binary variables while providing feasible solutions to the non-coordinated variables; the non-anticipativity of the continuous variables before stage s* is also guaranteed whenever problem MP2 is solved.

In every iteration, we will often (though not necessarily so) find ourselves doing as many calls to the solver as the number of clusters created from the original scenario tree, it is in this part where we implement parallel computing. Since the NACs will eventually hold due to the coordination part of the algorithm described in Step 3, we can solve independent subproblems for each cluster. However, some of the clusters’ solutions in a particular iteration would have been solved already because whichever variables which were newly fixed do not appear in those clusters, thus any previously calculated solutions remain valid.

Notice that an early s* implies relatively larger subproblems CP2
                     
                        c
                     , but fewer clusters and coordinated variables.

For a more detailed explanation of the BFC algorithm, we refer to Alonso-Ayuso et al. (2003) and Escudero et al. (2010b, 2012). Our own implementation is summarised below. We assume the reader is familiar with the concepts used in a branch-and-bound routine (Wolsey, 1998).

Let L be the list of open nodes (problems) in the B&B tree, 
                        
                           f
                           ^
                        
                      the best solution to problem MP1, and 
                        f
                      its best lower bound.


                              
                                 
                                    
                                       Step 0
                                    
                                    
                                       (Initialization)
                                       
                                          
                                             
                                                f
                                                ^
                                             
                                             :
                                             =
                                             +
                                             ∞
                                             ,
                                             
                                                f
                                                ̲
                                             
                                             :
                                             =
                                             −
                                             ∞
                                             ,
                                             L
                                             :
                                             =
                                             ∅
                                          
                                       .


                                       (Root node) Create the first B&B search node n
                                       0 in the problem list L, setting all coordinated variables as relaxed 
                                          
                                             (
                                             
                                                G
                                                f
                                             
                                             =
                                             ∅
                                             ,
                                             
                                                G
                                                r
                                             
                                             =
                                             G
                                             )
                                          
                                        , 
                                          
                                             
                                                I
                                                g
                                                r
                                             
                                             =
                                             
                                                I
                                                g
                                             
                                          
                                        for each 
                                          
                                             g
                                             ∈
                                             
                                                G
                                                r
                                             
                                          
                                       ; and define the node lower bound 
                                          f
                                        * as − ∞.

Add this node to the list of unsolved B&B nodes, n
                                       0 → L.


                                       (Select a node from the list) If L = ∅, go to Step 13. Otherwise, choose the first node from the list as the current node.


                                       (Bound node) Solve the individual cluster subproblems CP2
                                       
                                          
                                             
                                                
                                                c
                                             
                                             
                                                (
                                                
                                                   
                                                      H
                                                   
                                                   f
                                                
                                                ,
                                                ∅
                                                ,
                                                
                                                   
                                                      H
                                                   
                                                   b
                                                
                                                )
                                             
                                          
                                       . For each cluster, build 
                                          
                                             
                                                H
                                             
                                             f
                                          
                                        using the information of the current node to determine which coordinated binary variables are fixed to either 0 or 1. Assign the rest of the variables to 
                                          
                                             
                                                H
                                             
                                             b
                                          
                                       .


                                       (Process bound) If any subproblem is infeasible, go to Step 12 (prune by infeasibility).

Otherwise, compute 
                                          f
                                        
                                       
                                          c
                                        as shown in (6).

If 
                                          
                                             
                                                
                                                   f
                                                   ̲
                                                
                                                c
                                             
                                             ≥
                                             
                                                f
                                                ^
                                             
                                             ,
                                          
                                        go to Step 12 (prune by cutoff).

If not, update the lower bound for this search node as 
                                          f
                                        * = max { 
                                          f
                                        *, 
                                          f
                                        
                                       
                                          c
                                       }.

Then, if all binary variables satisfy the NACs, go to Step 8. Otherwise continue.


                                       (Select branching variable) Select a branching binary variable x
                                       
                                          g, i
                                        in the node, according to the selected branching order criterion (natural order, most fractional, etc.). Update the sets 
                                          
                                             
                                                
                                                   H
                                                
                                                f
                                             
                                             ,
                                             
                                                
                                                   H
                                                
                                                r
                                             
                                          
                                        such that 
                                          
                                             
                                                G
                                                f
                                             
                                             =
                                             
                                                G
                                                f
                                             
                                             ∪
                                             
                                                {
                                                g
                                                }
                                             
                                             ,
                                          
                                       
                                       
                                          
                                             
                                                I
                                                g
                                                f
                                             
                                             =
                                             
                                                I
                                                g
                                                f
                                             
                                             ∪
                                             
                                                {
                                                i
                                                }
                                             
                                          
                                        and 
                                          
                                             
                                                I
                                                g
                                                r
                                             
                                             =
                                             
                                                I
                                                g
                                                r
                                             
                                             ∖
                                             
                                                {
                                                i
                                                }
                                             
                                          
                                       . If 
                                          
                                             
                                                I
                                                g
                                                r
                                             
                                             =
                                             ∅
                                             ,
                                          
                                        then 
                                          
                                             
                                                G
                                                r
                                             
                                             =
                                             
                                                G
                                                r
                                             
                                             ∖
                                             
                                                {
                                                g
                                                }
                                             
                                          
                                       .


                                       (Branch) Add two new nodes to the list, identical to each other except for their value of 
                                          
                                             
                                                x
                                                
                                                   g
                                                   ,
                                                   i
                                                
                                                f
                                             
                                             ∈
                                             
                                                {
                                                0
                                                ,
                                                1
                                                }
                                             
                                          
                                       . Update the priority value of each node according to the node selection criteria (best first, depth first, etc.)


                                       (Reorder) Reorder the list of nodes according to the priority criterion. Go to Step 2.


                                       (Check continuous NAC) Build a binary solution for the total problem given the solutions provided by subproblems CP2
                                       
                                          c
                                       . Solve this MP2
                                       
                                          
                                             (
                                             
                                                
                                                   H
                                                
                                                f
                                             
                                             ,
                                             ∅
                                             ,
                                             ∅
                                             )
                                             ,
                                          
                                        with 
                                          
                                             
                                                H
                                             
                                             f
                                          
                                        containing all binary variables, to obtain a candidate solution to MP1.

If MP2 is feasible, let f* be equal to its objective value. Otherwise, set f* as NaN (there is no candidate solution for this node at this point).

If f* is better than the incumbent 
                                          
                                             
                                                f
                                                ^
                                             
                                             ,
                                          
                                        update 
                                          
                                             
                                                f
                                                ^
                                             
                                             :
                                             =
                                             min
                                             
                                                {
                                                
                                                   f
                                                   ^
                                                
                                                ,
                                                
                                                   f
                                                   *
                                                
                                                }
                                             
                                          
                                       . Prune the tree.


                                       (Bound node with LP model)
Solve problem MP2
                                       
                                          
                                             (
                                             
                                                
                                                   H
                                                
                                                f
                                             
                                             ,
                                             
                                                
                                                   H
                                                
                                                r
                                             
                                             ,
                                             ∅
                                             )
                                          
                                        with 
                                          
                                             x
                                             
                                                g
                                                ,
                                                i
                                             
                                             f
                                          
                                        defined as those binary variables fixed by branching (i.e. the sets 
                                          
                                             
                                                (
                                                
                                                   G
                                                   f
                                                
                                                ,
                                                
                                                   I
                                                   g
                                                   f
                                                
                                                )
                                             
                                             ∈
                                             
                                                
                                                   H
                                                
                                                f
                                             
                                          
                                        contain some/all coordinated variables) to satisfy the NAC for the y variables to obtain 
                                          f
                                        
                                       LP.

If MP2 is infeasible, go to Step 12 (pruning by infeasibility).

Update the lower bound of the node as in (8), 
                                          f
                                        * = max ( 
                                          f
                                        
                                       
                                          c
                                       , 
                                          f
                                        
                                       LP).


                                       (Check candidate solution) If f* = NaN, go to Step 11.

If f* = 
                                          f
                                        *, go to Step 12; else go to Step 5.


                                       (Fully coordinated node) Solve the MIP problem MP2
                                       
                                          
                                             (
                                             
                                                
                                                   H
                                                
                                                f
                                             
                                             ,
                                             ∅
                                             ,
                                             
                                                
                                                   H
                                                
                                                b
                                             
                                             )
                                          
                                        with 
                                          
                                             
                                                H
                                             
                                             f
                                          
                                        such that it contains all coordinated binary variables (
                                          
                                             x
                                             
                                                g
                                                ,
                                                i
                                             
                                             f
                                          
                                        are given by the solutions of the cluster subproblems CP2
                                       
                                          c
                                       , which satisfy the NAC,) and 
                                          
                                             
                                                H
                                             
                                             b
                                          
                                        contains all the non-coordinated ones.

If feasible, update the incumbent and prune the tree.

If in this search node all coordinated variables have been fixed (i.e. no more branching can be done), go to Step 12, otherwise go to Step 5.


                                       (Close the node) Remove this node from the list. Go to Step 2.


                                       (End) Stop. The optimal solution value is 
                                          
                                             f
                                             ^
                                          
                                       .

There are some particularities inherent to our BFC implementation. Most notable, there is one, and only one, subproblem per processing core, being solved in parallel each time a subproblem solution request is sent by the master thread. This means that loading a problem from file into memory is done only once, and the data is kept in the memory space allocated to that core. The only messages passed between cores are the fixed/relaxed states of the variables, optimal solution values, and the algorithm status reports; this keeps the message passing overhead and data input/output as light as possible.

The master thread handles the list of open nodes and sends requests to the worker threads to solve the CP2
                        
                           c
                         subproblems with a particular state of the common binary variables.

When the master needs the solution of the node with highest priority (defined according to the node selection criteria, i.e. depth-first, best-first or breadth-first), it sends the information of said node to each worker so that they can determine which variation of their problem CP2
                        
                           c
                         will solve. Given that some coordinated variables are not common to all the clusters sometimes only a subset of the 
                           
                              |
                              C
                              |
                           
                         clusters needs to actually be solved.

The pseudo-code of the parallel algorithm is shown in Algorithm 1
                         and Table 1
                         briefly presents the main tasks done in each step of the algorithm, relating it to the BFC algorithm presented in the previous section.

This algorithm is coded in C++, using the openMPI (Open MPI Project, 2013) implementation of the MPI protocol to pass the information between threads.

As noted in the algorithm above, the subproblems are solved as MILPs, using the technology of the solver of choice to efficiently compute integer solutions which are then passed to the master thread. In turn, the master thread will mostly solve LPs, which arise from fixing each binary to a value determined either by coordination or by sub-problem solution; or by relaxing the non-fixed and the non-coordinated binary variables.

The MILP versions of the complete problem to be solved in Step 11 of the algorithm are typically lighter than the problem on file. Indeed, because at this point we have fixed all coordinated variables, the number of ‘real’ binary variables in the clusters is smaller the higher the break stage s* is. As pointed out in the results section, many instances using the investment/decision paradigm, such as those labelled C##, would not reach Step 11 at all.

When compared to other past and current BFC implementation efforts (Aldasoro et al., 2013; Escudero et al., 2010b; Escudero et al., 2012), we can say that our implementation differs in three key aspects:

                           
                              •
                              We take on a problem directly, loading the total problem as-is into the master thread, while the research groups in the references use, among other advanced techniques, an Outer Parallelisation to fix some of the binary variables. This creates n independent problems roughly the size of the original one in a partial enumeration scheme. Along with other additional parallelisation schemes around the core BFC, this has reportedly good results. We, on the other hand, have focused our efforts in improving the performance of the core BFC itself, using distributed computing only to the extent it helps, or is needed by, the BFC.

We rely on faster node processing over tightening of bounds; as opposed to evaluating a ‘large’ MIP to test the non-anticipativity of the continuous variables at certain points of the process. The full problem MP2 is solved only in Step 8 (when it is actually a LP due to binary fixing) or in Step 11 (when there is no other way to test feasibility of a coordinated node).

Finally, we allow for the selection of the branching node and variable according to different strategies, instead of using a pre-determined branching order.

This BFC implementation was designed with industry-sized problem instances in mind. This leads to the assumption that the scenario trees employed are large enough to be decomposed in as many clusters as needed to achieve computational efficiency. Since (in principle, and given good computational performance) all available processors can be used for a single cluster, the design of our application has been more focused on a lean and efficient BFC, instead of refining parallelised strategies for flexibility and maximum usage of resources.

An ad hoc heuristic, while very valuable when one has partial integer solutions which ultimately will lead to poor or unfeasible leaf nodes, implies the total problem will be solved more often, which might cause performance problems if the machines used are not efficient enough. We prefer to avoid this at the expense of potentially poorer bounds.

@&#EXPERIMENTAL RESULTS@&#

In order to test the performance of our BFC implementation, we compared it against the commercial solver FICO Xpress 7.4 (FICO Xpress, 2009), in a number of different problem instances. Xpress is also used to solve the LP and MILP problems within the BFC algorithm.

The experimental instances come from two sources:

                           
                              1.
                              Problems arising from pipeline network expansion. The two instances analysed (R1, R2) come from the RAMONA project, a natural gas network model developed by SINTEF/NTNU (Hellemo, Midthun, Tomasgard, and Werner, 2012).

Instances randomly generated based on stochastic knapsack variations with binary variables in generally all stages. First-stage binary variables are knapsack items available to take, while at latter stages binary variables are the actual decisions on whether to pack an item or not (instances C##).


                        Table 2
                         shows the instance sizes for a formulation in compact form. The columns contain the number of binary variables (n
                        bin), continuous variables (n
                        con), number of constraints (n
                        row) and number of nonzero elements in the constraint matrix (n
                        ele). We also compute the density of the constraints matrix (δ), as well as the number of stages (S), scenarios (n
                        scn) and the number of nodes (
                           
                              |
                              G
                              |
                           
                        ) of the problem’s scenario tree. Instances R1 and R2 use a symmetric scenario tree, whereas instances C## have generally asymmetric trees since each node has max {1, Poisson(λ)} children, with λ varying from instance to instance.


                        Table 3
                         shows the objective function of the best known solutions (z*). Best known solutions have been found and corroborated by both Xpress solving the original problem in compact formulation, and BFC using the cluster decompositions, in all but two cases. A best known solution (z*) for case C05 is missing given that neither a direct solution with FICO-Xpress nor one using our BFC implementation was found. The best solution for instance C03 was found by the BFC, with an optimality gap of 0.42 percent. Xpress used the time limit of 5 hours and did not provide a smaller gap for this instance (actually it found a solution with objective function value equal to 0 and the best bound was − 4000). Next we show the objective function value of the LP relaxation (
                           
                              z
                              LP
                              *
                           
                        ) and the gap between these two values computed as 
                           
                              
                                 
                                    |
                                 
                                 
                                    z
                                    *
                                 
                                 −
                                 
                                    z
                                    LP
                                    *
                                 
                                 
                                    |
                                 
                              
                              
                                 
                                    |
                                 
                                 
                                    z
                                    *
                                 
                                 
                                    |
                                 
                              
                           
                         and the time (in seconds) to find the LP solution.

For each instance, different configurations of BFC parameters (node selection, variable selection, and number of clusters) were tested. In all cases, the performance of the BFC implementation was compared to an out-of-the-box Xpress optimisation.

All instances were solved using a HPC cluster with machines running Linux 2.6, each with 2 processors of 6 cores running at 2.39 gigahertz and 24 gigabytes of shared RAM per machine.

BFC uses one dedicated core for the master thread, plus one more for each worker and its respective, uniquely assigned cluster. There are no extra cores allowed for the internal solver call (i.e. within the BFC, Xpress operates without any parallelisation). Out-of-the-box Xpress is allowed to automatically choose the number of cores to use, up to 12. Table 4
                         shows, for selected instances, results for any combination of variable selection and node selection of the BFC parameters, compared to the results obtained from running out-of-the-box Xpress. Specific instances with solution time (both with Xpress and BFC) below 60 seconds have been omitted from the table. The interested reader is welcome to contact the authors for further details on these runs or the testbed used.

For all but one instance,
                           3
                        
                        
                           3
                           Experience showed that, for instance R2, further cluster partitions were unlikely to provide better solutions, hence no tests were made for the last partitions.
                         we tested the BFC with partitions at every possible break stage. From Table 4, we observe that the cluster partition plays a more important role in the solution time than the variable and node selection strategies. In most of the cases, the solution time of instances with the same cluster partition is within the same order of magnitude without showing any node or variable selection strategy with clearer advantages.

When we look at the solution times by cluster partition we observe that there usually exists a fastest partition (that is, if the instance has more than 2 stages). It is clear that breaking the scenario tree in earlier stages provides tighter bounds for the B&B search (because more NACs are kept implicit) at the expenses of solving larger MIP cluster problems. On the other hand, breaking the scenario tree at later stages results in smaller (and faster to solve) MIP cluster problems but increases the communication calls and the number of variables to coordinate (therefore providing weaker bounds of the original problem). A balance between the tightness of the bound and the speed of the MIP cluster solution arguably delivers the fastest solution times, though this is highly dependent on the instance in question.

On a further note, the structure of the C## instances makes it so no problems of type MP2 needed to be solved to reach an optimal solution. For the R## instances, problem MP2 was solved at most two times in the solution process.

The column headed Xpress in Table 4 shows the time reported by that solver to reach optimality using the default settings (i.e. 12 cores, pre-solve activated, etc.). In order to compare both solvers, we list the best and worst solution times obtained among the several strategies implemented with the BFC. For the worst values column, we list the best time obtained, along with an indication in case any of the combinations failed to provide an acceptable solution, either because the 5 hours time limit (TL) was exceeded, or because the memory was exhausted (OoM).

Column “BFC Best” shows the fastest running time needed by the BFC for solving each instance, which compares favourably to the Xpress solution time with default settings. In those instances where BFC provided a solution, the times needed were consistently faster. In case of the rather small instances C07, C09, C11, C14 and C15, both Xpress and each BFC combination took less than 1 minute and their solution time has been omitted from the table. A more dramatic difference is observed in instance C06, where BFC, using a 25-cluster decomposition, provides a solution in an average of 5 seconds for all running configurations, as opposed to Xpress, which runs out of memory while trying to solve C06. Similarly, for cases C10, C13, C16, C17, C18 and C23 the direct solution with Xpress exhausts the available memory before closing the gap.

In cases like C04, the best (and even the worst) performance of BFC takes less than 30 minutes, whereas Xpress fails to close a gap after the 5-hour time limit. A similar behaviour happens for cases C08, C12, C20, C21, C22 and R1.

For cases C18, C20, C21, C22 and C23, when attempting to solve the instance with the BFC using the partition with the least clusters, the BFC did not complete a single iteration due to fact that the solution of the cluster subproblems has exhausted the machine’s memory or did not report the solution within the time limit.

When looking at the “BFC Worst” figures, one realises that we should avoid solving partitions which will not finish a single iteration of the BFC. It is then advised that prior to start the BFC, we solve the MIP of each cluster subproblems directly with Xpress. If the solution for all clusters is found within reasonable time, we can attempt to find the optimal solution with the BFC. By doing so we avoid working with subproblems too hard to take advantage of the decomposition scheme. Further, based on the evidence of the instances solved, the recommendation is to solve the BFC with a depth first or best first plus natural input order settings.

For the set of instances tested, when looking for the “BFC Worst” figures, we have encouraging results for BFC, with only a limited number of entries taking longer than Xpress.

As mentioned before, each call from BFC using Xpress as solver is only allowed to use one core. In order to see the effect of allowing a parallelised Xpress within BFC, we present Table 5
                            with results on the speed-up from using 12 cores rather one when using Xpress as solver. Since this change typically favours partitions with hard MIP cluster problems (as opposed to simpler but numerous ones), we only present those instances where, for a break stage s* = 2, the number of clusters is 100 or less.


                           Table 5 shows that in those cases which were solved in a few seconds with the original settings (Xpress with 1 core) there is hardly any advantage in increasing the computational resources (case C12 even increases the solution time!). For most other cases there is an improvement of the overall solution time, specially for those which originally took a long time to solve.

Unfortunately, the “difficult” cases C03 and C05 did not change their behaviour. We did not manage to improve the solution of the smallest partition neither for cases C18, C20, C21, C22 and C23. These cases are omitted from Table 5 for brevity.

On instances C01, C02, C06, C16, C17, C19 and R2, the smallest partition was not the best one, and even the fact that the solution time is slightly better allowing Xpress to use 12 cores does not improve the solution time compared to the solution time with the best cluster partition. For the cases in which the smallest (or unique) partition was the best one (C08, C10, C12, C13 and R1) we observe that there exists an improvement for those cases with solution times higher than a few seconds. This suggests that when a fast partition of the problem is found, if we have enough computational resources, an extra speed-up can be achieved by using the multi-thread capabilities of Xpress within the BFC.

In this work, we describe a Branch and Fix Coordination implementation which uses a master–worker(s) parallel computing paradigm to solve stochastic mixed integer (binary) linear problems. It differs with former BFC implementations with a more flexible variable branching selection and focuses on faster iterations over tighter B&B node bounds.

The implementation was tested against the state-of-the-art solver FICO Xpress, which is also the tool used to obtain LP and MIP solutions in the various points the BFC needs to calculate those. Results show that, for a number of instances of different sizes and four different problem structures, there were generally many combinations of BFC running parameters which delivered optimal solutions in a competitive way when compared to Xpress, and those with poorer performance still compare well against the commercial solver.

Future areas of research include improving the bounding procedures by evaluating the complete problem’s LP relaxation more often in order to discard potentially unfeasible search nodes, and implementing Lagrangian relaxation (Jünger, Liebling, and Naddef, 2008). Further, inspired by Escudero et al. (2007); 2009b), we are introducing an L-shaped method and other complementary decomposition approaches (Birge and Louveaux, 1997) to avoid solving the full problem at any time. These additional decomposition methods should take away from the master thread the task of solving a potentially large LP/MILP problem, and also allow us to load considerably larger problems into machines with less individual memory. In this way, there would be no complete problem file loaded into memory in any machine, only smaller scenario clusters’ files. These two improvements should increase the size of the SMILPs which can be solved using the BFC routine.

@&#ACKNOWLEDGEMENTS@&#

The authors would like to thank the Norwegian Research Council, who provided monetary support for this research through the LinkS Project (R&D Project Agreement no. 190913/S60), and FME CenSES. Additionally, we would like to thank Professors Laureano Escudero, Gloria Pérez, as well as their teams in Universidad Rey Juan Carlos, and Universidad del País Vasco/Euskal Herriko Unibertsitatea. Also, many thanks to Marte Fodstad and Lars Hellemo from SINTEF Technology and Society, for their valuable insight, help and cooperation in this research. Finally, our thanks to two anonymous referees for providing insightful comments which improved the contents of this paper.

@&#REFERENCES@&#

