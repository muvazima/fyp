@&#MAIN-TITLE@&#Advanced greedy algorithms and surrogate constraint methods for linear and quadratic knapsack and covering problems

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           New refined greedy algorithms for linear and quadratic knapsack/covering problems.


                        
                        
                           
                           Extensions for multiple multi-constraint knapsack and covering problems.


                        
                        
                           
                           
                              Advance-look combination strategies that provide enhanced solution capabilities.


                        
                        
                           
                           Effective multi-start and strategic oscillation approaches exploiting these methods.


                        
                        
                           
                           New surrogate constraints dominating the constraints guiding current best methods.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Metaheuristics

Greedy algorithms

Knapsack/covering problems

Surrogate constraints

Multi-start/strategic oscillation

Tabu search

@&#ABSTRACT@&#


               
               
                  New variants of greedy algorithms, called advanced greedy algorithms, are identified for knapsack and covering problems with linear and quadratic objective functions. Beginning with single-constraint problems, we provide extensions for multiple knapsack and covering problems, in which objects must be allocated to different knapsacks and covers, and also for multi-constraint (multi-dimensional) knapsack and covering problems, in which the constraints are exploited by means of surrogate constraint strategies. In addition, we provide a new graduated-probe strategy for improving the selection of variables to be assigned values. Going beyond the greedy and advanced greedy frameworks, we describe ways to utilize these algorithms with multi-start and strategic oscillation metaheuristics. Finally, we identify how surrogate constraints can be utilized to produce inequalities that dominate those previously proposed and tested utilizing linear programming methods for solving multi-constraint knapsack problems, which are responsible for the current best methods for these problems. While we focus on 0–1 problems, our approaches can readily be adapted to handle variables with general upper bounds.
               
            

@&#INTRODUCTION@&#

Greedy algorithms have long been a mainstay of methods for single-constraint and multi-constraint knapsack and covering problems. These algorithms are often embedded within constructive processes used in multi-start metaheuristics and also within linked constructive and destructive processes in strategic oscillation metaheuristics. We introduce new variants of these algorithms, called advanced greedy algorithms, which can be implemented for problems with linear and quadratic objective functions.

In the quadratic case, we observe that previous formulations of greedy algorithms have conspicuous deficiencies and show how a new graduated-probe strategy can be used to overcome them both for greedy and advanced greedy methods. Though most strongly motivated in the quadratic setting, this new strategy can also be used to enhance variable-selection for problems with linear objectives. Starting with single-constraint problems, we then introduce extensions for more general multiple knapsack and multi-constraint (multi-dimensional) problems. Processes for employing these methods in strategic oscillation and multi-start approaches are also described.

In the domain of multi-constraint knapsack problems, we show how surrogate constraints can be used to provide inequalities that dominate inequalities used by previous methods incorporating linear programming strategies, which have produced the best existing methods for these problems. Our primary focus deals with 0–1 problems, though our methods can also be adapted for problems with more general integer variables.

Our paper is organized as follows. Section 2 begins by examining the simple case of single-constraint 0–1 knapsack and covering problems, including consideration of both linear and quadratic objectives. Section 3 describes classical greedy methods for these problems utilizing a framework that provides a foundation for later extensions. The new advanced greedy algorithms are introduced in Section 4, disclosing how these methods have the ability to eliminate certain deficiencies of the classical methods (and other previous methods). This section also identifies a way to produce fast updates for one of the main components of these methods.

Section 5 introduces the graduated-probe strategy and discloses the manner in which it overcomes limitations of methods proposed for quadratic problems. More general multiple knapsack problems, which have recently become the focus of a number of investigations, are addressed in Section 6. This section also describes how to reinforce such strategies in multi-start and strategic oscillation approaches. Finally, Section 7 discusses multi-constraint knapsack problems, together with the surrogate constraint strategies that generate inequalities to guide the solution process.

Single-constraint 0–1 knapsack and covering problems with linear and quadratic objectives may be formulated as follows.
                        
                           
                              Linear single-constraint knapsack (LK)
                              
                                 
                                    (LK0)
                                    
                                       Maximize
                                       
                                       
                                          
                                             x
                                          
                                          
                                             o
                                          
                                       
                                       =
                                       
                                          ∑
                                       
                                       (
                                       
                                          
                                             p
                                          
                                          
                                             j
                                          
                                       
                                       
                                          
                                             x
                                          
                                          
                                             j
                                          
                                       
                                       ;
                                       j
                                       ∈
                                       N
                                       )
                                    
                                 
                              
                              
                                 
                                    (K1)
                                    
                                       subject
                                       
                                       to
                                       
                                       
                                          ∑
                                       
                                       (
                                       
                                          
                                             a
                                          
                                          
                                             j
                                          
                                       
                                       
                                          
                                             x
                                          
                                          
                                             j
                                          
                                       
                                       ;
                                       j
                                       ∈
                                       N
                                       )
                                       ⩽
                                       
                                          
                                             a
                                          
                                          
                                             o
                                          
                                       
                                    
                                 
                              
                              
                                 
                                    (K2)
                                    
                                       
                                       
                                          
                                             x
                                          
                                          
                                             j
                                          
                                       
                                       ∈
                                       {
                                       0
                                       ,
                                       
                                       1
                                       }
                                       ,
                                       
                                       j
                                       ∈
                                       N
                                    
                                 
                              where a
                              
                                 o
                              
                              >0, and the profit coefficients p
                              
                                 j
                               and the constraint coefficients a
                              
                                 j
                               are likewise positive constants for all j
                              ∈
                              N
                              ={1,…,
                              n}. (Cases where some p
                              
                                 j
                               or a
                              
                                 j
                               coefficients are non-positive can easily be converted to the positive coefficient form by complementing variables or by observing that particular variables can be automatically assigned 0 or 1 values in an optimal solution.) We assume 
                                 
                                    ∑
                                    (
                                    
                                       
                                          a
                                       
                                       
                                          j
                                       
                                    
                                    :
                                    
                                    j
                                    ∈
                                    N
                                    )
                                    >
                                    
                                       
                                          a
                                       
                                       
                                          o
                                       
                                    
                                 
                              , since 
                                 
                                    ∑
                                    (
                                    
                                       
                                          a
                                       
                                       
                                          j
                                       
                                    
                                    :
                                    
                                    j
                                    ∈
                                    N
                                    )
                                    ⩽
                                    
                                       
                                          a
                                       
                                       
                                          o
                                       
                                    
                                 
                               implies (LK) has the trivial solution x
                              
                                 j
                              
                              =1, all j
                              ∈
                              N.


                              Linear single-constraint cover (LC)
                              
                                 
                                    (LC0)
                                    
                                       Minimize
                                       
                                       
                                          
                                             y
                                          
                                          
                                             o
                                          
                                       
                                       =
                                       
                                          ∑
                                       
                                       (
                                       
                                          
                                             c
                                          
                                          
                                             j
                                          
                                       
                                       
                                          
                                             y
                                          
                                          
                                             j
                                          
                                       
                                       ;
                                       j
                                       ∈
                                       N
                                       )
                                    
                                 
                              
                              
                                 
                                    (C1)
                                    
                                       subject
                                       
                                       to
                                       
                                       
                                          ∑
                                       
                                       (
                                       
                                          
                                             d
                                          
                                          
                                             j
                                          
                                       
                                       
                                          
                                             y
                                          
                                          
                                             j
                                          
                                       
                                       ;
                                       j
                                       ∈
                                       N
                                       )
                                       ⩾
                                       
                                          
                                             d
                                          
                                          
                                             o
                                          
                                       
                                    
                                 
                              
                              
                                 
                                    (C2)
                                    
                                       
                                       
                                          
                                             y
                                          
                                          
                                             j
                                          
                                       
                                       ∈
                                       {
                                       0
                                       ,
                                       
                                       1
                                       }
                                       ,
                                       
                                       j
                                       ∈
                                       N
                                    
                                 
                              
                           

(LK) and (LC) are equivalent problems, as can be seen by replacing x
                     
                        j
                      by 1−
                     y
                     
                        j
                      in the former or replacing y
                     
                        j
                      by 1−
                     x
                     
                        j
                      in the latter and simplifying the resulting representation. (This produces constant terms in the objective functions for the two problems, but these do not affect the optimal solutions. The assumption a
                     
                        o
                     
                     >0 in (LK) corresponds to stipulating 
                        
                           ∑
                           (
                           
                              
                                 d
                              
                              
                                 j
                              
                           
                           ;
                           j
                           ∈
                           N
                           )
                           >
                           
                              
                                 d
                              
                              
                                 o
                              
                           
                        
                      in (LC), and the assumption d
                     
                        o
                     
                     >0 in (LC) corresponds to stipulating 
                        
                           ∑
                           (
                           
                              
                                 a
                              
                              
                                 j
                              
                           
                           ;
                           j
                           ∈
                           N
                           )
                           >
                           
                              
                                 a
                              
                              
                                 o
                              
                           
                        
                      in (LK).) In spite of this equivalence, however, the classical greedy algorithms for these problems do not yield equivalent solutions, and we treat them separately by indicating specific rules for each.

The quadratic versions of these problems arise by replacing the objective functions of the linear versions as follows:
                        
                           
                              Quadratic single-constraint knapsack (QK)
                              
                                 
                                    (QK0)
                                    
                                       
                                          
                                             
                                                
                                                   Maximize
                                                
                                             
                                             
                                                
                                                   
                                                   
                                                      
                                                         x
                                                      
                                                      
                                                         o
                                                      
                                                   
                                                   =
                                                   
                                                      ∑
                                                   
                                                   (
                                                   
                                                      
                                                         p
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                   
                                                      
                                                         x
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                   ;
                                                   j
                                                   ∈
                                                   N
                                                   )
                                                   +
                                                   
                                                      ∑
                                                   
                                                   (
                                                   
                                                      
                                                         p
                                                      
                                                      
                                                         jh
                                                      
                                                   
                                                   
                                                      
                                                         x
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                   
                                                      
                                                         x
                                                      
                                                      
                                                         h
                                                      
                                                   
                                                   :
                                                   
                                                   j
                                                   ,
                                                   
                                                   h
                                                   ∈
                                                   N
                                                   )
                                                
                                             
                                          
                                          
                                             
                                                
                                                   subject
                                                   
                                                   to
                                                
                                             
                                             
                                                
                                                   
                                                   (
                                                   K
                                                   1
                                                   )
                                                   
                                                   and
                                                   
                                                   (
                                                   K
                                                   2
                                                   )
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           


                              Quadratic single-constraint cover (QC)
                              
                                 
                                    (QC0)
                                    
                                       
                                          
                                             
                                                
                                                   Minimize
                                                
                                             
                                             
                                                
                                                   
                                                   
                                                      
                                                         y
                                                      
                                                      
                                                         o
                                                      
                                                   
                                                   =
                                                   
                                                      ∑
                                                   
                                                   (
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                   
                                                      
                                                         y
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                   ;
                                                   
                                                   j
                                                   ∈
                                                   N
                                                   )
                                                   +
                                                   
                                                      ∑
                                                   
                                                   (
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         jh
                                                      
                                                   
                                                   
                                                      
                                                         y
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                   
                                                      
                                                         y
                                                      
                                                      
                                                         h
                                                      
                                                   
                                                   :
                                                   
                                                   j
                                                   ,
                                                   
                                                   h
                                                   ∈
                                                   N
                                                   )
                                                
                                             
                                          
                                          
                                             
                                                
                                                   subject
                                                   
                                                   to
                                                
                                             
                                             
                                                
                                                   
                                                   (
                                                   C
                                                   1
                                                   )
                                                   
                                                   and
                                                   
                                                   (
                                                   C
                                                   2
                                                   )
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           

In these formulations we assume for convenience that p
                     
                        jj
                      and c
                     
                        jj
                      are 0. This can be accomplished by setting p
                     
                        j
                     
                     ≔
                     p
                     
                        j
                     
                     +
                     p
                     
                        jj
                      and c
                     
                        j
                     
                     ≔
                     c
                     
                        j
                     
                     +
                     c
                     
                        jj
                     , which is justified by the observation that a 0–1 variable z satisfies z
                     2
                     =
                     z. We also assume p
                     
                        jh
                      and c
                     
                        jh
                      are 0 for j
                     >
                     h, in this case accomplished by setting p
                     
                        jh
                     
                     ≔
                     p
                     
                        jh
                     
                     +
                     p
                     
                        hj
                      and c
                     
                        jh
                     
                     ≔
                     c
                     
                        jh
                     
                     +
                     c
                     
                        hj
                      for j
                     <
                     h (justified by the fact that x
                     
                        j
                     
                     x
                     
                        h
                     
                     =
                     x
                     
                        h
                     
                     x
                     
                        j
                      and y
                     
                        j
                     
                     y
                     
                        h
                     
                     =
                     y
                     
                        h
                     
                     y
                     
                        j
                     ). This latter assumption gives a means to save memory in storing data for the quadratic problems.

It is also customary to assume the profit coefficients p
                     
                        j
                      and p
                     
                        jh
                      and the cost coefficients c
                     
                        j
                      and c
                     
                        jh
                      are non-negative. However, this is not necessary for our development, though we retain the assumption that the a
                     
                        j
                      and d
                     
                        j
                      coefficients of (K1) and (K2) are positive. (The quadratic problems (QK) and (QC) are not equivalent under the assumption of non-negative p
                     
                        jh
                      and c
                     
                        jh
                      coefficients. In fact, equivalence between the two formulations requires c
                     
                        jh
                     
                     =−p
                     
                        jh.)
                  

We begin by discussing the classical greedy algorithms as a prelude to introducing the advanced greedy algorithms.

The classical greedy algorithms for (LK) and (LC) use the so-called bang-for-buck ratios RK
                           j
                        
                        =
                        p
                        
                           j
                        /a
                        
                           j
                         and RC
                           j
                        
                        =
                        c
                        
                           j
                        /d
                        
                           j
                         whose relevance for one-pass constructive methods was first noted in Dantzig (1957). Effectively, the algorithms go through the RK
                           j
                         ratios in descending order and the RC
                           j
                         ratios in ascending order, respectively, to assign x
                        
                           j
                        
                        =1 and y
                        
                           j
                        
                        =1 until no more assignments are possible that preserve feasibility for (LK) and until feasibility is achieved for (LC). We describe these algorithms in a form that is convenient for introducing later extensions, without consideration of details relating to efficient implementation (although we later describe fast updating methods for elements that change).
                           
                              
                                 
                                 
                                    
                                       
                                          Greedy (LK)
                                       
                                    
                                    
                                       
                                          
                                          Initialize:
                                    
                                    
                                       
                                          
                                          x
                                          
                                             j
                                          
                                          =0 for all j
                                          ∈
                                          N
                                       
                                    
                                    
                                       
                                          
                                          N1=∅ (N1 is the index set for variables x
                                          
                                             j
                                           currently set to 1)
                                    
                                    
                                       
                                          RHS=
                                          a
                                          
                                             o
                                           (RHS is the current “right hand side”)
                                    
                                    
                                       
                                          
                                          N
                                          
                                             o
                                          
                                          ={j
                                          ∈
                                          N: a
                                          
                                             j
                                          
                                          ⩽RHS} (N
                                          
                                             o
                                           is the index set for variables x
                                          
                                             j
                                           that can feasibly
                                    
                                    
                                       
                                          be set to 1 at a given iteration of the following loop)
                                    
                                    
                                       While RHS>0 and N
                                          
                                             o
                                          
                                          ≠∅
                                    
                                    
                                       
                                          
                                          j
                                          ∗
                                          =argmax(RK
                                             j
                                          : j
                                          ∈
                                          N
                                          
                                             o
                                          )
                                    
                                    
                                       
                                          
                                          
                                             
                                                
                                                   
                                                      x
                                                   
                                                   
                                                      
                                                         
                                                            j
                                                         
                                                         
                                                            ∗
                                                         
                                                      
                                                   
                                                
                                                =
                                                1
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                          N1=
                                          N1∪{j
                                          ∗}
                                    
                                    
                                       
                                          
                                          
                                             
                                                RHS
                                                =
                                                RHS
                                                -
                                                
                                                   
                                                      a
                                                   
                                                   
                                                      j
                                                   
                                                   
                                                      ∗
                                                   
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                          N
                                          
                                             o
                                          
                                          =
                                          N
                                          
                                             o
                                          
                                          −{j
                                          ∗}
                                    
                                    
                                       
                                          
                                          N
                                          
                                             o
                                          
                                          ={j
                                          ∈
                                          N
                                          
                                             o
                                          : a
                                          
                                             j
                                          
                                          ⩽RHS}
                                    
                                    
                                       Endwhile
                                    
                                    
                                       (Upon concluding, x
                                          
                                             j
                                          
                                          =1 for j
                                          ∈
                                          N1 and x
                                          
                                             j
                                          
                                          =0 otherwise.)
                                    
                                 
                              
                           
                        
                     

We remark that the set N
                        
                           o
                         does not have to be explicitly identified and updated in the context of the simple (LK) problem, since it suffices to identify j
                        ∗ by writing
                           
                              
                                 
                                    
                                       j
                                    
                                    
                                       ∗
                                    
                                 
                                 =
                                 arg
                                 
                                 max
                                 (
                                 
                                    
                                       RK
                                    
                                    
                                       j
                                    
                                 
                                 :
                                 j
                                 ∈
                                 N
                                 -
                                 N
                                 1
                                 :
                                 
                                    
                                       a
                                    
                                    
                                       j
                                    
                                 
                                 ⩽
                                 RHS
                                 )
                              
                           
                        However, explicit reference to N
                        
                           o
                         is useful for the context where knapsacks are generated by surrogate constraints in solving multidimensional knapsack problems, as discussed in Section 7.
                           
                              
                                 
                                 
                                    
                                       
                                          Greedy (LC)
                                       
                                    
                                    
                                       
                                          
                                          Initialize:
                                    
                                    
                                       
                                          
                                          y
                                          
                                             j
                                          
                                          =0 for all j
                                          ∈
                                          N
                                       
                                    
                                    
                                       
                                          
                                          N1=∅ (N1 is the index set for variables y
                                          
                                             j
                                           currently set to 1)
                                    
                                    
                                       
                                          RHS=
                                          d
                                          
                                             o
                                           (RHS is the current “right hand side”)
                                    
                                    
                                       
                                          While RHS>0 and N1≠
                                          N
                                       
                                    
                                    
                                       
                                          
                                          j
                                          ∗
                                          =argmin(RC
                                             j
                                          : j
                                          ∈
                                          N
                                          −
                                          N1)
                                    
                                    
                                       
                                          
                                          
                                             
                                                
                                                   
                                                      y
                                                   
                                                   
                                                      
                                                         
                                                            j
                                                         
                                                         
                                                            ∗
                                                         
                                                      
                                                   
                                                
                                                =
                                                1
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                          N1=
                                          N1∪{j
                                          ∗}
                                    
                                    
                                       
                                          
                                          
                                             
                                                RHS
                                                =
                                                RHS
                                                -
                                                
                                                   
                                                      d
                                                   
                                                   
                                                      j
                                                   
                                                   
                                                      ∗
                                                   
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          Endwhile
                                    
                                    
                                       
                                          If N1=
                                          N and RHS>0, problem (LC) has no feasible solution.
                                    
                                    
                                       
                                          (Otherwise, the algorithm yields y
                                          
                                             j
                                          
                                          =1 for j
                                          ∈
                                          N1 and y
                                          
                                             j
                                          
                                          =0 for j
                                          ∈
                                          N
                                          −
                                          N1.)
                                    
                                 
                              
                           
                        
                     

As previously indicated, Greedy (LK) and Greedy (LC) do not necessarily yield equivalent solutions. To make the methods more nearly comparable, a post-greedy process can be applied in conjunction with Greedy (LC) as follows.
                           
                              
                                 
                                 
                                    
                                       
                                          Post-Greedy (LC)
                                       
                                    
                                    
                                       
                                          For j
                                          ∈
                                          N1
                                    
                                    
                                       
                                          Examine indexes j in the reverse order in which they were added to
                                    
                                    
                                       
                                          
                                          N1 (or alternatively in descending order of the d
                                          
                                             j
                                           or c
                                          
                                             j
                                           coefficients)
                                    
                                    
                                       
                                          If RHS+
                                          d
                                          
                                             j
                                          
                                          ⩽0
                                    
                                    
                                       
                                          
                                          
                                          y
                                          
                                             j
                                          
                                          =0
                                    
                                    
                                       
                                          
                                          RHS=RHS+
                                          d
                                          
                                             j
                                          
                                       
                                    
                                    
                                       
                                          
                                          
                                          N1=
                                          N1−{j}
                                    
                                    
                                       
                                          Endif
                                    
                                    
                                       
                                          Endfor
                                    
                                 
                              
                           
                        
                        Comment. A different type of greedy algorithm can be specified for (LC) that is in fact equivalent to Greedy (LK). This algorithm modifies Greedy (LK) to start by setting y
                        
                           j
                        
                        =1 for all j
                        ∈
                        N and 
                           
                              RHS
                              =
                              ∑
                              (
                              
                                 
                                    d
                                 
                                 
                                    j
                                 
                              
                              :
                              j
                              ∈
                              N
                              )
                              -
                              
                                 
                                    d
                                 
                                 
                                    o
                                 
                              
                           
                        , and then replacing “a
                        
                           j
                        ” by “d
                        
                           j
                        ”, “RK
                           j
                        ” by “RC
                           j
                        ” and “x
                        
                           j
                        
                        =1” by “y
                        
                           j
                        
                        =0” (including in the case where j
                        =
                        j
                        ∗). Traditionally, however, greedy algorithms for the covering problem are formulated by reference to starting with all variables equal to 0.

It is also possible to improve the greedy solution of (LK) by post-processing. We do not bother to state such a post-processing approach in this case, because the advanced greedy methods together with the associated strategies described in the knapsack context in succeeding sections render such an approach significantly less relevant.

We now observe that these methods can be extended in a straightforward way to handle quadratic problems. However, for reasons to be elaborated later, we call these naïve greedy methods.

Relative to the set N1={j
                        ∈
                        N: x
                        
                           j
                        
                        =1} for the knapsack problem, and the set N1={j
                        ∈
                        N: y
                        
                           j
                        
                        =1} for the covering problem, define the quadratic profit QPj for j
                        ∈
                        N
                        −
                        N1 in the knapsack case, and the quadratic cost QCj for j
                        ∈
                        N
                        −
                        N1 in the covering case, as follows:
                           
                              
                                 
                                    
                                       
                                       
                                          
                                             QPj
                                             =
                                             
                                                
                                                   p
                                                
                                                
                                                   j
                                                
                                             
                                             +
                                             
                                                ∑
                                             
                                             (
                                             
                                                
                                                   p
                                                
                                                
                                                   hj
                                                
                                             
                                             :
                                             h
                                             ∈
                                             N
                                             1
                                             )
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             QCj
                                             =
                                             
                                                
                                                   c
                                                
                                                
                                                   j
                                                
                                             
                                             +
                                             
                                                ∑
                                             
                                             (
                                             
                                                
                                                   c
                                                
                                                
                                                   hj
                                                
                                             
                                             :
                                             h
                                             ∈
                                             N
                                             1
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        We employ the convention that a summation over the empty set is 0, hence QPj=
                        p
                        
                           j
                         and QCj=
                        c
                        
                           j
                         if N1=∅.

The greedy single constraint quadratic objective algorithms that directly correspond to the algorithms for linear objective problems can then be expressed as:
                           
                              
                                 Naïve Greedy (QK)

Replace the ratio RK
                                    j
                                 
                                 =
                                 p
                                 
                                    j
                                 /a
                                 
                                    j
                                  in Greedy (LK) by the ratio RQK
                                    j
                                 
                                 =QPj/a
                                 
                                    j
                                 
                                 
                                    
                                       
                                          for
                                          
                                          j
                                          ∈
                                          
                                             
                                                N
                                             
                                             
                                                o
                                             
                                          
                                       
                                    
                                 
                              

Then Naïve Greedy (QK) has the same statement as Greedy (LK)


                                 Naïve Greedy (QC)

Replace the ratio RC
                                    j
                                 
                                 =
                                 c
                                 
                                    j
                                 /d
                                 
                                    j
                                  in Greedy (CK) by the ratio RQCj=QCj/d
                                 
                                    j
                                 
                                 
                                    
                                       
                                          for
                                          
                                          j
                                          ∈
                                          N
                                          -
                                          N
                                          1
                                       
                                    
                                 
                              

Then Naïve Greedy (QC) has the same statement as Greedy (LC).

The use of the ratio RQK
                           j
                         was proposed by Hiley and Julstrom (2006). In the following sections, we first introduce the advanced greedy algorithms for the linear and quadratic problems. Then we consider how the naïve greedy approaches can be improved by means of a graduated-probe strategy, which also can be used to enhance the solution process for linear objectives.

The advanced greedy algorithms can be stated in a direct manner by reference to the format used to state the preceding methods.

The advanced greedy algorithms replace the bang-for-buck ratios RK
                           j
                        
                        =
                        p
                        
                           j
                        /a
                        
                           j
                         and RC
                           j
                        
                        =
                        c
                        
                           j
                        /d
                        
                           j
                         of the Greedy (LK) and Greedy (LC) algorithms with quantities (products) PK
                           j
                         and PC
                           j
                         defined as follows. To identify these products we take advantage of quantities n
                        
                           j
                         and n0, and m
                        
                           j
                         and m0, exploited in connection with surrogate constraint knapsack and covering problems in Glover (1965). The n
                        
                           j
                         quantities were also employed in Akcay et al. (2007) in the context of multi-constraint knapsack problems.
                           
                              
                                 Determination of PK
                                 
                                    j
                                 :

Relative to the value 
                           
                              RHS
                              =
                              
                                 
                                    a
                                 
                                 
                                    o
                                 
                              
                              -
                              ∑
                              (
                              
                                 
                                    a
                                 
                                 
                                    j
                                 
                              
                              :
                              j
                              ∈
                              N
                              1
                              )
                           
                         computed and updated as in the Greedy (LK) algorithm let
                           
                              
                                 
                                    
                                       n
                                    
                                    
                                       j
                                    
                                 
                                 =
                                 ⌊
                                 RHS
                                 /
                                 
                                    
                                       a
                                    
                                    
                                       j
                                    
                                 
                                 ⌋
                                 
                                 where
                                 
                                 ⌊
                                 
                                 ⌋
                                 
                                 is
                                 
                                 the
                                 
                                 integer
                                 
                                 floor
                                 
                                 function
                              
                           
                        Assume N is indexed so that the a
                        
                           j
                         coefficients appear in ascending order, and moreover, we have extracted the subset of these indexes for the current set N
                        
                           o
                        , which we denote by {1,…,
                        q} to give a
                        1
                        ⩽⋯⩽
                        a
                        
                           q
                         for q
                        =∣N
                        
                           o
                        ∣. (The original indexing and the extraction can easily be handled by a doubly linked list allowing an element j to be removed from the sequence by linking the predecessor of j to its successor.) Let n0 be the largest index ⩽q in N
                        
                           o
                         such that a
                        1
                        +⋯+
                        a
                        
                           n0
                        ⩽RHS. (Thus, n0 maximizes 
                           
                              ∑
                              (
                              
                                 
                                    x
                                 
                                 
                                    j
                                 
                              
                              ;
                              j
                              ∈
                              
                                 
                                    N
                                 
                                 
                                    o
                                 
                              
                              )
                           
                         subject to the knapsack constraint.)

Finally, let 
                           
                              
                                 
                                    n
                                 
                                 
                                    j
                                 
                                 
                                    ′
                                 
                              
                              =
                              Min
                              (
                              
                                 
                                    n
                                 
                                 
                                    j
                                 
                              
                              ,
                              n
                              0
                              )
                           
                        . Then we define
                           
                              
                                 PKj
                                 =
                                 
                                    
                                       p
                                    
                                    
                                       j
                                    
                                 
                                 
                                    
                                       n
                                    
                                    
                                       j
                                    
                                    
                                       ′
                                    
                                 
                              
                           
                        Then the Advanced Greedy (LK) algorithm can be expressed as follows.
                           
                              
                                 Advanced Greedy (LK)
                              

Replace the ratio RK
                                    j
                                 
                                 =
                                 p
                                 
                                    j
                                 /a
                                 
                                    j
                                  in Greedy(LK) by the product 
                                    
                                       PKj
                                       =
                                       
                                          
                                             p
                                          
                                          
                                             j
                                          
                                       
                                       
                                          
                                             n
                                          
                                          
                                             j
                                          
                                          
                                             ′
                                          
                                       
                                    
                                 
                                 
                                    
                                       
                                          for
                                          
                                          j
                                          ∈
                                          
                                             
                                                N
                                             
                                             
                                                o
                                             
                                          
                                       
                                    
                                 
                              

Then the Advanced Greedy (LK) has the same statement as Greedy (LK).

The analogous product PC
                           j
                         and the associated advanced greedy algorithm for the covering problem are given as follows.

Relative to the value 
                           
                              RHS
                              =
                              
                                 
                                    d
                                 
                                 
                                    o
                                 
                              
                              -
                              ∑
                              (
                              
                                 
                                    d
                                 
                                 
                                    j
                                 
                              
                              :
                              j
                              ∈
                              N
                              1
                              )
                           
                         computed and updated as in the Greedy (LC) algorithm, let
                           
                              
                                 
                                    
                                       m
                                    
                                    
                                       j
                                    
                                 
                                 =
                                 ⌈
                                 RHS
                                 /
                                 
                                    
                                       d
                                    
                                    
                                       j
                                    
                                 
                                 ⌉
                                 
                                 where
                                 
                                 ⌈
                                 
                                 rceil
                                 
                                 is
                                 
                                 the
                                 
                                 integer
                                 
                                 ceiling
                                 
                                 function
                              
                           
                        Assume the indexes in N
                        −
                        N1 are ordered so the d
                        
                           j
                         coefficients by this indexing yield d
                        1
                        ⩾⋯⩾
                        d
                        
                           p
                        , where p
                        =∣N
                        −
                        N1∣. Let m0 be the smallest index in N
                        −
                        N1 such that d
                        1
                        +⋯+
                        d
                        
                           m0
                        ⩾RHS. (Thus, m0 minimizes 
                           
                              ∑
                              (
                              
                                 
                                    x
                                 
                                 
                                    j
                                 
                              
                              ;
                              j
                              ∈
                              N
                              -
                              N
                              1
                              )
                           
                        .) If m0 is undefined (i.e., d
                        1
                        +⋯+
                        d
                        
                           p
                        
                        <RHS), then (LC) has no feasible solution. Finally, let 
                           
                              
                                 
                                    m
                                 
                                 
                                    j
                                 
                                 
                                    ′
                                 
                              
                              =
                              Max
                              (
                              
                                 
                                    m
                                 
                                 
                                    j
                                 
                              
                              ,
                              m
                              0
                              )
                           
                        . Then we define
                           
                              
                                 PCj
                                 =
                                 
                                    
                                       c
                                    
                                    
                                       j
                                    
                                 
                                 
                                    
                                       m
                                    
                                    
                                       j
                                    
                                    
                                       ′
                                    
                                 
                              
                           
                        
                        
                           
                              
                                 Advanced Greedy (LC)
                              

Replace the ratio RC
                                    j
                                 
                                 =
                                 c
                                 
                                    j
                                 /d
                                 
                                    j
                                  in Greedy(LC) by the product 
                                    
                                       PCj
                                       =
                                       
                                          
                                             c
                                          
                                          
                                             j
                                          
                                       
                                       
                                          
                                             m
                                          
                                          
                                             j
                                          
                                          
                                             ′
                                          
                                       
                                    
                                 
                                 
                                    
                                       
                                          for
                                          
                                          j
                                          ∈
                                          N
                                          -
                                          N
                                          1
                                       
                                    
                                 Then the Advanced Greedy (LC) has the same statement as Greedy (LC)

The linked lists used to identify the ordering of the a
                        
                           j
                         and d
                        
                           j
                         coefficients can be accompanied by a fast update procedure that allows values of n0 and m0 to be identified highly efficiently on each iteration.


                           
                              
                                 
                                    
                                    
                                       
                                          
                                             Initialization.
                                          
                                       
                                       
                                          For descriptive purposes, let the auxiliary indexing j(h) identify the ordering
                                       
                                       
                                          
                                             
                                             a
                                             
                                                j(1)
                                             ⩽
                                             a
                                             
                                                j(2)
                                             ⩽⋯⩽
                                             a
                                             
                                                j(n)
                                          
                                       
                                       
                                          We identify this ordering by a linked list where j
                                             =FirstIndex identifies j(1), then j
                                             =After(j) identifies all remaining j(h). Let Before(j) be the reverse linked list, and set Before(FirstIndex)=
                                             n
                                             +1 and After(n)=
                                             n
                                             +2.
                                       
                                       
                                          Using the linked list:
                                       
                                       
                                          
                                             Identify n0 so that a
                                             
                                                j(1)
                                             +⋯+
                                             a
                                             
                                                j(no)
                                             ⩽
                                             a
                                             
                                                o
                                              and=
                                             a
                                             
                                                j(1)
                                             +⋯+
                                             a
                                             
                                                j(no+1)
                                             >
                                             a
                                             
                                                o
                                             
                                          
                                       
                                       
                                          
                                             Record KeyIndex=
                                             j(n0) and KeySum=
                                             a
                                             
                                                j(1)
                                             +⋯+
                                             a
                                             
                                                j(no).
                                       
                                       
                                          
                                             For j
                                             =
                                             j(h), let KeySet(j)=true for h
                                             ⩽
                                             n0 and KeySet(j)=false for h
                                             >
                                             n0
                                       
                                       
                                          
                                             Update when j
                                             ∗ 
                                             is selected and 
                                             
                                                
                                                   RHS
                                                   =
                                                   RHS
                                                   -
                                                   
                                                      
                                                         a
                                                      
                                                      
                                                         
                                                            
                                                               j
                                                            
                                                            
                                                               ∗
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          jBefore=Before(j
                                             ∗) and jAfter=After(j
                                             ∗)
                                       
                                       
                                          After(jBefore)=jAfter and Before(jAfter)=jBefore
                                       
                                       
                                          If KeySet(j
                                             ∗)=true
                                       
                                       
                                          
                                             
                                             n0=
                                             n0−1
                                       
                                       
                                          
                                             
                                             
                                                
                                                   KeySum
                                                   =
                                                   KeySum
                                                   -
                                                   
                                                      
                                                         a
                                                      
                                                      
                                                         
                                                            
                                                               j
                                                            
                                                            
                                                               ∗
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             If j
                                             ∗
                                             =KeyIndex then KeyIndex=jBefore
                                       
                                       
                                          Else
                                       
                                       
                                          
                                             
                                             j
                                             =KeyIndex
                                       
                                       
                                          
                                             While KeySum>RHS
                                       
                                       
                                          
                                             KeySet(j)=false
                                       
                                       
                                          
                                             
                                             n0=
                                             n0−1
                                       
                                       
                                          
                                             KeySum=KeySum−
                                             a
                                             
                                                j
                                             
                                          
                                       
                                       
                                          
                                             
                                             j
                                             =Before(j)
                                       
                                       
                                          
                                             Endwhile
                                       
                                       
                                          Endif
                                       
                                    
                                 
                              
                           
                        

We observe that when KeySet(j
                           ∗)=true, so that j
                           ∗
                           =
                           j(h) for h
                           ⩽
                           n0, the implication is that dropping 
                              
                                 
                                    
                                       a
                                    
                                    
                                       
                                          
                                             j
                                          
                                          
                                             ∗
                                          
                                       
                                    
                                 
                              
                            both from RHS and from KeySum means that we continue to satisfy KeySum⩽RHS and KeySum+
                           a
                           
                              j(n0+1)
                           >RHS, where n0 refers to the “old n0” before updating. Thus KeySet(j)=true accurately identifies the indexes that define KeySum, noting that j
                           ∗ has been removed (so it is not necessary to set KeySet(j
                           ∗)=false) and hence n0 must decrease by 1. On the other hand, when KeySet(j
                           ∗)=false, 
                              
                                 
                                    
                                       a
                                    
                                    
                                       
                                          
                                             j
                                          
                                          
                                             ∗
                                          
                                       
                                    
                                 
                              
                            has not been removed from KeySum, and we iteratively check whether KeySum>RHS to determine if the “last j” in the sequence defining KeySum needs to be dropped.

A corresponding fast update identifies the new m0 value for the covering problem, making use of the same doubly linked list but tracing it backward from larger to smaller a
                           
                              j
                            values.

We give an interpretation of the product term PK
                           j
                         used in Advanced Greedy (LK) to motivate its use. (An analogous interpretation applies to the term PC
                           j
                         used in Advanced Greedy (LC).)

First, note that the ratio RK
                           j
                        
                        =
                        p
                        
                           j
                        /a
                        
                           j
                         used in the classical greedy algorithm can be scaled by RHS so that it can be replaced by the product p
                        
                           j
                        (RHS/a
                        
                           j
                        ) without changing the choice of j
                        ∗. Moreover, RHS/a
                        
                           j
                         can be interpreted as the value x
                        
                           j
                         would receive in the relaxation of the current instance of (LK) where the 0–1 restriction is replaced by requiring the variables simply to be non-negative. However, if we add the condition that x
                        
                           j
                         is an integer variable, the value RHS/a
                        
                           j
                         can be replaced by n
                        
                           j
                        
                        =⌊RHS/a
                        
                           j
                        ⌋ as in the bounding process of Glover (1965). Thus n
                        
                           j
                         represents the “number of times” the 0–1 variable x
                        
                           j
                         could be used to form an approximate solution to the current instance of (LK) if an ideal number of copies of x
                        
                           j
                         existed. But an additional implication of the 0–1 condition is that the largest legitimate number of such copies cannot exceed n0. In short, the ideal number of copies of x
                        
                           j
                         equals 
                           
                              
                                 
                                    n
                                 
                                 
                                    j
                                 
                                 
                                    ′
                                 
                              
                              =
                              Min
                              (
                              
                                 
                                    n
                                 
                                 
                                    j
                                 
                              
                              ,
                              n
                              0
                              )
                           
                        . Finally, the ideal contribution of x
                        
                           j
                         (and its potential copies) to the objective function will be 
                           
                              
                                 
                                    p
                                 
                                 
                                    j
                                 
                              
                              
                                 
                                    n
                                 
                                 
                                    j
                                 
                                 
                                    ′
                                 
                              
                           
                        , which is precisely the product PK
                           j
                        .

The use of PK
                           j
                         automatically overcomes a deficiency of the classical greedy algorithm, which can be illustrated by the simple problem
                           
                              
                                 
                                    
                                       
                                          
                                             Maximize
                                          
                                       
                                       
                                          
                                             
                                             10
                                             
                                                
                                                   x
                                                
                                                
                                                   1
                                                
                                             
                                             +
                                             1000
                                             
                                                
                                                   x
                                                
                                                
                                                   2
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                             5
                                             
                                                
                                                   x
                                                
                                                
                                                   1
                                                
                                             
                                             +
                                             501
                                             
                                                
                                                   x
                                                
                                                
                                                   2
                                                
                                             
                                             ⩽
                                             505
                                          
                                       
                                    
                                 
                              
                           
                        The classical greedy algorithm gives the solution x
                        1
                        =1 and x
                        2
                        =0, whereas the solution x
                        1
                        =0 and x
                        2
                        =1 is much better. The example can easily be changed to make the difference between the greedy solution and the optimal solution arbitrarily large, and the typical proposed “fix” is to select j
                        ∗ by reference to the max p
                        
                           j
                         value on the last assignment step of the algorithm, instead of by reference to the max ratio p
                        
                           j
                        /a
                        
                           j
                        . The Advanced Greedy (LK) not only avoids this problem but removes a variety of other potential deficiencies as well. (It should be observed that the use of n
                        
                           j
                         by itself does not avoid this difficulty, but that we also require reference to n0 in defining 
                           
                              
                                 
                                    n
                                 
                                 
                                    j
                                 
                                 
                                    ′
                                 
                              
                           
                        .)

The determination of j
                        ∗ in the advanced greedy algorithm requires somewhat more work than in the classical greedy algorithm. This is not due to the work of identifying n0 (when the fast update described above is used) but rather due to the fact that the n
                        
                           j
                         and 
                           
                              
                                 
                                    n
                                 
                                 
                                    j
                                 
                                 
                                    ′
                                 
                              
                           
                         values are not constant from iteration to iteration. This means they do not necessarily fall in the same descending sequence order as the ratios RK
                           j
                         (an order which, once determined, does not change).

On the other hand, the issue of determining j
                        ∗ quickly for the advanced method becomes irrelevant in the context of solving quadratic knapsack problems, since as previously noted the profit p
                        
                           j
                         of the linear problem is replaced by the quantity QP
                           j
                         that changes from iteration to iteration, and hence there is no fixed descending order sequence for these quantities. The same is true for multi-constraint knapsack problems, where the generation of surrogate constraints causes the a
                        
                           j
                         coefficients and RHS values defining both the RKj ratios and the PKj products to change for each new surrogate constraint.

The Naïve Greedy (QK) and (QC) algorithms for quadratic problems can be advanced in the same manner as the Greedy (LK) and (LC) algorithms, by replacing ratio terms with corresponding product terms employing the values 
                        
                           
                              
                                 n
                              
                              
                                 j
                              
                              
                                 ′
                              
                           
                        
                      and 
                        
                           
                              
                                 m
                              
                              
                                 j
                              
                              
                                 ′
                              
                           
                        
                     . However, this replacement is not enough to remove the naïve character of the classical methods in the quadratic case, which effectively renders them too myopic to generate solutions of reasonably high quality.

To overcome this limitation requires increasing the computational effort to respond to the additional complexity introduced by the quadratic structure, which grows roughly by the square of the number of variables. (The increase in complexity is actually somewhat greater, since this squared growth becomes magnified by the exponential behavior typical of NP hard problems.) We consider a specialized approach that increases the computational effort by a constant factor, which (according to a choice among options) multiplies the work of selecting j
                     ∗ in the naïve approach by examining from 5 to 7 additional candidates for j
                     ∗ at each iteration, which in turn translates into examining approximately 10–50 related cross product terms x
                     
                        j
                     
                     x
                     
                        h
                     . Again we restrict attention to the knapsack problem, since the corresponding considerations for the covering problem can be established by direct analogy.

First we examine the nature of the limitation encountered by the Naïve Greedy (QK) method to motivate our alternative approach. Essentially the profit value 
                           
                              QPj
                              =
                              
                                 
                                    p
                                 
                                 
                                    j
                                 
                              
                              +
                              ∑
                              (
                              
                                 
                                    p
                                 
                                 
                                    hj
                                 
                              
                              :
                              h
                              ∈
                              N
                              1
                              )
                           
                         embodied in the ratio RQK
                           j
                        
                        =QPj/a
                        
                           j
                         contains insufficient information to make an intelligent choice when the set N1={j
                        ∈
                        N: x
                        
                           j
                        
                        =1} is small. Since the composition of N1 depends on past choices of j
                        ∗ (added to N1 at each iteration), the value QPj does not reflect the interactions of the current choice of 
                           
                              
                                 
                                    x
                                 
                                 
                                    
                                       
                                          j
                                       
                                       
                                          ∗
                                       
                                    
                                 
                              
                              =
                              1
                           
                         with potential future choices of other variables to set to 1. Instead QPj only gives “retrospective guidance” relative to interactions between current candidates for 
                           
                              
                                 
                                    x
                                 
                                 
                                    
                                       
                                          j
                                       
                                       
                                          ∗
                                       
                                    
                                 
                              
                           
                         and past choices of other variables that previously have taken the role of 
                           
                              
                                 
                                    x
                                 
                                 
                                    
                                       
                                          j
                                       
                                       
                                          ∗
                                       
                                    
                                 
                              
                           
                        .

This retrospective weakness is especially pronounced in early iterations of the algorithm, where N1 is small and few variables have been set to 1. On the first iteration, when N1 is empty, the choice of j
                        ∗ depends solely on the value of p
                        
                           j
                        /a
                           j
                        , so that no potential interactions with other variables are considered at all. In short, the choice of j
                        ∗ on this first step is very nearly “blind”, and the choices that immediately follow have scarcely more information to rely on. Moreover, since these early choices strongly influence the choices subsequently made, a process that makes poor initial choices can degrade the entire collection of choices.

To make a more informed choice, we modify the Greedy (QK) algorithm to incorporate an evaluation that anticipates the impact of potential future choices. This is accomplished by making use of a simple candidate list idea.

We extend the process of identifying a “best” variable 
                           
                              
                                 
                                    x
                                 
                                 
                                    
                                       
                                          j
                                       
                                       
                                          ∗
                                       
                                    
                                 
                              
                           
                         by identifying b best x
                        
                           j
                         candidate variables to become x
                        
                           j
                         by using either the greedy evaluation or the advanced greedy evaluation, and denote their indexes by j1,
                        j2,…,
                        jb. (Hence j1 corresponds to j
                        ∗.) Taking advantage of these candidates, we create a “best anticipated evaluation” for each of these b choices by first evaluating 2-element or 3-element combinations of these choices and then considering the contribution of each candidate to the resulting combinations. (If b
                        =5, for example, then the possible 2-element combinations can be represented by (j(p), j(q)) for p
                        =1–4, and q
                        =
                        p
                        +1–5, and the possible 3-element combinations can be represented by (j(p), j(q), j(r)) for p
                        =1–3, q
                        =
                        p
                        +1–4, and r
                        =
                        q
                        +1–5.)

The Graduated-Probe Strategy consists of two parts, a Combination Evaluation Method and a Choice Rule for Selecting j
                        ∗ that makes use of the combination evaluations.

We first describe the method for evaluating combinations by reference to bang-for-buck ratios of the type used in the classical methods, and then by reference to product terms of the type used in the advanced greedy methods.

For simplicity, first consider the evaluation of 2-element combinations, where we represent the indexes for the combination currently examined by j
                              =1 and j
                              =2 for j
                              ∈
                              N
                              −
                              N1 (i.e., x
                              
                                 j
                               is among the “unassigned” variables currently set=0). Denote the profit of this 2-element combination by QProfit(1,2), which is analogous to the profit contribution of a single variable x
                              
                                 j
                               which we have represented by 
                                 
                                    
                                       
                                          QP
                                       
                                       
                                          j
                                       
                                    
                                    (
                                    =
                                    
                                       
                                          p
                                       
                                       
                                          j
                                       
                                    
                                    +
                                    ∑
                                    (
                                    
                                       
                                          p
                                       
                                       
                                          hj
                                       
                                    
                                    :
                                    h
                                    ∈
                                    N
                                    1
                                    )
                                 
                              . In view of the meaning of QP
                                 j
                               we infer that setting x
                              1
                              =
                              x
                              2
                              =1 will yield a profit of
                                 
                                    
                                       QProfit
                                       (
                                       1
                                       ,
                                       2
                                       )
                                       =
                                       
                                          
                                             QP
                                          
                                          
                                             1
                                          
                                       
                                       +
                                       
                                          
                                             QP
                                          
                                          
                                             2
                                          
                                       
                                       +
                                       
                                          
                                             p
                                          
                                          
                                             12
                                          
                                       
                                    
                                 
                              The act of setting x
                              1
                              =
                              x
                              2
                              =1 also results in consuming resources from the knapsack equal to a
                              1
                              +
                              a
                              2, and hence the appropriate bang-for-buck ratio QRatio(1,2) is given by
                                 
                                    
                                       QRatio
                                       (
                                       1
                                       ,
                                       2
                                       )
                                       =
                                       QProfit
                                       (
                                       1
                                       ,
                                       2
                                       )
                                       /
                                       (
                                       
                                          
                                             a
                                          
                                          
                                             1
                                          
                                       
                                       +
                                       
                                          
                                             a
                                          
                                          
                                             2
                                          
                                       
                                       )
                                    
                                 
                              Similarly, to evaluate a 3-element combination, whose indexes j
                              ∈
                              N
                              −
                              N1 are denoted by 1, 2 and 3, we obtain a profit contribution of
                                 
                                    
                                       QProfit
                                       (
                                       1
                                       ,
                                       2
                                       ,
                                       3
                                       )
                                       =
                                       
                                          
                                             QP
                                          
                                          
                                             1
                                          
                                       
                                       +
                                       
                                          
                                             QP
                                          
                                          
                                             2
                                          
                                       
                                       +
                                       
                                          
                                             QP
                                          
                                          
                                             3
                                          
                                       
                                       +
                                       
                                          
                                             p
                                          
                                          
                                             12
                                          
                                       
                                       +
                                       
                                          
                                             p
                                          
                                          
                                             13
                                          
                                       
                                       +
                                       
                                          
                                             p
                                          
                                          
                                             23
                                          
                                       
                                    
                                 
                              and a bang-for-buck ratio of
                                 
                                    
                                       QRatio
                                       (
                                       1
                                       ,
                                       2
                                       ,
                                       3
                                       )
                                       =
                                       QProfit
                                       (
                                       1
                                       ,
                                       2
                                       ,
                                       3
                                       )
                                       /
                                       (
                                       
                                          
                                             a
                                          
                                          
                                             1
                                          
                                       
                                       +
                                       
                                          
                                             a
                                          
                                          
                                             2
                                          
                                       
                                       +
                                       
                                          
                                             a
                                          
                                          
                                             3
                                          
                                       
                                       )
                                    
                                 
                              It may be noted that the QProfit contribution in the numerator of QRatio grows more rapidly than the knapsack resource utilization in the denominator. This growth difference is still more pronounced for 4-element combinations, where the profit contribution becomes
                                 
                                    
                                       QProfit
                                       (
                                       1
                                       ,
                                       2
                                       ,
                                       3
                                       ,
                                       4
                                       )
                                       =
                                       
                                          
                                             QP
                                          
                                          
                                             1
                                          
                                       
                                       +
                                       
                                          
                                             QP
                                          
                                          
                                             2
                                          
                                       
                                       +
                                       
                                          
                                             QP
                                          
                                          
                                             3
                                          
                                       
                                       +
                                       
                                          
                                             QP
                                          
                                          
                                             4
                                          
                                       
                                       +
                                       
                                          
                                             p
                                          
                                          
                                             12
                                          
                                       
                                       +
                                       
                                          
                                             p
                                          
                                          
                                             13
                                          
                                       
                                       +
                                       
                                          
                                             p
                                          
                                          
                                             14
                                          
                                       
                                       +
                                       
                                          
                                             p
                                          
                                          
                                             23
                                          
                                       
                                       +
                                       
                                          
                                             p
                                          
                                          
                                             24
                                          
                                       
                                       +
                                       
                                          
                                             p
                                          
                                          
                                             34
                                          
                                       
                                    
                                 
                              while the resource utilization is just a
                              1
                              +
                              a
                              2
                              +
                              a
                              3
                              +
                              a
                              4.

Letting QProfit(1)=QP1, and letting [a, b] denote the closed interval of integers from a to b, then for any r
                              ⩾2 we have
                                 
                                    
                                       QProfit
                                       (
                                       1
                                       ,
                                       …
                                       ,
                                       r
                                       )
                                       =
                                       
                                          ∑
                                       
                                       (
                                       
                                          
                                             QP
                                          
                                          
                                             j
                                          
                                       
                                       :
                                       j
                                       ∈
                                       [
                                       1
                                       ,
                                       r
                                       ]
                                       )
                                       +
                                       
                                          
                                             Delta
                                          
                                          
                                             r
                                          
                                       
                                    
                                 
                              where 
                                 
                                    
                                       
                                          Delta
                                       
                                       
                                          r
                                       
                                    
                                    =
                                    ∑
                                    (
                                    
                                       
                                          p
                                       
                                       
                                          hj
                                       
                                    
                                    :
                                    h
                                    ∈
                                    [
                                    1
                                    ,
                                    r
                                    -
                                    1
                                    ]
                                    ,
                                    j
                                    ∈
                                    [
                                    h
                                    +
                                    1
                                    ,
                                    r
                                    ]
                                    )
                                    (
                                    
                                       
                                          Delta
                                       
                                       
                                          r
                                       
                                    
                                    =
                                    0
                                 
                               if r
                              =1). Here we assume the indexes j
                              ∈[1, r] belong to N
                              −
                              N1 (={j
                              ∈
                              N: x
                              
                                 j
                              
                              =0}). To compute QProfit with slightly less effort, and using the convention QProfit
                                 k
                              (1)=
                              Q
                              1k
                              , the foregoing can also be written for r
                              >1 as
                                 
                                    
                                       QProfit
                                       (
                                       1
                                       ,
                                       …
                                       ,
                                       r
                                       )
                                       =
                                       QProfit
                                       (
                                       1
                                       ,
                                       …
                                       ,
                                       r
                                       -
                                       1
                                       )
                                       +
                                       
                                          
                                             QP
                                          
                                          
                                             r
                                          
                                       
                                       +
                                       
                                          
                                             PostDelta
                                          
                                          
                                             r
                                          
                                       
                                    
                                 
                              where 
                                 
                                    
                                       
                                          PostDelta
                                       
                                       
                                          r
                                       
                                    
                                    =
                                    ∑
                                    (
                                    
                                       
                                          p
                                       
                                       
                                          hr
                                       
                                    
                                    :
                                    h
                                    ∈
                                    [
                                    1
                                    ,
                                    r
                                    -
                                    1
                                    ]
                                    )
                                 
                              .

As noted in Garcı́a-Martı́nez (submitted for publication-a), the single-element profit terms QP
                                 j
                               can be updated very efficiently, which permits the foregoing evaluations to be made efficiently as well.

We observe that the foregoing discussion is general by understanding j
                              =1,…,
                              r to be shorthand for j
                              =
                              j(1),…,
                              j(r).

The corresponding evaluation for the Advanced Greedy version of the quadratic problem replaces the values n
                              
                                 j
                               and 
                                 
                                    
                                       
                                          n
                                       
                                       
                                          j
                                       
                                       
                                          ′
                                       
                                    
                                 
                               of the linear problem with values n(1,2) and n′(1,2) for 2-element combinations and with values n(1,2,3) and n′(1,2,3) for 3-element combinations, which in turn yield product terms QProduct(1,2) and QProduct(1,2,3) to replace the preceding ratio terms QRatio(1,2) and QRatio(1,2,3), as follows.
                                 
                                    
                                       2-element combination evaluations:
                                    

Define n(1,2)=⌊RHS/(a
                                       1
                                       +
                                       a
                                       2)⌋ and n′(1,2)=Min(n(1,2), ⌊n0/2⌋). Then
                                          
                                             
                                                QProduct
                                                (
                                                1
                                                ,
                                                2
                                                )
                                                =
                                                QProfit
                                                (
                                                1
                                                ,
                                                2
                                                )
                                                
                                                   
                                                      n
                                                   
                                                   
                                                      ′
                                                   
                                                
                                                (
                                                1
                                                ,
                                                2
                                                )
                                             
                                          
                                       
                                    


                                       3-element combination evaluations:
                                    

Define n(1,2,3)=⌊RHS/(a
                                       1
                                       +
                                       a
                                       2
                                       +
                                       a
                                       3)⌋ and n′(1,2,3)=Min(n(1,2,3), ⌊n0/3⌋). Then
                                          
                                             
                                                QProduct
                                                (
                                                1
                                                ,
                                                2
                                                ,
                                                3
                                                )
                                                =
                                                QProfit
                                                (
                                                1
                                                ,
                                                2
                                                ,
                                                3
                                                )
                                                
                                                   
                                                      n
                                                   
                                                   
                                                      ′
                                                   
                                                
                                                (
                                                1
                                                ,
                                                2
                                                ,
                                                3
                                                )
                                             
                                          
                                       Again, the general form of these expressions is apparent. The same is true of the following remarks.

The value of n0 in these instances is unchanged from its earlier definition. If ⌊n0/2⌋=0 (hence n0<2), then clearly no 2-element combinations exist, and if ⌊n0/3⌋=0 (hence n0<3), then similarly no 3-element combinations exist.

When considering these evaluations both for the greedy and advanced greedy cases, it is evidently necessary to restrict attention in the 2-element case to pairs such that a
                                    1
                                    +
                                    a
                                    2
                                    ⩽RHS, and in the 3-element case to triples such that a
                                    1
                                    +
                                    a
                                    2
                                    +
                                    a
                                    3
                                    ⩽RHS. As a special instance, when examining r-element combinations we require r
                                    ⩽
                                    n0.

Because it is generally more important to use more extensive evaluations in early iterations, it would be reasonable to use 4-element evaluations for some initial number of iterations and then eventually switch to 3-element and ultimately to 2-element evaluations. When n0 reaches 1, the method uses a “1-element” evaluation, which is just the evaluation involving QProfit(1)=QP1 (and a
                                    1).

The choice of b, the number of best candidates for j
                                    ∗, can be varied in a similar manner. For example, b can start at 7 in early iterations and then drop eventually to 6 and then ultimately to 5 or even smaller (noting that we require b
                                    ⩽∣N
                                    
                                       o
                                    ∣).

We exploit the preceding Combination Evaluation Method by using it to select a single element j
                           ∗ for setting 
                              
                                 
                                    
                                       x
                                    
                                    
                                       
                                          
                                             j
                                          
                                          
                                             ∗
                                          
                                       
                                    
                                 
                                 =
                                 1
                              
                           . For concreteness, consider the 3-element case (The 2-element and 4-element cases follow the same design.) Denote the combination that yields the best (maximum) evaluation by (jp, jq, jr). We propose the following two rules for selecting one of the three indexes jp, jq and jr to be j
                           ∗.


                              
                                 
                                    
                                       Rule 1. Assign a weight to each combination, with the largest weight going to the best combination (jp, jq, jr), the next largest weight going to the next best combination, and so forth. Compute the sum of these weighted values for each j index (according to the combinations that contain j) and choose j
                                       ∗ to be the index that receives the largest tally. Ties in the choice of j
                                       ∗ can be broken by choosing the one that yields the largest QP
                                          j
                                       /a
                                       
                                          j
                                        or 
                                          
                                             
                                                
                                                   QP
                                                
                                                
                                                   j
                                                
                                             
                                             
                                                
                                                   n
                                                
                                                
                                                   j
                                                
                                                
                                                   ′
                                                
                                             
                                          
                                        value.


                                       Rule 2. Select one of the j indexes from the winning combination (jp, jq, jr) by selecting the maximum profit coefficient p
                                       jh from the paired combinations (j, h)=(jp, jq), (jp, jr) (jq, jr). The selected combination that yields the largest profit p
                                       
                                          jh
                                        reduces the choice of j
                                       ∗ to be either j
                                       ∗
                                       =
                                       j or j
                                       ∗
                                       =
                                       h. We make this final choice to be the one that yields the maximum bang-for-buck value 
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            p
                                                         
                                                         
                                                            
                                                               
                                                                  j
                                                               
                                                               
                                                                  ∗
                                                               
                                                            
                                                         
                                                      
                                                      +
                                                      
                                                         
                                                            p
                                                         
                                                         
                                                            
                                                               
                                                                  j
                                                               
                                                               
                                                                  ∗
                                                               
                                                            
                                                            j
                                                            0
                                                         
                                                      
                                                   
                                                
                                             
                                             /
                                             
                                                
                                                   a
                                                
                                                
                                                   
                                                      
                                                         j
                                                      
                                                      
                                                         ∗
                                                      
                                                   
                                                
                                             
                                          
                                        or the maximum product 
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            p
                                                         
                                                         
                                                            
                                                               
                                                                  j
                                                               
                                                               
                                                                  ∗
                                                               
                                                            
                                                         
                                                      
                                                      +
                                                      
                                                         
                                                            p
                                                         
                                                         
                                                            
                                                               
                                                                  j
                                                               
                                                               
                                                                  ∗
                                                               
                                                            
                                                            j
                                                            0
                                                         
                                                      
                                                   
                                                
                                             
                                             /
                                             
                                                
                                                   n
                                                
                                                
                                                   
                                                      
                                                         j
                                                      
                                                      
                                                         ∗
                                                      
                                                   
                                                
                                                
                                                   ′
                                                
                                             
                                          
                                        (where j0=
                                       h if j
                                       ∗
                                       =
                                       j and j0=
                                       j if j
                                       ∗
                                       =
                                       h).

Weights can be selected in Rule 1, for example, by giving a weight to each combination equal to the evaluation of that combination. Alternatively, if there are a total of c combinations generated, the weights could be c, c
                              −1,…,1, or (weighting on the 5 best) 5,4,…,1,0,…,0. One reason for having a tie-breaking rule is that not all combinations may exist, in view of Remark 2. (For instance, selecting 3 out of 5 elements would normally generate 10 combinations, but for some of these the sum a
                              1
                              +
                              a
                              2
                              +
                              a
                              3 may exceed RHS.)

Generally speaking, Rule 1 is anticipated to be better than Rule 2, but both are offered as a means to indicate alternative components that may be relevant to a rule for selecting j
                              ∗.

The quadratic multiple knapsack and multiple covering problems consist of assigning variables to different single-constraint knapsacks or covers. We continue to focus on the knapsack case in recognition that the covering case can be handled analogously. (Moreover, linear multiple knapsack problems can be handled by direct specialization of the quadratic case examined here.) A good deal of attention has recently been given to the quadratic multiple knapsack problem (QMK) in Saraç and Sipahioglu (2007), Singh and Baghel (2007), Sundar and Singh (2010), Garcı́a-Martı́nez (submitted for publication-a, submitted for publication-b), the latter two approaches making significant gains over their predecessors.

The (QMK) problem involves a collection of single-constraint knapsacks indexed by k
                        ∈
                        K. Zero-one variables x
                        
                           jk
                         are introduced with the interpretation that x
                        
                           jk
                        
                        =1 if and only if object j is assigned to knapsack k. Hence we have
                           
                              
                                 
                                    ∑
                                 
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       jk
                                    
                                 
                                 :
                                 k
                                 ∈
                                 K
                                 )
                                 ⩽
                                 1
                                 ,
                                 
                                 j
                                 ∈
                                 N
                              
                           
                        The knapsack constraints associated with these inequalities are given by
                           
                              
                                 
                                    ∑
                                 
                                 (
                                 
                                    
                                       a
                                    
                                    
                                       j
                                    
                                 
                                 
                                    
                                       x
                                    
                                    
                                       jk
                                    
                                 
                                 :
                                 j
                                 ∈
                                 N
                                 )
                                 ⩽
                                 
                                    
                                       a
                                    
                                    
                                       ok
                                    
                                 
                                 ,
                                 
                                 k
                                 ∈
                                 K
                              
                           
                        The quadratic objective function for (QMK) is then
                           
                              
                                 Maximize
                                 
                                 
                                    ∑
                                 
                                 (
                                 
                                    
                                       p
                                    
                                    
                                       j
                                    
                                 
                                 
                                    
                                       x
                                    
                                    
                                       jk
                                    
                                 
                                 :
                                 j
                                 ∈
                                 N
                                 ,
                                 k
                                 ∈
                                 K
                                 )
                                 +
                                 
                                    ∑
                                 
                                 (
                                 
                                    
                                       p
                                    
                                    
                                       jh
                                    
                                 
                                 
                                    
                                       x
                                    
                                    
                                       jk
                                    
                                 
                                 
                                    
                                       x
                                    
                                    
                                       hk
                                    
                                 
                                 :
                                 j
                                 ,
                                 
                                 h
                                 ∈
                                 N
                                 :
                                 j
                                 <
                                 h
                                 ,
                                 
                                 k
                                 ∈
                                 K
                                 )
                              
                           
                        The cross product terms x
                        
                           jk
                        
                        x
                        
                           hk
                         for the quadratic multiple problem correspond directly to the cross product terms x
                        
                           j
                        
                        x
                        
                           h
                         for the quadratic single-constraint problem. Note in particular the profit coefficients p
                        
                           j
                         and p
                        
                           jh
                        , and the constraint coefficients a
                        
                           j
                        , are the same regardless of the knapsack k that variable x
                        
                           j
                         is assigned to, and are just the profit and constraint coefficients used in the single-constraint problem.

Thus, the additional complexity introduced by the quadratic multiple knapsack problem consists of allocating the x
                        
                           j
                         variables to different knapsacks (which have different capacities a
                        
                           ok
                        ). This allocation may be viewed as subdividing N1={j
                        ∈
                        N: x
                        
                           j
                        
                        =1} into sets J
                        
                           k
                        , k
                        ∈
                        K, where setting x
                        
                           jk
                        
                        =1 corresponds to assigning j to J
                        
                           k
                         (i.e., J
                        
                           k
                        
                        ={j
                        ∈
                        N1: x
                        
                           jk
                        
                        =1}).

Just as the multiple knapsack problem has different a
                        
                           o
                         coefficients denoted by a
                        
                           ok
                        , the updated form of these coefficients produces different RHS values denoted by RHS
                           k
                        .

To apply the previous Combination Evaluation Method and the associated Choice Rule for Selecting j
                        ∗ given in Sections 5.2.1 and 5.2.2, respectively, we must differentiate the evaluation QP
                           j
                         according to the knapsack k to which the evaluation refers, thus replacing 
                           
                              
                                 
                                    QP
                                 
                                 
                                    j
                                 
                              
                              
                                 
                                    
                                       =
                                       
                                          
                                             p
                                          
                                          
                                             j
                                          
                                       
                                       +
                                       ∑
                                       (
                                       
                                          
                                             p
                                          
                                          
                                             hj
                                          
                                       
                                       :
                                       h
                                       ∈
                                       N
                                       1
                                       )
                                    
                                 
                              
                           
                         by the term QP
                           jk
                         defined by
                           
                              
                                 
                                    
                                       QP
                                    
                                    
                                       jk
                                    
                                 
                                 =
                                 
                                    
                                       p
                                    
                                    
                                       j
                                    
                                 
                                 +
                                 
                                    ∑
                                 
                                 (
                                 
                                    
                                       p
                                    
                                    
                                       hj
                                    
                                 
                                 :
                                 h
                                 ∈
                                 
                                    
                                       J
                                    
                                    
                                       k
                                    
                                 
                                 )
                              
                           
                        
                     

Then the previous terms QProfit, QRatio and QProduct all similarly are differentiated to refer to a specific knapsack k, to yield corresponding terms QProfit
                           k
                        , QRatio
                           k
                         and QProduct
                           k
                        . Hence, for example, in the 3-element case we have
                           
                              
                                 
                                    
                                       
                                       
                                          
                                             
                                                
                                                   QProfit
                                                
                                                
                                                   k
                                                
                                             
                                             (
                                             1
                                             ,
                                             2
                                             ,
                                             3
                                             )
                                             =
                                             
                                                
                                                   QP
                                                
                                                
                                                   1
                                                   k
                                                
                                             
                                             +
                                             
                                                
                                                   QP
                                                
                                                
                                                   2
                                                   k
                                                
                                             
                                             +
                                             
                                                
                                                   QP
                                                
                                                
                                                   3
                                                   k
                                                
                                             
                                             +
                                             
                                                
                                                   p
                                                
                                                
                                                   12
                                                
                                             
                                             +
                                             
                                                
                                                   p
                                                
                                                
                                                   13
                                                
                                             
                                             +
                                             
                                                
                                                   p
                                                
                                                
                                                   23
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                                
                                                   QRatio
                                                
                                                
                                                   k
                                                
                                             
                                             (
                                             1
                                             ,
                                             2
                                             ,
                                             3
                                             )
                                             =
                                             
                                                
                                                   QProfit
                                                
                                                
                                                   k
                                                
                                             
                                             (
                                             1
                                             ,
                                             2
                                             ,
                                             3
                                             )
                                             /
                                             (
                                             
                                                
                                                   a
                                                
                                                
                                                   1
                                                
                                             
                                             +
                                             
                                                
                                                   a
                                                
                                                
                                                   2
                                                
                                             
                                             +
                                             
                                                
                                                   a
                                                
                                                
                                                   3
                                                
                                             
                                             )
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                                
                                                   QProduct
                                                
                                                
                                                   k
                                                
                                             
                                             (
                                             1
                                             ,
                                             2
                                             ,
                                             3
                                             )
                                             =
                                             
                                                
                                                   QProfit
                                                
                                                
                                                   k
                                                
                                             
                                             (
                                             1
                                             ,
                                             2
                                             ,
                                             3
                                             )
                                             
                                                
                                                   n
                                                
                                                
                                                   k
                                                
                                                
                                                   ′
                                                
                                             
                                             (
                                             1
                                             ,
                                             2
                                             ,
                                             3
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        where n
                        
                           k
                        (1,2,3)=⌊RHS
                           k
                        /(a
                        1
                        +
                        a
                        2
                        +
                        a
                        3)⌋ and 
                           
                              
                                 
                                    n
                                 
                                 
                                    k
                                 
                                 
                                    ′
                                 
                              
                              (
                              1
                              ,
                              2
                              ,
                              3
                              )
                              =
                              Min
                              (
                              
                                 
                                    n
                                 
                                 
                                    k
                                 
                              
                              (
                              1
                              ,
                              2
                              ,
                              3
                              )
                              ,
                              ⌊
                              n
                              
                                 
                                    0
                                 
                                 
                                    k
                                 
                              
                              /
                              3
                              ⌋
                              )
                           
                        . Here, following Remark 2, we require a
                        1
                        +
                        a
                        2
                        +
                        a
                        3
                        ⩽RHS
                           k
                        . The general profit representation is given by
                           
                              
                                 
                                    
                                       QProfit
                                    
                                    
                                       k
                                    
                                 
                                 (
                                 1
                                 ,
                                 …
                                 ,
                                 r
                                 )
                                 =
                                 
                                    ∑
                                 
                                 (
                                 
                                    
                                       QP
                                    
                                    
                                       jk
                                    
                                 
                                 :
                                 j
                                 ∈
                                 [
                                 1
                                 ,
                                 r
                                 ]
                                 )
                                 +
                                 
                                    
                                       Delta
                                    
                                    
                                       r
                                    
                                 
                              
                           
                        where 
                           
                              
                                 
                                    Delta
                                 
                                 
                                    r
                                 
                              
                              =
                              ∑
                              (
                              
                                 
                                    p
                                 
                                 
                                    hj
                                 
                              
                              :
                              h
                              ∈
                              [
                              1
                              ,
                              r
                              -
                              1
                              ]
                              ,
                              j
                              ∈
                              [
                              h
                              +
                              1
                              ,
                              r
                              ]
                              )
                              (
                              
                                 
                                    Delta
                                 
                                 
                                    r
                                 
                              
                              =
                              0
                           
                         if r
                        =1) where again we assume [1, r]⊆
                        N
                        −
                        N1 (={j
                        ∈
                        N1: x
                        
                           j
                        
                        =0}).

By means of these observations, our previous method for the quadratic single-constraint knapsack problem generalizes to the quadratic multiple knapsack problem as follows. We refer to this generalized method as a “Constructive Greedy” method to differentiate it from a related “Destructive Greedy” method we introduce later. The Constructive Greedy method includes both a classical ratio-based choice rule and an advanced product-based choice rule, according to the version of the Combination Evaluation Method that is embedded in the algorithm.
                           
                              
                                 
                                 
                                    
                                       
                                          Constructive Greedy (QMK)
                                       
                                    
                                    
                                       
                                          
                                          Initialize:
                                    
                                    
                                       
                                          
                                          x
                                          
                                             j
                                          
                                          =0 for all j
                                          ∈
                                          N
                                       
                                    
                                    
                                       
                                          
                                          N1=∅ (N1, as before, is the index set for variables x
                                          
                                             j
                                           currently set to 1)
                                    
                                    
                                       
                                          RHS
                                             k
                                          
                                          =
                                          a
                                          
                                             ok
                                           and J
                                          
                                             k
                                          
                                          =∅ for all k
                                          ∈
                                          K (J
                                          
                                             k
                                           is the index set for j
                                          ∈
                                          N1 such that j is
                                    
                                    
                                       
                                          assigned to knapsack k, hence for which x
                                          
                                             jk
                                          
                                          =1)
                                    
                                    
                                       
                                          ActiveK=
                                          K (ActiveK is the index set for those knapsacks k such that N
                                          
                                             k
                                          
                                          ≠∅,
                                    
                                    
                                       
                                          where N
                                          
                                             k
                                           (analogous to N
                                          
                                             o
                                          ) is identified next)
                                    
                                    
                                       
                                          For each k
                                          ∈ActiveK
                                    
                                    
                                       
                                          
                                          N
                                          
                                             k
                                          
                                          ={j
                                          ∈
                                          N: a
                                          
                                             j
                                          
                                          ⩽RHS
                                             k
                                          }
                                    
                                    
                                       
                                          If N
                                          
                                             k
                                          
                                          =∅ then ActiveK=ActiveK−{k}
                                    
                                    
                                       
                                          Endfor
                                    
                                    
                                       
                                          While ActiveK ≠∅
                                       
                                    
                                    
                                       
                                          Apply Knapsack Choice Rule for Selecting k
                                          ∗ (identified below)
                                    
                                    
                                       
                                          Apply Combination Evaluation Method to the knapsack k
                                          ∗
                                       
                                    
                                    
                                       
                                          Apply Choice Rule for Selecting 
                                          j
                                          ∗ to the knapsack k
                                          ∗
                                       
                                    
                                    
                                       
                                          
                                          
                                             
                                                
                                                   
                                                      x
                                                   
                                                   
                                                      j
                                                   
                                                   
                                                      ∗
                                                   
                                                
                                                =
                                                1
                                                
                                                   
                                                      
                                                         
                                                            
                                                               x
                                                            
                                                            
                                                               j
                                                            
                                                            
                                                               ∗
                                                            
                                                         
                                                         
                                                            
                                                               k
                                                            
                                                            
                                                               ∗
                                                            
                                                         
                                                         =
                                                         1
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                          N1=
                                          N1∪{j
                                          ∗}
                                    
                                    
                                       
                                          
                                          
                                             
                                                
                                                   
                                                      J
                                                   
                                                   
                                                      k
                                                   
                                                   
                                                      ∗
                                                   
                                                
                                                =
                                                
                                                   
                                                      J
                                                   
                                                   
                                                      k
                                                   
                                                   
                                                      ∗
                                                   
                                                
                                                ∪
                                                {
                                                
                                                   
                                                      j
                                                   
                                                   
                                                      ∗
                                                   
                                                
                                                }
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                          
                                             
                                                
                                                   
                                                      RHS
                                                   
                                                   
                                                      k
                                                   
                                                   
                                                      ∗
                                                   
                                                
                                                =
                                                
                                                   
                                                      RHS
                                                   
                                                   
                                                      k
                                                   
                                                   
                                                      ∗
                                                   
                                                
                                                -
                                                
                                                   
                                                      a
                                                   
                                                   
                                                      j
                                                   
                                                   
                                                      ∗
                                                   
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          For all k
                                          ∈ActiveK
                                    
                                    
                                       
                                          
                                          
                                          N
                                          
                                             k
                                          
                                          =
                                          N
                                          
                                             k
                                          
                                          −{j
                                          ∗}
                                    
                                    
                                       
                                          
                                          
                                          N
                                          
                                             k
                                          
                                          ={j
                                          ∈
                                          N
                                          
                                             k
                                          : a
                                          
                                             j
                                          
                                          ⩽RHS
                                             k
                                          }
                                    
                                    
                                       
                                          
                                          If N
                                          
                                             k
                                          
                                          =∅ then ActiveK=ActiveK−{k}
                                    
                                    
                                       
                                          Endfor
                                    
                                    
                                       
                                          Endwhile
                                    
                                    
                                       
                                          (Upon concluding, x
                                          
                                             j
                                          
                                          =1 for j
                                          ∈
                                          N1 and x
                                          
                                             j
                                          
                                          =0 otherwise. In terms of double subscripted variables, for each k
                                          ∈
                                          K, x
                                          
                                             jk
                                          
                                          =1 for each j
                                          ∈
                                          J
                                          
                                             k
                                          ,)
                                    
                                 
                              
                           
                        
                     

The key issue remaining is to identify the Knapsack Choice Rule to choose k
                        ∗. We examine six options for this rule in order to show the relevant considerations, and then indicate the option that is anticipated to be best.


                           
                              
                                 
                                    Option 1. Choose k
                                    ∗
                                    =argmin (RHS
                                       k
                                    : k
                                    ∈ActiveK), hence knapsack k
                                    ∗ is the one with the least current capacity.


                                    Option 2. Choose k
                                    ∗
                                    =argmax (RHS
                                       k
                                    : k
                                    ∈ActiveK), hence knapsack k
                                    ∗ is the one with the greatest current capacity.


                                    Option 3. Choose k
                                    ∗ to be the knapsack k that yields the maximum QRatio
                                       k
                                     (or QProduct
                                       k
                                    ) by the Combination Evaluation Method.


                                    Option 4. Let QRatio1
                                       k
                                     (QProduct1
                                       k
                                    ) denote the largest QRatio
                                       k
                                     (QProduct
                                       k
                                    ) for knapsack k and let QRatio2
                                       k
                                     (QProduct2
                                       k
                                    ) denote the second largest QRatio
                                       k
                                     (QProduct
                                       k
                                    ) for knapsack k. Then we choose k
                                    ∗
                                    =argmax (QRatio1
                                       k
                                    
                                    −QRatio2
                                       k
                                    ) or k
                                    ∗
                                    =argmax (QProduct1
                                       k
                                    
                                    −QProduct2
                                       k
                                    ).


                                    Option 5. Apply Option 3 or Option 4 subject to the following additional stipulation: the choice of the first k
                                    ∗, denoted by k0, launches a cycle in which all other k
                                    ∈ActiveK must be selected exactly once as k
                                    ∗ before starting the next cycle by choosing as k
                                    ∗
                                    =
                                    k0 again. (Thus there is no restriction on the order of choosing the knapsacks k
                                    ∈ActiveK within the cycle.) If the original k0 drops out of ActiveK, then apply Option 3 or 4 to select a new k0 at the end of the cycle.


                                    Option 6. Apply Option 3 or 4 subject to the following restriction. When a knapsack k0 is selected as k
                                    ∗, let MaxVal(k0)=Max (RHS
                                       k
                                    : k
                                    ∈ActiveK) and MeanVal(k0)=Mean (RHS
                                       k
                                    : k
                                    ∈ActiveK). Then k0 is eligible to be re-selected as k
                                    ∗ by Option 3 or 4 as long as RHS
                                       k0
                                    ⩾MeanVal(k0) and Max(RHS
                                       k
                                    : k
                                    ∈ActiveK)<MaxVal(k0). Initialization sets MeanVal(k0) as above and MaxVal(k)=Large for all k
                                    ∈ActiveK.

First observe that Option 1 shares part of the same failing that the Naïve Greedy (QP) algorithm exhibited. Effectively, Option 1 implies that the same knapsack k
                           ∗ will be chosen on every iteration until it is filled – i.e., until 
                              
                                 
                                    
                                       N
                                    
                                    
                                       
                                          
                                             k
                                          
                                          
                                             ∗
                                          
                                       
                                    
                                 
                                 =
                                 ∅
                              
                           . Then another knapsack will be chosen and it will likewise be chosen on every succeeding iteration until it is filled. The potential contribution of the Combination Evaluation Method is therefore partly negated.

Option 2 does not suffer the limitation of Option 1, because it allows the Combination Evaluation Method to rotate its application among different knapsacks as their residual capacities RHS
                              k
                            become more nearly the same. However this option still does not give the Combination Evaluation Method a direct role in choosing k
                           ∗, hence again a part of the potential contribution of this evaluation method fails to be realized.

Option 3 evokes the Combination Evaluation Method in choosing k
                           ∗, but the method will be biased to repeat the same choice of k
                           ∗ until the knapsack is full, much as in the case of Option 1 (due to the fact that the QP
                              j
                            values make an increasingly large contribution to the combination evaluations as J
                           
                              k
                            grows, and hence this growth will tend to favor repeated choice of the same knapsack k
                           ∗ on successive iterations.

Option 4, which is a form of “Min Regret” rule, engages the Combination Evaluation Rule more fully in the choice of k
                           ∗ and in this way appears more promising than the previous options. Nevertheless, there is still a possibility that the contribution from the QP
                              j
                            values to the combination evaluations will pass a tipping point that causes this option to shift toward selecting the same k
                           ∗ repeatedly until the knapsack k
                           ∗ is full.

Options 5 and 6 offer a way to combat the limitations of Options 3 and 4. On the surface, Option 6 appears to be slightly more flexible than Option 5, but both options may be worth exploring. Conjecturally, the best option is Option 6 in the version that incorporates Option 4.

A highly effective approach for the multiple knapsack problem has been developed in Garcı́a-Martı́nez (submitted for publication-a) using the strategic oscillation method. We briefly remark on how the Constructive Greedy (QMK) method can be used within such a strategic oscillation framework.

The approaches of nearly all the methods for the (QMK) previously indicated use the naïve greedy algorithm for an initial construction, choosing the current knapsack k that receives the highest evaluation. Consequently, these methods all exhibit the weaknesses previously indicated for the naïve greedy approaches, and also have the “sequential fill” weakness discussed for Option 1 above. Thus, not surprisingly, the initial construction rarely produces a solution of high quality. We suggest a way to improve this situation even with a simple version of the Constructive Greedy (QMK) method, including one that uses only “1-element combinations,” hence which reduces to the naïve greedy method when bang-for-buck evaluations are used (as opposed to the product-based evaluations of the advanced methods).

The idea is this. As observed in Glover (1995), it can sometimes be valuable to hover at various levels of constructive and destructive approaches, especially in a strategic oscillation setting, and improve the solution at such levels in addition to applying a method to improve the solution at the critical (boundary) level. In the present case, such a Hover-Oscillation process can serve to remedy a situation where early choices are myopic, and thus interfere with the possibility of making good later choices because of their reliance on the early choices for their evaluations. The following method, which is described for strategic oscillation, can also be adapted to the case of multi-start strategies (which may be viewed as one-sided oscillations that drop all the way back to the 0 solution).


                           
                              
                                 1.
                                 Select hover-levels by dividing the constructive or destructive process into intervals based on allocating resources available at the critical boundary. We illustrate this by considering 6 hover-levels H(L), L
                                    =1–6, represented by H(1)=.25, H(2)=.50, H(3)=.75, H(4)=1.00, H(5)=1.15 and H(6)=1.30. In the resource-based allocation, this generates the resource levels
                                       
                                          
                                             
                                                
                                                   a
                                                
                                                
                                                   ok
                                                
                                             
                                             (
                                             L
                                             )
                                             =
                                             H
                                             (
                                             L
                                             )
                                             
                                                
                                                   a
                                                
                                                
                                                   ok
                                                
                                             
                                             
                                             L
                                             =
                                             1
                                             –
                                             6
                                             ,
                                             
                                             k
                                             ∈
                                             K
                                          
                                       
                                    (Note that the hover-point 4, for H(4)=1.00, corresponds to the critical level of a complete construction since a
                                    
                                       ok
                                    (4)=
                                    a
                                    
                                       ok
                                     for each k.)

Treat each hover-level as defining a complete problem, and instigate an improvement process to create a better solution relative to this level. (For example, for L
                                    =1 the problem is conceived to be the one with resource limits given by .25 of their total values. Once the construction process is complete for this set of limits, an improvement process is initiated to improve the solution at this level.)

Spend additional effort at the critical hover-level which defines the complete construction (i.e., for H(L)=1.00), corresponding to the greater importance of obtaining good solutions at this level. The effort at other levels is graduated to be greater as the levels become closer to the critical level, particularly upon approaching the critical level from either side.

Spend less effort at a hover-level during the process of retreating from the critical level than at the same level during the process of approaching the critical level. (As an extreme instance of this approach, the improvement at a given hover-level may be bypassed when retreating from the critical level.)

The foregoing approach clearly gives rise to a number of possible variants, according to the choice of the number of hover-levels and the spacing between them, which may vary depending on which side of the critical level a particular hover-level lies. In addition, the hover-levels and the turn-around points, where the strategic oscillation ends its progression away from the critical level and begins approaching the boundary again, can change over time, as by the use of a changing span parameter (see. e.g., Glover and Kochenberger (1996) and the related rule of Garcı́a-Martı́nez (submitted for publication-a)).

Implicit in the foregoing method is the need for a Destructive Greedy method that is the counterpart of the Constructive method, but which is executed during destructive phases of the method. Special considerations apply to the formulation of such a method and to coordinating it with a Constructive method. We describe such considerations and observe how they can give rise to variants of the Hover-Oscillation strategy for a variety of problems other than the quadratic multiple knapsack (QMK) problem. For example, such a variant is particularly well suited for being applied to the multi-constraint problems discussed next.

The multi-constraint (or multi-dimensional) knapsack and covering problems generalize the single-constraint knapsack and covering problems as follows.
                        
                           
                              Multi-constraint knapsack (MK)
                              
                                 
                                    (MK0)
                                    
                                       Maximize
                                       
                                       
                                          
                                             x
                                          
                                          
                                             o
                                          
                                       
                                       =
                                       
                                          ∑
                                       
                                       (
                                       
                                          
                                             p
                                          
                                          
                                             j
                                          
                                       
                                       
                                          
                                             x
                                          
                                          
                                             j
                                          
                                       
                                       ;
                                       j
                                       ∈
                                       N
                                       )
                                       +
                                       
                                          
                                             p
                                          
                                          
                                             o
                                          
                                       
                                    
                                 
                              
                              
                                 
                                    (MK1)
                                    
                                       subject
                                       
                                       to
                                       
                                       
                                          ∑
                                       
                                       (
                                       
                                          
                                             a
                                          
                                          
                                             ij
                                          
                                       
                                       
                                          
                                             x
                                          
                                          
                                             j
                                          
                                       
                                       ;
                                       j
                                       ∈
                                       N
                                       )
                                       ⩽
                                       
                                          
                                             a
                                          
                                          
                                             io
                                          
                                       
                                       i
                                       ∈
                                       M
                                    
                                 
                              
                              
                                 
                                    (MK2)
                                    
                                       
                                       
                                          
                                             x
                                          
                                          
                                             j
                                          
                                       
                                       ∈
                                       {
                                       0
                                       ,
                                       1
                                       }
                                       ,
                                       j
                                       ∈
                                       N
                                    
                                 
                              where a
                              
                                 io
                              
                              >0 for all i
                              ∈
                              M
                              ={1,…,
                              m}, p
                              
                                 j
                              
                              >0 for all j
                              ∈
                              N
                              ={1,…,
                              n} and a
                              
                                 ij
                              
                              ⩾0 for all i
                              ∈
                              M and j
                              ∈
                              N.


                              Multi-constraint cover (MC)
                              
                                 
                                    (MC0)
                                    
                                       Minimize
                                       
                                       
                                          
                                             y
                                          
                                          
                                             o
                                          
                                       
                                       =
                                       
                                          ∑
                                       
                                       (
                                       
                                          
                                             c
                                          
                                          
                                             j
                                          
                                       
                                       
                                          
                                             y
                                          
                                          
                                             j
                                          
                                       
                                       :
                                       j
                                       ∈
                                       N
                                       )
                                       +
                                       
                                          
                                             c
                                          
                                          
                                             o
                                          
                                       
                                    
                                 
                              
                              
                                 
                                    (MC1)
                                    
                                       subject
                                       
                                       to
                                       
                                       
                                          ∑
                                       
                                       (
                                       
                                          
                                             d
                                          
                                          
                                             ij
                                          
                                       
                                       
                                          
                                             y
                                          
                                          
                                             j
                                          
                                       
                                       :
                                       j
                                       ∈
                                       N
                                       )
                                       ⩾
                                       
                                          
                                             d
                                          
                                          
                                             io
                                          
                                       
                                       i
                                       ∈
                                       M
                                    
                                 
                              
                              
                                 
                                    (MC2)
                                    
                                       
                                       
                                          
                                             y
                                          
                                          
                                             j
                                          
                                       
                                       ∈
                                       {
                                       0
                                       ,
                                       1
                                       }
                                       ,
                                       j
                                       ∈
                                       N
                                    
                                 
                              
                           

Similarly d
                     
                        io
                     
                     >0 for all i
                     ∈
                     M, c
                     
                        j
                     
                     >0 for all j
                     ∈
                     N and d
                     
                        ij
                     
                     ⩾0 for all i
                     ∈
                     M and j
                     ∈
                     N.

Thus, (MK) and (MC) have the same formulations as (LK) and (LC), respectively, except that (MK1) and (MC1) involve multiple constraints whose coefficients are permitted to be non-negative instead of restricting the constraint coefficients to be positive. Problem (MC) is often called the generalized covering problem because classical covering problems additionally assume d
                     
                        ij
                     
                     =0 or 1 for all coefficients defining (MC1). As before, we focus on the knapsack version of these problems since our observations extend naturally to the covering version.

A variety of methods have been developed for the (MK) problem, including more recently a very effective method by Khemakhem et al. (in press). Most of the best-known solutions for the set of MKP instances available in the OR-Library (Beasley, 1990) were obtained by Vasquez and Hao (2001) and Vasquez and Vimont (2005). A comprehensive annotated bibliography of exact and approximate algorithms for (MK) appears in Fréville and Hanafi (2005).

Surrogate constraint approaches for the (MK) problem apply weights w
                     
                        i
                     
                     ⩾0, i
                     ∈
                     M, to the constraints (MK1) to yield
                        
                           
                              
                                 
                                    a
                                 
                                 
                                    j
                                 
                              
                              =
                              
                                 ∑
                              
                              (
                              
                                 
                                    w
                                 
                                 
                                    i
                                 
                              
                              
                                 
                                    a
                                 
                                 
                                    ij
                                 
                              
                              :
                              i
                              ∈
                              M
                              )
                              
                              for
                              
                              j
                              =
                              0
                              
                              and
                              
                              j
                              ∈
                              N
                           
                        
                     The resulting surrogate constraints thus acquire the form
                        
                           
                              
                                 ∑
                              
                              (
                              
                                 
                                    a
                                 
                                 
                                    j
                                 
                              
                              
                                 
                                    x
                                 
                                 
                                    j
                                 
                              
                              :
                              j
                              ∈
                              N
                              )
                              ⩽
                              
                                 
                                    a
                                 
                                 
                                    o
                                 
                              
                           
                        
                     which are the same as the constraint (K1) of the single-constraint knapsack problems. In consequence, surrogate constraint strategies often use the approach of generating approximate solutions to single-constraint knapsack (and covering) problems as part of their operation (see, e.g., Glover, 1965, 1975, 2003; Gavish et al., 1991; Osorio et al., 2002; Hanafi and Glover, 2007; Ablanedo-Rosas and Rego, 2010).

The extension of the Greedy and Advanced Greedy (LK) methods to apply to surrogate constraints for the (MK) problem is straightforward, noting that the set N
                     
                        o
                      must be explicitly determined relative to all constraints, by stipulating 
                        
                           
                              
                                 N
                              
                              
                                 o
                              
                           
                           =
                           {
                           j
                           ∈
                           
                              
                                 N
                              
                              
                                 :
                              
                           
                           
                              
                                 a
                              
                              
                                 ij
                              
                           
                           ⩽
                           
                              
                                 RHS
                              
                              
                                 i
                              
                           
                        
                      for all i
                     ∈
                     M}. For any given i
                     ∈
                     M, as soon as a
                     
                        ij
                     
                     =0 for all j
                     ∈
                     N
                     
                        o
                      this index i can be removed from M. (The current reduced constraint 
                        
                           ∑
                           (
                           
                              
                                 a
                              
                              
                                 ij
                              
                           
                           
                              
                                 x
                              
                              
                                 j
                              
                           
                           :
                           j
                           ∈
                           
                              
                                 N
                              
                              
                                 o
                              
                           
                           )
                           ⩽
                           
                              
                                 RHS
                              
                              
                                 i
                              
                           
                        
                      corresponds to 0⩽RHS
                        i
                      and hence is redundant.)

Surrogate constraints can be generated and updated on successive iterations by using weights that result from normalizing the problems constraints, though the most effective rules generally include the use of linear programming to generate the weights, as by employing the weights that result from the optimal solution to the dual when (MK) is solved by a linear program.

A recent extension of these approaches employs searches that employ constraints also generated by linear programming that bound sums of variables, as instances of earlier proposals for generating guiding constraints composed of sums and nested sums of variables (see, e.g., Glover, 1971; Osorio et al., 2002; Hanafi and Glover, 2007). These linear programming based methods have provided the best solutions for multi-constraint problems, notably in the work of Fleszar and Hindi (2009), Hanafi and Wilbaut (2011) and Khemakhem et al. (in press).

We now disclose the somewhat surprising fact that the inequalities used by these best methods in the literature are dominated by inequalities generated by surrogate constraints, which raises the possibility that these latter constraints may provide guidance that is still more effective. Building on this observation, we will also propose new strategies for generating and exploiting such guiding inequalities. As a basis for doing this, we first briefly sketch the nature of inequalities previously used.

Consider the relaxation of the constraints of (MK2) given by
                           
                              (MK2′)
                              
                                 0
                                 ⩽
                                 
                                    
                                       x
                                    
                                    
                                       j
                                    
                                 
                                 ⩽
                                 1
                                 ,
                                 
                                 j
                                 ∈
                                 N
                              
                           
                        Then the methods that use linear programming to generate guiding inequalities generally employ the following design.


                           
                              
                                 1.
                                 Use linear programming to Maximize 
                                       
                                          
                                             
                                                z
                                             
                                             
                                                o
                                             
                                          
                                          =
                                          ∑
                                          (
                                          
                                             
                                                x
                                             
                                             
                                                j
                                             
                                          
                                          :
                                          j
                                          ∈
                                          N
                                          )
                                       
                                     subject to (MK1) and (MK2′), and denote the optimum z
                                    
                                       o
                                     value by 
                                       
                                          
                                             
                                                z
                                             
                                             
                                                o
                                             
                                             
                                                ∗
                                             
                                          
                                       
                                    .

Conduct a series of searches that enforce a succession of equations or inequalities of the form
                                       
                                          
                                             
                                                
                                                   z
                                                
                                                
                                                   o
                                                
                                             
                                             =
                                             U
                                             
                                             (
                                             or
                                             
                                             
                                                
                                                   z
                                                
                                                
                                                   o
                                                
                                             
                                             ⩽
                                             U
                                             )
                                          
                                       
                                    where 
                                       
                                          U
                                          =
                                          
                                             
                                                
                                                   
                                                      
                                                         z
                                                      
                                                      
                                                         o
                                                      
                                                      
                                                         ∗
                                                      
                                                   
                                                
                                             
                                          
                                          ,
                                          
                                             
                                                
                                                   
                                                      
                                                         z
                                                      
                                                      
                                                         o
                                                      
                                                      
                                                         ∗
                                                      
                                                   
                                                
                                             
                                          
                                          -
                                          1
                                          ,
                                          
                                             
                                                
                                                   
                                                      
                                                         z
                                                      
                                                      
                                                         o
                                                      
                                                      
                                                         ∗
                                                      
                                                   
                                                
                                             
                                          
                                          -
                                          2
                                          ,
                                          …
                                          ,
                                          
                                             
                                                U
                                             
                                             
                                                min
                                             
                                          
                                       
                                     for a chosen integer value of U
                                    min.

As a variant (Fleszar and Hindi, 2009), randomly partition N into subsets N1 and N2 (restricting the number of elements in each) and use LP post-optimization to Maximize 
                                       
                                          
                                             
                                                z
                                             
                                             
                                                o
                                             
                                          
                                          =
                                          ∑
                                          (
                                          
                                             
                                                x
                                             
                                             
                                                j
                                             
                                          
                                          :
                                          j
                                          ∈
                                          N
                                          1
                                          )
                                          -
                                          ∑
                                          (
                                          
                                             
                                                x
                                             
                                             
                                                j
                                             
                                          
                                          :
                                          j
                                          ∈
                                          N
                                          2
                                          )
                                       
                                     subject to (MK1) and (MK2′). Then similarly enforce a succession of equations or inequalities as in step 2.

Additional strategies are employed for carrying out the indicated searches, as by tabu search in the case of Hanafi and Wilbaut (2011) and by the filter-and-fan method in the case of Khemakhem et al. (in press).

We indicate the relationship of the guiding constraints used in these approaches to corresponding surrogate constraints as follows.

Consider a more general class of linear programs for creating guiding constraints defined by
                           
                              
                                 (
                                 P
                                 )
                                 
                                 Maximize
                                 
                                 
                                    
                                       z
                                    
                                    
                                       o
                                    
                                 
                                 =
                                 
                                    ∑
                                 
                                 (
                                 
                                    
                                       b
                                    
                                    
                                       j
                                    
                                 
                                 
                                    
                                       x
                                    
                                    
                                       j
                                    
                                 
                                 :
                                 j
                                 ∈
                                 N
                                 )
                                 
                                 subject
                                 
                                 to
                                 
                                 (
                                 MK
                                 1
                                 )
                                 
                                 and
                                 
                                 (
                                 MK
                                 
                                    
                                       2
                                    
                                    
                                       ′
                                    
                                 
                                 )
                              
                           
                        where the coefficients b
                        
                           j
                         can take any integer values, positive or negative. If 
                           
                              
                                 
                                    z
                                 
                                 
                                    o
                                 
                                 
                                    ∗
                                 
                              
                           
                         is an optimum value for the linear program (P), then we have a guiding inequality
                           
                              (G)
                              
                                 
                                    
                                       z
                                    
                                    
                                       o
                                    
                                 
                                 =
                                 
                                    ∑
                                 
                                 (
                                 
                                    
                                       b
                                    
                                    
                                       j
                                    
                                 
                                 
                                    
                                       x
                                    
                                    
                                       j
                                    
                                 
                                 :
                                 j
                                 ∈
                                 N
                                 )
                                 ⩽
                                 
                                    
                                       
                                          
                                             
                                                z
                                             
                                             
                                                o
                                             
                                             
                                                ∗
                                             
                                          
                                       
                                    
                                 
                              
                           
                        Relative to this general problem (P), we identify the surrogate constraint
                           
                              (SC)
                              
                                 
                                    ∑
                                 
                                 (
                                 
                                    
                                       a
                                    
                                    
                                       j
                                    
                                 
                                 
                                    
                                       x
                                    
                                    
                                       j
                                    
                                 
                                 ;
                                 j
                                 ∈
                                 N
                                 )
                                 ⩽
                                 
                                    
                                       a
                                    
                                    
                                       o
                                    
                                 
                              
                           
                        where, as before
                           
                              
                                 
                                    
                                       a
                                    
                                    
                                       j
                                    
                                 
                                 =
                                 
                                    ∑
                                 
                                 (
                                 
                                    
                                       w
                                    
                                    
                                       i
                                    
                                 
                                 
                                    
                                       a
                                    
                                    
                                       ij
                                    
                                 
                                 :
                                 i
                                 ∈
                                 M
                                 )
                                 
                                 for
                                 
                                 j
                                 =
                                 0
                                 
                                 and
                                 
                                 j
                                 ∈
                                 N
                              
                           
                        We note that the (LK) problem, which becomes a surrogate constraint problem when (SC) replaces (K1), explicitly includes the constraints x
                        
                           j
                        
                        ∈{0,1}, j
                        ∈
                        N. This observation is important for identifying the relative strength of different surrogate constraints.

The integer coefficient version of (SC) is
                           
                              (SCI)
                              
                                 
                                    ∑
                                 
                                 (
                                 ⌊
                                 
                                    
                                       a
                                    
                                    
                                       j
                                    
                                 
                                 ⌋
                                 
                                    
                                       x
                                    
                                    
                                       j
                                    
                                 
                                 ;
                                 j
                                 ∈
                                 N
                                 )
                                 ⩽
                                 ⌊
                                 
                                    
                                       a
                                    
                                    
                                       o
                                    
                                 
                                 ⌋
                              
                           
                        By the original formulation of Glover (1965), surrogate constraints are defined to include cutting planes obtained from other surrogate constraints, and we note that (SCI) is a simple instance of a constraint that falls in this category.

We identify the dual of (P) to be the problem
                           
                              (D1)
                              
                                 
                                    
                                       
                                          
                                             (
                                             D
                                             )
                                             
                                             Minimize
                                          
                                       
                                       
                                          
                                             
                                             
                                                
                                                   w
                                                
                                                
                                                   o
                                                
                                             
                                             =
                                             
                                                ∑
                                             
                                             (
                                             
                                                
                                                   w
                                                
                                                
                                                   i
                                                
                                             
                                             
                                                
                                                   a
                                                
                                                
                                                   io
                                                
                                             
                                             :
                                             i
                                             ∈
                                             M
                                             )
                                             +
                                             
                                                ∑
                                             
                                             (
                                             
                                                
                                                   u
                                                
                                                
                                                   j
                                                
                                             
                                             :
                                             j
                                             ∈
                                             N
                                             )
                                          
                                       
                                    
                                    
                                       
                                          
                                             subject
                                             
                                             to
                                          
                                       
                                       
                                          
                                             
                                                ∑
                                             
                                             (
                                             
                                                
                                                   w
                                                
                                                
                                                   i
                                                
                                             
                                             
                                                
                                                   a
                                                
                                                
                                                   ij
                                                
                                             
                                             :
                                             i
                                             ∈
                                             M
                                             )
                                             +
                                             
                                                
                                                   u
                                                
                                                
                                                   j
                                                
                                             
                                             ⩾
                                             
                                                
                                                   b
                                                
                                                
                                                   j
                                                
                                             
                                             j
                                             ∈
                                             N
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (D2)
                              
                                 
                                 
                                    
                                       w
                                    
                                    
                                       i
                                    
                                 
                                 ⩾
                                 0
                                 ,
                                 
                                 i
                                 ∈
                                 M
                                 
                                 
                                 and
                                 
                                 
                                 
                                    
                                       u
                                    
                                    
                                       j
                                    
                                 
                                 ⩾
                                 0
                                 ,
                                 j
                                 ∈
                                 N
                              
                           
                        Here w
                        
                           i
                         is the dual variable associated with constraint 
                           
                              ∑
                              (
                              
                                 
                                    a
                                 
                                 
                                    ij
                                 
                              
                              
                                 
                                    x
                                 
                                 
                                    j
                                 
                              
                              ;
                              j
                              ∈
                              N
                              )
                              ⩽
                              
                                 
                                    a
                                 
                                 
                                    io
                                 
                              
                           
                         of (MK1) and u
                        
                           j
                         is the dual variable associated with the inequality x
                        
                           j
                        
                        ⩽1 of (MK2′). Note that the w
                        
                           i
                         weights can be used to generate (SC) and (SCI).

Define 
                           
                              
                                 
                                    a
                                 
                                 
                                    i
                                 
                                 
                                    ′
                                 
                              
                              =
                              
                                 
                                    a
                                 
                                 
                                    i
                                 
                              
                              +
                              
                                 
                                    u
                                 
                                 
                                    j
                                 
                              
                           
                         for j
                        ∈
                        N and 
                           
                              
                                 
                                    a
                                 
                                 
                                    o
                                 
                                 
                                    ′
                                 
                              
                              =
                              
                                 
                                    a
                                 
                                 
                                    o
                                 
                              
                              +
                              ∑
                              (
                              
                                 
                                    u
                                 
                                 
                                    j
                                 
                              
                              :
                              j
                              ∈
                              N
                              )
                           
                        . Then the surrogate constraint generated from using all dual variables of (D) is given by
                           
                              (SCD)
                              
                                 
                                    ∑
                                 
                                 (
                                 
                                    
                                       a
                                    
                                    
                                       j
                                    
                                    
                                       ′
                                    
                                 
                                 
                                    
                                       x
                                    
                                    
                                       j
                                    
                                 
                                 ;
                                 j
                                 ∈
                                 N
                                 )
                                 ⩽
                                 
                                    
                                       a
                                    
                                    
                                       o
                                    
                                    
                                       ′
                                    
                                 
                              
                           
                        and the integer version of this constraint is given by
                           
                              (SCID)
                              
                                 
                                    ∑
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         a
                                                      
                                                      
                                                         j
                                                      
                                                      
                                                         ′
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                x
                                             
                                             
                                                j
                                             
                                          
                                          ;
                                          j
                                          ∈
                                          N
                                       
                                    
                                 
                                 ⩽
                                 
                                    
                                       
                                          
                                             
                                                a
                                             
                                             
                                                o
                                             
                                          
                                       
                                    
                                 
                              
                           
                        The following result shows that the solution of (P) to obtain the guiding constraint (G) also generates a surrogate inequality that dominates (G), since the optimal dual values for (D) are automatically obtained as a result of solving (P). (In particular, these dual values correspond to the optimal reduced costs for the slack variables of the constraints of (P).)
                           Proposition
                           
                              Assume the weights w
                              
                                 i
                              
                              , i
                              ∈
                              M and u
                              
                                 j
                              
                              , j
                              ∈
                              N are obtained from optimal dual values for (D). Then the surrogate constraint 
                              (SCID) 
                              dominates the guiding inequality 
                              (G). Moreover, the surrogate constraint 
                              (SC) 
                              dominates the surrogate constraint 
                              (SCD), and the surrogate constraint 
                              (SCI) 
                              typically dominates both 
                              (SCID) 
                              and 
                              (G). Finally, 
                              (SCID) 
                              strictly dominates 
                              (G) 
                              if any coefficient b
                              
                                 j
                               
                              of 
                              (G) 
                              is negative.
                           

Denote optimal dual weights for (D) by 
                                 
                                    
                                       
                                          w
                                       
                                       
                                          i
                                       
                                       
                                          ∗
                                       
                                    
                                    ,
                                    i
                                    ∈
                                    M
                                 
                               and 
                                 
                                    
                                       
                                          u
                                       
                                       
                                          j
                                       
                                       
                                          ∗
                                       
                                    
                                    ,
                                    j
                                    ∈
                                    N
                                 
                              , and let 
                                 
                                    
                                       
                                          w
                                       
                                       
                                          o
                                       
                                       
                                          ∗
                                       
                                    
                                 
                               denote the associated optimum value of w
                              
                                 o
                              . By duality, 
                                 
                                    
                                       
                                          w
                                       
                                       
                                          o
                                       
                                       
                                          ∗
                                       
                                    
                                    =
                                    
                                       
                                          z
                                       
                                       
                                          o
                                       
                                       
                                          ∗
                                       
                                    
                                 
                              . Under the assumption of the Proposition and the definition of 
                                 
                                    
                                       
                                          a
                                       
                                       
                                          o
                                       
                                       
                                          ′
                                       
                                    
                                 
                               we also have 
                                 
                                    
                                       
                                          a
                                       
                                       
                                          o
                                       
                                       
                                          ′
                                       
                                    
                                    =
                                    
                                       
                                          w
                                       
                                       
                                          o
                                       
                                       
                                          ∗
                                       
                                    
                                 
                              . Hence 
                                 
                                    
                                       
                                          a
                                       
                                       
                                          o
                                       
                                       
                                          ′
                                       
                                    
                                    =
                                    
                                       
                                          z
                                       
                                       
                                          o
                                       
                                       
                                          ∗
                                       
                                    
                                 
                               and we may write (SCID) and (SCID) in this instance as
                                 
                                    
                                       (
                                       
                                          
                                             SC
                                          
                                          
                                             D
                                          
                                       
                                       )
                                       :
                                       
                                          ∑
                                       
                                       (
                                       
                                          
                                             a
                                          
                                          
                                             j
                                          
                                          
                                             ′
                                          
                                       
                                       
                                          
                                             x
                                          
                                          
                                             j
                                          
                                       
                                       ;
                                       j
                                       ∈
                                       N
                                       )
                                       ⩽
                                       
                                          
                                             z
                                          
                                          
                                             o
                                          
                                          
                                             ∗
                                          
                                       
                                    
                                 
                              and
                                 
                                    
                                       (
                                       
                                          
                                             SCI
                                          
                                          
                                             D
                                          
                                       
                                       )
                                       :
                                       
                                          ∑
                                       
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               a
                                                            
                                                            
                                                               j
                                                            
                                                            
                                                               ′
                                                            
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                      x
                                                   
                                                   
                                                      j
                                                   
                                                
                                                ;
                                                j
                                                ∈
                                                N
                                             
                                          
                                       
                                       ⩽
                                       
                                          
                                             
                                                
                                                   
                                                      z
                                                   
                                                   
                                                      o
                                                   
                                                   
                                                      ∗
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              From (D1) we have 
                                 
                                    
                                       
                                          a
                                       
                                       
                                          j
                                       
                                       
                                          ′
                                       
                                    
                                    ⩾
                                    
                                       
                                          b
                                       
                                       
                                          j
                                       
                                    
                                 
                               and hence (SCD) dominates the inequality
                                 
                                    
                                       
                                          ∑
                                       
                                       (
                                       
                                          
                                             b
                                          
                                          
                                             j
                                          
                                       
                                       
                                          
                                             x
                                          
                                          
                                             j
                                          
                                       
                                       ;
                                       j
                                       ∈
                                       N
                                       )
                                       ⩽
                                       
                                          
                                             z
                                          
                                          
                                             o
                                          
                                          
                                             ∗
                                          
                                       
                                    
                                 
                              where the latter is the same as the guiding inequality (G) except that (G) replaces 
                                 
                                    
                                       
                                          z
                                       
                                       
                                          o
                                       
                                       
                                          ∗
                                       
                                    
                                 
                               by 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   z
                                                
                                                
                                                   o
                                                
                                                
                                                   ∗
                                                
                                             
                                          
                                       
                                    
                                 
                              . In addition, 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   a
                                                
                                                
                                                   j
                                                
                                                
                                                   ′
                                                
                                             
                                          
                                       
                                    
                                    ⩾
                                    
                                       
                                          b
                                       
                                       
                                          j
                                       
                                    
                                 
                               and together with 
                                 
                                    
                                       
                                          a
                                       
                                       
                                          o
                                       
                                       
                                          ′
                                       
                                    
                                    =
                                    
                                       
                                          z
                                       
                                       
                                          o
                                       
                                       
                                          ∗
                                       
                                    
                                 
                               we conclude that (SCID) in turn dominates (G). This proves the first claim of the Proposition.

Next we show that by using the surrogate constraint (SCI) in place of (SCID) we can typically do still better. First consider the outcome of replacing (SCD) with the surrogate constraint (SC), which is given by
                                 
                                    
                                       
                                          ∑
                                       
                                       (
                                       
                                          
                                             a
                                          
                                          
                                             j
                                          
                                       
                                       
                                          
                                             x
                                          
                                          
                                             j
                                          
                                       
                                       ;
                                       j
                                       ∈
                                       N
                                       )
                                       ⩽
                                       
                                          
                                             a
                                          
                                          
                                             o
                                          
                                       
                                    
                                 
                              where 
                                 
                                    
                                       
                                          a
                                       
                                       
                                          j
                                       
                                    
                                    =
                                    
                                       
                                          a
                                       
                                       
                                          i
                                       
                                       
                                          ′
                                       
                                    
                                    -
                                    
                                       
                                          u
                                       
                                       
                                          j
                                       
                                       
                                          ∗
                                       
                                    
                                 
                               for j
                              ∈
                              N and 
                                 
                                    
                                       
                                          a
                                       
                                       
                                          o
                                       
                                    
                                    =
                                    
                                       
                                          z
                                       
                                       
                                          o
                                       
                                       
                                          ∗
                                       
                                    
                                    -
                                    ∑
                                    
                                       
                                          
                                             
                                                
                                                   u
                                                
                                                
                                                   j
                                                
                                                
                                                   ∗
                                                
                                             
                                             :
                                             j
                                             ∈
                                             N
                                          
                                       
                                    
                                 
                              . From this we observe that the inequality (SCD) results from (SC) by multiplying each inequality x
                              
                                 j
                              
                              ⩽1 by the non-negative value 
                                 
                                    
                                       
                                          u
                                       
                                       
                                          j
                                       
                                       
                                          ∗
                                       
                                    
                                 
                               and adding it to (SC). Since the surrogate constraint problem includes the inequalities x
                              
                                 j
                              
                              ⩽1 for j
                              ∈
                              N (as part of the stronger constraint x
                              
                                 j
                              
                              ∈{0,1}), the inequality (SCD) is dominated by (SC) when these constraints are considered as part of the full surrogate constraint problem. This dominance of (SCD) by (SC) indicates that upon considering the integer coefficient versions these constraints, the constraint (SCID) will often be dominated by (SCI).

Finally, the fact that (SCID) strictly dominates the guiding constraint (G) when some coefficient b
                              
                                 j
                               of (G) is negative follows simply from the observation that all coefficients a
                              
                                 ij
                               of the constraints (MK1) are non-negative, and hence both a
                              
                                 j
                              
                              ⩾0 and 
                                 
                                    
                                       
                                          a
                                       
                                       
                                          j
                                       
                                       
                                          ′
                                       
                                    
                                    ⩾
                                    0
                                 
                              , hence 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   a
                                                
                                                
                                                   j
                                                
                                                
                                                   ′
                                                
                                             
                                          
                                       
                                    
                                    >
                                    
                                       
                                          b
                                       
                                       
                                          j
                                       
                                    
                                 
                              .□

Another way of expressing the last statement of the preceding proof is to note that the surrogate constraints (SCI) and (SC) will be unchanged if any negative b
                        
                           j
                         coefficient is replaced by 0. Since this replacement significantly strengthens (G), and since one or both of the indicated surrogate constraints dominate this stronger form of (G), they correspondingly dominate the original form of (G).

We observe that the equations corresponding to the surrogate constraint inequalities of the foregoing Proposition are likewise more restrictive than the equation that enforces (G) as an equality. Thus, equations as well as inequalities derived from surrogate constraints afford an opportunity to produce stronger methods based on incorporating guiding constraints to solve (MK) problems.

The foregoing Proposition raises the thought that the surrogate constraint (SC) may be advantageous in place of using one of the integer coefficient surrogate constraints (SCI) or (SCID). The only reason for using these latter constraints is to be able to conduct a search that systematically decreases the right hand side value ⌊a
                           
                              o
                           ⌋ or 
                              
                                 
                                    
                                       
                                          
                                             
                                                z
                                             
                                             
                                                o
                                             
                                             
                                                ∗
                                             
                                          
                                       
                                    
                                 
                              
                            by integer amounts. But all other search operations using such a surrogate constraint are unaffected by whether its coefficients are integer or not. These include, in particular, the operation of shrinking the set of active variables by reference to the set N
                           
                              o
                           , and the exploitation of the upper bound n0 on the sum of the variables in N
                           
                              o
                           .

Consequently, the fact that (SC) dominates the surrogate constraint (SCD) which is the source of (SCID) makes (SC) an appealing candidate for consideration. A search based on systematically decreasing the right hand side of (SC) is still possible, and in fact integer decrements are reasonable by noting that the resulting right hand side values will still be as large or larger than those obtained by decrementing ⌊a
                           
                              o
                           ⌋. Moreover, since a
                           
                              j
                           
                           ⩾⌊a
                           
                              j
                           ⌋ for left hand side coefficients, the “scale” of an integer decrement in the right hand side is less for (SC) than it is for (SCI). If this loses perfect assurance that no integer solution is bypassed, the implicit tolerance for deviating from an optimum objective function value will be small.

If a search process that uncovers a succession of feasible solutions and keeps track of the best, whose objective function value we denote by 
                              
                                 
                                    
                                       p
                                    
                                    
                                       o
                                    
                                    
                                       ∗
                                    
                                 
                              
                           , it is natural and customary to include the following objective function constraint among the other problem constraints
                              
                                 
                                    
                                       ∑
                                    
                                    (
                                    
                                       
                                          p
                                       
                                       
                                          j
                                       
                                    
                                    
                                       
                                          x
                                       
                                       
                                          j
                                       
                                    
                                    ;
                                    j
                                    ∈
                                    N
                                    )
                                    ⩾
                                    
                                       
                                          p
                                       
                                       
                                          o
                                       
                                       
                                          ∗
                                       
                                    
                                    +
                                    1
                                 
                              
                           (The value 
                              
                                 
                                    
                                       p
                                    
                                    
                                       o
                                    
                                    
                                       ∗
                                    
                                 
                                 +
                                 1
                              
                            is based on assuming the p
                           
                              j
                            coefficients are integers.) To include this constraint among those of (P) to generate a surrogate constraint, we may re-write it as
                              
                                 (OB)
                                 
                                    
                                       ∑
                                    
                                    (
                                    (
                                    -
                                    
                                       
                                          p
                                       
                                       
                                          j
                                       
                                    
                                    )
                                    
                                       
                                          x
                                       
                                       
                                          j
                                       
                                    
                                    ;
                                    j
                                    ∈
                                    N
                                    )
                                    ⩽
                                    -
                                    
                                       
                                          
                                             
                                                
                                                   p
                                                
                                                
                                                   o
                                                
                                                
                                                   ∗
                                                
                                             
                                             +
                                             1
                                          
                                       
                                    
                                 
                              
                           where OB is shorthand for “objective.” When surrogate constraints are generated from the resulting modified form of (P) and (D), there is an option of including or excluding the weight attached to (OB). In either case, the modified (P) and (D) can be valuable for strategies such as those discussed in Section 7.3 below.

Assuming all coefficients of (P) are integers the range of surrogate constraints considered can be enlarged by a special use of the classical Gomory fractional cuts (FC). For our present purpose, we write these cuts in the following form
                              
                                 (FC)
                                 
                                    s
                                    =
                                    
                                       ∑
                                    
                                    (
                                    
                                       
                                          f
                                       
                                       
                                          j
                                       
                                    
                                    
                                       
                                          x
                                       
                                       
                                          j
                                       
                                    
                                    ;
                                    j
                                    ∈
                                    NB
                                    1
                                    )
                                    +
                                    
                                       ∑
                                    
                                    (
                                    
                                       
                                          f
                                       
                                       
                                          i
                                       
                                    
                                    
                                       
                                          s
                                       
                                       
                                          i
                                       
                                    
                                    ;
                                    i
                                    ∈
                                    NB
                                    2
                                    )
                                    +
                                    
                                       ∑
                                    
                                    (
                                    
                                       
                                          f
                                       
                                       
                                          j
                                       
                                    
                                    
                                       
                                          v
                                       
                                       
                                          j
                                       
                                    
                                    ;
                                    j
                                    ∈
                                    NB
                                    3
                                    )
                                    -
                                    
                                       
                                          f
                                       
                                       
                                          o
                                       
                                    
                                 
                              
                           Here “NB” refers to the set of non-basic variables in the optimal LP basic solution, and we have divided this set into NB1={j
                           ∈
                           N; x
                           
                              j
                            is non-basic}, NB2={i
                           ∈
                           M; s
                           
                              i
                            is non-basic} and NB3={j
                           ∈
                           N; v
                           
                              j
                            is non-basic}, where the variables s
                           
                              i
                           , i
                           ∈
                           M are the slack variables for the constraints of (MK1) and the variables v
                           
                              j
                           , j
                           ∈
                           N are the slack variables for the constraints of (MK2′). The “fractional” coefficients f
                           
                              o
                           , f
                           
                              i
                            and f
                           
                              j
                            are non-negative values less than 1 (with f
                           
                              o
                           
                           >0) and s is the integer-valued slack variable for (FC). A Gomory all-integer cut can be obtained for the original representation of (P) (as opposed to the optimal basis representation that gives rise to (FC)) by noting that the coefficients f
                           
                              j
                            for j
                           ∈NB1 can be viewed as weights for the inequalities x
                           
                              j
                           
                           ⩾0, written in the form −x
                           
                              j
                           
                           ⩽0 to include among the other “⩽constraints” of (P). Then, multiplying each inequality of (P) by its corresponding non-negative weight from (FC) we obtain a valid inequality, and since s also has a representation as an integer linear combination of the current non-basic variables, we know the coefficients of the inequality for (P) are integers. However the right hand side is fractional, equal to an integer +f
                           
                              o
                           , and hence upon rounding this value down (equivalent to subtracting f
                           
                              o
                           ) we obtain a Gomory all-integer cut for (P) that corresponds to the fractional cut (FC).

For the goal of generating a surrogate constraint, however, we are only interested in the weights w
                           
                              i
                           
                           =
                           f
                           
                              i
                            for i
                           ∈NB2⊆
                           M, since the inequalities x
                           
                              j
                           
                           ⩾0 and x
                           
                              j
                           
                           ⩽1 are explicitly included within the surrogate constraint system as part of x
                           
                              j
                           
                           ∈{0,1}, and thus including the weights f
                           
                              j
                            for j
                           ∈NB1 and for j
                           ∈NB3 only weakens the resulting constraint. (This is conspicuously true for j
                           ∈NB1, since including the weight f
                           
                              j
                            adds f
                           
                              j
                           (−x
                           
                              j
                           ) to the resulting constraint, thus reducing the coefficient of x
                           
                              j
                           .) Consequently, by defining w
                           
                              i
                           
                           =
                           f
                           
                              i
                            for i
                           ∈NB2 and w
                           
                              i
                           
                           =0 for i
                           ∈
                           M
                           −NB2 we obtain a surrogate constraint of the form (SC) that may be denoted.

Different Gomory fractional cuts give rise to different surrogate constraints (SC)–(FC), and these provide an opportunity for using additional guiding constraints for solving (MK). When an objective function constraint is incorporated, as above, then it may optionally be considered as included among the constraints defining (MK1). As previously noted, we do not necessarily require the coefficients of the resulting surrogate constraints to be integers.

We now examine a new class of strategies for exploiting surrogate constraints obtained by reference to (P).

The Proposition of Section 7.2 and its associated discussion suggest how we can improve upon the customary approaches that use guiding inequalities for (MK). In these approaches the objective function Maximize 
                           
                              
                                 
                                    z
                                 
                                 
                                    o
                                 
                              
                              =
                              ∑
                              (
                              
                                 
                                    b
                                 
                                 
                                    j
                                 
                              
                              
                                 
                                    x
                                 
                                 
                                    j
                                 
                              
                              :
                              j
                              ∈
                              N
                              )
                           
                         for (P) either has all coefficients b
                        
                           j
                        
                        =1, or has some b
                        
                           j
                        
                        =1 and some b
                        
                           j
                        
                        =−1. However, we are motivated to go farther by considering other possibilities for selecting the coefficients of (P) to create guiding surrogate constraints, and to use the outcome of solving (P) as a basis for additional information to aid the search for a solution to (MK).

We start from the premise that that it can be valuable to obtain surrogate constraints (and hence their associated surrogate constraint problems) which are likely to yield values of variables that match the values we anticipate most likely to correspond to values in an (MK) solution. Variables we estimate should receive 0 values will be called weak variables and variables we estimate should instead receive values of 1 will be called strong variables. We begin with the supposition that a good portion of the variables that should receive values of 0 and 1 will respectively be among those that have values close to 0 and close to 1 in an LP solution to (MK), and hence we use this as an initial criterion for identifying weak and strong variables.

Evidently, surrogate constraints that yield larger coefficients a
                        
                           j
                         and 
                           
                              
                                 
                                    a
                                 
                                 
                                    j
                                 
                                 
                                    ′
                                 
                              
                           
                         for the weak variables compared to the coefficients for the strong variables will be more likely to drive the weak x
                        
                           j
                         variables to 0 in a knapsack solution. (This likelihood is reinforced by the definition of N
                        
                           o
                         as the index set for variables that have coefficients not exceeding the current right-hand-side.) But since the dual problem (D) bounds each 
                           
                              
                                 
                                    a
                                 
                                 
                                    j
                                 
                                 
                                    ′
                                 
                              
                           
                         from below by b
                        
                           j
                        , we may expect to influence the surrogate constraint to have the desired form by selecting positive b
                        
                           j
                         coefficients for the weak variables and zero b
                        
                           j
                         coefficients for the strong variables.

More formally, let 
                           
                              
                                 
                                    x
                                 
                                 
                                    j
                                 
                                 
                                    MK
                                 
                              
                           
                         denote the value of x
                        
                           j
                         in an optimal LP solution to (MK). Then we select a fractional threshold T and define the weak and strong index sets by
                           
                              
                                 Weak
                                 =
                                 {
                                 j
                                 ∈
                                 N
                                 :
                                 
                                    
                                       x
                                    
                                    
                                       j
                                    
                                    
                                       MK
                                    
                                 
                                 ⩽
                                 T
                                 }
                                 
                                 and
                                 
                                 Strong
                                 =
                                 {
                                 j
                                 ∈
                                 N
                                 :
                                 
                                    
                                       x
                                    
                                    
                                       j
                                    
                                    
                                       MK
                                    
                                 
                                 >
                                 T
                                 }
                              
                           
                        From this, we choose b
                        
                           j
                        
                        >0 for j
                        ∈Weak and b
                        
                           j
                        
                        =0 for j
                        ∈Strong. By allowing T to vary, we can generate different collections of Weak and Strong variables, and thus induce the resulting surrogate constraints to influence the solution of (MK) in different ways in the role of guiding constraints.

Among the possibilities for selecting the values of the positive b
                        
                           j
                         coefficients, two apparent candidates are to set (i) b
                        
                           j
                        
                        =1 for j
                        ∈Weak and (ii) b
                        
                           j
                        
                        =
                        p
                        
                           j
                         for j
                        ∈Weak. By these choices, the instances of problem (P) that result for various values of the threshold T can readily be solved by post-optimization starting from the LP solution to (MK), and proceeding from smaller values of T to larger ones. By this means, the first post-optimization will occur for the instance that is closest in form to (MK) (especially when choosing b
                        
                           j
                        
                        =
                        p
                        
                           j
                         as opposed to b
                        
                           j
                        
                        =1) and each successive instance will be relatively close to the one preceding.

Moreover, we can use solutions to these problems to refine the choices of Strong and Weak variables and to aid in the determination of 0–1 trial solutions for (MK). We describe how this can be done in very general terms, to provide latitude for multiple strategies.

Let 
                           
                              
                                 
                                    x
                                 
                                 
                                    j
                                 
                                 
                                    P
                                 
                              
                           
                         denote the value of x
                        
                           j
                         in an LP solution to (P). If a variable x
                        
                           j
                         in the Strong set (i.e., for which j
                        ∈Strong) yields a value 
                           
                              
                                 
                                    x
                                 
                                 
                                    j
                                 
                                 
                                    P
                                 
                              
                           
                         that is not appreciably closer to 0 than 
                           
                              
                                 
                                    x
                                 
                                 
                                    j
                                 
                                 
                                    MK
                                 
                              
                           
                        , then in view of the fact that b
                        
                           j
                        
                        =0 provides less inducement for x
                        
                           j
                         to be positive than the p
                        
                           j
                         coefficient in (MK), we may take this as evidence that x
                        
                           j
                         should indeed belong in the strong category. Consequently we are motivated to employ a trial solution strategy that sets x
                        
                           j
                        
                        =1 for such variables. On the other hand, if the relative decrease in 
                           
                              
                                 
                                    x
                                 
                                 
                                    j
                                 
                                 
                                    P
                                 
                              
                           
                         compared to 
                           
                              
                                 
                                    x
                                 
                                 
                                    j
                                 
                                 
                                    MK
                                 
                              
                           
                         is greater than that the decrease for most other variables in the Strong set, then we may surmise that x
                        
                           j
                         is not as strong as originally anticipated. This latter condition therefore motivates a transfer of j to the Weak set.

Similarly, if a variable x
                        
                           j
                         in the Weak set yields a value 
                           
                              
                                 
                                    x
                                 
                                 
                                    j
                                 
                                 
                                    P
                                 
                              
                           
                         which is not appreciably closer to 1 than 
                           
                              
                                 
                                    x
                                 
                                 
                                    j
                                 
                                 
                                    MK
                                 
                              
                           
                        , then in view of the fact that b
                        
                           j
                        
                        >0 provides greater inducement for x
                        
                           j
                         to be positive than the coefficients b
                        
                           j
                        
                        =0 for variables in the Strong set, and in view of the effect of inequalities of (MK1) which causes a competition among variables to receive positive values, we may interpret the lack of increase in 
                           
                              
                                 
                                    x
                                 
                                 
                                    j
                                 
                                 
                                    P
                                 
                              
                           
                         over 
                           
                              
                                 
                                    x
                                 
                                 
                                    j
                                 
                                 
                                    MK
                                 
                              
                           
                         as evidence that x
                        
                           j
                         indeed belongs in the weak category. Consequently, this supports a trial solution strategy that sets x
                        
                           j
                        
                        =0 for such variables. On the other hand, if the relative increase in 
                           
                              
                                 
                                    x
                                 
                                 
                                    j
                                 
                                 
                                    P
                                 
                              
                           
                         compared to 
                           
                              
                                 
                                    x
                                 
                                 
                                    j
                                 
                                 
                                    MK
                                 
                              
                           
                         is greater than that the increase for most other variables in the Weak set, then we may conclude that x
                        
                           j
                         is not as weak as originally anticipated. This latter condition therefore motivates a transfer of j to the Strong set.

When applying the preceding principles, variables that jump back and forth between the Strong and Weak categories are the ones that deserve special attention. Ultimately, when variables that belong more consistently to the Strong and Weak categories are set to their presumed appropriate values, the step of re-solving (P) for the reduced problem should cause these “vacillating variables” to become more stable (and land more decisively within either the Weak or Strong set), thus identifying good trial values for these variables as well.

Greater variety in the foregoing process can be induced by using probabilities for assigning indexes to the Weak and Strong sets, where the magnitude of such probabilities is based on the proximity of 
                           
                              
                                 
                                    x
                                 
                                 
                                    j
                                 
                                 
                                    MK
                                 
                              
                           
                         to T. However, this probabilistic approach weakens the basis for concluding whether a variable should be considered as a stable member of one set or another.

The strategic oscillation approach sketched in Section 6 describes a form of this method in which the critical region is given in terms of the boundary that demarks feasibility from infeasibility. Other definitions of the critical region are appropriate to other forms of strategic oscillation and additional observations are warranted in order to identify how the Hover-Oscillation Method of Section 6.3 can be adapted to these cases. We first introduce key considerations relevant to the Hover-Oscillation Method in the context of the multiple knapsack problem, as treated in Section 6, identifying its components more rigorously and providing details of how the coordination of constructive and destructive phases occurs. Following this we discuss broader issues for carrying these ideas into other problem settings.

We begin by giving a more compact but more technical description of the Hover-Oscillation Method of Section 6.3. We employ the following conventions.

The hover-levels are indexed by L
                        =0 to CrestLevel, the upper turn-around level, where a Destructive Phase is launched. A Destructive Phase then decreases L, proceeding from CrestLevel to TroughLevel, the lower turn-around level, where a new Constructive Phase in launched in turn. Thereafter, the method oscillates by repeating the Constructive and Destructive Phases. The number of levels between the lower and upper turn-around points (CrestLevel+1−TroughLevel) can be changed by reselecting CrestLevel each time L
                        =TroughLevel or L
                        =CrestLevel is reached.

The hover-level multiples H(L) that give current resource capacities by the formula a
                        
                           ok
                        (L)=
                        H(L)a
                        
                           ok
                        , k
                        ∈
                        K can also change. We represent these capacities more directly by b
                        
                           ok
                        
                        =
                        H(L)a
                        
                           ok
                        , k
                        ∈
                        K The application of either a constructive method in a Constructive Phase or a destructive method in a Destructive Phase, followed by an execution an Improvement Method, defines a pass of the method. That is, a Constructive Pass occurs when L increases by 1, and a new increased resource level 
                           
                              
                                 
                                    b
                                 
                                 
                                    ok
                                 
                                 
                                    ∗
                                 
                              
                              =
                              H
                              (
                              L
                              +
                              1
                              )
                              
                                 
                                    a
                                 
                                 
                                    ok
                                 
                              
                           
                         results, while a Destructive Pass occurs when L decreases by 1, and a new decreased resource level 
                           
                              
                                 
                                    b
                                 
                                 
                                    ok
                                 
                                 
                                    ∗
                                 
                              
                              =
                              H
                              (
                              L
                              -
                              1
                              )
                              
                                 
                                    a
                                 
                                 
                                    ok
                                 
                              
                           
                         results.

Both the values of CrestLevel and TroughLevel, and the values H (L) can change from one oscillation to another. However, we retain the relationships
                           
                              
                                 
                                    
                                       
                                       
                                          
                                             H
                                             (
                                             L
                                             +
                                             1
                                             )
                                             >
                                             H
                                             (
                                             L
                                             )
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             H
                                             (
                                             L
                                             )
                                             =
                                             1
                                             
                                             for
                                             
                                             some
                                             
                                             L
                                             
                                             such
                                             
                                             that
                                             
                                             TroughLevel
                                             <
                                             L
                                             <
                                             CrestLevel
                                          
                                       
                                    
                                 
                              
                           
                        where H(L)=1 identifies the critical level where b
                        
                           ok
                        
                        =
                        a
                        
                           ok
                        . By convention H(0)=0, but normally L
                        =0 is only relevant for launching the initial constructive pass. (We could assume that TroughLevel is always represented by L
                        =1 after this initial pass, but we refer to TroughLevel as a counterpart to CrestLevel to keep the description of the method symmetric.)

The resulting Hover-Oscillation Method is described next to give an overall view of its structure, though we have not yet described the Destructive Greedy (QMK) Method employed during its Destructive Phase. This latter method requires the introduction of several additional observations, and is described subsequently.


                           
                              
                                 
                                    
                                    
                                       
                                          
                                             Initialization: x
                                             
                                                j
                                             
                                             =0, j
                                             ∈
                                             N, and J
                                             
                                                k
                                             
                                             =∅, RHS
                                                k
                                             
                                             =0, k
                                             ∈
                                             K.
                                       
                                       
                                          Set the initial boundary level by b
                                             
                                                ok
                                             
                                             =0, k
                                             ∈
                                             K, corresponding to H(L)=0 for L
                                             =0.
                                       
                                       
                                          Establish a Termination Condition represented by Termination=true or false
                                       
                                       
                                          While Termination=false
                                       
                                       
                                          
                                             (Constructive Phase of Oscillation)
                                       
                                       
                                          
                                             While L
                                             <CrestLevel
                                       
                                       
                                          
                                             
                                             L
                                             =
                                             L
                                             +1 (Begin Constructive Pass)
                                       
                                       
                                          
                                             
                                             
                                                
                                                   
                                                      
                                                         b
                                                      
                                                      
                                                         ok
                                                      
                                                      
                                                         ∗
                                                      
                                                   
                                                   =
                                                   H
                                                   (
                                                   L
                                                   )
                                                   
                                                      
                                                         a
                                                      
                                                      
                                                         ok
                                                      
                                                   
                                                   ,
                                                   k
                                                   ∈
                                                   K
                                                
                                             .
                                       
                                       
                                          
                                             
                                             
                                                
                                                   
                                                      
                                                         RHS
                                                      
                                                      
                                                         k
                                                      
                                                   
                                                   =
                                                   
                                                      
                                                         RHS
                                                      
                                                      
                                                         k
                                                      
                                                   
                                                   +
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  b
                                                               
                                                               
                                                                  ok
                                                               
                                                               
                                                                  ∗
                                                               
                                                            
                                                            -
                                                            
                                                               
                                                                  b
                                                               
                                                               
                                                                  ok
                                                               
                                                            
                                                         
                                                      
                                                   
                                                   ,
                                                   k
                                                   ∈
                                                   K
                                                
                                              (RHS
                                                k
                                              increases)
                                       
                                       
                                          
                                             
                                             
                                                
                                                   
                                                      
                                                         b
                                                      
                                                      
                                                         ok
                                                      
                                                   
                                                   =
                                                   
                                                      
                                                         b
                                                      
                                                      
                                                         ok
                                                      
                                                      
                                                         ∗
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             Execute Constructive Greedy (QMK) Method
                                       
                                       
                                          
                                             Execute Improvement Method
                                       
                                       
                                          
                                             EndWhile
                                       
                                       
                                          
                                             (Destructive Phase of Oscillation)
                                       
                                       
                                          
                                             While L
                                             >TroughLevel
                                       
                                       
                                          
                                             
                                             L
                                             =
                                             L
                                             −1 (Begin Destructive Pass)
                                       
                                       
                                          
                                             
                                             
                                                
                                                   
                                                      
                                                         b
                                                      
                                                      
                                                         ok
                                                      
                                                      
                                                         ∗
                                                      
                                                   
                                                   =
                                                   H
                                                   (
                                                   L
                                                   )
                                                   
                                                      
                                                         a
                                                      
                                                      
                                                         ok
                                                      
                                                   
                                                   ,
                                                   k
                                                   ∈
                                                   K
                                                
                                             .
                                       
                                       
                                          
                                             
                                             
                                                
                                                   
                                                      
                                                         RHS
                                                      
                                                      
                                                         k
                                                      
                                                   
                                                   =
                                                   
                                                      
                                                         RHS
                                                      
                                                      
                                                         k
                                                      
                                                   
                                                   +
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  b
                                                               
                                                               
                                                                  ok
                                                               
                                                               
                                                                  ∗
                                                               
                                                            
                                                            -
                                                            
                                                               
                                                                  b
                                                               
                                                               
                                                                  ok
                                                               
                                                            
                                                         
                                                      
                                                   
                                                   ,
                                                   k
                                                   ∈
                                                   K
                                                
                                              (RHS
                                                k
                                              decreases)
                                       
                                       
                                          
                                             
                                             
                                                
                                                   
                                                      
                                                         b
                                                      
                                                      
                                                         ok
                                                      
                                                   
                                                   =
                                                   
                                                      
                                                         b
                                                      
                                                      
                                                         ok
                                                      
                                                      
                                                         ∗
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             Execute Destructive Greedy (QMK) Method
                                       
                                       
                                          
                                             Execute Improvement Method
                                       
                                       
                                          
                                             EndWhile
                                       
                                       
                                          
                                             (Return to launch next Constructive Phase)
                                       
                                       
                                          Endwhile
                                       
                                    
                                 
                              
                           
                        

There are several things to observe.
                              
                                 1.
                                 The Termination Condition can be established in various ways, as in customary metaheuristic methods. For example, when the Improvement Method is applied at the critical level, a check can be maintained of the number of iterations since the last new best solution was obtained, and the method may terminate when this number exceeds a desired cutoff. Alternatively, the method may terminate after a specified overall iteration limit or time limit is exceeded, and so forth.

In the Constructive Phase, 
                                       
                                          
                                             
                                                b
                                             
                                             
                                                ok
                                             
                                             
                                                ∗
                                             
                                          
                                          >
                                          
                                             
                                                b
                                             
                                             
                                                ok
                                             
                                          
                                       
                                    , and hence the value RHS
                                       k
                                     increases, while in the Destructive Phase, 
                                       
                                          
                                             
                                                b
                                             
                                             
                                                ok
                                             
                                             
                                                ∗
                                             
                                          
                                          <
                                          
                                             
                                                b
                                             
                                             
                                                ok
                                             
                                          
                                       
                                    , and hence the value RHS
                                       k
                                     decreases. If the problem data are integers, as often is the case, each new 
                                       
                                          
                                             
                                                b
                                             
                                             
                                                ok
                                             
                                             
                                                ∗
                                             
                                          
                                       
                                     can be rounded to its nearest integer value so that the successive RHS
                                       k
                                     values will also be integers.

The format of setting 
                                       
                                          
                                             
                                                b
                                             
                                             
                                                ok
                                             
                                             
                                                ∗
                                             
                                          
                                          =
                                          H
                                          (
                                          L
                                          )
                                          
                                             
                                                a
                                             
                                             
                                                ok
                                             
                                          
                                          ,
                                          k
                                          ∈
                                          K
                                       
                                     is primarily for representational convenience and to give an intuitive glimpse of possibilities for setting resource levels. Because of the flexibility for revising the H(L) values, we could as easily stipulate that the 
                                       
                                          
                                             
                                                b
                                             
                                             
                                                ok
                                             
                                             
                                                ∗
                                             
                                          
                                       
                                     values are generated by performing a current evaluation process each time L changes. As the process continues, the depth of the oscillation (distance between the turn-around points) can become relatively shallow.

At the conclusion of both the Constructive and Destructive Greedy methods, the value of RHS
                                       k
                                     will be given by 
                                       
                                          
                                             
                                                RHS
                                             
                                             
                                                k
                                             
                                          
                                          =
                                          
                                             
                                                b
                                             
                                             
                                                ok
                                             
                                          
                                          -
                                          ∑
                                          
                                             
                                                a
                                             
                                             
                                                jk
                                             
                                          
                                          :
                                          j
                                          ∈
                                          
                                             
                                                J
                                             
                                             
                                                k
                                             
                                          
                                          )
                                          ⩾
                                          0
                                          ,
                                          k
                                          ∈
                                          K
                                       
                                    . Hence the Improvement Method inherits the condition 
                                       
                                          ∑
                                          
                                             
                                                a
                                             
                                             
                                                jk
                                             
                                          
                                          
                                             
                                                x
                                             
                                             
                                                jk
                                             
                                          
                                          :
                                          j
                                          ∈
                                          
                                             
                                                J
                                             
                                             
                                                k
                                             
                                          
                                          )
                                          ⩽
                                          
                                             
                                                b
                                             
                                             
                                                ok
                                             
                                          
                                       
                                     (since J
                                    
                                       k
                                    
                                    ={j
                                    ∈
                                    N: x
                                    
                                       jk
                                    
                                    =1}).

As already intimated, the Improvement Method is applied more intensively during a process of approaching the critical level than during a process of retreating from the critical level, and as the current b
                                    
                                       ok
                                     values become closer to the a
                                    
                                       ok
                                     values (devoting the greatest effort to the case b
                                    
                                       ok
                                    
                                    =
                                    a
                                    
                                       ok
                                    , which identifies the critical level). Upon drawing close to the critical level, it is natural to allow the Improvement Method to have some flexibility to make moves that slightly violate the feasibility conditions. (If this is done at the critical level itself, the approach must of course complement such moves with others that restore feasibility.)

The Hover-Oscillation Method could also begin by launching a Destructive Phase first, setting all x
                                    
                                       j
                                    
                                    =1 initially and arbitrarily (or heuristically) assigning the indexes j to the sets J
                                    
                                       k
                                    , to determine 
                                       
                                          
                                             
                                                RHS
                                             
                                             
                                                k
                                             
                                          
                                          =
                                          
                                             
                                                a
                                             
                                             
                                                ok
                                             
                                          
                                          -
                                          ∑
                                          (
                                          
                                             
                                                a
                                             
                                             
                                                jk
                                             
                                          
                                          :
                                          j
                                          ∈
                                          
                                             
                                                J
                                             
                                             
                                                k
                                             
                                          
                                          )
                                       
                                    .

We remark that it is also possible to select the critical level to be a turn-around level, in which case the method gives a one-sided oscillation. In such an approach, all oscillation occurs within exactly one of the feasible and infeasible regions, except that the final step within the infeasible region crosses into the feasible region in order to attain the the critical level that defines a complete (and feasible) solution.

Now we turn to describing the Destructive Method that is incorporated within the foregoing approach.

We require some additional conventions and definitions. As in the Constructive Greedy (QMK) Method, we make use of the term QP
                           jk
                         defined by
                           
                              
                                 
                                    
                                       QP
                                    
                                    
                                       jk
                                    
                                 
                                 =
                                 
                                    
                                       p
                                    
                                    
                                       j
                                    
                                 
                                 +
                                 
                                    ∑
                                 
                                 (
                                 
                                    
                                       p
                                    
                                    
                                       hj
                                    
                                 
                                 :
                                 h
                                 ∈
                                 
                                    
                                       J
                                    
                                    
                                       k
                                    
                                 
                                 )
                              
                           
                        However, since we are choosing an index j
                        ∗ to remove from J
                        
                           k
                         instead of one to add to J
                        
                           k
                         (i.e., changing 
                           
                              
                                 
                                    x
                                 
                                 
                                    
                                       
                                          j
                                       
                                       
                                          ∗
                                       
                                    
                                 
                              
                           
                         from 1 to 0 instead of from 0 to 1) we are only interested in quantities QP
                           jk
                         such that j
                        ∈
                        J
                        
                           k
                        . (Note it is not necessary in this case to stipulate h
                        ≠
                        j in defining QP
                           jk
                         above since p
                        
                           jj
                        
                        =0.)

Analogous to the profit term QProfit
                           k
                         used in the Constructive Method, we introduce a lost profit term 
                           
                              
                                 
                                    QProfit
                                 
                                 
                                    k
                                 
                                 
                                    o
                                 
                              
                           
                         for the Destructive Method which we define by
                           
                              
                                 
                                    
                                       QProfit
                                    
                                    
                                       k
                                    
                                    
                                       o
                                    
                                 
                                 (
                                 1
                                 ,
                                 …
                                 ,
                                 r
                                 )
                                 =
                                 
                                    ∑
                                 
                                 (
                                 
                                    
                                       QP
                                    
                                    
                                       j
                                    
                                 
                                 :
                                 j
                                 ∈
                                 [
                                 1
                                 ,
                                 r
                                 ]
                                 )
                                 -
                                 
                                    
                                       Delta
                                    
                                    
                                       r
                                    
                                 
                              
                           
                        Where, as before, 
                           
                              
                                 
                                    Delta
                                 
                                 
                                    r
                                 
                              
                              =
                              ∑
                              (
                              
                                 
                                    p
                                 
                                 
                                    hj
                                 
                              
                              :
                              h
                              ∈
                              [
                              1
                              ,
                              r
                              -
                              1
                              ]
                              ,
                              j
                              ∈
                              [
                              h
                              +
                              1
                              ,
                              r
                              ]
                              )
                              (
                              
                                 
                                    Delta
                                 
                                 
                                    r
                                 
                              
                              =
                              0
                           
                         if r
                        =1). Here we assume [1, r]⊆
                        J
                        
                           k
                        .

There are two ways in which 
                           
                              
                                 
                                    QProfit
                                 
                                 
                                    k
                                 
                                 
                                    o
                                 
                              
                           
                         of the Destructive Method contrasts with QProfit
                           k
                         of the Constructive Method. First, as seen earlier, QProfit
                           k
                         is defined for the Constructive Method by
                           
                              
                                 
                                    
                                       QProfit
                                    
                                    
                                       k
                                    
                                 
                                 (
                                 1
                                 ,
                                 …
                                 ,
                                 r
                                 )
                                 =
                                 
                                    ∑
                                 
                                 (
                                 
                                    
                                       QP
                                    
                                    
                                       jk
                                    
                                 
                                 :
                                 j
                                 ∈
                                 [
                                 1
                                 ,
                                 r
                                 ]
                                 )
                                 +
                                 
                                    
                                       Delta
                                    
                                    
                                       r
                                    
                                 
                              
                           
                        hence attaching a different sign to Delta
                           r
                        . Second, although the definition of Delta
                           r
                         appears to be identical in the Constructive and Destructive Methods, in the Constructive case the indexes j
                        ∈[1, r] are elements of N
                        −
                        N1 (={j
                        ∈
                        N: x
                        
                           j
                        
                        =0}), while in the Destructive case the indexes j
                        ∈[1, r] are elements of N1 (={j
                        ∈
                        N: x
                        
                           j
                        
                        =1}) and in addition are assigned to a specific knapsack k; i.e., they are elements of J
                        
                           k
                        .

Employing the convention 
                           
                              
                                 
                                    QProfit
                                 
                                 
                                    k
                                 
                                 
                                    o
                                 
                              
                              (
                              1
                              )
                              =
                              
                                 
                                    Q
                                 
                                 
                                    1
                                    k
                                 
                              
                           
                        , we may similarly write (in the case r
                        >1)
                           
                              
                                 
                                    
                                       QProfit
                                    
                                    
                                       k
                                    
                                    
                                       o
                                    
                                 
                                 (
                                 1
                                 ,
                                 …
                                 ,
                                 r
                                 )
                                 =
                                 
                                    
                                       QProfit
                                    
                                    
                                       k
                                    
                                    
                                       o
                                    
                                 
                                 (
                                 1
                                 ,
                                 …
                                 ,
                                 r
                                 -
                                 1
                                 )
                                 +
                                 
                                    
                                       QP
                                    
                                    
                                       rk
                                    
                                 
                                 -
                                 
                                    
                                       PostDelta
                                    
                                    
                                       r
                                    
                                 
                              
                           
                        where 
                           
                              
                                 
                                    PostDelta
                                 
                                 
                                    r
                                 
                              
                              =
                              ∑
                              (
                              
                                 
                                    p
                                 
                                 
                                    hr
                                 
                              
                              :
                              h
                              ∈
                              [
                              1
                              ,
                              r
                              -
                              1
                              ]
                              )
                           
                        .

Thus, in particular, the 2-element and 3-element cases yield
                           
                              
                                 
                                    
                                       Profit
                                    
                                    
                                       k
                                    
                                 
                                 (
                                 1
                                 ,
                                 2
                                 
                                    
                                       )
                                    
                                    
                                       o
                                    
                                 
                                 =
                                 
                                    
                                       QP
                                    
                                    
                                       1
                                       k
                                    
                                 
                                 +
                                 
                                    
                                       QP
                                    
                                    
                                       2
                                       k
                                    
                                 
                                 -
                                 
                                    
                                       p
                                    
                                    
                                       12
                                    
                                 
                              
                           
                        and
                           
                              
                                 
                                    
                                       Profit
                                    
                                    
                                       k
                                    
                                    
                                       o
                                    
                                 
                                 (
                                 1.2.3
                                 )
                                 =
                                 
                                    
                                       QP
                                    
                                    
                                       1
                                       k
                                    
                                 
                                 +
                                 
                                    
                                       QP
                                    
                                    
                                       2
                                       k
                                    
                                 
                                 +
                                 
                                    
                                       Q
                                    
                                    
                                       3
                                       k
                                    
                                 
                                 -
                                 
                                    
                                       p
                                    
                                    
                                       12
                                    
                                 
                                 -
                                 
                                    
                                       p
                                    
                                    
                                       13
                                    
                                 
                                 -
                                 
                                    
                                       p
                                    
                                    
                                       23
                                    
                                 
                              
                           
                        Moreover, because 
                           
                              
                                 
                                    Profit
                                 
                                 
                                    k
                                 
                                 
                                    o
                                 
                              
                           
                         is a lost profit (i.e., it represents the amount by which profit decreases when variables change from 1 to 0), we want to minimize rather than maximize this quantity. More precisely, we want to minimize an associated quantity 
                           
                              
                                 
                                    QRatio
                                 
                                 
                                    k
                                 
                                 
                                    o
                                 
                              
                           
                         or 
                           
                              
                                 
                                    QProduct
                                 
                                 
                                    k
                                 
                                 
                                    o
                                 
                              
                           
                         analogous to QRatio
                           k
                         and QProduct
                           k
                         in the Constructive Method. However, 
                           
                              
                                 
                                    QRatio
                                 
                                 
                                    k
                                 
                                 
                                    o
                                 
                              
                           
                         and 
                           
                              
                                 
                                    QProduct
                                 
                                 
                                    k
                                 
                                 
                                    o
                                 
                              
                           
                         are defined somewhat differently than QRatio
                           k
                         and QProduct
                           k
                        , drawing on the following stipulations.

Just as n
                        
                           j
                        , n0 and 
                           
                              
                                 
                                    n
                                 
                                 
                                    j
                                 
                                 
                                    ′
                                 
                              
                           
                         in the knapsack (LK) case are replaced by m
                        
                           j
                        , m0 and 
                           
                              
                                 
                                    m
                                 
                                 
                                    j
                                 
                                 
                                    ′
                                 
                              
                           
                         in the covering (LC) case, we replace the values n
                        
                           k
                        (1,…,
                        r), n0
                           k
                         and 
                           
                              
                                 
                                    n
                                 
                                 
                                    k
                                 
                                 
                                    ′
                                 
                              
                              (
                              1
                              ,
                              
                              …
                              
                              ,
                              
                              r
                              )
                           
                         for the Constructive Method with values m
                        
                           k
                        (1,…,
                        r), m0
                           k
                         and 
                           
                              
                                 
                                    m
                                 
                                 
                                    k
                                 
                                 
                                    ′
                                 
                              
                              (
                              1
                              ,
                              
                              …
                              
                              ,
                              r
                              )
                           
                         for the Destructive Method. The quantity m0
                           k
                         is entirely analogous to m0, representing the least number of variables x
                        
                           j
                         that can be set to 0 in order to satisfy the resource level b
                        
                           ok
                         of knapsack k. A fast method for determining m0, corresponding to the fast level for determining n0 in Section 4.1, can be applied to each knapsack k to yield m0
                           k
                        .

Let 
                           
                              
                                 
                                    RHS
                                 
                                 
                                    k
                                 
                                 
                                    o
                                 
                              
                              =
                              -
                              
                                 
                                    RHS
                                 
                                 
                                    k
                                 
                              
                           
                        . In reference to 2-element combinations we define
                           
                              
                                 
                                    
                                       m
                                    
                                    
                                       k
                                    
                                 
                                 (
                                 1
                                 ,
                                 2
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             
                                                RHS
                                             
                                             
                                                k
                                             
                                             
                                                o
                                             
                                          
                                          /
                                          (
                                          
                                             
                                                a
                                             
                                             
                                                1
                                             
                                          
                                          +
                                          
                                             
                                                a
                                             
                                             
                                                2
                                             
                                          
                                          )
                                       
                                    
                                 
                                 
                                 and
                                 
                                 
                                    
                                       m
                                    
                                    
                                       k
                                    
                                    
                                       ′
                                    
                                 
                                 (
                                 1
                                 ,
                                 2
                                 )
                                 =
                                 Max
                                 (
                                 
                                    
                                       m
                                    
                                    
                                       k
                                    
                                 
                                 (
                                 1
                                 ,
                                 2
                                 )
                                 ,
                                 ⌊
                                 m
                                 
                                    
                                       0
                                    
                                    
                                       k
                                    
                                 
                                 /
                                 2
                                 ⌋
                                 )
                              
                           
                        Similarly, in reference to 3-element combinations we define
                           
                              
                                 
                                    
                                       m
                                    
                                    
                                       k
                                    
                                 
                                 (
                                 1
                                 ,
                                 2
                                 ,
                                 3
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             
                                                RHS
                                             
                                             
                                                k
                                             
                                             
                                                o
                                             
                                          
                                          /
                                          (
                                          
                                             
                                                a
                                             
                                             
                                                1
                                             
                                          
                                          +
                                          
                                             
                                                a
                                             
                                             
                                                2
                                             
                                          
                                          +
                                          
                                             
                                                a
                                             
                                             
                                                3
                                             
                                          
                                          )
                                       
                                    
                                 
                                 
                                 and
                                 
                                 
                                    
                                       m
                                    
                                    
                                       k
                                    
                                    
                                       ′
                                    
                                 
                                 (
                                 1
                                 ,
                                 2
                                 ,
                                 3
                                 )
                                 =
                                 Max
                                 (
                                 
                                    
                                       m
                                    
                                    
                                       k
                                    
                                 
                                 (
                                 1
                                 ,
                                 2
                                 ,
                                 3
                                 )
                                 ,
                                 ⌈
                                 m
                                 
                                    
                                       0
                                    
                                    
                                       k
                                    
                                 
                                 /
                                 3
                                 ⌉
                                 )
                              
                           
                        From this, the general form for m
                        
                           k
                        (1,…,
                        r) and 
                           
                              
                                 
                                    m
                                 
                                 
                                    k
                                 
                                 
                                    ′
                                 
                              
                              (
                              1
                              ,
                              …
                              ,
                              r
                              )
                           
                         is apparent. Note that the 
                           
                              
                                 
                                    m
                                 
                                 
                                    k
                                 
                                 
                                    ′
                                 
                              
                              (
                              •
                              )
                           
                         values select the max of two terms instead of the min of two terms as done in defining the 
                           
                              
                                 
                                    n
                                 
                                 
                                    k
                                 
                                 
                                    ′
                                 
                              
                              (
                              •
                              )
                           
                         values.

This minimization goal of the Destructive Phase implies that the 
                           
                              
                                 
                                    QProduct
                                 
                                 
                                    k
                                 
                                 
                                    o
                                 
                              
                           
                         and 
                           
                              
                                 
                                    QRatio
                                 
                                 
                                    k
                                 
                                 
                                    o
                                 
                              
                           
                         values should be sequenced from smallest to largest to obtain a “best to worst” ordering, exactly the opposite from the QProduct
                           k
                         and QRatio
                           k
                         values. Accounting for this difference, the Graduated-Probe Strategy has the same description for the destructive case as for the constructive case. Thus similarly we will refer to the Combination Evaluation Method and the Choice Rule for Selecting j
                        ∗ as if they are unchanged, understanding that we are referring to 
                           
                              
                                 
                                    QProduct
                                 
                                 
                                    k
                                 
                                 
                                    o
                                 
                              
                           
                         and 
                           
                              
                                 
                                    QRatio
                                 
                                 
                                    k
                                 
                                 
                                    o
                                 
                              
                           
                         values in place of QProduct
                           k
                         and QRatio
                           k
                         values, and prefer smaller values to larger ones.

There is one final important difference to note concerning the organization of a Destructive Method. Each knapsack k is evaluated independently of the others during a Destructive Phase, and the sequence in which the knapsacks are considered is immaterial. Thus, for example, the decisions made will not change if each knapsack k is examined in succession (in any order) and the method focuses just on this knapsack to set selected variables 
                           
                              
                                 
                                    x
                                 
                                 
                                    
                                       
                                          j
                                       
                                       
                                          ∗
                                       
                                    
                                 
                              
                              =
                              0
                           
                         for j
                        ∗
                        ∈
                        J
                        
                           k
                         until satisfying RHS
                           k
                        
                        ⩾0, before examining the next knapsack. However, the interjection of improving moves at any point may modify this outcome.

The Destructive Greedy method thus operates as follows, where we note that N1 and the sets J
                        
                           k
                        , k
                        ∈
                        K are inherited from the current phase of search, along with the implicit assignments x
                        
                           j
                        
                        =1 for all j
                        ∈
                        N1 and x
                        
                           ik
                        
                        =1 for all j
                        ∈
                        J
                        
                           k
                        , k
                        ∈
                        K. The values RHS
                           k
                         are likewise inherited, and as stipulated we understand 
                           
                              
                                 
                                    RHS
                                 
                                 
                                    k
                                 
                                 
                                    o
                                 
                              
                              =
                              -
                              
                                 
                                    RHS
                                 
                                 
                                    k
                                 
                              
                           
                        .
                           
                              
                                 
                                 
                                    
                                       
                                          Destructive Greedy (QMK)
                                       
                                    
                                    
                                       
                                          
                                          Initialize:
                                    
                                    
                                       
                                          
                                          
                                             
                                                ActiveK
                                                =
                                                
                                                   
                                                      
                                                         k
                                                         :
                                                         
                                                            
                                                               RHS
                                                            
                                                            
                                                               k
                                                            
                                                            
                                                               o
                                                            
                                                         
                                                         >
                                                         0
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          While ActiveK≠∅
                                    
                                    
                                       
                                          Select any knapsack k
                                          ∗ in ActiveK
                                    
                                    
                                       
                                          Apply Combination Evaluation Method to the knapsack k
                                          ∗
                                       
                                    
                                    
                                       
                                          Apply Choice Rule for Selecting 
                                          j
                                          ∗ to the knapsack k
                                          ∗
                                       
                                    
                                    
                                       
                                          
                                          
                                             
                                                
                                                   
                                                      x
                                                   
                                                   
                                                      
                                                         
                                                            j
                                                         
                                                         
                                                            ∗
                                                         
                                                      
                                                   
                                                
                                                =
                                                0
                                                
                                                   
                                                      
                                                         
                                                            
                                                               x
                                                            
                                                            
                                                               
                                                                  
                                                                     j
                                                                  
                                                                  
                                                                     ∗
                                                                  
                                                               
                                                               k
                                                            
                                                         
                                                         =
                                                         0
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                          N1=
                                          N1−{j
                                          ∗}
                                    
                                    
                                       
                                          
                                          
                                             
                                                
                                                   
                                                      J
                                                   
                                                   
                                                      
                                                         
                                                            k
                                                         
                                                         
                                                            ∗
                                                         
                                                      
                                                   
                                                
                                                =
                                                
                                                   
                                                      J
                                                   
                                                   
                                                      
                                                         
                                                            k
                                                         
                                                         
                                                            ∗
                                                         
                                                      
                                                   
                                                
                                                -
                                                {
                                                
                                                   
                                                      j
                                                   
                                                   
                                                      ∗
                                                   
                                                
                                                }
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                          
                                             
                                                
                                                   
                                                      RHS
                                                   
                                                   
                                                      
                                                         
                                                            k
                                                         
                                                         
                                                            ∗
                                                         
                                                      
                                                   
                                                
                                                =
                                                
                                                   
                                                      RHS
                                                   
                                                   
                                                      
                                                         
                                                            k
                                                         
                                                         
                                                            ∗
                                                         
                                                      
                                                   
                                                
                                                +
                                                
                                                   
                                                      a
                                                   
                                                   
                                                      
                                                         
                                                            j
                                                         
                                                         
                                                            ∗
                                                         
                                                      
                                                   
                                                
                                             
                                           (hence 
                                             
                                                
                                                   
                                                      RHS
                                                   
                                                   
                                                      
                                                         
                                                            k
                                                         
                                                         
                                                            ∗
                                                         
                                                      
                                                   
                                                   
                                                      o
                                                   
                                                
                                                =
                                                
                                                   
                                                      RHS
                                                   
                                                   
                                                      
                                                         
                                                            k
                                                         
                                                         
                                                            ∗
                                                         
                                                      
                                                   
                                                   
                                                      o
                                                   
                                                
                                                -
                                                
                                                   
                                                      a
                                                   
                                                   
                                                      
                                                         
                                                            j
                                                         
                                                         
                                                            ∗
                                                         
                                                      
                                                   
                                                
                                             
                                          )
                                    
                                    
                                       
                                          If 
                                             
                                                
                                                   
                                                      RHS
                                                   
                                                   
                                                      
                                                         
                                                            k
                                                         
                                                         
                                                            ∗
                                                         
                                                      
                                                   
                                                
                                                ⩾
                                                0
                                             
                                           then ActiveK=ActiveK−{k
                                          ∗}
                                    
                                    
                                       
                                          Endwhile
                                    
                                    
                                       
                                          (Upon concluding, x
                                          
                                             j
                                          
                                          =1 for j
                                          ∈
                                          N1 and x
                                          
                                             j
                                          
                                          =0 otherwise. In terms of double subscripted variables, for each k
                                          ∈
                                          K, x
                                          
                                             jk
                                          
                                          =1 for each j
                                          ∈
                                          J
                                          
                                             k
                                          ,)
                                    
                                 
                              
                           
                        
                     

As previously indicated, strategic oscillation has been applied by reference to defining critical levels based on a variety of criteria in addition to feasibility and infeasibility. Commonly, the critical level itself is manipulated in an oscillating fashion. For example, critical levels have been defined by reference to numbers of employees in employing scheduling (Glover and McMillan, 1986), numbers of platforms in telecommunications network design (Glover et al., 1992), objective function values in arc crossing minimization (Valls et al., 1996), values of p for in p-median problem (Voss, 1996a), numbers of markets in the traveling purchaser problem (Voss, 1996b), and numbers of partitioned nodes in graph partitioning (Rolland et al., 1997).

Problems where the Hover-Oscillation approach appears most relevant are those where it is natural to oscillate over an allocation of resources, as in multiple knapsack and multi-constraint knapsack problems. In the multi-constraint problems, unlike the multiple knapsack problems, the destructive phases are more nearly symmetrical to the constructive phases. However, here too a minimization perspective related to a covering approach is appropriate in the destructive phase. In general, if the original problem is formulated with a maximization objective, then destructive phases are most easily formulated in terms of a minimization objective (as opposed to the equivalent, but less intuitive, formulation in terms of maximizing the negative of the original objective).

The application of the basic ideas of the Hover-Oscillation Method in other settings opens up an interesting area for research. In particular, for problems where oscillation strategies effectively involve oscillating over a sum of variables, as in the first two oscillation methods mentioned above (oscillating over numbers of employees and over numbers of platforms), other resource considerations are likely to be present where a Hover-Oscillation approach may constitute a reinforcing form of oscillation.

In addition, the uses of surrogate constraints described in Section 7 invite a strategy where a collection of such constraints is considered as a select set of resource limitations to which a Hover-Oscillation Method can be applied. The Improvement Method in such cases will normally include reference to constraints in addition to those treated by the Hover-Oscillation approach.

@&#REFERENCES@&#

