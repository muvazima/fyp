@&#MAIN-TITLE@&#Deformable registration using patch-wise shape matching

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A robust and efficient non-rigid registration method has been developed.


                        
                        
                           
                           Large deformations are enabled by a nonlinear elastic energy.


                        
                        
                           
                           Our hierarchical optimization with successive refinement guarantees efficiency.


                        
                        
                           
                           Several examples with real-world scans are provided.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Non-rigid registration

Nonlinear shape deformation

@&#ABSTRACT@&#


               
               
                  We present a novel approach for non-rigid registration of partially overlapping surfaces acquired from a deforming object. To allow for large and general deformations our method employs a nonlinear physics-inspired deformation model, which has been designed with a particular focus on robustness and performance. We discretize the surface into a set of overlapping patches, for each of which an optimal rigid motion is found and interpolated faithfully using dual quaternion blending. Using this discretization we can formulate the two components of our objective function—a fitting and a regularization term—as a combined global shape matching problem, which can be solved through a very robust numerical approach. Interleaving the optimization with successive patch refinement results in an efficient hierarchical coarse-to-fine optimization. Compared to other approaches our as-rigid-as-possible deformation model is faster, causes less distortion, and gives more accurate fitting results.
               
            

@&#INTRODUCTION@&#

The need to compensate for deformation present on a set of captured data, or between modeled objects, is inbred to all dynamic 3D imaging and graphics applications, such as capturing, modeling, representation, recognition, morphing, and animation. In particular the 3D scanning of physical objects that undergo some kind of non-rigid motion leads to a space–time shape matching problem, which has to be solved to achieve a non-rigid alignment between partial views.

Depending on the application and the scanning system, the type of non-rigid motion the object is undergoing and the distortion caused for local and global features can vary a lot. This mainly depends on the temporal distribution of the single scans. For real-time scanners the deformation of consecutive scans is rather small and their overlap rather large. The acquired data is typically not problematic from a registration perspective. In contrast, when high-end scanners are used to acquire precise high-resolution scans for production quality models, the delay between two consecutive scans is significantly larger, leading to more deformation and less overlap between individual scans, and therefore to a more challenging registration problem.

Large-scale deformations require a more sophisticated regularization of the deformation field in order to prevent implausible deformations and to keep the surface locally rigid during the registration process (Fig. 1
                     ). Since the small strain assumption does not hold for large deformation, the regularization is typically implemented as some nonlinear physics-inspired strain measure, which is to be minimized simultaneously with the fitting error between the two scans. The resulting nonlinear minimization is challenging in terms of numerical robustness and computational performance.

In this paper we present an approach for accurate and robust deformable registration of models acquired by high-quality, high-resolution 3D scanners. Our method is able to compensate for various kinds of motion and deformation the acquired data can exhibit, which is achieved by a nonlinear, physics-inspired deformation regularization. Our method is based on a space deformation approach, such that it can process arbitrary point-sampled data and is not affected negatively by degenerate input meshes. We discretize the surface into a hierarchy of partially overlapping patches, for each of which a distinct rigid transformation is found by minimizing a global objective function that takes into account both the need for accurate alignment as well as for the regularity of the deformation field. The resulting rigid transformations are then extended to all sample points in a rigid manner using dual quaternion interpolation. As a result of this as-rigid-as-possible deformation our dynamic registration avoids unnecessary distortion and faithfully preserves geometric features. Both the fitting and regularization terms are based on a global shape matching strategy, which results in a unified objective function that can be minimized in a numerically very robust manner. Finally, our hierarchical patch discretization and correspondence refinement further improves stability and accelerates convergence. An example of our deformable registration is shown in Fig. 1.

Our approach demonstrates a favorable combination of fitting accuracy, geometric feature preservation, and computational performance, as we evaluate on several challenging datasets and compare to recent state-of-the-art techniques. As such, our approach can have many practical applications for the acquisition of objects that undergo undesired motion, such as acquisition of body parts for orthopedic applications, as well as for the analysis of deformation with respect to a reference surface for manufacturing quality control.

@&#RELATED WORK@&#

Non-rigid shape registration belongs to the wide family of shape correspondence problems [1–3], and its understanding is of fundamental importance for a variety of advanced applications in computer graphics, geometric modeling, and computer vision. In this work we concentrate on non-rigid registration of partial views, which is a fundamental problem in 3D scanning. Since all acquisition sensors can only provide a limited field of view, scanning a deforming object requires the solution of partial shape matching problems. This defines what has been called the problem of time-varying (non-rigid) registration, which has found different solutions according to the attainable acquisition frame rate for a given scanning technology (real-time scanning or non-interactive scanning). This technological distinction can also act as a classification of non-rigid registration techniques, since the amount of deformation that needs to be taken care of is typically less for scanners with a faster acquisition rate.

A first family of approaches can be associated to the advancements of real-time scanning technologies [4,5], where data acquisition is characterized by a regular and dense frame rate (in the order of dozens of frames per second). Recently developed, handy, and affordable devices from the entertainment industry are having a great impact on research in computer vision, computer graphics, and multimedia [6], allowing for 3D object modeling and scene reconstruction [7]. With respect to professional high-end scanners, real-time devices provide only limited spatial resolution and a high amount of geometric noise. For objects that do not move or deform too quickly, subsequent view overlapping is quite high and the deformation between scans is rather small, therefore allowing to assume that subsequent scans are already coarsely aligned.

This inspired the development of non-rigid variants of rigid alignment methods relying on the estimation of correspondence sets [8]. An alternative method that does not have to explicitly compute correspondences has been proposed in [9]. Under the gradual deformation hypothesis, template-free methods that guarantee global consistency of the space–time object reconstruction and prevent erroneous topology changes have been proposed in [10,11], while the template-based approach [12] has been proposed in the same perspective. Other approaches consider non-rigid alignment as a form of compensation for nonlinearities related to the acquisition device, such as optical distortion and calibration errors [13,14]. A multiview global alignment solution of these issues has been proposed in [15], while loop closure issues have been addressed in [16].

A second group of approaches, which is more similar to the problem we wish to address, aims to obtain a high-quality, precise model of a deforming object, for instance for the sake of reverse engineering or high-fidelity reproduction. The acquisition is usually done at irregular time intervals, therefore a high overlap of consecutive views cannot be assumed, nor can consecutive scans be considered coarsely aligned as in the case of real-time scanners. It is worth noting that the presence of deformation could be considered either as a kind of noise to compensate for, or, on the contrary, as useful additional information that can be attached to a static “consensus model” of the object being acquired.

In order to constrain the registration problem some approaches assume the availability of prior knowledge of either the object shape (such as template-based approaches [17–19]) or of the deformation model (e.g., assuming articulated motion [20,21]). Under general deformation assumptions, some approaches based on non-rigid ICP have been proposed [22,18]. In particular, a reference template is needed in [22], while [18] presents a reliable correspondence selection strategy based on a combination of point-to-point and point-to-plane metrics. The method proposed in [23] estimates a diffeomorphism between data that have undergone large deformations.

Other approaches successfully handle large and general deformations without the need of a priori assumptions by minimizing a global energy that takes into account both fitting error and deformation smoothness [24,25,12]. Our method is most closely related to these latter approaches, as we also employ an objective function consisting of fitting and regularization terms. However, our method differs in a few important aspects, which result in a noticeable improvement over the very successful and quite mature state-of-the-art techniques. We discuss the similarities and differences in Section 5.3, after having presented our method in detail in the following sections.

In general, when the deformation increases, the problem of automatically searching for reliable correspondences between partial views becomes more challenging. Several interesting alternatives to closest-point correspondences have been proposed, based on geometric features and geodesic distances [25], on the Heat Kernel Map [26], Möbius transformation [27], or a blending of several intrinsic maps [28]. The focus of this paper is the deformation model instead of the computation of robust correspondences. We therefore restrict to simple closest-point correspondences and use a stronger regularization to prevent distortions due to wrong correspondences at the early stage of the registration. Even larger deformations of the input scans could be handled by enhancing our method by any of the above-mentioned correspondence computations.

Our main objective is to estimate the optimal deformation capable of aligning a scan 
                        
                           S
                        
                      (the surface we want to deform) to a target model 
                        
                           M
                        
                      (the reference surface), while at the same time preserving the shape of the scan as much as possible.

Solving this problem for all the points simultaneously can quickly become an impractical task, depending on the size of 
                        
                           S
                        
                     . However, since the deformation of the object typically is a smooth function, we can safely assume that nearby points undergo similar deformations, and discretize the problem at a coarser resolution, solving the registration for a subset of evenly-spaced points, and then interpolating the deformation to the rest of the scan. Similarly to [29] we denote these points as nodes, and refer to their set with 
                        
                           N
                        
                     . Each node has a radius of influence, chosen such that the nodes’ influence regions correspond to a set of partially overlapping patches. Each node 
                        
                           n
                           ∈
                           N
                        
                      is then associated a rigid transformation, i.e., a rotation 
                        
                           
                              
                                 R
                              
                              
                                 n
                              
                           
                           ∈
                           
                              
                                 R
                              
                              
                                 3
                                 ×
                                 3
                              
                           
                        
                      and a translation 
                        
                           
                              
                                 t
                              
                              
                                 n
                              
                           
                           ∈
                           
                              
                                 R
                              
                              
                                 3
                              
                           
                        
                     . Since rotations can be represented by 3 parameters, this yields 6 degrees of freedom (DoFs) per node. During the optimization the density of the set 
                        
                           N
                        
                      will be hierarchically adapted in a coarse-to-fine manner, so that distortion on 
                        
                           S
                        
                      is progressively compensated.

The per-node rigid motions are determined by minimizing an objective function consisting of a fitting term 
                        
                           
                              
                                 E
                              
                              
                                 fit
                              
                           
                        
                     , which drives the deformation of the scan toward the model, and a regularization term 
                        
                           
                              
                                 E
                              
                              
                                 reg
                              
                           
                        
                     , which maintains a smooth and physically plausible deformation throughout the optimization.

For the 
                        fitting term
                      we resort to a set of correspondences 
                        
                           C
                           =
                           {
                           P
                           ,
                           Q
                           }
                        
                     , where the sample points 
                        
                           p
                           ∈
                           P
                           ⊂
                           S
                        
                      are selected from the scan 
                        
                           S
                        
                     , while their corresponding points 
                        
                           q
                           ∈
                           Q
                           ⊂
                           M
                        
                      are found on the target model 
                        
                           M
                        
                     . The fitting term penalizes for each node 
                        
                           n
                           ∈
                           N
                        
                      the (squared) distance of corresponding points 
                        
                           (
                           p
                           ,
                           q
                           )
                           ∈
                           
                              
                                 C
                              
                              
                                 n
                              
                           
                        
                      that are within n’s influence radius, where 
                        
                           q
                        
                      is being transformed by n’s rotation and translation:
                        
                           (1)
                           
                              
                                 
                                    E
                                 
                                 
                                    fit
                                 
                              
                              =
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       n
                                       ∈
                                       N
                                    
                                 
                              
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       (
                                       p
                                       ,
                                       q
                                       )
                                       ∈
                                       
                                          
                                             C
                                          
                                          
                                             n
                                          
                                       
                                    
                                 
                              
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      R
                                                   
                                                   
                                                      n
                                                   
                                                
                                                p
                                                +
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      n
                                                   
                                                
                                                -
                                                q
                                             
                                          
                                       
                                       
                                          2
                                       
                                    
                                 
                                 
                                    |
                                    N
                                    |
                                    ·
                                    |
                                    
                                       
                                          C
                                       
                                       
                                          n
                                       
                                    
                                    |
                                 
                              
                              .
                           
                        
                     
                  

The rigid transformations of neighboring nodes n and m are not completely independent, but will instead be similar due to correspondence points 
                        
                           (
                           p
                           ,
                           q
                           )
                        
                      located in the partial overlap of their influence regions, i.e., 
                        
                           
                              
                                 C
                              
                              
                                 n
                              
                           
                           ∩
                           
                              
                                 C
                              
                              
                                 m
                              
                           
                        
                     . Nevertheless, the 
                        regularization term
                      explicitly penalizes the difference between neighboring nodes’ transformations, as measured by the distance of points 
                        
                           p
                        
                      in their overlap region 
                        
                           
                              
                                 P
                              
                              
                                 n
                              
                           
                           ∩
                           
                              
                                 P
                              
                              
                                 m
                              
                           
                        
                      after being transformed by the rigid motions of n and m, respectively:
                        
                           (2)
                           
                              
                                 
                                    E
                                 
                                 
                                    reg
                                 
                              
                              =
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       n
                                       ∈
                                       N
                                    
                                 
                              
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       m
                                       ∈
                                       N
                                    
                                 
                              
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       p
                                       ∈
                                       
                                          
                                             P
                                          
                                          
                                             n
                                          
                                       
                                       ∩
                                       
                                          
                                             P
                                          
                                          
                                             m
                                          
                                       
                                    
                                 
                              
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      R
                                                   
                                                   
                                                      n
                                                   
                                                
                                                p
                                                +
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      n
                                                   
                                                
                                                -
                                                
                                                   
                                                      R
                                                   
                                                   
                                                      m
                                                   
                                                
                                                p
                                                -
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      m
                                                   
                                                
                                             
                                          
                                       
                                       
                                          2
                                       
                                    
                                 
                                 
                                    |
                                    N
                                    
                                       
                                          |
                                       
                                       
                                          2
                                       
                                    
                                    ·
                                    |
                                    
                                       
                                          P
                                       
                                       
                                          n
                                       
                                    
                                    ∩
                                    
                                       
                                          P
                                       
                                       
                                          m
                                       
                                    
                                    |
                                 
                              
                              .
                           
                        
                     
                  

The global energy is a weighted sum of fitting and regularization
                        
                           (3)
                           
                              
                                 
                                    E
                                 
                                 
                                    total
                                 
                              
                              =
                              
                                 
                                    w
                                 
                                 
                                    fit
                                 
                              
                              
                                 
                                    E
                                 
                                 
                                    fit
                                 
                              
                              +
                              
                                 
                                    
                                       1
                                       -
                                       
                                          
                                             w
                                          
                                          
                                             fit
                                          
                                       
                                    
                                 
                              
                              
                                 
                                    E
                                 
                                 
                                    reg
                                 
                              
                              ,
                           
                        
                     where the fitting weight 
                        
                           
                              
                                 w
                              
                              
                                 fit
                              
                           
                        
                      is increased during the optimization so that the surface is deformed in a stiff-to-smooth manner.

Our framework can be considered as a sequence of operations distributed on three nested loops (see Fig. 2
                     ), where in each loop some of the optimization features or parameters are selected and considered fixed throughout the execution of the inner loops. The three phases are outlined below, and the involved techniques are described in detail in the following section.

The 
                        setup phase
                      is responsible for adjusting the optimization parameters (Section 4.1) and for selecting the set of nodes 
                        
                           N
                        
                      and correspondence samples 
                        
                           P
                        
                      (Section 4.2). At this step we also compute the weights used for interpolating the nodes’ transformations to all the points of the scan 
                        
                           S
                        
                      (Section 4.3). The setup phase is repeated until a given number of iterations is reached.

The 
                        update phase
                      updates the target points 
                        
                           P
                        
                      for correspondences 
                        
                           C
                           =
                           (
                           P
                           ,
                           Q
                           )
                        
                      according to the current deformation estimate of 
                        
                           S
                        
                      (Section 4.4). It also performs a classification of the nodes (Section 4.5) based on the updated correspondences, which allows to speed up the minimization and avoid potential instabilities. The update phase is terminated when the correspondences 
                        
                           C
                        
                      do not improve any further.

In the 
                        minimization phase
                      the energy (3) is solved while keeping the set of parameters, nodes, and correspondences fixed (Section 4.6). Similarly in spirit to [30], we can interpret all the nodes as rigid objects, which are coupled to the model 
                        
                           M
                        
                      through (1) and to each other through (2). In this view, the minimization of (3) is a global shape matching problem, which can be solved robustly as shown in [31,32].

The proposed approach relies on three main parameters. Besides the first one, the other two require an initial and final value each, so that at a given iteration the current values for these parameters are linearly interpolated.

The first parameter is the 
                           number of iterations
                         for which the setup phase, i.e., the outer loop, should be repeated. This value may require tuning according to the complexity of the deformation that has to be handled: more demanding cases may need a greater number of iterations, so that the scan slowly adapts to the target model.

The 
                           node spacing
                         represents the minimum Euclidean distance between two nodes (and indirectly defines the spacing of correspondence samples, Section 4.2). While its initial value should be tuned according to the metric size of the processed scan, its final value controls the smallest deformation that can be handled. During the optimization this value decreases, so that the number of nodes increases. This way the optimization initially takes care of large, low-frequency deformations, while handling small, high-frequency ones at the end, in a coarse-to-fine manner.

The 
                           fitting weight
                         
                        
                           
                              
                                 
                                    w
                                 
                                 
                                    fit
                                 
                              
                           
                         represents the weight associated to the fitting term 
                           
                              
                                 
                                    E
                                 
                                 
                                    fit
                                 
                              
                           
                         in the objective function (3). Similar to other approaches, this parameter is monotonically increased during the optimization (typically from 0.1 to 0.9), causing the surface to remain stiff during the initial optimization stages, while getting softer toward the end, in a stiff-to-smooth fashion.

At every iteration of the setup phase we select a progressively denser set 
                           
                              N
                           
                         of regularly-spaced nodes on the scan 
                           
                              S
                           
                        , controlled by the node spacing parameter, which can be implemented efficiently through simple farthest point sampling. The node spacing also controls the sampling of the correspondence points 
                           
                              P
                           
                        . A key difference of our method to other approaches, such as [25,12], is that we chose the density of correspondence samples as a multiple of the node density, which leads to a more accurate estimation of the deformation field (see Fig. 3
                        ). In particular, in all our examples we chose the spacing of correspondence samples to be 
                           
                              1
                              /
                              4
                           
                         of the node spacing. An example of how the sets 
                           
                              N
                           
                         and 
                           
                              P
                           
                         are distributed on the scan 
                           
                              S
                           
                         is shown in Fig. 4
                        .

The deformation of points 
                           
                              p
                              ∈
                              S
                           
                         is computed by interpolating the nodes’ rigid transformations. The interpolation weights can be computed by an arbitrary smooth weighting function with local support radius r. In our case a simple inverse distance weighting turned out to be sufficient, where the weight 
                           
                              
                                 
                                    w
                                 
                                 
                                    n
                                 
                              
                              (
                              p
                              )
                           
                         of point 
                           
                              p
                           
                         with respect to node n is computed as
                           
                              
                                 
                                    
                                       w
                                    
                                    
                                       n
                                    
                                 
                                 (
                                 p
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             1
                                             -
                                             
                                                
                                                   
                                                      
                                                         
                                                            n
                                                            -
                                                            p
                                                         
                                                      
                                                   
                                                
                                                
                                                   r
                                                
                                             
                                          
                                       
                                    
                                    
                                       +
                                    
                                 
                                 .
                              
                           
                        Here, r is the influence radius of node n, typically chosen as 1.25 times the node spacing, and 
                           
                              
                                 
                                    (
                                    ·
                                    )
                                 
                                 
                                    +
                                 
                              
                           
                         clamps negative values to zero. The weights are normalized such that 
                           
                              
                                 
                                    ∑
                                 
                                 
                                    n
                                    ∈
                                    N
                                 
                              
                              
                              
                                 
                                    w
                                 
                                 
                                    n
                                 
                              
                              (
                              p
                              )
                              =
                              1
                           
                        .

Once the blending weights have been computed, we can interpolate the transformations of the nodes to all other points of the scan. The approaches of Huang et al. [25] and Li et al. [24,12] employ linear blend skinning [33] for this task, which is known to produce artifacts when interpolating strongly different transformations. In contrast, we employ dual quaternion skinning [34], which produces a more accurate, artifact-free interpolation of rigid transformations by inherently preserving the orthogonality of rotation matrices. Due to the more complex formulation of the dual-quaternion interpolation, we cannot integrate the interpolation of node transformations into the minimization of correspondence errors, as has been done in the embedded deformation approach [24,12] (for simple linear interpolation of node transformations). Instead, our dual-quaternion interpolation is performed after node transformations have been computed, similar to [25].

Every time new correspondence samples 
                           
                              P
                              ⊂
                              S
                           
                         have been selected (Section 4.2) or have been deformed during the registration process (Section 4.3), we have to update their corresponding points 
                           
                              Q
                           
                         on the target model 
                           
                              M
                           
                        .

To this end, we find for each sample 
                           
                              p
                              ∈
                              P
                           
                         its closest point 
                           
                              q
                              ∈
                              M
                           
                        . To avoid erroneous correspondences, we discard any point couple 
                           
                              (
                              p
                              ,
                              q
                              )
                           
                         if their Euclidean distance or the angle between their normals is above a certain threshold [35]. These thresholds are linearly interpolated from rather large initial values to more stringent final values, such that towards the end of the optimization, when the surfaces are very close to each other, outliers can be effectively rejected. While the thresholds on the distance of corresponding points depends on the model dimensions and the amount of noise and deformation present, the normal deviation thresholds are 
                           
                              60
                              °
                           
                         in the beginning and 
                           
                              30
                              °
                           
                         at the end for all our examples. The updated correspondence set then becomes 
                           
                              C
                              =
                              (
                              P
                              ,
                              Q
                              )
                           
                        .

To guarantee a numerically robust computation of each node’s rigid transformation by minimizing the objective function (3), each node has to be properly constrained. This can happen either through sufficient valid constraints for the fitting term (1), or through a sufficient overlap with neighboring (constrained) nodes in the regularization term (2).

Nodes that do not have a sufficient number of valid correspondences are excluded from the fitting term. If such nodes still have a sufficient overlap with other nodes, they can be used in the regularization term. Otherwise, they have to be completely discarded from the optimization. Since in our approach the densities of nodes 
                           
                              N
                           
                         and correspondence samples 
                           
                              P
                           
                         are coupled (Section 4.2), we can simply use the fixed thresholds 
                           
                              |
                              
                                 
                                    C
                                 
                                 
                                    n
                                 
                              
                              |
                              >
                              20
                           
                         and 
                           
                              |
                              
                                 
                                    P
                                 
                                 
                                    n
                                 
                              
                              ∩
                              
                                 
                                    P
                                 
                                 
                                    m
                                 
                              
                              |
                              >
                              20
                           
                         for these tests.

The node classification starts by collecting all nodes with sufficient correspondences (yellow in Fig. 4). From each of those a breadth first search is started, proceeding to all neighboring nodes with sufficient overlap. At the end of the process, all unmarked nodes are considered disconnected and are temporarily excluded from the current optimization step (cyan in Fig. 4). We found this node classification to be crucial for avoiding numerical instabilities, in particular when working with raw scans that did not undergo any sort of preprocessing and therefore might contain outliers as well as ill-constrained (or un-constrained) regions.

In the numerical minimization of (3), we can consider each node as an individual rigid object (having 6 DoF for rotation and translation). These rigid parts are coupled to each other through the regularization term (2), which is closely related to the PriMo approach [32,30], where it has proven to be a physically plausible deformation model. In contrast to the interactive PriMo application, in our approach the deformation is driven by the correspondences, i.e., by the fitting term (1) that couples the nodes of the scan to the target model. Our optimization can be solved robustly and efficiently by the Gauss–Newton approach described in [31,32]. In each Gauss–Newton iteration, rigid transformation updates are linearized as affine transformations (helical screw motions), and the optimal updates are found by solving a sparse 
                        
                           
                              6
                              |
                              N
                              |
                              ×
                              6
                              |
                              N
                              |
                           
                         linear system. The resulting screw motions are projected back to the rigid motion manifold and used to update the current node transformations. This kind of nonlinear optimization was shown to be very robust and reasonably efficient in [32,30], and worked reliably in our application.

@&#RESULTS AND DISCUSSION@&#

The described approach has been implemented in C++ and tested on a 2.4GHz Intel Dual Core laptop with 4GB of RAM. The code can exploit multi-core processing. Several datasets were considered, each composed by a pair of surfaces, previously referred to as the scan 
                        
                           S
                        
                      and the target model 
                        
                           M
                        
                     , where the former presents both some degree of overlap and deformation with respect to the latter. The Sole (a shoe sole subject to elastic bending), Mould (a foam rubber mould subject to external deforming forces), and Pillow datasets (a pillow taken in two different creased states) were acquired with a high-resolution, structured-light professional scanner, while the Torso dataset (kindly provided by the authors of [24]) was obtained through the fast scanner described in [5]. Both the Sole and Mould datasets are characterized by a smooth, low-frequency warping, however the Sole is a problematic dataset for any ICP-based technique (such as ours) due to the presence of repeated patterns, which causes many local minima in the objective function and increases the risk of obtaining a suboptimal alignment. In addition we tested our approach on some face scans, which represent more noisy and partial surfaces with complex deformations.

For all the considered datasets, our approach succeeded in estimating a physically plausible deformation, as testified by the alignment shown in Table 1
                         and Fig. 5
                        . The final average distance between the scans is consistent among all datasets with the exception of the Torso model, where a greater final distance is justified by the more noisy surface compared to the other high-resolution scans. Thanks to our physically plausible regularization term in the error functional, the extension of the deformation field to the rest of the surface leads to a plausible warping, even for areas where no overlap with the target surface exists.

This is shown for the Sole dataset, where the wedge heel is correctly bent according to the rest of the data, as well as for the Torso dataset, where the upper part of the face has been warped correctly, even though it was completely missing on the target model.

More examples with noisy surfaces, incomplete data, and partial overlap are shown Fig. 6
                        , where a scan of a neutral face is registered to scans of different facial expressions. As the corresponding statistics in Table 2
                         demonstrate, our method succeeds to accurately register the different scans in reasonable time. For the example “neutral→smile” a higher resolution could be used to reduce the deviation in the mouth area, however, the other regions are sufficiently accurate. Hence, this problem could well be solved using adaptive (instead of uniform) refinement, which we leave for future work. Nevertheless, these examples demonstrate the capability of our method for building a blend shape facial rig by matching a neutral scan (or a template facial model) to recorded facial expressions.

We now present a breakdown of the involved computations of our approach with respect to the conceptual operations described in the pipeline presented in Fig. 2. While the exact time balance may vary depending on the dataset characteristics and node density, the following general trend can be observed. The most time-consuming part involves the solution of the minimization problem, which accounts for 40% of the total time, followed by the correspondence update phase, which requires 25% of the total time. Next is the application of the deformation field to the entire surface (15%), while the remaining 20% of the time is distributed among the other operations (parameter selection, selection of nodes and samples, weight computation, node classification, I/O operations).

In order to further assess our approach, we compare to the two approaches most similar to ours, namely the ones of Huang et al. [25] and Li et al. [12] (which improves upon [24]). Since our approach shares certain details with [25,12], but differs in other crucial aspects, we start with a theoretical discussion of the similarities and differences between the methods, before providing an experimental comparison.


                        Methodological comparison. The approach of Huang et al. [25] selects uniformly distributed nodes on the deforming scan, and infers their deformation from a set of robust correspondences computed by taking into account both geodesic distance and feature signature consistency. During the optimization, neighboring nodes undergoing the same rigid transformation are clustered and are assigned a common transformation. However, since these clusters are only allowed to grow, the final phase of the optimization may be hampered since sub-cluster alignment accuracy would be required to improve the fitting quality. Their error functional consists of a fitting and a regularization term, both weighted with constant factors.

Similarly to [25] we compute a hierarchy of nodes, but instead of a fine-to-coarse node clustering, our node selection strategy actually is a coarse-to-fine optimization. This is particularly useful toward the end of the processing, when optimization of the deformation field at node level is necessary to reach complete convergence. Moreover, our adaptive balancing between fitting and regularization is more flexible and further contributes to reaching more accurate results.

The method of Li et al. [12] (which improves upon [24]) also employs an adaptive weighting for fitting and regularization in order to reach a higher fitting accuracy. Their regularization is based on the embedded deformation approach [29], which also discretizes the scan by a set of nodes that build the so-called deformation graph. Each node has an associated affine transformation, which is kept close to a rigid motion by a special term in their energy formulation. As a consequence, their method uses 12 DoFs per node (affine motion), whereas we use 6 DoFs per node only (rigid motion). This consequently reduces memory consumption and computational costs for our numerical optimization. In [12] the resulting node transformations are then linearly interpolated to all points of the scan, which for highly differing matrices might lead to the well-known artifacts of linear blend skinning (as described in [34]). In contrast, our use of dual quaternion skinning should help to avoid these artifacts and reduce distortion during the registration process.

In contrast to [25], however, Li et al.perform an adaptive refinement of the deformation graph in region of highly differing local transformation, which somewhat reduces the linear interpolation problems and allows for more localized updates of the deformation field. In comparison, our hierarchical but uniform discretization is less flexible, and an adaptive refinement is a promising subject of future work.

Our method differs from both approaches by selecting a greater number of correspondences compared to the node density, which leads to superior alignment accuracy, as demonstrated in Section 4.2 and Fig. 3.


                        Experimental comparison. The authors of both approaches kindly agreed to apply their techniques to our datasets, and provided us with the deformation results as well as with the maximum number of nodes employed and the computational performance. In order to provide a fair experimental comparison we decided to adapt (downgrade) our algorithm to the approach that obtained the best results between the two. In particular, we decreased the maximum number of nodes employed by our algorithm to roughly match the number of nodes of the best algorithm. In addition, since both other methods do not exploit multi-core processing, we deactivated this feature in our algorithm. In the following, we indicate this adapted configuration with the symbol (
                           
                              D
                           
                        ) to distinguish its results from the ones obtained by employing our optimal working configuration, already presented in Table 1 and Fig. 5. The results of the comparative assessment are organized in Table 3
                         and Fig. 7
                        .

Non-rigid registration is always a compromise between fitting accuracy and geometric distortion. Zero fitting error can be achieved by simply projecting the scan onto the target model, but this would cause high distortion. Performing only a rigid registration avoids any distortion, but leads to a high fitting error. To allow for a more meaningful comparison we therefore also report the isometric distortion in Table 3. We measure distortion (in a simplified manner) as the squared relative difference of edge length between the original scan (length 
                           
                              
                                 
                                    L
                                 
                                 
                                    e
                                 
                              
                           
                        ) and the deformed scan (length 
                           
                              
                                 
                                    l
                                 
                                 
                                    e
                                 
                              
                           
                        ), averaged over all edges 
                           
                              e
                              ∈
                              E
                           
                         of the scan:
                           
                              
                                 
                                    
                                       1
                                    
                                    
                                       |
                                       E
                                       |
                                    
                                 
                                 
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             e
                                             ∈
                                             E
                                          
                                       
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               l
                                                            
                                                            
                                                               e
                                                            
                                                         
                                                         -
                                                         
                                                            
                                                               L
                                                            
                                                            
                                                               e
                                                            
                                                         
                                                      
                                                   
                                                
                                                
                                                   2
                                                
                                             
                                          
                                          
                                             
                                                
                                                   L
                                                
                                                
                                                   e
                                                
                                                
                                                   2
                                                
                                             
                                          
                                       
                                    
                                 
                                 .
                              
                           
                        
                     

This measure does (intentionally) not penalize bending, but is sensitive to stretching and shearing. Obviously a certain amount of distortion is required to match the scan to the target model. However, for two methods reaching a similar fitting accuracy, the one causing fewer distortion should be the preferred solution.

From a visual inspection of the results (Fig. 7), as well as the alignment error and geometric distortion reported in Table 3, we conclude that the approach of Huang et al. [25] yields the least accurate results for the given datasets. These results seem to confirm the considerations with regard to the fine-to-coarse node clustering: Although it can grant satisfying results for objects undergoing homogeneous, smooth deformations, it can be a limiting factor when the deformation becomes more heterogeneous, or when small portions of data need to be accurately registered. While its computational performance greatly outperforms the other approaches, the alignment performance proved to be unsatisfactory for the given datasets, regardless of the number of nodes employed (as testified by the Torso and Pillow datasets, for which said technique employs a greater and a comparable number of nodes as the other approaches).

We compared our approach (
                           
                              D
                           
                        ) to the results obtained by Li et al. [12], employing a similar number of nodes as the ones declared by their technique. While for the Sole and Mould datasets our approach seemingly reaches better visual results, in the Torso case Li’s method achieves a better deformation. For the Pillow dataset Li’s method fails to reach any plausible result, while our approach achieves a meaningful alignment. In general, our alignment distances are similar to those of Li et al., with the exception of the Pillow dataset, which should not be considered because of the alignment failure. In terms of distortion our method performs slightly but consistently better, which might be due to our use of exact per-node rotations and dual quaternion interpolation. With respect to computational performance, our technique is about twice as fast as Li’s method for all the datasets with the exception of the Torso, for which it is just slightly faster. We assume that this is because the Torso dataset is a smaller one, requiring the smallest number of nodes. For more complex deformations the difference between our 6 DoFs to their 12 DoFs per node seem to have a stronger influence.

In conclusion our method compares favorably to the methods of Huang et al. [25] and Li et al. [12], in particular when it comes to the precise registration of high-resolution range scans.

The proposed approach improves upon closely related techniques in terms of fitting accuracy, geometric distortion, and computational performance (for bigger datasets). However, there are also some limitations. One major limitation is related to the fact that the method cannot handle topological changes, such as an opening mouth. This is mostly due to the adopted formulation for the smoothing energy that constraints neighbor nodes to deform similarly, as well as due to the interpolation policy adopted. A possible way to compensate for this would be to include the interpolation weights in the error functional, modifying their computation so that they can convey a topology-aware neighborhood information.

Another issue of the current approach is related to its scalability. As Fig. 8
                         testifies, our approach could achieve an even better alignment of the Pillow dataset, but the increased number of nodes noticeably increase its computational cost. A possible solution would be a more efficient error-driven node placement or refinement: Through the estimate of an average error associated to each node, one could locate which areas of the surface need a greater node density, and only refine the discretization there, rather than imposing a uniform node density on the entire scan. This would reduce the overall number of nodes, therefore speeding up the computational performance.

Finally, we would like to extend our approach in such a way as to treat multiple-view deformable registration.

@&#CONCLUSIONS@&#

In this work we presented an improved solution for the non-rigid registration of partial views which is suitable for deforming object acquisition and modeling, especially for high-resolution surfaces acquired through professional 3D scanners. The method demonstrated its capability of suitably handling different degrees of deformation for all the considered challenging datasets. The selection of a denser set of correspondences with respect to the number of node patches defined on the surface granted our approach an improved accuracy with respect to state-of-the-art techniques for high-resolution datasets, while the adoption of a fast and robust optimization scheme, as well as a lightweight correspondence selection procedure granted satisfactory computational performance. With the complex of the described features, our technique is capable to provide physically-plausible, as-rigid-as-possible deformations with accurate and effective detail-aware registration properties which are valuable for many demanding and emerging applications.

@&#REFERENCES@&#

