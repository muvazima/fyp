@&#MAIN-TITLE@&#On a family of run length limited, block decodable codes to prevent payload-induced jitter in Controller Area Networks

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A family of codes to prevent jitter in Controller Area Networks is proposed.


                        
                        
                           
                           It was proved that the codes are optimal under typical embedded system constraints.


                        
                        
                           
                           A software implementation of the encoder and decoder modules has been carried out.


                        
                        
                           
                           The implementation is portable, compact, fast, and fully deterministic.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Industrial control

Real-time distributed systems

Controller Area Network

@&#ABSTRACT@&#


               
               
                  Controller Area Networks (CAN) adopt bit stuffing at the physical layer, thus introducing a frame length variability that may adversely affect sensing and actuation jitter. One way to mitigate this issue is to encode the payload by means of a suitable run length limited code, before transmission.
                  In this paper, a family of these codes is defined and thoroughly analyzed from the theoretical point of view, showing its optimality within a set of performance and footprint-related constraints typical of contemporary embedded systems. Experimental results confirm that the proposed technique is amenable to an efficient and deterministic software-based implementation.
               
            

@&#INTRODUCTION@&#

Controller Area Network (CAN) [1] is a very popular digital communication protocol that was initially conceived for in-vehicle use. Currently, the most part of the existing cars includes indeed one or more of these networks on board. Besides the automotive field, CAN has been widely used in industrial scenarios [2] and networked embedded control systems as well [3].

At the physical layer, CAN relies on a Non Return to Zero (NRZ) encoding with bit stuffing. Although bit stuffing (BS) is quite simple and efficient, it has one drawback. In fact, the exact size of the frames that are sent over the bus depends on the values they carry, which may lead to jitters on actuation and sensing. In [4] an encoding technique was described, namely 8B9B, that completely prevents stuff bits in the data field of CAN frames. A codec was introduced as well, which was characterized by a very small footprint and also achieved really short (and deterministic) execution times. A comparison of the performance of this encoding scheme with other previous solutions available in the literature was carried out in [5], where it was shown that 8B9B is able to ensure higher determinism than plain CAN at the expense of a slightly lower encoding efficiency.

In this paper the family of encoding schemes to which 8B9B belongs has been analyzed from the theoretical point of view, and a new enhanced scheme, called Variable-length, High-performance Code for CAN (VHCC), has been introduced. Unlike [4], where the codebook used for the lookup tables in the codec was found empirically, a formal approach is adopted here that permitted us to prove that our solution actually provides the highest encoding efficiency for this kind of approaches. Moreover, an additional mechanism has been defined that, combined with the new codebook, permits to pack additional sub-byte information in the encoded data field of CAN frames.

The paper is structured as follows: in Section 2 the bit stuffing mechanism of CAN is briefly recalled and compared with related techniques for other kinds of link. Section 3 defines the framework that permits creating the new codebook by induction, whereas Section 4 provides more detailed information on how both the codebook generator and the encoding and decoding software modules have been implemented in practice. Last, Section 5 contains experimental results about codec footprint and performance on a contemporary microcontroller, Section 6 compares them with related works, and Section 7 draws some conclusions.

Bit stuffing in CAN is a line code with the main goal of ensuring that a sufficient number of edges are found in the bit stream sent over the bus, so that the Digital Phase Locked Loop (DPLL) in receivers can recover the transmitter clock correctly. Basically, every time 5 bits at the same value have been transmitted in a row, an additional stuff bit at the opposite level is inserted by the transmitting node, hence creating an edge on which DPLLs can synchronize. Stuff bits are removed by receiver nodes to get back the original frame.

Moreover, a well-defined code violation (namely, transmitting 6 consecutive bits at the same value) constitutes an error flag, which is used to signal bus errors and globalize them. As depicted in Fig. 1
                     , BS applies to the part of the frame from the Start Of Frame bit (SOF) to the Cyclic Redundancy Check field (CRC) included. The following part is of fixed format and not stuffed. Similar encoding schemes have been adopted for other kinds of communication links, too, such as High-level Data Link Control (HDLC) [6] and the Universal Serial Bus (USB) [7], up to version 2.0.

Because of BS, the exact duration of the transmission of any given frame depends not only on the size of the payload but also on its content. As a consequence, reception times for messages in the same message stream may suffer from unwanted jitters that, in CAN, may be as high as 24 bit times (in theory). This also means that the timing accuracy of actuation and sampling on the networked devices in the system is negatively affected to the same extent. The jitter due to BS is much lower than the uncertainty in transmission times due to the CAN arbitration technique. This explains why this problem is typically overlooked in several contexts, such as the automotive domain. There are, however, other application fields where the ability to carry out frame exchanges with accurate timings is of practical relevance. Possible examples are distributed control systems in factory automation that require precise synchronization and accurate measuring instruments.

The problem above is well known: It has been highlighted several times in the literature [8–13] and several remedies have been consequently proposed. Among them, the 8B9B approach [4] has been recently introduced. Basically, 8B9B is a block code that applies to unmodified conventional CAN controllers and prevents the insertion of stuff bits in the data field of CAN frames, by avoiding the occurrence of sequences of 5 or more bits at the same level (denoted primer sequences) in that part of the frame.

The related problem of constructing Run Length Limited (RLL) bit sequences to encode information has been studied extensively in the context of data storage systems [14]. However, the design goals of RLL codes for data storage and codes like 8B9B are quite different, and hence, they lead to dissimilar encoding mechanisms.

First of all, in the data storage context, the presence of an additional, differentiating decoding stage–often taking place at the level of the physical read/write heads–is implicitly assumed, leading to the use of the Non Return To Zero Inverse (NRZI) code format. Under this hypothesis, the construction of a RLL sequence is accomplished starting from another kind of constrained sequence, called (dk) sequence, and then integrating it.

By definition, a (dk) sequence is a bit sequence in which there are at least d bits at zero between two bits at one and that contains no more than k consecutive bits at zero. It can easily be shown that, after integration, the output RLL sequence will have no less than d
                        +1 and no more than k
                        +1 consecutive bits at the same value. Because of inherent limits of the recording medium, the vast majority of data storage codes have d
                        >0, a constraint that does not apply to CAN.

Moreover, communication channels like CAN do not have any integrating/differentiating stage on their own, and therefore, they use the NRZ code format instead of NRZI. The explicit addition of such a stage, albeit possible, would be a source of additional overhead–especially in software implementation–because it is a bit-by-bit operation to be carried out on the data stream. For the same reason, other properties of interest for data storage codes, such as the absence of a Direct Current (DC) component in the encoded bit stream and embedded error-detection capabilities, are not as important for CAN.

Secondly, most data storage codes are designed for hardware-based encoding and decoding. Therefore, they often trade off additional encoding and decoding complexity for optimal information rate plus the additional properties outlined above. By contrast, the focus of this paper is on an efficient software-based implementation. Because of this, code design was based on the hypotheses of:
                           
                              •
                              
                                 memoryless, efficient block encoding and decoding, based on table lookup;


                                 direct transmission of codewords through the channel, without intermediate integrating/differentiating elements (by using conventional CAN controllers);

possibility of nesting smaller codebooks into larger ones, to encode and decode blocks of varying length with the same tables (in order not to increase codec footprint).

The basic principle behind 8B9B is quite simple. Every byte in the original payload of the CAN message is translated separately to a codeword expressed as a 9-bit pattern. The codebook was obtained in [4] by means of a simple C program, and satisfies the basic property that primer sequences can never appear in the encoded data field, irrespective of the original payload.

Two mechanisms were also introduced in 8B9B, that corresponds to the break bit (BB) and the padding field (PAD). BB is located in the very first position of the data field, and is set at the opposite value than the least significant bit of the DLC. It prevents the occurrence of a primer sequence on the boundary between the DLC and data fields. The padding, instead, is just a particular filling of the unused portion of the last byte in the encoded data field that, again, is aimed at preventing primer sequences. The bottom part of Fig. 1 shows the usage 8B9B makes of the data field. It is worth noting that 8B9B, as well as any other approach defined so far, is unable to prevent stuff bits in the CRC. Nevertheless, it can be easily shown that no more than 4 residual stuff bits can be added to this field.

Although the basic 8B9B mechanism is simple enough to allow for very fast implementations, and intuitively it is able to achieve very good encoding efficiency, there is not any warranty that it is actually the best possible choice. In the following, this problem has been modeled formally using an inductive approach and solved by means of a Prolog 
                        [15] program. Results prove that, in practical cases, our solution is actually the optimal one. Moreover, our analysis has also led to a new version of the codebook, which satisfies an interesting nesting property that has been used to further improve the codec.

Then, small changes have been brought to the original encoding scheme – and to the codec as well – which permit the amount of information that can be embedded in the encoded frames to be maximized (payload granularity is now one bit instead of one byte). Overall, it is possible to state that the new version of 8B9B, which we have called VHCC, is the best solution available to cope with BS jitters in CAN, among those able to prevent stuff bits in the data field completely.

Let us denote with the calligraphic letter 
                           U
                        
                        
                           s
                         the universe of binary strings of length s and with the corresponding uppercase letter Us
                         the number of elements of 
                           U
                        
                        
                           s
                        , that is, let Us
                        
                        =|
                           U
                        
                        
                           s
                        |. An analogous notation will be used for the other sets defined throughout this section. Obviously, it is:
                           
                              (1)
                              
                                 
                                    
                                       U
                                       s
                                    
                                    =
                                    
                                       2
                                       s
                                    
                                    .
                                 
                              
                           
                        
                     

Our goal is to build a set of codebooks 
                           G
                        
                        
                           s,l,b,t
                         for integer values s
                        ≥2, l
                        ≥1, b
                        ≥1, and t
                        ≥1, so that each codebook satisfies the following properties:
                           
                              •
                              the elements of 
                                    G
                                 
                                 
                                    s,l,b,t
                                  are binary strings of length s, that is, 
                                    G
                                 
                                 
                                    s,l,b,t
                                 
                                 ⊆
                                 
                                    U
                                 
                                 
                                    s
                                 ;

all elements g
                                 ∈
                                 
                                    G
                                 
                                 
                                    s,l,b,t
                                  have at most l leading bits at the same value, at most b consecutive inner bits at the same value, and at most t trailing bits at the same value;

the elements of 
                                    G
                                 
                                 
                                    s,l,b,t
                                  contain at least one bit value transition, that is,
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            0
                                                            …
                                                            
                                                               0
                                                               2
                                                            
                                                         
                                                         ⏞
                                                      
                                                      
                                                         s
                                                         
                                                         bits
                                                      
                                                   
                                                   ∉
                                                   
                                                      G
                                                      
                                                         s
                                                         ,
                                                         l
                                                         ,
                                                         b
                                                         ,
                                                         t
                                                      
                                                   
                                                   ,
                                                
                                                
                                                   
                                                      
                                                         
                                                            1
                                                            …
                                                            
                                                               1
                                                               2
                                                            
                                                         
                                                         ⏞
                                                      
                                                      
                                                         s
                                                         
                                                         bits
                                                      
                                                   
                                                   ∉
                                                   
                                                      G
                                                      
                                                         s
                                                         ,
                                                         l
                                                         ,
                                                         b
                                                         ,
                                                         t
                                                      
                                                   
                                                   ,
                                                
                                             
                                          
                                       
                                    
                                 this condition is included in the previous one when s
                                 >min(l, t);


                                 
                                    G
                                 
                                 
                                    s,l,b,t
                                  contains enough codewords to uniquely encode a binary string of length s
                                 −1, that is, denoting with G
                                 
                                    s,l,b,t
                                  the number of elements of 
                                    G
                                 
                                 
                                    s,l,b,t
                                 :
                                    
                                       (2)
                                       
                                          
                                             
                                                G
                                                
                                                   s
                                                   ,
                                                   l
                                                   ,
                                                   b
                                                   ,
                                                   t
                                                
                                             
                                             ≥
                                             
                                                U
                                                
                                                   s
                                                   −
                                                   1
                                                
                                             
                                             .
                                          
                                       
                                    
                                 when all these conditions are satisfied – and provided that l+
                                 t
                                 ≤
                                 b – it is trivial to prove that the bit string resulting from the concatenation of any number of elements of 
                                    G
                                 
                                 
                                    s,l,b,t
                                 , even for varying s, will contain no more than b consecutive bits at the same value at any position, as long as l, b, and t are still kept the same for all codebooks. If the communication channel bit stuffing mechanism is triggered by a sequence of b
                                 +1 bits at the same value (one of the primer sequences mentioned in Section 2), this is a sufficient condition for the complete absence of bit stuffing at the channel level. As discussed in Section 2, b
                                 =4 for CAN.

Other points of interest are to determine the maximum value of s, denoted with sm
                         in the following, for which codebook construction is still possible and, in particular, property (2) still holds. For an efficient practical implementation of the encoding and decoding software modules based on lookup tables, which will be discussed in Section 4, it is also important to highlight any relationship between the codebooks 
                           G
                        
                        
                           s,l,b,t
                        , for varying s
                        =2,…, sm
                        . This is because any relationship can be leveraged to reduce the size of the lookup tables, and hence, the footprint of the software.

In the following, for any s
                        ≥1, 
                           Q
                        
                        
                           s
                         denotes the set of strings of length s with exactly s leading (and trailing) bits at the same value. Moreover, for any s
                        ≥2 and 1≤
                        k
                        ≤
                        s
                        −1, R
                           s
                        (k) denotes the set of strings of length s with no more than s–k leading bits at the same value and exactly k trailing bits at the same value.

A direct consequence of these definitions is that all the elements of R
                           s
                        (k), regardless of the value of k, always have strictly less than s leading bits at the same value. Moreover, for any value of s, the set 
                           Q
                        
                        
                           s
                         contains exactly two binary strings composed of either all zeros or all ones, namely:
                           
                              (3)
                              
                                 
                                    
                                       Q
                                       s
                                    
                                    =
                                    
                                       
                                          
                                             
                                                0
                                                …
                                                
                                                   0
                                                   2
                                                
                                             
                                             ⏞
                                          
                                          
                                             s
                                             
                                             bits
                                          
                                       
                                       ,
                                       
                                          
                                             
                                                1
                                                …
                                                
                                                   1
                                                   2
                                                
                                             
                                             ⏞
                                          
                                          
                                             s
                                             
                                             bits
                                          
                                       
                                    
                                    ∀
                                    s
                                    ≥
                                    1.
                                 
                              
                           
                        
                     

Denoting with Qs
                         the number of elements of 
                           Q
                        
                        
                           s
                        , it is therefore:
                           
                              (4)
                              
                                 
                                    
                                       Q
                                       s
                                    
                                    =
                                    2
                                    ∀
                                    s
                                    ≥
                                    1.
                                 
                              
                           
                        
                     

The construction of the sets R
                           s
                        (k), as well as the calculation of how many elements belong to them, Rs
                        (k), is slightly more complex, but it can be performed effectively by induction.

For s
                           =1, from Eq. (3) and according to the definitions given in Section 3.1:
                              
                                 (5)
                                 
                                    
                                       
                                          Q
                                          1
                                       
                                       =
                                       
                                          
                                             0
                                             2
                                          
                                          
                                             1
                                             2
                                          
                                       
                                       .
                                    
                                 
                              
                           
                        

This is because the two 1-bit strings 02 and 12 both have one leading (and trailing) bit at the same value.

For s
                           ≥2, it is:
                              
                                 (6)
                                 
                                    
                                       
                                          
                                             
                                                R
                                                s
                                             
                                             
                                                1
                                             
                                             =
                                             
                                                
                                                   x
                                                   ≀
                                                   ∼
                                                   rb
                                                   
                                                      x
                                                   
                                                   
                                                      
                                                         x
                                                         ∈
                                                         
                                                            R
                                                            
                                                               s
                                                               −
                                                               1
                                                            
                                                         
                                                         
                                                            k
                                                         
                                                         ∪
                                                         
                                                            Q
                                                            
                                                               s
                                                               −
                                                               1
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                             ,
                                          
                                          
                                             1
                                             ≤
                                             k
                                             ≤
                                             s
                                             −
                                             2
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (7)
                                 
                                    
                                       
                                          
                                             
                                                R
                                                s
                                             
                                             
                                                k
                                             
                                             =
                                             
                                                
                                                   x
                                                   ≀
                                                   rb
                                                   
                                                      x
                                                   
                                                   
                                                      
                                                         x
                                                         ∈
                                                         
                                                            R
                                                            
                                                               s
                                                               −
                                                               1
                                                            
                                                         
                                                         
                                                            
                                                               k
                                                               −
                                                               1
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                             ,
                                          
                                          
                                             2
                                             ≤
                                             k
                                             ≤
                                             s
                                             −
                                             1
                                          
                                       
                                    
                                 
                              
                           where the ≀ operator denotes string concatenation and the function rb(x) extracts the least significant (rightmost) bit of the binary string x given as an argument. The ~ operator denotes Boolean one's complement. Informally speaking, the inductive construction of the sets R
                              s
                           (k) proceeds as follows:
                              
                                 •
                                 The strings of length s
                                    ≥2, with strictly less than s leading bits at the same value and exactly 1 trailing bit at the same value, belonging to R
                                       s
                                    (1), can be obtained from any string of length s
                                    −1, belonging to either R
                                       s
                                       −1(k), 1≤
                                    k
                                    ≤
                                    s
                                    −2, or 
                                       Q
                                    
                                    
                                       s
                                       −1, by appending an additional bit that is the complement of the rightmost one as in Eq. (6).

The strings of length s
                                    ≥2 with no more than s–k leading bits at the same value and exactly k trailing bits at the same value, with 2≤
                                    k
                                    ≤
                                    s
                                    −1 (the elements of R
                                       s
                                    (k)), can be built from any sequence of s
                                    −1 bits with no more than s
                                    −
                                    k leading bits at the same value and exactly k
                                    −1 trailing bits at the same value (the elements of R
                                       s
                                       −1(k
                                    −1)) by appending an additional bit that is the same as the rightmost one as in Eq. (7).

Although Eq. (3) already gives a direct definition of 
                              Q
                           
                           
                              s
                           , it is worth noting anyway that the 2 strings of length s
                           ≥1 with s leading (and trailing) bits at the same value, the elements of 
                              Q
                           
                           
                              s
                           , can be trivially derived from the 2 sequences of length s
                           −1 with s
                           −1 leading (and trailing) bits at the same value, the elements of 
                              Q
                           
                           
                              s
                              −1, by appending an additional bit at the same value as the rightmost one. Namely:
                              
                                 (8)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   Q
                                                   s
                                                
                                                =
                                                
                                                   
                                                      x
                                                      ≀
                                                      rb
                                                      
                                                         x
                                                      
                                                      
                                                         
                                                            x
                                                            ∈
                                                         
                                                      
                                                      
                                                         Q
                                                         
                                                            s
                                                            −
                                                            1
                                                         
                                                      
                                                   
                                                
                                                ,
                                             
                                             
                                                s
                                                ≥
                                                2
                                             
                                          
                                       
                                       .
                                    
                                 
                              
                           
                        

Concerning the number of elements of R
                              s
                           (k), denoted by Rs
                           (k), referring to Eq. (6) we can write:
                              
                                 (9)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   R
                                                   s
                                                
                                                
                                                   1
                                                
                                                =
                                                
                                                   
                                                      ∑
                                                      
                                                         k
                                                         =
                                                         1
                                                      
                                                      
                                                         s
                                                         −
                                                         2
                                                      
                                                   
                                                   
                                                      
                                                         R
                                                         
                                                            s
                                                            −
                                                            1
                                                         
                                                      
                                                      
                                                         k
                                                      
                                                   
                                                
                                                +
                                                
                                                   Q
                                                   
                                                      s
                                                      −
                                                      1
                                                   
                                                
                                                ,
                                             
                                             
                                                s
                                                ≥
                                                2
                                             
                                          
                                       
                                       ,
                                    
                                 
                              
                           because the sets R
                              s
                              −1(k), 1≤
                           k
                           ≤
                           s
                           −2, and 
                              Q
                           
                           
                              s
                              −1 are, by definition, all disjoint for a fixed s. From Eq. (7) we can similarly write:
                              
                                 (10)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   R
                                                   s
                                                
                                                
                                                   k
                                                
                                                =
                                                
                                                   R
                                                   
                                                      s
                                                      −
                                                      1
                                                   
                                                
                                                
                                                   
                                                      k
                                                      −
                                                      1
                                                   
                                                
                                                ,
                                             
                                             
                                                2
                                                ≤
                                                k
                                                ≤
                                                s
                                                −
                                                1
                                             
                                          
                                       
                                       .
                                    
                                 
                              
                           
                        

By repeatedly applying Eq. (10) it is:
                              
                                 (11)
                                 
                                    
                                       
                                          R
                                          s
                                       
                                       
                                          k
                                       
                                       =
                                       
                                          R
                                          
                                             s
                                             −
                                             k
                                             +
                                             1
                                          
                                       
                                       
                                          1
                                       
                                       .
                                    
                                 
                              
                           
                        

Substituting Eqs. (4) and (11) into Eq. (9), we obtain:
                              
                                 (12)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   R
                                                   s
                                                
                                                
                                                   1
                                                
                                                =
                                                
                                                   
                                                      ∑
                                                      
                                                         k
                                                         =
                                                         1
                                                      
                                                      
                                                         s
                                                         −
                                                         2
                                                      
                                                   
                                                   
                                                      
                                                         R
                                                         
                                                            s
                                                            −
                                                            k
                                                         
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                
                                                +
                                                
                                                   Q
                                                   
                                                      s
                                                      −
                                                      1
                                                   
                                                
                                                =
                                                
                                                   
                                                      ∑
                                                      
                                                         k
                                                         =
                                                         2
                                                      
                                                      
                                                         s
                                                         −
                                                         1
                                                      
                                                   
                                                   
                                                      
                                                         R
                                                         k
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                
                                                +
                                                2
                                                ,
                                             
                                             
                                                s
                                                ≥
                                                2
                                             
                                          
                                       
                                       .
                                    
                                 
                              
                           
                        

From the previous expression we can also write:
                              
                                 (13)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   R
                                                   s
                                                
                                                
                                                   1
                                                
                                                =
                                                
                                                   R
                                                   
                                                      s
                                                      −
                                                      1
                                                   
                                                
                                                
                                                   1
                                                
                                                +
                                                
                                                   
                                                      
                                                         
                                                            ∑
                                                            
                                                               k
                                                               =
                                                               2
                                                            
                                                            
                                                               s
                                                               −
                                                               2
                                                            
                                                         
                                                         
                                                            
                                                               R
                                                               
                                                                  s
                                                                  −
                                                                  k
                                                               
                                                            
                                                            
                                                               1
                                                            
                                                         
                                                      
                                                      +
                                                      2
                                                   
                                                
                                                ,
                                             
                                             
                                                s
                                                ≥
                                                3
                                             
                                          
                                       
                                       ,
                                    
                                 
                              
                           where the rightmost part of the last expression, surrounded by parentheses, corresponds to the definition of R
                           
                              s
                              −1(1). This is because, by letting j
                           =
                           s
                           −
                           k, we can write:
                              
                                 (14)
                                 
                                    
                                       
                                          
                                             ∑
                                             
                                                k
                                                =
                                                2
                                             
                                             
                                                s
                                                −
                                                2
                                             
                                          
                                          
                                             
                                                R
                                                
                                                   s
                                                   −
                                                   k
                                                
                                             
                                             
                                                1
                                             
                                          
                                       
                                       =
                                       
                                          
                                             ∑
                                             
                                                j
                                                =
                                                2
                                             
                                             
                                                s
                                                −
                                                2
                                             
                                          
                                          
                                             
                                                R
                                                j
                                             
                                             
                                                1
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

Therefore, it is:
                              
                                 (15)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   R
                                                   s
                                                
                                                
                                                   1
                                                
                                                =
                                                2
                                                
                                                   R
                                                   
                                                      s
                                                      −
                                                      1
                                                   
                                                
                                                
                                                   1
                                                
                                                =
                                                
                                                   2
                                                   
                                                      s
                                                      −
                                                      2
                                                   
                                                
                                                
                                                   R
                                                   2
                                                
                                                
                                                   1
                                                
                                                ,
                                             
                                             
                                                s
                                                ≥
                                                3
                                             
                                          
                                       
                                       .
                                    
                                 
                              
                           
                        

Being R
                           2(1)=
                           Q
                           1
                           =2, from Eqs. (4) and (9) we have, in general:
                              
                                 (16)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   R
                                                   s
                                                
                                                
                                                   1
                                                
                                                =
                                                
                                                   2
                                                   
                                                      s
                                                      −
                                                      1
                                                   
                                                
                                                ,
                                             
                                             
                                                s
                                                ≥
                                                2
                                             
                                          
                                       
                                       .
                                    
                                 
                              
                           
                        

From Eq. (11) we can eventually conclude that:
                              
                                 (17)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   R
                                                   s
                                                
                                                
                                                   k
                                                
                                                =
                                                
                                                   2
                                                   
                                                      s
                                                      −
                                                      k
                                                   
                                                
                                                ,
                                             
                                             
                                                1
                                                ≤
                                                k
                                                ≤
                                                s
                                                −
                                                1
                                             
                                          
                                       
                                       .
                                    
                                 
                              
                           
                        

An additional consistency check of the above statements can be performed by noticing that, for any given s, the sets R
                              s
                           (k), 1≤
                           k
                           ≤
                           s
                           −1, and 
                              Q
                           
                           
                              s
                            must cover the universe of the strings of length s:
                              
                                 (18)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      ∪
                                                      
                                                         k
                                                         =
                                                         1
                                                      
                                                      
                                                         s
                                                         −
                                                         1
                                                      
                                                   
                                                   
                                                      
                                                         R
                                                         s
                                                      
                                                      
                                                         k
                                                      
                                                      ∪
                                                      
                                                         Q
                                                         s
                                                      
                                                   
                                                
                                                =
                                                
                                                   U
                                                   s
                                                
                                                ,
                                             
                                             
                                                s
                                                ≥
                                                1
                                             
                                          
                                       
                                       ,
                                    
                                 
                              
                           
                        

Since the sets being considered are all disjoint for a fixed s by definition, it must also be:
                              
                                 (19)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      ∑
                                                      
                                                         k
                                                         =
                                                         1
                                                      
                                                      
                                                         s
                                                         −
                                                         1
                                                      
                                                   
                                                   
                                                      
                                                         R
                                                         s
                                                      
                                                      
                                                         k
                                                      
                                                   
                                                
                                                +
                                                
                                                   Q
                                                   s
                                                
                                                =
                                                
                                                   2
                                                   s
                                                
                                                ,
                                             
                                             
                                                s
                                                ≥
                                                1
                                             
                                          
                                       
                                       .
                                    
                                 
                              
                           
                        

In fact, from Eqs. (17) and (4) it is:
                              
                                 (20)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   ∑
                                                   
                                                      k
                                                      =
                                                      1
                                                   
                                                   
                                                      s
                                                      −
                                                      1
                                                   
                                                
                                                
                                                   
                                                      R
                                                      s
                                                   
                                                   
                                                      k
                                                   
                                                
                                             
                                             +
                                             
                                                Q
                                                s
                                             
                                             =
                                             
                                                
                                                   ∑
                                                   
                                                      k
                                                      =
                                                      1
                                                   
                                                   
                                                      s
                                                      −
                                                      1
                                                   
                                                
                                                
                                                   
                                                      2
                                                      
                                                         s
                                                         −
                                                         k
                                                      
                                                   
                                                
                                             
                                             +
                                             2
                                          
                                       
                                       
                                          
                                             =
                                             2
                                             
                                                
                                                   
                                                      ∑
                                                      
                                                         j
                                                         =
                                                         0
                                                      
                                                      
                                                         s
                                                         −
                                                         2
                                                      
                                                   
                                                   
                                                      
                                                         2
                                                         j
                                                      
                                                      +
                                                      1
                                                   
                                                
                                             
                                             =
                                             2
                                             
                                                
                                                   
                                                      2
                                                      
                                                         s
                                                         −
                                                         1
                                                      
                                                   
                                                   −
                                                   1
                                                   +
                                                   1
                                                
                                             
                                             =
                                             
                                                2
                                                s
                                             
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        

The construction of the sets R
                              s
                           (k) and 
                              Q
                           
                           
                              s
                            by induction can also be depicted by means of the data flow diagram shown in Fig. 2
                           . In the figure, circles represent sets; they contain the name of the set and its cardinality. Beside each set, the strings belonging to that set and beginning with 02 are shown. Due to a property to be proved in Section 3.5, the complement of the strings shown in the figure belongs to the same set, too.

Thick lines represent the operation of appending to each element x of a set an additional bit equal to its rightmost bit, to obtain a new element y, that is, y
                           =
                           x
                           ≀
                           rb(x). Thin lines represent the operation of appending to each element x of a set an additional bit equal to the complement of its rightmost bit, to obtain a new element y, that is, y
                           =
                           x
                           ≀~
                           rb(x).

The strings of length l
                           +1 belonging to R
                              l
                              +1(k), 1≤
                           k
                           ≤
                           l will be used as a starting point to build longer strings, with at most l leading bits at the same value, by appending further bits. On the contrary, the strings belonging to 
                              Q
                           
                           
                              l
                              +1 must be excluded, because they have got l
                           +1 leading bits at the same value, and hence, already violate the requirements set forth in Section 3.1.

It is possible to use the partial results presented in Section 3.2 to generate strings of length s, with at most l leading bits at the same value and at most b consecutive inner bits at the same value, assuming that b
                        >
                        l. The case b
                        ≤
                        l is not of practical interest because it would make the assumption l
                        +
                        t
                        ≤
                        b, set forth in Section 3.1, impossible to satisfy.

The set denoted by B
                           s,l,b
                        (k) will be formally defined as the set of strings of length s
                        >
                        l, which have got:
                           
                              •
                              at most l leading bits at the same value, and

at most b consecutive inner bits at the same value, and

exactly 1≤
                                 k
                                 ≤
                                 b trailing bits at the same value.

As before, we denote by 
                           Q
                        
                        
                           s,l,b
                         the set of “invalid” strings, that is, strings of length s which do not satisfy the property set forth for any of the B
                           s,l,b
                        (k) for the same s, that is, strings that have got either:
                           
                              •
                              more than l leading bits at the same value, or

more than b consecutive inner bits at the same value.

As for R
                           s
                        (k) and 
                           Q
                        
                        
                           s
                        , set generation is performed in an inductive way.

The base case of the generation are the strings of length s
                           =
                           l
                           +1 belonging to R
                              l
                              +1(k), 1≤
                           k
                           ≤
                           l. Consistently with the hypothesis b
                           ≥
                           l, we will let:
                              
                                 (21)
                                 
                                    
                                       
                                          
                                             
                                                B
                                                
                                                   l
                                                   +
                                                   1
                                                   ,
                                                   l
                                                   ,
                                                   b
                                                
                                             
                                             
                                                k
                                             
                                             =
                                             
                                                R
                                                
                                                   l
                                                   +
                                                   1
                                                
                                             
                                             
                                                k
                                             
                                             ,
                                          
                                          
                                             1
                                             ≤
                                             k
                                             ≤
                                             l
                                          
                                       
                                       
                                          
                                             
                                                B
                                                
                                                   l
                                                   +
                                                   1
                                                   ,
                                                   l
                                                   ,
                                                   b
                                                
                                             
                                             
                                                k
                                             
                                             =
                                             ∅
                                             ,
                                          
                                          
                                             l
                                             +
                                             1
                                             ≤
                                             k
                                             ≤
                                             b
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        

According to the definition of 
                              Q
                           
                           
                              l
                              +1,l,b
                           , we can also let:
                              
                                 (22)
                                 
                                    
                                       
                                          Q
                                          
                                             l
                                             +
                                             1
                                             ,
                                             l
                                             ,
                                             b
                                          
                                       
                                       =
                                       
                                          Q
                                          
                                             l
                                             +
                                             1
                                          
                                       
                                       .
                                    
                                 
                              
                           
                        

For s
                           ≥
                           l
                           +2, the induction proceeds according to the following formulae. First of all, it is:
                              
                                 (23)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   B
                                                   
                                                      s
                                                      ,
                                                      l
                                                      ,
                                                      b
                                                   
                                                
                                                
                                                   1
                                                
                                                =
                                                
                                                   
                                                      x
                                                      ≀
                                                      ∼
                                                      rb
                                                      
                                                         x
                                                      
                                                      
                                                         
                                                            x
                                                            ∈
                                                            
                                                               B
                                                               
                                                                  s
                                                                  −
                                                                  1
                                                                  ,
                                                                  l
                                                                  ,
                                                                  b
                                                               
                                                            
                                                            
                                                               k
                                                            
                                                         
                                                      
                                                   
                                                
                                                ,
                                             
                                             
                                                1
                                                ≤
                                                k
                                                ≤
                                                b
                                             
                                          
                                       
                                       ,
                                    
                                 
                              
                           because it is possible to build a string of length s that has no more than 1 trailing bit at the same value, by taking a string of length s
                           −1 that has no more than 1≤
                           k
                           ≤
                           b trailing bits at the same value, and appending one more bit that is the complement of the rightmost one. This operation preserves the property that no strings generated in this way have either more than l leading bits at the same value or more than b consecutive inner bits at the same value.

Secondly, it is:
                              
                                 (24)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   B
                                                   
                                                      s
                                                      ,
                                                      l
                                                      ,
                                                      b
                                                   
                                                
                                                
                                                   k
                                                
                                                =
                                                
                                                   
                                                      x
                                                      ≀
                                                      rb
                                                      
                                                         x
                                                      
                                                      
                                                         
                                                            x
                                                            ∈
                                                            
                                                               B
                                                               
                                                                  s
                                                                  −
                                                                  1
                                                                  ,
                                                                  l
                                                                  ,
                                                                  b
                                                               
                                                            
                                                            
                                                               
                                                                  k
                                                                  −
                                                                  1
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                                ,
                                             
                                             
                                                2
                                                ≤
                                                k
                                                ≤
                                                b
                                             
                                          
                                       
                                       ,
                                    
                                 
                              
                           because, by taking a string of length s
                           −1 with up to b consecutive inner bits at the same value, as well as k
                           −1 trailing bits at the same value, and appending one more bit at the same value as the rightmost one, a string of length s is obtained. That string has k trailing bits at the same value and, provided that k
                           ≤
                           b, it still has no more than b consecutive inner bits at the same value.

Finally, we can also write:
                              
                                 (25)
                                 
                                    
                                       
                                          
                                             
                                                Q
                                                
                                                   s
                                                   ,
                                                   l
                                                   ,
                                                   b
                                                
                                             
                                             =
                                             
                                                
                                                   x
                                                   ≀
                                                   
                                                      0
                                                      2
                                                   
                                                   
                                                      
                                                         x
                                                         ∈
                                                         
                                                            Q
                                                            
                                                               s
                                                               −
                                                               1
                                                               ,
                                                               l
                                                               ,
                                                               b
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             ∪
                                             
                                                
                                                   x
                                                   ≀
                                                   
                                                      1
                                                      2
                                                   
                                                   
                                                      
                                                         x
                                                         ∈
                                                         
                                                            Q
                                                            
                                                               s
                                                               −
                                                               1
                                                               ,
                                                               l
                                                               ,
                                                               b
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             ∪
                                             
                                                
                                                   x
                                                   ≀
                                                   rb
                                                   
                                                      x
                                                   
                                                   
                                                      
                                                         x
                                                         ∈
                                                         
                                                            B
                                                            
                                                               s
                                                               −
                                                               1
                                                               ,
                                                               l
                                                               ,
                                                               b
                                                            
                                                         
                                                         
                                                            b
                                                         
                                                      
                                                   
                                                
                                             
                                             ,
                                          
                                       
                                    
                                 
                              
                           because an “invalid” string of length s can be obtained in two different ways:
                              
                                 1.
                                 By taking a string of length s
                                    −1 that already violates the requirement and appending one more bit, at any value. This case corresponds to the first two terms of Eq. (25).

By taking a string of length s
                                    −1 that satisfies the requirement, but has exactly b trailing bits at the same value, and adding one more bit at that same value to obtain a string with b
                                    +1 trailing bits at the same value. This case corresponds to the last term of Eq. (25).

Also in this case, it is worth remarking that the sets B
                              s,l,b
                           (k), 1≤
                           k
                           ≤
                           b and 
                              Q
                           
                           
                              s,l,b
                            for a given s cover 
                              U
                           
                           
                              s
                           , that is,
                              
                                 (26)
                                 
                                    
                                       
                                          
                                             ∪
                                             
                                                k
                                                =
                                                1
                                             
                                             b
                                          
                                          
                                             
                                                B
                                                
                                                   s
                                                   ,
                                                   l
                                                   ,
                                                   b
                                                
                                             
                                             
                                                k
                                             
                                          
                                       
                                       ∪
                                       
                                          Q
                                          
                                             s
                                             ,
                                             l
                                             ,
                                             b
                                          
                                       
                                       =
                                       
                                          U
                                          s
                                       
                                       .
                                    
                                 
                              
                           
                        

Denoting by B
                           
                              s,l,b
                           (k) the number of elements of B
                              s,l,b
                           (k) and referring to Eq. (23), taking into account that the sets B
                              s
                              −1,l,b
                           (k), 1≤
                           k
                           ≤
                           b are all disjoint, it is:
                              
                                 (27)
                                 
                                    
                                       
                                          B
                                          
                                             s
                                             ,
                                             l
                                             ,
                                             b
                                          
                                       
                                       
                                          1
                                       
                                       =
                                       
                                          
                                             ∑
                                             
                                                k
                                                =
                                                1
                                             
                                             b
                                          
                                          
                                             
                                                B
                                                
                                                   s
                                                   −
                                                   1
                                                   ,
                                                   l
                                                   ,
                                                   b
                                                
                                             
                                             
                                                k
                                             
                                          
                                       
                                       .
                                    
                                 
                              
                           
                        

Then, from Eq. (24), it is:
                              
                                 (28)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   B
                                                   
                                                      s
                                                      ,
                                                      l
                                                      ,
                                                      b
                                                   
                                                
                                                
                                                   k
                                                
                                                =
                                                
                                                   B
                                                   
                                                      s
                                                      −
                                                      1
                                                      ,
                                                      l
                                                      ,
                                                      b
                                                   
                                                
                                                
                                                   
                                                      k
                                                      −
                                                      1
                                                   
                                                
                                                ,
                                             
                                             
                                                2
                                                ≤
                                                k
                                                ≤
                                                b
                                             
                                          
                                       
                                       .
                                    
                                 
                              
                           
                        

Finally, from Eq. (25) we obtain that the number of elements of 
                              Q
                           
                           
                              s,l,b
                           , denoted by Q
                           
                              s,l,b
                            is given by:
                              
                                 (29)
                                 
                                    
                                       
                                          Q
                                          
                                             s
                                             ,
                                             l
                                             ,
                                             b
                                          
                                       
                                       =
                                       2
                                       
                                          Q
                                          
                                             s
                                             −
                                             1
                                             ,
                                             l
                                             ,
                                             b
                                          
                                       
                                       +
                                       
                                          B
                                          
                                             s
                                             −
                                             1
                                             ,
                                             l
                                             ,
                                             b
                                          
                                       
                                       
                                          b
                                       
                                       ,
                                    
                                 
                              
                           in which the factor 2 comes from the fact that a string belonging to Q
                           
                              s,l,b
                            can be obtained from an element of Q
                           
                              s
                              –1,l,b
                            by appending a bit at any value, that is, either 02 or 12.

By applying Eq. (28) repeatedly, it is:
                              
                                 (30)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   B
                                                   
                                                      s
                                                      ,
                                                      l
                                                      ,
                                                      b
                                                   
                                                
                                                
                                                   k
                                                
                                                =
                                                
                                                   B
                                                   
                                                      s
                                                      −
                                                      
                                                         
                                                            k
                                                            −
                                                            1
                                                         
                                                      
                                                      ,
                                                      l
                                                      ,
                                                      b
                                                   
                                                
                                                
                                                   1
                                                
                                                ,
                                             
                                             
                                                s
                                                ≥
                                                l
                                                +
                                                k
                                             
                                          
                                       
                                       .
                                    
                                 
                              
                           
                        

Substituting Eq. (30) back into Eq. (27) we can write, for s
                           ≥
                           l
                           +
                           b
                           +1,
                              
                                 (31)
                                 
                                    
                                       
                                          B
                                          
                                             s
                                             ,
                                             l
                                             ,
                                             b
                                          
                                       
                                       
                                          1
                                       
                                       =
                                       
                                          
                                             ∑
                                             
                                                k
                                                =
                                                1
                                             
                                             b
                                          
                                          
                                             
                                                B
                                                
                                                   s
                                                   −
                                                   k
                                                   ,
                                                   l
                                                   ,
                                                   b
                                                
                                             
                                             
                                                1
                                             
                                          
                                       
                                       .
                                    
                                 
                              
                           
                        

This formula shows that B
                           
                              s,l,b
                           (1) can be calculated by means of a generalized Fibonacci sequence of order b. Due to Eq. (30), this property is also valid for B
                           
                              s,l,b
                           (k), 1≤
                           k
                           ≤
                           b when s
                           ≥
                           l
                           +
                           k.

The construction process of B
                              s,l,b
                           (k) and 
                              Q
                           
                           
                              s,l,b
                            for a case of interest is depicted in Fig. 3
                           . The notation is the same as in Fig. 2, with a double, thin line denoting the operation of appending a bit at any value. To avoid cluttering the figure, only one exemplar string is shown for each set.

The last step of the construction of the codebook 
                           G
                        
                        
                           s,l,b,t
                         consists of taking into account the requirement about the maximum number of trailing bits at the same value, which shall be no more than t, with t
                        ≤
                        b. This is quite simple because B
                           s,l,b
                        (k) satisfies all the requirements on s, l, and b and, moreover, contains strings with exactly k trailing bits at the same value.

We can therefore write:
                           
                              (32)
                              
                                 
                                    
                                       
                                          
                                             
                                                G
                                                
                                                   s
                                                   ,
                                                   l
                                                   ,
                                                   b
                                                   ,
                                                   t
                                                
                                             
                                             =
                                             
                                                
                                                   ∪
                                                   
                                                      k
                                                      =
                                                      1
                                                   
                                                   t
                                                
                                                
                                                   
                                                      B
                                                      
                                                         s
                                                         ,
                                                         l
                                                         ,
                                                         b
                                                      
                                                   
                                                   
                                                      k
                                                   
                                                   ,
                                                
                                             
                                          
                                          
                                             s
                                             ≥
                                             l
                                             +
                                             1
                                          
                                       
                                    
                                    .
                                 
                              
                           
                        
                     

By recalling again that all the sets B
                           s,l,b
                        (k) are all disjoint for a fixed s, it is:
                           
                              (33)
                              
                                 
                                    
                                       G
                                       
                                          s
                                          ,
                                          l
                                          ,
                                          b
                                          ,
                                          t
                                       
                                    
                                    =
                                    
                                       
                                          ∑
                                          
                                             k
                                             =
                                             1
                                          
                                          t
                                       
                                       
                                          
                                             B
                                             
                                                s
                                                ,
                                                l
                                                ,
                                                b
                                             
                                          
                                          
                                             k
                                          
                                       
                                    
                                    .
                                 
                              
                           
                        
                     

Moreover, it is easy to show that, in the corner case s
                        =
                        l, a suitable choice for 
                           G
                        
                        
                           l,l,b,t
                        , analogous to Eq. (32), is:
                           
                              (34)
                              
                                 
                                    
                                       G
                                       
                                          l
                                          ,
                                          l
                                          ,
                                          b
                                          ,
                                          t
                                       
                                    
                                    =
                                    
                                       
                                          ∪
                                          
                                             k
                                             =
                                             1
                                          
                                          
                                             min
                                             
                                                
                                                   l
                                                   −
                                                   1
                                                   ,
                                                   t
                                                
                                             
                                          
                                       
                                       
                                          
                                             R
                                             l
                                          
                                          
                                             k
                                          
                                       
                                    
                                    .
                                 
                              
                           
                        
                     

Let 
                           G
                        
                        
                           s
                           −1,l,b,t
                        
                        ⁎ be the set of strings obtained from 
                           G
                        
                        
                           s,l,b,t
                         by deleting the rightmost bit of its elements. By construction, all the elements of 
                           G
                        
                        
                           s
                           −1,l,b,t
                        
                        ⁎ are of length s
                        −1. It can be proved that:
                           
                              (35)
                              
                                 
                                    
                                       
                                          
                                             
                                                G
                                                
                                                   s
                                                   −
                                                   1
                                                   ,
                                                   l
                                                   ,
                                                   b
                                                   ,
                                                   t
                                                
                                             
                                             ⊆
                                             
                                                G
                                                
                                                   s
                                                   −
                                                   1
                                                   ,
                                                   l
                                                   ,
                                                   b
                                                   ,
                                                   t
                                                
                                                *
                                             
                                             ,
                                          
                                          
                                             s
                                             >
                                             l
                                             +
                                             1
                                          
                                       
                                    
                                    ,
                                 
                              
                           
                        which, informally speaking, means that for fixed l, b, and t, the codebooks 
                           G
                        
                        
                           s,l,b,t
                         obtained by varying s are all nested into each other.

From the implementation point of view, this is very useful because, although all the codebooks 
                           G
                        
                        
                           s,l,b,t
                         for s
                        =2,…, sm
                         are needed in a certain application, only 
                           
                              G
                              
                                 
                                    s
                                    m
                                 
                                 ,
                                 l
                                 ,
                                 b
                                 ,
                                 t
                              
                           
                         must be stored explicitly, because all the smaller codebooks can be obtained from a subset of the biggest one by deleting some of the rightmost bits of its elements.

From Eq. (32), since we assume that t
                        ≤
                        b, we can write:
                           
                              (36)
                              
                                 
                                    
                                       G
                                       
                                          s
                                          −
                                          1
                                          ,
                                          l
                                          ,
                                          b
                                          ,
                                          t
                                       
                                    
                                    =
                                    
                                       
                                          ∪
                                          
                                             k
                                             =
                                             1
                                          
                                          t
                                       
                                       
                                          
                                             B
                                             
                                                s
                                                −
                                                1
                                                ,
                                                l
                                                ,
                                                b
                                             
                                          
                                          
                                             k
                                          
                                       
                                    
                                    ⊆
                                    
                                       
                                          ∪
                                          
                                             k
                                             =
                                             1
                                          
                                          b
                                       
                                       
                                          
                                             B
                                             
                                                s
                                                −
                                                1
                                                ,
                                                l
                                                ,
                                                b
                                             
                                          
                                          
                                             k
                                          
                                       
                                    
                                    .
                                 
                              
                           
                        
                     

From Eq. (23), defining B
                           s
                           −1,l,b
                        
                        ⁎(1) as the set of strings obtained from B
                           s,l,b,t
                        (1) by removing the rightmost bit of its elements, we can also write:
                           
                              (37)
                              
                                 
                                    
                                       
                                          
                                             
                                                B
                                                
                                                   s
                                                   −
                                                   1
                                                   ,
                                                   l
                                                   ,
                                                   b
                                                
                                                *
                                             
                                             
                                                1
                                             
                                             =
                                             
                                                
                                                   x
                                                   ,
                                                   x
                                                   ∈
                                                   
                                                      B
                                                      
                                                         s
                                                         −
                                                         1
                                                         ,
                                                         l
                                                         ,
                                                         b
                                                      
                                                   
                                                   
                                                      k
                                                   
                                                
                                             
                                             ,
                                          
                                          
                                             1
                                             ≤
                                             k
                                             ≤
                                             b
                                          
                                       
                                    
                                    ,
                                 
                              
                           
                        and therefore:
                           
                              (38)
                              
                                 
                                    
                                       B
                                       
                                          s
                                          −
                                          1
                                          ,
                                          l
                                          ,
                                          b
                                       
                                       *
                                    
                                    
                                       1
                                    
                                    =
                                    
                                       
                                          ∪
                                          
                                             k
                                             =
                                             1
                                          
                                          b
                                       
                                       
                                          
                                             B
                                             
                                                s
                                                −
                                                1
                                                ,
                                                l
                                                ,
                                                b
                                             
                                          
                                          
                                             k
                                          
                                       
                                    
                                    .
                                 
                              
                           
                        
                     

Substituting Eq. (38) back into Eq. (36) we obtain:
                           
                              (39)
                              
                                 
                                    
                                       G
                                       
                                          s
                                          −
                                          1
                                          ,
                                          l
                                          ,
                                          b
                                          ,
                                          t
                                       
                                    
                                    ⊆
                                    
                                       B
                                       
                                          s
                                          −
                                          1
                                          ,
                                          l
                                          ,
                                          b
                                       
                                       *
                                    
                                    
                                       1
                                    
                                    .
                                 
                              
                           
                        
                     

From Eq. (32), being t
                        ≥1, it is:
                           
                              (40)
                              
                                 
                                    
                                       B
                                       
                                          s
                                          ,
                                          l
                                          ,
                                          b
                                       
                                    
                                    
                                       1
                                    
                                    ⊆
                                    
                                       G
                                       
                                          s
                                          ,
                                          l
                                          ,
                                          b
                                          ,
                                          t
                                       
                                    
                                    .
                                 
                              
                           
                        
                     

Remembering the definition of 
                           G
                        
                        
                           s
                           −1,l,b,t
                        
                        ⁎ and B
                           s
                           −1,l,b
                        
                        ⁎(1), this implies:
                           
                              (41)
                              
                                 
                                    
                                       B
                                       
                                          s
                                          −
                                          1
                                          ,
                                          l
                                          ,
                                          b
                                       
                                       *
                                    
                                    
                                       1
                                    
                                    ⊆
                                    
                                       G
                                       
                                          s
                                          −
                                          1
                                          ,
                                          l
                                          ,
                                          b
                                          ,
                                          t
                                       
                                       *
                                    
                                    .
                                 
                              
                           
                        
                     

At this point, we obtain Eq. (35) by combining Eqs. (39) and (41). The same nesting property can also be stated in a different way by observing that, due to Eqs. (23) and (32), we can write:
                           
                              (42)
                              
                                 
                                    x
                                    ∈
                                    
                                       G
                                       
                                          s
                                          ,
                                          l
                                          ,
                                          b
                                          ,
                                          t
                                       
                                    
                                    ⇒
                                    x
                                    ≀
                                    ∼
                                    rb
                                    
                                       x
                                    
                                    ∈
                                    
                                       G
                                       
                                          s
                                          +
                                          1
                                          ,
                                          l
                                          ,
                                          b
                                          ,
                                          t
                                       
                                    
                                    ,
                                 
                              
                           
                        and therefore, by induction:
                           
                              (43)
                              
                                 
                                    
                                       
                                          
                                             x
                                             ∈
                                             
                                                G
                                                
                                                   s
                                                   ,
                                                   l
                                                   ,
                                                   b
                                                   ,
                                                   t
                                                
                                             
                                             ⇒
                                             x
                                             ≀
                                             abp
                                             
                                                
                                                   ∼
                                                   rb
                                                   
                                                      x
                                                   
                                                   ,
                                                   
                                                      s
                                                      ′
                                                   
                                                   −
                                                   s
                                                
                                             
                                             ∈
                                             
                                                G
                                                
                                                   
                                                      s
                                                      ′
                                                   
                                                   ,
                                                   l
                                                   ,
                                                   b
                                                   ,
                                                   t
                                                
                                             
                                             ,
                                          
                                          
                                             
                                                s
                                                ′
                                             
                                             >
                                             s
                                          
                                       
                                    
                                    ,
                                 
                              
                           
                        where abp(b, l) is an alternating bit pattern of length l starting with bit b. This alternate formulation will be especially important to reduce the footprint of the reverse lookup table used by the decoder module, to be discussed in Section 4.2.

Further codebook storage savings can be achieved by observing that, due to how 
                           G
                        
                        
                           s,l,b,t
                         has been defined:
                           
                              (44)
                              
                                 
                                    g
                                    ∈
                                    
                                       G
                                       
                                          s
                                          ,
                                          l
                                          ,
                                          b
                                          ,
                                          t
                                       
                                    
                                    ⇔
                                    ∼
                                    g
                                    ∈
                                    
                                       G
                                       
                                          s
                                          ,
                                          l
                                          ,
                                          b
                                          ,
                                          t
                                       
                                    
                                    .
                                 
                              
                           
                        
                     

Informally speaking, if g belongs to 
                           G
                        
                        
                           s,l,b,t
                        , then its one's complement ~
                        g also belongs to the same codebook. It is therefore possible to define a reduced codebook 
                           G
                        
                        
                           s,l,b,t
                        
                        + containing only half of the codewords of 
                           G
                        
                        
                           s,l,b,t
                        , namely, the ones beginning with zero. The amount of storage required for 
                           G
                        
                        
                           s,l,b,t
                        
                        + with respect to 
                           G
                        
                        
                           s,l,b,t
                        , in bits, is considerably reduced because:
                           
                              •
                              it contains only half of the entries, and

the leftmost bit of all entries is always zero, and hence, it is unnecessary to store it explicitly.

At the same time, it is still possible to calculate the elements of the full codebook from the reduced ones by means of simple and efficient binary operations.

Due to Eqs. (6), (7), (21), (23), (24), and (32), the elements of 
                           Q
                        
                        1 become the leftmost bit of any codeword in 
                           G
                        
                        
                           s,l,b,t
                        . It is therefore possible to build 
                           G
                        
                        
                           s,l,b,t
                        
                        + by using the same process (base case and induction) discussed before, but starting from 
                           Q
                        
                        1
                        +
                        ={02} instead of 
                           Q
                        
                        1.

The implementation activity to be discussed in this paper concerns two complementary software modules, with very different goals and requirements, namely:
                        
                           1.
                           
                              Codebook generator. This module is executed offline, once and for all. For this reason, the focus during software development shall be on correctness, rather than performance. It generates the codebooks G
                              
                                 s,l,b,t
                              , 2≤
                              s
                              ≤
                              sm
                              , in a format suitable to be used by the other modules and as compact as possible to reduce their memory footprint.


                              Encoder and decoder. The purpose of this module is to encode the data stream before transmitting it on the channel and, symmetrically, decode the data stream coming from the channel before handing it to the upper layers of the protocol stack. Since it resides in the critical path of the protocol stack, its efficiency is of paramount practical importance.

The codebook generator was implemented in ISO Prolog 
                        [15] for the SWI Prolog system [16]. The choice of a logic programming language instead of a more traditional one stems from the fact that logic languages in general, and Prolog in particular, directly support the inductive definition of sets. Hence, the program is very concise and its statements closely resemble the mathematical definitions given in Section 3. In turn, this greatly reduces the likelihood of programming mistakes.

Listing 1. Prolog definition of Rs(k) and Qs.
                           
                              
                           
                        
                     

For instance, the generation of the sets R
                           s
                        (k) and Qs
                         defined in Section 3.2 has been programmed as shown in Listing 1. The functors rb(X, Y), neg(X, Y), and app(X, R, Y) correspond to y
                        =
                        rb(x), y
                        =~
                        x, and y
                        =
                        x
                        ≀
                        r, respectively. Their definition consists of a few lines of Prolog code and is not further discussed for conciseness. Bit strings are modeled as lists.

The base case for the definition of Qs
                         is given at lines 1–2. The two facts concerning the functor in_qs correspond to Eq. (5) and assert the initial contents of Q
                        1. Then, lines 4–6 give the inductive construction of Qs
                         for s
                        ≥2 in terms of Q
                        
                           s
                           −1, as defined in Eq. (8). The inductive construction of R
                           s
                        (1) is slightly more complex because, as defined in Eq. (6), it entails the enumeration of all elements belonging to R
                           s
                           −1(k) for 1≤
                        k
                        ≤
                        s
                        −2. This is performed by the helper functor in_rs_anyk and its iterator in_rs_anyk_iter at lines 8–16. The inductive construction itself is performed by the two induction rules found at lines 18–24. Finally, the inductive construction of R
                           s
                        (k) for 2≤
                        k
                        ≤
                        s
                        −1, which corresponds to Eq. (7) is given at lines 26–29.

With those definitions, the whole set of codewords belonging, for instance, to R4(2) can easily be found with the query


                        bag of (CW, in_rsk(4, 2, CW), CB).

The result is bound to variable CB:


                        CB=[[0,1,0,0],[1,0,1,1],
                     


                        [0,0,1,1],[1,1,0,0]].

All the other sets presented in Sections 3.3 and 3.4 have been defined in a very similar way and are not shown here for conciseness. It should be noted that, as discussed in Section 3.5, the code shown in Listing 1 can be used to generate either the full codebooks or the reduced ones, by including or excluding line 2, respectively. No modifications to any other part of the code are necessary to this purpose.

The codebook generator output can be used for a variety of purposes. First of all, the quantities G
                        
                           s,l,b,t
                         provide a mean to evaluate and compare the efficiency of different codebooks for different parameter values. In fact, a codebook composed of G
                        
                           s,l,b,t
                         strings of length s is able to encode any string of length
                           
                              (45)
                              
                                 
                                    
                                       s
                                       ′
                                    
                                    =
                                    
                                       
                                          
                                             log
                                             2
                                          
                                          
                                             G
                                             
                                                s
                                                ,
                                                l
                                                ,
                                                b
                                                ,
                                                t
                                             
                                          
                                       
                                    
                                    .
                                 
                              
                           
                        
                     

The efficiency of the codebook is then given by its information rate R, that is, the ratio
                           
                              (46)
                              
                                 
                                    R
                                    =
                                    
                                       
                                          s
                                          ′
                                       
                                       s
                                    
                                    =
                                    
                                       1
                                       s
                                    
                                    
                                       
                                          
                                             log
                                             2
                                          
                                          
                                             G
                                             
                                                s
                                                ,
                                                l
                                                ,
                                                b
                                                ,
                                                t
                                             
                                          
                                       
                                    
                                    .
                                 
                              
                           
                        
                     


                        Fig. 4
                         shows the information rate of the codebooks 
                           G
                        
                        
                           s,1,4,3 and 
                           G
                        
                        
                           s,2,4,2 as a function of s. Although they both satisfy the requirements needed to prevent CAN bit stuffing, as discussed in Section 2, 
                           G
                        
                        
                           s,2,4,2 has a better efficiency for some values of s, namely, for 5≤
                        s
                        ≤9. Another interesting information that can be inferred from Fig. 4 is that 
                           G
                        
                        9,2,4,2 has the best efficiency for any value of s
                        ≤18. The result highlights that for a memoryless block encoder for CAN, 
                           G
                        
                        9,2,4,2 is the best choice.

In order to achieve a better efficiency, it would in fact be necessary to adopt a codebook with s>18. However, in this case, the footprint of the encoding and decoding lookup tables – which is proportional to the codebook size – would be too large, at least for a small embedded system.

Moreover, the codebook generator output has also been used to check which codebooks of the form 
                           G
                        
                        
                           s,2,4,2 satisfy property (2) and, as a consequence, determine the value of sm
                         discussed in Section 3.1. Fig. 5
                         compares the two sides of Eq. (2) and shows that, in the case being considered, sm
                        
                        =9. In other words, any codebook 
                           G
                        
                        
                           s,2,4,2 with s
                        ≤
                        sm
                         has enough elements to encode any string of length s
                        −1, but this property no longer holds for any s
                        >
                        sm
                        .

Last, but not least, the codebook generator has been used as the starting point to build the forward and reverse lookup tables for the encoder and decoder module, to be discussed in Section 4.2. As an example, Table 1
                         shows the codebooks 
                           G
                        
                        
                           s,2,4,2
                        +, 2≤
                        s
                        ≤9, highlighting the nesting property presented in Section 3.5. Defining the inference rules in the right order within the Prolog code – namely, assuring that the inference rule corresponding to Eq. (23) comes before the one corresponding to Eq. (24) – ensures that, when the largest codebook 
                           G
                        
                        9,2,4,2
                        + is being generated, the codebook entries corresponding to the nested, smaller codebooks, are generated first, as shown in the table.

Besides dealing with payload encoding and decoding, with the help of the codebook presented in Section 4.1, the actual encoder and decoder software modules must also take care of other important low-level details—for instance, format the encoded message as a whole in a proper way and prevent other parts of the message, namely the header, from injecting part of a primer sequence into the payload. Both goals must be accomplished in an efficient way, where efficiency has got two different, and possibly conflicting, meanings:
                           
                              •
                              
                                 space efficiency, to make the best possible use of the limited payload carrying capabilities of CAN;


                                 time efficiency, because the encoding and decoding processes must be as fast as possible.

For what concerns the break bit (BB), a simple optimization consists of including it only when necessary, that is, when the DLC in the transmitted frame is equal to 7, 8, or 3. In the former two cases it is easy to see that the corresponding DLC bit patterns (01112 and 10002) include 3 bits at the same value at their end. In the absence of BB, it would no longer be ensured that no stuff bit may appear when a codeword is appended. The latter case (00112) leads to the same issue when a stuff bit (at 12) is inserted just after the two initial bits at 02 because the part of header that precedes the DLC ends with 0002.

Another drawback of 8B9B is that part of the data field is actually wasted. In fact, the encoded payload is typically not aligned on a byte boundary, because it is made up of an integral number of 9-bit codewords, and must be properly padded at the end. The VHCC encoding scheme overcomes this limitation. In fact, instead of filling the PAD field using a fixed alternating bit pattern – just to prevent bit stuffing – it is now possible to leverage it suitably in order to pack further information. If the PAD field is made up of s bits, the codebook 
                           G
                        
                        
                           s,2,4,2
                        + discussed in Section 3 can be used to efficiently store s
                        −1 bits of additional data. For instance, when the PAD is 7-bit long (as happens when the original payload takes one whole byte and DLC equals 2), it is possible to accommodate a further piece of information comprising up to 6 data bits. This means, 14 bits can be encoded in this case with VHCC versus the 8 bits allowed in 8B9B.

In practice, an additional parameter PS (PAD selector) expressed on one byte is provided to the encoding function – besides the original payload – which is used for determining the content of the PAD field (the old name has been retained for simplicity, in spite of the fact its meaning has actually changed). Basically, after all the bytes of the original payload have been converted to the related codewords, one additional translation is carried out using the least significant part of PS. For obvious reasons, not every bit of this byte will be encoded (see Table 2
                         for details). In the case no additional information is available, the user has to provide a dummy value for PS nonetheless, which will never be used on the receiver side. The contents of PS will be encoded anyway, and hence, the PAD field will be set to a value that prevents primer sequences in the data field, as happened in 8B9B with the original, alternating bit pattern.

The additional byte PS introduced above can be seen as part of an “extended” payload and appended at byte position n
                        +1. In the following, the notation n.m will be used to denote the size of such a payload, made up of n bytes (base size) and m bits (additional information). In Table 2, details about the enhancements achieved by the VHCC encoding scheme are shown. Particularly, for every DLC value, the maximum size allowed for the payload is reported (expressed as n.m), as well as the presence (and value) of BB. It is worth noting that, in the original 8B9B, encoded frames with a DLC value equal to 1 were forbidden. Instead, in VHCC, this case is permitted and can be used to achieve sub-byte information encoding (up to 7 bits).

The approach defined above could be profitably adopted, for instance, when the payload is obtained by collecting together several signals defined at the application level (as for PDO mapping in CANopen) or when information is encoded on more bits than strictly necessary (this happens, e.g., if a small set of enumerated values takes one whole byte, as in the case of the state information found in some NMT messages of CANopen). In these cases, the payload (as seen by the application) is best described as a sequence of bits, instead of bytes—indeed, the requirement that the payload takes an integral number of bytes depends basically on CAN.

In Fig. 6
                        , the duration (in bit times) of the data field in the frame sent over the bus is shown for plain CAN and VHCC for different sizes of the payload (also expressed in bits). The other fields of the CAN frame were not taken into account explicitly, because either BS cannot be prevented (CRC), it does not apply (unstuffed trailer part), or it can be tackled by means of a careful selection of the message parameters (i.e., the identifier). It is worth noting that the actual duration in CAN is not fixed, because of the stuff bits possibly added by the CAN controller. In the worst case, up to 2 bits may be added to every original byte. As a consequence, two plots labeled “CAN (min)” and “CAN (max)” were added to Fig. 6, which correspond to the best and worst cases, respectively.

It can be seen that, overall, VHCC is often quite close to the best case in CAN, and rarely it happens to be (slightly) worse. The major advantage with respect to plain CAN is the noticeably lower transmission jitter, especially when the payload is large. More specifically, the residual jitter only comes from the CRC field.

From the implementation point of view, Table 2 includes two borderline cases:
                           
                              1.
                              The first row of the table corresponds to a completely empty payload (payload size 0.0). To streamline the encoding software, it is assumed that this case – usually related to peculiar classes of messages – will be handled specially in the application layer, so that the encoder will never encounter it.

In the penultimate row of the table (payload size 6.1), there is only one PAD bit available. In order to ensure that the payload still ends with no more than 2 bits at the same value – and preserve one of the basic code properties – it would be necessary to set the PAD bit to the complement of the last bit of the last codeword. However, since the proposed scheme does not handle CRC jitter in any way, a more efficient implementation has been obtained by simply using that bit to transfer one more payload bit. It is, in fact, possible to design the encoding and decoding algorithms so that they gracefully fall back to this behavior when executed with a one-bit input and one-bit output. As a side effect, we accept that up to 3 bits at the same value may appear at the end of the payload.

However, this choice also explains the apparent anomaly of Table 2, in which the PAD size is always 1 bit more than m (the additional information part of the payload), whereas in this case it is not.

The most critical part of the implementation, regarding performance, is how to individually encode and decode each byte of the payload, as well as PS. To attain maximum efficiency, this is performed by means of two lookup tables:
                           
                              1.
                              
                                 Forward lookup table. The first 27 entries of the reduced codebook shown in Table 1 embody the forward lookup table of the encoder for 
                                    G
                                 
                                 9,2,4,2
                                 +. The 8-bit word w to be encoded shall first of all be reduced, by masking off its most significant bit, and then used as an index in the table. The contents of the table will then be either used directly as a codeword, or complemented, depending on whether the most significant bit of w was 02 or 12.

The table will be only 8-bit wide instead of 9 when stored in memory, because the leftmost bit is zero in all its entries and it is therefore unnecessary to store it explicitly.

To encode a word w according to the smaller codebooks 
                                    G
                                 
                                 
                                    s,2,4,2
                                 +, with 2≤
                                 s
                                 <9, due to the codebook nesting property, w itself can still be used as an index in the forward lookup table as discussed before. Then, the codeword derived from the table must be shifted/masked to extract its s most significant bits.


                                 Reverse lookup table. 
                                 Table 1 can be used to generate the reverse lookup table for 
                                    G
                                 
                                 9,2,4,2
                                 +, by inverting it. Namely, if the forward lookup table contains codeword g at index w, with 0≤
                                 w
                                 <27, the reverse lookup table will contain the value w at index g. Reduced codewords g are 8-bit wide, while w is 7-bit wide, and hence, the reverse lookup table must have 28 7-bit entries.

Since only 27 reduced codewords exist, not all entries of the reverse lookup table will be filled in this way. The remaining entries correspond to invalid bit patterns, which are not valid encoder outputs.

Due to property (43), the same reverse lookup table can also be used when smaller codebooks 
                                    G
                                 
                                 
                                    s,2,4,2, 2≤
                                 s
                                 <9 are needed. In this case, the encoded bit pattern must be padded to the right with an alternating bit pattern, beginning with the complement of its least significant bit, before being used as an index in the reverse lookup table of 
                                    G
                                 
                                 9,2,4,2
                                 +. The length of the alternating bit pattern must be chosen to bring the total width of the index to 8 bits.


                        Fig. 7
                         fully describes how the reverse lookup table is handled to decode a single codeword of any size, since this is the most complex operation to be performed. This procedure is used to handle both the 9-bit codewords coming from byte-by-byte payload encoding, as well as the smaller codeword coming from PS encoding.

In the flowchart, the function bit(g, p) extracts bit number p from word g. Bits are numbered from zero starting with the least significant bit. Function neg(g, n) returns the complement of the n least significant bits of g. Both functions are straightforward to express in any high-level programming language and are amenable to a very efficient machine-language translation on most modern processor architectures.
                           
                              •
                              The procedure starts with an s-bit pattern g extracted from the CAN message payload. The value of g ranges from 0 to 2
                                    s
                                 
                                 −1, inclusive.

The most significant bit of g, called gm
                                 , is used to reduce the range of g in preparation to the reverse lookup table access. In particular, if gm
                                 
                                 =1, g is complemented to make sure that its range is from 0 and 2
                                    s
                                    −1
                                 −1, inclusive.

If necessary, g is extended to the right with an alternating bit pattern, in order to make it 8-bit wide. The correct bit pattern to be used (out of the two possible ones) depends on the least significant bit of g before extension, called gl
                                 . In the flowchart, both bit patterns are stored in the 2-element array abp[] and gl
                                  is used as an index into it. However, for efficiency, in the actual implementation they are specified as constants in the code.

The reduced reverse lookup table rlt[] is accessed to get the decoded value. Depending on the value of gm
                                 , the decoded value is either the value found in the table or its complement.

At the end of the procedure, f contains the decoded value in its s
                                 −1 least significant bits.

The additional consistency checks involving invalid bit patterns are not shown in Fig. 7 for clarity. In addition, when s
                        =9, the operations specified in the gray blocks can be skipped for efficiency.

@&#EXPERIMENTAL RESULTS@&#

A prototype implementation of VHCC has been developed for the NXP LPC 1768 microcontroller [17,18] and then tested, focusing on correctness, performance, and footprint evaluation. The microcontroller was configured to run with a core clock frequency of 100MHz and the software was developed by means of an open-source toolchain based on binutils [19], gcc [20], and newlib [21].

The correctness of a single encoding and decoding step – involving forward and reverse lookup table access – has been verified exhaustively, by encoding all the possible bit patterns of length between 1 and 8 bits inclusive, and then decoding the result. Lengths from 1 to 7 bits inclusive cover all the possible cases for PS encoding and decoding, while the length of 8 bits refers to how a whole byte of the payload is processed.

However, verifying the encoding and decoding modules as a whole in the same way would have been infeasible, due to the huge size of the sample space. Instead, a probabilistic approach has been adopted. Namely, correctness has been checked on a large number (107) of randomly-generated payloads for each length from 0.7 to 7.0 (see Table 2).

Similarly, performance was evaluated by measuring the encoding and decoding times of randomly-generated payloads of varying sizes by means of one LPC 1768 internal timer, with a resolution of 10ns. Fig. 8
                      shows the encoding and decoding times as a function of payload size.

By looking at the figure, it can be noted that the main properties of the 8B9B implementation are still valid for VHCC. The execution time jitter is in fact below the minimum measurable amount of 10ns, that is, one core clock cycle. For this reason, the sample variance has not been shown in Fig. 8. Moreover, the overall execution time of the encoder and decoder modules never exceeds a few bit times, even at the maximum CAN bit rate of 1Mbps.

For what concerns footprint, Table 3
                      details the size of the encoding and decoding modules in different memory segments. This breakdown is important because, in a typical embedded system, different segments are allocated to different kinds of memory, with their own characteristics. For instance, the constant data (cdata) segment can be stored in a read-only memory, whereas the stack, being heavily used, requires a fast read–write memory. Furthermore, the code footprint has been broken down to shed more light on the relative size of the encoding and decoding loops, handling full payload bytes, with respect to loop setup as well as PS encoding and decoding.

In the first place, it is important to remark that the total footprint of the combined VHCC encoding and decoding modules is only 1052bytes for the code and constant data segments, plus either 48 or 40bytes of stack space, respectively. This figure, just above 1kB, is likely to be acceptable even in a very small and resource-limited embedded system.

Moreover, the footprint results indirectly confirm the consistency of the performance data shown in Fig. 8. Although the exact relationship between the size of a code fragment and its execution time is not straightforward on current processors, it can qualitatively be seen that one very likely reason of the slowness of the encoder with respect to the decoder for small payload sizes is due to its bigger loop setup and PS encoding sections. Similarly, the execution time of the encoder grows slower than the decoder as the payload size increases, because its loop section is smaller.

The problem of BS-induced jitters in CAN is well known, and a number of remedies have been proposed in the literature over the past years. Early solutions [9,11], also known as XOR-based approaches, operate by scrambling the contents of the data field before transmission. Despite providing tangible improvements in several operating conditions, they are unable to ensure that stuff bits are completely prevented in the data field. For this reason, they have not been considered in the following.

More recent solutions, instead, operate by encoding the data field in a suitable way, so that stuff bits can never occur in this part of the frame. This is the case of software bit stuffing (SBS) [12], eight-to-eleven modulation (EEM) [13] and, more recently, 8B9B [4]. A comparison is carried out in this section between VHCC and these approaches. Since EEM and 8B9B are very similar and the second one can be seen as an optimized version of the first, only 8B9B and SBS will be considered.

In principle, other solutions exist that are able to ensure jitter-free communication. In [22] a CAN-like protocol is described, with grounds on the overclocking technique first proposed in [23]. An enhancement of the basic technique is introduced in [22], which exploits a variable-size dummy field (an alternating bit pattern called Data_Plus, located after the CRC) so as to guarantee that the duration of frame transmissions does not depend on the content of the payload, but only on its size. This idea is quite appealing as, unlike the other solutions listed above, it permits to remove BS-jitters altogether (including those caused by stuff bits added to the CRC). More recently CAN-FD [24], which relies on similar concepts, has also been introduced. However, neither their implementation is possible on conventional CAN controllers, nor do these approaches ensure backward compatibility with legacy CAN networks. Thus, they will not be taken into account further.

The comparison among SBS, 8B9B, and VHCC includes maximum payload size, encoding efficiency, execution time, and memory footprint as performance metrics. As said above, the effectiveness of jitter reduction is reasonably the same for these approaches since, in all cases, stuff bits may be inserted only in the CRC. Because of the way the CRC is computed, the same amount of residual jitter could be expected on the average. A thorough evaluation of the jitter reduction capability of 8B9B is included in [5].

When the payload (as seen at the application level) takes an integral number of bytes, 8B9B and VHCC have exactly the same encoding efficiency, whereas SBS behaves slightly worse because of the higher overhead (potentially, up to one software stuff bit may be added every three original bits).

Things change when the payload can take an arbitrary number of bits. Fig. 9
                         shows the size of the data field in the frame sent over the bus for SBS, 8B9B, and VHCC for different sizes of the payload. In order to carry out a fair comparison, a slightly different version of SBS is considered here, called SBS+. This is because SBS was initially conceived for use with the shared-clock (S-C) [25] synchronization mechanism. SBS+ is almost the same as the original one, but, a) it does not encode any additional information in the data field (besides the original payload) and, b) it can also tackle the cases where the original payload is not aligned on a byte boundary.

As can be seen from the figure, VHCC never leads to a larger data field than 8B9B and SBS+. Thus, as expected, it is the optimal choice for achieving low-jitter communication in CAN. VHCC is particularly advantageous over 8B9B when the original payload size is small — which is also the case where the encoding efficiency of the latter was noticeably worse than plain CAN. In these conditions, both VHCC and SBS+ outperform 8B9B for what concerns encoding efficiency. This is because 8B9B was not conceived to deal with sub-byte information: for instance, in order to encode a single bit, two bytes are needed. Conversely, 8B9B excels for large payloads, where it resembles VHCC closely.

The execution time at maximum payload size and code/data footprint of 8B9B, SBS, and VHCC are shown in Table 4
                        . They were taken from published literature [4,12] for 8B9B and SBS, while they were derived from Fig. 8 and Table 3 for VHCC. Regarding VHCC, footprint data have been aggregated to bring them down to the same level of detail as the other methods and simplify the comparison. In particular, the data footprint includes both the constant and variable data segments, as well as the stack space. For the sake of the comparison, it is also assumed that the execution time and footprint of SBS and SBS+ are the same, regardless of the differences between them.

First of all, it is important to remark that a direct comparison among the figures shown in Table 4 is not possible, because the processor cores used in the three cases are not the same and they differ significantly in terms of instruction set and clock speed. In fact, both the LPC 2468 and the LPC 2129 use an ARM7 core (running at different speeds), whereas the LPC 1768 adopts a Cortex-M3 core.

It can however be noted that, despite the noticeable difference in flexibility between the two methods, the VHCC and 8B9B execution times are still comparable, even taking into account the about 40% clock speed difference between the two microcontrollers chosen for the experiments — 100MHz versus 72MHz. Taking this fact into account, the VHCC execution time is roughly equal to the 8B9B execution time with one additional payload byte. This relationship can easily be justified by noticing that the complexity of PS encoding in VHCC is of the same order of magnitude as the encoding of one more full byte in 8B9B.

By contrast, the SBS execution time is significantly higher. This is probably due to the different nature of the SBS algorithm with respect to the others. In fact, the software stuff bit insertion performed by SBS is basically a bit-oriented operation, whereas both 8B9B and VHCC are codeword-oriented algorithms. Moreover, the implementation of both 8B9B and VHCC has been highly optimized, thus imparting additional bias to the comparison.

A somewhat opposite consideration can be done about footprint, though. Albeit the code footprint of SBS and VHCC are close to each other, the data footprint of VHCC is noticeably higher. This is due to its forward and reverse lookup tables, which are not needed by the bit-oriented SBS algorithm. Even if they greatly contribute to the high performance of VHCC in terms of execution time, they put it at a disadvantage in terms of data footprint. However, especially on modern microcontrollers, the extra 384 bytes for the lookup tables are likely an affordable price to be paid for the added performance and flexibility of VHCC.

Going into a more detailed comparison between 8B9B and VHCC – referring back to Table 3 and the additional data presented in [4] – it should be noted that, although the total code size of both the encoder and decoder modules almost doubled when going from one method to the other, most additional instructions are located either in loop setup or in PS handling. Therefore, these instructions are executed just once for each encoding or decoding request and their impact on performance is limited. By contrast, the size of the encoding and decoding loops only increased by about 9% and 12%, respectively. This can easily be justified by considering that:
                           
                              1.
                              The VHCC algorithm uses reduced forward and reverse lookup tables, as discussed in Section 4.2, whereas 8B9B adopted full tables. Although this is very convenient to reduce constant data footprint, it implies a slight code footprint penalty due to the more complex table access mechanism.

The higher complexity of the VHCC algorithm forced the compiler to allocate more registers and stack space for local variables and temporary storage. For this reason, the quality of code generation and optimization related to the loops worsened.

@&#CONCLUSION@&#

The bit stuffing mechanism of CAN implies transmission jitters that may lead to an unwanted (and sometimes unacceptable) worsening in the timing accuracy of distributed real-time control applications. Some recently defined approaches, 8B9B [4] for instance, are aimed at lessening this problem, by preventing stuff bits in the data field.

In this paper, a theoretical foundation has been developed that provides two important benefits: first, it demonstrates that the 8B9B approach is the best choice in its class for what concerns the achievable information rate; second, it allows the fully automatic construction of a family of nested codebooks that supports efficient sub-byte encoding and decoding.

The new codebooks, along with some additional improvements, have been used to bring further notable improvements to the basic encoding scheme previously discussed in literature. The new scheme, called VHCC, is able to make full use of the room available in the data field, yet preserving the ability of completely preventing the occurrence of stuff bits in this field.

Measurements carried out on a prototype implementation of the related software modules show that their execution speed and footprint are still comparable to those achieved in the previous version, although the new enhanced scheme has a better overall encoding efficiency.

@&#REFERENCES@&#

