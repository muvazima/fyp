@&#MAIN-TITLE@&#A fast algorithm for matrix embedding steganography

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           1.
                           A fast matrix embedding algorithm using Hamming code is proposed.


                        
                        
                           2.
                           A fast matrix embedding algorithm using random linear code is proposed.


                        
                        
                           3.
                           The computational complexity is extremely low for low and medium embedding rates.


                        
                        
                           4.
                           The requirement for memory space is low.


                        
                        
                           5.
                           Compared with the existing algorithm, the embedding efficiency maintains the same.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Image steganography

Matrix embedding

Fast algorithm

Hamming code

Random linear code

@&#ABSTRACT@&#


               
               
                  A fast algorithm for matrix embedding steganography is proposed in this paper. Matrix embedding encodes the cover image and the secret message with an error correction code and modifies the cover image according to the coding result. The modification to the cover image is the coset leader of the error correction code, and it is computationally complex to find the coset leader. This paper proposes a fast algorithm to find the coset leader by using a lookup table algorithm. The proposed algorithm is suitable for matrix embedding steganography using Hamming code and random linear code. In our scheme, the syndrome of the coset is used to search for the coset leader in the standard array of the error correction code. For the Hamming code, we improved the parity check matrix of the code in order to make the syndrome indicate the coset leader by itself. Therefore, it is not necessary to search for the coset leader in a table. For the random linear code, this method is effective for most cosets, and we only memorize the coset leaders that cannot be identified by their syndromes. With this approach, the size of the table can be reduced significantly, and the computational complexity of embedding can be decreased. The proposed fast embedding algorithm has the same embedding efficiency as the conventional matrix embedding. Compared with the existing fast matrix embedding algorithms, the computational complexity of the proposed scheme is decreased significantly for the steganographic systems with low and medium embedding rates.
               
            

@&#INTRODUCTION@&#

Digital image steganography is a popular information-hiding technology in which the secret messages are transmitted by being hid in the digital images, which are known as cover images. Using the redundancy of cover images, extensive secret messages can be embedded imperceptibly and transmitted together with the cover images [1]. The presence of the secret messages is imperceptible. Thus, illegal attackers cannot detect the secret messages, but the legal receivers can acquire the secret messages by using an extraction algorithm.

Least-significant-bit (LSB) replacement is a popular steganographic method in which the secret message bits are embedded into the LSBs of the cover images. In spatial-image steganography, the lowest bits of the pixelsʼ gray values usually are chosen for embedding the secret messages in LSB replacement. Therefore, LSB replacement either increases (or decreases) the pixel values by one or leaves them unmodified, after which the lowest bits of the stego image represent the secret messages. In addition, there are many other stego methods, such as EzStego, J-Steg, OutGuess, and F5. All of these methods can transmit secret messages imperceptibly in vision and ensure good quality of the stego images [2–4].

There are two important issues for a steganography scheme, i.e., payload and security. Payload is the quantity of the embedded message in the cover image. The payload can be quantified as the embedding rate, which is the quantity of the embedded bits vs. the quantity of the pixels used for information hiding in the cover image. Security means that the embedded message should be visually and statistically undetectable. Statistical undetectability is more difficult to achieve than visual undetectability because there are many steganographic analytical methods [5–7]. Steganalysis, which was developed soon after steganography was first proposed, is the antithesis of steganography. Steganography imparts some statistical characteristics to the cover images, and these can be used by steganalysis to determine whether any secret messages are embedded in the cover images or not. Clearly, the larger the embedding rate is, the more detectable the stego image is. A good steganography scheme embeds as much information as possible while modifying the cover images as little as possible. To accomplish this, we must improve the embedding efficiency, i.e., embed more information per modification to the cover image [8,9].

Matrix embedding steganography was proposed by Crandall [10] to achieve high embedding efficiency, and this method has been studied extensively [11,12]. In this method, the cover coefficients are perturbed minimally, such that the transmitted bits fall in a coset of the linear code, with the syndrome conveying the hidden bits. Matrix embedding steganography increases embedding efficiency and enhances the security of the steganography with the cost of decreasing the embedding rate. The Hamming codes were initially used for matrix embedding, in which 
                        n
                        −
                        k
                      secret bits are embedded into n cover pixels by an [n, k] Hamming code. Fridrich proposed two novel matrix embedding steganographic schemes using simplex codes and random linear codes, respectively, and both schemes achieved higher embedding rates [13]. Zhang proposed a “Hamming+1” scheme in which 
                        n
                        −
                        k
                        +
                        1
                      secret bits were embedded into n cover pixels in every embedding group [14].

One of the problems associated with matrix embedding is the excessive computational complexity of the embedding process. For a matrix embedding steganographic scheme using an [n, k] block code, the computational complexity is 
                        O
                        (
                        n
                        
                           
                              2
                           
                           
                              k
                           
                        
                        )
                      to find the modification to the cover image for every embedding group, where 
                        O
                        (
                        ⋅
                        )
                      means the number of bit operations [13]. Therefore, to keep the complexity and memory space low, the code dimension k should be small. In order to simplify the computational complexity, Gao et al. chose to find a vector in the coset that had a relatively small Hamming weight instead of finding a coset leader [15]. This scheme decreased the computational complexity at the cost of reducing the embedding efficiency to a certain degree. Chen et al. proposed to use the Walsh spectrum and the fast Hadamard transform to search for the optimal solution in the embedding process with a reduced computational complexity, and they proposed some methods to increase the embedding efficiency in this scheme [16]. Li et al. proposed a scheme that increases the embedding efficiency by a tree structure [17]. Hou et al. improved Liʼs method as a fast matrix embedding algorithm, which decreases the computational complexity of matrix embedding [18]. But compared with the original matrix embedding proposed in [13], both Liʼs algorithm and Houʼs algorithm decreased the embedding efficiency. Wang et al. proposed a fast matrix embedding scheme by extending the parity check matrix of the block code via some referential columns and achieved higher embedding efficiency and faster embedding speed [19].

Recently, the usage of error correction codes for matrix embedding has been extended to convolutional codes. Filler et al. proposed a steganography using trellis-coded quantization [20,21]. In this scheme, the syndrome coding for secret embedding is based on Viterbi algorithm running in the dual domain, which provides an embedding efficiency closing to the upper bound [22].

In this paper, we reduce the computational complexity of matrix embedding further and propose a novel fast algorithm for matrix embedding using Hamming code and random linear code. The proposed scheme has the same embedding efficiency as the conventional matrix embedding, but it has lower computational complexity for steganographic systems with low and medium embedding rates, compared with both the conventional matrix embedding and the trellis-coded quantization scheme. Notice that our goal is not to design a new matrix embedding scheme, but to propose a fast algorithm for matrix embedding using Hamming code and random linear code. The small block size of the code used in our scheme and the extremely low computational complexity make our fast algorithm very suitable for the low-power processors. The paper is organized as follows. In Section 2, some preliminaries are given. In Section 3, the characteristics of the conventional matrix embedding steganography are analyzed. Our novel fast embedding algorithm is proposed in Section 4, and the experimental results are presented in Section 5. Our conclusions and recommendations for future work are presented in Section 6.

Let 
                        
                           
                              F
                           
                           
                              2
                           
                           
                              n
                           
                        
                      denote the Galois field of order 2 and length n; then, 
                        
                           
                              F
                           
                           
                              2
                           
                           
                              n
                           
                        
                      is a space of all n-bit column vectors 
                        x
                        =
                        (
                        
                           
                              x
                           
                           
                              1
                           
                        
                        ,
                        
                           
                              x
                           
                           
                              2
                           
                        
                        ,
                        …
                        ,
                        
                           
                              x
                           
                           
                              n
                           
                        
                        )
                     . The Hamming weight 
                        w
                        (
                        x
                        )
                      of vector x is defined as the number of ones in x. A binary linear [n, k] code 
                        C
                      of length n and dimension k is a k-dimensional linear sub-space of 
                        
                           
                              F
                           
                           
                              2
                           
                           
                              n
                           
                        
                     , in which the sum of two vectors and a multiplication of a vector by a scalar are defined using the usual binary arithmetics. Let m denote the message of length k, and 
                        m
                        ∈
                        
                           
                              F
                           
                           
                              2
                           
                           
                              k
                           
                        
                     . The mapping from any message m to the codeword c is called an encoding of 
                        C
                      by means of the generator matrix G, which is
                        
                           (1)
                           
                              c
                              =
                              m
                              G
                              ,
                           
                        
                      where the generator matrix G is a k-by-n matrix whose rows are basis vectors of code 
                        C
                     . The orthogonal complement of an [n, k] code is an [n, 
                        n
                        −
                        k
                     ] code with an 
                        (
                        n
                        −
                        k
                        )
                        ×
                        n
                      generator matrix H with the property that 
                        H
                        c
                        =
                        0
                      for each 
                        c
                        ∈
                        C
                     . This [n, 
                        n
                        −
                        k
                     ] code is called the dual code of 
                        C
                     , and the matrix H is called the parity check matrix of code 
                        C
                     .

For any vector 
                        x
                        ∈
                        
                           
                              F
                           
                           
                              2
                           
                           
                              n
                           
                        
                     , the vector 
                        s
                        =
                        H
                        x
                      is called the syndrome of x. Note that 
                        s
                        ∈
                        
                           
                              F
                           
                           
                              2
                           
                           
                              n
                              −
                              k
                           
                        
                     , and 
                        x
                        ∈
                        C
                      if and only if the syndrome of x is 0. For each syndrome s, the set 
                        E
                        (
                        s
                        )
                        =
                        {
                        x
                        ∈
                        
                           
                              F
                           
                           
                              2
                           
                           
                              n
                           
                        
                        |
                        H
                        x
                        =
                        s
                        }
                      is defined as a coset. For an [n, k] linear code, there are 
                        
                           
                              2
                           
                           
                              n
                              −
                              k
                           
                        
                      disjoint cosets, each consisting of 
                        
                           
                              2
                           
                           
                              k
                           
                        
                      vectors. Among these vectors, the one that has the smallest Hamming weight is called a coset leader and is denoted as 
                        
                           
                              e
                           
                           
                              L
                           
                        
                        (
                        s
                        )
                     . For a linear code 
                        C
                     , there is a standard array that denotes all its cosets, as shown in Table 1
                     .

In Table 1, the first row of the array consists of all the codewords of 
                        C
                     . To form the second row, we choose a word 
                        
                           
                              e
                           
                           
                              1
                           
                        
                      with smallest Hamming weight that is not in the first row. Then we add 
                        
                           
                              e
                           
                           
                              1
                           
                        
                      to each word of the first row and get the second row, which is the first coset. In general, the ith row of the standard array is formed by choosing a word 
                        
                           
                              e
                           
                           
                              i
                           
                        
                      with smallest weight that is not yet in the array and adding it to each word of the first row. This process continues until the array contains all the words in 
                        
                           
                              F
                           
                           
                              2
                           
                           
                              n
                           
                        
                     . The vectors in the first column of the standard array are the coset leaders.

Digital image steganography modifies the gray value of the selected pixel in the cover image X according to the value of the secret message M, so that the stego image Y conveys M. Suppose that I and 
                        M
                      are the sets of all possible values of the cover image and the secret message, respectively. In order to embed the secret message into the cover image, the transmitter needs a bit-assignment function, Emb, to generate the stego image Y. At the receiver side, the recipient gets the embedded information 
                        
                           
                              M
                           
                           
                              ′
                           
                        
                      by an extraction function, Ext.
                        
                           (2)
                           
                              Y
                              =
                              Emb
                              (
                              X
                              ,
                              M
                              )
                              ,
                           
                        
                     
                     
                        
                           (3)
                           
                              
                                 
                                    M
                                 
                                 
                                    ′
                                 
                              
                              =
                              Ext
                              (
                              Y
                              )
                              .
                           
                        
                     
                  

Suppose that 
                        
                           
                              l
                           
                           
                              m
                           
                        
                      message elements are embedded into 
                        
                           
                              l
                           
                           
                              c
                              1
                           
                        
                      cover elements by modifying 
                        
                           
                              l
                           
                           
                              c
                              2
                           
                        
                      cover elements in an embedding process; then, the embedding rate, ER, and the embedding efficiency, EE, are defined as:
                        
                           (4)
                           
                              
                                 ER
                              
                              =
                              
                                 
                                    
                                       l
                                    
                                    
                                       m
                                    
                                 
                                 
                                    
                                       l
                                    
                                    
                                       c
                                       1
                                    
                                 
                              
                              ,
                           
                        
                     
                     
                        
                           (5)
                           
                              
                                 EE
                              
                              =
                              
                                 
                                    
                                       l
                                    
                                    
                                       m
                                    
                                 
                                 
                                    
                                       l
                                    
                                    
                                       c
                                       2
                                    
                                 
                              
                              .
                           
                        
                     
                  

One of the most popular bit-assignment functions for steganography is the least-significant-bit (LSB) replacement. In this method, the lowest bits of the chosen pixelsʼ values in the cover image are used to indicate the message bits. When embedding, if the LSB of the cover pixel is the same as that of the message bit, the gray value remains unchanged. If they are different, add 1 (or minus 1) to the cover pixel. At the receiver side, the recipient extracts the embedded message by reading the lowest bits of the chosen pixels in the stego image Y. The embedding and extracting processes are denoted as the following:
                        
                           (6)
                           
                              y
                              (
                              i
                              ,
                              j
                              )
                              =
                              Emb
                              
                                 (
                                 x
                                 (
                                 i
                                 ,
                                 j
                                 )
                                 ,
                                 m
                                 (
                                 l
                                 )
                                 )
                              
                              =
                              
                                 {
                                 
                                    
                                       
                                          x
                                          (
                                          i
                                          ,
                                          j
                                          )
                                          ,
                                       
                                       
                                          if 
                                          m
                                          (
                                          l
                                          )
                                          =
                                          x
                                          (
                                          i
                                          ,
                                          j
                                          )
                                          
                                          
                                             mod
                                          
                                          
                                          2
                                          ,
                                       
                                    
                                    
                                       
                                          x
                                          (
                                          i
                                          ,
                                          j
                                          )
                                          ±
                                          1
                                          ,
                                       
                                       
                                          if 
                                          m
                                          (
                                          l
                                          )
                                          ≠
                                          x
                                          (
                                          i
                                          ,
                                          j
                                          )
                                          
                                          
                                             mod
                                          
                                          
                                          2
                                          ,
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (7)
                           
                              
                                 
                                    m
                                 
                                 
                                    ′
                                 
                              
                              (
                              l
                              )
                              =
                              Ext
                              
                                 (
                                 y
                                 (
                                 i
                                 ,
                                 j
                                 )
                                 )
                              
                              =
                              y
                              (
                              i
                              ,
                              j
                              )
                              
                              
                                 mod
                              
                              
                              2
                              ,
                           
                        
                      where 
                        x
                        (
                        i
                        ,
                        j
                        )
                      and 
                        y
                        (
                        i
                        ,
                        j
                        )
                      are the gray values of the pixels in position 
                        (
                        i
                        ,
                        j
                        )
                      in the cover image and the stego image, respectively, and 
                        m
                        (
                        l
                        )
                      and 
                        
                           
                              m
                           
                           
                              ′
                           
                        
                        (
                        l
                        )
                      are the lth bit in the secret message stream and the extracted message stream, respectively. And 
                        (
                        x
                        
                        
                           mod
                        
                        
                        2
                        )
                      is the remainder of 
                        (
                        x
                        /
                        2
                        )
                     .

It is apparent that for the LSB replacement, the highest embedding rate ER is 1, when every pixel in the cover image has a secret bit embedded. And the embedding efficiency EE of the LSB replacement is 2. To reduce the influence of the embedded message on the cover image and make the hiding less detectable, matrix embedding steganography was proposed by researchers. In this method, 
                        n
                        −
                        k
                      message bits are embedded into n cover image pixels by an [n, k] block code 
                        C
                     , of which parity check matrix is H. In the matrix embedding process, first, the transmitter reads the LSBs of n pixels in the cover image (denoted as vector x) and 
                        n
                        −
                        k
                      message bits (denoted as vector m), which are defined as an embedding group. Then, the coset leader of the coset 
                        E
                        (
                        m
                        −
                        H
                        x
                        )
                      is found and added to x. By this means, the stego image is achieved. The embedding process is indicated as the following:
                        
                           (8)
                           
                              y
                              =
                              Emb
                              (
                              x
                              ,
                              m
                              )
                              =
                              x
                              +
                              
                                 
                                    e
                                 
                                 
                                    L
                                 
                              
                              (
                              m
                              −
                              H
                              x
                              )
                              ,
                           
                        
                      where 
                        
                           
                              e
                           
                           
                              L
                           
                        
                        (
                        m
                        −
                        H
                        x
                        )
                      is the coset leader of which syndrome is 
                        m
                        −
                        H
                        x
                     . This coset leader is the modification to the cover vector. By adding 
                        
                           
                              e
                           
                           
                              L
                           
                        
                        (
                        m
                        −
                        H
                        x
                        )
                      to the cover vector x, the stego vector y is achieved.

At the receiver side, since 
                        H
                        y
                        =
                        H
                        (
                        x
                        +
                        
                           
                              e
                           
                           
                              L
                           
                        
                        (
                        m
                        −
                        H
                        x
                        )
                        )
                        =
                        H
                        x
                        +
                        m
                        −
                        H
                        x
                        =
                        m
                     , the extracted message 
                        
                           
                              m
                           
                           
                              ′
                           
                        
                      is obtained by
                        
                           (9)
                           
                              
                                 
                                    m
                                 
                                 
                                    ′
                                 
                              
                              =
                              Ext
                              (
                              y
                              )
                              =
                              H
                              y
                              .
                           
                        
                     
                  

The average changes, AC, to the cover image for an embedding group are equal to the average weight of all the coset leaders of the block code 
                        C
                     , as shown in the following
                        
                           (10)
                           
                              
                                 AC
                              
                              =
                              
                                 1
                                 
                                    
                                       2
                                    
                                    
                                       n
                                       −
                                       k
                                    
                                 
                              
                              
                                 ∑
                                 
                                    i
                                    =
                                    1
                                 
                                 
                                    
                                       2
                                    
                                    
                                       n
                                       −
                                       k
                                    
                                 
                              
                              w
                              
                                 (
                                 
                                    
                                       e
                                    
                                    
                                       L
                                       ,
                                       i
                                    
                                 
                                 (
                                 s
                                 )
                                 )
                              
                              ,
                           
                        
                      where 
                        
                           
                              e
                           
                           
                              L
                              ,
                              i
                           
                        
                        (
                        s
                        )
                      is the coset leader of the ith coset of which syndrome is 
                        s
                        (
                        i
                        =
                        1
                        ,
                        …
                        ,
                        n
                        −
                        k
                        )
                     .

Therefore, the embedding rate, ER, and the embedding efficiency, EE, of the matrix embedding scheme using an [n, k] block code are:
                        
                           (11)
                           
                              
                                 ER
                              
                              =
                              
                                 
                                    n
                                    −
                                    k
                                 
                                 n
                              
                              ,
                           
                        
                     
                     
                        
                           (12)
                           
                              
                                 EE
                              
                              =
                              
                                 
                                    n
                                    −
                                    k
                                 
                                 
                                    AC
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          2
                                       
                                       
                                          n
                                          −
                                          k
                                       
                                    
                                    (
                                    n
                                    −
                                    k
                                    )
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          
                                             
                                                2
                                             
                                             
                                                n
                                                −
                                                k
                                             
                                          
                                       
                                    
                                    w
                                    (
                                    
                                       
                                          e
                                       
                                       
                                          L
                                          ,
                                          i
                                       
                                    
                                    (
                                    s
                                    )
                                    )
                                 
                              
                              .
                           
                        
                     
                  

Embedding rate is also defined as relative payload in some literatures. There is an asymptotic boundary of embedding efficiency [13], which is
                        
                           (13)
                           
                              
                                 EE
                              
                              ⩽
                              
                                 
                                    ER
                                 
                                 
                                    
                                       
                                          H
                                       
                                       
                                          −
                                          1
                                       
                                    
                                    (
                                    
                                       ER
                                    
                                    )
                                 
                              
                              ,
                           
                        
                      where 
                        H
                        (
                        x
                        )
                        =
                        −
                        x
                        
                           
                              log
                           
                           
                              2
                           
                        
                        
                        x
                        −
                        (
                        1
                        −
                        x
                        )
                        
                           
                              log
                           
                           
                              2
                           
                        
                        (
                        1
                        −
                        x
                        )
                     , 
                        0
                        ⩽
                        x
                        ⩽
                        0.5
                     , is the binary entropy function.

In the matrix embedding algorithm using an [n, k] linear block code, one of the biggest challenges is to find the coset leader, 
                        
                           
                              e
                           
                           
                              L
                           
                        
                        (
                        m
                        −
                        H
                        x
                        )
                     , in (8). The transmitter must solve a system of 
                        n
                        −
                        k
                      linear equations with n unknowns in 
                        
                           
                              F
                           
                           
                              2
                           
                           
                              n
                           
                        
                     , therefore the computational complexity is high. Ref. [13] proposed a fast algorithm to find 
                        
                           
                              e
                           
                           
                              L
                           
                        
                        (
                        m
                        −
                        H
                        x
                        )
                     , which has a lower computational complexity, CC, for each embedding bit:
                        
                           (14)
                           
                              
                                 CC
                              
                              =
                              O
                              
                                 (
                                 
                                    
                                       n
                                       
                                          
                                             2
                                          
                                          
                                             k
                                          
                                       
                                    
                                    
                                       n
                                       −
                                       k
                                    
                                 
                                 )
                              
                              .
                           
                        
                     
                  

From (14) we can see that the computational complexity of the existing method exponentially increases with the number of k. Since the embedding rate, ER, is proportional to 
                        n
                        −
                        k
                     , the higher the ER, the lower the computational complexity will be with a given n. But the steganography with low or medium embedding rate, which basically creates stego images with higher quality, is needed in some applications. But for the existing algorithm of matrix embedding, the computational complexity is extremely high when the embedding rate is low or medium, which can be seen from (11) and (14).

In this section, we propose a fast embedding algorithm to find the coset leader for matrix embedding steganography using Hamming code. We assumed that the cover image X was gray-value images for which the range of pixel values was 
                           [
                           0
                           ,
                           255
                           ]
                         and that the secret message M was a bit stream. When embedding a secret message using an [n, k] block code 
                           C
                        , we achieved the stego image by (8). Since the value 
                           
                              
                                 e
                              
                              
                                 L
                              
                           
                           (
                           m
                           −
                           H
                           x
                           )
                         is the coset leader with syndrome 
                           m
                           −
                           H
                           x
                        , we constructed the standard array of the code 
                           C
                         and searched for the coset leader according to 
                           m
                           −
                           H
                           x
                         in the standard array. Since there are 
                           
                              
                                 2
                              
                              
                                 n
                                 −
                                 k
                              
                           
                         cosets of the [n, k] code 
                           C
                         and every coset has an (
                           n
                           −
                           k
                        )-bit syndrome, finding the coset leader requires 
                           O
                           (
                           (
                           n
                           −
                           k
                           )
                           
                              
                                 2
                              
                              
                                 n
                                 −
                                 k
                              
                           
                           )
                         computational complexity, at most.

Take the [7,4] Hamming code as an example. The parity check matrix H is:
                           
                              (15)
                              
                                 H
                                 =
                                 
                                    [
                                    
                                       
                                          
                                             1
                                          
                                          
                                             0
                                          
                                          
                                             0
                                          
                                          
                                             1
                                          
                                          
                                             1
                                          
                                          
                                             0
                                          
                                          
                                             1
                                          
                                       
                                       
                                          
                                             0
                                          
                                          
                                             1
                                          
                                          
                                             0
                                          
                                          
                                             1
                                          
                                          
                                             0
                                          
                                          
                                             1
                                          
                                          
                                             1
                                          
                                       
                                       
                                          
                                             0
                                          
                                          
                                             0
                                          
                                          
                                             1
                                          
                                          
                                             0
                                          
                                          
                                             1
                                          
                                          
                                             1
                                          
                                          
                                             1
                                          
                                       
                                    
                                    ]
                                 
                                 .
                              
                           
                        
                     

All the cosets of this Hamming code are shown in Table 2
                        . This table shows the syndromes and the coset leaders of all the 23 cosets of the [7,4] Hamming code 
                           C
                         with the parity check matrix H.

Assume that for an embedding group, the cover vector is 
                           x
                           =
                           [
                           
                              
                                 
                                    0
                                    
                                    0
                                    
                                    0
                                    
                                    0
                                    
                                    0
                                    
                                    0
                                    
                                    0
                                 
                              
                           
                           ]
                        , and that the secret message is 
                           m
                           =
                           [
                           
                              
                                 
                                    1
                                    
                                    0
                                    
                                    0
                                 
                              
                           
                           ]
                        ; then, 
                           m
                           −
                           H
                           x
                           =
                           [
                           
                              
                                 
                                    1
                                    
                                    0
                                    
                                    0
                                 
                              
                           
                           ]
                        . Taking vector 
                           [
                           1
                           
                           0
                           
                           0
                           ]
                         as the syndrome to look up the coset leader in Table 2, we find that 
                           
                              
                                 e
                              
                              
                                 L
                              
                           
                           (
                           m
                           −
                           H
                           x
                           )
                           =
                           [
                           
                              
                                 
                                    1
                                    
                                    0
                                    
                                    0
                                    
                                    0
                                    
                                    0
                                    
                                    0
                                    
                                    0
                                 
                              
                           
                           ]
                        . Then the stego vector y is:
                           
                              
                                 y
                                 =
                                 x
                                 +
                                 
                                    
                                       e
                                    
                                    
                                       L
                                    
                                 
                                 (
                                 m
                                 −
                                 H
                                 x
                                 )
                                 =
                                 
                                    [
                                    
                                       
                                          
                                             0
                                          
                                          
                                             0
                                          
                                          
                                             0
                                          
                                          
                                             0
                                          
                                          
                                             0
                                          
                                          
                                             0
                                          
                                          
                                             0
                                          
                                       
                                    
                                    ]
                                 
                                 +
                                 
                                    [
                                    
                                       
                                          
                                             1
                                          
                                          
                                             0
                                          
                                          
                                             0
                                          
                                          
                                             0
                                          
                                          
                                             0
                                          
                                          
                                             0
                                          
                                          
                                             0
                                          
                                       
                                    
                                    ]
                                 
                                 =
                                 
                                    [
                                    
                                       (
                                       
                                          
                                             
                                                1
                                             
                                             
                                                0
                                             
                                             
                                                0
                                             
                                             
                                                0
                                             
                                             
                                                0
                                             
                                             
                                                0
                                             
                                             
                                                0
                                             
                                          
                                       
                                       )
                                    
                                    ]
                                 
                                 .
                              
                           
                        
                     

At the receiver side, the embedded message is extracted by:
                           
                              
                                 
                                    
                                       m
                                    
                                    
                                       ′
                                    
                                 
                                 =
                                 Ext
                                 (
                                 y
                                 )
                                 =
                                 H
                                 y
                                 =
                                 
                                    [
                                    
                                       
                                          
                                             1
                                          
                                          
                                             0
                                          
                                          
                                             0
                                          
                                       
                                    
                                    ]
                                 
                                 .
                              
                           
                        
                     

The lookup table method proposed above can be simplified further. The simplification is based on the following two criterions:
                           
                              •
                              The syndromes and their coset leaders are one-to-one correspondent.

Changing the positions of any two columns of the parity check matrix H doesnʼt change the characteristics of the Hamming code.

Now, we can simplify the embedding algorithm using these two criterions. First, we change the positions of the columns in H to make all columns array in ascending (or descending) order in decimal form. Since the columns of the parity check matrix H of a Hamming code run over all the possible arrays of 0 and 1 (except 
                           [
                           0
                           
                           0
                           
                           0
                           ]
                        ), we can make the decimal forms of matrix Hʼs column run from 1 to 
                           
                              
                                 2
                              
                              
                                 n
                                 −
                                 k
                              
                           
                           −
                           1
                        . By this means, the syndromes themselves indicate the coset leaders, and we donʼt have to memorize them in the table.

Taking the above [7,4] Hamming code as an example, in our proposed fast embedding algorithm, first, we modify (15) to the following form:
                           
                              (16)
                              
                                 
                                    
                                       H
                                    
                                    
                                       em
                                    
                                 
                                 =
                                 
                                    [
                                    
                                       
                                          
                                             0
                                          
                                          
                                             0
                                          
                                          
                                             0
                                          
                                          
                                             1
                                          
                                          
                                             1
                                          
                                          
                                             1
                                          
                                          
                                             1
                                          
                                       
                                       
                                          
                                             0
                                          
                                          
                                             1
                                          
                                          
                                             1
                                          
                                          
                                             0
                                          
                                          
                                             0
                                          
                                          
                                             1
                                          
                                          
                                             1
                                          
                                       
                                       
                                          
                                             1
                                          
                                          
                                             0
                                          
                                          
                                             1
                                          
                                          
                                             0
                                          
                                          
                                             1
                                          
                                          
                                             0
                                          
                                          
                                             1
                                          
                                       
                                    
                                    ]
                                 
                                 .
                              
                           
                        
                     

It is apparent that the decimal forms of all the columns in H
                        em change from 1 to 7 (from left to right). The syndromes and the coset leaders of this new code are shown in Table 3
                        .

From Table 3, it can be seen that, if the syndrome is transformed into the decimal form e, the eth bit (from left to right) in its coset leader is 1, and all the others are zeroes. This means that the eth bit in the cover vector x should be changed and that all the others should be unchanged. By this means, we embed the secret messages only according to the syndromes and donʼt have to maintain the table about the cosets of the code 
                           C
                        . For example, assume that the cover vector is 
                           x
                           =
                           [
                           0
                           
                           0
                           
                           0
                           
                           0
                           
                           0
                           
                           0
                           
                           0
                           ]
                         and the secret message is 
                           m
                           =
                           [
                           1
                           
                           0
                           
                           0
                           ]
                        ; then, 
                           m
                           −
                           H
                           x
                           =
                           [
                           1
                           
                           0
                           
                           0
                           ]
                        . Since 
                           [
                           1
                           
                           0
                           
                           0
                           ]
                         is 4 in the decimal form, the 4th bit in x should be changed. Therefore, the stego vector is 
                           y
                           =
                           [
                           0
                           
                           0
                           
                           0
                           
                           1
                           
                           0
                           
                           0
                           
                           0
                           ]
                        . At the receiver side, the extracted vector is 
                           
                              
                                 m
                              
                              
                                 ′
                              
                           
                           =
                           H
                           y
                           =
                           [
                           1
                           
                           0
                           
                           0
                           ]
                        . By this means, the secret message is embedded and extracted correctly, and the computational complexity is low.

The embedding process of our fast matrix embedding algorithm using Hamming code is shown as the following:
                           
                              1.
                              In order to embed 
                                    n
                                    −
                                    k
                                  secret message bits into n pixels in the cover image, find an [n, k] Hamming code for which the parity check matrix is H.

Change the positions of the columns in H to make all the columns arrange in ascending (or descending) order in decimal form.

Take the next n pixels in the cover image, get the lowest bits of their gray values, and denote them as vector x. Read the next 
                                    n
                                    −
                                    k
                                  secret message bits and denote them as vector m. Compute 
                                    m
                                    −
                                    H
                                    x
                                 .

Transform 
                                    m
                                    −
                                    H
                                    x
                                  into a decimal number e.

Change the lowest bits of the eth pixelʼs gray value among the n cover pixels, and keep the others unchanged. Then, the stego vector is achieved.

The extracting process at the receiver side takes the next n pixels in the stego image, get the lowest bits of the pixelsʼ gray values, and denote them as vector y. Then, the extracted secret vector is 
                           
                              
                                 m
                              
                              
                                 ′
                              
                           
                           =
                           Ext
                           (
                           y
                           )
                           =
                           H
                           y
                        .

The embedding rate, ER, and the embedding efficiency, EE, of our fast algorithm are same as the conventional matrix embedding algorithm using Hamming code, since the coset leaders in our fast algorithm is totally the same as those in the conventional algorithm. Therefore, ER and EE are shown as (11) and (12), respectively. Since the weight of every coset leader of the Hamming code is 1, the embedding efficiency, EE, of our fast algorithm can be denoted as the following:
                           
                              (17)
                              
                                 
                                    EE
                                 
                                 =
                                 
                                    
                                       n
                                       −
                                       k
                                    
                                    
                                       
                                          1
                                          
                                             
                                                2
                                             
                                             
                                                n
                                                −
                                                k
                                             
                                          
                                       
                                       (
                                       
                                          
                                             2
                                          
                                          
                                             n
                                             −
                                             k
                                          
                                       
                                       −
                                       1
                                       )
                                    
                                 
                                 =
                                 
                                    
                                       (
                                       n
                                       −
                                       k
                                       )
                                       ⋅
                                       
                                          
                                             2
                                          
                                          
                                             n
                                             −
                                             k
                                          
                                       
                                    
                                    
                                       
                                          
                                             2
                                          
                                          
                                             n
                                             −
                                             k
                                          
                                       
                                       −
                                       1
                                    
                                 
                                 .
                              
                           
                        
                     

The fast embedding algorithm proposed above does not depend on a lookup table algorithm or solving equations, so the computational complexity to find the coset leader is 
                           O
                           (
                           1
                           )
                        , which means a constant complexity regardless of the input size.

Matrix embedding steganography using Hamming code has a high embedding efficiency but a low embedding rate. In order to achieve a high embedding rate, many studies have sought to find some other linear block codes for matrix embedding. In Ref. [13], an embedding scheme was proposed that used random linear codes. A random linear code is a kind of block error correction codes that has the parity check matrix 
                           H
                           =
                           [
                           
                              
                                 I
                              
                              
                                 n
                                 −
                                 k
                              
                           
                           ,
                           D
                           ]
                        , where 
                           
                              
                                 I
                              
                              
                                 n
                                 −
                                 k
                              
                           
                         is an 
                           (
                           n
                           −
                           k
                           )
                           ×
                           (
                           n
                           −
                           k
                           )
                         identity matrix, and D is an 
                           (
                           n
                           −
                           k
                           )
                           ×
                           k
                         matrix, the elements of which are pseudo-randomly chosen from 
                           
                              
                                 F
                              
                              
                                 2
                              
                           
                        . Random linear codes achieve the bound asymptotically (13) 
                        [23], and they have flexible coding rates. Therefore, we can achieve any embedding rate by constructing a random linear code with proper coding rate and small block size for matrix embedding steganography. A small block size is important for decreasing the computational complexity.

But when the parity check matrix H is a pseudo-random matrix, finding the coset leader is a Nondeterministic Polynomial (NP) question. Therefore, Fridrich proposed a simpler method to find the coset leader for embedding process [13]. In this method, for the matrix embedding scheme using an [n, k] random linear code, the average computational complexity for every embedding bit is shown as (14).

In this section, we propose a novel fast embedding algorithm for the random linear codes. Although the parity check matrix of the random linear code lacks the perfect structures of Hamming code, we can still use the syndrome to search for the coset leader 
                           
                              
                                 e
                              
                              
                                 L
                              
                           
                           (
                           m
                           −
                           H
                           x
                           )
                         in the standard array and achieve the stego image by (8). For the random linear code, since there is an identity matrix in its parity check matrix H, some coset leaders can be denoted by the syndromes themselves. Assuming that the syndrome is vector s, its coset leader 
                           
                              
                                 e
                              
                              
                                 L
                              
                           
                         may be:
                           
                              (18)
                              
                                 
                                    
                                       e
                                    
                                    
                                       L
                                    
                                 
                                 =
                                 
                                    [
                                    
                                       
                                          
                                             s
                                          
                                          
                                             0
                                          
                                       
                                    
                                    ]
                                 
                                 ,
                              
                           
                         where 
                           s
                           =
                           m
                           −
                           H
                           x
                         and 0 is a 
                           1
                           ×
                           k
                         vector the elements of which are all zeroes. Therefore, we do not have to memorize all the coset leaders. For some cosets of which the coset leaders can be denoted by (18), we use the syndromes to indicate the coset leaders; and for the others, we memorize the coset leaders and their syndromes in a table. By this means, the size of the table for finding the coset leader is decreased.

Assume that the number of the cosets of which the coset leaders cannot be indicated by their syndromes is p, then, there should be p syndromes in the table. Since every syndrome is an (
                           n
                           −
                           k
                        )-bits vector, the computational complexity of searching for the coset leader is 
                           p
                           ×
                           (
                           n
                           −
                           k
                           )
                        . While for the rest 
                           
                              
                                 2
                              
                              
                                 n
                                 −
                                 k
                              
                           
                           −
                           p
                         cosets, the syndromes indicate their coset leaders by themselves and we donʼt have to search for them in the table. Therefore, the average computational complexity of each embedded bit in our fast algorithm is:
                           
                              (19)
                              
                                 
                                    CC
                                 
                                 =
                                 O
                                 
                                    (
                                    
                                       
                                          p
                                          (
                                          n
                                          −
                                          k
                                          )
                                       
                                       
                                          n
                                          −
                                          k
                                       
                                    
                                    )
                                 
                                 =
                                 O
                                 (
                                 p
                                 )
                                 .
                              
                           
                         Taking an [8,2] random linear code as an example, the parity check matrix, 
                           
                              
                                 H
                              
                              
                                 6
                                 ⁎
                                 8
                              
                           
                        , is:
                           
                              
                                 
                                    
                                       H
                                    
                                    
                                       6
                                       ⁎
                                       8
                                    
                                 
                                 =
                                 
                                    [
                                    
                                       
                                          
                                             1
                                          
                                          
                                             0
                                          
                                          
                                             0
                                          
                                          
                                             0
                                          
                                          
                                             0
                                          
                                          
                                             0
                                          
                                          
                                             1
                                          
                                          
                                             0
                                          
                                       
                                       
                                          
                                             0
                                          
                                          
                                             1
                                          
                                          
                                             0
                                          
                                          
                                             0
                                          
                                          
                                             0
                                          
                                          
                                             0
                                          
                                          
                                             0
                                          
                                          
                                             0
                                          
                                       
                                       
                                          
                                             0
                                          
                                          
                                             0
                                          
                                          
                                             1
                                          
                                          
                                             0
                                          
                                          
                                             0
                                          
                                          
                                             0
                                          
                                          
                                             1
                                          
                                          
                                             1
                                          
                                       
                                       
                                          
                                             0
                                          
                                          
                                             0
                                          
                                          
                                             0
                                          
                                          
                                             1
                                          
                                          
                                             0
                                          
                                          
                                             0
                                          
                                          
                                             1
                                          
                                          
                                             1
                                          
                                       
                                       
                                          
                                             0
                                          
                                          
                                             0
                                          
                                          
                                             0
                                          
                                          
                                             0
                                          
                                          
                                             1
                                          
                                          
                                             0
                                          
                                          
                                             0
                                          
                                          
                                             0
                                          
                                       
                                       
                                          
                                             0
                                          
                                          
                                             0
                                          
                                          
                                             0
                                          
                                          
                                             0
                                          
                                          
                                             0
                                          
                                          
                                             1
                                          
                                          
                                             0
                                          
                                          
                                             1
                                          
                                       
                                    
                                    ]
                                 
                                 .
                              
                           
                        
                     

The cosets of this [8,2] random linear code are shown as Table 4
                        . This table lists the syndromes and their coset leaders of all the cosets, and it shows that most coset leaders can be indicated by (18). Only those marked coset leaders cannot be indicated by their syndromes, so we only memorize these cosets in a table. By this means, the size of the table can be decreased significantly. In addition, since the coset leaders found by the simplified table are the same as that found by the standard array, the embedding efficiency of our fast algorithm is the same as that of the conventional matrix embedding.

The embedding process of our fast algorithm using random linear code is shown as the following:
                           
                              1.
                              Choose the proper size 
                                    n
                                    −
                                    k
                                  of the secret message and the proper size n of the cover vector of an embedding group, according to the embedding rate ER.

Construct the parity check matrix H of an [n, k] systematic random linear code 
                                    
                                       
                                          C
                                       
                                       
                                          R
                                       
                                    
                                 .

Find the syndromes and the coset leaders of all the cosets. Separate these cosets into two parts. The first part includes those of which the coset leaders can be indicated by (18). The second part includes the rest of the cosets. Memorize the syndromes and the coset leaders of the second part in a table.

Take the next n pixels in the cover image, get the lowest bits of their gray values and denote them as vector x. Read the next 
                                    n
                                    −
                                    k
                                  secret message bits and denote them as vector m. Compute 
                                    m
                                    −
                                    H
                                    x
                                 .

If 
                                    m
                                    −
                                    H
                                    x
                                  belongs to the first coset part, the modification to the cover vector is 
                                    
                                       
                                          e
                                       
                                       
                                          L
                                       
                                    
                                    (
                                    m
                                    −
                                    H
                                    x
                                    )
                                    =
                                    [
                                    s
                                    
                                    0
                                    ]
                                 , where 
                                    s
                                    =
                                    m
                                    −
                                    H
                                    x
                                  and 0 is a 
                                    1
                                    ×
                                    k
                                  vector whose elements are all zeroes, therefore, the stego vector is 
                                    y
                                    =
                                    x
                                    +
                                    
                                       
                                          e
                                       
                                       
                                          L
                                       
                                    
                                    (
                                    m
                                    −
                                    H
                                    x
                                    )
                                    =
                                    x
                                    +
                                    [
                                    s
                                    
                                    0
                                    ]
                                 . If 
                                    m
                                    −
                                    H
                                    x
                                  belongs to the second coset part, find 
                                    
                                       
                                          e
                                       
                                       
                                          L
                                       
                                    
                                    (
                                    m
                                    −
                                    H
                                    x
                                    )
                                  in the table and add it to the cover vector.

The extracting algorithm at the receiver side is 
                           
                              
                                 m
                              
                              
                                 ′
                              
                           
                           =
                           Ext
                           (
                           y
                           )
                           =
                           H
                           y
                        . The embedding rate, ER, and the embedding efficiency, EE, of our fast algorithm are the same as those of the conventional algorithm, as shown by (11) and (12), respectively. The computational complexity, CC, of our fast algorithm depends on the number, p, of the cosets that should be memorized in the table. The smaller p is, the lower CC is, shown as (19).

An [n, k] Hamming codes is defined as 
                           n
                           =
                           
                              
                                 2
                              
                              
                                 n
                                 −
                                 k
                              
                           
                           −
                           1
                        . For an [n, k] Hamming code, there are n columns in its parity check matrix H and these columns run over all the 
                           n
                           −
                           k
                        -length vectors consisting of 0 and 1 (except the all-zero vector). Since 
                           n
                           =
                           
                              
                                 2
                              
                              
                                 n
                                 −
                                 k
                              
                           
                           −
                           1
                         for the Hamming code, it is completely possible to use the columns of H to denote all of the decimal numbers varying from 1 to n by permuting the columns. By this means, all of the 
                           
                              
                                 2
                              
                              
                                 n
                                 −
                                 k
                              
                           
                         coset leaders, which represent the distortion patterns to the cover vector in matrix embedding algorithm, can be directly denoted by the syndromes, 
                           m
                           −
                           H
                           x
                        . Therefore, the proposed scheme provides exactly the same embedding effect as the conventional matrix embedding algorithm using the Hamming codes.

For the proposed fast algorithm using the random linear code, if a coset satisfies (18), then, the coset leader can be directly deduced by its syndrome. Therefore, this coset can be removed from the standard array. If a coset does not satisfy (18), its coset leader and syndrome should be recorded in the table. This algorithm makes sure that the coset leader found by the simplified table is the same as that found by the standard array, therefore, the embedding efficiency maintains constant. The proposed scheme is applicable for the random linear code at the cost of maintaining a shortened standard array.

When a large embedding rate is required, the [n, k] random linear code with the condition that 
                           n
                           ≫
                           k
                         will be used for embedding. For the proposed fast algorithm using the random linear code, the computation complexity depends on the amount of the cosets that do not satisfy (18). The more the cosets the random linear code has, the larger the table will be. Since the [n, k] random linear code has 
                           
                              
                                 2
                              
                              
                                 n
                                 −
                                 k
                              
                           
                         cosets, the large embedding rate will lead to increased computation complexity. Therefore, the proposed fast matrix embedding algorithm using the random linear code is more suitable for low and medium embedding rates, which is more secure from the point of view of the steganalysis.

@&#EXPERIMENTAL RESULTS@&#

In this section, we compare the proposed fast embedding algorithm with some existing fast algorithms of matrix embedding steganography. For the conventional matrix embedding using the [n, k] block code, all the 
                           
                              
                                 2
                              
                              
                                 n
                                 −
                                 k
                              
                           
                         cosets should be searched and the computational complexity for each embedded bit is 
                           O
                           (
                           
                              
                                 2
                              
                              
                                 n
                                 −
                                 k
                              
                           
                           )
                        . The fast matrix embedding algorithm using random linear code proposed in [13] embeds 
                           n
                           −
                           k
                         secret bits into n LSBs of the cover image. The average computational complexity of each embedded bit is shown as (14). The fast algorithm of matrix embedding proposed in [19] adds h referential columns to the parity check matrix to embed 
                           n
                           −
                           k
                         secret bits into 
                           n
                           +
                           h
                         LSBs. For the sake of the special structures of the referential columns, the embedding algorithm only needs to search a solution space with the size of 
                           
                              
                                 2
                              
                              
                                 k
                              
                           
                         and to implement h comparisons and additions for each solution. Therefore, the computational complexity of each embedding block is 
                           O
                           (
                           (
                           n
                           +
                           h
                           )
                           
                              
                                 2
                              
                              
                                 k
                              
                           
                           )
                        . The fast algorithm based on the random linear code proposed in this paper search the coset leader in a pre-generated table. The computational complexity depends on the size of the table, shown as (19). The computational complexity of the proposed scheme and some existing steganographic schemes are shown in Table 5
                        . Pay attention that the computational complexities in Table 5 are values of each embedded bit.


                        Fig. 1
                         shows the comparisons of the computational complexity with different length of secret message of each embedding block, i.e., 
                           k
                           =
                           4
                        , 
                           k
                           =
                           8
                        , and 
                           k
                           =
                           10
                        . From the experimental results we see that, the proposed scheme has extremely low computational complexity for small and medium embedding rates. But since the size of the table increases with the raise of the amount of cosets, the searching space of the proposed scheme increases with 
                           n
                           −
                           k
                        . The searching spaces of the fast algorithms proposed in [13] and [19] exponentially increase with the raise of k, as shown in Table 5, thus, the larger the embedding rate is, the less the computational complexity they will have. Therefore, compared with the schemes of [13] and [19], the proposed scheme is more suitable for matrix embedding with low and medium embedding rates. The experimental results also show that the proposed schemes always have the same embedding efficiency as the conventional matrix embedding using the same code.

The steganography proposed by Fill et al. employs the syndrome-trellis of dual convolutional codes to generate the stego object, which can minimize the embedding distortion [20,21]. In this scheme, a parity-check matrix H of size 
                           b
                           ×
                           (
                           b
                           ⋅
                           w
                           )
                         is generated by duplicating a submatrix 
                           
                              
                                 H
                              
                              
                                 ′
                              
                           
                         of size 
                           v
                           ×
                           w
                         in the diagonal direction b times. The stego object y is a vector satisfying 
                           H
                           y
                           =
                           m
                        , which can be represented as a path through the syndrome trellis (Here we assume that all of the operations are binary). The embedding rate, ER, of the trellis-coded quantization scheme can be arbitrary, but small embedding rate such as 
                           
                              ER
                           
                           ⩽
                           0.5
                         is mainly focused in the papers. The height v of the submatrix 
                           
                              
                                 H
                              
                              
                                 ′
                              
                           
                         is the constraint height of the syndrome-trellis. Fill et al. pointed that the computational complexity for each secret bit is 
                           O
                           (
                           
                              
                                 2
                              
                              
                                 v
                              
                           
                           w
                           )
                        , and the embedding efficiency improves with the increasing of the constraint height v and the block size n. Thus, the values of v and n are chosen as a trade-off among embedding efficiency, computational complexity, and memory space. Typically, 
                           6
                           ⩽
                           v
                           ⩽
                           15
                         and 
                           n
                           >
                           
                              
                                 10
                              
                              
                                 4
                              
                           
                        . In the following experiments, 10 000 bits that are arbitrarily generated are embedded in the image of “Lena” using three schemes, respectively, i.e., Fillʼs scheme with 
                           w
                           =
                           3
                        , 
                           v
                           =
                           3
                         and 
                           n
                           =
                           9
                        , the proposed fast embedding algorithm using [7,4] Hamming code, and the proposed fast embedding scheme using [8,2] random linear code. All of the experiments were performed in Matlab on a PC running Windows 7, with 3.40 GHz Intel Core i7 CPU and 8 GB main memory. The experimental results are shown in Table 6
                        . We can see that, the computation time of Fillʼs scheme is the longest, and its embedding efficiency is low due to the small constraint height and small block size used in the experiment. The embedding efficiency of Fillʼs scheme can reach the value of 4 under the condition of large constraint height and large block size. Compared with Fillʼs scheme, our fast algorithm is more suitable for the applications of low-power processors.

@&#CONCLUSIONS@&#

A fast algorithm for matrix embedding steganography was proposed in this paper. In this scheme, the syndrome of the error correction code was used to search for the coset leader, which was the modification to the cover image. In addition, in order to simplify the searching process, we improved the parity check matrix of the Hamming code to make the syndrome indicate its coset leader by itself. By this means, we didnʼt have to search for the coset leader in a table when embedding with a Hamming code, and the computational complexity of the embedding process was reduced significantly. For matrix embedding using random linear code, our fast algorithm used the syndrome to indicate its coset leader for most cosets, and it searched for the coset leader by its syndrome for the rest. By this means, the size of the table for embedding was decreased significantly, and the computational complexity was reduced. Our fast algorithm has the same embedding rate and embedding efficiency as the conventional matrix embedding algorithms, while its computational complexity is significantly lower for the low and medium embedding rates. Besides Hamming code and random linear code, some other error correction codes are suitable for the matrix embedding steganography. Our future work may focus on finding the embedding schemes using these codes and the fast embedding algorithms for them.

@&#REFERENCES@&#

