@&#MAIN-TITLE@&#A new descriptor resistant to affine transformation and monotonic intensity change

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Perform a thorough analysis of the disadvantages of SIFT-based descriptors.


                        
                        
                           
                           Apply an adaptive strategy for the subregion division.


                        
                        
                           
                           Utilize intensity order to construct the descriptor.


                        
                        
                           
                           Explain how the new method is resistant to affine transformation and monotonic intensity change.


                        
                        
                           
                           Demonstrate the effectiveness and efficiency of the new method through extensive experiments.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Local invariant descriptor

Affine transformation

Monotonic intensity change

Intensity order

@&#ABSTRACT@&#


               
               
                  A substantial number of local feature extraction and description methodologies have been proposed as image recognition algorithms. However, these algorithms do not exhibit adequate performance with regard to repeatability, accuracy, and time consumption for both affine transformation and monotonic intensity change. In this paper, we propose a new descriptor, named Resistant to Affine Transformation and Monotonic Intensity Change (RATMIC). Unlike traditional descriptors, we utilize an adaptive division strategy and intensity order to construct the new descriptor, which is actually resistant to affine transformation and monotonic intensity change. Extensive experiments demonstrate the effectiveness and efficiency of the new descriptor compared to existing state-of-the-art descriptors.
               
            

@&#INTRODUCTION@&#

The task of finding correspondences between two images has been a prevalent topic for years. However, even for the simplest objects or scenes, computers still experience difficulty fulfilling their missions of recognition. With the emergence of local invariant features, it is possible to achieve better performance and improved efficiency with several successful applications, including object recognition [1], 3D object reconstruction [2], and image retrieval [3], as well as panoramic image stitching [4]. Moreover, this methodology can be divided into two main steps: the extraction of features and the description of these features. Several algorithms have been proposed for both steps; some are reviewed in the next two subsections.

Among these invariant feature extraction methodologies, the Harris corner detector [5], which is based on the computation of the eigenvalues of the Harris matrix, is used to detect corners by curvature, and the Hessian detector, which employs the Hessian matrix, is used to retrieve conspicuous texture information from images. Nevertheless, neither is invariant to affine transformation, which reduces their performance. Thus, the Harris-Affine detector [6–8] and Hessian-Affine detector [6,7] are proposed based on the second moment matrix and automatic scale selection theory [9]. The Maximally Stable Extremal Region (MSER) [10] detects the maximally stable extreme districts to form the affine invariant areas. Based on the Accelerated Segment Test (AST) standard, the Features from AST (FAST) [11,12] utilizes machine learning to establish a decision tree for corner detection. Based on FAST, Mair et al. [13] present the Adaptive and Generic Accelerated Segment Test (AGAST), which finds the optimal decision tree in an extended configuration space and also demonstrates how to combine specialized trees to yield an adaptive and generic AST.

The SIFT descriptor [1,14] is the most popular descriptor that it is invariant to scale transformation by means of an image pyramid; it also undergoes robust-to-rotation transformation and intensity change through gradient information. However, it presents certain disadvantages, which will be discussed in detail in Section 2. By utilizing both the integral image and Haar wavelet transformation, the SURF descriptor [15,16] exhibits higher efficiency but lower performance than the SIFT descriptor. By combining the FAST detector with the BRIEF descriptor [17], the ORB algorithm [18] is faster than the SIFT and SURF algorithms by two orders and one order of magnitude, respectively; however, it displays poor performance when a serious affine transformation occurs. The DAISY descriptor [19] performs well for affine transformations and linearly uniform intensity changes. However, due to high dimensions and complex computations, time and space consumptions for the construction of the DAISY descriptor increased accordingly. The Rotation-Invariant Fast Feature (RIFF) [20] descriptor calculates the gradient information based on a local coordinate such that it is invariant under rotation but the descriptor may result in increased computational complexity. The Compact And Real-time Descriptors (CARD) [21] makes effective use of query tables to reduce the construction time of the SIFT algorithm; however, it is still inferior to the SIFT algorithm. To cope with complicated intensity change, the Local Binary Pattern (LBP) descriptor [22] considers intensity order information but still contains high dimensions. Heikkilä et al. [23] combine the SIFT and LBP descriptors to form the Center Symmetric LBP (CS-LBP) descriptor, which can efficiently deal with complex intensity change but experiences the same disadvantages as the SIFT descriptor. For better coping with noises, Gupta et al. [24] presents the Center Symmetric Local Ternary Patterns (CS-LTP) descriptor to establish a dead zone for comparisons of pixel intensity.

As discussed previously, development of a new descriptor that can efficiently and effectively handle both affine transformation and complex intensity change is essential. Consequently, we propose the Resistant to Affine Transform and Monotonic Intensity Change descriptor (RATMIC), whose synthetical performance outperforms most of the existing state-of-the-art descriptors. The remainder of the paper is organized as follows. Section 2 discusses the shortages of SIFT-based descriptors. Section 3 introduces our proposed RATMIC descriptor in detail. Case studies are discussed in Section 4, and our conclusions are presented in Section 5.

As stated previously, the SIFT algorithm is the most popular algorithm in the fields of invariant feature extraction and description. Consequently, there are many new algorithms deriving from the SIFT algorithm, e.g., SURF, DAISY, and CS-LBP, that are worthy of emphasis. Based on our analyses, we present some disadvantages of SIFT-based descriptors in this section, including extensive time consumption, lack of invariance to non-uniform intensity changes, and reduced accuracy due to predefined subregions.


                        Fig. 1
                         depicts the distribution of time consumption during feature extraction and description by the SIFT algorithm. For the image with a size of 700×1000 pixels, 3354 features are extracted from the raw image. The overall process takes 13,588ms, including 1653ms for features extraction, 2840ms for orientations estimation and 9095ms for descriptors extraction in the experimental environment of Intel Core (TM) i3-2100 CPU 3.10GHZ.

As shown in Fig. 1, the most time-consuming stages are the estimation of the principal direction and the construction of the descriptors, which together comprise about 88% of the total process time. The reasons for this proportion are fourfold. First, the gradient computation over the entire region of interest (ROI) for each feature is very large, i.e., provided that there are J (J
                        ∈
                        N
                        +) features extracted from the raw image and ROIs centered at different features are of an n
                        2 (n
                        ∈
                        N
                        +) size, the computation complexity is up to O(Jn
                        2), where O(·) is the asymptotic time complexity. Second, SIFT-based algorithms divide gradient orientation into several directions; all pixels are then pooled according to their gradient orientations. Subsequently, the direction with the largest magnitude is assigned as the principal direction. Third, to become rotation invariant, the rotation of the ROI relative to the principal direction is required, which consists of a large number of bilinear interpolations. Finally, SIFT-based algorithms divide the ROI into several predefined subregions and construct the descriptor based upon the gradient information of pixels. According to the previous analyses, Most of SIFT-based descriptors are not suitable for real-time applications because they are overly time consuming.

The construction of SIFT-based descriptors depends on the gradient computation of pixels in the ROI. If the same intensity increment occurs in the image, the gradient information is invariant, i.e., all pixels in the original image change from I(x,
                        y) to I(x,
                        y)+Δ(x,
                        y), where I(x,
                        y) is the intensity located at (x,
                        y) and Δ is a compatible matrix with a same element representing an equivalent intensity change. This change does not affect the gradient result for they are computed from the pixel differences. Thus, SIFT-based descriptors are invariant to the same incremental intensity change.

A change that every pixel multiplies a constant, i.e., the intensity changes from I(x,
                        y) to k
                        ×
                        I(x,
                        y), where k is a positive scalar, will multiply the gradient value by the identical constant. To counteract this effect, SIFT-based descriptors are unitized by the Euclidean distance.

So the SIFT-based algorithms are capable of handling linear uniform intensity change, i.e., intensity changes from I(x,
                        y) to k
                        ×
                        I(x,
                        y)+Δ. Nevertheless, when a non-uniform intensity change occurs, which can be represented as f(x,
                        y)×
                        I(x,
                        y)+Δ′(x,
                        y), where the scale coefficient f(x,
                        y) is a general matrix instead of a scalar and translation coefficient Δ′(x,
                        y) is a matrix with different elements, the gradient computation is unable to eliminate the effect caused by the non-uniform intensity changes. To reduce the influence, D. Lowe thresholds the maximum gradient value and then renormalizes the SIFT descriptor. However, such changes will still affect the construction and performance of SIFT-based descriptors.

To take spatial information into consideration, SIFT-based descriptors divide the ROI into several predefined subregions, e.g., the SIFT descriptor divides the ROI into 4×4 square subregions. Unfortunately, SIFT-based descriptors need to determine the principal direction and rotate the ROI relative to the principal direction to obtain rotational invariance. However, this method not only augments time consumption but also reduces accuracy. Its instability was previously pointed out by Bin et al. [25].

Aimed at overcoming the aforementioned disadvantages of SIFT-based descriptors, we propose the RATMIC descriptor, which is constructed by the intensity order instead of gradient information. It will improve repeatability and accuracy, as well as decrease time consumption. The construction process can be divided into four steps. First, we employ the affine-invariant detector to extract features from raw images. Second, we adopt a strategy, which is invariant to rotation transformation, to pool pixels in the ROI into different subregions. Third, a ratmic function is applied to different subregions to form their own RATMIC subdescriptors. Finally, all subdescriptors are orderly concatenated to construct the RATMIC descriptor. Further details of this process are provided below.

We use the Hessian-Affine detector to extract features in that such detector can obtain spatial information and other affine transformation information from the extracted features, i.e., the Hessian-Affine detector returns not only the spatial information (x,
                        y) but also the set (a,
                        b,
                        c), which can form a symmetric matrix defined as Eq. (1).
                           
                              (1)
                              
                                 M
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   a
                                                
                                                
                                                   b
                                                
                                             
                                             
                                                
                                                   b
                                                
                                                
                                                   c
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The different elements in the matrix M can describe ROIs within different ellipses, which are defined as
                           
                              (2)
                              
                                 
                                    
                                       X
                                    
                                    
                                       T
                                    
                                 
                                 MX
                                 ⩽
                                 1
                              
                           
                        where X is a column vector representing the location in ROI. This ellipse incorporates abundant affine transformation information; we will normalize the ellipse to the unit circle for the convenience of matching.


                        
                           Theorem 1
                           Given that M is a symmetric matrix, and X is a column vector representing the location in ROI, we will normalize the ellipse described by M to a unit circle by the transformation defined as
                                 
                                    (3)
                                    
                                       Y
                                       =
                                       
                                          
                                             M
                                          
                                          
                                             1
                                             /
                                             2
                                          
                                       
                                       X
                                    
                                 
                              
                           

For M is a symmetric matrix, we have M
                              =
                              MT
                               and M
                              1/2
                              =(M
                              1/2)
                                 T
                               intuitively. According to Eq. (2), we can deduce that
                                 
                                    (4)
                                    
                                       
                                          
                                             X
                                          
                                          
                                             T
                                          
                                       
                                       MX
                                       =
                                       
                                          
                                             X
                                          
                                          
                                             T
                                          
                                       
                                       
                                          
                                             M
                                          
                                          
                                             1
                                             /
                                             2
                                          
                                       
                                       
                                          
                                             M
                                          
                                          
                                             1
                                             /
                                             2
                                          
                                       
                                       X
                                       =
                                       
                                          
                                             X
                                          
                                          
                                             T
                                          
                                       
                                       
                                          
                                             (
                                             
                                                
                                                   M
                                                
                                                
                                                   1
                                                   /
                                                   2
                                                
                                             
                                             )
                                          
                                          
                                             T
                                          
                                       
                                       
                                          
                                             M
                                          
                                          
                                             1
                                             /
                                             2
                                          
                                       
                                       X
                                       =
                                       
                                          
                                             (
                                             
                                                
                                                   M
                                                
                                                
                                                   1
                                                   /
                                                   2
                                                
                                             
                                             X
                                             )
                                          
                                          
                                             T
                                          
                                       
                                       
                                          
                                             M
                                          
                                          
                                             1
                                             /
                                             2
                                          
                                       
                                       X
                                       =
                                       
                                          
                                             Y
                                          
                                          
                                             T
                                          
                                       
                                       Y
                                       =
                                       1
                                    
                                 
                              Therefore, we can successfully normalize the ellipse to a unit circle using Eq. (3). Fig. 2
                               provides an example of the ROI normalization procedure.

Provided that there is an affine transformation between two ROIs, i.e., XR
                              
                              =
                              AXL
                              , we can separately transform XR
                              , XL
                               into 
                                 
                                    
                                       
                                          X
                                       
                                       
                                          R
                                       
                                       
                                          ′
                                       
                                    
                                 
                              , 
                                 
                                    
                                       
                                          X
                                       
                                       
                                          L
                                       
                                       
                                          ′
                                       
                                    
                                 
                               by Eq. (3). Then, the affine transformation between XR
                               and XL
                               is converted to the rotation transformation between 
                                 
                                    
                                       
                                          X
                                       
                                       
                                          R
                                       
                                       
                                          ′
                                       
                                    
                                 
                               and 
                                 
                                    
                                       
                                          X
                                       
                                       
                                          L
                                       
                                       
                                          ′
                                       
                                    
                                 
                              . Thus, we still have to address the rotation transformation.□

To take advantage of the spatial information of the features without introducing errors from the assignment of the principal direction, we adopt the subregion division methodology presented by Bin et al. [25]. We first sort all pixels within the ROI in non-decreasing order according to their intensity value. Then, we divide the sorted sequence into k segments; namely, different pixels are separately allocated to different subregions according to their intensity order. As an example, Fig. 3
                         shows the strategy with k equal to eight. Even if the ROI rotates by a certain angle, the intensity order remains invariant. As a consequence, every pixel is pooled into the same subregion after a rotation transformation, leading the strategy to be invariant to rotation.

In this subsection, the construction of subdescriptors in each subregion will be discussed in detail. Instead of gradient information, we consider the intensity order to keep the RATMIC descriptor invariant to both rotation transformation and monotonic intensity change. Provided that I(x
                        1,
                        y
                        1) and I(x
                        2,
                        y
                        2) represent the intensities before transformation, they satisfy I(x
                        1,
                        y
                        1)<
                        I(x
                        2,
                        y
                        2); when the monotonic intensity change occurs, the intensity order still satisfies I′(x
                        1,
                        y
                        1)<
                        I′(x
                        2,
                        y
                        2), where I′(x
                        1,
                        y
                        1) and I′(x
                        1,
                        y
                        1) denote the intensities after the intensity change.

As shown in Fig. 4
                        , P is a feature and C is an arbitrary pixel within the ROI centered at P. We sample four pixels in the circle with radial l centered at C. To obtain rotation invariance, the sample process is as follows. Since there are two pixels along the radial direction centered at P, we select the pixel away from P as C
                        1; others are sampled anti-clockwise. Furthermore, the line through C
                        1 and C
                        3 is orthogonal to the line through C
                        2 and C
                        4. To illustrate that the sample strategy remains invariant to rotation, we rotate the pixel C by a certain angle θ to pixel C′. The four neighboring pixels around C are equivalent to the four neighboring pixels around C′. Hence, this sample strategy is invariant to rotation.

As gradient information is incapable of coping with non-uniform and non-linear monotonic intensity change, we propose a new methodology to construct the subdescriptor by utilizing the intensity order of Ci
                        (i
                        =1,2,3,4), which is described as follows. First, the comparison between I(xi
                        ,
                        yi
                        ) and 
                           
                              I
                              (
                              
                                 
                                    x
                                 
                                 
                                    i
                                    
                                    mod
                                    4
                                    +
                                    1
                                 
                              
                              ,
                              
                                 
                                    y
                                 
                                 
                                    i
                                    
                                    mod
                                    4
                                    +
                                    1
                                 
                              
                              )
                           
                         is performed where 1⩽
                        i
                        ⩽4 and mod denotes the modulo operation. If 
                           
                              I
                              (
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    y
                                 
                                 
                                    i
                                 
                              
                              )
                              ⩾
                              I
                              (
                              
                                 
                                    x
                                 
                                 
                                    i
                                    
                                    mod
                                    4
                                    +
                                    1
                                 
                              
                              ,
                              
                                 
                                    y
                                 
                                 
                                    i
                                    
                                    mod
                                    4
                                    +
                                    1
                                 
                              
                              )
                              +
                              thres
                           
                        , where thres is a threshold to reduce the effect of noises. Then, we set Qi
                        
                        =1; otherwise, Qi
                        
                        =0. After the comparison, we concatenate Qi
                         to form Q, i.e., Q
                        ={Q
                        1,
                        Q
                        2,
                        Q
                        3,
                        Q
                        4}. Second, we define
                           
                              (5)
                              
                                 S
                                 =
                                 {
                                 γ
                                 (
                                 Q
                                 )
                                 ∈
                                 N
                                 |
                                 Q
                                 ∈
                                 
                                    
                                       {
                                       0
                                       ,
                                       1
                                       }
                                    
                                    
                                       4
                                    
                                 
                                 }
                              
                           
                        where S is a non-negative integer representing the weighted sum of the binary number Qi
                        , i.e., 
                           
                              S
                              =
                              
                                 
                                    ∑
                                 
                                 
                                    i
                                    =
                                    0
                                 
                                 
                                    3
                                 
                              
                              
                                 
                                    2
                                 
                                 
                                    i
                                 
                              
                              ×
                              
                                 
                                    Q
                                 
                                 
                                    i
                                    +
                                    1
                                 
                              
                           
                        . According to the definition of S, we have 
                           
                              0
                              ⩽
                              S
                              ⩽
                              15
                           
                        . Subsequently, we define
                           
                              (6)
                              
                                 W
                                 =
                                 
                                    
                                       
                                          ϕ
                                          (
                                          S
                                          )
                                          ∈
                                          
                                             
                                                {
                                                0
                                                ,
                                                1
                                                }
                                             
                                             
                                                
                                                   
                                                      2
                                                   
                                                   
                                                      4
                                                   
                                                
                                                -
                                                1
                                             
                                          
                                          |
                                          S
                                          ∈
                                          N
                                       
                                    
                                 
                              
                           
                        where W is a column vector that includes a set of binary numbers denoted as WS
                        , where 
                           
                              0
                              ⩽
                              S
                              ⩽
                              15
                           
                        . The map ϕ sets the corresponding WS
                         to one, e.g., if S
                        =5, W
                        =
                        ϕ(5)=(0,…,0,15,0,…,0)
                           T
                        .

In summary, we concatenate Eqs. (5) and (6) to form the ratmic function in Eq. (7).
                           
                              (7)
                              
                                 ratmic
                                 (
                                 X
                                 )
                                 =
                                 ϕ
                                 (
                                 γ
                                 (
                                 Q
                                 )
                                 )
                                 =
                                 
                                    
                                       (
                                       0
                                       ,
                                       …
                                       ,
                                       0
                                       ,
                                       
                                          
                                             1
                                          
                                          
                                             γ
                                             (
                                             Q
                                             )
                                          
                                       
                                       ,
                                       0
                                       ,
                                       …
                                       ,
                                       0
                                       )
                                    
                                    
                                       T
                                    
                                 
                              
                           
                        where 
                           
                              X
                              ∈
                              
                                 
                                    R
                                 
                                 
                                    2
                                 
                              
                           
                         denotes the location of a feature.

An illustration of the ratmic function is shown in Fig. 5
                        , where the threshold is set to four.

Finally, the subdescriptor in each subregion is constructed by the sum of the ratmic functions of features belonging to each subregion.

After constructing each subdescriptor, we can construct the RATMIC descriptor by concatenating the subdescriptors orderly as Eq. (8).
                           
                              (8)
                              
                                 
                                    
                                       
                                       
                                          
                                             RATMIC
                                             
                                             descriptor
                                             =
                                             
                                                
                                                   
                                                      
                                                         subdes
                                                         
                                                            
                                                               (
                                                               1
                                                               )
                                                            
                                                            
                                                               T
                                                            
                                                         
                                                         ,
                                                         subdes
                                                         
                                                            
                                                               (
                                                               2
                                                               )
                                                            
                                                            
                                                               T
                                                            
                                                         
                                                         ,
                                                         …
                                                         ,
                                                         subdes
                                                         
                                                            
                                                               (
                                                               k
                                                               )
                                                            
                                                            
                                                               T
                                                            
                                                         
                                                      
                                                   
                                                
                                                
                                                   T
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             subdes
                                             (
                                             j
                                             )
                                             =
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      X
                                                      ∈
                                                      Sub
                                                      Re
                                                      gion
                                                      (
                                                      j
                                                      )
                                                   
                                                
                                             
                                             ratmic
                                             (
                                             X
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        
                     

Moreover, we normalize the RATMIC descriptor to the unit vector by analogy with the SIFT algorithm to better handle the intensity change. The complete construction process is shown in Algorithm 1.
                           
                              
                                 
                                 
                                    
                                       
                                          Algorithm 1: Construction of the RATMIC descriptor
                                    
                                 
                                 
                                    
                                       01Smooth the raw image utilizing the Gaussian filter
                                    
                                    
                                       02 Extract J features using the Hessian-Affine detector
                                    
                                    
                                       03
                                          for 
                                          i
                                          =1,2,…,
                                          J
                                       
                                    
                                    
                                       04
                                          Normalize the ROI centered at the i
                                          th feature according to (3)
                                    
                                    
                                       05
                                          
                                          Sort the pixels within the normalized ROI in non-decreasing order and divide them into k equal segments
                                    
                                    
                                       06
                                          Pool the pixels into different subregions according to their intensity
                                    
                                    
                                       07
                                          
                                          Calculate the ratmic function of the pixels within the ROI according to (7). Then, add the results to different subdescriptors separately according to (8)
                                    
                                    
                                       08
                                          
                                          Concatenate all subdescriptors according to the order described in step 5 to construct the RATMIC descriptor
                                    
                                    
                                       09
                                          
                                          Normalize the RATMIC descriptor to the unit vector
                                    
                                    
                                       10
                                          Assign the normalized RATMIC descriptor to RATMIC(i)
                                    
                                    
                                       11
                                          end for
                                       
                                    
                                    
                                       12
                                          return 
                                          RATMIC
                                       
                                    
                                 
                              
                           
                        
                     

After the RATMIC descriptor is constructed, it can be seen that either the subregion division or sample strategy of the pixels within the ROI is invariant to rotation; thus, we can deduce that the RAIMIC descriptor is invariant to rotation transformation compared to other algorithms whose principal direction is required. In addition, we make effective use of the intensity order to enable the RATMIC descriptor to cope with monotonic intensity change. Hence, the RATMIC descriptor outperforms most of the gradient-based descriptors due to its characteristics of both resistance to affine transformation and the invariance to monotonic intensity change. In the next section, sufficient experiments are conducted on standard datasets to demonstrate the superiority of the RATMIC descriptor.

@&#EXPERIMENTS@&#

To completely demonstrate the effectiveness of the RATMIC descriptor, we conduct two experiments to compare its performance with other descriptors: one is on the Oxford dataset, and the other is on the 3D objects [26]. Additionally, we compare the time consumption with other descriptors.

We employ the nearest neighbor distance ratio [27] as our matching strategy. In the feature domain, the Manhattan distance DAB
                         is adopted to describe the similarity between TA
                         and TB
                         defined as
                           
                              (9)
                              
                                 
                                    
                                       D
                                    
                                    
                                       AB
                                    
                                 
                                 =
                                 ‖
                                 
                                    
                                       T
                                    
                                    
                                       A
                                    
                                 
                                 -
                                 
                                    
                                       T
                                    
                                    
                                       B
                                    
                                 
                                 
                                    
                                       ‖
                                    
                                    
                                       1
                                    
                                 
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          n
                                       
                                    
                                 
                                 |
                                 
                                    
                                       a
                                    
                                    
                                       i
                                    
                                 
                                 -
                                 
                                    
                                       b
                                    
                                    
                                       i
                                    
                                 
                                 |
                              
                           
                        where TA
                        
                        =(a
                        1,
                        a
                        2,…,
                        an
                        )
                           T
                         and TB
                        
                        =(b
                        1,
                        b
                        2,…,
                        bn
                        )
                           T
                         are the descriptors for features A and B, respectively. We then calculate the nearest neighbor distance ratio R between the nearest distance 
                           
                              ‖
                              
                                 
                                    T
                                 
                                 
                                    A
                                 
                              
                              -
                              
                                 
                                    T
                                 
                                 
                                    B
                                 
                              
                              
                                 
                                    ‖
                                 
                                 
                                    1
                                 
                              
                           
                         and second-nearest distance 
                           
                              ‖
                              
                                 
                                    T
                                 
                                 
                                    A
                                 
                              
                              -
                              
                                 
                                    T
                                 
                                 
                                    C
                                 
                              
                              
                                 
                                    ‖
                                 
                                 
                                    1
                                 
                              
                           
                         as follows.
                           
                              (10)
                              
                                 R
                                 =
                                 
                                    
                                       ‖
                                       
                                          
                                             T
                                          
                                          
                                             A
                                          
                                       
                                       -
                                       
                                          
                                             T
                                          
                                          
                                             B
                                          
                                       
                                       
                                          
                                             ‖
                                          
                                          
                                             1
                                          
                                       
                                    
                                    
                                       ‖
                                       
                                          
                                             T
                                          
                                          
                                             A
                                          
                                       
                                       -
                                       
                                          
                                             T
                                          
                                          
                                             C
                                          
                                       
                                       
                                          
                                             ‖
                                          
                                          
                                             1
                                          
                                       
                                    
                                 
                              
                           
                        
                     

If R is smaller than the threshold t, then we match feature A with nearest feature B.

During the process of constructing the RATMIC descriptor, three parameters need to be determined. The first parameter is the number of subregions k, the second parameter is the radial of the sample circle l, and the last parameter is the threshold thres used in map η.

We conduct our experiments on sufficient pairs of images, including scale, rotation, intensity, and viewpoint change. We choose thres(2,4), l(3,5), and k(6,8) according to the comprehensive performance of these parameter values, as shown in Fig. 6
                        . The combinations of thres
                        =2, l
                        =5, k
                        =6 and thres
                        =2, l
                        =5, k
                        =8 have nearly equivalent performances that are both superior to those obtained with other combinations. However, the dimension of the former is (24
                        −1)×6=90, whereas the latter is (24
                        −1)×8=120. We choose the former combination as the best parameter set, as shown in Table 1
                        . Thus, the dimension of the RATMIC descriptor is 90.

The RATMIC descriptor is evaluated based upon the Oxford dataset, as shown in Fig. 7
                           . It includes six groups of images with different scenes, and the images in each group contain different image transformations, i.e., the Bikes with varying blur, the Boat with zoom and rotation, the Graffiti with different viewpoints, the Leuven with light changes, the UBC with JPEG compression, and the Wall with different viewpoints and ambiguous textures. The severity of transformation increases with an increasing index in each group.

We employ recall vs. 1-precision 
                           [27] to compare the performance of the RATMIC descriptor with other descriptors. In this method, the recall and precision represent the correspondent and correct match determined by the overlap error, respectively. The recall and 1-precision are separately defined as Eqs. (11) and (12).
                              
                                 (11)
                                 
                                    recall
                                    =
                                    
                                       
                                          #
                                          correct
                                          
                                          matches
                                       
                                       
                                          #
                                          correspondences
                                       
                                    
                                 
                              
                           
                           
                              
                                 (12)
                                 
                                    1
                                    -
                                    precision
                                    =
                                    
                                       
                                          #
                                          false
                                          
                                          matches
                                       
                                       
                                          #
                                          correct
                                          
                                          matches
                                          +
                                          #
                                          false
                                          
                                          matches
                                       
                                    
                                 
                              
                           
                        

It is obvious from (11) and (12) that the larger recall and precision are, the better the performance of the descriptor, i.e., a higher recall and lower 1-precision are anticipated for the proposed descriptor.

@&#PERFORMANCE EVALUATION@&#

In this subsection, we conduct numerous experiments to compare the performances of the RATMIC, SIFT, SURF, ORB, DAISY, and CS-LTP descriptors. Since our descriptor is motivated by MROGH descriptor, we also compare the performances with it. In our experiments, the features for the RATMIC, SIFT, SURF, DAISY, CS-LTP and MROGH descriptors are extracted by the Hessian Affine detector, whereas the FAST detector extracts the features in the ORB algorithm to retain its rapidity. It is not feasible to list all of the performance results due to limited space, so we illustrate several results in Figs. 8-13
                           
                           
                           
                           
                           
                           .

It is not difficult to find that with the increase of the severity of all kinds of transformations in the dataset, the performance of all descriptors descend more or less. In comparison with all descriptors without MROGH descriptor, the “recall vs. 1-precision” curve of RATMIC descriptor is on the upper left of others at the most time, which indicates that the RATMIC descriptor outperforms other descriptors for most of transformations including blur, viewpoint, intensity change and JPEG compression. In addition, the performances of RATMIC descriptor approximate that of MROGH descriptor in the Bikes, Leuven and UBC datasets, but are still inferior to that of MROGH descriptor in other datasets. To our knowledge, the reason that MROGH descriptor is better than RATMIC descriptor lies in the multi support regions they used in [25]. Although multi support regions promote the performance of MROGH descriptor, the time consumption introduced by it multiplies which is revealed in the comparison of time consumption in the next subsection. Incorporating multi support regions into RATMIC descriptor or not is a tradeoff between performance and time consumption. Considering the synthetical performance and the real-time request in practical applications, we do not take multi support regions into account in this paper.

Furthermore, to show that the RATMIC descriptor is better at handling monotonic intensity changes, we compare the algorithms on the datasets with non-linear monotonic intensity changes in Fig. 14
                            (square intensity changes) and 15 (root intensity changes). The results of Figs. 14 and 15
                            validate the effectiveness of the RATMIC descriptor in dealing with monotonic intensity changes.

To further evaluate the performance of RATMIC descriptors, we download the 3D image database collected by Moreels and Perona, and randomly select 5 images ranged from 0° to 40° in each subject, total 85×5=425 images as the testing dataset. And then we conduct classification by using the proposed RATMIC descriptors and adopt ROC curves for performance evaluation. Finally the experimental results are compared with those of MROGH, SIFT, SURF, ORB descriptor. To ensure the fairness of comparison, the RATMIC, MROGH, SIFT and SURF descriptors adopt the Harris Affine detectors, and ORB algorithm still uses the FAST detector and BRIEF descriptor.

We adopt shortest distance method as point matching strategy between the images, after obtained matching point-pairs, we define the similarity of two tested images as the number of matching points against the mean of number of their feature points, which can be expressed as
                           
                              (13)
                              
                                 M
                                 =
                                 
                                    
                                       2
                                       ×
                                       #
                                       matching
                                       
                                       points
                                    
                                    
                                       #
                                       feature
                                       
                                       points
                                       
                                       of
                                       
                                       image
                                       1
                                       +
                                       #
                                       feature
                                       
                                       points
                                       
                                       of
                                       
                                       image
                                       2
                                    
                                 
                              
                           
                        Then the two tested images can be classified as the same subject or different subjects according to predefined threshold. In Fig. 16
                        , the ROC curves of ‘false acceptance rate (FAR) and false rejection rate (FRR)’ are obtained by varying the predefined threshold value. The FAR is the fraction of the number of the falsely accepted pairs divided by the number of all imposter pairs, while the FRR is the fraction of the number of rejected client pairs divided by the total number of client pairs. Furthermore, the equal error rates (EERs), which is the value of the FAR and the FRR at this point is the same, of all the descriptors are shown in Fig. 16. It is observed from Fig. 16 that the performance of RATMIC descriptor approximates to that of MROGH descriptor, and surpasses those of SIFT, SURF and ORB descriptors. Consequently, we can draw the conclusion that the RATMIC descriptor can handle 3D perspective changes within 0–40 degree well.

In this subsection, we compare the time consumed in the construction of these descriptors. To make the time consumption proximates to its actual value, 40 randomly selected images are utilized to evaluate the time consumption. As stated above, we extract the Hessian-Affine features for RATMIC, SIFT, MROGH, SURF, DAISY, CS-LTP and the FAST features for ORB. It is noteworthy that the time consumption considered here is merely the time of the construction of a specific descriptor. We conduct our experiments in the experimental environment of Intel Core (TM) i3-2100 CPU 3.10GHZ. As shown in Fig. 17
                        , the average time consumption is as follows: ORB 0.344ms, SURF 0.620ms, RATMIC 1.080ms, DAISY 2.547ms, MROGH 3.665ms, CS-LTP 4.177ms and SIFT 4.215ms. It is evident that RATMIC is a little slower than ORB and SURF, whereas much faster than other descriptors.

@&#CONCLUSION@&#

In this paper, a novel RATMIC descriptor is proposed to resist affine transformation and monotonic intensity change. With the help of the Hessian-Affine detector, we extract features that are invariant to most affine transformations other than rotation. Unlike SIFT-based descriptors, we make an effective and efficient use of intensity order for the subregions division and construction of the RATMIC descriptor, which is invariant to both affine transformation and monotonic intensity change.

In the studies, we conduct sufficient experiments on the Oxford dataset and the 3D objects to demonstrate that the RATMIC descriptor outperforms most of existing state-of-the-art descriptors. Furthermore, the experimental results indicate that the speed of the RATMIC descriptor approximates the speed of the ORB and SURF descriptor, but is significantly faster than the other descriptors. In conclusion, the synthetical performance of the RATMIC descriptor is superior to the other existing descriptors.

@&#ACKNOWLEDGMENTS@&#

This work was supported by the National Natural Science Foundation of China (No. 61105019), the Guangdong Natural Science Foundation (No. S2011040002474), the Science and Technology Planning Project of Guangdong Province (No. 2012B010100021), Project on the Integration of Industry, Education and Research of Guangdong Province (No. 2011B090400564), and the Fundamental Research Funds for the Central Universities, SCUT (Nos. 2014ZG0041 and 2013ZB0006). The authors would like to thank the anonymous reviewers for their constructive comments and Dr. Bin Fan in the National Laboratory of Pattern Recognition (NLPR), Institute of Automation, Chinese Academy of Sciences (CASIA) for his help in the revision of the manuscript.

@&#REFERENCES@&#

