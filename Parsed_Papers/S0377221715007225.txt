@&#MAIN-TITLE@&#Augmenting measure sensitivity to detect essential, dispensable and highly incompatible features in mass customization

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Complex variability models (VM) are commonly used in mass customization.


                        
                        
                           
                           The limitations of current measures and algorithms to identify essential and dispensable features in VMs are shown.


                        
                        
                           
                           We redefine existing measures by taking into account a sensitivity parameter.


                        
                        
                           
                           We propose an algorithm to efficiently compute the measures using Binary Decision Diagrams.


                        
                        
                           
                           We report empirical evidence of the goodness of our approach.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Mass customization

Product platform

Variability modeling

Binary decision diagram

@&#ABSTRACT@&#


               
               
                  Mass customization is the new frontier in business competition for both manufacturing and service industries. To improve customer satisfaction, reduce lead-times and shorten costs, families of similar products are built jointly by combining reusable parts that implement the features demanded by the customers. To guarantee the validity of the products derived from mass customization processes, feature dependencies and incompatibilities are usually specified with a variability model. As market demand grows and evolves, variability models become increasingly complex. In such entangled models it is hard to identify which features are essential, dispensable, highly required by other features, or highly incompatible with the remaining features. This paper exposes the limitations of existing approaches to gather such knowledge and provides efficient algorithms to retrieve that information from variability models.
               
            

@&#INTRODUCTION@&#

Companies have shifted from mass production to mass customization in order to increase product variety, improve customer satisfaction, reduce lead-times, and shorten costs (Liou, Yen, & Tzeng, 2010; Ngniatedema, Fono, & Mbondo, 2015; Simpson, Siddique, & Jiao, 2005; Takagoshi & Matsubayashi, 2013). For instance, van der Linden, Schmid, and Rommes (2007) report successful experiences of large companies such as Bosch (Gasoline Systems), Nokia (Mobile Phones), Philips (Consumer Electronics Software for Televisions), Siemens (Medical Solutions), etc.

Mass customization enriches the mass production economies of scale with the flexibility of custom manufacturing by developing families of related products instead of single products. From this perspective, designing a product family requires developing a generic architecture, named product platform, that supports the creation of customized products, named derivatives, to satisfy different market niches. Derivatives are specified as combinations of features demanded by the customers (e.g., get a car with cruise control, speed limiter, directional stability control, etc.) (Apel, Batory, Kästner, & Saake, 2013; van der Linden et al., 2007).

Product platforms usually offer a high number of features whose combination can produce a large quantity of derivatives (Sternatz, 2014). For instance, the BMW 7-Series platform supports 1017 derivatives (ElMaraghy et al., 2013). Typically not all feature combinations are valid. There may be feature incompatibilities (e.g.,“manual transmissions are not compatible with V8 engines”), feature dependencies (e.g., “sport cars require manual gearbox”), etc. As product platforms grow and evolve, the need for feature variability increases, and managing that variability becomes increasingly difficult (Bachmann & Clements, 2005). Variability models (also known as configuration models, feature models, etc.) are widely used to support variability management by modeling the dependencies and incompatibilities among features (Pohl, Bockle, & Linden, 2005; Zhang & Tseng, 2007).

Operational research methods are currently being used to tackle several problems regarding the automated management of variability models. For instance, they are applied to search which derivative best fulfills the requirements of a given customer in terms of costs and/or utilities (Du, Jiao, & Chen, 2014; Yang et al., 2015), to diagnose and re-factor variability models (Zhang, 2014) (e.g., by removing redundant constraints), etc. In particular, the goal of this paper falls into the model diagnosis domain.

Product variety creates both challenges and opportunities. Customers prefer broad product variety and, therefore, marketing managers are rewarded with greater revenue when product platforms are extended (Jacobs, 2013). Nevertheless, this may increase costs and reduce profits (ElMaraghy et al., 2013; Patel & Jayaram, 2014; Salvador, Chandrasekaran, & Sohail, 2014; Takagoshi & Matsubayashi, 2013; Yenipazarli & Vakharia, 2015). In order to provide guidance on how maximize the profits and minimize the costs associated with product platforms, this paper describes how to analyze variability models to identify which features are essential, dispensable, highly required by other features, or highly incompatible with the remaining features. That is, features in a product platform have usually varying degrees of importance. Some features may be highly demanded by the market and so most derivatives should include them. Other features may become dispensable as the market demand evolves. In addition, there may be features that indirectly become of key importance because other essential features need them. Finally, product platforms may include highly incompatible features whose presence disable many other features, hindering feature combinability.

Since variability models specify how features can be combined to get the valid derivatives, it is possible to identify the incompatibility and the relative importance of the features by directly inspecting the models. Nevertheless, existing approaches to carry out such identification have the following limitations:

                        
                           1.
                           
                              Measures are rigid. Measures are needed to account for feature incompatibility and relative importance. Although some measures have been proposed (Benavides, Segura, & Ruiz-Cortes, 2010; Boender, 2011; Cosmo & Boender, 2010; van Deursen & Klint, 2002; Zhang, Zhao, & Mei, 2004), their sensitivity is not adjustable and thus they are often too rigid in practice. For instance, the dead measure is commonly used to detect if a feature is expendable for a product platform (Benavides et al., 2010). Its traditional definition is: “a feature is dead if, due to its dependencies and incompatibilities with the remaining features, it cannot be included in any derivative”. Imagine a feature that can only be included in 1 percent of the derivatives. The high dispensability of such feature would go unnoticed for the current definition of dead feature.


                              Algorithms to compute the measures are inefficient. Calculating the measures by hand is unfeasible for all but the most trivial variability models, so their automated computation is required. The usual way to perform that computation is to translate the models into Boolean formulas and use off-the-self logic tools, such as SAT solvers (Batory, 2005) or Binary Decision Diagrams (BDDs) (Mendonça, 2009), to get the measures. Unfortunately, current algorithms have poor time performance (Fernandez-Amoros, Heradio, Cerrada, & Cerrada, 2014; Heradio, Fernandez-Amoros, Cerrada, & Abad, 2013; Mendonça, 2009).

To overcome the aforementioned limitations, this paper contributes with:

                        
                           1.
                           The redefinition, by taking into account a sensitivity parameter, of the existing measures. In particular, the following ones have been extended: dead and core features (Benavides et al., 2010), impact and exclusion sets (Boender, 2011), feature necessity and incompatibility (Boender, 2011). As we will see, sensitivity is a number between 0 and 1. For instance, if the dead sensitivity is set at 0.01, a feature passes to be considered dead if its reusability is restricted to 1 percent of the derivatives.

Algorithms to efficiently compute the measures from a variability model. The input of our algorithms is the Propositional logic codification of a variability model. Since more complex logics than the Propositional one, which include integer arithmetic, transitive closure, etc., can be reduced to Boolean functions (Huth & Ryan, 2004; Jackson, 2012), our algorithms are general enough to support most variability model notations. In fact, the paper includes an experimental validation of our algorithms processing models specified in three different notations: the Configit language (http://configit.com/), feature models (Kang, Cohen, Hess, Novak, & Peterson, 1990), and decision models (Reuse-driven software processes, 1993).

This paper provides empirical evidence of the usefulness of our measure redefinition to detect essential, dispensable and highly incompatible features that go unnoticed using current measures. It also shows that our algorithms not only support the efficient computation of the flexibilized measures, but also have better time performance than existing algorithms when computing the rigid measures.

The remainder of this paper is structured as follows. Section 2 introduces the background required to understand our work, i.e., variability models and current measures. Section 3 summarizes related work to our approach, identifying its limitations. Section 4 describes our approach, defining the flexibilization of the considered measures thanks to the sensitivity parameter, and presenting the algorithms that support the computation of the measures. Section 5 reports the experimental validation of our approach. Finally, Section 6 outlines the conclusions of our work.

@&#BACKGROUND@&#


                        Fig. 1
                         represents a variability model written as a directed graph where the nodes represent features and the edges represent constraints related to dependencies or incompatibilities between features. A dashed-line edge depicts that the two connected features are incompatible, while a solid-line edge from a feature to another represents that the first feature requires the second one.

Each derivative is characterized by a selection of features from a variability model. From all possible combinations of 6 features, i.e. 
                           
                              
                                 2
                                 6
                              
                              =
                              64
                              ,
                           
                         the set of valid derivatives is reduced to the six ones enumerated in Eq. (1) due to the feature interdependencies. For instance, {f
                        1, f
                        3, f
                        4, f
                        5} is discarded because it violates the constraint 
                           
                              
                                 f
                                 4
                              
                              ⤎
                              ⤏
                              
                                 f
                                 5
                              
                           
                        ,

                           
                              (1)
                              
                                 
                                    
                                       
                                          
                                             valid
                                             
                                             derivatives
                                          
                                       
                                       
                                          =
                                       
                                       
                                          
                                             {
                                             
                                                {
                                                
                                                   f
                                                   1
                                                
                                                }
                                             
                                             ,
                                             
                                                {
                                                
                                                   f
                                                   1
                                                
                                                ,
                                                
                                                   f
                                                   3
                                                
                                                }
                                             
                                             ,
                                             
                                                {
                                                
                                                   f
                                                   1
                                                
                                                ,
                                                
                                                   f
                                                   3
                                                
                                                ,
                                                
                                                   f
                                                   6
                                                
                                                }
                                             
                                             ,
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             
                                                {
                                                
                                                   f
                                                   1
                                                
                                                ,
                                                
                                                   f
                                                   3
                                                
                                                ,
                                                
                                                   f
                                                   5
                                                
                                                }
                                             
                                             ,
                                             
                                                {
                                                
                                                   f
                                                   1
                                                
                                                ,
                                                
                                                   f
                                                   3
                                                
                                                ,
                                                
                                                   f
                                                   5
                                                
                                                ,
                                                
                                                   f
                                                   6
                                                
                                                }
                                             
                                             ,
                                             
                                                {
                                                
                                                   f
                                                   1
                                                
                                                ,
                                                
                                                   f
                                                   3
                                                
                                                ,
                                                
                                                   f
                                                   4
                                                
                                                }
                                             
                                             }
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        
                     

As product platforms grow, variability models become bigger and harder to understand. So, there is a need for an automated mechanism that provides information regarding which role each feature plays according to the variability model. Two complementary approaches are found in the literature to identify the essential, dispensable and highly incompatible features:

                           
                              1.
                              
                                 “Look at the feature distribution in all valid derivatives” (Benavides, Segura, Trinidad, & Ruiz-Cortes, 2007; van Deursen & Klint, 2002; Fernandez-Amoros, Heradio, & Somolinos, 2009; Mendonça, Wasowski, & Czarnecki, 2009; Pena, Hinchey, Ruiz-Cortes, & Trinidad, 2006; Segura, 2008; Trinidad, Benavides, Duran, Ruiz-Cortes, & Toro, 2008; Trinidad & Cortes, 2009; Yan et al., 2009; Zhang, Mei, & Zhao, 2006; Zhang, Yan, Zhao, Jin, & Mei, 2008; Zhang et al., 2004). In particular, features that appear in all or none the valid derivatives are absolutely essential or dispensable, respectively. In the Software Product Line literature (Benavides et al., 2010), those features are known as core and dead, respectively.

According to Eq. (1), f
                                 1 is included in all derivatives and so it is a core feature. As f
                                 2 is missing in every derivative, it is a dead feature.


                                 “Look at how features interact with each other in all valid derivatives” (Abate, Cosmo, Boender, & Zacchiroli, 2009; Boender, 2011; Boender, 2011; Boender, Barthe, Pardo, & Schneider, 2011; Cosmo & Boender, 2010). If a feature is required by many others then it is highly necessary. If a feature excludes many others then it is highly incompatible. In particular, Boender (2011) provides the following measures to quantify feature necessity and incompatibility:
                                    
                                       (a)
                                       The impact set of a feature f is composed of all the features f′ that require f to be enabled whenever they are included in a valid derivative, i.e.,

                                             
                                                
                                                   
                                                      Impact
                                                      
                                                      Set
                                                      
                                                         (
                                                         f
                                                         )
                                                      
                                                      =
                                                      
                                                         {
                                                         
                                                            f
                                                            ′
                                                         
                                                         ·
                                                         
                                                            f
                                                            ′
                                                         
                                                         ⇒
                                                         f
                                                         }
                                                      
                                                      .
                                                   
                                                
                                             
                                          
                                       

The exclusion set of a feature f is composed of all the features that are required to be disabled whenever f is included in a valid derivative, i.e.,

                                             
                                                
                                                   
                                                      Exclusion
                                                      
                                                      Set
                                                      
                                                         (
                                                         f
                                                         )
                                                      
                                                      =
                                                      
                                                         {
                                                         
                                                            f
                                                            ′
                                                         
                                                         ·
                                                         f
                                                         ⇒
                                                         ¬
                                                         
                                                            f
                                                            ′
                                                         
                                                         }
                                                      
                                                      .
                                                   
                                                
                                             
                                          
                                       

The necessity and incompatibility of a feature f is the cardinal of its impact and exclusion sets, respectively, divided by the total number of features 
                                             
                                                #
                                                F
                                                ,
                                             
                                           i.e.,

                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               Necessity
                                                               (
                                                               f
                                                               )
                                                            
                                                         
                                                         
                                                            =
                                                         
                                                         
                                                            
                                                               
                                                                  
                                                                     #
                                                                     
                                                                        Impact
                                                                        
                                                                        Set
                                                                     
                                                                  
                                                                  
                                                                     #
                                                                     F
                                                                  
                                                               
                                                               ,
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               
                                                                  Incompatibility
                                                               
                                                               (
                                                               f
                                                               )
                                                            
                                                         
                                                         
                                                            =
                                                         
                                                         
                                                            
                                                               
                                                                  
                                                                     #
                                                                     
                                                                        Exclusion
                                                                        
                                                                        Set
                                                                     
                                                                  
                                                                  
                                                                     #
                                                                     F
                                                                  
                                                               
                                                               .
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       

For instance, Table 1
                                  summarizes feature co-occurrences in Fig. 1. According to Eq. (1), all products that include f
                                 4, f
                                 5, or f
                                 6, also include f
                                 3. So the impact set of f
                                 3 is {f
                                 3, f
                                 4, f
                                 5, f
                                 6} , and its necessity is 
                                    
                                       4
                                       6
                                    
                                  (it is required by 4 of the 6 features).

In the same way, if the focus is changed to looking at how features interact with each other in all derivatives, a feature f belongs to f′ exclusion set if there is NO product including f and f′. Fig. 2
                         depicts a variability model where feature f
                        1 is included in 32 valid derivatives. Among them, just one includes f
                        7 and so it might be convenient to consider f
                        7 as part of f
                        1’s exclusion set.

In Section 4, we propose a measure redefinition where ALL and NONE can be flexibilized to MOST OF and ALMOST NONE. Moreover, we provide an algorithm that supports that flexibilization.

@&#RELATED WORK@&#

To model the configurable options of a product family, a number of different notations are available. For instance, Feature Diagrams (FD) (Kang et al., 1990), Decision Diagrams (guidebook, 1993), the Configit language,
                        1
                     
                     
                        1
                        
                           http://configit.com/.
                      the SAP Product Configurator language,
                        2
                     
                     
                        2
                        
                           https://scn.sap.com/docs/DOC-25224.
                      the Oracle Configurator language,
                        3
                     
                     
                        3
                        
                           http://www.oracle.com/us/products/applications/ebusiness/scm/051314.html.
                      etc. Interestingly, most of those notations are semantically equivalent (Czarnecki, Grünbacher, Rabiser, Schmid, & Wasowski, 2012; Schobbens, Heymans, Trigaux, & Bontemps, 2007). In fact, instead of processing models directly, automated tools for variability management usually translate them into a propositional logic representation, such as a logic formula in conjunctive normal form, a BDD, etc. That logic representation is then processed using off-the-self tools, such as SAT solvers, BDD engines, etc. (Zhang, Xu, Yu, & Jiao, 2012)

For instance, Eq. (2) shows the Boolean encoding of Fig. 1. The first row means that at least one of the six features has to be selected. The second and third rows encode constraints between those features. The second row encodes five dependencies, for example ¬f
                     2∨f
                     3 means that f
                     2 requires f
                     3. The third row encodes three incompatibilities, for example ¬f
                     1∨¬f
                     2 means that f
                     1 is incompatible with f
                     2,

                        
                           (2)
                           
                              
                                 
                                    
                                       ψ
                                    
                                    
                                       =
                                    
                                    
                                       
                                          (
                                          
                                             f
                                             1
                                          
                                          ∨
                                          
                                             f
                                             2
                                          
                                          ∨
                                          
                                             f
                                             3
                                          
                                          ∨
                                          
                                             f
                                             4
                                          
                                          ∨
                                          
                                             f
                                             5
                                          
                                          ∨
                                          
                                             f
                                             6
                                          
                                          )
                                          ∧
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          
                                             (
                                             ¬
                                             
                                                f
                                                2
                                             
                                             ∨
                                             
                                                f
                                                3
                                             
                                             )
                                          
                                          ∧
                                          
                                             (
                                             ¬
                                             
                                                f
                                                3
                                             
                                             ∨
                                             
                                                f
                                                1
                                             
                                             )
                                          
                                          ∧
                                          
                                             (
                                             ¬
                                             
                                                f
                                                4
                                             
                                             ∨
                                             
                                                f
                                                3
                                             
                                             )
                                          
                                          ∧
                                          
                                             (
                                             ¬
                                             
                                                f
                                                5
                                             
                                             ∨
                                             
                                                f
                                                3
                                             
                                             )
                                          
                                          ∧
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          
                                             (
                                             ¬
                                             
                                                f
                                                6
                                             
                                             ∨
                                             
                                                f
                                                3
                                             
                                             )
                                          
                                          ∧
                                          
                                             (
                                             ¬
                                             
                                                f
                                                1
                                             
                                             ∨
                                             ¬
                                             
                                                f
                                                2
                                             
                                             )
                                          
                                          ∧
                                          
                                             (
                                             ¬
                                             
                                                f
                                                4
                                             
                                             ∨
                                             ¬
                                             
                                                f
                                                5
                                             
                                             )
                                          
                                          ∧
                                          
                                             (
                                             ¬
                                             
                                                f
                                                4
                                             
                                             ∨
                                             ¬
                                             
                                                f
                                                6
                                             
                                             )
                                          
                                          .
                                       
                                    
                                 
                              
                           
                        
                     
                  

The usual way to compute the core and dead features of a formula ψ with n features is described by Algorithm 1
                      (Benavides et al., 2007; van Deursen & Klint, 2002; Fernandez-Amoros et al., 2009; Heradio, Fernandez-Amoros, Cerrada, & Cerrada, 2011; Heradio et al., 2013; Mendonça et al., 2009; Pena et al., 2006; Segura, 2008; Trinidad et al., 2008; Trinidad & Cortes, 2009; Yan et al., 2009; Zhang et al., 2006; Zhang et al., 2008; Zhang et al., 2004). The idea is to repeatedly call the sat_count function, one time for each feature f, to get the number of satisfying assignments of ψ∧f. The most common approaches to compute sat_count are:

                        
                           1.
                           Using a #SAT solver. A SAT solver is a program that tries to determine if a Boolean formula is satisfiable. A #SAT model counter is a program that tries to determine how many models (i.e., how many satisfying assignments) a formula has. A simple SAT solver can be easily modified to act as a model counter, and even as an explicit model generator. Nevertheless, as SAT solver techniques grow increasingly specialized, they become useless for these other problems, which demand their own techniques. For instance, it is now customary for solvers to implement timed restarts; if no answer to the SAT problem is found, then the search is interrupted and continued elsewhere. For satisfiable cases, it suffices to find one model, so the technique seems to speed up the process. However, it does not carry over to efficient counting or enumerating of the models. While the SAT problem is known to be NP-complete (Cook, 1971), it is widely believed that the #SAT problem is even harder (Biere, Heule, & van Maaren, 2009).

Using a BDD engine. BDDs are an optimized way of representing Boolean functions by mean of rooted, directed, acyclic graphs (Berghammer & Bolus, 2012; Bryant, 1986). The Achilles heel of BDDs is its size, which depends on the variable ordering the BDD uses to encode ψ. Ordering heuristics can take remarkably long, and it is known that finding an ordering that produces an optimal BDD (i.e. a BDD with the minimal number of nodes) is an NP-complete problem (Bollig & Wegener, 1996). For a BDD with m nodes, computing sat_count has complexity O(m) (Bryant, 1986). So, the time complexity of Algorithm 1 for a model with n features is O(mn).

The straightforward approach to compute the impact and exclusion sets is described by Algorithm 2
                     . It checks the following two conditions for all pairwise combinations of features f and f′:

                        
                           1.
                           If sat_count(ψ∧f) and sat_count(ψ∧f∧f′) coincide then f belongs to the f′ impact set.

If sat_count(ψ∧f∧f′) is zero then f′ belongs to the f exclusion set.

This algorithm requires calling sat_count
                     
                        
                           n
                           ·
                           (
                           n
                           −
                           1
                           )
                        
                      times. Therefore, if the computation is performed with a BDD the complexity is O(mn
                     2).


                     Boender (2011), Boender (2011), Boender et al. (2011) propose the alternative Algorithm 3
                     , which includes the following shortcut: for each feature f a satisfying assignment a of ψ∧f is computed using the sat_one function (line 9), which has time complexity O(m) (Bryant, 1986). If a feature f′ is true in a, it cannot belong to f exclusion set (i.e., since there is at least one derivative than include both f and f′, they cannot be incompatible). So line 18 avoids the unnecessary computation sat_count(ψ∧f∧f′) for such f′ (in lines 18 and 23, the symbol \ represents set difference). Analogously, if a feature f′ is false in a, f cannot be part of f impact set, and so line 22 avoids calling sat_count(ψ∧f∧f′). Although the time complexity for Algorithm 3 is the same that for Algorithm 2, in practice it usually saves steps and thus runs faster.

This section is organized in four subsections. First, Subsection 4.1 redefines the measures introduced in Section 2.2 to increase their sensitivity. Then, Subsection 4.2 describes two algorithms that compute the measures. Those algorithms require the auxiliary computation of feature probability, which is described in Subsection 4.3. Finally, Subsection 4.4 discusses the computational cost of all the algorithms considered in this paper.

The sensitivity of existing measures can be augmented using the concept of feature probability, which accounts for the likeliness of a feature to be included in a derivative.

                           Definition 1
                           The probability of a feature f is calculated as:

                                 
                                    
                                       
                                          
                                             Pr
                                          
                                          
                                             (
                                             f
                                             )
                                          
                                          =
                                          
                                             
                                                
                                                   Number
                                                   
                                                   of
                                                   
                                                   valid
                                                   
                                                   derivatives
                                                   
                                                   that
                                                   
                                                   include
                                                   
                                                
                                                f
                                             
                                             
                                                Total
                                                
                                                number
                                                
                                                of
                                                
                                                valid
                                                
                                                derivatives
                                             
                                          
                                          .
                                       
                                    
                                 
                              
                           


                        Table 2
                         summarizes feature probabilities for Fig. 1. For instance, looking at Eq. (1) it can be checked that feature f
                        3 is included in 5 of the 6 valid derivatives, so its probability is 
                           
                              5
                              6
                           
                         .

Let sensitivity be a number between 0 and 1. The measures this paper deals with can be redefined as follows.

                           Definition 2
                           A feature f is core or dead under sensitivity α iif Eqs. (3) or (4) holds, respectively

                                 
                                    (3)
                                    
                                       
                                          
                                             Pr
                                          
                                          (
                                          f
                                          )
                                          ≥
                                          (
                                          1
                                          −
                                          α
                                          )
                                       
                                    
                                 
                              
                              
                                 
                                    (4)
                                    
                                       
                                          
                                             Pr
                                          
                                          (
                                          f
                                          )
                                          ≤
                                          α
                                          .
                                       
                                    
                                 
                              
                           

For example, under sensitivity 0.2, f
                        3 is considered core (i.e., 
                           
                              
                                 5
                                 6
                              
                              ≥
                              1
                              −
                              −
                              0.2
                           
                        ), and f
                        4 dead (i.e., 
                           
                              
                                 1
                                 6
                              
                              ≤
                              0.2
                           
                        ).

                           Definition 3
                           The probability Pr(f|f′) of a feature f conditioned to another feature f′ is calculated as:

                                 
                                    
                                       
                                          
                                             
                                             
                                             
                                                
                                                   
                                                      Pr
                                                   
                                                   (
                                                   f
                                                   )
                                                
                                             
                                          
                                          
                                             
                                             
                                             
                                                
                                                   
                                                   =
                                                   
                                                      
                                                         
                                                            Number
                                                            
                                                            of
                                                            
                                                            those
                                                            
                                                            derivatives
                                                            
                                                            that
                                                            
                                                            including
                                                            
                                                         
                                                         
                                                            f
                                                            ′
                                                         
                                                         
                                                            
                                                            also
                                                            
                                                            include
                                                            
                                                         
                                                         f
                                                      
                                                      
                                                         
                                                            Number
                                                            
                                                            of
                                                            
                                                            derivatives
                                                            
                                                            that
                                                            
                                                            include
                                                            
                                                         
                                                         
                                                            f
                                                            ′
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           

For instance, from all the derivatives summarized by Eq. (1), only the following two include f
                        5: {{f
                        1, f
                        3, f
                        5}, {f
                        1, f
                        3, f
                        5, f
                        6}}. As just one of them includes f
                        6, 
                           
                              
                                 Pr
                              
                              
                                 (
                                 
                                    f
                                    6
                                 
                                 |
                                 
                                    f
                                    5
                                 
                                 )
                              
                              =
                              
                                 1
                                 2
                              
                           
                        .

                           Definition 4
                           The impact set of a feature f under sensitivity α is composed of all the features f′ that require f to be enabled whenever they are included in at least 
                                 
                                    1
                                    −
                                    α
                                 
                               of the derivatives, i.e.,

                                 
                                    
                                       
                                          
                                             
                                                Impact
                                                
                                                Set
                                             
                                             α
                                          
                                          
                                             (
                                             f
                                             )
                                          
                                          =
                                          
                                             {
                                             
                                                f
                                                ′
                                             
                                             ·
                                             
                                                Pr
                                             
                                             
                                                (
                                                f
                                                |
                                                
                                                   f
                                                   ′
                                                
                                                )
                                             
                                             ≥
                                             
                                                (
                                                1
                                                −
                                                α
                                                )
                                             
                                             }
                                          
                                          .
                                       
                                    
                                 
                              
                           


                        Table 3
                         summarizes the conditional probabilities for all features in Fig. 3. Let us suppose sensitivity is 0.2, then the impact set of f
                        3 is {f
                        1, f
                        3, f
                        4, f
                        5, f
                        6} (i.e., those features whose rows are ≥ 0.8 in column f
                        3).

                           Definition 5
                           The exclusion set of a feature f under sensitivity α is composed of all the features f′ that are required to be disabled in at least 
                                 
                                    1
                                    −
                                    α
                                 
                               of the derivatives that include f, i.e.,

                                 
                                    
                                       
                                          
                                             
                                                Exclusion
                                                
                                                Set
                                             
                                             α
                                          
                                          
                                             (
                                             f
                                             )
                                          
                                          =
                                          
                                             {
                                             
                                                f
                                                ′
                                             
                                             ·
                                             
                                                Pr
                                             
                                             
                                                (
                                                
                                                   f
                                                   ′
                                                
                                                |
                                                f
                                                )
                                             
                                             ≤
                                             α
                                             }
                                          
                                          .
                                       
                                    
                                 
                              
                           

For example, according to Table 3, the exclusion set of f
                        3 with sensitivity 0.2 is {f
                        2, f
                        4} (i.e., those features whose columns are ≤ 0.2 in row f
                        3).

Note that Definitions 2, 4, and 5 coincide with the rigid ones given in Section 2.2 for the extreme case when sensitivity is 0.

The following Subsection 4.3 presents the algorithm get_prob that computes the feature probabilities of a variability model encoded as a BDD. Using that algorithm:

                           
                              1.
                              The identification of all core and dead features in a variability model considering a given sensitivity is performed by Algorithm 4.
                                  To do so, the algorithm builds the BDD that encodes the formula ψ according to an input variable ordering. Remember from Section 3 that ψ is the Boolean representation of the input variability model. The variable ordering is specified using an array which sets how variables are arranged in the BDD (see Section 4.3.2). Then, feature probabilities are computed by calling Algorithm 6
                                  using the BDD as input parameter (line 8). Finally, Definitions 3 and 4 are applied to check if the features are core or dead according to their probability(lines 11–14).

The impact and exclusion sets of all features in a variability model considering a given sensitivity is computed by Algorithm 5. To do so, for each feature f, the algorithm builds a BDD that encodes the formula ψ∧f (line 11). Afterwards, feature probabilities are computed by calling Algorithm 6 (line 12), and those probabilities are used to compute the impact and exclusion sets according to Definitions 4 and 5 (lines 15–18).

BDDs are a way of representing Boolean functions. They are rooted, directed, acyclic graphs, which consist of several decision nodes and terminal nodes (Bryant, 1986). There are two types of terminal nodes called 0-terminal and 1-terminal. Each decision node vi
                         is labeled by a Boolean variable xk
                         and has two child nodes called low and high (which are usually depicted by dashed and solid lines, respectively). The edge from node vi
                         to a low (or high) child represents an assignment of vi
                         to 0 (resp. 1). Such a BDD is called ordered if different variables appear in the same order on all paths from the root. A BDD is said to be reduced if the following two rules have been applied to its graph: (i) isomorphic subgraphs are merged, and (ii) nodes whose two children are isomorphic are eliminated.

Let us use formula ψ ≡ (x
                        1∧x
                        2)∨(x
                        3∧x
                        4) as a running example for this subsection. Table 4
                         is the truth table for ψ. Fig. 3
                         is its BDD
                           4
                        
                        
                           4
                           In popular usage, the term BDD almost always refers to Reduced Ordered Binary Decision Diagram (Huth & Ryan, 2004). In this paper, we will follow that convention as well.
                         representation using the variable ordering x
                        1≺x
                        2≺x
                        3≺x
                        4.
                           5
                        
                        
                           5
                           Note that a logic formula may be encoded with different BDDs according to the variable ordering used to synthesize the BDD. Obviously, our algorithm produces the same results for equivalent BDDs (i.e., BDDs that encode the same formula).
                        
                     

The remainder of this subsection is structured as follows. First, some definitions required to understand our algorithm are given. Next, the data structures the algorithm uses are described from a theoretical perspective. Then, the algorithm is presented. Finally, the algorithm computational cost is discussed.


                           
                              Definition 6
                              The satisfying set of a Boolean formula 
                                    
                                       ψ
                                       (
                                       
                                          x
                                          1
                                       
                                       ,
                                       …
                                       ,
                                       
                                          x
                                          n
                                       
                                       )
                                       ,
                                    
                                  denoted Sψ
                                 , is defined by Eq. (5),

                                    
                                       (5)
                                       
                                          
                                             
                                                S
                                                ψ
                                             
                                             =
                                             {
                                             
                                                (
                                                
                                                   x
                                                   1
                                                
                                                ,
                                                …
                                                ,
                                                
                                                   x
                                                   n
                                                
                                                )
                                             
                                             ·
                                             ψ
                                             
                                                (
                                                
                                                   x
                                                   1
                                                
                                                ,
                                                …
                                                ,
                                                
                                                   x
                                                   n
                                                
                                                )
                                             
                                             =
                                             
                                                true
                                             
                                             }
                                             .
                                          
                                       
                                    
                                 
                              

The satisfying set of the variable xi
                                  of a Boolean formula 
                                    
                                       ψ
                                       (
                                       
                                          x
                                          1
                                       
                                       ,
                                       …
                                       ,
                                       
                                          x
                                          
                                             i
                                             −
                                             1
                                          
                                       
                                       ,
                                       
                                          x
                                          i
                                       
                                       ,
                                       
                                          x
                                          
                                             i
                                             +
                                             1
                                          
                                       
                                       ,
                                       …
                                       ,
                                       
                                          x
                                          n
                                       
                                       )
                                       ,
                                    
                                  denoted 
                                    
                                       
                                          S
                                          
                                             
                                                ψ
                                                |
                                             
                                             
                                                
                                                   x
                                                   i
                                                
                                                =
                                                
                                                   true
                                                
                                             
                                          
                                       
                                       ,
                                    
                                  is defined by Eq. (6),

                                    
                                       (6)
                                       
                                          
                                             
                                                
                                                   
                                                      S
                                                      
                                                         
                                                            ψ
                                                            |
                                                         
                                                         
                                                            
                                                               x
                                                               i
                                                            
                                                            =
                                                            
                                                               true
                                                            
                                                         
                                                      
                                                   
                                                
                                                
                                                   =
                                                
                                                
                                                   
                                                      {
                                                      
                                                         (
                                                         
                                                            x
                                                            1
                                                         
                                                         ,
                                                         …
                                                         ,
                                                         
                                                            x
                                                            
                                                               i
                                                               −
                                                               1
                                                            
                                                         
                                                         ,
                                                         
                                                            true
                                                         
                                                         ,
                                                         
                                                            x
                                                            
                                                               i
                                                               +
                                                               1
                                                            
                                                         
                                                         ,
                                                         …
                                                         ,
                                                         
                                                            x
                                                            n
                                                         
                                                         )
                                                      
                                                      
                                                         ·
                                                         ψ
                                                         (
                                                      
                                                      
                                                         x
                                                         1
                                                      
                                                      ,
                                                      …
                                                      ,
                                                      
                                                         x
                                                         
                                                            i
                                                            −
                                                            1
                                                         
                                                      
                                                      ,
                                                   
                                                
                                             
                                             
                                                
                                                
                                                
                                                   
                                                      
                                                         true
                                                      
                                                      ,
                                                      
                                                         x
                                                         
                                                            i
                                                            +
                                                            1
                                                         
                                                      
                                                      ,
                                                      …
                                                      ,
                                                      
                                                         x
                                                         n
                                                      
                                                      
                                                         )
                                                         =
                                                         
                                                            true
                                                         
                                                         
                                                            }
                                                            .
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              

For instance, according to Table 4, 
                              
                                 #
                                 
                                    S
                                    ψ
                                 
                                 =
                                 7
                              
                            since there are 7 rows where ψ evaluates to true,
                              6
                           
                           
                              6
                              Throughout this paper 0/1 and false/true are used interchangeably.
                            and 
                              
                                 #
                                 
                                    S
                                    
                                       
                                          ψ
                                          |
                                       
                                       
                                          x
                                          4
                                       
                                    
                                 
                                 =
                                 5
                              
                            because 
                              
                                 
                                    x
                                    4
                                 
                                 =
                                 1
                              
                            in 5 of the 7 rows where 
                              
                                 ψ
                                 =
                                 1
                              
                           .

                              Definition 8
                              The satisfying probability of a Boolean formula 
                                    
                                       ψ
                                       (
                                       
                                          x
                                          1
                                       
                                       ,
                                       …
                                       ,
                                       
                                          x
                                          n
                                       
                                       )
                                       ,
                                    
                                  denoted Pr(ψ), is defined by Eq. (7),

                                    
                                       (7)
                                       
                                          
                                             
                                                Pr
                                             
                                             
                                                (
                                                ψ
                                                )
                                             
                                             =
                                             
                                                
                                                   #
                                                   
                                                      S
                                                      ψ
                                                   
                                                
                                                
                                                   2
                                                   n
                                                
                                             
                                             .
                                          
                                       
                                    
                                 
                              

The satisfying marginal probability of a variable xi
                                  in a Boolean formula


                                 
                                    
                                       ψ
                                       (
                                       
                                          x
                                          1
                                       
                                       ,
                                       …
                                       ,
                                       
                                          x
                                          
                                             i
                                             −
                                             1
                                          
                                       
                                       ,
                                       
                                          x
                                          i
                                       
                                       ,
                                       
                                          x
                                          
                                             i
                                             +
                                             1
                                          
                                       
                                       ,
                                       …
                                       ,
                                       
                                          x
                                          n
                                       
                                       )
                                       ,
                                    
                                  denoted 
                                    
                                       
                                          MPr
                                       
                                       (
                                       ψ
                                       
                                          |
                                          
                                             
                                                x
                                                i
                                             
                                             =
                                             
                                                true
                                             
                                          
                                       
                                       )
                                       ,
                                    
                                  is defined by Eq. (8),

                                    
                                       (8)
                                       
                                          
                                             
                                                MPr
                                             
                                             
                                                (
                                                ψ
                                                
                                                   |
                                                   
                                                      
                                                         x
                                                         i
                                                      
                                                      =
                                                      
                                                         true
                                                      
                                                   
                                                
                                                )
                                             
                                             =
                                             
                                                
                                                   #
                                                   
                                                      S
                                                      
                                                         
                                                            ψ
                                                            |
                                                         
                                                         
                                                            
                                                               x
                                                               i
                                                            
                                                            =
                                                            
                                                               true
                                                            
                                                         
                                                      
                                                   
                                                
                                                
                                                   2
                                                   n
                                                
                                             
                                             .
                                          
                                       
                                    
                                 
                              

The satisfying probability of a variable xi
                                  in a Boolean formula 
                                    
                                       ψ
                                       (
                                       
                                          x
                                          1
                                       
                                       ,
                                       …
                                       ,
                                       
                                          x
                                          
                                             i
                                             −
                                             1
                                          
                                       
                                       ,
                                       
                                          x
                                          i
                                       
                                       ,
                                       
                                          x
                                          
                                             i
                                             +
                                             1
                                          
                                       
                                       ,
                                       …
                                       ,
                                       
                                          x
                                          n
                                       
                                       )
                                       ,
                                    
                                  denoted 
                                    
                                       
                                          Pr
                                       
                                       (
                                       ψ
                                       
                                          |
                                          
                                             
                                                x
                                                i
                                             
                                             =
                                             
                                                true
                                             
                                          
                                       
                                       )
                                       ,
                                    
                                  is defined by Eq. (9),

                                    
                                       (9)
                                       
                                          
                                             
                                                Pr
                                             
                                             
                                                (
                                                ψ
                                                
                                                   |
                                                   
                                                      
                                                         x
                                                         i
                                                      
                                                      =
                                                      
                                                         true
                                                      
                                                   
                                                
                                                )
                                             
                                             =
                                             
                                                
                                                   #
                                                   
                                                      S
                                                      
                                                         
                                                            ψ
                                                            |
                                                         
                                                         
                                                            
                                                               x
                                                               i
                                                            
                                                            =
                                                            
                                                               true
                                                            
                                                         
                                                      
                                                   
                                                
                                                
                                                   #
                                                   
                                                      S
                                                      ψ
                                                   
                                                
                                             
                                             .
                                          
                                       
                                    
                                 
                              

For instance, looking at Table 4, it is easy to see that 
                              
                                 
                                    Pr
                                 
                                 
                                    (
                                    ψ
                                    )
                                 
                                 =
                                 
                                    7
                                    
                                       2
                                       4
                                    
                                 
                                 ,
                              
                           
                           
                              
                                 
                                    MPr
                                 
                                 
                                    (
                                    ψ
                                    
                                       |
                                       
                                          
                                             x
                                             4
                                          
                                          =
                                          
                                             true
                                          
                                       
                                    
                                    )
                                 
                                 =
                                 
                                    5
                                    
                                       2
                                       4
                                    
                                 
                                 ,
                              
                            and 
                              
                                 
                                    Pr
                                 
                                 
                                    (
                                    ψ
                                    
                                       |
                                       
                                          
                                             x
                                             4
                                          
                                          =
                                          
                                             true
                                          
                                       
                                    
                                    )
                                 
                                 =
                                 
                                    5
                                    7
                                 
                              
                           .

For convenience, in the remainder of the paper we denote 
                              
                                 
                                    Pr
                                 
                                 (
                                 ψ
                                 
                                    |
                                    
                                       
                                          x
                                          i
                                       
                                       =
                                       
                                          true
                                       
                                    
                                 
                                 )
                              
                            and 
                              
                                 
                                    MPr
                                 
                                 (
                                 ψ
                                 
                                    |
                                    
                                       
                                          x
                                          i
                                       
                                       =
                                       
                                          true
                                       
                                    
                                 
                                 )
                              
                            as Pr(xi
                           ) and MPr(xi
                           ), respectively, which is consistent with the notation introduced in Definition 1 (i.e., if a variability model is encoded by ψ then: 
                              
                                 #
                                 
                                    S
                                    
                                       
                                          ψ
                                          |
                                       
                                       
                                          
                                             f
                                             i
                                          
                                          =
                                          
                                             true
                                          
                                       
                                    
                                 
                              
                            represents the number of derivatives than include fi
                           , 
                              
                                 #
                                 
                                    S
                                    ψ
                                 
                              
                            is the total number of derivatives, and consequently, 
                              
                                 
                                    Pr
                                 
                                 
                                    (
                                    ψ
                                    
                                       |
                                       
                                          
                                             f
                                             i
                                          
                                          =
                                          
                                             true
                                          
                                       
                                    
                                    )
                                 
                                 =
                                 
                                    Pr
                                 
                                 
                                    (
                                    
                                       f
                                       i
                                    
                                    )
                                 
                              
                           ).

Let us represent a BDD that has m nodes and encodes a Boolean formula with n variables by using the following data structures:

                              
                                 •
                                 The variable ordering used to synthesize the BDD is represented by an array declared as follows:


                                    
                                       
                                          
                                             
                                                var
                                                _
                                                ordering
                                                :
                                                
                                                array
                                                
                                                [
                                                0
                                                .
                                                .
                                                n
                                                −
                                                1
                                                ]
                                                
                                                of
                                                
                                                string
                                             
                                          
                                       
                                    
                                 

Each node is represented by a record declared as follows:


                                    
                                       
                                          
                                             
                                                
                                                   
                                                   
                                                   
                                                      
                                                         
                                                            type
                                                            
                                                            node
                                                            =
                                                            record
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                   
                                                   
                                                      
                                                         
                                                         
                                                         
                                                         
                                                            index
                                                            :
                                                            
                                                            0
                                                            .
                                                            .
                                                            n
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                   
                                                   
                                                      
                                                         
                                                         
                                                         
                                                         
                                                            low
                                                            ,
                                                            high
                                                            :
                                                            
                                                            node
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                   
                                                   
                                                      
                                                         
                                                         
                                                         
                                                         
                                                            mark
                                                            :
                                                            
                                                            Boolean
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                   
                                                   
                                                      
                                                         end
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 

Where:

                                       
                                          1.
                                          
                                             index is the index of the variables in the ordering. The terminal nodes of the BDD (i.e., 0 and 1) have index n.


                                             low and high are the low and high node successors.


                                             mark is used to mark which nodes have been visited during a traversal of the graph. As we will see, our algorithm is called at the top level with the root node as argument and with the mark fields of the nodes being either all true or all false. It then systematically visits every node in the graph by recursively visiting the subgraphs rooted by the two children low and high. As it visits a node, it complements the value of the mark field, so that it can later determine whether a child has already been visited by comparing the two marks.

The BDD is represented by an array declared as follows:


                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         bdd
                                                         :
                                                         
                                                         array
                                                         [
                                                         0
                                                         .
                                                         .
                                                         m
                                                         ]
                                                         
                                                         of
                                                         
                                                         node
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 

The terminal nodes of the BDD, 0 and 1, are stored at positions 0 and 1 of the bdd array, respectively.

For instance, Tables 5
                            and 6
                            represent the content of bdd and var_ordering for the BDD in Fig. 3, respectively.

Pr(xi
                           ) is computed jointly by Algorithms 6–8
                           
                           . Fig. 4
                            summarizes the computations for the BDD in Fig. 3. Let us examine how our approach proceeds:


                           Algorithm 6 Computes Pr(xi
                           ) as 
                              
                                 
                                    Pr
                                 
                                 
                                    (
                                    
                                       x
                                       i
                                    
                                    )
                                 
                                 =
                                 
                                    
                                       
                                          MPr
                                       
                                       (
                                       
                                          x
                                          i
                                       
                                       )
                                    
                                    
                                       
                                          Pr
                                       
                                       (
                                       ψ
                                       )
                                    
                                 
                              
                            by calling the auxiliary Algorithms 7 and 8.


                           Algorithm 7 Computes Pr(ψ). A nice mental picture to understand Algorithm 7 is thinking in pouring 1 liter of water from the BDD root to the terminal nodes. 1 liter goes through the root, then half a liter goes through the low branch and half a liter through the high branch. This procedure advances until the water reaches the leaves. Hence, MPr(xi
                           ) is the amount of water that node 1 has.

In Fig. 3, through node v
                           5 goes 1 liter (i.e., formula_sat_prob[5]
                              7
                           
                           
                              7
                              According to Tables 5 and 6, the root node has label v
                                 5 and it is in the position 5 of the bdd array.
                            = 1). Half of it goes to v
                           3 and the other half to v
                           4. Whereas through v
                           4 passes 
                              
                                 1
                                 2
                              
                            liter, through v
                           3 goes the 
                              
                                 1
                                 2
                              
                            liter that comes from v
                           5 and half of the water that comes from v
                           4 (i.e., formula_sat_prob[3] = 
                              
                                 
                                    1
                                    2
                                 
                                 +
                                 
                                    
                                       1
                                       2
                                    
                                    2
                                 
                                 =
                                 
                                    3
                                    4
                                 
                              
                           ).


                           Algorithm 8 Computes MPr(xi
                           ). In particular, let us examine how it computes MPr(x
                           2). In the truth Table 4, ψ evaluates to true when x
                           2 is true five times:

                              
                                 1.
                                 In four of them x
                                    1 is true. When the call get_marginal_prob(4, ...) is made, lines 10–23 compute the marginal probability of x
                                    2 for the explicit path v
                                    5 → v
                                    4. The probabilities due to the low and high branches of vi
                                     are stored into the prob_low and prob_high variables, respectively. As bdd[4].low ≠ 0, a recursive call is made to compute the total probability due to the low descendants of v
                                    4 (i.e., get_marginal_prob(3, ...)). As a result:

                                       
                                          
                                             
                                                
                                                   total
                                                   _
                                                   prob
                                                
                                                
                                                   [
                                                   3
                                                   ]
                                                
                                                =
                                                
                                                   
                                                      prob
                                                      _
                                                      low
                                                   
                                                   
                                                      v
                                                      3
                                                   
                                                
                                                +
                                                
                                                   
                                                      prob
                                                      _
                                                      high
                                                   
                                                   
                                                      v
                                                      3
                                                   
                                                
                                                =
                                                0
                                                +
                                                
                                                   3
                                                   16
                                                
                                                =
                                                
                                                   3
                                                   16
                                                
                                                .
                                             
                                          
                                       
                                    
                                 

Notice that prob_low
                                    
                                       
                                          
                                          
                                             x
                                             2
                                          
                                       
                                     is not simply equal to total_prob[3], because total_prob[3] depends also on the probability that comes from the link 
                                       
                                          
                                             v
                                             5
                                          
                                          ⤏
                                          
                                             v
                                             3
                                          
                                       
                                    . To get just the probability due to the link 
                                       
                                          
                                             v
                                             4
                                          
                                          ⤏
                                          
                                             v
                                             3
                                          
                                          ,
                                       
                                     
                                    prob_low has to be adjusted using the formula_sat_prob array as:

                                       
                                          
                                             
                                                
                                                   prob
                                                   _
                                                   low
                                                
                                                =
                                                
                                                   
                                                      
                                                         total
                                                         _
                                                         prob
                                                      
                                                      
                                                         [
                                                         3
                                                         ]
                                                      
                                                      ·
                                                      
                                                         
                                                            
                                                               formula
                                                               _
                                                               sat
                                                               _
                                                               prob
                                                            
                                                            [
                                                            4
                                                            ]
                                                         
                                                         2
                                                      
                                                   
                                                   
                                                      
                                                         formula
                                                         _
                                                         sat
                                                         _
                                                         prob
                                                      
                                                      [
                                                      3
                                                      ]
                                                   
                                                
                                                =
                                                
                                                   
                                                      
                                                         3
                                                         16
                                                      
                                                      ·
                                                      
                                                         
                                                            1
                                                            2
                                                         
                                                         2
                                                      
                                                   
                                                   
                                                      3
                                                      4
                                                   
                                                
                                                =
                                                
                                                   1
                                                   16
                                                
                                                .
                                             
                                          
                                       
                                    
                                 

Since bdd[4].high = 1, prob_high is directly computed as:

                                       
                                          
                                             
                                                
                                                   prob
                                                   _
                                                   high
                                                
                                                =
                                                
                                                   
                                                      
                                                         formula
                                                         _
                                                         sat
                                                         _
                                                         prob
                                                      
                                                      [
                                                      4
                                                      ]
                                                   
                                                   2
                                                
                                                =
                                                
                                                   
                                                      1
                                                      2
                                                   
                                                   2
                                                
                                                =
                                                
                                                   1
                                                   4
                                                
                                                .
                                             
                                          
                                       
                                    
                                 

Finally:

                                       
                                          
                                             
                                                
                                                   prob
                                                
                                                
                                                   [
                                                   
                                                      bdd
                                                   
                                                   
                                                      [
                                                      4
                                                      ]
                                                   
                                                   .
                                                   
                                                      index
                                                   
                                                   ]
                                                
                                                =
                                                
                                                   prob
                                                   _
                                                   high
                                                
                                                =
                                                
                                                   1
                                                   4
                                                
                                                .
                                             
                                          
                                       
                                    
                                 

In one of them x
                                    1 is false. The two following implicit paths that have been removed from the reduced BDD: (i) 
                                       
                                          
                                             v
                                             5
                                          
                                          ⤏
                                          
                                             v
                                             4
                                          
                                          ⤏
                                          
                                             v
                                             3
                                          
                                          ,
                                       
                                     and (ii) 
                                       
                                          
                                             v
                                             5
                                          
                                          ⤏
                                          
                                             v
                                             4
                                          
                                          →
                                          
                                             v
                                             3
                                          
                                       
                                    . Nevertheless, path 
                                       
                                          
                                             v
                                             5
                                          
                                          ⤏
                                          
                                             v
                                             4
                                          
                                          →
                                          
                                             v
                                             3
                                          
                                       
                                     should be considered to compute the marginal probability of x
                                    2. Lines 24–31 account for that kind of implicit paths, adjusting the marginal probability with the variables omitted in the paths. For instance, when the algorithm is called for v
                                    5, the marginal probability of x
                                    2 is updated with half the prob_low of v
                                    5.

To sum up:

                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   MPr
                                                
                                                (
                                                
                                                   x
                                                   2
                                                
                                                )
                                             
                                          
                                          
                                             =
                                          
                                          
                                             
                                                
                                                   MPr
                                                
                                                
                                                   (
                                                   
                                                      v
                                                      5
                                                   
                                                   ⤏
                                                   
                                                      v
                                                      4
                                                   
                                                   →
                                                   
                                                      v
                                                      3
                                                   
                                                   )
                                                
                                                +
                                                
                                                   MPr
                                                
                                                
                                                   (
                                                   
                                                      v
                                                      5
                                                   
                                                   →
                                                   
                                                      v
                                                      4
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                       
                                          
                                          
                                             =
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         prob
                                                         _
                                                         low
                                                      
                                                      
                                                         v
                                                         5
                                                      
                                                   
                                                   2
                                                
                                                +
                                                
                                                   prob
                                                
                                                
                                                   [
                                                   
                                                      bdd
                                                   
                                                   
                                                      [
                                                      4
                                                      ]
                                                   
                                                   .
                                                   
                                                      index
                                                   
                                                   ]
                                                
                                             
                                          
                                       
                                       
                                          
                                          
                                             =
                                          
                                          
                                             
                                                
                                                   
                                                      1
                                                      8
                                                   
                                                   2
                                                
                                                +
                                                
                                                   1
                                                   4
                                                
                                                =
                                                
                                                   5
                                                   16
                                                
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

Let m be the number of nodes of the BDD, and n the number of variables of the Boolean formula. Algorithm 7 requires traverse all the nodes, so its computational complexity is O(m). Algorithm 8 also traverses all the BDD nodes. In addition, to account for the implicit paths removed from the reduced BDD, the variables omitted on the edges that come from each node need to be traversed (which is done by lines 24–31).


                        Table 7
                         summarizes those traversals for Fig. 3. For instance, when v
                        4 is recursively traversed, the variables x
                        3 and x
                        4 need to be iteratively traversed because the edge v
                        4 → 1 omits them (i.e., the variable encoded by node v
                        4, x
                        2, jumps directly to 1 omitting the intermediate variables x
                        3 and x
                        4 in the ordering x
                        1≺x
                        2≺x
                        3≺x
                        4). Table 7 helps noticing the savings our algorithm provides compared to the straightforward approach (Algorithms 1 and 2), which requires traversing all nodes for all variables (which in computational cost terms is equivalent to traversing all variables for every node).

Therefore, Algorithm 8 does not traverse mn elements, but mn′, where n′ is strictly less than n. If 
                           
                              
                                 n
                                 ′
                              
                              =
                              n
                              ,
                           
                         all nodes in the BDD should go directly to 0 or 1, jumping over all the variables. Nevertheless, as BDDs are organized in hierarchical levels according to the variable ordering, this is impossible (i.e., the nodes that encode a variable with position k in the ordering only can jump over the variables with positions 
                           
                              k
                              +
                              1
                              …
                              n
                           
                        ).

It follows that Algorithm 6 has computational complexity O(mn′), and thus, Algorithms 4 and 5 have complexity O(mn′) and O(mn′n), respectively.


                        Table 8
                         summarizes the complexities for Algorithms 1–5. Our approach has the best time complexity. Nevertheless, computational complexity O only provides an upper bound on the worst time required by the algorithms. As it will be empirically shown in Section 5, in practice our approach is also the fastest for all the evaluated cases. In particular:

                           
                              1.
                              
                                 Algorithms 1 and 2 run always on the worst case, i.e., they require traversing mn and mn
                                 2 for all variability models, respectively.

Thanks to its lines 18 and 22, Algorithm 3 saves a number of iterations, requiring in practice mnn′′ steps where n′′ is usually < n.


                                 Algorithm 5 requires mnn′ iterations and, on average requires less time than Algorithm 3, i.e., n′ ≪ n′′.

To sum up, our approach not only provides new functionality (i.e., it can take into account different levels of sensitivity) but also it is more time-efficient than related work.

The goal of this section is to experimentally check if:

                        
                           •
                           Our approach is faster than others. In addition to the theoretical evaluation that computational complexity provides (see Section 4.4), it would be desirable to test if in practice our approach has better time performance on real variability models.

The measure flexibilization we propose really helps to detect essential, dispensable and highly incompatible features that would have passed unnoticed using current rigid measures.

The time performance of our approach and related work have been evaluated on a benchmark composed the following models:

                           
                              1.
                              A configuration model provided by the car manufacturing company Renault DVI, which deals with the configuration of a family of cars named Renault Megane. The model is written in the Configit language and can be downloaded from: http://www.itu.dk/research/cla/externals/clib/.

A configuration model for laptops, which was reverse engineered from the DELL homepage on February 2009 by Nöhrer (Nöhrer, Biere, & Egyed, 2012; Nöhrer & Egyed, 2011; Nöhrer & Egyed, 2013). The model is specified as a decision model and can be downloaded from the C2O website: http://www.sea.jku.at/tools/c2o.

All feature models from the SPLOT repository including more than 100 features: Xtext, Battle of Tanks, FM Test, Printers, Banking Software, Electronic Shopping, and a Model for Decision-making for Investments on Enterprise Information Systems. Those models can be downloaded from the SPLOT website: http://www.splot-research.org/.

To support the reliable comparison of the algorithms described in this paper, all of them have been implemented extending the BuDDy package for BDDs, which is freely available at: http://sourceforge.net/projects/buddy/
                     


                        Table 9
                        
                         summarizes the results of the performance tests, which were conducted on an Intel© CoreTM 2 i3-4010U with 1.7 gigahertz and 4 gigabyte RAM (although only one core was used). Our approach (Algorithms 4 and 5 parameterized with sensitivity = 0) outperforms related work (Algorithms 1–3) in all the experiments.

It is worth noting that Boender’s shortcut to compute the impact and exclusion sets (Algorithm 3) is not always faster than the straightforward approach (Algorithm 2). Thus, in some cases the extra cost required due to the sat_one call in line 9 of Algorithm 3 does not payoff. In particular, it is slightly slower for the following SPLOT test cases: Xtext, FM Test, Printers, and Banking Software.

The Renault Megane model is a benchmark widely used by the mass customization community (e.g., Amilhastre, Fargier, & Marquis, 2002; Bessiere, Fargier, Lecoutre, & Schulte, 2013; Cambazard & O’Sullivan, 2008; Gange, 2012; Hansen & Tiedemann, 2007; Hebrard, Hnich, O’Sullivan, & Walsh, 2005; Jensen, 2004; Kroer, 2012; Narodytska & Walsh, 2007; O’Sullivan, O’Callaghan, & Freuder, 2005; Queva, 2011). To the extent of our knowledge no author has reported dispensable nor highly incompatible features for the model. Nevertheless, the model includes 6 dead features, i.e., the 1.51 percent of the features cannot be included in any derivative.

If sensitivity is taken into account and so feature probabilities are computed, the perception of feature reusability changes dramatically. Fig. 5
                         shows the histogram of feature probabilities. According to such figure, 53.27 percent of the features are dead at sensitivity 0.05 (see the first bar). In other words, more than half of the features can be reused at most in just 5 percent of the valid derivatives!


                        Fig. 6
                         shows how the number of incompatible feature grows drastically with a small sensitivity increase. According to the rigid version of feature incompatibility, there are 33 features incompatible with at least 50 percent of the remaining ones (8.29 percent of the features). When sensitivity is set to 0.5, that number becomes 380 (95.48 percent of the features).


                        Table 10 summarizes the aforementioned outcomes, highlighting the benefits of using our flexible approach.

@&#CONCLUSIONS@&#

The development and maintenance of product platforms require the management of complex variability models. The role each feature plays in such models is unclear to the naked eye and so automated support is needed to identify which features are essential, dispensable, highly required by other features and highly incompatible with the remaining features. We have exposed the drawbacks of existing approaches to provide that support.

Due to the rigidness of the current measures to account for feature interrelations, relevant information is frequently overlooked. Moreover, existing approaches to automatically compute the measures from variability models have poor time performance.

To overcome such problems, we have increased measure sensitivity by introducing the concepts of feature probability and conditional probability. It has been empirically shown that our measure flexibilization unveils critical information that current measures cannot detect.

Finally, we have provided new algorithms to support the computation of these measures. It has been shown, both theoretically and experimentally, that our algorithms not only can take into account different levels of sensitivity, but also are more time-efficient than related work even for computing the rigid measures.

@&#ACKNOWLEDGMENTS@&#

The authors thank Roberto López Herrejón and Alexander Egyed at the Johannes Kepler University of Linz for their advice.This work has been supported by the Spanish Government under the CICYT project DPI-2013-44776-R, and the Comunidad de Madrid under the RoboCity2030-II excellence research network S2009DPI-1559.

@&#REFERENCES@&#

