@&#MAIN-TITLE@&#Identifying and constructing elemental parts of shafts based on conditional random fields model

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Our work improves the level of semantic understanding of 2D projections in 3D solids reconstruction.


                        
                        
                           
                           It is the first trial to formulate the parts identification task into a classification problem.


                        
                        
                           
                           We employ an advanced classification model, CRFs, to identify the elemental parts.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

3D reconstruction

Shafts

Semantic information

Conditional random fields (CRFs) model

@&#ABSTRACT@&#


               
               
                  Semantic information is very important for understanding 2D engineering drawings. However, this kind of information is implicit so that it is hard to be extracted and understood by computers. In this paper, we aim to identify the semantic information of shafts from their 2D drawings, and then reconstruct the 3D models. The 2D representations of shafts are diverse. By analyzing the characteristics of 2D drawings of shafts, we find that there is always a view which represents the projected outline of the shaft, and each loop in this view corresponds to an elemental part. The conditional random fields (CRFs) model is a classification technique which can automatically integrate various features, rather than manually organizing of heuristic rules. We first use a CRFs model to identify elemental parts with semantic information. The 3D elemental parts are then constructed by a parameters template method. Compared with the existing 3D reconstruction methods, our approach can obtain both geometrical information and semantic information of each part of shafts from 2D drawings. Several examples are provided to demonstrate that our algorithm can accurately handle diverse 2D drawings of shafts.
               
            

@&#INTRODUCTION@&#

2D engineering drawings have been taken as a standard language to carry out mechanical designs since the 19th century  [1]. From then on, many engineering drawings have been accumulated which are useful for design reuse. Currently, they still play a key role in engineering practices since many product designs are definitively represented in the format of 2D engineering drawings. Moreover, many small to medium size manufacturing companies directly use the 2D CAD software to do design work. However, 3D solid models have become more useful CAD tools  [2] for visualization, modification and some other operations in downstream computer-aided manufacturing processes  [3]. Considering that much of the existing product design documentation is described by 2D engineering drawings, it is necessary to convert them to 3D solid models.

@&#RELATED WORK@&#

Since Idesawa  [4] published the first paper on reconstructing 3D models from 2D vector drawings in 1973, many researchers have studied on the field and made great improvements.

There are two main approaches used in the existing 3D reconstruction research  [5]: wireframe-based approach and volume-based approach. The wireframe-based approach was presented by Idesawa  [4] firstly, and then it was formalized by Markowsky and Wesley  [6,7]. This approach generates 3D vertices, edges and faces by matching projection relations among 2D vertices and edges of different views. The volume-based approach identifies elemental entities by matching predefined patterns, and then combines them together using Boolean operations. The former approach has one important advantage over the latter, since it covers wider domain of objects. The latter approach is limited to extrusions of uniform thickness  [8,9] and axis-aligned revolutions  [10,11]. The former approach can reconstruct more complicated objects, including polyhedrons  [12,13] and quadric surfaces  [3,14] without restrictions on their axes. However, the former is generally applicable to three orthographic views, and the latter is more suitable for handling sectional views  [2,15,16] which are commonly used in engineering practices  [17].

In the last few years, many nontraditional algorithms have been provided to deal with 3D reconstruction from 2D drawings. Ibrahim  [18] proposed a new 3D reconstruction framework. It considers the initial object as a prismatic volume at first, and then uses the proposed 3-Space method to identify features which would be removed. Wen et al.  [16] presented a new feature identification algorithm to handle sectional views. The desired features, including explicit features and implicit features, can be recognized by extracting semantic information of incomplete projections in sectional views. In addition, a novel confidence-based algorithm was proposed to validate features.

The current researches are focused on identifying 3D geometric information from 2D engineering drawings  [19]. A 3D object usually consists of several elemental entities. Using the existing volume-based methods, the reconstructed 3D entities just contain 3D geometric information and topological relations. However, their real semantic names in mechanical parts, which can be easily identified by human engineers, are unknown. Moreover, semantics are useful for the manufacture in subsequent processes.

Many researchers have studied on extracting features from 2D drawings  [20–24]. Features are identified by pattern matching, and as defined in these papers capture the semantic information. However, it needs manually define the templates and exact matches. Recently, Zhang et al.  [25] presented a new reconstruction algorithm which can obtain semantic names of elemental entities of shafts. However, both 2D engineering drawings and the process planning information are needed as input of the algorithm, and the semantic names are obtained from the machining operation sheets using text recognition. In this paper, our purpose is to identify elemental entities with semantics of shafts from 2D engineering drawings, and then reconstruct the 3D models.

We observe that the identification task can be regarded as a classification problem. However, it is difficult to get some regular rules for the problem, since the 2D representations of shafts are diverse. The conditional random fields (CRFs) model is one of the most successful methods to solve the structured output classification problem  [26–31]. It can automatically integrate rules. Therefore, in this paper, we are interested in applying a CRFs model to solve the problem. The proposed method first uses a graph formalism to describe the relations among loops of 2D views. Based on the undirected graph model, a CRFs model is applied to identify elemental parts by incorporating attribute features and relation features of these loops. Then, the 3D elemental parts are constructed by a parameters template method. Using the algorithm, we manage to get the semantic information of shafts from 2D drawings and improve the level of semantic understanding in 3D reconstruction.

The rest of the paper is organized as follows. An introduction of the characteristics of engineering drawings of shafts is presented in Section  2, with some definitions and properties. A brief overview of the 3D reconstruction framework is then described in Section  3. The introduction of CRFs model and our elemental parts identification algorithm are proposed in Section  4. The construction algorithm of 3D elemental parts is described in Section  5. Section  6 shows some experimental results of implementation. Finally, we conclude our work in Section  7.

In this section, we briefly describe the characteristics of 2D drawings of shafts.

The 2D drawings of shafts are not three orthographic views, since three views are superfluous for describing them. In engineering practices, the 2D representations of shafts are diverse. Usually, there are three main ways to represent shafts using 2D views: single view, coincide sections and removed sections. Fig. 1
                      shows the examples. In Fig. 1(a), the single view represents a shaft. The coincide sectional view in Fig. 1(b) represents a shaft with two holes. Fig. 1(c) describes a shaft which has two keyways by removed sections. Note that there is always a view that represents the projected outline of the shaft, no matter what kind of 2D representation is used.
                        Definition 1
                        Main View


                        It is one of the 2D views of a shaft, which describes the projected outline of the shaft.

For example, in Fig. 1(a) and (b), the single view is the main view, and in Fig. 1(c), the non-sectional view is the main view. 
                        Definition 2
                        Main Loop


                        A 2D loop is a simple closed cycle of 2D lines in a view  [2]. Loops in a main view are defined as main loops.

For example, in Fig. 1(a), loop 
                        
                           (
                           a
                           ,
                           b
                           ,
                           c
                           ,
                           d
                           ,
                           a
                           )
                        
                      in the main view is a main loop. 
                        Definition 3
                        Elemental Part


                        An elemental part represents one of the mechanical entities of a shaft and has its definite semantic name.

Hole, keyway and outer diameter (OD) are the most common elemental parts in shafts. Therefore, we only consider these three kinds of elemental parts in this paper. For example, in Fig. 1(a), main loop 
                        
                           (
                           a
                           ,
                           b
                           ,
                           c
                           ,
                           d
                           ,
                           a
                           )
                        
                      is corresponding to one of the ODs of this shaft. In shafts of Fig. 1(b) and Fig. 1(c), there are two holes and two keyways respectively, and the others are ODs.

The typical characteristic of 2D drawings of shafts is that each main loop corresponds to one elemental part. For example, in Fig. 1(a), there are 6 main loops and each of them represents an OD of the shaft. 
                        Property 1
                        
                           Each main loop in the  2D  drawing of a shaft corresponds to an elemental part of the shaft.
                        


                     Property 1 is gained from experience, so there is no proof. According to Property 1, we can take main loops as hints to identify elemental parts of shafts from their 2D drawings.

The process of identifying and constructing elemental parts is illustrated in Fig. 2
                     , which is outlined within the pipeline of 3D solids reconstruction framework. The starting point is 2D engineering drawings which are available as vector data in CAD neutral format including .DXF and .DWG. The final output is 3D solid models. This whole process is fully automatic.

In preprocessing stage, a 2D drawing is separated into several views and the view relations are labeled. In 2D views, types (non-section or kinds of sections) of views, center lines, the geometric entities and their topological relations are obtained, as described by Liu  [14] and Gong  [32].

Four main steps involved in the elemental parts reconstruction phase are as follows. 
                        
                           (1)
                           
                              Main views determining.

The main views are determined automatically in a certain order. If there is only one view, then this view is determined as the main view. Otherwise, non-sections are assigned with higher priority, and the lowest priority is given to removed sections.


                              2D loops searching.

2D loops in all views are obtained from the geometric lines of views via the two-stage loop searching algorithm, as described in  [15]. The first stage is to search inner loops, and the second stage is to partition the outlines of views and extract contour loops. This algorithm can find out all the useful loops in both sectional views and non-sectional views.


                              Elemental parts identification.

Main loops and the 2D views are subsequently input to the algorithm of elemental parts identification. The main task here is to label each main loop with proper elemental part. The proposed method first generates an undirected loop relation graph by detecting their collocation and relations. After that, the elemental parts that correspond to all the main loops are determined by collecting attributes of these loops and their relations based on a CRFs model. The procedure is described in detail in Section  4.


                              3D elemental parts construction.

The major task in this stage is to get the 3D geometric parameters for each elemental part to be produced. For a shaft, its elemental parts mentioned in this paper are either extrusions or revolutions, and can be described by some definitive parameters. Therefore, we define three parameters templates for the three types of elemental parts. The details are described in Section  5.

Finally, the constructed 3D elemental parts are combined together via Boolean operations to form the 3D solid models.

In this section, we introduce how to identify elemental parts from main loops.

According to Property 1, one main loop corresponds to one elemental part. The main task here is to identify what kind of elemental part is for each main loop. Therefore, the problem of identifying elemental parts can be transformed into a classification problem. Each category relates to a type of elemental part, and we need to classify each main loop into one of the three categories: hole, keyway and OD.

Conditional random fields (CRFs) model introduced by Lafferty [26] is a discriminative probabilistic model most often used for classification tasks. It can automatically combine various features to predict the corresponding labels (or categories) for the main loops, and can also utilize the label relationship for the prediction task, which can get a global optimization result for all the main loops of a shaft. This proves to be much better than independent prediction for each loop. Additionally, it can handle undefined cases compared to the template-based methods. Therefore, we propose to employ a general CRFs model to identify the semantic categories and solve the elemental parts identification task.

In the next two subsections, we first introduce the background of CRFs models, and then show how to employ a CRFs model to solve the elemental parts identification task.

CRFs model provides a powerful framework for representation and inference for structure data prediction. It has been proven useful in various areas, including computer vision  [33,34], natural language processing  [35,36] and web information extraction  [37].


                        Fig. 3
                         shows the structure of linear chain CRFs model. There are two types of nodes 
                           V
                           =
                           X
                           ⋃
                           Y
                        , where 
                           X
                         is a set of input nodes, which are assumed to be observed, and 
                           Y
                         is a set of output nodes, which are the hidden labels we wish to predict. The conditional random fields model is defined as  [38]:

(Conditional random fields model). Let 
                           G
                           =
                           
                              {
                              V
                              ,
                              E
                              }
                           
                         be a graph, where the vertices 
                           V
                         are the set of 
                           X
                         and 
                           Y
                        , the edges 
                           E
                         denote their relationships. Then 
                           G
                         is a conditional random fields model and, when conditioned on 
                           X
                        , the random variable 
                           
                              
                                 Y
                              
                              
                                 i
                              
                           
                         obeys the Markov property with respect to the graph 
                           p
                           
                              (
                              
                                 
                                    Y
                                 
                                 
                                    i
                                 
                              
                              |
                              X
                              ,
                              
                                 
                                    Y
                                 
                                 
                                    j
                                 
                              
                              ,
                              j
                              ≠
                              i
                              )
                           
                           =
                           p
                           
                              (
                              
                                 
                                    Y
                                 
                                 
                                    i
                                 
                              
                              |
                              X
                              ,
                              
                                 
                                    Y
                                 
                                 
                                    j
                                 
                              
                              ,
                              j
                              ∼
                              i
                              )
                           
                        , where 
                           j
                           ∼
                           i
                         means that 
                           j
                         and 
                           i
                         are neighbors in 
                           G
                        . We also denote 
                           θ
                           =
                           
                              {
                              
                                 
                                    λ
                                 
                                 
                                    k
                                 
                              
                              }
                           
                           ∈
                           
                              
                                 ℜ
                              
                              
                                 K
                              
                           
                         be a parameter vector, and 
                           
                              
                                 
                                    {
                                    
                                       
                                          f
                                       
                                       
                                          k
                                       
                                    
                                    
                                       (
                                       y
                                       ,
                                       
                                          
                                             y
                                          
                                          
                                             ′
                                          
                                       
                                       ,
                                       
                                          
                                             x
                                          
                                          
                                             t
                                          
                                       
                                       )
                                    
                                    }
                                 
                              
                              
                                 k
                                 =
                                 1
                              
                              
                                 K
                              
                           
                         be a set of feature functions. Then a conditional random fields model is a distribution 
                           p
                           
                              (
                              y
                              |
                              x
                              )
                           
                         that takes the form 
                           
                              (1)
                              
                                 p
                                 
                                    (
                                    
                                       y
                                    
                                    |
                                    
                                       x
                                    
                                    )
                                 
                                 =
                                 
                                    
                                       1
                                    
                                    
                                       Z
                                       
                                          (
                                          
                                             x
                                          
                                          )
                                       
                                    
                                 
                                 
                                    
                                       ∏
                                    
                                    
                                       t
                                       =
                                       1
                                    
                                    
                                       T
                                    
                                 
                                 exp
                                 
                                    {
                                    
                                       
                                          ∑
                                       
                                       
                                          k
                                          =
                                          1
                                       
                                       
                                          K
                                       
                                    
                                    
                                       
                                          λ
                                       
                                       
                                          k
                                       
                                    
                                    
                                       
                                          f
                                       
                                       
                                          k
                                       
                                    
                                    
                                       (
                                       
                                          
                                             y
                                          
                                          
                                             t
                                          
                                       
                                       ,
                                       
                                          
                                             y
                                          
                                          
                                             t
                                          
                                          
                                             ′
                                          
                                       
                                       ,
                                       
                                          
                                             x
                                          
                                          
                                             t
                                          
                                       
                                       )
                                    
                                    }
                                 
                                 ,
                              
                           
                         where 
                           Z
                           
                              (
                              
                                 x
                              
                              )
                           
                         is an instance-specific normalization function 
                           
                              
                                 Z
                                 
                                    (
                                    
                                       x
                                    
                                    )
                                 
                                 =
                                 
                                    
                                       ∑
                                    
                                    
                                       y
                                    
                                 
                                 
                                    
                                       ∏
                                    
                                    
                                       t
                                       =
                                       1
                                    
                                    
                                       T
                                    
                                 
                                 exp
                                 
                                    {
                                    
                                       
                                          ∑
                                       
                                       
                                          k
                                          =
                                          1
                                       
                                       
                                          K
                                       
                                    
                                    
                                       
                                          λ
                                       
                                       
                                          k
                                       
                                    
                                    
                                       
                                          f
                                       
                                       
                                          k
                                       
                                    
                                    
                                       (
                                       
                                          
                                             y
                                          
                                          
                                             t
                                          
                                       
                                       ,
                                       
                                          
                                             y
                                          
                                          
                                             t
                                          
                                          
                                             ′
                                          
                                       
                                       ,
                                       
                                          
                                             x
                                          
                                          
                                             t
                                          
                                       
                                       )
                                    
                                    }
                                 
                                 .
                              
                           
                        
                     

The parameter 
                           
                              
                                 λ
                              
                              
                                 k
                              
                           
                         is the weight of feature function 
                           
                              
                                 f
                              
                              
                                 k
                              
                           
                        . We should estimate the parameter value with the labeled training data set.

Note that, in this paper, we use 
                           y
                         (or 
                           
                              
                                 y
                              
                              
                                 t
                              
                           
                        , 
                           
                              
                                 y
                              
                              
                                 ′
                              
                           
                        ) to denote the label for a single observation. For example, there are six labels, 
                           
                              
                                 y
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 y
                              
                              
                                 2
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 y
                              
                              
                                 6
                              
                           
                         in Fig. 3. 
                           
                              y
                           
                         denotes the vector of labels for all observations. For example, in Fig. 3, 
                           
                              y
                           
                           =
                           
                              {
                              
                                 
                                    y
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    y
                                 
                                 
                                    2
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    y
                                 
                                 
                                    6
                                 
                              
                              }
                           
                         is the vector for all the labels. The difference between 
                           
                              x
                           
                         and 
                           x
                         is the same as the difference between 
                           
                              y
                           
                         and 
                           y
                        . 
                           
                              x
                           
                         denotes the vector of all the observations, and 
                           x
                         denotes a single observation. From Eq. (1), we can see that the CRFs model computes the global result for all labels 
                           
                              y
                           
                         simultaneously, not the local result for a single label 
                           y
                        . This is one of the advantages of CRFs model.

To utilize the CRFs model, we need to consider the following three steps. First, since the CRFs model can employ graph structure, we need to determine the relationship among main loops in 2D views. Second, since the CRFs model can integrate various features for label prediction, we need to define the useful feature functions. Finally, we need to know how to estimate the values of parameters 
                           θ
                           =
                           
                              {
                              
                                 
                                    λ
                                 
                                 
                                    k
                                 
                              
                              }
                           
                         and how to find the best predicted labels 
                           
                              y
                           
                        , given a new 2D drawing. We will introduce these steps in the following three sub-sections.

In this step, we will construct the graph structures for CRFs model based on the position relations among main loops. Firstly, we define several relations between two loops.

(Loop relations). Loop relations describe the position relations between two different loops. There are five types of loop relations that are listed as follows: 
                              
                                 •
                                 
                                    ADJACENT: A loop 
                                       
                                          
                                             l
                                          
                                          
                                             a
                                          
                                       
                                     is classified to be ADJACENT with respect to another loop 
                                       
                                          
                                             l
                                          
                                          
                                             b
                                          
                                       
                                     if they have an overlapping line and there is no line in one loop is inside of the another one. And 
                                       
                                          
                                             l
                                          
                                          
                                             b
                                          
                                       
                                     is also the ADJACENT loop of 
                                       
                                          
                                             l
                                          
                                          
                                             a
                                          
                                       
                                    .


                                    IN/OUT: A loop 
                                       
                                          
                                             l
                                          
                                          
                                             a
                                          
                                       
                                     is classified to be IN with respect to another loop 
                                       
                                          
                                             l
                                          
                                          
                                             b
                                          
                                       
                                     if all its lines are inside of 
                                       
                                          
                                             l
                                          
                                          
                                             b
                                          
                                       
                                    . And 
                                       
                                          
                                             l
                                          
                                          
                                             b
                                          
                                       
                                     is the OUT loop of 
                                       
                                          
                                             l
                                          
                                          
                                             a
                                          
                                       
                                    .


                                    INON/OUTON: A loop 
                                       
                                          
                                             l
                                          
                                          
                                             a
                                          
                                       
                                     is classified to be INON with respect to another loop 
                                       
                                          
                                             l
                                          
                                          
                                             b
                                          
                                       
                                     if they have one or more overlapping lines, and the other lines of 
                                       
                                          
                                             l
                                          
                                          
                                             a
                                          
                                       
                                     are all inside of 
                                       
                                          
                                             l
                                          
                                          
                                             b
                                          
                                       
                                    . And 
                                       
                                          
                                             l
                                          
                                          
                                             b
                                          
                                       
                                     is the OUTON loop of 
                                       
                                          
                                             l
                                          
                                          
                                             a
                                          
                                       
                                    .


                           Fig. 4
                            shows the examples. In Fig. 4(a), loop 1 and loop 2 are ADJACENT with each other. In Fig. 4(b), loop 2 is IN of loop 1, and loop 1 is OUT of loop 2. In Fig. 4(c), loop 2 is INON of loop 1, and loop 1 is OUTON of loop 2.

According to the loop relations, we can construct an undirected graph named undirected loop relation graph
                           (ULRG). Each node of the graph corresponds to a main loop. Firstly, each pair of ADJACENT loops is connected by an edge. Then, edges are added to connect every pair of IN/OUT and INON/OUTON loops. It is important to note that a node is just related to its connected nodes. Fig. 5
                            shows an example of constructing ULRG. Fig. 5(a) is the original 2D drawing. There are three views including two removed sectional views. The non-sectional view is taken as the main view. There are 7 main loops in the main view, which are marked in Fig. 5(b). The constructed ULRG is shown in Fig. 5(c).

After acquiring ULRG, we need to generate the graph structure for CRFs model. Since our goal is to predict the labels for the main loops, based on the CRFs model assumption, the hidden labels also have the same relationships as the main loops. Then we can get the graph structure with ULRG. Fig. 5(d) shows the corresponding graph structure for CRFs model. 
                              X
                              =
                              
                                 {
                                 
                                    
                                       X
                                    
                                    
                                       1
                                       ,
                                       2
                                       ,
                                       4
                                       ,
                                       5
                                       ,
                                       7
                                    
                                 
                                 ,
                                 
                                    
                                       X
                                    
                                    
                                       3
                                       ,
                                       6
                                    
                                 
                                 }
                              
                            is the set of observation variables, which is the set of main loops 
                              
                                 
                                    l
                                 
                                 
                                    1
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    l
                                 
                                 
                                    7
                                 
                              
                           . 
                              Y
                              =
                              
                                 {
                                 
                                    
                                       y
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    
                                       y
                                    
                                    
                                       7
                                    
                                 
                                 }
                              
                            is the set of output variables, which presents the hidden labels to be predicted. The cardinalities of 
                              X
                            and 
                              Y
                            are the same since one loop has only one predict result.

One of the most attractive advantages of CRFs model is that it can integrate rich features. In this section, we will introduce the features used in our elemental part identification approach.

We extract a set of features including attributes of main loops themselves and their relations, as listed in Table 1
                           . For the three types of elemental parts that we deal with, these features contain enough information for classifying them.

Several terms used in Table 1 are explained in the following: 
                              
                                 •
                                 
                                    Boundary line/Non-Boundary line. A 2D line which locates on the outer boundary of a view is defined as a boundary line  [15]. Otherwise, it is a non-boundary line.


                                    Cut line. A cut line shows where an object was cut to obtain the section view  [32].


                                    Hatched line. A hatched area in a sectional view shows the solid surface of an object which was cut through to make the section  [32]. A 2D line in a sectional view is thought to be a hatched line if it is next to a hatched area of the view  [15].


                                    Matching loops. A pair of loops 
                                       
                                          
                                          
                                             
                                                
                                                   V
                                                
                                                
                                                   i
                                                
                                             
                                          
                                       
                                       L
                                       ∈
                                       
                                          
                                             V
                                          
                                          
                                             i
                                          
                                       
                                     and 
                                       
                                          
                                          
                                             
                                                
                                                   V
                                                
                                                
                                                   j
                                                
                                             
                                          
                                       
                                       L
                                       ∈
                                       
                                          
                                             V
                                          
                                          
                                             j
                                          
                                       
                                       
                                       
                                          (
                                          i
                                          ≠
                                          j
                                          )
                                       
                                     are said to be a group of matching loops, if 
                                       
                                          project
                                       
                                       A
                                       
                                          (
                                          B
                                          
                                             (
                                             
                                                
                                                
                                                   
                                                      
                                                         V
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                
                                             
                                             L
                                             )
                                          
                                          )
                                       
                                       =
                                       
                                          project
                                       
                                       A
                                       
                                          (
                                          B
                                          
                                             (
                                             
                                                
                                                
                                                   
                                                      
                                                         V
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                
                                             
                                             L
                                             )
                                          
                                          )
                                       
                                    , where 
                                       A
                                     is the common coordinate axis between views 
                                       
                                          
                                             V
                                          
                                          
                                             i
                                          
                                       
                                     and 
                                       
                                          
                                             V
                                          
                                          
                                             j
                                          
                                       
                                    , 
                                       
                                          project
                                       
                                       A
                                       
                                          (
                                          n
                                          )
                                       
                                     represents the projected interzone of 
                                       n
                                     on 
                                       A
                                    -axis, and 
                                       B
                                       
                                          (
                                          m
                                          )
                                       
                                     returns the bounding box of 
                                       m
                                    .

As summarized in Table 1, we define two types of features: one is the attribute feature on nodes of ULRG; the other is the relation feature on edges of ULRG. In total, there are 6 attribute features and 3 relation features. Taking Fig. 5(c) as an example, the attribute feature set of node 
                              
                                 
                                    l
                                 
                                 
                                    1
                                 
                              
                            is 
                              
                                 AFS
                              
                              
                                 (
                                 
                                    
                                       l
                                    
                                    
                                       1
                                    
                                 
                                 )
                              
                              =
                              
                                 {
                                 
                                    FALSE
                                 
                                 ,
                                 
                                    TRUE
                                 
                                 ,
                                 
                                    FALSE
                                 
                                 ,
                                 
                                    TRAPEZOID
                                 
                                 ,
                                 
                                    FALSE
                                 
                                 ,
                                 0
                                 }
                              
                           , and the attribute feature set of node 
                              
                                 
                                    l
                                 
                                 
                                    6
                                 
                              
                            is 
                              
                                 AFS
                              
                              
                                 (
                                 
                                    
                                       l
                                    
                                    
                                       6
                                    
                                 
                                 )
                              
                              =
                              
                                 {
                                 
                                    TRUE
                                 
                                 ,
                                 
                                    TRUE
                                 
                                 ,
                                 
                                    TRUE
                                 
                                 ,
                                 2
                                 
                                    SEMICR
                                 
                                 ,
                                 
                                    FALSE
                                 
                                 ,
                                 1
                                 }
                              
                           . Assuming edge 
                              
                                 〈
                                 
                                    
                                       l
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 
                                    
                                       l
                                    
                                    
                                       2
                                    
                                 
                                 〉
                              
                            is 
                              
                                 
                                    e
                                 
                                 
                                    12
                                 
                              
                            and edge 
                              
                                 〈
                                 
                                    
                                       l
                                    
                                    
                                       2
                                    
                                 
                                 ,
                                 
                                    
                                       l
                                    
                                    
                                       3
                                    
                                 
                                 〉
                              
                            is 
                              
                                 
                                    e
                                 
                                 
                                    23
                                 
                              
                           . The relation feature set of 
                              
                                 
                                    e
                                 
                                 
                                    12
                                 
                              
                            is 
                              
                                 RFS
                              
                              
                                 (
                                 
                                    
                                       e
                                    
                                    
                                       12
                                    
                                 
                                 )
                              
                              =
                              
                                 {
                                 
                                    TRUE
                                 
                                 ,
                                 
                                    FALSE
                                 
                                 ,
                                 
                                    FALSE
                                 
                                 }
                              
                           , and the relation feature set of 
                              
                                 
                                    e
                                 
                                 
                                    23
                                 
                              
                            is 
                              
                                 RFS
                              
                              
                                 (
                                 
                                    
                                       e
                                    
                                    
                                       23
                                    
                                 
                                 )
                              
                              =
                              
                                 {
                                 
                                    FALSE
                                 
                                 ,
                                 
                                    TRUE
                                 
                                 ,
                                 
                                    FALSE
                                 
                                 }
                              
                           .

Then, we need to define the corresponding feature function used in CRFs model for each feature. As the CRFs model definition  [26], the feature function 
                              
                                 
                                    f
                                 
                                 
                                    k
                                 
                              
                              
                                 (
                                 y
                                 ,
                                 
                                    
                                       y
                                    
                                    
                                       ′
                                    
                                 
                                 ,
                                 x
                                 )
                              
                            in Eq. (1) includes two types as well: one is state feature function 
                              
                                 
                                    s
                                 
                                 
                                    k
                                 
                              
                              
                                 (
                                 
                                    
                                       y
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 x
                                 )
                              
                           , which models the relationship between label 
                              
                                 
                                    y
                                 
                                 
                                    i
                                 
                              
                            and the observation 
                              x
                           ; the other is transition feature function 
                              
                                 
                                    t
                                 
                                 
                                    k
                                 
                              
                              
                                 (
                                 y
                                 ,
                                 
                                    
                                       y
                                    
                                    
                                       ′
                                    
                                 
                                 ,
                                 x
                                 )
                              
                           , which models the relationship between labels 
                              y
                            and 
                              
                                 
                                    y
                                 
                                 
                                    ′
                                 
                              
                           . The labels relation can also depend on the observation 
                              x
                           . For simplicity, our defined transition feature functions are independent of the observations. Therefore, we can define the corresponding state feature functions for attribute features and the corresponding transition feature functions for relation features.

We define the discrete feature functions based on the features listed in Table 1. For example, the corresponding state feature function for attribute feature 
                              
                                 BD
                              
                              
                                 (
                                 n
                                 )
                              
                            is: 
                              
                                 
                                    
                                       
                                          f
                                       
                                       
                                          n
                                       
                                    
                                    
                                       (
                                       y
                                       ,
                                       x
                                       )
                                    
                                    =
                                    
                                       {
                                       
                                          
                                             
                                                1
                                             
                                             
                                                If  
                                                
                                                   BD
                                                
                                                
                                                   (
                                                   n
                                                   )
                                                
                                                  is TRUE ,
                                             
                                          
                                          
                                             
                                                0
                                             
                                             
                                                otherwise
                                             
                                          
                                       
                                    
                                 
                              
                            where 
                              y
                            is the label for node 
                              n
                           , 
                              x
                            corresponds to the observed variable.

The corresponding transition feature function for relation feature 
                              
                                 INOUT
                              
                              
                                 (
                                 e
                                 )
                              
                            is:
                              
                                 
                                    
                                       
                                          f
                                       
                                       
                                          n
                                       
                                    
                                    
                                       (
                                       y
                                       ,
                                       
                                          
                                             y
                                          
                                          
                                             ′
                                          
                                       
                                       )
                                    
                                    =
                                    
                                       {
                                       
                                          
                                             
                                                1
                                             
                                             
                                                If  
                                                
                                                   INOUT
                                                
                                                
                                                   (
                                                   e
                                                   )
                                                
                                                  is TRUE ,
                                             
                                          
                                          
                                             
                                                0
                                             
                                             
                                                otherwise
                                             
                                          
                                       
                                    
                                 
                              
                            where 
                              y
                            is the label for node 
                              n
                           , 
                              
                                 
                                    y
                                 
                                 
                                    ′
                                 
                              
                            is the label for the neighbor of node 
                              n
                           , connected with an edge 
                              e
                           .

In this section, we introduce how to estimate the parameter values and how to predict the best labels. There are two sub tasks: first, since the feature functions are defined manually (see the previous feature set section), we need to know the values of parameters 
                              θ
                              =
                              
                                 {
                                 
                                    
                                       λ
                                    
                                    
                                       k
                                    
                                 
                                 }
                              
                            in order to compute the conditional probability
                              p
                              
                                 (
                                 
                                    y
                                 
                                 |
                                 
                                    x
                                 
                                 )
                              
                            in Eq. (1); second, we need to find the best predictions for the new instance 
                              
                                 x
                              
                           . If the instance contains 
                              n
                            nodes, and there are 
                              m
                            labels, the number of label assignment for 
                              
                                 y
                              
                            is 
                              
                                 
                                    m
                                 
                                 
                                    n
                                 
                              
                           . It is inefficient to find the best assignment from these exponential computations. We need to employ an efficient way to predict the best label assignment.

Therefore, to learn with a CRFs model, it mainly has two steps: the training step (parameter estimation) and the testing step (prediction). In the training step, we want to learn the parameters 
                              θ
                              =
                              
                                 {
                                 
                                    
                                       λ
                                    
                                    
                                       k
                                    
                                 
                                 }
                              
                              ∈
                              
                                 
                                    ℜ
                                 
                                 
                                    K
                                 
                              
                            based on the set of labeled instances. In the testing step, we use the learned parameters to predict the labels for new instances. Since our 
                              
                                 ULRG
                              
                            can be formulated as a tree structure graph. In the following part, we will introduce the parameter estimation step and prediction step for tree-structured CRFs model, as shown in Fig. 6
                           .

Parameter estimation is to estimate the parameters 
                              θ
                              =
                              
                                 {
                                 
                                    
                                       λ
                                    
                                    
                                       k
                                    
                                 
                                 }
                              
                            with the labeled training data set 
                              
                                 
                                    
                                       {
                                       
                                          
                                             
                                                x
                                             
                                          
                                          
                                             i
                                          
                                       
                                       ,
                                       
                                          
                                             
                                                y
                                             
                                          
                                          
                                             i
                                          
                                       
                                       }
                                    
                                 
                                 
                                    i
                                    =
                                    1
                                 
                                 
                                    N
                                 
                              
                           . The maximum likelihood method selects parameter values when the logarithm of the likelihood is maximized. Here, we use conditional log likelihood:
                              
                                 
                                    L
                                    
                                       (
                                       θ
                                       )
                                    
                                    =
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          N
                                       
                                    
                                    log
                                    p
                                    
                                       (
                                       
                                          
                                             
                                                y
                                             
                                          
                                          
                                             
                                                (
                                                i
                                                )
                                             
                                          
                                       
                                       |
                                       
                                          
                                             
                                                x
                                             
                                          
                                          
                                             
                                                (
                                                i
                                                )
                                             
                                          
                                       
                                       )
                                    
                                    .
                                 
                              
                            The goal is to solve the optimization problem: 
                              arg
                              
                                 
                                    max
                                 
                                 
                                    θ
                                    =
                                    
                                       {
                                       
                                          
                                             λ
                                          
                                          
                                             k
                                          
                                       
                                       }
                                    
                                 
                              
                              L
                              
                                 (
                                 θ
                                 )
                              
                           . To avoid overfitting, we add a regularizer to penalize the large values of parameters. The regularized log likelihood is 
                              
                                 
                                    L
                                    
                                       (
                                       θ
                                       )
                                    
                                    =
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          N
                                       
                                    
                                    log
                                    p
                                    
                                       (
                                       
                                          
                                             
                                                y
                                             
                                          
                                          
                                             
                                                (
                                                i
                                                )
                                             
                                          
                                       
                                       |
                                       
                                          
                                             
                                                x
                                             
                                          
                                          
                                             
                                                (
                                                i
                                                )
                                             
                                          
                                       
                                       )
                                    
                                    −
                                    
                                       
                                          ∑
                                       
                                       
                                          k
                                          =
                                          1
                                       
                                       
                                          K
                                       
                                    
                                    
                                       
                                          
                                             
                                                λ
                                             
                                             
                                                k
                                             
                                             
                                                2
                                             
                                          
                                       
                                       
                                          2
                                          
                                             
                                                ω
                                             
                                             
                                                2
                                             
                                          
                                       
                                    
                                    .
                                 
                              
                            The derivative of the regularized log likelihood with respect to a parameter 
                              
                                 
                                    λ
                                 
                                 
                                    k
                                 
                              
                            is: 
                              
                                 
                                    
                                       
                                          L
                                          
                                             (
                                             θ
                                             )
                                          
                                       
                                       
                                          
                                             
                                                λ
                                             
                                             
                                                k
                                             
                                          
                                       
                                    
                                    =
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          N
                                       
                                    
                                    
                                       
                                          ∑
                                       
                                       
                                          t
                                          =
                                          1
                                       
                                       
                                          T
                                       
                                    
                                    
                                       
                                          f
                                       
                                       
                                          k
                                       
                                    
                                    
                                       (
                                       
                                          
                                             y
                                          
                                          
                                             t
                                          
                                          
                                             
                                                (
                                                i
                                                )
                                             
                                          
                                       
                                       ,
                                       
                                          
                                             y
                                          
                                          
                                             
                                                
                                                   t
                                                
                                                
                                                   ′
                                                
                                             
                                          
                                          
                                             
                                                (
                                                i
                                                )
                                             
                                          
                                       
                                       ,
                                       
                                          
                                             x
                                          
                                          
                                             t
                                          
                                          
                                             
                                                (
                                                i
                                                )
                                             
                                          
                                       
                                       )
                                    
                                    −
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          N
                                       
                                    
                                    
                                       
                                          ∑
                                       
                                       
                                          t
                                          =
                                          1
                                       
                                       
                                          T
                                       
                                    
                                    
                                       
                                          ∑
                                       
                                       
                                          y
                                          ,
                                          
                                             
                                                y
                                             
                                             
                                                ′
                                             
                                          
                                       
                                    
                                    
                                       
                                          f
                                       
                                       
                                          k
                                       
                                    
                                    
                                       (
                                       y
                                       ,
                                       
                                          
                                             y
                                          
                                          
                                             ′
                                          
                                       
                                       ,
                                       
                                          
                                             x
                                          
                                          
                                             t
                                          
                                          
                                             
                                                (
                                                i
                                                )
                                             
                                          
                                       
                                       )
                                    
                                    p
                                    
                                       (
                                       y
                                       ,
                                       
                                          
                                             y
                                          
                                          
                                             ′
                                          
                                       
                                       |
                                       
                                          
                                             
                                                x
                                             
                                          
                                          
                                             
                                                (
                                                i
                                                )
                                             
                                          
                                       
                                       )
                                    
                                    −
                                    
                                       
                                          ∑
                                       
                                       
                                          k
                                          =
                                          1
                                       
                                       
                                          K
                                       
                                    
                                    
                                       
                                          
                                             
                                                λ
                                             
                                             
                                                k
                                             
                                             
                                                2
                                             
                                          
                                       
                                       
                                          2
                                          
                                             
                                                ω
                                             
                                             
                                                2
                                             
                                          
                                       
                                    
                                 
                              
                            where 
                              p
                              
                                 (
                                 y
                                 ,
                                 
                                    
                                       y
                                    
                                    
                                       ′
                                    
                                 
                                 |
                                 
                                    
                                       
                                          x
                                       
                                    
                                    
                                       
                                          (
                                          i
                                          )
                                       
                                    
                                 
                                 )
                              
                            is the marginal distribution for variable 
                              y
                            and 
                              
                                 
                                    y
                                 
                                 
                                    ′
                                 
                              
                            given 
                              
                                 
                                    
                                       x
                                    
                                 
                                 
                                    
                                       (
                                       i
                                       )
                                    
                                 
                              
                           .

There are several inference algorithms to compute the marginal distribution for tree-structured CRFs model. Sum–Product algorithm  [39] is an exact inference algorithm. It employs the message passing technique to iteratively process neighboring variables. It is a dynamic programming algorithm, which provides an efficient way to compute the marginal distribution. Here, we employ the Sum–Product algorithm as the inference algorithm.

Since the objective function 
                              L
                              
                                 (
                                 θ
                                 )
                              
                            is concave, it guarantees the local maximum to be the global maximum. This optimization function can be solved by iterative techniques. Here, we employ the L-BFGS  [40], which only use the derivative of the objective function, and is a proven effective method among other techniques   [35].

After acquiring all the parameter values in the training step, we want to predict labels for new instances in the testing step. The prediction process is to find the most likely label assignment 
                              
                                 
                                    
                                       y
                                    
                                 
                                 
                                    ∗
                                 
                              
                            for the new instance 
                              
                                 x
                              
                           : 
                              
                                 
                                    
                                       
                                          
                                             y
                                          
                                       
                                       
                                          ∗
                                       
                                    
                                    =
                                    arg
                                    
                                       
                                          max
                                       
                                       
                                          
                                             y
                                          
                                       
                                    
                                    p
                                    
                                       (
                                       
                                          y
                                       
                                       |
                                       
                                          x
                                       
                                       )
                                    
                                    .
                                 
                              
                            To find the best 
                              
                                 
                                    
                                       y
                                    
                                 
                                 
                                    ∗
                                 
                              
                           , which obtain the highest 
                              p
                              
                                 (
                                 
                                    y
                                 
                                 |
                                 
                                    x
                                 
                                 )
                              
                            score, it is impossible to enumerate all the label assignments. Because the time complexity of this brute-force method is 
                              O
                              
                                 (
                                 
                                    
                                       m
                                    
                                    
                                       n
                                    
                                 
                                 )
                              
                           , where 
                              m
                            is the number of categories or label types, 
                              n
                            is the number of nodes in instance 
                              
                                 x
                              
                           . Max-Product algorithm  [39] is an efficient method to find the best prediction, which is a variant of Sum–Product algorithm. The former algorithm changes the sum computation in the latter algorithm as max computation. Max-Product algorithm is also a dynamic programming method. It reduces the prediction complexity from 
                              O
                              
                                 (
                                 
                                    
                                       m
                                    
                                    
                                       n
                                    
                                 
                                 )
                              
                            to 
                              O
                              
                                 (
                                 
                                    
                                       m
                                    
                                    
                                       2
                                    
                                 
                                 )
                              
                           . Here, we use the Max-Product algorithm to find the best label assignment 
                              
                                 
                                    
                                       y
                                    
                                 
                                 
                                    ∗
                                 
                              
                           .

For example, with the learned parameters, we can correctly predict the labels for the 7 main loops in Fig. 5. The predicted result is shown in Table 2
                           . The main loop 
                              
                                 
                                    l
                                 
                                 
                                    3
                                 
                              
                            is labeled as hole, the main loop 
                              
                                 
                                    l
                                 
                                 
                                    6
                                 
                              
                            is labeled as keyway, and the other main loops are labeled as ODs.

For the elemental parts of hole, keyway and OD, we define three parameters templates for constructing their 3D volumes. The desired parameters of a part can be extracted from its 2D views and then filled in the parameters template. When the parameters are satisfied, its 3D model can be generated. 
                        
                           (1)
                           Keyway.

Keyways part is a kind of extrusions. We need to know both the profile of extrusion and the height to be extruded when constructing an extrusion  [15]. Thus, the parameters template of constructing keyways is defined as: 
                                 
                                    
                                       
                                          
                                             T
                                          
                                          
                                             
                                                keyway
                                             
                                          
                                       
                                       =
                                       
                                          (
                                          
                                             Extrude
                                          
                                          ,
                                          
                                             Loop
                                          
                                          ,
                                          
                                             height
                                          
                                          )
                                       
                                       ,
                                    
                                 
                               where the first parameter indicates that extrusion operation is used. The second parameter represents the profile loop of extrusion. It should be the main loop corresponds to the keyway. The last parameter is the height to be extruded. For a keyway, its height could be computed in the related cross sectional view. For example, in Fig. 5(b), main loop 6 is identified as a keyway. When constructing this keyway, loop 6 is taken as the second parameter. The length of its matching loop 
                                 
                                    (
                                    e
                                    ,
                                    f
                                    ,
                                    g
                                    ,
                                    h
                                    ,
                                    e
                                    )
                                 
                               in view 2 is 
                                 
                                    |
                                    p
                                    q
                                    |
                                 
                              . Thus, 
                                 
                                    |
                                    p
                                    q
                                    |
                                 
                               is considered as the third parameter.

Outer diameter (OD).

ODs in a shaft are series of coaxial revolutions. Constructing a revolution needs information about the profile, the axis of rotation, and the rotation angle  [15]. Thus, the parameters template of constructing ODs is defined as: 
                                 
                                    
                                       
                                          
                                             T
                                          
                                          
                                             
                                                od
                                             
                                          
                                       
                                       =
                                       
                                          (
                                          
                                             Rotate
                                          
                                          ,
                                          
                                             Loop
                                          
                                          ,
                                          
                                             axis
                                          
                                          ,
                                          π
                                          )
                                       
                                       ,
                                    
                                 
                               where the first parameter indicates that rotation operation is used. The second parameter represents the profile loop of rotation. It should be the main loop which corresponds to the OD. The third parameter is the axis of rotation. Usually, the center line of the profile loop is taken as the axis. The last parameter indicates the rotation angle is 
                                 π
                              .

Hole.

Note that holes are limited to cylinder holes and cone holes here. Threaded holes and some other holes are not considered.

The process is more complex for constructing holes since a hole might be either an extrusion or a revolution. If the main loop of a hole is a circle, then it is considered as an extrusion which will be constructed by extruding this circle loop. Otherwise, the main loop represents the lateral projection profile of the hole, and then the part is considered as a revolution. The parameters template of constructing hole parts is defined as: 
                        
                           
                              
                                 
                                    T
                                 
                                 
                                    
                                       hole
                                    
                                 
                              
                              =
                              
                                 (
                                 
                                    Operation
                                 
                                 ,
                                 
                                    Loop
                                 
                                 ,
                                 
                                    height
                                 
                                 )
                              
                              ,
                           
                        
                      where the first parameter can be Extrude or Rotate. The second parameter should be the main loop corresponds to the hole. If the loop is a circle, then the third parameter needs to be obtained from its related cross section. We consider that a hole is a through hole if there is no related sectional view. If the main loop is a non-circle, then the third parameter is NULL, and the hole is constructed by rotating this loop around its center line. For example, in Fig. 5(b), loop 3 in the main view is a circle. It indicates an extrusion hole, and the height can be obtained from its matching loop 
                        
                           (
                           a
                           ,
                           b
                           ,
                           c
                           ,
                           d
                           ,
                           a
                           )
                        
                      in view 1. In Fig. 7
                     , there are two holes. Main loop 1 is a non-circle loop and indicates a rotated hole, and main loop 2 represents a through hole since there is only one view. It is noticed that there are two polylines in loop 1, which are formed by the interaction of two quadric surfaces. In such a case, the loop is recovered into a rectangle loop to construct a complete object, as described in  [15].

After generating the 3D elemental parts, the final shaft is obtained by combining all these elemental parts using Boolean operations (union and difference). 
                        Property 2
                        
                           ODs are solid volumes which actually exist in the final objects. Holes and keyways are virtual volumes which should be subtracted from the final objects.
                        


                     Property 2 is obtained by analyzing the attributes of these elemental parts. According to Property 2, all the ODs are first added into final objects one by one according to their adjacency relations. Then, difference operation is used to remove holes and keyways from current objects in turn.

We also take the 2D drawing which is shown in Fig. 5(a) as the example. There are 7 main loops in the main view, and the constructed ULRG and tree structure for CRFs model are shown in Fig. 5(c) and (d) respectively. The result of elemental parts identification is shown in Table 2. There are one hole, one keyway and five ODs. After using the parameters template method, the constructed 3D volumes are shown in Fig. 8
                     (a). Fig. 8(b) shows the final 3D model of the shaft.

Our algorithm has been implemented as an extension and integrated into a commercial CAD system TiGEMSR 7.0 that is owned by Tsinghua Software Information Technology Co. Ltd. The developed program accepts 2D drawing files of shafts in CAD neutral format that consist of one view or several removed sections. We will first introduce the results of elemental parts identification task, and then demonstrate the results of the overall 3D reconstruction algorithm with several examples.

We evaluate the proposed approach on our collected data set. It contains 50 engineering drawings of shafts. The drawings are automatically transferred into the tree structures, which are then manually annotated with the corresponding labels: hole, keyway, and OD. 30 of them are randomly selected as the training data set, and the left 20 drawings are selected as the testing data set. The employed feature functions include two types: state feature functions and transition feature functions, which are defined in Section  4.2.2. With the 30 labeled training data set, we first estimate the optimal parameters 
                           θ
                           =
                           
                              {
                              
                                 
                                    λ
                                 
                                 
                                    k
                                 
                              
                              }
                           
                        , which denote the relative weights for the feature functions. After acquiring the parameter values, given a new tree structure, we can predict the best labels for all the tree nodes. The parameter estimation step and prediction step are introduced in Section  4.2.3. We test our CRFs-based approach on the testing data set with 20 drawings: we hide the labels for the 20 drawings in test set, and use our CRFs-based approach to predict the labels for these drawings. By comparing the predicted results and the manually labeled results, we find that our approach can correctly predict all the labels for the 20 test drawings.

We provide several examples to demonstrate the cases, which are handled by our algorithm.


                        Fig. 9
                         shows the example of reconstructing a shaft from 2D single view. The input drawing is shown in Fig. 1(a). This single view is taken as the main view, and there are 6 main loops. The result of elemental parts identification is shown in Fig. 9(a). Six ODs are identified from main loops. Fig. 9(b) shows the final reconstructed 3D shaft.

The reconstructed result of the 2D drawing in Fig. 1(b) is shown in Fig. 10
                        . The input drawing is a coincide section. The result of identifying elemental parts is shown in Fig. 10(a). In this shaft, there are two holes. The right one is constructed as an extrusion and the left one is considered as a revolution. The other main loops are labeled as ODs. The 3D solid model of this shaft is shown in Fig. 10(b).


                        Fig. 11
                         shows another example. Its input drawing is shown in Fig. 1(c). There are two removed sections and one non-sectional view in the drawing. According to our algorithm, the non-sectional view is taken as the main view and its loops are taken as main loops. After the stage of identifying elemental parts, eight ODs and two keyways are identified by these main loops, as shown in Fig. 11(a). The final 3D shaft is obtained by combining all the ODs and removing the two keyways, as shown in Fig. 11(b).

As can be seen from the examples, the proposed method is competent for engineering drawings of shafts that contain removed sections, coincide sections and single view. In all these cases, the elemental parts have been successfully identified from 2D drawings and accurately transformed into 3D volumes.

@&#CONCLUSION@&#

In this paper, we propose a novel approach based on conditional random fields (CRFs) model to identify and construct elemental parts with semantic information of shafts from 2D engineering drawings.

One of our main advantages is that the elemental parts are identified by automatically incorporating various features from 2D views. It is unnecessary to define heuristic rules and manually determine how to use these rules by experiences. If the number of rules becomes too large, it is difficult to organize them manually.

Classification methods can automatically learn the weights of features, and easily integrate various features. We apply the CRFs model as our classification algorithm. With the classification technique, we define our overall framework: use a CRFs model to label all the main loops of a shaft and identify corresponding elemental parts first, and then construct the 3D elemental parts via the parameters template method. We also implemented this framework, and achieved very promising results.

In summary, the main contributions of this work can be concluded as follows: 
                        
                           (1)
                           This is an attempt to understand the real semantics of entities from only 2D drawings by computers. Both geometrical information and semantic information can be obtained in 3D solids reconstruction. The computers can become intelligent by simulating the engineers’ thought.

As far as we know, this is the first trial to formulate the parts identification task into a classification problem. The classification method can automatically integrate a large number of features, rather than manually organizing the heuristic rules.

We employ an advanced classification model, CRFs, to identify the elemental parts. CRFs model can utilize the structured relation among labels to get the optimal prediction for all main loops simultaneously. The experiments show that the CRFs-based approach can achieve good performance to the 3D reconstruction systems.

The current implementation, as the first solution to the problem of identifying elemental parts of shafts from 2D drawings, does not fully cover some other kinds of elemental parts, such as threaded hole, groove, undercut, taper, notch and so on. Future work will extend the approach to identify additional types of elemental parts.

@&#ACKNOWLEDGMENTS@&#

This work was supported by the 973 Program of China (Grant No. 2010CB328001), the National Natural Science Foundation of China (Grant Nos. 61373070 and 61035002), the 863 Program of China (Grant No. 2012AA040902) and Tsinghua University Initiative Scientific Research Program (Grant No. 2012Z02170).

@&#REFERENCES@&#

