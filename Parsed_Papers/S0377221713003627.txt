@&#MAIN-TITLE@&#Construction heuristics for two-dimensional irregular shape bin packing with guillotine constraints

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We model a new problem to the cutting and packing literature with real application.


                        
                        
                           
                           We design an new adaptive search methodology for this problem.


                        
                        
                           
                           We design a second approach using state of the art heuristics and geometry approaches.


                        
                        
                           
                           We introduce new benchmark instance.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Heuristic

Cutting and packing

Forest search

Bin packing

Irregular

Phi-functions

@&#ABSTRACT@&#


               
               
                  The paper examines a new problem in the irregular packing literature that has many applications in industry: two-dimensional irregular (convex) bin packing with guillotine constraints. Due to the cutting process of certain materials, cuts are restricted to extend from one edge of the stock-sheet to another, called guillotine cutting. This constraint is common place in glass cutting and is an important constraint in two-dimensional cutting and packing problems. In the literature, various exact and approximate algorithms exist for finding the two dimensional cutting patterns that satisfy the guillotine cutting constraint. However, to the best of our knowledge, all of the algorithms are designed for solving rectangular cutting where cuts are orthogonal with the edges of the stock-sheet. In order to satisfy the guillotine cutting constraint using these approaches, when the pieces are non-rectangular, practitioners implement a two stage approach. First, pieces are enclosed within rectangle shapes and then the rectangles are packed. Clearly, imposing this condition is likely to lead to additional waste. This paper aims to generate guillotine-cutting layouts of irregular shapes using a number of strategies. The investigation compares three two-stage approaches: one approximates pieces by rectangles, the other two approximate pairs of pieces by rectangles using a cluster heuristic or phi-functions for optimal clustering. All three approaches use a competitive algorithm for rectangle bin packing with guillotine constraints. Further, we design and implement a one-stage approach using an adaptive forest search algorithm. Experimental results show the one-stage strategy produces good solutions in less time over the two-stage approach.
               
            

@&#INTRODUCTION@&#

There exist in the literature a high volume and variety of investigations into two-dimensional (2D) cutting and packing problems, which reflects the large application scope, such as ship building, shoe manufacturing, garment manufacturing and tool manufacturing, and a range of materials, for example glass, metal, wood, and textiles. Within these publications, a popular focus of research is generating cutting patterns that satisfying guillotine cutting constraints. These constrain any cut to begin at one edge of the stock sheet and continue in a straight line to another edge of the stock sheet. To the best of our knowledge, all of the algorithms are designed for solving 2D rectangular shape cutting problems where all cuts are orthogonal to the edges of the stock-sheet. Guillotine cutting with irregular pieces has not been tackled directly. In this problem, guillotine cuts are not constrained to be orthogonal to the rectangular stock sheet edges, and pieces can be continuously rotated.

An example of the irregular shape bin packing problem with guillotine constraints arises from the glass cutting industry and in particular the manufacture of conservatories (glass houses). Although many of the pieces are rectangular, there is a substantial number of irregular pieces. These are convex polygons with up to five sides in general, and occasionally more. It is common for conservatories to be a bespoke design (usually based on a standard style) to fit the specific building, hence, glass is cut to order. To satisfy the guillotine cutting constraints in practice, items of irregular shapes are individually, or in pairs, enclosed within rectangles and these rectangles are then arranged into a cutting pattern. This adds a restriction that is not present in practice, which is likely to create patterns with more waste than necessary.

In this paper, we implement four pattern generation strategies with the objective of minimizing the number of bins required to pack all items. Primarily, we aim to investigate the benefit of generating cutting patterns which satisfy the guillotine cutting constraint by implementing the cuts directly on the irregular shapes instead of on rectangle enclosures. This one-stage approach is based on an efficient forest search algorithm. The forest constructs multiple layouts in parallel according to a dynamic measure of the quality of the partial layout. In order to benchmark our approach we implement a state of the art rectangle guillotine cutting algorithm of Charalambous and Fleszar [6] and generate solutions by approximating each piece by its minimum area enclosing rectangle. Further, we attempt to improve on the two stage approach used in practice by using phi-functions to cluster all pairs of pieces in their minimum rectangle enclosure and use a greedy heuristic to select a subset to pack, again using the approach of Charalambous and Fleszar [6].

The contributions of this paper are many. We have brought a new problem to the literature that is found in practice. As a result, there is significant scope for further research. We have designed an efficient search heuristic using a dynamic solution evaluation function. The approach can handle continuous rotation of the pieces, multiple bins, and guillotine cuts. Irregular shape packing usually constrains the number of orientations of the pieces, approaches generally only pack a single strip and to our knowledge formulations have never included guillotine constraints. Further, the paper describes a second approach, based on industry practice, but using state of the art techniques to solve the problem by first optimizing the rectangle enclosure of pairs of pieces using phi-functions and then packing using a rectangle guillotine packing approach. This in itself is new to the literature. Finally, we have also introduced new benchmark data sets for this problem.

In the next section (Section 2), we give a more detailed description of the problem. In Section 3 we review some related literature on guillotine bin packing. Section 3 explains the one-stage approach, including some notation and definitions to describe the important characteristics of the problem, and details of a core function, best match, that forms the basis of the algorithm. It also includes a description of the forest search algorithm. In Section 5, we describe the two-stage approach based on the work of Charalambous and Fleszar [6], minimum rectangle clustering based on phi-functions and our greedy selection. Section 6 contains the computational study and the discussion of the results. Finally, in Section 7 we present the conclusions.

The problem objective is to cut all demand pieces from the minimum number of stock sheets possible, hence it is an input minimization problem. There are sufficient standard size rectangular stock-sheets available to meet demand, where the stock sheet has length L and width W. The demand set D contains N irregular shaped pieces, where each piece is considered to be unique and the demand of each piece is one. According to the typology proposed by Wäscher et al. [16] this is a single bin size bin packing problem (SBSBPP).

Further refinements to the problem type are that all pieces are convex, and usually irregular. Pieces can be rotated continuously i.e. there are no fixed rotation angles. Further, the stock sheet can be rotated. In principle this is taken care of by rotating the pieces. However, in Charalambous and Fleszar [6] the orientation of a non-square stock sheet is important. Only guillotine cuts are allowed. A guillotine cut is a single straight line cut that begins at an edge of the stock-sheet and ends at another edge. Unlike the vast majority of the literature, the cutting line is not constrained to be parallel to an edge of the stock-sheet. Often when considering guillotine constraints, pieces must be cut free from the stock sheet with a maximum number of cuts, which is typically three. In this problem there are no limits on the number cuts.

@&#LITERATURE REVIEW@&#

There are three key components of the problem under consideration: bin packing, guillotine cuts, and irregular shapes. To our knowledge there are no papers that tackle these three together. In addition, irregular shape packing literature is almost exclusively strip packing (single infinite length stock sheet) with a finite fixed set of rotation angles. Those who have tackled multiple stock sheet problems reduce the problem to a one-dimensional cutting stock problem using pre-defined pattern layouts, for example, Degraeve and Vandebroek [8]. A key challenge in packing irregular shapes is handling complex geometry, particularly when pieces contain concavities. In this paper all pieces are convex. Instead, the key challenge arises in modelling efficiently continuous rotation of the pieces, which is not commonly dealt with in the literature. For a discussion of techniques for handling the geometry in irregular shape packing see Bennell and Oliveira [4]. Aside from the geometry, solution approaches to irregular packing are almost all heuristic and can be divided into those that build up to a final solution through sequentially adding to partial solutions, and those that work with complete solutions and search by making small changes to the incumbent solution. The latter approach can be subdivided into representing the solution by a sequence, or packing order, that is decoded by a construction heuristic, or by the co-ordinate positions of the pieces in the layout. For a review of solution approaches to the irregular packing problem see Bennell and Oliveira [3].

The rectangle bin packing problem with guillotine constraints has the most similarities to the problem we are tacking in this paper. Lodi et al. [12] survey two dimensional rectangle bin packing, including algorithms that handle guillotine constraints. They describe the one- and two-phase approach, where both consist of packing pieces onto shelves along the width of the bin. The former directly packs pieces into the bin, where as the latter optimizes the packing of the shelves into the bins by modelling as a one dimensional bin packing problem. Lodi et al. [10] creates the shelves by solving a series of 0–1 knapsack problems improving on the performance of the finite first fit and finite best strip heuristics of Berkey and Wang [5]. More recent construction heuristics are not constrained to creating shelves. Charalambous and Fleszar [6] start by generating simple patterns, initially across the width of the bin, and subsequently within free rectangle areas. Pieces may shift horizontally or vertically in order to maximize the size of the free rectangle, while maintaining the guillotine constraint. Fleszar [9] propose a constructive heuristic where the insertion decision is made by first-fit, best-fit or critical-fit criteria. Patterns are generated using a tree structure where nodes determine the cuts and the leaf nodes are pieces. Further improvement is made by a justification heuristic. Polyakovsky and M’Hallah [13] modify the well know bottom left construction heuristic to meet guillotine constraints. After placing each piece, they apply both horizontal and vertical guillotine cuts and select the one that gives the largest rectangle area available for packing. Pieces are assigned to bins using an agent-based algorithm. Pieces may be agent-initiators attracting individual-agents (pieces) to their group in order to maximize the fitness of the group. Individual-agents compete to join groups to maximize their purpose parameters. These groups are assigned to the same bin and arranged using the guillotine bottom left heuristic. Lodi et al. [11] uses tabu search to assign pieces to bins. Initially, one piece is packed in each bin. The heuristic attempts to empty weak bins by assigning pieces to sub-instances that include the pieces from k bins. Instead of assigning pieces to bins and then packing, Alvelos et al. [1] define a sequence for packing the pieces while keeping a list of candidate locations for the next piece. The solution is improved using variable neighborhood descent where moves are made within the packing sequence. Although none of these papers directly apply to the problem addressed in this paper, we have made use of some core knowledge. We adopt methodologies for efficiently processing the geometry of irregular convex shapes with free rotation using some classic concepts and phi-functions. We follow the common theme of construction methodologies for generating patterns while meeting guillotine constraints, and for the two-stage strategies we directly use the approach of Charalambous and Fleszar [6].

Our one-stage solution approach is a constructive heuristic where the algorithm begins with generating efficient clusters of polygons, and then uses these clusters to construct the bin packing solution. In the following sections we first define the process and criteria for clustering two polygons, this is called a match. A match is accepted as a node in the search forest if the utilization ratio meets or exceeds a certain acceptance threshold θ. The forest is populated by matching polygons with polygons, polygons with clusters, and clusters with clusters. The latter leading to the term forest search. These clusters are called blocks. The forest is complete once there are no further matches for the blocks, this may be as a result of the boundary constraint of the stock sheet or there are no matches that meet the threshold. The bin packing step sequentially selects the block with the greatest summed area of polygons, while removing any other blocks from the forest that contain common polygons. If no further blocks can be placed in a bin and the utilization ratio is below a given threshold θ
                     
                        u
                     , the forest is recreated with a lower acceptance threshold. Eventually the threshold is set to zero so all polygons are packed.

In this section we describe a core function of the overall methodology, the best match of two convex polygons. For the purposes of this section, we describe the approach in the context of the original convex polygons. Later we will generalize the procedure and associated definitions for clusters of polygons.

A convex polygon, P, can be expressed by a set of vertices (p
                           1,
                           p
                           2,…,
                           p
                           
                              n
                           ), where n is the number of vertices of the convex polygon, and each vertex p
                           
                              i
                            is defined by cartesian co-ordinates (x
                           
                              i
                           ,
                           y
                           
                              i
                           ) where i
                           =,1,…,
                           n. p
                           1 is set as the origin of P. The ith edge can be expressed by e
                           
                              i
                           
                           =(p
                           
                              i
                           ,
                           p
                           
                              i+1) where i
                           =1,…,
                           n
                           −1, and the nth edge is e
                           
                              n
                           
                           =(p
                           
                              n
                           ,
                           p
                           1). P is convex if all vertices lie on, or to one side of, the infinite line concurrent with e
                           
                              i
                           , for each e
                           
                              i
                           . Let INT(P) be the interior of P and FR(P) be the edges, or frontier, of P. Let set D
                           ={P
                           
                              i
                           
                           ∣
                           i
                           =1,…,
                           N} be customer demand, where N is the total number of pieces ordered. P
                           
                              i
                            is called a basic polygon and has a demand of one.

Clearly because of the guillotine constraint, only convex shapes can be cut. When combining two basic items, the resulting union may not be convex. Hence, two useful convex approximations of the union are the convex hull and enclosing rectangle. Given a point set S, let O(S) be the convex hull of S and R(S) be the minimum area enclosing rectangle of S. For convex polygon P, O(P)=
                           P.

A polygon can be transformed by three operations: reflection (mirror), translation and rotation. Let f be a transformation of polygon P, which can be expressed by a four element group {m,
                           x,
                           y,
                           t}. m
                           ∈{0,1} is a reflection transformation, where the values 1 and 0 represent reflection and no reflection respectively. Note that you only need to reflect in one axis and all other reflections arise from rotating the reflected polygon. x,
                           y represent the translation distance along the x-axis and y-axis. t
                           ∈(−π,
                           π] is the rotation angle of the convex polygon around the origin p
                           1. Obviously, the transformation space, Ψ, is the composition of reflection, translation and rotation. We also call f
                           
                              i
                           (P
                           
                              i
                           ) the transform of P
                           
                              i
                           .

Since it is possible to change the position, orientation and reflection of a polygon, it is important to define the combinations of transformations of multiple polygons that are feasible with respect to mutual overlap. Hence, the set of non-overlapping transformations is defined in Eq. (1). A non-overlapping configuration of two polygons is called a match.
                              
                                 (1)
                                 
                                    f
                                    (
                                    
                                       
                                          P
                                       
                                       
                                          i
                                       
                                    
                                    ,
                                    
                                       
                                          P
                                       
                                       
                                          j
                                       
                                    
                                    )
                                    =
                                    
                                       
                                          f
                                       
                                       
                                          i
                                       
                                    
                                    (
                                    
                                       
                                          P
                                       
                                       
                                          i
                                       
                                    
                                    )
                                    
                                    
                                       ⋃
                                    
                                    
                                    
                                       
                                          f
                                       
                                       
                                          j
                                       
                                    
                                    (
                                    
                                       
                                          P
                                       
                                       
                                          j
                                       
                                    
                                    )
                                    
                                    and
                                    
                                    INT
                                    (
                                    
                                       
                                          f
                                       
                                       
                                          i
                                       
                                    
                                    (
                                    
                                       
                                          P
                                       
                                       
                                          i
                                       
                                    
                                    )
                                    )
                                    
                                    
                                       ⋂
                                    
                                    
                                    INT
                                    (
                                    
                                       
                                          f
                                       
                                       
                                          j
                                       
                                    
                                    (
                                    
                                       
                                          P
                                       
                                       
                                          j
                                       
                                    
                                    )
                                    )
                                    =
                                    ∅
                                 
                              
                           
                        

In order to construct the cutting pattern, we must decide where to place each polygon relative to the other polygons. This amounts to choosing a match between two polygons. Given we wish to minimize waste, we only consider positions where the two polygons touch. A match that gives the minimum convex hull would arguably be a good choice. Given the stock sheets are rectangular, then the minimum area enclosing rectangle would also be a sensible measure and favor configurations that fit the boundary of the placement area. Hence, we want to evaluate both these contributions to waste. Given polygons P
                           1,
                           P
                           2
                           ∈
                           D, the convex hull and rectangle enclosure of the match f(P
                           1,
                           P
                           2) are denoted as O(f(P
                           1,
                           P
                           2)) and R(f(P
                           1,
                           P
                           2)) respectively, see Fig. 1
                           . For consistency with other measures of solution quality, we define the utilization of the convex hull and rectangle enclosure of f(P
                           1,
                           P
                           2) using Eqs. (2) and (3), where Area(.) is the area of the polygon.
                              
                                 (2)
                                 
                                    
                                       
                                          U
                                       
                                       
                                          cov
                                       
                                       
                                          f
                                          (
                                          
                                             
                                                P
                                             
                                             
                                                1
                                             
                                          
                                          ,
                                          
                                             
                                                P
                                             
                                             
                                                2
                                             
                                          
                                          )
                                       
                                    
                                    =
                                    
                                       
                                          Area
                                          (
                                          
                                             
                                                P
                                             
                                             
                                                1
                                             
                                          
                                          )
                                          +
                                          Area
                                          (
                                          
                                             
                                                P
                                             
                                             
                                                2
                                             
                                          
                                          )
                                       
                                       
                                          Area
                                          (
                                          O
                                          (
                                          f
                                          (
                                          
                                             
                                                P
                                             
                                             
                                                1
                                             
                                          
                                          ,
                                          
                                             
                                                P
                                             
                                             
                                                2
                                             
                                          
                                          )
                                          )
                                          )
                                       
                                    
                                 
                              
                           
                           
                              
                                 (3)
                                 
                                    
                                       
                                          U
                                       
                                       
                                          rec
                                       
                                       
                                          f
                                          (
                                          
                                             
                                                P
                                             
                                             
                                                1
                                             
                                          
                                          ,
                                          
                                             
                                                P
                                             
                                             
                                                2
                                             
                                          
                                          )
                                       
                                    
                                    =
                                    
                                       
                                          Area
                                          (
                                          O
                                          (
                                          f
                                          (
                                          
                                             
                                                P
                                             
                                             
                                                1
                                             
                                          
                                          ,
                                          
                                             
                                                P
                                             
                                             
                                                2
                                             
                                          
                                          )
                                          )
                                          )
                                       
                                       
                                          Area
                                          (
                                          R
                                          (
                                          f
                                          (
                                          
                                             
                                                P
                                             
                                             
                                                1
                                             
                                          
                                          ,
                                          
                                             
                                                P
                                             
                                             
                                                2
                                             
                                          
                                          )
                                          )
                                          )
                                       
                                    
                                 
                              
                           
                        

Eq. (2) measures the ratio of piece area and convex hull area, if high then the match is tight. Eq. (3) measures the ratio of convex hull area and rectangle enclosure area, if high then the match generates a rectangle shape, which fits our global objective. Since both attributes are desirable, we define a weighted sum of these measures of utilization. Given the weight w
                           ∈[0,1], the weighted utilization ratio of the match f(P
                           1,
                           P
                           2) is given in Eq. (4).
                              
                                 (4)
                                 
                                    
                                       
                                          U
                                       
                                       
                                          w
                                       
                                       
                                          f
                                          (
                                          
                                             
                                                P
                                             
                                             
                                                1
                                             
                                          
                                          ,
                                          
                                             
                                                P
                                             
                                             
                                                2
                                             
                                          
                                          )
                                       
                                    
                                    =
                                    
                                       
                                          wU
                                       
                                       
                                          rec
                                       
                                       
                                          f
                                          (
                                          
                                             
                                                P
                                             
                                             
                                                1
                                             
                                          
                                          ,
                                          
                                             
                                                P
                                             
                                             
                                                2
                                             
                                          
                                          )
                                       
                                    
                                    +
                                    (
                                    1
                                    -
                                    w
                                    )
                                    
                                       
                                          U
                                       
                                       
                                          cov
                                       
                                       
                                          f
                                          (
                                          
                                             
                                                P
                                             
                                             
                                                1
                                             
                                          
                                          ,
                                          
                                             
                                                P
                                             
                                             
                                                2
                                             
                                          
                                          )
                                       
                                    
                                 
                              
                           
                        

It is unlikely that there is one ideal value of w across all data instance. Note that during the earlier stage of the search, tight combinations of polygons is desirable with little concern for creating rectangular shaped clusters. A heavier weight on the convex hull ratio would achieve this. While in the later stage of the search, achieving a rectangular cluster in order to not incur large amounts of waste between the convex hull of the cluster and the edges of the stock sheet is more important. A heavier weight on the rectangular enclosure would encourage this sort of configuration. In our experiments we evaluate a number of different fixed and dynamic weighting strategies.

The heuristic procedure for finding the best match of two polygons uses three main operations: Mirror, Attach and Slide, these are defined as follows:


                           Mirror(P
                           
                              l
                           ,
                           m
                           
                              l
                           ), l
                           =1,2 and m
                           
                              l
                           
                           =0,1. If m
                           
                              l
                           
                           =1 reflect P
                           
                              l
                           
                        


                           Attach(P
                           1,
                           P
                           2,
                           i,
                           j). Let P
                           1 be the fixed polygon with counter clockwise direction and P
                           2 be the sliding polygon with clockwise direction. The attach operation between P
                           1 and P
                           2 is as follows: move polygon P
                           2 so that the jth convex vertex on P
                           2 coincides with the ith convex vertex on P
                           1. Rotate P
                           2 so that the jth edge of polygon P
                           2 coincides with the ith edge of polygon P
                           1. Recall that the kth edge of a polygon is between vertices (k,
                           k
                           +1). Since P
                           1 and P
                           2 have opposite orientation and are both convex, the attach procedure will not result in the polygons overlapping.


                           Slide(P
                           1,
                           P
                           2,
                           i,
                           j,
                           d). After the attach operation, slide the jth point on P
                           2 along the ith edge of polygon P
                           1. Let d be the slide distance, then d
                           ⩽
                           max{0,
                           dis(e
                           
                              i
                           )−
                           dis(e
                           
                              j
                           )}, where dis(e
                           
                              j
                           ) is the length of edge e
                           
                              j
                           . Each call of slide(P
                           1,
                           P
                           2,
                           i,
                           j,
                           d) will slide polygon P
                           2 an additional distance ∊. As long as we consider all combinations of Mirror(P
                           
                              l
                           ,
                           m
                           
                              l
                           ), then all incremental slide points are captured. An illustration of an attached pair and the slide operation is given in Fig. 2
                           , where three candidate positions are shown including the first and last positions.

Since only the relative positions of the two polygons are of interest, we can find all matches by rotating and translating just one of the polygons. Before sliding along a certain edge attachment, we test the potential of that match on the given edge combination, called the match degree, md(i,
                           j). Only if the match degree is greater than a threshold parameter, θ
                           
                              d
                           , will the algorithm proceed to the attach and slide operation. The match degree of the attachment operation Attach(P
                           1,
                           P
                           2,
                           i,
                           j) is defined in Eq. (5).
                              
                                 (5)
                                 
                                    md
                                    (
                                    i
                                    ,
                                    j
                                    )
                                    =
                                    1
                                    -
                                    
                                       
                                          |
                                          dis
                                          (
                                          
                                             
                                                e
                                             
                                             
                                                i
                                             
                                          
                                          )
                                          -
                                          dis
                                          (
                                          
                                             
                                                e
                                             
                                             
                                                j
                                             
                                          
                                          )
                                          |
                                       
                                       
                                          max
                                          {
                                          dis
                                          (
                                          
                                             
                                                e
                                             
                                             
                                                i
                                             
                                          
                                          )
                                          ,
                                          dis
                                          (
                                          
                                             
                                                e
                                             
                                             
                                                j
                                             
                                          
                                          )
                                          }
                                       
                                    
                                 
                              
                           
                        

The match degree is high for edges that have similar lengths and low for edges that have very different lengths. Note that if the match degree does not exceed θ
                           
                              d
                            then the edge combination is rejected. If all edge combinations are rejected then the two polygons are not matched. The best match procedure is given in Algorithm 1.
                              Algorithm 1
                              Best match 
                                    
                                       
                                          
                                          
                                             
                                                1: Input: Polygon P
                                                   1,
                                                   P
                                                   2,
                                                   θ
                                                   
                                                      d
                                                   ,
                                                   w,
                                                   ∊
                                                
                                             
                                             
                                                2: Initialize MaxU
                                                   =0, match
                                                   =0
                                             
                                             
                                                3: for each pair of vertices i on P
                                                   1 and j on P
                                                   2 
                                                   do
                                                
                                             
                                             
                                                4: 
                                                   if 
                                                   md(i,
                                                   j)>
                                                   θ
                                                   
                                                      d
                                                    
                                                   then
                                                
                                             
                                             
                                                5: 
                                                   match
                                                   =1
                                             
                                             
                                                6: Create copies of polygons 
                                                      
                                                         
                                                            
                                                               P
                                                            
                                                            
                                                               1
                                                            
                                                            
                                                               ′
                                                            
                                                         
                                                         ←
                                                         
                                                            
                                                               P
                                                            
                                                            
                                                               1
                                                            
                                                         
                                                         ,
                                                         
                                                            
                                                               P
                                                            
                                                            
                                                               2
                                                            
                                                            
                                                               ′
                                                            
                                                         
                                                         ←
                                                         
                                                            
                                                               P
                                                            
                                                            
                                                               2
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                                7: 
                                                   for 
                                                   m
                                                   1
                                                   =0,1 do
                                                
                                             
                                             
                                                8: 
                                                   
                                                   
                                                      
                                                         Mirror
                                                         
                                                            
                                                               
                                                                  
                                                                     
                                                                        P
                                                                     
                                                                     
                                                                        1
                                                                     
                                                                     
                                                                        ′
                                                                     
                                                                  
                                                                  ,
                                                                  
                                                                     
                                                                        m
                                                                     
                                                                     
                                                                        1
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   .
                                             
                                             
                                                9: 
                                                   
                                                   for 
                                                   m
                                                   2
                                                   =0,1 do
                                                
                                             
                                             
                                                10: 
                                                   
                                                   
                                                      
                                                         Mirror
                                                         
                                                            
                                                               
                                                                  
                                                                     
                                                                        P
                                                                     
                                                                     
                                                                        2
                                                                     
                                                                     
                                                                        ′
                                                                     
                                                                  
                                                                  ,
                                                                  
                                                                     
                                                                        m
                                                                     
                                                                     
                                                                        2
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   .
                                             
                                             
                                                11: 
                                                   
                                                   for 
                                                   d
                                                   =0,max{0,
                                                   dis(e
                                                   
                                                      i
                                                   )−
                                                   dis(e
                                                   
                                                      j
                                                   )}, step ∊ 
                                                   do
                                                
                                             
                                             
                                                12: 
                                                   
                                                   
                                                   
                                                      
                                                         Attach
                                                         
                                                            
                                                               
                                                                  
                                                                     
                                                                        P
                                                                     
                                                                     
                                                                        1
                                                                     
                                                                     
                                                                        ′
                                                                     
                                                                  
                                                                  ,
                                                                  
                                                                     
                                                                        P
                                                                     
                                                                     
                                                                        2
                                                                     
                                                                     
                                                                        ′
                                                                     
                                                                  
                                                                  ,
                                                                  i
                                                                  ,
                                                                  j
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                                13: 
                                                   
                                                   
                                                   
                                                      
                                                         Slide
                                                         
                                                            
                                                               
                                                                  
                                                                     
                                                                        P
                                                                     
                                                                     
                                                                        1
                                                                     
                                                                     
                                                                        ′
                                                                     
                                                                  
                                                                  ,
                                                                  
                                                                     
                                                                        P
                                                                     
                                                                     
                                                                        2
                                                                     
                                                                     
                                                                        ′
                                                                     
                                                                  
                                                                  ,
                                                                  i
                                                                  ,
                                                                  j
                                                                  ,
                                                                  d
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                                14: 
                                                   
                                                   
                                                   if 
                                                   
                                                      
                                                         
                                                            
                                                               U
                                                            
                                                            
                                                               w
                                                            
                                                            
                                                               f
                                                               
                                                                  
                                                                     
                                                                        
                                                                           
                                                                              P
                                                                           
                                                                           
                                                                              1
                                                                           
                                                                           
                                                                              ′
                                                                           
                                                                        
                                                                        ,
                                                                        
                                                                           
                                                                              P
                                                                           
                                                                           
                                                                              2
                                                                           
                                                                           
                                                                              ′
                                                                           
                                                                        
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                         >
                                                         MaxU
                                                      
                                                    
                                                   then
                                                
                                             
                                             
                                                15: 
                                                   
                                                   
                                                   
                                                      
                                                         MaxU
                                                         ←
                                                         
                                                            
                                                               U
                                                            
                                                            
                                                               w
                                                            
                                                            
                                                               f
                                                               
                                                                  
                                                                     
                                                                        
                                                                           
                                                                              P
                                                                           
                                                                           
                                                                              1
                                                                           
                                                                           
                                                                              ′
                                                                           
                                                                        
                                                                        ,
                                                                        
                                                                           
                                                                              P
                                                                           
                                                                           
                                                                              2
                                                                           
                                                                           
                                                                              ′
                                                                           
                                                                        
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                         ,
                                                         best
                                                         (
                                                         
                                                            
                                                               m
                                                            
                                                            
                                                               1
                                                            
                                                         
                                                         )
                                                         ←
                                                         
                                                            
                                                               m
                                                            
                                                            
                                                               1
                                                            
                                                         
                                                         ,
                                                         best
                                                         (
                                                         
                                                            
                                                               m
                                                            
                                                            
                                                               2
                                                            
                                                         
                                                         )
                                                         ←
                                                         
                                                            
                                                               m
                                                            
                                                            
                                                               2
                                                            
                                                         
                                                         ,
                                                         best
                                                         (
                                                         i
                                                         )
                                                         ←
                                                         i
                                                         ,
                                                         best
                                                         (
                                                         j
                                                         )
                                                         ←
                                                         j
                                                         ,
                                                         best
                                                         (
                                                         d
                                                         )
                                                         ←
                                                         d
                                                      
                                                   
                                                
                                             
                                             
                                                16: 
                                                   
                                                   
                                                   end if
                                                
                                             
                                             
                                                17: 
                                                   
                                                   end for
                                                
                                             
                                             
                                                18: 
                                                   
                                                   end for
                                                
                                             
                                             
                                                19: 
                                                   end for
                                                
                                             
                                             
                                                20: 
                                                   end if
                                                
                                             
                                             
                                                21: end for
                                                
                                             
                                             
                                                22: if 
                                                   match
                                                   =0 then
                                                
                                             
                                             
                                                23: Return P
                                                   1
                                                   ⋃
                                                   P
                                                   2
                                                   =∅
                                             
                                             
                                                24: end if
                                                
                                             
                                             
                                                25: Mirror(P
                                                   1,
                                                   best(m
                                                   1)), Mirror(P
                                                   2,
                                                   best(m
                                                   1))
                                             
                                             
                                                26: Attach(P
                                                   1,
                                                   P
                                                   2,
                                                   best(i),
                                                   best(j)), Slide(P
                                                   1,
                                                   P
                                                   2,best(i),
                                                   best(j),
                                                   best(d))
                                             
                                             
                                                27: Return P
                                                   1
                                                   ⋃
                                                   P
                                                   2
                                                
                                             
                                          
                                       
                                    
                                 
                              

In this section we describe the definitions, functions and procedures to generate the forest search. Some of the notation and definitions are analogous to those described in the previous section. A key progression is that the operations are performed with clusters of polygons rather than the original basic polygons.

Let set T be the subset of the demand set D, so T
                           ={P
                           1,P
                           2,…,
                           P
                           
                              t
                           }⊆
                           D. Let f(T)=
                           f
                           1(P
                           1)⋃
                           f
                           2(P
                           2)⋃…⋃
                           f
                           
                              t
                           (P
                           
                              t
                           ) be a transformation of set T, where f
                           
                              i
                           (P
                           
                              i
                           ), i
                           =1,…,
                           t, is a transformation of polygon P
                           
                              i
                           . All the transformations on T form the transformation space, denoted by Ψ
                           
                              T
                           . The convex hull of f(T) is O(f(T)). A uniform transformation of T is when f
                           
                              i
                           
                           =
                           f
                           
                              j
                           , for all i,
                           j
                           ∈[1,
                           t].

In order for the transformation of set T to be feasible, f(T) must satisfy two conditions: no pair of polygons may overlap and every polygon can be removed from the stock sheet using guillotine cuts.
                              Proposition 1
                              
                                 
                                    Algorithm 1 
                                 produces non-overlapping configurations of pieces.
                              

The attach and slide operators only generate non-overlapping configurations of P
                                 1 and P
                                 2. The convex hull of the best match from Algorithm 1 is O(P
                                 1
                                 ⋃
                                 f(P
                                 2)). Let 
                                    
                                       
                                          
                                             P
                                          
                                          
                                             1
                                          
                                          
                                             ∗
                                          
                                       
                                       =
                                       O
                                       (
                                       
                                          
                                             P
                                          
                                          
                                             1
                                          
                                       
                                       ⋃
                                       f
                                       (
                                       
                                          
                                             P
                                          
                                          
                                             2
                                          
                                       
                                       )
                                       )
                                    
                                  and 
                                    
                                       
                                          
                                             P
                                          
                                          
                                             2
                                          
                                          
                                             ∗
                                          
                                       
                                    
                                  be the next polygon to be matched, then the matching of the three polygons will meet the no-overlap constraint. This is also true if 
                                    
                                       
                                          
                                             P
                                          
                                          
                                             2
                                          
                                          
                                             ∗
                                          
                                       
                                    
                                  is the convex hull of a cluster of polygons. Provided Algorithm 1 is matching convex polygons, or convex hulls of clusters of polygons, then the no-overlap constraint holds.□


                                 
                                    Algorithm 1 
                                 produces guillotine-able configurations of pieces.
                              

Let P
                                 1 and P
                                 2 be convex polygons and O(P
                                 1
                                 ⋃
                                 f(P
                                 2)) be the convex hull of the optimal match, where the match arises from edge e
                                 
                                    i
                                  from P
                                 1 and e
                                 
                                    j
                                  from P
                                 2 coinciding. Let 
                                    
                                       
                                          
                                             o
                                          
                                          
                                             →
                                          
                                       
                                    
                                  be the infinite line coinciding with e
                                 
                                    i
                                  and e
                                 
                                    j
                                 , then 
                                    
                                       
                                          
                                             o
                                          
                                          
                                             →
                                          
                                       
                                       ⊃
                                       FR
                                       (
                                       
                                          
                                             P
                                          
                                          
                                             1
                                          
                                       
                                       )
                                    
                                  and 
                                    
                                       
                                          
                                             o
                                          
                                          
                                             →
                                          
                                       
                                       ⊃
                                       FR
                                       (
                                       
                                          
                                             P
                                          
                                          
                                             2
                                          
                                       
                                       )
                                    
                                 . Since P
                                 1 and P
                                 2 are convex then 
                                    
                                       
                                          
                                             o
                                          
                                          
                                             →
                                          
                                       
                                       ⋂
                                       INT
                                       (
                                       
                                          
                                             P
                                          
                                          
                                             i
                                          
                                       
                                       )
                                       =
                                       ∅
                                    
                                  for i
                                 =1,2 then we know that 
                                    
                                       
                                          
                                             o
                                          
                                          
                                             →
                                          
                                       
                                    
                                  is a feasible guillotine cut for P
                                 1 and P
                                 2.□

Note that guillotine cuts are defined in reverse order, i.e. the first match defines the last cut. In general, O(f(T)) is called guillotine-able if one of the following two conditions is satisfied:
                              
                                 1.
                                 
                                    T only contains two convex basic polygons P
                                    1 and P
                                    2.

There exists one guillotine segment in O(f(T)), which divide T into two subsets T
                                    1 and T
                                    2, and T
                                    1 and T
                                    2 are guillotine-able.

A non-overlapping guillotine-able transformation is called a feasible transformation.

Blocks, B
                           
                              i
                           , populate the forest. In order for subsets of polygons to appear in the forest, they must be part of a valid block. A valid block is the convex hull of a feasible transformation of T with a utilization ratio of at least θ, where θ is the acceptance threshold for blocks to appear in the forest. It can be defined by Eq. (6)
                           
                              
                                 (6)
                                 
                                    
                                       
                                          B
                                       
                                       
                                          i
                                       
                                    
                                    =
                                    
                                       
                                          
                                             O
                                             (
                                             f
                                             (
                                             
                                                
                                                   T
                                                
                                                
                                                   i
                                                
                                             
                                             )
                                             )
                                             |
                                             
                                                
                                                   U
                                                
                                                
                                                   w
                                                
                                                
                                                   f
                                                   (
                                                   
                                                      
                                                         T
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   )
                                                
                                             
                                             ⩾
                                             θ
                                             ,
                                             
                                             f
                                             
                                             is a feasible transformation
                                          
                                       
                                    
                                 
                              
                           Eq. (6) is a necessary condition to define a block but it does not fully describe its composition. A block may be made up of several groups of pieces that have been matched and approximated by their convex hull. Fig. 3
                            shows a small portion of the forest and illustrates the creation and composition of blocks through the levels of the search. At the top level the forest contains all basic items and each basic item is a block. The second level contains pairs of basic items in the configuration that gives the best U
                           
                              w
                           , these are the level two blocks. Level three adds a basic item to the level two blocks. Level four contains a level three block combined with a basic item, but could also contain two level two blocks. Level five is empty in this example, but could contain combinations from level four and one or level two and three. Finally level six contains all basic items made up from a block from levels two and four.

In general, at the first level of the forest, m
                           =1, a block is a basic polygon. Applying Algorithm 1 directly to the basic polygons generates all candidate feasible transformations for m
                           =2. The convex hull of each feasible transformation becomes a block in the second level if the weighted utilization ratio is at least θ. Note that the level refers to the number of basic polygons in the subset. Hence, m
                           =3 would match a block from level one and level two, using Algorithm 1 and so on. Hence, the convex hull of a feasible transform of subset T is a block, B, if one of the following two conditions is satisfied.
                              
                                 1.
                                 
                                    B contains only one element.


                                    B can be divided into two subsets B
                                    1,B
                                    2, and the weighted utilization of B is greater than θ, and B
                                    1,
                                    B
                                    2 are valid blocks.

In order to control the size of the forest, we only accept a new block in the forest if the weighted utilization ratio meets, or exceeds, an acceptance threshold θ. The utilization ratios and weighted utilization are calculated using Eqs. (2)–(4), where P
                           1 is replaced by B
                           1 and P
                           2 is replaced by B
                           2.

As discussed earlier, the weighted utilization ratio represents the two aspirations of tight packing and an overall rectangular layout to fit the stock sheet area. Initially the tightness of the packing is more important. As the layout grows closer to the stock sheet size, the rectangular shape is more important. As a result, we define a number of alternative weighting schemes, both dynamic and fixed.

There are three fixed weighting schemes that set w
                           ={0,0.5,1.0} for the entire search process. The dynamic weighting schemes increases the value of w for each generation, m, where m
                           =1,…,
                           G, and G is the maximum number of generations. We use the following S shape function to manage the transition of the weights.
                              
                                 (7)
                                 
                                    
                                       
                                          w
                                       
                                       
                                          m
                                       
                                    
                                    =
                                    1
                                    -
                                    
                                       
                                          1
                                       
                                       
                                          1
                                          +
                                          
                                             
                                                e
                                             
                                             
                                                
                                                   
                                                      2
                                                      m
                                                      -
                                                      G
                                                   
                                                   
                                                      2
                                                      K
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                           K controls the linearity of the function. When K
                           =1, the range of the exponential component is from almost zero to very large, hence the graph of w
                           
                              m
                            is a sharp S shape function from zero to one. When K is large w
                           
                              m
                            is approximately linear. Also note that at half the maximum generations w
                           
                              m
                           
                           =0.5. In our experiments we use K
                           ={3,5,15} as illustrated in Fig. 4
                           .

The generation of the forest naturally extends from the definition of a block, and in particular the concept of a block as a tree, where all the trees make up the forest. Note that branches of blocks may be shared. Eq. (8) provides a mathematical description of each level of the forest. 
                              
                                 
                                    
                                       g
                                    
                                    
                                       m
                                    
                                    
                                       θ
                                       ,
                                       w
                                    
                                 
                              
                            where m is the level, θ is the acceptance threshold and w is the weight applied to the utilization ratio. Level 1 is simply the basic polygons in the demand set D. Subsequent levels are θ acceptable matches of blocks from the previous level.
                              
                                 (8)
                                 
                                    
                                       
                                          g
                                       
                                       
                                          m
                                       
                                       
                                          θ
                                          ,
                                          w
                                       
                                    
                                    =
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            P
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      ,
                                                      i
                                                      ∈
                                                      D
                                                   
                                                   
                                                      m
                                                      =
                                                      1
                                                   
                                                
                                                
                                                   
                                                      
                                                         
                                                            
                                                               ⋃
                                                            
                                                            
                                                               i
                                                               +
                                                               j
                                                               =
                                                               m
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               f
                                                               (
                                                               
                                                                  
                                                                     B
                                                                  
                                                                  
                                                                     i
                                                                  
                                                               
                                                               ,
                                                               
                                                                  
                                                                     B
                                                                  
                                                                  
                                                                     j
                                                                  
                                                               
                                                               )
                                                               |
                                                               
                                                                  
                                                                     B
                                                                  
                                                                  
                                                                     i
                                                                  
                                                               
                                                               ∈
                                                               
                                                                  
                                                                     g
                                                                  
                                                                  
                                                                     i
                                                                  
                                                                  
                                                                     θ
                                                                     ,
                                                                     w
                                                                  
                                                               
                                                               ,
                                                               
                                                                  
                                                                     B
                                                                  
                                                                  
                                                                     j
                                                                  
                                                               
                                                               ∈
                                                               
                                                                  
                                                                     g
                                                                  
                                                                  
                                                                     j
                                                                  
                                                                  
                                                                     θ
                                                                     ,
                                                                     w
                                                                  
                                                               
                                                               ,
                                                               
                                                                  
                                                                     U
                                                                  
                                                                  
                                                                     w
                                                                  
                                                                  
                                                                     
                                                                        
                                                                           f
                                                                        
                                                                        
                                                                           w
                                                                        
                                                                     
                                                                     (
                                                                     
                                                                        
                                                                           B
                                                                        
                                                                        
                                                                           i
                                                                        
                                                                     
                                                                     ,
                                                                     
                                                                        
                                                                           B
                                                                        
                                                                        
                                                                           j
                                                                        
                                                                     
                                                                     )
                                                                  
                                                               
                                                               ⩽
                                                               θ
                                                               ,
                                                               
                                                                  
                                                                     T
                                                                  
                                                                  
                                                                     i
                                                                  
                                                               
                                                               
                                                                  ⋂
                                                               
                                                               
                                                                  
                                                                     T
                                                                  
                                                                  
                                                                     j
                                                                  
                                                               
                                                               =
                                                               ∅
                                                            
                                                         
                                                      
                                                   
                                                   
                                                      m
                                                      >
                                                      1
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

In addition to the acceptance threshold on weighted utilization, there are two further constraints on the acceptability of a block. First, only one of each piece type can appear across all the patterns. Before matching blocks, the procedure performs a conflict check for common pieces. Hence, a match between B
                           
                              i
                            and B
                           
                              j
                            is made only if T
                           
                              i
                           
                           ⋂
                           T
                           
                              j
                           
                           =∅. Second, each new block must not violate the dimensions of the stock sheet. Hence, we need to check if the length and width of the block is larger than those of the rectangle stock sheet. Note that the entire block can be freely rotated and a block may exceed the boundaries of the stock sheet in one orientation and not in another. Since the minimum area enclosing rectangle will have an edge collinear to the edge of the block (Toussaint [15], then the worst case number of tests equals the number of edges of the block. However, since we only need to satisfy this constraint, the number of tests may be many fewer. Let l(R(B)),w(R(B)) be the length and width of the candidate rectangle enclosure of block B, where the rectangle has at least one edge collinear with the block, then l(R(B))⩽
                           L,w(R(B)) ⩽
                           W must hold for one of the candidates. Algorithm 2 details the procedure to generate a forest.
                              Algorithm 2
                              Forest Construction 
                                    
                                       
                                          
                                          
                                             
                                                1: Input: G,
                                                   D,
                                                   K,
                                                   θ
                                                
                                             
                                             
                                                2: Initialize 
                                                   
                                                      
                                                         
                                                            
                                                               g
                                                            
                                                            
                                                               m
                                                            
                                                            
                                                               θ
                                                            
                                                         
                                                         ←
                                                         ∅
                                                      
                                                    for all m. Set m
                                                   =1 and calculate w
                                                   
                                                      m
                                                    according to K and G
                                                
                                             
                                             
                                                3: 
                                                      
                                                         
                                                            
                                                               g
                                                            
                                                            
                                                               1
                                                            
                                                            
                                                               θ
                                                            
                                                         
                                                         ←
                                                         D
                                                      
                                                   
                                                
                                             
                                             
                                                4: for 
                                                   L
                                                   =2,…,
                                                   m 
                                                   do
                                                
                                             
                                             
                                                5: 
                                                   for 
                                                   
                                                      
                                                         i
                                                         =
                                                         1
                                                         ,
                                                         …
                                                         ,
                                                         
                                                            
                                                               
                                                                  
                                                                     
                                                                        L
                                                                     
                                                                     
                                                                        2
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                    
                                                   do
                                                
                                             
                                             
                                                6: For each block 
                                                      
                                                         
                                                            
                                                               B
                                                            
                                                            
                                                               x
                                                            
                                                         
                                                         ∈
                                                         
                                                            
                                                               g
                                                            
                                                            
                                                               L
                                                            
                                                            
                                                               θ
                                                            
                                                         
                                                      
                                                    combined with each block 
                                                      
                                                         
                                                            
                                                               B
                                                            
                                                            
                                                               y
                                                            
                                                         
                                                         ∈
                                                         
                                                            
                                                               g
                                                            
                                                            
                                                               L
                                                               -
                                                               i
                                                            
                                                            
                                                               θ
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                                7: 
                                                   if 
                                                   T
                                                   
                                                      x
                                                   
                                                   ⋂
                                                   T
                                                   
                                                      y
                                                   
                                                   =∅ then
                                                
                                             
                                             
                                                8: 
                                                   construct f(B
                                                   
                                                      x
                                                   ,
                                                   B
                                                   
                                                      y
                                                   ) using Algorithm 1
                                             
                                             
                                                9: 
                                                   
                                                   if 
                                                   
                                                      
                                                         
                                                            
                                                               U
                                                            
                                                            
                                                               
                                                                  
                                                                     w
                                                                  
                                                                  
                                                                     L
                                                                  
                                                               
                                                            
                                                            
                                                               f
                                                               (
                                                               
                                                                  
                                                                     B
                                                                  
                                                                  
                                                                     x
                                                                  
                                                               
                                                               ,
                                                               
                                                                  
                                                                     B
                                                                  
                                                                  
                                                                     y
                                                                  
                                                               
                                                               )
                                                            
                                                         
                                                         >
                                                         θ
                                                      
                                                    
                                                   then
                                                
                                             
                                             
                                                10: 
                                                   
                                                   
                                                      
                                                         
                                                            
                                                               g
                                                            
                                                            
                                                               L
                                                            
                                                            
                                                               θ
                                                            
                                                         
                                                         ←
                                                         
                                                            
                                                               g
                                                            
                                                            
                                                               L
                                                            
                                                            
                                                               θ
                                                            
                                                         
                                                         ⋃
                                                         f
                                                         (
                                                         
                                                            
                                                               B
                                                            
                                                            
                                                               x
                                                            
                                                         
                                                         ,
                                                         
                                                            
                                                               B
                                                            
                                                            
                                                               y
                                                            
                                                         
                                                         )
                                                      
                                                   
                                                
                                             
                                             
                                                11: 
                                                   
                                                   end if
                                                
                                             
                                             
                                                12: 
                                                   end if
                                                
                                             
                                             
                                                13: 
                                                   end for
                                                
                                             
                                             
                                                14: end for
                                                
                                             
                                          
                                       
                                    
                                 
                              

The final step of the approach is to pack the blocks that populate the forest into the bins. All blocks will satisfy the acceptance threshold, hence in this step we seek to place blocks on stock sheets as efficiently as possible. Clearly, packing blocks into bins will generate more waste between the edges of the stock sheet and the blocks, and between adjacent blocks. A utilization threshold, θ
                        
                           u
                        , determines whether a bin packing pattern is acceptable. Once the newly generated patterns are no longer acceptable, the approach reduces both the acceptance threshold (θ) and θ
                        
                           u
                         and generates a new forest with the remaining unpacked pieces, repeating the bin packing procedure with the lower utilization threshold. Eventually, both thresholds are set to zero to ensure all pieces are packed. The procedure has a number of operations as follows:


                        Recursive fill (RF): select the block with the largest area that will fit into a given size stock sheet/partial stock sheet, place the block at the top left corner. Note that a block can come from any part of the forest. Mark that block, and any other block containing common pieces, as used.


                        Single bin (SB): take a new stock sheet and call RF. Horizontal and vertical guillotine cuts divide the unpacked areas into S1 and S2. Fig. 5
                         shows the two possible ways of generating these partial stock sheets, we generate both. Call RF for each partial stock sheet and select the best. Continue this process until no further blocks can be packed.


                        Bin packing (BP): generate the forest given the input data, acceptance threshold and weighting scheme. θ
                        
                           u
                         initially is set to 0.8. Repeatedly call SB, and accept a pattern if the stock sheet utilization is greater than θ
                        
                           u
                        . Otherwise reduce θ to 0.9 and θ
                        
                           u
                         to 0.7, generate a new forest with the remaining pieces and call SB as before. The third and final forest generation sets θ to 0.8 and θ
                        
                           u
                         to zero.

Note that initially we expect to fill a stock sheet with a single block, but it is highly unlikely that all stock sheets can be filled this way. In order to control computation time, the procedure generates at most three forests at reducing values of θ. After the third forest, set θ
                        
                           u
                        
                        =0 so all pieces are packed, potentially individually as the forest may not accept any matches. Since θ reduces the size of the forest, it should not be too small, however, the decrease must be sufficient to generate useful size blocks. Algorithm 3 gives a summary of the one stage procedure.
                           Algorithm 3
                           One-stage procedure 
                                 
                                    
                                       
                                       
                                          
                                             1: Input: G,
                                                D,
                                                K,
                                                W,
                                                L,
                                                θ,
                                                θ
                                                
                                                   d
                                                ,
                                                θ
                                                
                                                   u
                                                ,
                                                ∊,
                                                k
                                                =1
                                          
                                          
                                             2: Generate forest using Algorithm 2
                                             
                                          
                                          
                                             3: Pack single bin, BIN
                                                   k
                                                
                                             
                                          
                                          
                                             4: until no further blocks can be packed, call recursive fill
                                          
                                          
                                             5: if stock sheet utilization ⩾θ
                                                
                                                   u
                                                 
                                                then
                                             
                                          
                                          
                                             6: go to 3
                                          
                                          
                                             7: end if
                                             
                                          
                                          
                                             8: if remaining blocks contain unused pieces then
                                             
                                          
                                          
                                             9: Reduce θ
                                                
                                                   u
                                                 and θ and go to 2
                                          
                                          
                                             10: end if
                                             
                                          
                                          
                                             11: Return BIN
                                                   i
                                                ,i
                                                =1,…,
                                                k
                                             
                                          
                                       
                                    
                                 
                              
                           

In order to benchmark our approach we implement a two-stage procedure. The first stage encloses individual or pairs of pieces into rectangles, the second stage packs the rectangles. For the former we investigate two approaches. One clusters the pieces using Algorithm 1, described earlier. The other uses a state of the art convex polygon clustering approach using phi-functions presented by Scheithauer et al. [14]. See Bennell et al. [2] for a discussion of phi-functions. For the latter we use the recently published guillotine bin packing approach of Charalambous and Fleszar [6].

The approach is directly taken from Charalambous and Fleszar [6] and therefore only briefly described here.

The fundamental building block of the approach is a simple pattern generator that arranges a subset of pieces side by side. Items that are available to be packed are sorted in non-increasing order of the weighted sum of their normalized height and area and then patterns are generated using the well-known first fit rule. Rotation is taken care of by including two copies of each piece in each orientation, if one copy is used the other becomes unavailable. They generate a number of alterative simple patterns by varying the weights, and identify those that satisfying a sufficiency criterion, which reduces the greediness of the approach. From the identified patterns, they select the pattern with the maximum total area of items, if no patterns satisfy the sufficiency criteria, they select the pattern that violates it the least. Clearly the simple pattern must fit within the available rectangle. Initially this rectangle is the size of the bin, but subsequent calls to the generator will be for smaller empty rectangle areas remaining in the bin.

The procedure generates a simple pattern and places it in the bottom left corner of the bin, this is the committed pattern. Then it identifies multiple empty overlapping rectangles that are all above the simple pattern, removing any rectangle areas that are too small for any available item. The simple pattern generator fills each rectangle and selects the best when combined with the current committed pattern. Following sets of overlapping empty rectangles may appear above, below or to the left of the last committed pattern and are filled in that order. While maintaining guillotine cuts, these rectangles are expanded to the maximum size by shifting sets of pieces in the pattern vertically or horizontally. Once no further pieces can be added to the pattern, the procedure begins again on the next bin until all items are packed. If the stock sheet is not square, the complete procedure is repeated with the stock sheet rotated by 90°. The authors suggest a further improvement to the constructive heuristic, which involves varying the strength of the sufficiency criteria using a bias.

The basic items are approximated by an enclosing rectangle individually and in pairs. The minimum area rectangle enclosure of a single piece is straightforward to find given it will have one edge colinear with the edge of the piece [15]. The maximum number of edges in our data sets is five, hence complete enumeration is quick and simple. The minimum area enclosing rectangle for a pair of pieces, where the pieces can be freely rotated is non-trivial. For one variant we cluster two pieces using Algorithm 1. For the other variant, we use the phi-function implementation of Scheithauer et al. [14].

The phi-function procedure is complex and only briefly outlined here. Given two convex polygons, find the phi-function for the pair of polygons with free rotation and the phi function for each polygon with free rotation and the complement of a rectangle with variable length and width. See Chernov et al. [7] for details of this procedure. These phi-functions are deconstructed into phi-trees where the terminal nodes correspond to systems of nonlinear inequalities, each focusing on a subset of configurations of the polygons. Each set of inequalities are solved to minimize the area of the enclosing rectangle using IPOPT and the best is selected. Since there are multiple local optima for each set of inequalities, we define many starting solutions. Note that if the polygons have fixed orientation, the procedure defines a linear set of inequalities that can be solved to optimality.

The clustering approach generates a complete set of candidate rectangles that include multiple copies of each piece. In order to determine the set of rectangles to use as input to the guillotine packing algorithm, we apply a greedy selection. This sorts all the enclosing rectangle clusters, individual and pairs, from minimum to maximum waste, where waste is defined by Eq. (9).
                           
                              (9)
                              
                                 
                                    
                                       W
                                    
                                    
                                       k
                                    
                                 
                                 =
                                 Area
                                 (
                                 R
                                 (
                                 f
                                 (
                                 
                                    
                                       P
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 
                                    
                                       P
                                    
                                    
                                       2
                                    
                                 
                                 )
                                 )
                                 )
                                 -
                                 (
                                 Area
                                 (
                                 
                                    
                                       P
                                    
                                    
                                       1
                                    
                                 
                                 )
                                 +
                                 Area
                                 (
                                 
                                    
                                       P
                                    
                                    
                                       2
                                    
                                 
                                 )
                                 )
                              
                           
                        
                     

In the case of an individual piece, P
                        2 is an empty set. The heuristic selects the first rectangle on the sorted list, removes any rectangles that contain common piece(s), selects the next available rectangle on the sorted list, and so on until the list is empty. At this point all basic items will appear once in the rectangle clusters.

@&#EXPERIMENTS AND RESULTS@&#

In this section we provide details of the results for both the one-stage and two-stage approaches. For the one-stage approaches, we investigate two initial settings for the acceptance threshold (θ). The two-stage approach includes three sets of experiments: two variants that allow pieces to be clustered in pairs and one variant that only enclose individual pieces in rectangles. Experiments were programmed using C++ and Java and run on PC with 2.4gigahertz and 2G memory.


                        Table 1
                         provides details of the test data to be packed on stock sheets of size 3210 by 2250. Sets coded J are taken from real industrial data provided by a company specializing in glass cutting for conservatories. Sets coded H are generated using the properties of the industrial data. The number indicates the number of pieces in each data set. Recall each piece is considered unique. The table details the average number of edges, standard deviation of edges, the average area and the standard deviation of the area. The final column indicates the degree of irregularity of the data set found by Eq. (10). These data sets are available on the European Working Group in Cutting and Packing (ESICUP) website.
                           
                              (10)
                              
                                 Irregular degree
                                 =
                                 
                                    
                                       1
                                    
                                    
                                       n
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          P
                                          ∈
                                          D
                                       
                                    
                                 
                                 
                                    
                                       
                                          1
                                          -
                                          
                                             
                                                Area
                                                (
                                                P
                                                )
                                             
                                             
                                                R
                                                (
                                                P
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

@&#RESULTS@&#


                        Tables 2 and 3
                        
                         detail the results for the two approaches. The main body of the tables include the following information for each data set and variant: total number of bins to pack all pieces (N), stock sheet utilization (U), and the fractional number of bins used (F). The utilization is calculated by Eq. (11).
                           
                              (11)
                              
                                 U
                                 =
                                 
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             i
                                             =
                                             1
                                          
                                          
                                             n
                                          
                                       
                                       Area
                                       (
                                       
                                          
                                             P
                                          
                                          
                                             i
                                          
                                       
                                       )
                                    
                                    
                                       (
                                       (
                                       N
                                       -
                                       1
                                       )
                                       ×
                                       L
                                       ×
                                       W
                                       )
                                       +
                                       
                                          
                                             R
                                          
                                          
                                             ∗
                                          
                                       
                                    
                                 
                              
                           
                        where R
                        ∗ is the rectangle area of the stock sheet used once the reusable residual has been removed by either a complete horizontal or vertical guillotine cut, depending on which gives the largest reusable rectangle piece. This measure of utilization is helpful in differentiating the quality of competing methods when they produce solutions with the same number of bins. The fractional number of bins is calculated as (N
                        −1) plus the proportion of the final bin used once the reusable residual is removed.

For Table 2, the results refer to two starting acceptance thresholds θ and for each there are six weighting schemes for U
                        
                           w
                        . The first three are constant where w
                        =0 will focus solely on the convex enclosure and w
                        =1 will focus solely on the rectangle enclosure. The former will report lower waste for the same match, so more solutions will be accepted under this measure than the rectangle enclosure measures. This gives greater opportunity to find blocks but will result in longer run times (see Table 4
                        ). w
                        =0.5 gives equal weight to each. The second three schemes change the weights as the search moves through the levels of the forest, starting with a focus on convex enclosure, corresponding to small w, and shifting the focus to rectangle enclosure later in the search, corresponding to large w. The dynamic weights are linear, K
                        =3, which has the steepest sigmoid curve, and K
                        =5, which is less steep. These will accept fewer blocks than w
                        =0, but theoretically the accepted blocks will be more suitable for the final bin packing. This is born out in the results where the better results arise from the dynamic weighting schemes in general. Further, the S shaped weighting schemes consistently out perform the linear weighting scheme, where the less steep function found with K
                        =5 does better for a lower initial θ and the steepest function, K
                        =3, does better for the higher θ.


                        Table 3 retains the results for θ
                        =0.94 and K
                        =5, and θ
                        =0.97 and K
                        =3, and compares them with the two-stage approach where rectangles are clustered individually (single) and in pairs using Algorithm 1 (Alg 1) and phi-functions (Phi fn). Clearly, clustering individually consistently produces inferior solutions than all the other approaches. Clustering in pairs using phi-functions performs better than Algorithm 1 for all the data sets. The benefit of phi-functions reduces as the data sets grow in size with 4.8% improvement in utilization for small data sets and 1.6% for the largest. Clustering in pairs (using phi-functions) and the one-stage approach do similarly well, with one-stage doing better on five instances and two-stage doing better on three. The one-stage strategy packs the beginning stock-sheets very well but has a weak tail, where as two-stage will perform more consistently throughout. A key drawback of the two-stage approach using phi-functions is the computational time. The pairing process takes just over an hour for the smallest data set (40 pieces) and over eighteen hours for the largest (149 pieces), although the packing algorithm of Charalambous and Fleszar [6] takes only one or two seconds for all data sets. Pairing using Algorithm 1 also has negligible computational times (less than a second for all data sets). The computational times for the one-stage approach are in Table 4. The weighting scheme that emphasizes convex hull will accept more matches and lead to more branches, and as a result take longer to run. Also a lower initial θ will accept more matches. A lower θ will provide more opportunity to find better solutions, but the benefit of this is not clear cut in these results. Clearly there are many parameters that can be varied in the one-stage approach, in particular the acceptance thresholds at various points in the algorithm which control the relationship between run time and scope of the search. For θ
                        =0.94, the number of nodes is just over 10,000 for the largest data set and the average is approximately 5000. Increasing θ to 0.97 reduces the average to around 1000.

@&#CONCLUSIONS@&#

The paper addresses the irregular shape guillotine bin packing problem, which is found in the glass cutting industry, specifically for this paper, in the manufacture of conservatories. To the authors’ best knowledge, this problem has not been addressed in the literature before. We propose a forest tree search algorithm to solve this problem approximately, which is novel in the literature. First, we develop a procedure to find the best match of any two given convex shapes, which is evaluated using a newly derived function that includes two measures: how tight the packing is and how well it approximates to the rectangular stock sheet. The emphasis between these measures is dynamic through the search. Secondly, we construct search forest by selecting only those blocks with the utilization ratio function larger than a given value. Since this is a new problem in the literature, we cannot benchmark our results against previous work. Instead, we implement a second approach, called two-stage. This clusters all possible individuals and pairs into an enclosing rectangle, greedily selects a subset of rectangle enclosures so that all pieces are represented once, then generates the bin packing layout using a recently published guillotine cutting heuristic. The forest search and two-stage, using phi-functions for pairing, perform similarly well, but the forest search is significantly faster. A fast two-stage approach uses an alternative heuristic for pairing and produces results with between 1% and 5% reduction in stock sheet utilization. We have also introduced new benchmark data sets for this problem.

There is significant scope for more research on this problem, given its relevance and lack of attention by researchers. Two suggestions for investigation that build on this research are: to improve the quality of packing at the tail end of the pattern construction for the one-stage approach, and investigating a larger clusters for the two-stage approach.

@&#ACKNOWLEDGEMENTS@&#

Prof. Romanova, Prof. Stoyan and Prof. Pankratov for generously supporting this project by allowing us to use their phi-function implementation.

@&#REFERENCES@&#

