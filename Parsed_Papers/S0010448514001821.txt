@&#MAIN-TITLE@&#A highly solid model boundary preserving method for large-scale parallel 3D Delaunay meshing on parallel computers

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We propose a novel parallel 3D Delaunay meshing algorithm for large-scale simulations.


                        
                        
                           
                           The model information is kept during parallel triangulation process.


                        
                        
                           
                           A 3D local non-Delaunay mesh repair algorithm is proposed.


                        
                        
                           
                           The meshing results can be very approaching to the model boundary.


                        
                        
                           
                           The method can achieve high parallel performance and perfect scalability.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

3D Delaunay meshing

Parallel mesh generation

Mesh partition

CAD model boundary preserved meshing

@&#ABSTRACT@&#


               
               
                  In this paper, we propose a novel parallel 3D Delaunay triangulation algorithm for large-scale simulations on parallel computers. Our method keeps the 3D boundary representation model information during the whole parallel 3D Delaunay triangulation process running on parallel computers so that the solid model information can be accessed dynamically and the meshing results can be very approaching to the model boundary with the increase of meshing scale. The model is coarsely meshed at first and distributed on CPUs with consistent partitioned shared interfaces and partitioned model boundary meshes across processors. The domain partition aims at minimizing the edge-cuts across different processors for minimum communication cost and distributing roughly equal number of mesh vertices for load balance. Then a parallel multi-scale surface mesh refinement phase is iteratively performed to meet the mesh density criteria followed by a parallel surface mesh optimization phase moving vertices to the model boundary so as to fit model geometry feature dynamically. A dynamic load balancing algorithm is performed to change the partition interfaces if necessary. A 3D local non-Delaunay mesh repair algorithm is finally done on the shared interfaces across processors and model boundaries. The experimental results demonstrate our method can achieve high parallel performance and perfect scalability, at the same time preserve model boundary feature and generate high quality 3D Delaunay mesh as well.
               
            

@&#INTRODUCTION@&#

Mesh generation is the pre-process of Finite Element Analysis (FEA), whose result affects FEA solutions critically. Delaunay triangulation is the most widely used method for mesh generation. Many strategies for its construction have been proposed. In the paper by Su  [1], numerical tests on several Delaunay triangulation algorithms, namely, divide and conquer algorithms  [2], sweep line algorithms  [3], incremental algorithms  [4], and gift wrapping algorithms  [5], were conducted and their performances were compared.

With the rapid increase in problem size from thousands to millions of vertices to achieve higher-precision numerical simulations, devising efficient schemes to construct Delaunay triangulation is necessary. Due to the limitations of memory and speed on single computer, parallel Delaunay triangulation plays an increasingly important role. It is a relatively new research area that combines both computational geometry and parallel computing. For computational geometry, it is important to ensure that the parallel algorithm can preserve model boundary feature and generate high-quality 3D Delaunay mesh. For parallel computing, it is critical to ensure that the parallel algorithm can handle extremely large-scale data sets as well as achieve high parallel performance and perfect scalability. To meet both requirements, this paper proposes a highly solid model boundary preserving method for large-scale parallel 3D Delaunay meshing.

For computational geometry, the input of current parallel 3D Delaunay triangulation algorithms is the sampling vertices or the coarse surface triangle mesh of the model boundary. The input sampling vertices or coarse surface triangle mesh cannot express the model boundary precisely. Thus, the final generated tetrahedral mesh is restricted by the input. Moreover, the boundary feature of the 3D model cannot be well preserved. In addition, during parallel 3D Delaunay triangulation process, current algorithms do not optimize mesh to match model boundary. As a result, mesh precision cannot be improved even with the increase of the mesh scale. Thus, preserving model boundary feature and generating high-quality 3D Delaunay mesh is difficult.

For parallel computing strategies, current parallel 3D Delaunay triangulation algorithms are classified into domain decomposition and node-based modes according to their parallel schemas. The algorithms of the domain decomposition mode are further distinguished as coupled and decoupled according to the complexity of communications.

In 2003, Chrisochoides et al.  [6] present a parallel B–W insertion for mesh generation. It is reported that code complexity might cause stability issues near the domain boundary. Parallel optimistic Delaunay meshing (PODM)  [7] is the first proven parallel 3D Delaunay meshing algorithm that can guarantee quality for restricted domains. Input to the algorithm is a partitioned and conforming Delaunay mesh of a restricted polyhedral domain. The sub-meshes of the distributed domains are then independently refined by inserting new vertices. The algorithm enables a new vertex to affect both the sub-mesh and the shared interfaces induced by the partitioning. This flexibility is crucial to ensure mesh quality but introduces unpredictable latencies attributed to delays in gathering remote data to update the local mesh. In the experiments, more than 80% of this latency is attributed to fine-grained concurrency.

Okusanya et al.  [8] present a parallel 3D Delaunay triangulation algorithm based on subdivision. Vertices are inserted concurrently within each sub-domain. Dynamic load-balancing is incorporated to ensure even work distribution during the parallel process. The inter-processor boundaries are enabled to move to accommodate element migration between sub-domains. Scalability can be maintained for a large number of processors provided that granularity is sufficiently high.

The DeWall algorithm presented by Cignoni et al.  [9] is a typical decoupled parallel Delaunay triangulation method. The DeWall algorithm includes two main phases. In the partition phase, partition walls are generated to divide the input vertices into some groups. In the merging phase, the generated sub-meshes are merged. However, this algorithm has low efficiency because achieving load balancing and high quality partition walls are difficult.

Glut et al.  [10] propose two domain decomposition schemas in order to improve the mesh quality near the decomposition interface. The difference between the two schemas lies in the step in which the actual partitioning occurs. In the decomposition surface mesh (DSM) schema, the partitioning is achieved by using solely the surface mesh. In the decomposition coarse volume mesh (DCVM) schema, a coarse tetrahedral mesh is used. After the decomposition and creation of an interface mesh, final volume meshes are generated independently for each sub-domain. However, the parallel efficiency is not ideal for sophisticated models because it is sensitive to the quality of the partition interface.

Lo et al.  [11] put forward a generic parallel Delaunay triangulation scheme using the zonal partition of vertices. Vertices are initially sorted into cells, and the cells are naturally grouped into zones, in which Delaunay triangulation is constructed cell by cell within each zone. Tetrahedral between zones are created by adding layers of cells at the shared interfaces of each zone. However, parallel efficiency is low for sophisticated models because it is hard to achieve load balancing with the distribution schema of vertices.

Node-based parallel Delaunay triangulation algorithms focus on every vertex, not on every sub-domain. Yagawa et al.  [12] propose a free mesh method, the input of which is a set of vertices and the vertices are distributed to processors. The task of each processor is to construct neighboring vertices set of each vertex. The global mesh is generated by merging all local neighboring vertices. The task of each processor is relatively independent. Thus, this algorithm is suitable for parallel computing. However, the local mesh around nearby vertices may be in conflict and considerable communication is needed to guarantee consistency.

To maintain the Delaunay property during the parallel process, Kohout et al.  [13] propose parallel Delaunay triangulation with edge and face swaps in 3D space. Beyer et al.  [14] present a procedure for parallel dynamic and kinetic regular triangulation in 3D based on incremental construction with parallel flipping of tetrahedral.

From the related work on parallel 3D Delaunay triangulation algorithms, we can see current algorithms only take sampling vertices or coarse surface triangle mesh as input. Thus, the model boundary feature cannot be well preserved and high-quality 3D Delaunay mesh cannot be generated. The initial input vertices or surface mesh are only approximations of 3D models. Mesh refinement on parallel computers cannot improve mesh precision, even with the increase in mesh scale. Moreover, current parallel algorithms only focus on distributing the initial input to processors. Dynamic load balancing is neglected during parallel process. Thus, high parallel efficiency cannot be achieved. Furthermore, the partitioned interfaces generated by most current algorithms are inconsistent on each sub-domain, leading to considerable communication to ensure synchronization. Finally, the tetrahedral mesh around the shared partitioned interfaces among processors may be non-Delaunay elements when merging sub-meshes. Current algorithms either neglect non-Delaunay elements, or remove them by face flipping. However face flipping in 3D space may cause the expansion of non-Delaunay regions.

To overcome the main defects of current parallel algorithms, we propose a highly solid model boundary preserving method for large-scale parallel 3D Delaunay meshing.

First, the 3D boundary representation model information is kept during the whole parallel 3D Delaunay triangulation process. The solid model information (including surface, curve, point and corresponding parameters) is used to move vertices to the model boundaries during the surface mesh optimization phase. Thus, the generated mesh can highly approximate the model boundary as mesh scale increases. Experiment results show that the proposed algorithm can preserve model boundary features and generate high-quality 3D Delaunay mesh.

Second, we propose an efficient parallel 3D local mesh reconstruction algorithm with minimum reconstruction region to repair the non-Delaunay mesh, which guarantees the Delaunay property for the global mesh.

Third, we present a parallel framework for large-scale 3D Delaunay triangulation with high parallel performance and perfect scalability. After very coarse tetrahedral meshing and domain partition, arbitrary large mesh can be generated on distributed computers with parallel refinement and optimization to preserve the model boundaries. Dynamic load balancing is performed to achieve efficient parallel performance. The quality of generated mesh can satisfy the requirements of large simulation well.

@&#OVERVIEW@&#

The whole method framework is shown in Fig. 1
                        . In the pre-processing phase, a coarse sampling is performed on the 3D model boundary followed by coarse 3D Delaunay triangulation. Then we create mapping between 3D model and the mesh, which is a key process to maintain solid model information. In the parallel computing phase, a domain partition is performed to distribute the coarse mesh into parallel computers. In the multi-scale mesh refinement and surface mesh optimization process, the solid model information is accessed dynamically to refine the coarse mesh and move vertices to model boundaries to capture geometry features. In parallel implementation, a minimum load movement algorithm is employed to change the partition interfaces and maintain dynamic load balance. Finally, a 3D local mesh reconstruction algorithm is done to repair the non-Delaunay mesh. More details are addressed in the following sections.

For previous parallel meshing methods, very fine-grained sampling is required to capture geometry features. Such sampling requires a great deal of time in sequential pre-processing for sophisticated models. Moreover, mesh precision cannot be improved as the mesh scale increases during the parallel phase. However, the proposed method does not need to densely sample according to the model boundary features. Very coarse sampling is sufficient because we bring CAD model information to the parallel processors, and real boundaries can be accessed and recovered during parallel meshing. Therefore, the pre-processing time of preparing initial mesh for large-scale parallel meshing is much shorter than that of existing methods.

To sample the boundary representation model coarsely, we first project the model to the 2D parameter space. We then perform uniform sampling on the parameter space. Finally, we project the 2D vertices back to the 3D model space. For example, a cube is sufficient to coarsely sample a sphere model, whereas a cuboid is sufficient to coarsely sample a cylinder model. Meanwhile, the number of coarse tetrahedral elements also depends on the number of available PEs. It would cost too much time during sequential pre-processing if a large number of coarse tetrahedral elements are generated. But if the number is too small, it is hard to generate good partition interfaces to distribute roughly equal working loads when there are too many PEs. In implementation, we generate about 50 coarse tetrahedral elements on each PE, which can obtain a good balance between sequential pre-processing and parallel computing.

To construct a coarse tetrahedral mesh, we adopt the vertex insertion algorithm proposed by Shewchuk  [15]. The vertex insertion operation is highly independent among each vertex, so it is very suitable for parallel computing. As we know bad coarse mesh will lead to bad decomposition and eventually bring negative impacts on the meshing performance. Thus, we also employ quality control to generate a high-quality mesh during coarsening. We optimize the surface triangles to generate roughly isotropic elements based centroidal Voronoi tessellation energy  [16]. In addition, we improve the quality of tetrahedral mesh based on Ruppert algorithm  [17] to ensure that the radius–edge ratios and dihedral angles are larger than a specific value.

To maintain the 3D boundary representation model information during the parallel 3D Delaunay triangulation process, the mapping between 3D model and the mesh should be created. We can then access the solid model information dynamically with the mesh vertices and elements based on the mapping. As shown in Fig. 2
                        , after importing the 3D model, every model surface is marked with a unique index number, such as 
                           
                              
                                 F
                              
                              
                                 1
                              
                           
                        , 
                           
                              
                                 F
                              
                              
                                 2
                              
                           
                         and 
                           
                              
                                 F
                              
                              
                                 3
                              
                           
                        . During the boundary coarse sampling process, every sampling vertex is assigned the indexes of the surfaces to which it belongs. For example, the sampling vertices 
                           
                              
                                 v
                              
                              
                                 1
                              
                           
                         and 
                           
                              
                                 v
                              
                              
                                 2
                              
                           
                         on the share boundary are both assigned surface index 1 and 2. Sequential triangulation is then performed surface by surface. Every generated mesh element corresponds to a unique surface. Thus, such element is assigned the index of the surface to which it belongs. For example, the generated element 
                           
                              
                                 e
                              
                              
                                 1
                              
                           
                         on surface 
                           
                              
                                 F
                              
                              
                                 1
                              
                           
                         is assigned surface index 1, whereas 
                           
                              
                                 e
                              
                              
                                 2
                              
                           
                         is assigned surface index 2.

The goal of domain partition is to divide the coarse tetrahedral mesh into a specific number of domains. At the same time, we aim at minimizing the number of edges that straddle different domains which will minimize cross processor communication and distribute roughly equal number of vertices and elements in every domain which will ensure load balancing in parallel computing.

To partition a mesh, we first convert the mesh into a dual graph (each element becomes a graph node). We then use the multilevel 
                           k
                        -way graph partition algorithm proposed by Karypis  [18]. During the coarsening phase, we use the Heavy Edge Matching algorithm  [19] to collapse the edge between two vertices. Thus, the size of the graph successively decreases. During the initial partitioning phase, we use the multilevel recursive bisection algorithm  [19] to generate 
                           k
                         domains of the smaller coarse graph. In the uncoarsening phase, we employ the KL optimization algorithm  [19], which repeatedly moves vertices from domains with larger weights to domains with smaller weights until balance is achieved. Finally, the partitioning is successively refined as it is projected to the larger graph.

The eight partitioned domains of a cylinder model are shown in Fig. 3
                        . As shown in Table 1
                        , each domain has roughly equal number of vertices and minimum number of edges that straddle different domains. Thus, load balancing is achieved and cross processor communication is minimized. As shown in Fig. 4
                        , the outer surface triangle elements of each sub-mesh can be categorized into two types: model boundary surface elements (1–8) and shared partitioned interface elements across domains (9). Model boundary surface elements are marked with the 3D model surface indices to which they belong. This information is crucial in the next parallel multi-scale surface mesh refinement and surface mesh quality optimization phase.

Based on the partitioned coarse surface mesh, we need to refine and optimize such mesh to meet the density and quality criteria of the final parallel 3D Delaunay meshing.

For the model boundary surface mesh, we aim to approximate the input domain boundary. Thus, an adaptive mesh refinement schema based on the sizing field is needed. The sizing field on the boundary should be a function of the local absolute maximum curvature. Given that we maintain the 3D model boundary information during the parallel triangulation process, we can easily access the solid model information dynamically to calculate the local curvature. Based on the adaptive sizing field, we can refine the boundary surface mesh to preserve boundary and curvature continuity, as shown in Figs. 5 and 6
                        
                        .

For the shared partitioned interface mesh, we adopt the mid-point refinement schema. We already have a consistent interface mesh as a result of the domain partition. Thus, a mid-point refinement schema on both sides of the domains can continue to guarantee consistency.

This surface mesh refinement is performed on every processing element (PE) simultaneously for corresponding domain mesh. Such refinement can be performed for numerous iterations to meet specific criteria of mesh density and quality. We only need to guarantee that the shared partitioned interface mesh is refined for the same iteration times to obtain a consistent mesh among domains.

On the basis of the refined surface mesh, we need to improve mesh quality by optimizing the positions of vertices, which is crucial to preserving model boundaries.

For the model boundary surface mesh, the newly added vertices during the previous multi-scale surface mesh refinement are still located at the original triangle edge, not at the model boundary. We should move the newly added vertices to the model boundary as shown in Fig. 7
                        .

As shown in Fig. 8
                        , triangle 
                           
                              〈
                              
                                 
                                    P
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    P
                                 
                                 
                                    2
                                 
                              
                              ,
                              
                                 
                                    P
                                 
                                 
                                    3
                                 
                              
                              〉
                           
                         is the mesh triangle on model surface. 
                           P
                         is the newly added vertex during the parallel multi-scale surface mesh refinement. The goal of parallel surface mesh optimization is to identify the corresponding position 
                           
                              
                                 P
                              
                              
                                 ′
                              
                           
                         on model boundary. To preserve the boundary geometry feature well, when triangle 
                           
                              〈
                              
                                 
                                    P
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    P
                                 
                                 
                                    2
                                 
                              
                              ,
                              
                                 
                                    P
                                 
                                 
                                    3
                                 
                              
                              〉
                           
                         moves in the direction of vector 
                           
                              
                                 P
                                 
                                    
                                       P
                                    
                                    
                                       ′
                                    
                                 
                              
                              →
                           
                        , it should tangent to the boundary on 
                           
                              
                                 P
                              
                              
                                 ′
                              
                           
                        .

As previously mentioned, our method takes the CAD model which uses the boundary representation scheme as input and maintains the model information (including surface, curve, point and corresponding parameters) during the parallel 3D Delaunay triangulation process. Therefore, we can access the solid model information dynamically to calculate the corresponding position 
                           
                              
                                 P
                              
                              
                                 ′
                              
                           
                        . For example, for the spline surface, we can access the control points 
                           
                              
                                 P
                              
                              
                                 i
                                 ,
                                 j
                              
                           
                         and knots 
                           U
                           =
                           
                              [
                              
                                 
                                    u
                                 
                                 
                                    0
                                 
                              
                              …
                              
                                 
                                    u
                                 
                                 
                                    m
                                    +
                                    p
                                 
                              
                              ]
                           
                        , 
                           V
                           =
                           
                              [
                              
                                 
                                    v
                                 
                                 
                                    0
                                 
                              
                              …
                              
                                 
                                    v
                                 
                                 
                                    n
                                    +
                                    q
                                 
                              
                              ]
                           
                         as shown in Eq. (1). 
                           
                              (1)
                              
                                 P
                                 
                                    (
                                    u
                                    ,
                                    v
                                    )
                                 
                                 =
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       =
                                       0
                                    
                                    
                                       m
                                    
                                 
                                 
                                    
                                       ∑
                                    
                                    
                                       j
                                       =
                                       0
                                    
                                    
                                       n
                                    
                                 
                                 
                                    
                                       P
                                    
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 
                                    
                                       N
                                    
                                    
                                       i
                                       ,
                                       p
                                    
                                 
                                 
                                    (
                                    u
                                    )
                                 
                                 
                                    
                                       N
                                    
                                    
                                       j
                                       ,
                                       q
                                    
                                 
                                 
                                    (
                                    v
                                    )
                                 
                                 .
                              
                           
                        
                     

We can then obtain the corresponding position 
                           
                              
                                 P
                              
                              
                                 ′
                              
                           
                         by computing the intersection of the model boundary and the normal vector of triangle 
                           
                              〈
                              
                                 
                                    P
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    P
                                 
                                 
                                    2
                                 
                              
                              ,
                              
                                 
                                    P
                                 
                                 
                                    3
                                 
                              
                              〉
                           
                         on 
                           P
                        , as shown in Fig. 9
                        . 
                           
                              
                                 P
                              
                              
                                 0
                                 ,
                                 0
                              
                           
                        , 
                           
                              
                                 P
                              
                              
                                 1
                                 ,
                                 0
                              
                           
                        , 
                           
                              
                                 P
                              
                              
                                 2
                                 ,
                                 0
                              
                           
                         are the control points, and the red line is the normal vector.

The result of the surface mesh optimization of a sphere surface is shown in Fig. 10
                        . More results are shown in Figs. 11 and 12
                        
                        . To measure how well the model boundary is preserved, we adopt the mean symmetric approximation error  [20]. Fig. 13
                         shows the quality of the approximation of the boundary of different models for increasing vertices during the parallel surface mesh refinement and optimization. We plot the mean symmetric (
                           L
                           2
                        ) distance in percentage of the bounding box. As we can see from Fig. 13, during the parallel surface mesh refinement and optimization processes, the meshing results can approach to the model boundary with increasing meshing scale, which is the most significant advantage compared to other parallel 3D Delaunay algorithms.

Surface mesh optimization is performed simultaneously for every PE in all corresponding domains. The position calculations of newly added vertices are independent from each other. Thus, it is highly parallelizable in implementation.

Parallel multi-scale surface mesh refinement and parallel surface mesh quality optimization can be executed for numerous iterations to meet the required mesh density and quality criteria. The refinement process may cause load unbalancing as each domain may generate different number of vertices and elements. We adopt a minimum load movement algorithm used by ParMetis  [21] to change the partitioned interfaces dynamically to maintain load balancing. The minimum load movement algorithm repeatedly migrates vertices from domains with larger loads to those with smaller loads until balance is achieved among all domains. The result is shown in Fig. 14
                        , and the statistics are shown in Table 2
                        . The load balance ratio ranges from 0.77 to 1.3 before load movement, which is unsuitable for parallel computing. However, after minimum load movement, the ratio is improved to the range of 0.99–1.01, thus achieving dynamic load balancing.

After parallel surface mesh refinement and optimization, the model boundary is preserved, and the surface mesh density and quality meet certain criteria. Thus, we can simultaneously generate the 3D Delaunay triangulation on each PE. We then can combine the results for every PE to construct a complete tetrahedral mesh of the whole model, if necessary.

For the vertices on the shared partitioned interfaces, the 3D Delaunay triangulation is performed simultaneously on each domain by each PE. The generated tetrahedral elements satisfy the Delaunay property in the local domain but may not be Delaunay elements in view of neighboring domains. As shown in Fig. 15
                        , the tetrahedral element 
                           
                              〈
                              
                                 
                                    P
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    P
                                 
                                 
                                    2
                                 
                              
                              ,
                              
                                 
                                    P
                                 
                                 
                                    3
                                 
                              
                              ,
                              
                                 
                                    P
                                 
                                 
                                    4
                                 
                              
                              〉
                           
                         is not Delaunay because the circumsphere contains 
                           
                              
                                 P
                              
                              
                                 5
                              
                           
                         in neighboring domain.

For the vertices on the model boundary surfaces, the positions have been moved during parallel surface mesh optimization to capture the geometry features. Thus, some tetrahedral elements may no longer be Delaunay. As shown in Fig. 16
                        , 
                           
                              
                                 P
                              
                              
                                 2
                              
                           
                         is moved to the model boundary. Thus, the tetrahedral element 
                           
                              〈
                              
                                 
                                    P
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    P
                                 
                                 
                                    2
                                 
                              
                              ,
                              
                                 
                                    P
                                 
                                 
                                    3
                                 
                              
                              ,
                              
                                 
                                    P
                                 
                                 
                                    4
                                 
                              
                              〉
                           
                         becomes non-Delaunay because the circumsphere includes 
                           
                              
                                 P
                              
                              
                                 5
                              
                           
                        .

To remove these non-Delaunay elements, some edge flapping methods can be adopted in 2D. However, such face flapping methods are unsuitable for 3D and may cause local cycling flapping or the spread of non-Delaunay elements.

We adopt the local mesh reconstruction method to remove these non-Delaunay elements. First, we find all non-Delaunay elements and remove them, thus generating an empty hull. Second, a vertex insertion algorithm is applied to reconstruct 3D Delaunay elements. To prevent the non-Delaunay region from expanding, we must identify the minimum reconstruction region, which is very important in this process.

Chen  [22] has proposed a local Delaunay triangulation algorithm in 2D. We extend this algorithm to 3D in order to identify the possible Delaunay neighbors. We first propose the 3D local Delaunay lemma and its proof. 
                           3D Local Delaunay Lemma 1
                           
                              Let 
                              
                                 X
                               
                              be a set of points in the space. If subset 
                              
                                 P
                                 =
                                 
                                    {
                                    
                                       
                                          P
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          P
                                       
                                       
                                          2
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       
                                          P
                                       
                                       
                                          n
                                       
                                    
                                    }
                                 
                                 ∈
                                 X
                               
                              forms a simple polyhedron containing point 
                              
                                 c
                                 ∈
                                 X
                              
                              , then the Delaunay neighbors of point 
                              
                                 c
                               
                              are contained in the union of the circumspheres of the 
                              
                                 n
                               
                              tetrahedra formed by point 
                              
                                 c
                               
                              and every triangle face of polyhedron 
                              
                                 P
                              
                              , as shown in   
                                 Fig.  17
                              
                              (a).
                           


                        
                           Proof of 3D Local Delaunay Lemma
                           As shown in Fig. 17(b), a circumsphere of tetrahedron is formed by point 
                                 c
                               and triangle face 
                                 
                                    〈
                                    
                                       
                                          P
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          P
                                       
                                       
                                          2
                                       
                                    
                                    ,
                                    
                                       
                                          P
                                       
                                       
                                          3
                                       
                                    
                                    〉
                                 
                              . Assume point 
                                 v
                               is not in the circumsphere but a Delaunay neighbor of point 
                                 c
                              . According to Delaunay property, there exists a circumsphere which goes point 
                                 c
                               and 
                                 v
                              , but does not contain points 
                                 
                                    
                                       P
                                    
                                    
                                       1
                                    
                                 
                              , 
                                 
                                    
                                       P
                                    
                                    
                                       2
                                    
                                 
                               and 
                                 
                                    
                                       P
                                    
                                    
                                       3
                                    
                                 
                              . For any point 
                                 
                                    
                                       v
                                    
                                    
                                       1
                                    
                                 
                               on this circumsphere which is coplanar with points 
                                 c
                              , 
                                 v
                               and 
                                 
                                    
                                       P
                                    
                                    
                                       1
                                    
                                 
                              , we have 
                                 ∠
                                 c
                                 
                                    
                                       v
                                    
                                    
                                       1
                                    
                                 
                                 v
                                 ≥
                                 ∠
                                 c
                                 
                                    
                                       P
                                    
                                    
                                       1
                                    
                                 
                                 v
                              . For any point 
                                 
                                    
                                       v
                                    
                                    
                                       2
                                    
                                 
                               on this circumsphere which is coplanar with points 
                                 c
                              , 
                                 v
                               and 
                                 
                                    
                                       P
                                    
                                    
                                       2
                                    
                                 
                              , we have 
                                 ∠
                                 c
                                 
                                    
                                       v
                                    
                                    
                                       2
                                    
                                 
                                 v
                                 ≥
                                 ∠
                                 c
                                 
                                    
                                       P
                                    
                                    
                                       2
                                    
                                 
                                 v
                              , then we have 
                                 ∠
                                 c
                                 
                                    
                                       v
                                    
                                    
                                       1
                                    
                                 
                                 v
                                 +
                                 ∠
                                 c
                                 
                                    
                                       v
                                    
                                    
                                       2
                                    
                                 
                                 v
                                 ≥
                                 ∠
                                 c
                                 
                                    
                                       P
                                    
                                    
                                       1
                                    
                                 
                                 v
                                 +
                                 ∠
                                 c
                                 
                                    
                                       P
                                    
                                    
                                       2
                                    
                                 
                                 v
                              .

As 
                                 v
                               is not in the circumsphere of tetrahedron formed by point 
                                 c
                               and triangle face 
                                 
                                    〈
                                    
                                       
                                          P
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          P
                                       
                                       
                                          2
                                       
                                    
                                    ,
                                    
                                       
                                          P
                                       
                                       
                                          3
                                       
                                    
                                    〉
                                 
                              , we have 
                                 ∠
                                 c
                                 
                                    
                                       P
                                    
                                    
                                       1
                                    
                                 
                                 v
                                 +
                                 ∠
                                 c
                                 
                                    
                                       P
                                    
                                    
                                       2
                                    
                                 
                                 v
                                 >
                                 π
                              , so 
                                 ∠
                                 c
                                 
                                    
                                       v
                                    
                                    
                                       1
                                    
                                 
                                 v
                                 +
                                 ∠
                                 c
                                 
                                    
                                       v
                                    
                                    
                                       2
                                    
                                 
                                 v
                                 ≥
                                 ∠
                                 c
                                 
                                    
                                       P
                                    
                                    
                                       1
                                    
                                 
                                 v
                                 +
                                 ∠
                                 c
                                 
                                    
                                       P
                                    
                                    
                                       2
                                    
                                 
                                 v
                                 >
                                 π
                              .

At the same time, points 
                                 
                                    
                                       v
                                    
                                    
                                       1
                                    
                                 
                               and 
                                 
                                    
                                       v
                                    
                                    
                                       2
                                    
                                 
                               are on the circumsphere which goes point 
                                 c
                               and 
                                 v
                              , so we have 
                                 ∠
                                 c
                                 
                                    
                                       v
                                    
                                    
                                       1
                                    
                                 
                                 v
                                 +
                                 ∠
                                 c
                                 
                                    
                                       v
                                    
                                    
                                       2
                                    
                                 
                                 v
                                 =
                                 π
                              , which is a contradiction. Thus 
                                 
                                    〈
                                    c
                                    ,
                                    v
                                    〉
                                 
                               cannot be a Delaunay edge.

On the basis of the 3D local Delaunay lemma, we now outline how to identify the minimum reconstruction region as shown in Algorithm 1.


                        
                           
                              
                           
                        
                     

When the minimum reconstruction region is constructed, a vertex insertion algorithm is applied to reconstruct 3D Delaunay elements. The reconstruction results on shared partitioned interfaces are shown in Fig. 18
                        . The whole model is partitioned into two domains. Figs. (a)–(c) are the original empty hull (marked in red), minimum reconstruction region (marked in red) and final tetrahedral mesh of domain 1. Figs. (d)–(f) are same to domain 2. The reconstruction results on model boundaries are shown in Fig. 19
                        . The red area in Fig. (a) is the original empty hull, that in Fig. (b) is the minimum reconstruction region, and Fig. (c) is final tetrahedral mesh. The minimum reconstruction region is the expansion of the empty hull in 3D space, which includes more elements.

The proposed algorithm can work well in the most popular parallel environments. As shown in Fig. 20
                     , the hybrid parallel architecture consists of clusters of PEs with multiple cores for each PE. In our parallel algorithm implementation, a hybrid parallelization is developed. MPI is used for parallel management and message-passing among PEs, whereas OpenMP is used for multi-threading among cores inside each PE.

Coarse mesh vertices and elements are distributed to different domains, and each domain is assigned to a certain PE. To facilitate communication and synchronization among PEs, each domain is marked a unique index number 
                           p
                           _
                           i
                           d
                        . As shown in Fig. 21
                        , the whole mesh is partitioned into three domains 
                           p
                           _
                           1
                        , 
                           p
                           _
                           2
                        , 
                           p
                           _
                           3
                         and assigned to 
                           
                              
                                 
                                    PE
                                 
                              
                              
                                 1
                              
                           
                        , 
                           
                              
                                 
                                    PE
                                 
                              
                              
                                 2
                              
                           
                        , 
                           
                              
                                 
                                    PE
                                 
                              
                              
                                 3
                              
                           
                         correspondingly. As communication is needed during surface mesh optimization and local mesh reconstruction among PEs, we need to create adjacency relation information during domain partitioning. Each domain has a list of adjacent domains 
                           
                              adj
                           
                           _
                           p
                           
                              {
                              
                                 
                                    i
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    i
                                 
                                 
                                    2
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    i
                                 
                                 
                                    n
                                 
                              
                              }
                           
                        .

The mesh vertices and elements around the partitioned interfaces are shared by domains. Thus, the data is copied to different PEs. To maintain the synchronization of mesh data and operation, these shared vertices and elements should have a global index of the whole mesh and a local index of the partitioned mesh. For each vertex and element, the global_id and local_id are equal in the coarse mesh before parallelization. After distributed to different domains, the global_id remains the same, whereas the local_id is adjusted accordingly. During parallel surface mesh refinement, new vertices and elements are generated. For newly inserted vertices and elements, the local_id increases, and the global_id can be obtained by synchronization of neighboring domains.

During the parallel surface mesh optimization phase, each surface mesh vertex is moved to the model boundary simultaneously in different PEs. For the vertices on the shared partitioned interfaces, asynchronization of shared vertex movement may cause inconsistency. As shown in Fig. 22
                        , vertex 
                           P
                         is on the partitioned interfaces shared by two domains: the blue and green areas. The PE in charge of the green domain moves 
                           P
                         to new position 
                           
                              
                                 P
                              
                              
                                 ′
                              
                           
                         during surface mesh optimization to preserve the model boundary, whereas the PE in charge of the blue domain may not move 
                           P
                        , thus resulting in inconsistency.

To maintain consistency on the shared partitioned interfaces, we develop a high-efficiency parallel strategy to synchronize the surface mesh optimization, as shown in Algorithm 2.


                        
                           
                              
                           
                        
                     

As mentioned previously, 3D local Delaunay mesh reconstruction is performed to repair non-Delaunay elements on model boundaries and shared partitioned interfaces. For the vertices around the model boundaries, reconstruction is performed in each PE simultaneously and independently, so no communication is required. For the vertices around the shared partitioned interfaces, the generated minimum reconstruction regions may intersect among neighboring domains, which may cause inconsistency. To achieve global consistency, we develop a high-efficiency parallel strategy to synchronize the local mesh reconstruction, as shown in Algorithm 3.


                        
                           
                              
                           
                        
                     

We evaluated the performance of our algorithm in a hybrid parallel environments, as shown in Table 3
                     .

We conduct experiments to compare the parallel efficiency and scalability of our parallel algorithm based on different mesh scales and different numbers of PEs, as shown in Table 4
                         and Fig. 23
                        . Our parallel algorithm can achieve good parallel efficiency for different model sizes ranging from 102,246 vertices to 22,717,704 vertices. For the small bridge model, the speedup ranges from 3.8 to 165.2 as the number of PEs ranges from 4 to 256. For the large Triumphal Arch model, the speedup ranges from 3.8 to 197.2 as the number of PEs ranges from 4 to 256. We also test an extremely large model with 181,741,632 vertices. The final mesh has more than 500 million elements, and 201.5 times speedup is achieved for 256 PEs.

We also compare the load balancing and speedup between our parallel algorithm and previous parallel algorithms including DeWall  [9] and DCVM  [10], as shown in Table 5
                        . The DeWall algorithm uses orthogonal planes to partition the input vertices, so it is hard to achieve load balancing. The load balance ratio ranges from 0.42 to 1.71 using 4 PEs and ranges from 0.62 to 1.53 using 128 PEs, which significantly limits the parallel efficiency. The DCVM algorithm uses a more elegant schema to partition the original tetrahedral mesh. However, the pre-processing costs too much time to generate initial samplings to match model boundary. DCVM only uses static load balancing. The load becomes unbalanced during the mesh refinement process, thus leading to a low speedup. The speedup is only 2.3 on 4 PEs and 82.5 on 128 PEs. By contrast, in our algorithm, the pre-processing time of preparing initial mesh for large-scale parallel meshing is much faster than previous algorithms as we only need very coarse sampling. Also we keep dynamic load balancing through minimum load movement during parallel computing. Thus, the parallel efficiency is better than previous algorithms.

We also record the percentage of time during different parallel phases, as shown in Table 6
                        . Most of time is costed in parallel mesh generation and local mesh reconstruction phases.

From statistics in Tables 4 and 5, we can conclude that our parallel 3D Delaunay meshing algorithm can achieve high parallel efficiency and perfect scalability on different mesh scales with different PE numbers.

In this paper, we use radius–edge ratios and dihedral angles to measure the quality of generated mesh. The former measures the ratio between the circumsphere radius and the shortest edge length, whereas the latter measures the angles between two triangle faces in a tetrahedron.

We conduct experiments to compare the quality of 3D Delaunay mesh generated by our parallel 3D Delaunay triangulation algorithm and by different sequential triangulation algorithms including TetGen and CGAL. As shown in Fig. 24
                        , for models with different mesh scales, from simple bridge model with hundreds thousands vertices to the Triumphal Arch model with tens of millions of vertices, 90% of the radius–edge ratios fall in the range 0.4–1.0, whereas 97% of dihedral angles fall in the range 40°–100° for all the three methods. The statistics of Fig. 24 show that almost similar quality can be obtained for the three different methods. We also compare the average radius–edge ratios and dihedral angles numerically in Table 7
                        . This demonstrates that our method does not decrease the 3D Delaunay mesh quality during the parallel refinement and model boundary preserving process. However, our method can generate much larger mesh than the other two sequential triangulation software due to the memory limitation on single machine.

We conduct experiments to measure surface approximation of mesh generated in our method and also compare it with previous parallel algorithms including DeWall  [9] and DCVM  [10], as shown in Fig. 25
                        . For previous parallel algorithms, initial input boundary vertices are only the approximation of 3D models. Mesh refinement and optimization is useless to improve mesh precision with the increase of mesh scale. However, in our method, the mean symmetric approximation error for the bridge model with 102,246 vertices drops to 0.11% after multiple parallel refinements and surface mesh optimization. The approximation error for Triumphal Arch model with 22,717,704 vertices drops to 0.03%. This demonstrates that our method can generate meshes which are very approaching to the model boundary with the increase of mesh scale.

@&#CONCLUSIONS@&#

We propose a solid model boundary preserving method for large-scale parallel 3D Delaunay meshing. The most significant advantage is that the 3D boundary representation model information is kept during the entire parallel 3D Delaunay triangulation process. Based on this information, a parallel multi-scale surface mesh refinement is iteratively performed to meet the mesh density and quality criteria followed by a parallel surface mesh optimization to fit model geometry feature dynamically. Another advantage is that we propose a parallel 3D local mesh reconstruction algorithm to repair the non-Delaunay mesh. The algorithm is highly parallelized. Experimental results demonstrate high performance and perfect scalability. We plan to extend the algorithm to GPU clusters parallel environments to further improve the performance of Delaunay triangulation. We also know it is meaningful to extend the usability of our algorithm on general models such as 3D point cloud data generated by 3D laser. So our future research topics include CAD model boundary representation reconstruction based on surface triangle mesh from 3D scanner or 3D model boundary recovery only based on surface triangle mesh during parallel meshing. At that time, a more elegant partitioning scheme may be preferred such as semantic based partitioning scheme.

@&#ACKNOWLEDGMENTS@&#

The authors thank all the anonymous reviewers for their valuable comments and suggestions. This work is supported by National Science Foundation of China (61272225, 91315302, 60773143, 51261120376), Chinese 863 Program (2012AA041606) and Chinese 973 Program (2010CB328001).

@&#REFERENCES@&#

