@&#MAIN-TITLE@&#Clustering high throughput biological data with B-MST, a minimum spanning tree based heuristic

@&#HIGHLIGHTS@&#


               
                  
                  
                     
                        
                           
                           A novel minimum spanning tree based heuristic (B-MST) for clustering is introduced.


                        
                        
                           
                           The heuristic has multi-objective of obtaining both tight and separate clusters.


                        
                        
                           
                           The objective function of the heuristic can be used as an internal validation index.


                        
                        
                           
                           It is applied on 13 different data sets and compared with diverse algorithms.


                        
                        
                           
                           B-MST performs better than the compared algorithms on most of the data sets.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Clustering

Gene expression data

Heuristics

Biological networks

Graph mining

@&#ABSTRACT@&#


               
               
                  To address important challenges in bioinformatics, high throughput data technologies are needed to interpret biological data efficiently and reliably. Clustering is widely used as a first step to interpreting high dimensional biological data, such as the gene expression data measured by microarrays. A good clustering algorithm should be efficient, reliable, and effective, as demonstrated by its capability of determining biologically relevant clusters. This paper proposes a new minimum spanning tree based heuristic B-MST, that is guided by an innovative objective function: the tightness and separation index (TSI). The TSI presented here obtains biologically meaningful clusters, making use of co-expression network topology, and this paper develops a local search procedure to minimize the TSI value. The proposed B-MST is tested by comparing results to: (1) adjusted rand index (ARI), for microarray data sets with known object classes, and (2) gene ontology (GO) annotations for data sets without documented object classes.
               
            

@&#INTRODUCTION@&#

High throughput data technologies such as microarrays, devices measuring the abundance of thousands of RNAs simultaneously, generate a huge quantity of biological data, especially gene expression data. The information generated may be represented by networks. For example, gene expression data may be regarded as a complete network where the genes are its nodes, the edges represent the relations between genes, and the pairwise correlation values obtained from the expression data determine the strength of the relation between the gene pairs. The algorithms for clustering gene expression data are usually grouped as partitional or hierarchical, but they may also be grouped based on the representation of data, the relationship between clusters, the distribution of the data, or using other properties. Pirim et al. [1] present a recent survey of clustering algorithms that interpret gene expression data.

Clustering network data can be considered as a graph partitioning problem, that has many variations such as clique partition and K-way equipartition, which minimizes the weight of each sets’ edges by partitioning the vertices of a graph into k sets of equal size [2]. Since the graph partitioning problem is NP-hard [3], efficient heuristics to find meaningful solutions are required similar to one described by Kernighan and Lin [4] that interchanges subsets of partitions to minimize external cost.

A minimum spanning tree (MST) of a graph includes all of its vertices. Using network׳s MSTs to cluster biological data is practical since edge removal divides one group of genes directly into two groups. In other words, removing 
                        n
                        −
                        1
                      edges from a tree divides the nodes into n different groups. Xu et al. [5] demonstrate that no essential information is lost for clustering purposes with an MST representation. Moreover, the representation may overcome the computational burden of graph based calculations and the dependency difficulties associated with the geometrical shapes of the clusters [5].

Xu et al. [5] introduce novel algorithms for MST based clustering. One algorithm clusters by removing long tree edges, and the total edge-distance of all K sub-trees is minimized. This algorithm works as long as the inter-cluster edge distances are clearly larger than intra-cluster edge-distances. K, the number of clusters is increased till the objective function value changes dramatically and the last K value determines the number of clusters. The second algorithm is an iterative clustering algorithm minimizing the total distance between data points and the cluster center. The calculation begins with an arbitrary K partition. Then, each pair of adjacent clusters is merged; the algorithm cuts the edge that minimizes the objective function value. It converges to the local minimum. Finally, the third algorithm determines the globally optimal solution by grouping various data points around representative data points.

Determining which edges to remove and developing a quality measure or objective function to evaluate the clusters are the two most important considerations in developing an MST based heuristic. Having both tight and separated clusters at the same time is desirable since those types of clusters are more likely to have interdependent relationships. However, clustering objectives usually seek to maximize either the similarities within clusters – tightness – or the distances between them – separateness [6–8].

This paper proposes a new objective function that seeks to obtain tight and separated clusters at the same time. The function assumes that a binary graph of clusters will feature edges formed between two genes when the relationship between them is strong. The idea is that clusters׳ diameters will be minimized, and an object of a cluster will have as few connections with the other clusters as possible. To achieve the tight and separated clusters described here, the MST׳s most central or between edges are iteratively removed. An edge׳s betweenness is determined by the number of times a given edge appears on the shortest path between any node pairs. The betweenness calculation of the edges described by Newman and Girvan [9] is adopted in the heuristic presented here.

The work flow begins with Pearson correlation calculations that analyze gene expression data sets. Correlation values become edge weights that construct the gene co-expression network. The weighted network is transformed to a binary network with a threshold that retains the strongest edges; at the same time, the network remains connected as one percent of the edges is removed at each iteration. In addition to correlation calculations, expression data are used to calculate six different distances: Eucledian, Chebyshev, Manhattan, Canberra, Minkovski, and 1-Pearson correlation. K-means, PAM and B-MST use these distance measures and the given number of clusters to generate partitions, which are then used to calculate ARI values. TSI values, also used as the objective function of B-MST, are calculated using the partitions obtained from B-MST, K-means, PAM, and CSF and the edge distances over the binary network. The work flow is shown in Fig. 1
                     , and an example is provided in the Methods section.

@&#METHODS@&#

The B-MST approach for clustering microarray data sets works well in interpreting high dimensional data sets because removing the most between edge from the MST of the gene expression network results in biologically relevant clusters. The TSI objective function is used to improve the initial solution because of the biological network׳s features including the expectation that genes on the same pathway will be expressed simultaneously or sequentially upon receiving stimuli [10]. Hence, the shortest paths determine the distance calculations. The objective function seeks to minimize the maximum cluster diameter among all clusters, and B-MST aims to minimize the maximum number of connections of a single gene in one cluster to genes in other clusters. The idea is to achieve tightness and separation at the same time, as is often desired [11], and retain the hub genes in tight clusters, as demonstrated in the study by Barabási abd Oltvai [12]. Tightness is achieved by minimizing the maximum diameter, while separation is achieved by minimizing the maximum out-connection of genes. Fig. 2
                      illustrates the change between two partitions: the maximum diameter and the out-connection values. The first partition in the two clusters results in D
                     
                        max
                      and k
                     
                        max
                     
                     
                        out
                      values of (1,1); these values represent the shortest path distance between any pairs of the nodes in any of the two clusters and gene four. However, the second partition in the two clusters results in D
                     
                        max
                      and k
                     
                        max
                     
                     
                        out
                      values of (2,2), which reflects the shortest path distance between gene five (or gene six) and gene one. The objective function value becomes less reliable as it increases from two to four.

The B-MST heuristic has two phases. First, an initial solution is generated by finding an MST of the expression data and the corresponding TSI value is calculated. Second, a local search mechanism is introduced to improve the TSI value. The algorithm is implemented in R, and the igraph library [13] is used for applying Prim׳s algorithm to generate MSTs and perform other graph operations.


                        Fig. 3
                        (a)–(d) summarizes how the initial solution is generated using B-MST. The representative complete expression graph, panel (a) has six nodes and fifteen edges. The six-by-six expression of the data set was generated using six different normal distributions, and ten samples were developed from each distribution. The dashed edges represent the MST of the graph. Then, panel (b) graphically the MST of the graph presented in 3(a), and the dashed edges reflect the highest betweenness scores. Panel (c) shows the partition between two clusters; the corresponding partition vector is also shown below the clusters. Panel (d) is the binary network transformed from panel (a) with a 34 percent threshold. Although MSTs have been used to cluster biological data [5] and the betweenness approach has been applied to the graph partition approach [9], this paper is the first, to the best of the authors knowledge, to demonstrate that the betweenness approach can be applied to an MST clustering biological data.

The initial MST is generated using distance values between gene pairs as edge weights of the co-expression network. Then 
                           n
                           −
                           1
                         edges are removed from the MST to obtain n clusters. Betweenness values of the edges are used to decide which edges to remove and the edge with the highest betweenness value is removed. Then, all the betweenness values are recalculated to remove the next edge with the highest betweenness value. The smallest indexed edge is removed when there is more than one highest betweenness score. Edge removal continues until the desired number of clusters is obtained. In Fig. 3 example, the number of clusters is two. Euclidean distance measure is used to form the MST. Edge (1,3) has the smallest index.

The gene expression network is transformed to a binary graph using a threshold as explained above in the Introduction. In Fig. 3 example, this threshold is 34 percent below which the binary graph is not connected. In other words, the strongest five edges (34%⁎15) are retained and the removal of one more edge disconnects the graph. The edge weights are determined by the Pearson correlation values between gene pairs. The higher the correlation value, the stronger the edge must be. Then, this binary graph is employed for the TSI value calculation.

The TSI considers both the tightness and the separation of the clusters. Tightness is determined by minimizing the maximum diameter of the diameters among all the clusters, which is the maximum value of the shortest path distances between gene pairs. Separation is obtained by minimizing the maximum number of connections of a gene inside one cluster with other clusters. The TSI value calculation is performed on the binary graph, and the shortest paths between nodes are used as distance values between gene pairs. This method is based on the transitive gene expression approach assuming that functions are often the result of many genes interacting with each other, not the outcome of a simple pairwise relation [14].

Transitive expression implies that at least one path exists between two genes, though not necessarily like a pairwise relation of length one as assumed in a binary graph. The length of the path in the transitive expression has the shortest path distance between the genes. Researchers including [15,14] propose that more biologically meaningful results than a direct pairwise distance measure are determined by using a transitive co-expression analysis that applies the shortest path distance between two genes as shown in Fig. 4
                        . The TSI is formulated as follows:
                           
                              (1)
                              
                                 
                                    
                                       D
                                    
                                    
                                       max
                                    
                                 
                                 +
                                 
                                    
                                       k
                                    
                                    
                                       max
                                    
                                    
                                       out
                                    
                                 
                              
                           
                        
                        
                           
                              
                                 D
                              
                              
                                 max
                              
                           
                           =
                           
                              
                                 max
                              
                              
                                 s
                                 ∈
                                 S
                              
                           
                           {
                           
                              
                                 D
                              
                              
                                 s
                              
                           
                           }
                        , 
                           S
                           =
                           {
                           1
                           ,
                           2
                           ,
                           …
                           ,
                           c
                           }
                         where c is the number of clusters. 
                           
                              
                                 D
                              
                              
                                 s
                              
                           
                           =
                           
                              
                                 max
                              
                              
                                 i
                                 ,
                                 j
                                 ∈
                                 N
                                 ,
                                 i
                                 ≠
                                 j
                              
                           
                           {
                           
                              
                                 d
                              
                              
                                 ij
                              
                           
                           }
                        , 
                           N
                           =
                           {
                           1
                           ,
                           2
                           ,
                           …
                           ,
                           n
                           }
                         where n is the number of genes, d
                        
                           ij
                         is the shortest path distance between gene i and gene 
                           j
                           .
                           
                              
                                 k
                              
                              
                                 max
                              
                              
                                 out
                              
                           
                           =
                           
                              
                                 max
                              
                              
                                 i
                                 ∈
                                 N
                              
                           
                           {
                           
                              
                                 ∑
                              
                              
                                 j
                                 =
                                 1
                                 ,
                                 j
                                 ≠
                                 i
                              
                              
                                 n
                              
                           
                           
                              
                                 a
                              
                              
                                 ij
                              
                           
                           −
                           
                              
                                 ∑
                              
                              
                                 j
                                 =
                                 1
                                 ,
                                 j
                                 ≠
                                 i
                              
                              
                                 n
                              
                           
                           
                              
                                 a
                              
                              
                                 ij
                              
                           
                           
                              
                                 x
                              
                              
                                 ij
                              
                           
                           }
                        , where a
                        
                           ij
                         is one if genes i and j are connected, zero otherwise and x
                        
                           ij
                         is one if 
                           i
                           ,
                           j
                         are in the same cluster, zero otherwise.

For example, the TSI value for the partition in Fig. 3(c) is six where D
                        
                           max
                         is four and k
                        max
                        
                           out
                         is two. The B-MST heuristic, presented here seeks to minimize the TSI value.

A local search should improve the objective function value based on a neighborhood definition. Here, the neighborhood refers to a partition 
                           
                              
                                 P
                              
                              
                                 ′
                              
                           
                         which neighbors a partition P if a gene in P is transferred from its current cluster to another connected cluster. Starting from the first gene of the candidate genes list, or Clist, which includes the genes with at least one connection to the other clusters, a gene is transferred to the cluster with which it has the most connections. This cluster becomes the first in the transfer list, or Tlist(i) that includes the clusters to which gene i has at least one connection. This list is sorted in descending order of the number of connections that gene i has with other clusters. After the transfer a new objective function value is calculated, and if the new value is smaller than the initial objective function value, the partition, the objective value, and the Tlist(i) are all updated. This procedure is repeated until there is no improvement and n number of steps have been executed after an improvement, where n is the number of genes. The local search procedure is shown in Fig. 5
                        . In Fig. 3 example, the second and the fourth objects are transferred to the first cluster, and the TSI value changes from six to four.

If transferring the nodes to the clusters with which they have the most connections will improve the objective function value, they will be transferred following the local search. For example, membership changes when the local search is applied to the partition in Fig. 3.

The B-MST heuristic presented here takes 
                           O
                           (
                           
                              
                                 cn
                              
                              
                                 2
                              
                           
                           )
                        ) time to find the initial solution where c denotes the number of clusters. Betweenness calculations take 
                           O
                           (
                           
                              
                                 n
                              
                              
                                 2
                              
                           
                           )
                         to determine, and they are repeated 
                           c
                           −
                           1
                         times. Local search takes 
                           O
                           (
                           cn
                           (
                           m
                           +
                           n
                           )
                           )
                         time to find the best neighboring solution for a given solution, where m is the number of edges in the binary graph.

The performance of the B-MST method is compared to calculations using K-means, PAM, and CSF. K-means is implemented in the R base package, PAM is implemented in the R cluster package, and CSF algorithm developed by [16] is implemented in the R igraph 0.5.5 package. K-means and PAM are used here to test B-MST because they are widely used and quickly cluster high dimensional data. The CSF is a recent, fast, and well cited method. CSF uses graph topology and optimizes the modularity measure, a quantification of a community, or cluster structure. K-means has a time complexity of 
                           O
                           (
                           t
                           
                           c
                           
                           n
                           
                           p
                           )
                         
                        [17] where t, c, n, and p denote the number of iterations, clusters, objects, and attributes respectively. PAM takes 
                           O
                           (
                           (
                           1
                           +
                           r
                           )
                           c
                           
                              
                                 (
                                 n
                                 −
                                 c
                                 )
                              
                              
                                 2
                              
                           
                           )
                         where r is the number of replacements. CSF is completed in 
                           O
                           (
                           
                              
                                 n
                              
                              
                                 3
                              
                           
                           )
                        .

ARI is an external measure that relies on a real partition, whereas TSI is an internal measure. In other words, ARI requires a real partition for which the class information usually does not exist. In this study, most of the data sets real partitions are known. Once the information about the real partition is collected, the ARI for a clustering algorithm should be high indicating that it determines a partition close to the real one. On the other hand, TSI can be used to cluster data sets where information about the real partition (i.e. gene clustering) is unknown, and the TSI values correlate directly to the ARI values. Hence, we used ARI values for validation of the results using data sets with known class information and biological inference for validation of the results using data sets without class information.

Eleven data sets are used for external validation and two data sets are used for biological validation. The features of all 13 data sets are summarized in Table 1
                        .

The microarray measures the abundance of RNAs, or the simultaneous expression of thousands of genes. For example, the BreastA and BreastB cancer diagnosis microarray data sets have 98 and 49 tissues, or samples respectively, and each have 1213 attributes. The BreastA data set is generated using two-channel oligonucleotide microarrays and the BreastB set is generated using one-channel microarray technology. The diffuse large B-cell lymphoma A, or DLBCLA, is a diffuse large B-cell lymphoma data set having 141 samples with 661 attributes. Tumor specimens and retrospective clinical data from 176 DLBCL patients are analyzed and 80 percent of the samples, or a subsampling approach including 141 of the 176 tumors are randomly chosen and applied. More details about this data set are presented in [18]. Novartis denotes the MultiA gene expression data set with 103 samples and 5565 genes; the values are normalized and the number of genes reduced to 1000. The data sets BreastA, BreastB, DLBCLA, DLBCLB and MultiA are pre-processed by Hoshida et al. [19]. The data sets discussed here are described and addressed in [20]. The ALB, Leukemia, Brain, cGCM, and LungA cancer data sets are obtained online at http://www.broadinstitute.org/cgi-bin/cancer/datasets.cgi The Yeast1 data set is the yeast cell cycle data described in [21], while the CNS rat data set and the Yeast2 yeast sporulation data set are addressed in [22]. The Yeast3 data set includes the yeast cell cycle data presented in [23]. Clustering samples, not genes, is a useful approach to find subtypes of a disease, according to Tseng and Wong [24].

@&#RESULTS AND DISCUSSION@&#

All the data sets, barring Yeast2 and Yeast3 can be externally validated by the ARI [25]. The external validation index is defined for two partitions – P
                        1 and P
                        2, which are denoted as C-
                           rand
                           (
                           
                              
                                 P
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 P
                              
                              
                                 2
                              
                           
                           )
                        . The ARI is one of the most widely used indices for comparing a real partition to a partition generated by a clustering algorithm. The index is formulated as follows:
                           
                              (2)
                              
                                 C
                                 −
                                 rand
                                 (
                                 
                                    
                                       P
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 
                                    
                                       P
                                    
                                    
                                       2
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             i
                                             ,
                                             j
                                          
                                       
                                       (
                                       
                                          
                                             
                                                
                                                   
                                                      n
                                                   
                                                   
                                                      i
                                                      ,
                                                      j
                                                   
                                                
                                             
                                             
                                                2
                                             
                                          
                                       
                                       )
                                       −
                                       [
                                       
                                          
                                             ∑
                                          
                                          
                                             i
                                          
                                       
                                       (
                                       
                                          
                                             
                                                
                                                   
                                                      n
                                                   
                                                   
                                                      i
                                                      .
                                                   
                                                
                                             
                                             
                                                2
                                             
                                          
                                       
                                       )
                                       
                                          
                                             ∑
                                          
                                          
                                             j
                                          
                                       
                                       (
                                       
                                          
                                             
                                                
                                                   
                                                      n
                                                   
                                                   
                                                      .
                                                      j
                                                   
                                                
                                             
                                             
                                                2
                                             
                                          
                                       
                                       )
                                       ]
                                       /
                                       (
                                       
                                          
                                             
                                                n
                                             
                                             
                                                2
                                             
                                          
                                       
                                       )
                                    
                                    
                                       1
                                       /
                                       2
                                       [
                                       
                                          
                                             ∑
                                          
                                          
                                             i
                                          
                                       
                                       (
                                       
                                          
                                             
                                                
                                                   
                                                      n
                                                   
                                                   
                                                      i
                                                      .
                                                   
                                                
                                             
                                             
                                                2
                                             
                                          
                                       
                                       )
                                       +
                                       
                                          
                                             ∑
                                          
                                          
                                             j
                                          
                                       
                                       (
                                       
                                          
                                             
                                                
                                                   
                                                      n
                                                   
                                                   
                                                      .
                                                      j
                                                   
                                                
                                             
                                             
                                                2
                                             
                                          
                                       
                                       )
                                       ]
                                       −
                                       [
                                       
                                          
                                             ∑
                                          
                                          
                                             i
                                          
                                       
                                       (
                                       
                                          
                                             
                                                
                                                   
                                                      n
                                                   
                                                   
                                                      i
                                                      .
                                                   
                                                
                                             
                                             
                                                2
                                             
                                          
                                       
                                       )
                                       
                                          
                                             ∑
                                          
                                          
                                             j
                                          
                                       
                                       (
                                       
                                          
                                             
                                                
                                                   
                                                      n
                                                   
                                                   
                                                      .
                                                      j
                                                   
                                                
                                             
                                             
                                                2
                                             
                                          
                                       
                                       )
                                       ]
                                       /
                                       (
                                       
                                          
                                             
                                                n
                                             
                                             
                                                2
                                             
                                          
                                       
                                       )
                                    
                                 
                              
                           
                        where 
                           
                              
                                 n
                              
                              
                                 i
                                 ,
                                 j
                              
                           
                         is the number of objects at the intersection of clusters i and j, i is the cluster index for P
                        1, j is the cluster index for P
                        2, and 
                           
                              
                                 n
                              
                              
                                 i
                                 .
                              
                           
                         is the number of objects in cluster i.

Higher ARI values indicate that the partitions generated are closer to the real ones. ARI values can vary between −1 and 1. On the other hand, Yeast2 and Yeast3 data sets enable the possibility of biologically validating the heuristic presented here. Since high ARI values correspond to low TSI values in most comparisons, this study compares the algorithms that offer the best two TSI values. The CSF already determined the best TSI value for the Yeast2 data set, and PAM found the second best TSI value, after B-MST, for the Yeast3 data set. Therefore, the B-MST heuristic׳s performance is compared with CSF using Yeast2. Likewise, results generated with the heuristic proposed here are compared to PAM׳s performance with the Yeast3 data set. All the algorithms are compared based on the significantly clustered genes with the same biological process information as determined by GO terms. A biological inference strategy similar to [22] is applied here, and it results in multiple selectivity values. Then, the highest selectivity values of all the clusters obtained by each algorithm are compared.

As mentioned above, B-MST, K-means, and PAM calculations use distance measures to generate partitions. However, the CSF algorithm is independent of a distance measure. Instead, CSF uses the binary network to generate clusters. For B-MST, if local search does not result in a better ARI value, then the initial solution is kept. The ARI and TSI values are listed in Tables 2–8
                        
                        
                        
                        
                        
                        
                        . Biological inference, employing GO terms, is realized using FatiGO [26]. It employs gene ontology December 2009 release. FatiGO reports the percentage of biological process׳s annotated genes in a cluster and uses the same percentage for the remaining of the data set. These percentage values allow calculations of the selectivity values for all the clusters. Therefore, for a given cluster and biological process, the selectivity is the difference between the percentage of annotated genes in the cluster and the percentage of annotated genes outside this cluster. The highest selectivity values are compared for CSF and PAM. CSF was not eligible for the Yeast3 data set since it finds at most 14 clusters while the number of clusters was determined to be 15.

External validation is conducted by determining the ARI values for the partitions generated by B-MST, K-means, and PAM. The first 11 data sets shown in Table 1 are used for the external validation, and Tables 2–7 present ARI and TSI values for different distance measures. Table 5 is shorter than others because the Canberra distance cannot be calculated for all data sets. The first column lists the names of the data sets, and the second through fourth columns give the ARI values for B-MST, K-means, and PAM, respectively. Likewise, columns five through seven provide the TSI values for B-MST, K-means, and PAM, respectively. The highest ARI and the lowest TSI values for each data set are emphasized in bold.

The tables feature low ARI values for the LungA data set. Monti et al. [27] apply consensus clustering to diverse data sets including LungA. The rand index values for LungA are significantly lower than the other values. Their study reports the reason as lung cancer tissues highly heterogeneous data set features, molecular and clinical profile that is not well documented in the literature.

The data sets listed in the tables, show that B-MST outperforms both K-means and PAM in six out of eleven data sets, based on decision theory׳s dominance rule, which eliminates all dominated choices [28]. These data sets include BreastB, DLBCLA, ALB, cGCM, Yeast1, and CNS. The last two are gene clustering data sets. For example, B-MST finds the best ARI values in the first four data sets, 0.781, 0.577, 0.781, and 0.833 respectively, over four distance measures, Euclidean, Chebyshev, Manhattan, and Minkovski respectively. The worst value, 0.341 is found only once in Pearson for the ALB data set. The remaining data sets are evaluated in a similar manner. K-means and PAM outperformed B-MST in two and four data sets respectively. Table 9
                            summarizes the ranked results. Bold values indicate the data sets in which B-MST offers better results than K-means and PAM.

For the same 11 data sets, ARI and TSI values are calculated using the CSF algorithm. Table 8 shows B-MST׳s highest ARI values, among values generated by using different distance measures, which are compared to the ARI values determined by CSF. B-MST found higher ARI values for all of the data sets except Leukemia.


                           Tables 2–7, show that, in most cases, the maximum ARI values correspond to the minimum TSI values. Table 10
                            summarizes the comparison of ARI values with TSI values. The column titled “Best” has a 1 if the best ARI value is found by B-MST. Hence, this work proposes that the partition with the smaller TSI value has more biologically relevant clusters than those with higher TSI values.

The GO biological process terms of the clusters are investigated using the Yeast2 and Yeast3 data sets. Yeast2 clusters determined by B-MST are compared with those developed from CSF, and Yeast3 clusters suggested by B-MST are compared to the results of PAM. The highest selectivity values in a cluster are compared since this study is examining the reliability of algorithms׳ finding highly selected genes. The number of clusters is determined to be eight for Yeast2 and fifteen for Yeast3. The numbers are decided by visualization of the dendrograms generated by hierarchical clustering (HC) with average linkage such that clusters include enough number of genes visually. The height values of the dendrogram on the y-axis denote the distance values between clusters. Cutting the dendrogram at different levels will result in different number of clusters; one extreme is cutting the dendrogram at the highest level and ending with a cluster that includes all the genes. The other extreme is cutting the dendrogram at the lowest level, which results in each gene׳s cluster having a size of one. HC cut-off levels are 650 for the Yeast2 data set and size for the Yeast3 data set. Clusters with fewer ten genes are not considered.

The number of clusters suggested above is also supported by the Dynamic Tree Cut algorithm [29], which detects the number of clusters based on the shape of a dendrogram. The algorithm has user defined parameters such as the minimum cluster size and the cut point of the tree. These parameters are set to reasonable values of (10, 150.5) for the Yeast2 data set and (10,13) for the Yeast3 set. For the purpose of brevity, the dendrogram for only Yeast3 is shown in Fig. 6
                           . The Euclidean distance measure was used in all algorithms.

However, the GO terms are too general at lower levels and too specific at upper levels to apply to the final results. In other words, the number of GO annotated genes decreases at deeper GO levels, as demonstrated in [26]. Hence, GO levels are set between seven and nine. The highest selectivity values of the clusters are plotted in Figs. 7 and 8
                           
                           . For example, in cluster four of Fig. 7, the highest selectivity value for B-MST is 20.46 while it is 11.66 for the CSF. Zero values in the figures indicate that no significant biological process connects the genes in this cluster. The negative value in Fig. 8 indicates that the percentage of annotated genes in this cluster is smaller than the percentage of the annotated genes in the remaining clusters. In this sense, a negative value is not worse than a zero value, because it indicates a relationship regarding a biological process is present.

The minimum TSI values׳ corresponding to the maximum rand index values in most of the cases suggests that the optimum TSI value for a data set may be used to estimate the number of clusters. For ALB data set, TSI value improves (or stays the same) when the number of clusters is increased incrementally and gets worse after reaching the true number of clusters. Fig. 9
                            shows the change of TSI value as the number of clusters increased from two to ten by one. The minimum TSI value is kept at the true number of clusters that is three.

Xu et al. [5]׳s algorithm based on longest edge removal is compared to B-MST with cluster numbers varying from two to ten for ALB data set. As claimed by the authors, their algorithm fails to obtain the number of clusters for the data set, since there is no dramatic change between successive objective function values when the number of clusters are increased from two to ten by one. Their method works better, when the edge weights between clusters are significantly greater than the others. Fig. 10
                            depicts the linear change of the objective function value of the method with various number of clusters.

Xu et al. [5] remove the longest edges to form clusters, whereas B-MST removes the most between edge. The superiority of between edge removal to longest edge removal is illustrated in Fig. 11
                            comparing the adjusted rand index(Crand) values for the same data set using longest edge removal that is legended LE Removal and B-MST׳s betweenness edge removal legended BE Removal. The number of clusters increases from two to ten by one. The figure indicates that the highest index value is obtained by BE removal and this value is obtained at the true number of cluster, which is three. Moreover, LE removal generates a cluster with size one when the number of clusters is two. BE removal is less likely to result in monolithic clusters since the most central edge is removed at each iteration. Also, TSI improvement indirectly requires having more connections of an object inside its cluster to minimize the number of out-connections. However, a lower bound for the cluster size may be introduced while running B-MST calculations to prevent clusters with a few objects.

@&#CONCLUSIONS@&#

Clustering high throughput biological data efficiently is essential especially when information about the interactions between biological molecules is not yet available. The high dimensional nature of the abundant data generated in microarrays makes designing efficient and effective algorithms necessary to generating biologically meaningful clusters.

In this study, an MST based algorithm, B-MST, is developed to cluster gene expression data efficiently. The algorithm uses a new objective function, TSI, as a tool to measure tightness and separation at the same time, while considering transitive distances on a binary graph to generate biologically meaningful clusters.

Many distance measures and diverse data sets were employed to develop the ARI calculations that show that B-MST is a compelling alternative to other clustering approaches because a few distance measures and data sets may be easily optimized [30]. Moreover, a unique validation index based on biological theory is developed that may guide many clustering approaches in addition to B-MST.

B-MST is tested using 13 different data sets. Eleven of the data sets are used for external validation by the ARI measure. Nine of these eleven data sets are used for tissue clustering, while the other two are used for gene clustering. The ARI values generated by K-means and PAM algorithms are compared to the values produced by B-MST, which outperforms the other methods in the six data sets, based on the decision theory׳s domination rule. B-MST dominates the other algorithms for all the gene clustering data sets presented in this study, and the heuristic׳s performance is also compared with the well-cited CSF. B-MST׳s highest ARI values are compared with CSF׳s values because CSF calculations are independent of distance measures. B-MST outperforms CSF in all of the data sets except Leukemia. The remaining two of the thirteen data sets are used for biological inference. B-MST finds clusters with higher selectivity values than CSF, except for one cluster in the Yeast2 data set. B-MST presents relevant results for biological process relevance in seven out of eight clusters, while CSF finds relevance in six of them. For Yeast3, B-MST also finds higher selectivity values than PAM in most of the clusters. B-MST determines biological process relevance in thirteen clusters of fifteen while PAM determines only ten.

The new TSI measure offers a novel quality measure that may validate a result from a clustering algorithm using biological data. In external validation, the minimum TSI values correspond to maximum rand index values in most of the cases. In biological inference, CSF finds a smaller TSI value for Yeast2 (101) compared to B-MST (105). B-MST finds a smaller TSI value (845) compared to PAM (853). Hence, biologically enriched genes in clusters with lower TSI values demonstrate that, the TSI is a reliable quality measure to be used in clustering biological data.

None declared.

@&#ACKNOWLEDGMENTS@&#

Andy D. Perkins was supported by the National Science foundation under grants EPS-0903787 and EPS-1006883, and by the Mississippi INBRE funded by grants from the National Center for Research Resources (5P20RR016476-11) and the National Institute of General Medical Sciences (8 P20 GM103476-11) from the National Institutes of Health. Harun Pirim acknowledges the support of KFUPM.

@&#REFERENCES@&#

