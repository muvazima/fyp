@&#MAIN-TITLE@&#Effects of texture addition on optical flow performance in images with poor texture

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           An initial step for optical flow estimation in poorly-textured images is proposed.


                        
                        
                           
                           The simple yet effective step preserves motion boundaries where other methods fail.


                        
                        
                           
                           The proposed algorithm reduces computation time meaningfully.


                        
                        
                           
                           Mathematical analysis is employed to explain the advantages provided.


                        
                        
                           
                           Quantitative measures have been introduced to assess the performance.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Optical flow

Poor texture

Foreground detection

Laws' masks

F-measure

Boundary displacement error

Condition number

@&#ABSTRACT@&#


               
               
                  This paper investigates the effects of adding texture to images with poorly-textured regions on optical flow performance, namely the accuracy of foreground boundary detection and computation time. Despite significant improvements in optical flow computations, poor texture still remains a challenge to even the most accurate methods. Accordingly, we explored the effects of simple modification of images, rather than the algorithms. To localize and add texture to poorly-textured regions in the background, which induce the propagation of foreground optical flow, we first perform a texture segmentation using Laws' masks and generate a texture map. Next, using a binary frame difference, we constrain the poorly-textured regions to those with negligible motion. Finally, we calculate the optical flow for the modified images with added texture using the best optical flow methods available. It is shown that if the threshold used for binarizing the frame difference is in a specific range determined empirically, variations in the final foreground detection will be insignificant. Employing the texture addition in conjunction with leading optical flow methods on multiple real and animation sequences with different texture distributions revealed considerable advantages, including improvement in the accuracy of foreground boundary preservation, prevention of object merging, and reduction in the computation time. The F-measure and the Boundary Displacement Error metrics were used to evaluate the similarity between detected and ground-truth foreground masks. Furthermore, preventing foreground optical flow propagation and reduction in the computation time are discussed using analysis of optical flow convergence.
               
            

@&#INTRODUCTION@&#

Accurate optical flow computation is crucial in many computer vision tasks, including motion estimation, object detection, and tracking. Three decades after the seminal contribution by Horn and Schunck [1], accuracy of optical flow computation methods have been improved significantly. However, images with poor texture, especially in the background, which occur in many sequences, still remain a major challenge in this field [2]. Since solving for optical flow components using the optical flow constraint is an ill-posed problem with two unknowns and one equation, there is a need for extra constraint(s). Spatial smoothness of optical flow components introduced by Horn and Schunck (HS) is one of the most common constraints used in different publications with various modifications, such as in [3–6]. The smoothness constraint causes the blurring of computed motion at the object boundaries, together with spread of foreground non-zero flow to the neighboring background pixels.

As we will see in Section 2.1, while making optical flow computation possible, in images with poorly-textured regions, the smoothness constraint leads to some disadvantages, such as considerable deformations in the size and the shape of the detected foreground objects, and accordingly in the position of the center area, which results in errors for foreground diagnosis and tracking. This is shown in the first row of Fig. 1
                      for a sequence, where a wooden model (only the upper body) and its cast shadows are moving against a background with poor texture. The first and second frames are shown in parts (a) and (b), respectively; the magnitude of optical flow calculated by the method in [4] is shown in part (c), where propagation of the object flow to the neighboring background pixels with poor texture has deformed the object shape and lead to difficulty in foreground detection. In images with multiple moving objects within a small region, smoothness of optical flow can lead to objects merging. This is illustrated in the second row of Fig. 1, where multiple cars with cast shadows are moving close to each other on a highway with insufficient texture. The first and second frames are shown in parts (d) and (e), respectively; the magnitude of optical flow calculated by the method in [6] is shown in part (f), where object merging is observable. The other negative effect of computing optical flow for poorly-textured regions is the considerable computation time due to solving the time-consuming Laplace equation with boundary conditions.

Researchers have attempted to overcome the negative effects of the smoothness term following the HS contribution. Nagel and Enkelmann [7] employed oriented derivatives for the smoothness term, observing that the motion boundaries coincide with the abrupt light intensity transitions. Using heuristically determined smoothness across and along the object boundaries, Alvarez et al. [8] proposed a modification for improving the method by Nagel and Enkelmann. A manually-designed probabilistic model using Markov Random Field (MRF) and a statistical model using patch-based motion discontinuity were used to relate the light intensity edges and motion boundaries by Black [9] and Fleet et al. [10], respectively. Lei et al. [11] adopted a variable weight for the effectiveness of the smoothness term in the HS formulation. The variable weight coefficient is adaptive through a threshold function based on the detection of the gray boundaries and on the real-time detection of the movement boundaries in the iterative process. The method by Nir et al. [12] solves for six affine parameters at each pixel position instead of two flow components. Sun as well as Werlberger et al. [13,2] modified the total energy function by adding non-local smoothness terms that employ adaptive weights for each pixel, which is basically equivalent to using median filtering after every warping step.

The approach of anisotropic weighting of the smoothness term is a breakthrough employed recently, including substitution of the standard quadratic penalizing function by the anisotropic Huber-L
                     1 Norm, first introduced in [14] and used in [15] and [16], applying smaller weights along the intensity boundaries compared to the orthogonal direction in [2]. A similar approach was proposed by Zimmer et al. [17] in which the brightness constancy is used to determine the weights rather than the intensity gradient. Harmonic constraint has been imposed on the isotropic gradient vector field to create the anisotropic diffusion in [18] and [19], where the authors utilized divergence and curl of the vector field. Aubert et al. [20] added an extra term, which penalizes computing motion in homogeneous blocks and only allows for large values of optical flow components in textured regions. Divergence controls the amount of diffusion, and the curl term controls the diffusion direction.

Despite significant improvements in the suppression of motion blurring at the object boundaries, even accurate and sophisticated leading methods in the Middlebury,
                        1
                     
                     
                        1
                        
                           http://vision.middlebury.edu/flow/.
                      KITTI,
                        2
                     
                     
                        2
                        
                           http://www.cvlibs.net/datasets/kitti/eval_stereo_flow.php?benchmark=flow.
                      and MPI Sintel
                        3
                     
                     
                        3
                        
                           http://ps.is.tue.mpg.de/project/MPI_Sintel_Flow.
                      rankings, such as [4,6], and [13] fail to capture the proper size and contour of the foreground in images with poorly-textured background regions. Note that employing more complicated cost functions leads to larger computation times, which is detrimental in real-time tracking procedures. After numerous observations of optical flow results using state-of-the-art methods, we came to the conclusion that no matter how sophisticated the algorithm is, performance could be undesirable if original frames have poor texture. This encouraged us to explore the outcomes of modifying original images, rather than modifying the computing algorithms.

Regions with poor texture exist both within the background and the foreground; however the regions in the background are the main reason for propagation of foreground flow to neighboring pixels, object shape distortion, and even object merging. Furthermore, adding a static texture to these regions can be performed with sufficient accuracy. However, to generate a moving texture for the foreground regions, we need to know pixels' correspondence, which is not possible without calculating the optical flow. If we want to calculate optical flow once and use it again for generating a moving texture, even small inaccuracies in the optical flow vector field leads to addition of the texture to wrong pixels and hence induction of erroneous flow. Moreover, any interpolation using feature matching is prone to mismatching errors and it requires knowledge about the type of object motion (rigid or flexible as they need different types of interpolations) which is not known a-priori; thus it cannot be used to generate an accurate moving texture. Therefore, we treat only poorly-textured background regions and leave the modification of foreground regions to future investigations. It is important to mention that the camera is assumed to be stationary in this paper. Therefore, we only add texture to the background pixels. Should the camera be moving, egomotion estimation and compensation are required to be performed before texture addition.

To localize and add texture to poorly-textured regions in the background, we first perform a texture segmentation using Laws' masks and generate a texture map. Next, using a binary frame difference, we constrain the poorly-textured regions to those with negligible motion. Finally, we calculate the optical flow for the modified images with added texture. It is shown that if the threshold used for binarizing the frame difference is in a specific range determined empirically, variations in the final foreground detection will be insignificant. Note that optical flow calculations suffer from poor texture, and image differencing cannot provide us with motion information, being significantly sensitive to illumination changes and the binarizing threshold; however, computing optical flow while using image differencing and texture addition as just described provides improved accuracy and robustness in foreground detection, as will be shown.

The main contributions of this study are: (1) creation of sharp motion boundaries and more accurate capture of the object size, position, and contour; (2) avoiding or mitigating object merging in sequences with multiple objects moving in a small area with poor texture; (3) reduction in computation time; and (4) mathematical analysis of the effects of texture addition on the optical flow convergence and computation time. This paper is organized as follows: In Section 2, we describe the problem in more detail, together with the texture addition algorithm and effects accompanied by mathematical analysis of optical flow convergence. Section 3 demonstrates representative and quantitative results, and discussion. Section 4 provides limitations and future work, while general conclusions are included in Section 5.

In this section, we first discuss the problem in more detail in Section 2.1. Then, we describe the texture addition algorithm and effects in Section 2.2, and explain these effects from the mathematical perspective in 2.3.

We will use the formulation of HS throughout this section for simpler explanations, while applying the accurate and leading methods in [4,6], and [13] for demonstrations later. Denoting light intensity by I, first order spatial and temporal derivatives of light intensity by (Ix
                        , Iy
                        ) and It
                        , respectively, optical flow components (u,v) in [1] are computed by minimizing the following total energy function:
                           
                              (1)
                              
                                 ϕ
                                 
                                    u
                                    v
                                 
                                 =
                                 
                                    ∫
                                    
                                       
                                          ∫
                                          
                                             
                                                
                                                   
                                                      ρ
                                                      2
                                                   
                                                   
                                                      ϕ
                                                      d
                                                   
                                                   
                                                      u
                                                      v
                                                   
                                                   +
                                                   
                                                      ϕ
                                                      c
                                                   
                                                   
                                                      u
                                                      v
                                                   
                                                
                                             
                                             dxdy
                                          
                                       
                                    
                                 
                              
                           
                        where the data error energy function is given by:
                           
                              (2)
                              
                                 
                                    ϕ
                                    d
                                 
                                 
                                    u
                                    v
                                 
                                 =
                                 
                                    
                                       
                                          
                                             I
                                             x
                                          
                                          u
                                          +
                                          
                                             I
                                             y
                                          
                                          v
                                          +
                                          
                                             I
                                             t
                                          
                                       
                                    
                                    2
                                 
                              
                           
                        and smoothness energy function is defined as:
                           
                              (3)
                              
                                 
                                    ϕ
                                    c
                                 
                                 
                                    u
                                    v
                                 
                                 =
                                 
                                    
                                       
                                          
                                             ∂
                                             u
                                          
                                          
                                             ∂
                                             x
                                          
                                       
                                    
                                    2
                                 
                                 +
                                 
                                    
                                       
                                          
                                             ∂
                                             u
                                          
                                          
                                             ∂
                                             y
                                          
                                       
                                    
                                    2
                                 
                                 +
                                 
                                    
                                       
                                          
                                             ∂
                                             v
                                          
                                          
                                             ∂
                                             x
                                          
                                       
                                    
                                    2
                                 
                                 +
                                 
                                    
                                       
                                          
                                             ∂
                                             v
                                          
                                          
                                             ∂
                                             y
                                          
                                       
                                    
                                    2
                                 
                                 .
                              
                           
                        
                     

Parameter ρ determines the relative weight of the data term. Then, the Euler–Lagrange equations yield:
                           
                              (4)
                              
                                 
                                    
                                       
                                          
                                             I
                                             x
                                             2
                                          
                                          u
                                          +
                                          
                                             I
                                             x
                                          
                                          
                                             I
                                             y
                                          
                                          v
                                          −
                                          
                                             ρ
                                             2
                                          
                                          
                                             ∇
                                             2
                                          
                                          u
                                          =
                                          −
                                          
                                             I
                                             x
                                          
                                          
                                             I
                                             t
                                          
                                       
                                    
                                    
                                       
                                          
                                             I
                                             x
                                          
                                          
                                             I
                                             y
                                          
                                          u
                                          +
                                          
                                             I
                                             y
                                             2
                                          
                                          v
                                          −
                                          
                                             ρ
                                             2
                                          
                                          
                                             ∇
                                             2
                                          
                                          v
                                          =
                                          −
                                          
                                             I
                                             y
                                          
                                          
                                             I
                                             t
                                          
                                          .
                                       
                                    
                                 
                              
                           
                        
                     

In regions where spatial light intensity variations are negligible (poor texture), including along the x and y axes (I
                        
                           x
                        
                        ≈0,I
                        
                           y
                        
                        ≈0), Eq. (4) will be approximated by the Laplace equations with boundary conditions dictated by the neighboring windows:
                           
                              (5)
                              
                                 
                                    ∇
                                    2
                                 
                                 u
                                 ≈
                                 0
                                 ,
                                 
                                    ∇
                                    2
                                 
                                 v
                                 ≈
                                 0
                                 .
                              
                           
                        
                     

If Eq. (5) holds in the background regions (outside the boundaries of the foreground objects), non-zero optical flow of the object blocks will affect the neighboring background pixels, where zero motion is expected. This effect will spread, and the level of influence depends on the magnitude of light intensity variations around the object (as well as the computing method), which can be a region of the image relatively larger than the object size in images with considerably poor texture. This is illustrated in Fig. 2
                         for a sequence in which an airplane
                           4
                        
                        
                           4
                           
                              http://www.youtube.com/watch?v=qF9VZSkVZI0.
                         is moving against a uniform background sky, with the first frame, second frame, and the ground-truth of the foreground shown in parts (a), (b), and (c), respectively. The magnitude of optical flow computed according to methods in [4,6], and [13] can be seen in parts (d), (e), and (f) in the second row, respectively. Comparing the magnitudes of optical flow 
                           
                              
                                 w
                                 =
                                 
                                    
                                       
                                          u
                                          2
                                       
                                       +
                                       
                                          v
                                          2
                                       
                                    
                                 
                              
                           
                        , with the ground-truth of the foreground, we can see that not only are the detected moving pixels significantly larger than the object's size, especially in part (d), but also the contour of the object is not preserved.

The first step is to localize poorly-textured regions in a frame. We use the Laws' masks introduced in [21] to measure the texture energy in different regions of an image. Denoting a gray-scale frame by IL, we apply Laws' 2-D convolution kernels on IL, which can be created using the following set of 1-D kernels of length three: L
                        3
                        =[1 2 1] (average gray level), E
                        3
                        =[1 0 −1] (edge extractor), and S
                        3
                        =[1 −2 1] (spot extractor).

Although nine 2-D kernels can be built using the outer product of these filters, we did not use L
                        3
                        
                           T
                        
                        L
                        3, since it only measures the average gray level value in a 3×3 window, while we look for pixel-wise light intensity variations. Accordingly, each frame is convolved with the following set of eight 2-D masks: [L
                        3
                        
                           T
                        
                        E
                        3,L
                        3
                        
                           T
                        
                        S
                        3,E
                        3
                        
                           T
                        
                        L
                        3,E
                        3
                        
                           T
                        
                        E
                        3,E
                        3
                        
                           T
                        
                        S
                        3,S
                        3
                        
                           T
                        
                        L
                        3,S
                        3
                        
                           T
                        
                        E
                        3,S
                        3
                        
                           T
                        
                        S
                        3]. This set is capable of measuring light intensity variations in different patterns (i.e. texture) in a region. Denote this kernel set by [K
                        1,K
                        2,…,K
                        8] and show the convolution operation by (∗). Then texture energy (TE) at a pixel in position (i, j) is given by:
                           
                              (6)
                              
                                 
                                    
                                       
                                          T
                                          E
                                          
                                             i
                                             j
                                          
                                          =
                                          
                                             
                                                ∑
                                                
                                                   n
                                                   =
                                                   1
                                                
                                                8
                                             
                                             
                                          
                                          
                                             
                                                
                                                   F
                                                   n
                                                
                                                
                                                   i
                                                   j
                                                
                                             
                                          
                                          ,
                                       
                                    
                                    
                                       
                                          
                                          
                                             F
                                             n
                                          
                                          =
                                          
                                             K
                                             n
                                          
                                          ∗
                                          I
                                          L
                                          .
                                       
                                    
                                 
                              
                           
                        
                     

The next step is to create a binary texture energy map, denoted by TEB, which requires a threshold on the values of the texture energy, here denoted by γ. To avoid using an empirically-determined threshold which can fail for sequences not studied, we use an adaptive method based on the histogram of the texture energy values. Based on the knowledge from images processing – the major portion of an image information lies in the low texture energy values – and after investigating a large number of sequences, we acquired assurance that the histogram of TE values for a typical image looks like what is shown in Fig. 3
                         (here using 100 bins). It is a right-skewed distribution with mostly decreasing frequencies as the texture energy increases (there could be sudden increases, but low very texture energy values tend to have significantly larger frequencies).

We call those regions “poorly-textured” for which the texture energy levels are sufficiently different, here smaller than the other values (with higher frequencies). In other words, we look for those values with such high frequency that are outliers in this histogram. Since the histogram of texture energy levels for most of the images does not follow a normal distribution, determining outliers is performed using the method introduced in [22] for skewed distributions. In this paper, Vanderviere and Huber introduced an adjusted boxplot taking into account the medcouple MC, a robust measure of skewness for a skewed distribution, which for a data series with sorted entries (X
                        
                           n
                        
                        ={x
                        1,x
                        2,…,x
                        
                           n
                        },x
                        1
                        ≤
                        x
                        2
                        ≤…≤
                        x
                        
                           n
                        ) is given by:
                           
                              (7)
                              
                                 M
                                 C
                                 =
                                 m
                                 e
                                 d
                                 
                                    
                                       
                                          
                                             
                                                
                                                   x
                                                   j
                                                
                                                −
                                                me
                                                
                                                   d
                                                   k
                                                
                                             
                                          
                                          −
                                          
                                             
                                                me
                                                
                                                   d
                                                   k
                                                
                                                −
                                                
                                                   x
                                                   i
                                                
                                             
                                          
                                       
                                       
                                          
                                             x
                                             j
                                          
                                          −
                                          
                                             x
                                             i
                                          
                                       
                                    
                                 
                              
                           
                        with med and medk
                         be the median operator and the median of Xn
                        , and xi
                         and xj
                         have to satisfy x
                        
                           i
                        
                        ≤
                        med
                        
                           k
                        
                        ≤
                        x
                        
                           j
                         and x
                        
                           i
                        
                        ≠
                        x
                        
                           j
                        . Then, for right-skewed distributions like in Fig. 3 with MC
                        ≥0, the boxplot limits given in Eq. (8) can be used to determine the outliers:
                           
                              (8)
                              
                                 
                                    x
                                    i
                                 
                                 <
                                 
                                    Q
                                    1
                                 
                                 −
                                 1.5
                                 
                                    e
                                    
                                       −
                                       3.5
                                       M
                                       C
                                    
                                 
                                 I
                                 Q
                                 R
                                 
                                 ,
                                 
                                 
                                    x
                                    i
                                 
                                 >
                                 
                                    Q
                                    3
                                 
                                 +
                                 1.5
                                 
                                    e
                                    
                                       4
                                       M
                                       C
                                    
                                 
                                 I
                                 Q
                                 R
                              
                           
                        where Q
                        1 and Q
                        3 are the first and third quantiles and IQR is the interquartile range. Here Xn
                         represents the sorted frequencies of TE values acquired from the histogram. We use the upper limit in (8) to determine those texture energy levels with frequencies in the histogram that are outliers from above. For instance, for the histogram shown in Fig. 3, only the two first bins were found to be outliers; so a threshold of γ
                        =0.02 was used and multiplied by the maximum value of TE, since 100 bins were used.Because the binary texture energy maps for the first and the second frames are not usually identical due to different factors, such as lighting variations, we use the binary intersection operator to ensure that texture will only be added to identical locations in both frames. Denoting the texture energy maps for the first and the second frame by TE1
                         and TE2
                        , the final binary texture map is given by:
                           
                              (9)
                              
                                 T
                                 E
                                 B
                                 
                                    i
                                    j
                                 
                                 =
                                 
                                    
                                       
                                          
                                             1
                                          
                                          
                                             
                                             if
                                             
                                             
                                                
                                                   T
                                                   
                                                      E
                                                      1
                                                   
                                                   
                                                      i
                                                      j
                                                   
                                                   ≥
                                                   γ
                                                   
                                                   ×
                                                   
                                                   max
                                                   
                                                      
                                                         T
                                                         
                                                            E
                                                            1
                                                         
                                                      
                                                   
                                                
                                             
                                             ∩
                                             
                                                
                                                   T
                                                   
                                                      E
                                                      2
                                                   
                                                   
                                                      i
                                                      j
                                                   
                                                   ≥
                                                   γ
                                                   
                                                   ×
                                                   
                                                   max
                                                   
                                                      
                                                         T
                                                         
                                                            E
                                                            2
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             0
                                          
                                          
                                             
                                             otherwise
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        
                     


                        Fig. 4
                         shows the first and second frames from a laboratory sequence,
                           5
                        
                        
                           5
                           
                              http://arma.sourceforge.net/shadows/.
                         and the binary texture energy map in parts (a), (b), and (c), respectively.


                        TEB distinguishes only between regions with rich and poor textures. So, to localize and add texture only to the poorly-textured regions in the background, we must use a type of foreground detection algorithm. We opted to use image differencing due to the small computation time required. Note that in addition to foreground detection (which is not accurate for poorly-textured images), optical flow can also provide further information, such as direction and magnitude of pixels' displacement per frame. Furthermore, image differencing cannot be employed to detect the foreground with sufficient accuracy due to lighting changes, small capture rate, etc., and the shape of the resulting binary map will depend on the threshold utilized. Therefore, image differencing cannot replace optical flow regarding accurate detection of motion; it is merely used to ensure that the static texture is not added to the pixels with apparent motion, and that the added texture does not induce erroneous flow.

While the threshold used for binarizing the frame difference will determine the shape of the binary map, FDB, later we show that the final optical flow magnitude using the texture-added frames will not significantly vary provided that the threshold, β, is selected from an empirically-determined range. Denoting the frame difference by (FD
                        =
                        IL
                        2
                        −
                        IL
                        1), we define FDB as:
                           
                              (10)
                              
                                 F
                                 D
                                 B
                                 
                                    i
                                    j
                                 
                                 =
                                 
                                    
                                       
                                          
                                             1
                                          
                                          
                                             
                                             if
                                             
                                             F
                                             D
                                             
                                                i
                                                j
                                             
                                             ≥
                                             β
                                             
                                             ×
                                             
                                             max
                                             
                                                
                                                   F
                                                   D
                                                
                                             
                                          
                                       
                                       
                                          
                                             0
                                          
                                          
                                             
                                             otherwise
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        Note that in order to binarize the frame difference, typically a fixed threshold might be used, but we can improve the results by employing an adaptive threshold. To avoid rendering small light intensity variations (due to illumination changes, camera inherent noise, etc.) as foreground pixels, we tried to only keep those pixels with the largest light intensity variations, which can be determined by comparing their light intensity variation magnitude to the maximum value of light intensity change. Therefore, we used the max( ) function in Eq. (10).

We also perform binary image filling on FDB to avoid missing some of the moving pixels within the FDB borders. To generate the texture that will be added to the frames, we can select texture patches from available texture images or simply generate a stochastic texture. Selection of the texture types depends on the optical flow computation method, which will be discussed in Section 3. To create the stochastic texture for each pixel (i, j), first three random numbers (RND) from a normal distribution are generated with μ
                        =0 and σ
                        =1 for three RGB channels (RND(i,j,k)∈
                        N(0,1),k
                        =1,2,3). Then, they are multiplied by a scalar, SC that determines the magnitude of the texture for each pixel. The static stochastic texture image (STX) has the same size as both sequence frames, and is given by:
                           
                              (11)
                              
                                 S
                                 T
                                 X
                                 
                                    i
                                    j
                                    k
                                 
                                 =
                                 S
                                 C
                                 ×
                                 R
                                 N
                                 D
                                 
                                    i
                                    j
                                    k
                                 
                                 
                                 ,
                                 k
                                 =
                                 1
                                 ,
                                 2
                                 ,
                                 3
                                 .
                              
                           
                        
                     

Finally, the modified frames (IN
                        1, IN
                        2) are created by adding texture only to the regions in both original frames (here original color frames are denoted by IM) that have poor texture and do not show apparent motion:
                           
                              (12)
                              
                                 IN
                                 
                                    i
                                    j
                                    k
                                 
                                 =
                                 
                                    
                                       
                                          
                                             I
                                             M
                                             
                                                i
                                                j
                                                k
                                             
                                             +
                                             S
                                             T
                                             X
                                             
                                                i
                                                j
                                                k
                                             
                                          
                                          
                                             if
                                             
                                             
                                                
                                                   T
                                                   E
                                                   B
                                                   
                                                      i
                                                      j
                                                   
                                                   =
                                                   0
                                                   
                                                   and
                                                   
                                                   F
                                                   D
                                                   B
                                                   
                                                      i
                                                      j
                                                   
                                                   =
                                                   0
                                                
                                             
                                          
                                       
                                       
                                          
                                             I
                                             M
                                             
                                                i
                                                j
                                                k
                                             
                                          
                                          
                                             
                                             otherwise
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        
                     

In the first row in Fig. 5
                        , part (a) shows the binary frame difference for the laboratory sequence, and part (b) shows the map that localizes background regions with poor texture. Modified frames with texture addition can be seen in parts (c) and (d), respectively. Here, for frames with 8-bit unsigned integer values, SC
                        =40 was used for all pixel. Selection of SC will be discussed in Section 2.3. Magnitude of optical flow calculated according to [4,6], and [13] for the original and modified frames are shown in the second and third rows, respectively. Comparing the optical flow magnitude results for original and modified frames, we observe that the erroneous background flow has been suppressed, and thus the foreground boundaries have been preserved with higher accuracy in all methods, despite differences in the approaches used to calculate optical flow components. Quantitative improvement in preservation of foreground boundary detection is discussed in Section 3.

We have illustrated the effect of β
                        ∈[0.002,0.1] on the binary frame difference FDB and the optical flow magnitude using the texture-added frames in Fig. 6
                        . In the first row, part (a) shows the magnitude of optical flow using original images computed according to [13] and part (b) shows the ground-truth for the foreground; in the second row, binary frame difference is shown for β
                        =0.002, β
                        =0.01, β
                        =0.025, β
                        =0.04, and β
                        =0.1; and the third row shows the magnitude of optical flow using modified frames computed according to [13]. Very small thresholds as in part (c) lead to detection of the majority of pixels as belonging to the foreground, since light intensity of pixels do not remain unchanged due to lighting changes, quantization effects, etc. Therefore, texture will not be added to the poorly-textured regions as they are recognized to be foreground regions, and thus the magnitude of optical flow for the modified and original images will be similar without specific improvements. For large thresholds as in part (g), only a fraction of foreground pixels will be correctly detected, and adding texture incorrectly to the moving pixels will result in erroneous flow in the foreground regions (small flow magnitude in part (l) for some pixels). Our empirical results show that if the threshold is selected from the range β
                        ∈[0.01,0.04], the magnitude of optical flow remains approximately the same, while the binary frame difference significantly changes with the threshold. Similar experiments with other sequences revealed that the range β
                        ∈[0.01,0.04] (enclosed in a red rectangle in Fig. 6) can provide reasonable results.

In images with multiple objects moving close to each other, smoothness of optical flow variations and propagation of foreground flow into neighboring background pixels lead to object merging, as observed in the second row of Fig. 1 for the Highway Sequence. Modified frames and the magnitude of optical flow for these frames computed according to [6] are shown in parts (a) to (c) in Fig. 7
                        . (Here we use the method proposed in [6] rather than in [13], since it is designed to handle large displacements of the objects as they exist in this sequence). As compared to part (f) in Fig. 1, adding texture to background regions with poor texture results in the suppression of erroneous flow for the background pixels, thus reducing object merging, although not completely eliminating the problem.

The other advantage of adding texture to the images with poorly-textured regions in the background is reduction in the computation time, which is explained in 2.3. For the Laboratory Sequence shown in Fig. 4, we noticed 20.1%, 7.8%, and 11.7% reduction in computation time for methods in [4,6], and [13], respectively. Similar results have been observed in other sequences, which will be discussed in Section 3.

In this section, we explain why adding texture to poorly-textured background regions suppresses erroneous flow and why it reduces the computation time. Rewriting Eq. (4) in matrix notation helps analyze the convergence of optical flow values for the background to very small values, and reduced computation time. Mitchie and Mansouri [23] used discretization of the Laplace operator and rewrote Eq. (4) into a set of linear equations of the form Az
                        =
                        b, where A is a tridiagonal matrix, vector z contains 2N
                        2 unknown optical flow components, u and v, of an image with N
                        ×
                        N
                        pixels, and a constant vector b of the same size as z. Proof of block-wise convergence for unknown values in vector z using Gauss–Seidel iteration is provided in [23].

We can rewrite Eq. (4) for ρ
                        =1 as:
                           
                              (13)
                              
                                 
                                    ∇
                                    2
                                 
                                 
                                    
                                       
                                       v
                                       u
                                    
                                 
                                 +
                                 M
                                 
                                    
                                       
                                       v
                                       u
                                    
                                 
                                 =
                                 R
                              
                           
                        where M and R are defined by:
                           
                              (14)
                              
                                 M
                                 =
                                 −
                                 
                                    
                                       
                                          
                                             
                                                I
                                                x
                                                2
                                             
                                          
                                          
                                             
                                                I
                                                x
                                             
                                             
                                                I
                                                y
                                             
                                          
                                       
                                       
                                          
                                             
                                                I
                                                x
                                             
                                             
                                                I
                                                y
                                             
                                          
                                          
                                             
                                                I
                                                y
                                                2
                                             
                                          
                                       
                                    
                                 
                                 ,
                                 R
                                 =
                                 
                                    
                                       
                                          
                                             
                                                I
                                                x
                                             
                                             
                                                I
                                                t
                                             
                                          
                                       
                                       
                                          
                                             
                                                I
                                                y
                                             
                                             
                                                I
                                                t
                                             
                                          
                                       
                                    
                                 
                              
                           
                        and the magnitudes of Ix
                         and Iy
                         depend on SC. For the background regions, where texture has been added, Ix
                         and Iy
                         will no longer be negligible terms, while temporal derivative It
                         is close to zero (because background pixels do not move and their light intensities do not change significantly with time). If we use finite difference formulas, then the higher the scalar value SC is, the larger the spatial derivative terms become, and the larger the magnitudes of entries in M and R become. Since the entries of the resulting matrix from the Laplacian operator on the left-hand-side of Eq. (13) are not affected by the texture magnitude, and are calculated using only a weighted averaging of the neighboring flow components (which are not large), the Laplacian operator term would be significantly smaller than the entries of M and R for relatively large values of SC (SC
                        >20). Therefore, Eq. (13) can be written as M(
                           v
                        
                        
                           u
                        )≈
                        R, which is approximately a set of linear homogeneous equations, where the solution must converge to zero due to invertibility of the positive definite matrix M 
                        [23].

For the background blocks in the vicinity of the foreground objects, due to the coupling of optical flow components to the foreground values (as explained in [23]), values for u and v will not converge to zero, but to small values. As we move further from the foreground object, background flow would approximately vanish in a distance that depends on the magnitude of SC. The effect of SC on the suppression the background flow can be clearly seen in Fig. 8
                         for the Airplane Sequence in Fig. 2. First and second frames are shown in parts (a) and (b); modified second frames are shown in parts (c) to (e) for different values of SC (higher values mean stronger texture intensity); and corresponding magnitudes of optical flow are displayed under each modified frame in (f) to (h), respectively. As the value of SC increases, the background flow vanishes in shorter distances from the object.

Higher values of SC, however will lead to higher errors in the foreground object boundaries. Consider a background pixel and its immediate neighboring pixels in a poorly-textured background region that are covered by a foreground object only in the first frame (possibly pixels near boundaries). Using I to show light intensity values and indices i, j, and k for the x-axis, y-axis, and time, respectively, we can write the variations in the light intensity derivatives as:
                           
                              (15)
                              
                                 
                                    
                                       
                                          
                                          
                                             I
                                             
                                                i
                                                ,
                                                j
                                                ,
                                                k
                                                +
                                                1
                                             
                                          
                                          →
                                          
                                             I
                                             
                                                i
                                                ,
                                                j
                                                ,
                                                k
                                                +
                                                1
                                             
                                          
                                          +
                                          
                                             n
                                             1
                                          
                                       
                                    
                                    
                                       
                                          
                                          
                                             I
                                             
                                                i
                                                +
                                                1
                                                ,
                                                j
                                                ,
                                                k
                                                +
                                                1
                                             
                                          
                                          →
                                          
                                             I
                                             
                                                i
                                                +
                                                1
                                                ,
                                                j
                                                ,
                                                k
                                                +
                                                1
                                             
                                          
                                          +
                                          
                                             n
                                             2
                                          
                                       
                                    
                                    
                                       
                                          
                                          
                                             I
                                             
                                                i
                                                ,
                                                j
                                                +
                                                1
                                                ,
                                                k
                                                +
                                                1
                                             
                                          
                                          →
                                          
                                             I
                                             
                                                i
                                                ,
                                                j
                                                +
                                                1
                                                ,
                                                k
                                                +
                                                1
                                             
                                          
                                          +
                                          
                                             n
                                             3
                                          
                                       
                                    
                                    
                                       
                                          
                                             I
                                             
                                                i
                                                +
                                                1
                                                ,
                                                j
                                                +
                                                1
                                                ,
                                                k
                                                +
                                                1
                                             
                                          
                                          →
                                          
                                             I
                                             
                                                i
                                                +
                                                1
                                                ,
                                                j
                                                +
                                                1
                                                ,
                                                k
                                                +
                                                1
                                             
                                          
                                          +
                                          
                                             n
                                             4
                                          
                                       
                                    
                                 
                              
                           
                        where “→” indicates “become” and n
                        1 to n
                        4 are random numbers due to texture addition. If we employ the same discretizations used in [1] for numerical differentiations in Ix
                        , Iy
                        , and It
                        , then the expected values of the derivative terms can be given by Eq. (15), where E[n] is the expected value of a random variable n:
                           
                              (16)
                              
                                 
                                    
                                       
                                          E
                                          
                                             
                                                I
                                                x
                                             
                                          
                                          →
                                          E
                                          
                                             
                                                I
                                                x
                                             
                                          
                                          +
                                          E
                                          
                                             
                                                
                                                   n
                                                   3
                                                
                                                +
                                                
                                                   n
                                                   4
                                                
                                                −
                                                
                                                   n
                                                   1
                                                
                                                −
                                                
                                                   n
                                                   2
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          E
                                          
                                             
                                                I
                                                y
                                             
                                          
                                          →
                                          E
                                          
                                             
                                                I
                                                y
                                             
                                          
                                          +
                                          E
                                          
                                             
                                                
                                                   n
                                                   2
                                                
                                                +
                                                
                                                   n
                                                   4
                                                
                                                −
                                                
                                                   n
                                                   1
                                                
                                                −
                                                
                                                   n
                                                   3
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          E
                                          
                                             
                                                I
                                                t
                                             
                                          
                                          →
                                          E
                                          
                                             
                                                I
                                                t
                                             
                                          
                                          +
                                          E
                                          
                                             
                                                
                                                   n
                                                   1
                                                
                                                +
                                                
                                                   n
                                                   2
                                                
                                                +
                                                
                                                   n
                                                   3
                                                
                                                +
                                                
                                                   n
                                                   4
                                                
                                             
                                          
                                          .
                                       
                                    
                                 
                              
                           
                        
                     

Therefore, selection of random numbers in the synthetic texture from a normal distribution with expected value of zero helps to maintain the expected values of spatial and temporal derivative terms unchanged. Note that our zero-mean normal distribution is more likely to produce a larger number of random values close to zero than a zero-mean uniform distribution. This will reduce the foreground errors around the foreground object boundaries. Here, higher SC values would magnify the standard deviation of the foreground flow error, while suppressing the background flow faster.

As we can see in Fig. 8(c), employing large values for SC does not change the foreground size and shape considerably and provides negligible advantage. However, higher values of SC cause the optical flow error in the foreground boundary pixels to increase significantly. For the Airplane Sequence in Fig. 8, the object only undergoes a translation of u
                        =−5.11 and v
                        =−2.28pixels between two frames. The percentage of average errors 
                           
                              
                                 
                                    Δ
                                    u
                                 
                                 ¯
                              
                              
                                 
                                    Δ
                                    v
                                 
                                 ¯
                              
                           
                         in the u and v components are (0.40%, 0.32%), (1.16%, 0.91%), and (2.52%, 2.11%) for the object boundary pixels using texture magnitudes of SC
                        =5, SC
                        =40, and SC
                        =75, respectively. Experiments with multiple sequences have revealed that a texture magnitude of SC
                        =40 for images with 8-bit unsigned integer values (or equivalently 15% of the maximum light intensity value) can provide a reasonable compromise between suppression of erroneous background flow and the errors in u and v components for the object boundary pixels.

Eq. (13) can also help investigate the reduction in computation time. In a linear system of equations, such as Az
                        =
                        b, (where A is a positive definite matrix) the rate of convergence is directly related to the condition number (κ) of the coefficient matrix A, which can be defined as the ratio of the largest eigenvalue of a matrix, λmax
                        , to the smallest eigenvalue of the matrix, λmin
                        , for any symmetric positive matrix [24]. The higher the condition number, the slower the convergence would become. If we use a 9-point discretization for the Laplace operator on an image of N
                        ×
                        N
                        pixels, the condition number of the resulting positive definite matrix (denoted by L) is of order O(N
                        2) [25], which could be very large (≫1). In images with poorly-textured backgrounds, such as the UFO sequence, since the matrix M for these regions approximately vanishes in Eq. (13), the condition number of the Laplace operator is the dominating term, and it leads to very slow convergence.

When synthetic texture is added, entries in matrix M are no longer negligible, so we encounter the problem of eigenvalues of the sum of two Hermitian (here positive definite) matrices. If we denote the eigenvalues of a matrix in a descending order by λ
                        1
                        >
                        λ
                        2
                        >…>
                        λSZ
                        , where SZ is the size of the matrix, then we can find the upper and lower bounds for the largest and smallest eigenvalues of the sum of two positive definite matrices by referring to the Weyl inequality [26]:
                           
                              (17)
                              
                                 
                                    
                                       
                                          
                                             λ
                                             1
                                          
                                          
                                             
                                                L
                                                +
                                                M
                                             
                                          
                                          ≤
                                          
                                             λ
                                             1
                                          
                                          
                                             L
                                          
                                          +
                                          
                                             λ
                                             1
                                          
                                          
                                             M
                                          
                                       
                                    
                                    
                                       
                                          
                                             λ
                                             1
                                          
                                          
                                             
                                                L
                                                +
                                                M
                                             
                                          
                                          ≥
                                          max
                                          
                                             
                                                
                                                   λ
                                                   r
                                                
                                                
                                                   L
                                                
                                                +
                                                
                                                   λ
                                                   
                                                      r
                                                      +
                                                      S
                                                      Z
                                                      −
                                                      1
                                                   
                                                
                                                
                                                   M
                                                
                                             
                                          
                                          ,
                                          
                                          r
                                          =
                                          1
                                          ,
                                          2
                                          ,
                                          …
                                          ,
                                          S
                                          Z
                                       
                                    
                                    
                                       
                                          
                                             λ
                                             
                                                S
                                                Z
                                             
                                          
                                          
                                             
                                                L
                                                +
                                                M
                                             
                                          
                                          ≤
                                          min
                                          
                                             
                                                
                                                   λ
                                                   r
                                                
                                                
                                                   L
                                                
                                                +
                                                
                                                   λ
                                                   
                                                      r
                                                      +
                                                      S
                                                      Z
                                                      −
                                                      1
                                                   
                                                
                                                
                                                   M
                                                
                                             
                                          
                                          ,
                                          
                                          r
                                          =
                                          1
                                          ,
                                          2
                                          ,
                                          …
                                          ,
                                          S
                                          Z
                                       
                                    
                                    
                                       
                                          
                                             λ
                                             
                                                S
                                                Z
                                             
                                          
                                          
                                             
                                                L
                                                +
                                                M
                                             
                                          
                                          ≥
                                          
                                             λ
                                             
                                                S
                                                Z
                                             
                                          
                                          
                                             L
                                          
                                          +
                                          
                                             λ
                                             
                                                S
                                                Z
                                             
                                          
                                          
                                             M
                                          
                                          .
                                       
                                    
                                 
                              
                           
                        
                     

The condition number of L
                        +
                        M, denoted by κ(L
                        +
                        M) is the ratio of λ
                        1(L
                        +
                        M) to λSZ
                        (L
                        +
                        M), which is bounded by the following inequalities:
                           
                              (18)
                              
                                 
                                    
                                       max
                                       
                                          
                                             
                                                λ
                                                r
                                             
                                             
                                                L
                                             
                                             +
                                             
                                                λ
                                                
                                                   r
                                                   +
                                                   S
                                                   Z
                                                   −
                                                   1
                                                
                                             
                                             
                                                M
                                             
                                          
                                       
                                    
                                    
                                       min
                                       
                                          
                                             
                                                λ
                                                r
                                             
                                             
                                                L
                                             
                                             +
                                             
                                                λ
                                                
                                                   r
                                                   +
                                                   S
                                                   Z
                                                   −
                                                   1
                                                
                                             
                                             
                                                M
                                             
                                          
                                       
                                    
                                 
                                 ≤
                                 κ
                                 
                                    
                                       L
                                       +
                                       M
                                    
                                 
                                 ≤
                                 
                                    
                                       
                                          λ
                                          1
                                       
                                       
                                          L
                                       
                                       +
                                       
                                          λ
                                          1
                                       
                                       
                                          M
                                       
                                    
                                    
                                       
                                          λ
                                          
                                             S
                                             Z
                                          
                                       
                                       
                                          L
                                       
                                       +
                                       
                                          λ
                                          
                                             S
                                             Z
                                          
                                       
                                       
                                          M
                                       
                                    
                                 
                                 
                                 ,
                                 r
                                 =
                                 1
                                 ,
                                 2
                                 ,
                                 …
                                 ,
                                 S
                                 Z
                                 .
                              
                           
                        
                     

Within a poorly-textured background region, if the values of Ix
                         and Iy
                         using a very small scalar value of SC
                        0 (which can correspond to the original image without texture addition) are designated I
                        
                           x0 and I
                        
                           y0, then amplifying the texture magnitude using a scalar value of η
                        ×
                        SC
                        0 would change these terms to η
                        ×
                        I
                        
                           x0 and η
                        ×
                        I
                        
                           y0 due to the linearity of finite difference calculations. Furthermore, multiplication of scalar SC by a factor of η would magnify all the entries and the eigenvalues of M by a factor of η
                        2, including the smallest and the largest eigenvalues. As a result, all numerators and denominators of the upper bound and the lower bound terms in Eq. (18) increase linearly proportional to η
                        2. This leads to the reduction of both upper and lower bounds, since λ
                        1(L)≫
                        λ
                        
                           SZ
                        (L) and the bound terms are decreasing functions with respect to eigenvalues of M, or equivalently η
                        2. Reduction in the upper and the lower bounds will lead to the reduction in the condition number of the equivalent matrix (M
                        +
                        L), such that the convergence rate would increase.

@&#RESULTS AND DISCUSSION@&#

In this section, we will first demonstrate representative results in Section 3.1. Then, we evaluate the performance of optical flow methods used in this study with and without texture addition in terms of foreground boundary preservation and computation time in Section 3.2. Finally, we provide discussion in Section 3.3.

As we have seen in the previous section, an important advantage of the preprocessing stage is the suppression of the erroneous background flow yielding sharp motion boundaries and more accurate rendering of the foreground size and shape. To illustrate this effect, we employed texture addition in conjunction with accurate and leading optical flow methods in [4,6], and [13] on ten sequences with different texture distributions and number of moving objects, eight of which are captured from real videos and two are animations. The number of methods we used is limited by the availability of the publication and the algorithm code, because many leading algorithms in databases are from anonymous subscribers without access to the publication or the algorithm. The method in [4] is an accurate algorithm with similar performance over all sequences used in this study, so it can be considered as a reference for comparisons. The method in [6] is one of the leading methods in the KITTI database, which can handle large displacements more efficiently. The method in [13] uses median filtering that leads to higher accuracy of object boundary preservations in many sequences. This method was ranked 1st in the Middlebury database in 2010, and is currently a leading method in the KITTI and MPI Sintel databases.

Due to the large number of sequences and images, and to maintain sufficient space for each sequence, we have divided the results into two separate figures, Figs. 9 and 10
                        
                        . For each sequence, the results are displayed in one column, where the images from the top to the bottom are, respectively: the modified first frame, the original second frame, ground-truth mask for the foreground, magnitude of optical flow using the method in [4] for original images, magnitude of optical flow using the method in [4] for modified images, magnitude of optical flow using the method in [6] for original images, magnitude of optical flow using the method in [6] for modified images, magnitude of optical flow using the method in [13] for original images, and magnitude of optical flow using the method in [13] for modified images.

To generate ground-truth images, we used the edge maps of the frames which were delineated by the Canny edge detector with manually selected parameters determined to render all edge pixels. Next, we asked multiple volunteers to manually eliminate extra edge pixels and connect non-connected edges. Finally, image filling was performed on the accurate edge maps. In Fig. 9, the first sequence (laboratory sequence) shows a person moving away from the camera in a laboratory,
                           6
                        
                        
                           6
                           
                              http://arma.sourceforge.net/shadows/.
                         where cabinet doors surrounding his body have poor texture. The second sequence shows a wooden model
                           7
                        
                        
                           7
                           
                              http://www.youtube.com/watch?v=eJlqQSMifqk.
                         (wooden model sequence), where the upper body and cast shadows move against a uniform background. The third sequence shows a personal vehicle captured by a surveillance camera
                           8
                        
                        
                           8
                           
                              http://www.youtube.com/watch?v=x6HRKncJuB0.
                         (surveillance sequence), where the vehicle and the cast shadow move against the street with poor texture. In these sequences, a single object (and corresponding cast shadows) is moving, and the texture distribution varies significantly across the sequences. Texture addition in all methods helps suppress the erroneous flow around the objects (and shadows) and helps preserve the motion boundaries more accurately. The fourth and the fifth sequences demonstrate multiple objects moving, where two individuals are practicing in an indoor environment
                           9
                        
                        
                           9
                           
                              http://www.youtube.com/watch?v=APDmcwT1ii4.
                         (indoor practice sequence) with a poorly-textured background in the fourth sequence, and three rolling balls
                           10
                        
                        
                           10
                           
                              http://visual.cs.ucl.ac.uk/pubs/flowConfidence/supp/.
                         (and cast shadows) are animated on a curved surface with poor texture in the fifth sequence (rolling balls sequence). For these sequences, texture addition and suppression of the background flow also helps prevent object merging, specifically for the method in [4]. Comparing ground-truth for the foreground in the third row to the magnitude of optical flow in fifth, seventh, and ninth rows, we notice that the combination of the optical flow method in [13] with texture addition provides the most accurate foreground detection for the sequences in this figure.

In Fig. 10, all sequences have multiple moving objects. The first sequence (highway sequence) shows four vehicles moving toward the camera on a highway
                           11
                        
                        
                           11
                           
                              http://arma.sourceforge.net/shadows/.
                         with poor texture, where object merging can be clearly observed. The second sequence shows an indoor sequence (basketball sequence
                           12
                        
                        
                           12
                           
                              http://vision.middlebury.edu/flow/data/.
                        ), where two individuals are playing basketball against a background with partial poor texture. The third sequence shows two unmanned aerial vehicles flying in a partially cloudy sky (UAV sequence
                           13
                        
                        
                           13
                           
                              http://www.youtube.com/watch?v=fgHjVvqLXV8.
                        ). The fourth sequence is taken from an indoor office video, where two individuals are moving against a uniform background (office sequence
                           14
                        
                        
                           14
                           
                              http://www.youtube.com/watch?v=cOyla67NMHk.
                        ). The fifth sequence is an animation in which three children are moving against a background with poorly-textured regions (playground sequence
                           15
                        
                        
                           15
                           
                              http://www.youtube.com/watch?v=GXmW6S1iVCI.
                        ). Similar to Fig. 9, texture addition in all methods helps suppress the erroneous flow around the objects (and shadows), and helps preserve the motion boundaries more accurately. Note that while combination of texture addition and the optical flow method in [13] provides the most accurate foreground detections for most of the sequences in Fig. 10, for the highway and playground sequences, it does not show the best results and is not able to prevent the object merging problem. This is due to large object displacement in both sequences. As can be seen, the method in [6] demonstrates higher accuracy and is the only method capable of preventing object merging for the highway sequence, because of considering an extra term in the error functional, which employs feature matching to handle large displacements.

To quantify the effect of texture addition on the accuracy of foreground detection, we utilized two measures that are frequently used in the literature, such as in [27] when two binary images are compared: F-measure [28] and Boundary Displacement Error (BDE) [29]. Given a specific weight α (here 0.5), we use Fα
                         to designate F-measure, which evaluates the amount of overlap between the ground-truth foreground mask and the detected foreground mask, given by:
                           
                              (19)
                              
                                 
                                    F
                                    α
                                 
                                 =
                                 
                                    
                                       
                                          
                                             1
                                             +
                                             α
                                          
                                       
                                       ×
                                       Precision
                                       ×
                                       Recall
                                    
                                    
                                       α
                                       ×
                                       Precision
                                       +
                                       Recall
                                    
                                 
                                 ,
                              
                           
                        where Precision/Recall are the ratios of the correctly detected foreground (overlapped area) to the detected/ground-truth foreground. Denoting the area of detected foreground mask and ground-truth foreground mask by A(D) and A(G), respectively, Precision is given by:
                           
                              (20)
                              
                                 Precision
                                 =
                                 
                                    
                                       A
                                       
                                          
                                             D
                                             ∩
                                             G
                                          
                                       
                                    
                                    
                                       A
                                       
                                          D
                                       
                                    
                                 
                                 ,
                              
                           
                        and Recall is given by:
                           
                              (21)
                              
                                 Recall
                                 =
                                 
                                    
                                       A
                                       
                                          
                                             D
                                             ∩
                                             G
                                          
                                       
                                    
                                    
                                       A
                                       
                                          G
                                       
                                    
                                 
                                 .
                              
                           
                        
                     

Clearly, larger values for Fα
                         indicate higher overlap between the ground-truth foreground and the detected foreground, with Fα
                        
                        =1 indicating perfect overlap.The BDE measures the average displacement error between the boundaries of two masks mentioned above. Let BD
                         and BG
                         represent the boundary point set of the detected and ground-truth rectangles, respectively. The BDE from BD
                         to BG
                        , denoted as E(D, G), is computed as the average of distances from every point p in BD
                         to its closest point in BG
                        :
                           
                              (22)
                              
                                 E
                                 
                                    D
                                    G
                                 
                                 =
                                 
                                    
                                       
                                          
                                             ∑
                                             
                                                p
                                                ∈
                                                
                                                   B
                                                   D
                                                
                                             
                                          
                                          
                                       
                                       d
                                       
                                          p
                                          
                                             B
                                             G
                                          
                                       
                                    
                                    
                                       
                                          B
                                          D
                                       
                                    
                                 
                                 .
                              
                           
                        
                     

In Eq. (21), |B
                        
                           D
                        | represents the number of points in set BD, and d(p, BG
                        ) represents the minimum Euclidean distance from p to all points in BG
                        :
                           
                              (23)
                              
                                 d
                                 
                                    p
                                    
                                       B
                                       G
                                    
                                 
                                 =
                                 
                                    
                                       min
                                       
                                          q
                                          ∈
                                          
                                             B
                                             G
                                          
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      p
                                                      1
                                                   
                                                   −
                                                   
                                                      q
                                                      1
                                                   
                                                
                                             
                                             2
                                          
                                          +
                                          
                                             
                                                
                                                   
                                                      p
                                                      2
                                                   
                                                   −
                                                   
                                                      q
                                                      2
                                                   
                                                
                                             
                                             2
                                          
                                       
                                    
                                 
                                 ,
                              
                           
                        where (p
                        1, p
                        2) and (q
                        1, q
                        2) are coordinates of p and q, respectively. E(G, D), is computed similarly. The final BDE between BD
                         and BG
                         is computed as the average of these two BDEs:
                           
                              (24)
                              
                                 B
                                 D
                                 E
                                 
                                    
                                       B
                                       D
                                    
                                    
                                       B
                                       G
                                    
                                 
                                 =
                                 
                                    1
                                    2
                                 
                                 
                                    
                                       E
                                       
                                          D
                                          G
                                       
                                       +
                                       E
                                       
                                          G
                                          D
                                       
                                    
                                 
                                 .
                              
                           
                        
                     

Smaller values for BDE indicate lower average boundary displacement between the ground-truth foreground and the detected foreground, with BDE
                        =0 indicating perfect boundary match.


                        Table 1
                         summarizes the values for Fα
                         calculated for the optical flow methods in [4,6], and [13] without and with texture addition as they are employed on all sequences used in this study. Results indicate significant improvements in preservation of the foreground boundaries if the optical flow methods are accompanied by texture addition. Comparison of Fα
                         shows 30%, 21%, and 28% more overlap on average between detected and ground-truth foreground masks for the methods in [4,6], and [13], respectively.


                        Table 2
                         summarizes the values for BDE calculated for the optical flow methods in [4,6], and [13] without and with texture addition as they are employed on all sequences used in this study. Results indicate significant improvements in preservation of the foreground boundaries (displacement error) if the optical flow methods are accompanied by texture addition. BDE comparison shows an average reduction in the Boundary Displacement Error between detected and ground-truth foreground masks by a factor of 5 to 6 for all methods.

Note that from the majority of representative results, it is expected that the method in [13] with texture addition would provide the most promising quantitative values. However Table 1 shows only marginal performance increase for [13] with respect to the method in [6] with texture addition. Moreover Table 2 shows higher BDE for the method in [13] compared with the method in [6]. As explained earlier, the reason for relatively poor performance of the method in [13] for the highway sequence and the playground sequence is large object displacement as a result of low capture rate, which can be clearly observed from both tables, given that the method in [6] is designed to handle large displacements. To have a fair comparison between competing methods with data that is not biased toward one method, we need to compare Fα
                         and BDE for the sequences in these tables other than the highway and playground sequences. New calculations for the averages over these remaining sequences show that average Fα
                         for [13] with texture and [6] with texture are 0.853 and 0.799, respectively. Average BDE for [13] with texture and [6] with texture become 0.470 and 0.623, respectively. Now, it can be seen that [13] with texture demonstrates the highest performance provided that large object displacement does not occur.

Another advantage of texture addition is the reduction in computation time. Table 3
                         displays the variation percentage (defined as the difference between computation time with texture and computation time without texture divided by computation time without texture) in the running time for all three optical flow methods as they are applied to all sequences used in this study. Computations were performed using Matlab 2011a on a processor of Intel(R) core TM i7-2670QM CPU@ 2.20GHz with 6.00GB of installed RAM. Here, two types of texture are used: stochastic, which is generated according to (11) and regular, which is taken from a texture image. The reason for considering regular texture is that as can be seen in the fourth column of Table 3, computation time for the method in [6] has increased when stochastic texture is added to sequences. This is due to considering an extra term for feature matching in the energy functional in [6] for handling large displacements. When stochastic texture is added to frames, the number of feature points detected and used in the calculations dramatically increases. Therefore, increase in the running time due to larger number of feature point detection, description, and matching will be considerably larger than the decrease in the running time due to texture addition. Accordingly, we also employed a regular texture image for all methods to investigate the difference between the effects of regular and stochastic textures on the computation time. Comparing the fourth and the fifth columns, we can see that since a regular texture (with moderate size of textons as shown in Fig. 11
                        ) does not add a very large number of feature points to each frame, computation time of [6] with texture shows reduction with respect to [6] without texture. Furthermore, reduction percentages using regular and stochastic textures for other methods exhibit only negligible differences. As a result, the texture type does not change the computation time significantly for other methods. We note that the effect of the texture type on Fα
                         and BDE variations are similarly small.

@&#DISCUSSION@&#

In this section, we discuss two remaining issues related to the algorithm suggested. First, the answer to the following question: “what is the difference between adding static texture in non-moving areas according to this algorithm with simply setting optical flow component to zero for those pixels?”; second, further discussion about the parameters used in the algorithm.

Since a major goal of our proposed algorithm is to reduce the optical flow of the background regions with poor texture, ideally to zero, one might wonder why not setting the optical flow values to zero for the static poorly-textured regions after optical flow using original frames is calculated. To answer this question, we have to go back to the technique used for rough estimation of the moving pixels. On one hand, as explained in 2.2, image differencing can provide a fast yet crude estimate of the moving pixels. On the other hand, while results of texture segmentation are satisfying, there is potential for imperfection in the final binary mask. Therefore, when TEB and FDB are combined, the mask of static poorly-texture regions is not very accurate, as can be seen in Fig. 5(b). In fact, this mask contains some false alarms as well as significant number of disjoint pixels in the background due to camera inherent noise, lighting changes, and so on. As a result, employing this mask along with the optical flow magnitude from original frames leads to a foreground mask with remarkable boundary distortions. This is shown in Fig. 12
                         for four sequences used in this study, including the laboratory sequence in Fig. 5.

As observed in this figure, employing the final mask for static poorly-textured regions in order to suppress optical flow does not yield accurate object boundaries and produces erroneous foreground blobs due to imperfection in this mask. This is while if this mask is only used to add texture to these regions, should the synthetic texture be mistakenly not added to some background pixels, due to calculation of zero flow for neighboring pixels and the effects of those pixels next to the pixel deprived of texture (as discussed in Section 2.3), optical flow can still converge to zero for this pixel. This can be viewed as the healing effect of optical flow.

To quantitatively compare the effects of our proposed algorithm with the idea of simply suppressing the optical flow for pixels in the static purely-textured regions on the foreground detection accuracy, we calculated Precision, Recall, Fα
                        , and BDE for the sequences in Fig. 12, and showed the results in Table 4
                        . Since the crude frame difference map detects even the smallest variations in a pixel's brightness, the probability of detecting all foreground pixels and subsequently the value for Recall is expected to be higher if the latter method is used. This can be seen in the fourth and fifth columns of Table 4, where Recall values for the alternative idea are either comparable or higher. This is while, our proposed algorithm shows higher Precision values due to suppressing the erroneous background flow, as discussed earlier (second and third columns). For Fα
                        , which provides a good representation of both Precision and Recall, and BDE, our proposed algorithm outperforms the alternative idea, as can be seen by comparing sixth and seventh columns and eighth and ninth columns of this table, respectively. Hence, we can claim that our method provides higher foreground detection accuracy.

The next topic is about the effects of parameters used in the algorithm section: β, γ, and SC. Effects of β on the final binary mask of image difference were extensively discussed in 2.2 and Fig. 6. Investigating multiple sequences, it was empirically found that β
                        ∈[0.01,0.04] can provide a safe range for accurate foreground detection; however, it cannot guarantee perfect application for all sequences.

Threshold for texture segmentation (γ) was adaptively determined based on the histogram of the texture energy values and was explained in 2.2 using (8), and Fig. 3. Due to its adaptive nature, γ can be more trusted over a large number of sequences.

Finally, effects of SC were studied extensively in 2.3. Since the effect of SC on the shrinkage of the foreground blobs was only qualitatively demonstrated in Fig. 8, we employed the quantitative measure of the foreground detection accuracy introduced in 3.2 using Fα
                         to further clarify selection of value SC
                        =40 for the synthetic texture intensity. Fig. 13
                         shows the effect of SC on Fα
                         for the airplane sequenced used in Fig. 8. As can be seen, beyond SC
                        =40, the accuracy of foreground detection increases negligibly, while disadvantages mentioned in 2.3 increases more tangibly. Therefore, the value of SC
                        =40 can be justified quantitatively.

The algorithm proposed herein is the first step toward solving the problem of poor texture in optical flow computation using a novel and simple, yet effective approach. As mentioned earlier, our proposed method has shortcomings, which include providing an adaptive threshold for binarizing the image differencing results and a moving synthetic texture to poorly-textured blocks within the foreground.

We have attempted to generate an accurate moving texture that does not produce erroneous flow and tested multiple strategies for this problem, but they are far from a final solution. For instance, adding a moving texture to non-textured moving regions using displacement of the feature points and interpolation for any arbitrary pixel within the moving blocks cannot be accurately performed, since rigid and non-rigid motions require different types of texture interpolations and we do not know the motion type a-priori.

The other option considered was to use the optical flow vector field itself for finding the location of the corresponding pixels in the second frame, which has two limitations. First, optical flow does not only belong to one of the frames and magnitudes have sensible errors which leads to production of the synthetic texture in the wrong location; second, it requires optical flow computation twice, which neutralizes the advantage of reduction in the computation time provided by our algorithm. We have considered these problems as future work.

@&#CONCLUSIONS@&#

In this study, we have investigated the effects of adding synthetic texture to images with poorly-textured regions on the optical flow performance, namely the accuracy of foreground boundary detection and computation time. It is demonstrated that texture addition leads to important advantages, including creation of sharp motion boundaries, more accurate capture of object contour and size, avoidance or mitigation of object merging, and reduction in the computation time. Well-known quantitative metrics have been employed to evaluate the effectiveness of combining texture addition with several leading optical flow methods on multiple real and animation sequences. Analysis of optical flow convergence supported the resulting advantages from a mathematical perspective.

@&#ACKNOWLEDGMENT@&#

The authors would like to thank Dr. Yanqiu Wang with the Department of Mathematics, Oklahoma State University, for her assistance with the analysis of the convergence for the optical flow computation, and Dr. Damon Chandler with the Department of Electrical and Computer Engineering, Oklahoma State University, for his assistance with the quantitative measures for optical flow performance.

@&#REFERENCES@&#

