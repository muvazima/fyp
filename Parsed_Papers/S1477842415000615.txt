@&#MAIN-TITLE@&#Concepts and evaluation of the extended entity-relationship approach to database design in a multi-paradigm information system modeling tool

@&#HIGHLIGHTS@&#


               
                  
                  
                     
                        
                           
                           The architecture of Multi-Paradigm Information System Modeling Tool is presented.


                        
                        
                           
                           Components supporting Extended Entity-Relationship (EER) approach are presented.


                        
                        
                           
                           The textual domain specific language named EERDSL is presented.


                        
                        
                           
                           A case study “Power Plant information system specification” is presented.


                        
                        
                           
                           We present the user evaluation of EERDSL and disseminate the results.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Entity-relationship

Domain-specific language

Model transformation

Information system design

Evaluation study

@&#ABSTRACT@&#


               
               
                  Different approaches to information system (IS) development are based on different data models. The selection of a data model for conceptual design, among other things, depends on the problem domain, the knowledge, and the personal preferences of an IS designer. In some situations, a simultaneous usage of different approaches to the conceptual database design and IS development may lead to the most appropriate solutions. In our previous research we have developed a tool that provides an evolutive and incremental approach to IS development, which is based on the form type data model. The approaches based on the Extended Entity-Relationship (EER) and class data models are broadly accepted throughout the community of IS designers. In order to support the simultaneous usage of approaches based on the form type, EER and class data models, we have developed the Multi-Paradigm Information System Modeling Tool (MIST). In this paper, we present a part of our MIST tool that supports EER approach to a database design. MIST components currently provide a formal specification of an EER database schema specification and its transformation into the relational data model, or the class model. Also, MIST allows generation of Structured Query Language code for a database creation and procedural code for implementing database constraints. In addition, Java code that stores and processes data from the database, may be generated from the class model. In this paper, we present the evaluation study of the MIST EER domain-specific language. Users' perceptions of language quality characteristics are used for the evaluation.
               
            

@&#INTRODUCTION@&#

In the last few decades, a number of information system (IS) development approaches have emerged. Some of the methods that are still in use are based on: the Entity-Relationship (ER) data model proposed by Chen [1] with its further extensions (Extended ER, EER), the relational data model [2], the form type (FT) meta-model [3], and the object-oriented model [4].

In the context of the Model-Driven Software Development (MDSD), EER and relational data models may be seen as EER and relational meta-models respectively. A database schema is expressed by means of the concepts of a selected meta-model. According to the MDSD terminology, such database schema is called a database model and it should conform to the appropriate meta-model. An EER database model conforms to the EER meta-model, while a relational database model conforms to the relational meta-model. In this paper, we use the MDSD terminology based on the four-layered architecture proposed by OMG [5]. In Fig. 1
                     , we present notions used in this paper by gray rectangles. The white rectangles represent the corresponding notions from IS design terminology. Shapes filled with diagonal stripes are notions with the same name in both MDSD and IS design terminologies. Hereinafter, the notion “EER approach” is used to express the approach to an IS or a database schema modeling based on the EER data model, while the notion “FT approach” is used for the approach to an IS or a database schema modeling based on the FT meta-model.

Throughout our previous research [3,6–8], we have developed a tool named IIS⁎Studio that provides a FT approach to evolutive and incremental IS development. The approach is purely platform independent and strictly differentiates between the specification of a system and its implementation on a particular platform. A detailed description of the FT data model and FT approach implemented in IIS⁎Studio may be found in [3,7,8]. The EER approach is broadly accepted in the community of IS designers. Therefore, we have decided to extend the IIS⁎Studio functionalities in order to support the EER approach, too. By this, we have developed: (i) a DSL for creation of EER database schema specifications, named EERDSL; and (ii) Eclipse-based tool that supports the FT and EER approaches, both providing conceptual database schema modeling. The tool is named Multi-Paradigm Information System Modeling Tool (MIST). The MIST development is based on the MDSD paradigm and Eclipse Modeling Project (EMP) tools. In MIST, FT and EER approaches may be used simultaneously. For both FT and EER database models, MIST provides transformations into a relational data model. In our previous research on database reengineering approaches [9], we have developed a transformation from a relational database model to a FT model, named relational-to-form type transformation (R2FT). In MIST, we use R2FT as a link in the chain of transformations aimed to transform an EER database model into a corresponding FT model via a relational database model. Our primary idea was to use MIST for educational purposes, such as learning about: (i) EER data model concepts and developing a database schema specification at the conceptual level; (ii) transformations of EER to relational database schema specifications; (iii) transformations of EER to class models; and (iv) MDSD approach, by means of the EER approach the students are familiar with, since it is extensively taught in the database courses. Integrated with IIS⁎Studio, MIST can be successfully used in the design and generation process of a database and application software of an IS.

In the paper, we present the architecture of MIST. It comprises several components that support conceptual modeling based on the FT and EER approaches, as well as code generation. The focus of this paper is set on the components supporting EER approach. The description of other components may be found in [3,6–9]. Since a main goal of developing MIST is to deploy it both in education and practice, we have performed evaluations of the tool so as to recognize its strengths and shortcomings. In this paper, we present the findings of the following two types of evaluation:
                        
                           •
                           First, an evaluation by example is performed. By testing the approach on various examples, we were able to iteratively improve EERDSL, model transformations and code generators. However, a weakness of such an evaluation is that it was performed by the authors of the tool.

Second, in order to perform an objective assessment of the MIST tool, we have conducted a tool evaluation with students, IS designers, and human–computer interaction experts that were not involved in the tool design and implementation.

Apart from Introduction and Conclusion, the paper is organized in seven sections. In Section 2, we describe the architecture of MIST. The EER meta-model is presented in Section 3, while the Class and Relational meta-models are presented in Section 4. Section 5 includes description of code generators. A case study that illustrates a usage of the meta-models, MIST components and code generators is set up in Section 6. In Section 7, we present key findings of conducted evaluation. In Section 8, we discuss related work.

In this section we present the architecture of MIST. Its global picture is depicted in Fig. 2
                     . MIST comprises the following components: FTDSL, Synthesis, Business Application Generator, EERDSL, EER2Rel, EER2Class, SQL Generator, Java Generator, and R2FT. In the following text, we explain each of the components from Fig. 2.

The FTDSL component allows designers to specify a platform independent model (PIM) of an IS. FTDSL comprises Ecore meta-model specification of FT PIM concepts and a textual DSL based on these concepts. With the DSL a designer may specify a database schema of an IS, business applications and their graphical user interfaces (GUIs). After an IS is specified at the PIM level, the Synthesis component is used to generate a model of a relational database schema. The Synthesis component implements an improved synthesis algorithm, as it is presented in [10]. First, the component takes a form type model and transforms it into a Universal Relation Schema (URS) specification. The concept of URS and all its benefits are presented in [10]. The synthesis algorithm takes the URS specification and produces a relational database model as an output. As FT concepts may be used to specify business applications of an IS, the MIST architecture includes a Business Application Generator component. This component takes an FT model as the input and generates Java code of a modeled business application. As the specification is enriched with GUI details, the generated application prototype may be executed and used to perform basic CRUD operations over the database.

The EERDSL component provides a conceptual specification of an IS database model. Unlike FTDSL, EERDSL is used to specify IS database models only, without specification of business applications and their GUIs. We have created both textual and graphical notations for EERDSL. The textual notation was developed using the Xtext tool [11], while the Sirius tool [12] was used to develop the graphical notation. One of the main purposes of introducing the textual notation is to provide more experienced users with a textual language and editor that they may use as an alternative and more efficient way to create their design specifications. Textual editors are also a good choice, if the Eclipse environment is unavailable. The textual notation also allows the usage of commonly used textual version control systems to provide a better collaboration inside the developer team. Most database designers, however, are using some EER graphical notation. Several different graphical notations for the EER approach exist. Here we have implemented the notation presented by Thalheim in [13]. Both graphical and textual notations may be used by a designer simultaneously, while specifying an EER database model. By this, two different viewpoints over the same model are provided in MIST. EERDSL is presented in more details in [14].

The EER2Rel component of MIST provides a transformation of an EER database model to a relational database model. Models being transformed conform to the EER meta-model and relational meta-model, respectively. The meta-models are presented in the following section. The relational database model may be further used in the process of SQL code generation. For this purpose, the SQL Generator component is developed. Currently, it provides generating SQL code for Oracle DBMS.

The EER2Class component of MIST provides a transformation of an EER database model to a class model. The class model conforms to the class meta-model presented in Section 3. The class model may be used to generate code in some of the object-oriented programming languages. Our Java Generator component is used to generate Java code from the provided class model.

In order to provide reverse engineering of the relational database model to the FT model, the R2FT component has been developed. In MIST architecture R2FT component is used as a link in the chain of transformations aimed to transform an EER database model to a FT model.

Components from the upper part of Fig. 2 are already presented in our published papers. A detailed description of the FTDSL component may be found in [15], The Synthesis component is presented in [3,8,10], while [7] and [9] deal with the Business Application Generator and R2FT components respectively. In the following text, the focus is set on the components from the lower part of Fig. 2 that are aimed at supporting EER approach.

In this section we present the EER meta-model. A diagram of the meta-model is depicted in Fig. 3
                     . Throughout the paper, the names of concepts from meta-models and models are written in italics. The EER meta-model represents the abstract syntax of EERDSL used for specifying database models at the conceptual level. The root concept in our meta-model presented in Fig. 3 is EERModel. Each EER database model comprises one or more Entities and zero or more Relationships, Gerunds, and Domains. It should be noted that graphical representations of Gerund and Attribute concepts filled with gray color represent graphical synonyms of existing graphical elements. These graphical synonyms were introduced to improve readability of the diagram. This way of representing graphical synonyms is also used in other figures in which Relational and Class meta-models are presented.


                     Entity concept is used to specify a class of observed real world entities in a IS being designed. In some approaches, the Entity concept is named as Entity Type concept. According to [13], we adopt the name Entity.

Each entity has zero or more attributes that are modeled by Attribute class. Attributes represent properties of real world entities that are of importance for the specified IS. For each attribute, a domain is specified. A domain represents a specification of possible values that can be assigned to an attribute and it is modeled using Domain. A domain must be based upon a primitive domain, such as integer, string, real, boolean, date, and time. The primitive domain is modeled by an enumeration called PrimitiveDomain. An assignment of a domain to an attribute is modeled by AttributeDomain. For each attribute, length and default value may be specified. This way of restricting domains allows their reusability. Therefore, domains may be specified once at the level of EER database model and reused and further restricted at the level of attributes. An entity may have one or more keys modeled by Key. Each key comprises one or more attributes of the entity. Only one key may be declared as the primary key. This is modeled by primaryKey association.

In the meta-model from Fig. 3, different types of relationships between entities are modeled by: Relationship, ISA, Categorisation, and IdentificationDependency. An n-ary relationship between entities is modeled by Relationship. For each entity and its relationship, a role, minimum, and maximum cardinalities must be specified. Minimum cardinality may be provided with the values of zero or one, while a maximum cardinality may be provided with the values of one or more. The entity role and cardinalities are modeled by RegularEntity. Each relationship may have zero or more attributes. IS-A relationship, modeled by ISA, represents a specialization of entities. For each IS-A relationship, a single supertype entity should be provided. This is modeled by the supertype association. Also, for each IS-A relationship, subtype entities should be provided. This is modeled by the subtype association. The categorization relationship represents a classification, i.e. a typization relationship between entities. It comprises two or more category entities, modeled by Categories, and a single categorized entity. The identification dependency relationship concept is modeled by IdentificationDependency. A weak entity is modeled by the weakEntity association, while a regular entity is modeled by the regularEntity association.

An n-ary relationship may participate as an entity in another relationship. Such relationship is called gerund and modeled by Gerund. A gerund may take a role of a regular entity in an n-ary or identification dependency relationship. Also, it may take a role of a specialized entity in a specialization, and category entity in a classification.

An example of a database model of Power Plant IS specified by means of EERDSL is presented in Section 6.1.

After an EER database model has been specified using EERDSL, it may be transformed into a relational database model or a class model. First, we present the Relational and Class meta-models used in the specification of model transformations EER2Rel and EER2Class. Second, we present two transformations: EER2Rel used to transform an EER database model into a relational database model and EER2Class used to transform an EER database model into a class model. Both transformations are specified in the ATL Transformation Language (ATL) [16]. However, here we do not present implementation details in ATL. ATL code for the most representative transformation rules is given in [17]. In this paper we only present conceptual mappings between appropriate elements from different meta-models.

In this subsection we present our relational meta-model. The root concept of the relational meta-model presented in Fig. 4
                         is Database. Each database schema comprises Tables. SystemDataTypes represent predefined data types built into a DBMS, while UserDefinedDataTypes represent user defined restrictions on existing data types. Each table comprises one or more columns, modeled by Column, and constraints inheriting the abstract concept Constraints. At the level of a relational database model, for each table, the following constraints may be specified: (i) primary key constraint modeled by PrimaryKeyCon, comprising an array of columns; (ii) unique constraint modeled by UniqueCon, comprising an array of columns having a unique combination of values; (iii) foreign key constraint modeled by ForeignKey, comprising: an array of columns, referenced table, and primary key constraint or unique constraint of a referenced table; and (iv) check constraint modeled by CheckCon, comprising a logical expression.

In this subsection we present our class meta-model. We have modeled only the most basic concepts to specify elements for a representation of data in object oriented programs. The root concept of the class meta-model depicted in Fig. 5
                         is ClassModel. All concepts are grouped into packages modeled by Package. A package comprises zero or more Classes and other Packages. Each class comprises zero or more fields, modeled by the Attribute concept, and methods modeled by the Method concept. Data types are modeled by Type. Classes and types inherit the abstract Classifier. This concept is specified in order to allow attributes and functions to have both primitive and class types as their type, and the return type, respectively. Finally, for each attribute, class, and function, an access modifier should be provided. Possible access modifier values are modeled as an enumeration, which comprises the following values: private, protected, default, and public.

Once an EER database model is specified using EERDSL, it may be transformed into the corresponding relational database model. This transformation is named EER2Rel and is a part of a MIST component with the same name. In Table 1
                        , we present at a conceptual level, transformation rules for transforming EER meta-model concepts into concepts from the relational and class meta-models. In the first two columns of the table, we present all the correspondences between the EER and relational meta-modeling concepts. Based on these correspondences, concrete ATL transformation rules are specified.

Each EER model concept may be transformed directly into a relational database concept. This transformation may be specified according to the algorithm presented in [18]. A system data type is created from EER primitive domains and for each restricted domain, a specific user-defined data type is created. Tables are created from three different concepts in EER database model: Entity, Gerund, and Relationship. All entities, gerunds, and relationships that have maximum cardinality of many on both sides (M:N) are transformed directly into tables. Some kind of primary key propagation is used in other cases. A detailed description of transformations is intentionally missed here due to the lack of space, and could be found in [18].

The transformation of an EER database model into a class model is very similar to the transformation of an EER database model to a relational database model. This transformation is named EER2Class and is a part of the MIST component with the same name. In Table 1, the first and the third column represent all of the corresponding concepts between the EER and Class meta-models. Instead of tables, classes are created, while class attributes are created instead of columns. One notable difference is the lack of the constraint concept. In the class model, primary keys are not created. It eases the transformation specification. Instead of creating foreign keys, an attribute of the referenced class type is created. If a relationship has a maximum cardinality of many, then the created attribute will represent a collection of objects that are instances of referenced classes. The other difference is in the existence of functions. For each class, a parametrized constructor is created and for each class attribute, get and set methods are created, too.

In Section 6.2 we present results of the EER2Rel and EER2Class transformations performed on Power Plant EER database model presented in Section 6.1.

In MIST, there are two types of code generators: (i) SQL generators, which take a relational database model as an input and produce SQL code as an output, and (ii) OO generators, taking a class model as an input so as to produce an object-oriented program code as an output. In the rest of the section we present implemented generators in detail.

An SQL Generator generates SQL statements for creating database tables and all basic types of constraints according to the SQL:2011 standard (ISO/IEC 9075:2011). This is generated from a relational database model in a straightforward manner. The SQL generator loads specifications of all tables from the relational database model and creates a sorted collection of all tables, in a way that each table precedes its referencing tables. This collection is a starting point of the generation of DROP and CREATE statements. DROP statements are created for each table at the beginning of a script. CREATE statements only comprise a creation of columns and primary key constraints. To avoid potential table creation deadlocks, all other constraints are added to tables after all CREATE statements have been generated. Potential deadlocks may arise when two tables have mutual references. This is the case when the constraints of one table reference the other and vice versa.

Beside the standard SQL statements, supported by most of the contemporary CASE tools, the MSIT tool supports a generation of the inverse referential integrity constrains (IRICs) code. A formal definition of IRIC may be found in [19]. For each binary relationship specified in an EER database model, after the execution of the EER2Rel transformation, a set of foreign key (referential integrity) constraints is created in a relational database model. In addition to foreign key constraints, there are several cases when IRICs are created, too. An example of an IRIC constraint is given in Section 6.3.

Widely used CASE tools for conceptual modeling of a database schema, such as CA ERwin [20], Cameo Data Modeler [21], MagicDraw SmartDraw [22], Oracle Designer [23], and Sybase PowerDesigner [24], support the specification of the existential dependency between two entity types in the conceptual database schema by setting the appropriate minimum cardinality to one. However, to our knowledge, these tools ignore this specification when the minimum cardinality is set to one at the many side of relationship. When generating the SQL code, they do not implement IRICs. According to [19], the most suitable way to implement the validation of the IRICs is at a database server instead of the middle layer. In that case, programmers are to use procedural mechanisms (procedures, functions, and triggers) or views, to manage IRICs. As a rule, the aforementioned CASE tools do not employ any procedural DBMS mechanisms to provide the automatic implementation of IRICs. Therefore, programmers must write such procedural code by hand.

As the implementation of IRICs requires the use of the procedural code, different generators are needed for each target DBMS. MIST currently supports generation of the PL/SQL code for Oracle DBMS. The generator is implemented in Xtend [25]. We chose Xtend as it offers a good balance of a procedural language that we used for processing of an input relational database model, and a template language that we used for code generation. Procedural code elements are implemented according to the templates presented in [19]. The code excerpts from the SQL Generator, as well as the examples of the generated SQL script and trigger code for a selected part of Power Plant IS are presented in Section 6.3.

We have also implemented an OO generator for Java programming language in Xtend. Our Java code generator provides the generation of Java classes from the class model. As each class in a class model comprises information about its fields and methods, Java generator maps all of these concepts directly to the Java syntax. Generated Java classes are used in Java programs for storing loaded data from a database. Due to the simplicity of the generated Java code, we do not present it in this paper. An example of a generated class may be found in [17].

In this section we introduce a case study of Power Plant IS in order to illustrate concepts, data models, transformations, and code generators described in Sections 2–5.

In this subsection we present a part of a Power Plant IS database model, named PowerGeneratorSystem, responsible for storing data about power generators in a power plant facility. Due to complexity of the example, we present in detail only a subsystem that stores data about renewable energy source power generators alongside with basic characteristics of fossil fuel generators. Modeling concepts are presented by a textual and graphical notation of EERDSL.

In Fig. 6
                        , we present PowerGeneratorSystem specified by means of a textual notation of EERDSL. Due to the length of a textual specification, we do not present repetitive constructs. In Fig. 7
                        , we present a graphical specification of the same example.

Power plant facilities are modeled by an entity named Facility. Each facility may contain one or more power generators that produce electrical energy. General characteristics of a power generator are modeled by the PowerGenerator entity. Further, power generators may be classified as generators that use renewable energy sources (RenewableEnergyGenerator entity) and generators that use fossil fuels to produce electrical energy (FuelGenerator entity). A fuel generator uses one or more fossil fuel types to produce electrical energy. Fossil fuel types are modeled by FuelType entity. In contrast to fuel generators, renewable energy generators are designed to utilize exactly one renewable energy source in order to produce electrical energy. Types of renewable energy sources are modeled by the RenewableEnergyType entity. Renewable energy generators may be located at exactly one physical location (Location entity).

For each renewable generator, produced power is measured (ProducedPower entity). However, as there may be multiple measurements of the different renewable energy generators at the same time, produced power may be uniquely identified by the measurement time only in the scope of a particular generator. For a performance analysis of renewable energy generators, it is important to store information about weather conditions at the time of the produced power measurement. This is modeled by the WeatherCondition entity. Similarly to the produced power measurement, each measured weather condition may be uniquely identified by the time of measurement only in the scope of a single location. In addition to the weather condition data, IS must keep track of a season of the year during which the measurement took place. A season of the year is modeled by the Season entity.

In Fig. 8
                         we present results of the EER2Rel and EER2Class transformations performed on the Power Plant EER database model presented in the previous subsection. In the leftmost part of the figure, the aforementioned database model is opened with Eclipse “Sample Reflective Ecore Model Editor”. This database model is the input model for both EER2Rel and EER2Class transformations. In the reminder of this section we present results of both transformations in more detail.

A relational database model, representing an output of EER2Rel, is presented in the middle of Fig. 8. Each of EER database model entities is transformed into a table with the same name. For example, the PowerGenerator entity is transformed into the PowerGenerator table. Four columns of this table: generatorId, generatorMinPower, generatorMaxPower, and generatorType, are created from corresponding entity attributes with the same name. The fifth column, facilityId, is a foreign key column referencing the facilityId column of the Facility table. This is a result of the FacilityGen relationship transformation. As the maximum cardinality of the PowerGenerator entity in this relationship is one, during the transformation, primary key columns of the Facility table are propagated to the PowerGenerator table. Therefore, the facilityId column is created in the PowerGenerator table and is referenced as a foreign key column in the FK_PowerGenerator_Facility foreign key. Further, from the PK_generator key in the PowerGenerator entity, a primary key named PK_PowerGenerator is created in the PowerGenerator table. All the references between the key and attributes in the EER database model are preserved in a form of references between the primary key and appropriate columns in the relational database model. For the space reasons, these references of the primary key are not shown in Fig. 8. The rest of entities from the EER database model are transformed into tables in the same way, with an exception of RenewableEnergyGenerator and FuelGenerator entities. Both entities have a role of subtypes in the IS-A specialization relationship. As such, they are not required to have any attributes or the primary key on their own, as they have the same key as the supertype (PowerGenerator) in the same relationship. Therefore, tables created from these entities have the generatorId column created from a primary attribute of PowerGenerator. In addition to creating this column, the corresponding primary key and foreign key constraints are also created in the RenewableEnergyGenerator and FuelGenerator tables. The rest of the columns and foreign key constraints from the RenewableEnergyGenerator table, presented in Fig. 8, are created from binary relationships of the RenewableEnergyGenerator entity. The FGFuelType table is created from the relationship with the same name, as it has maximum cardinalities of many at both ends. The FGFuelType has generatorId and fuelId columns representing foreign keys that reference primary keys of FuelGenerator and FuelType entities respectively. Both columns are a part of the same primary key constraint named PK_FGFuelType. Appropriate foreign key constraints for aforementioned columns are also created.

The output of EER2Class is presented in the rightmost part of Fig. 8. From each entity, a class is created with the same name. For example, from the PowerGenerator entity, the PowerGenerator class is created. From each entity attribute a class field with the same name is created. These fields are of primitive types, which correspond to domains of entity attributes. The facility class field is created from a relationship FacilityGen connecting Facility and PowerGenerator. As the maximum cardinality on the PowerGenerator side is one, this field is created. The type of this field is of the PowerGenerator class. Types of the class fields may be seen in the property pages of the Eclipse editor. However, due to a large amount of space it would take to display, we chose not to present them. The rest of the entities are transformed into tables in a similar, straightforward manner. Unlike the relational meta-model, the class meta-model has a notion of inheritance. Therefore, the RenewableEnergyGenerator class does not contain attributes from PowerGenerator. Instead, it just inherits the class and adds its own attributes. Also, due to the space limitation, we are not presenting this class in the figure. For each class, a parametrized constructor is created. Furthermore, get and set methods are created for each attribute in a class. For each method, a body is automatically generated in a form of a string.

In Fig. 9
                        , we present an excerpt from the SQL generator which is applied to the relational model presented in Fig. 8. Due to the space limitation, we present only several representative functions. The initialize() function is called only once in order to sort database tables based on the number of references to other tables. For the creation of DROP TABLE statements, tables in the tablesInv collection must be sorted from the most referenced table to the least referenced one. The tables collection contains data sorted in the reverse order from the tablesInv collection. This collection is used for the generation of CREATE TABLE statements. The generate(Database db) function is a root function that generates SQL script from a relational model. First, it calls the generateDrops(Table t) function to generate DROP TABLE statements for each table in the tablesInv collection. Next, for each table in the tables collection, CREATE TABLE and ALTER TABLE statements are generated by calling generate(Table t) and generateAlter(Table t) functions. Each column of a table is generated by calling the generate(Column c) function from generate(Table t). Both generate(Table t) and generate(Column c) functions are presented in Fig. 9. They consist of a template parametrized with field values of a table or column argument respectively. It should be noted that we have created the fixName(String name) function that replaces any Oracle DBMS reserved words with valid names. This function is created since users may specify “Date” as an entity name in an EER model. As this is an Oracle DBMS reserved word, the function would change such name to “_Date”. This function also limits name strings to 30 characters as it is also a requirement of Oracle DBMS. Finally, the generateInverse(ForeignKey fk) function is called. It generates functions, triggers, packages, procedures, and functions needed to generate IRICs. These functions are not presented as they consist of templates that are very similar to the ones in presented functions.

In Fig. 10
                         we present the output of the SQL generator for the example presented in Fig. 9. The PowerGenerator table has a foreign key constraint referencing the Facility table.

In addition to creating foreign key constraints, there are several cases when IRICs are created, too. Let us consider the FacilityGen relationship in Fig. 7. It is represented in the relational database model by the PowerGenerator table, its column facilityId and the foreign key constraint FK_Power Generator_Facility (Fig. 8). The minimal cardinality on the Facility side is one, since a power energy facility must have at least one power generator, while the maximum cardinality is many since it can have more than one power generator. This cardinality indicates the existential dependency between a facility and its power generators. To model such a constraint in the relational database model, an IRIC must be created for the foreign key constraint of PowerGenerator table referencing Facility table. In a relational database model it is represented by setting a value of ForeignKey inverseReferentialIntegrityCon property to true. The meaning of such constraint specification is that in order to insert a row in the table with a foreign key constraint, at least one row must exist in the other table. A trigger to implement this IRIC is presented in the right part of Fig. 10.

During and after the development of MIST, we have tested the tool on various examples. One of these examples, Power Plant IS, is presented in this paper, while the Student Service IS example is presented in [17,14]. The main drawback of the evaluation by example is that it is performed by the authors of the tool and therefore may be biased. The authors are familiar with MIST implementation details and are aware of the tool advantages and shortcomings. In order for this tool to be used in practice and education, it must be also evaluated by other users. We also performed this type of evaluation and in the following subsections the objective, hypothesis, preparation, execution, threats to validity, and results of the experiment are presented.

EERDSL represents the entry point of the EER approach in MIST. Therefore, we wanted to evaluate EERDSL as it affects user experience the most. The objective of this experiment is to evaluate EERDSL by analyzing user perception of a chosen subset of DSL quality characteristics presented in [26]. As our goal is to make EERDSL usable in practice and education, experiment participants evaluated the following characteristics: (i) functional suitability – the degree to which a DSL supports developing solutions to meet stated needs of the application domain; (ii) usability – the degree to which a DSL can be used to achieve specified goals; (iii) trustworthiness (reliability in [26]) – the property of a language that aids producing reliable programs (model checking ability); (iv) expressiveness – the degree to which a problem-solving strategy can be mapped into a program naturally; and (v) productivity – a characteristic related to the amount of resources expended by a user to achieve specified goals.

In order to perform the evaluation of EERDSL, a questionnaire has been prepared. Based on the user evaluation of EERDSL collected using the questionnaire, we investigate the following hypothesis:

H1
                           null
                        
                     

EERDSL can be used in practice and education as it fulfills all of the following quality characteristics: functional suitability, usability, trustworthiness, expressiveness, and productivity.

H1
                           alt
                        
                     

EERDSL cannot be used in practice or education as it does not fulfill one of the following quality characteristics: functional suitability, usability, trustworthiness, expressiveness, and productivity.

Experiment participants were chosen based on several criteria. The first criterion was that a participant must not be familiar with the implementation details of EERDSL. A user which is familiar with the implementation details tends to avoid features that are not working properly. Therefore, aforementioned criterion was established so as to have an unbiased evaluation. Second, we selected the participants to fit one of the following three categories: (i) human–computer interface (HCI) experts, that could provide most valuable feedback on visual aspects of EERDSL, (ii) IS design experts, providing valuable insight into appropriateness of the EERDSL for a database model specification, and (iii) students, providing feedback needed for a successful application of the tool in education. From 16 participants that evaluated the approach, 2 were HCI experts, 3 were IS design experts, and 11 were students. Of 11 students, 6 were MSc students studying database courses at Faculty of Technical Sciences of the University of Novi Sad, while 5 were PhD students with some experience in designing a database schema.

All participants evaluated the tool in a same, controlled environment. The evaluation was performed in our office, on a single computer, one user at a time. First, we provided a brief introductory presentation to all participants which contained information about the experiment, tasks they had to perform, and the tool tutorial. In this tutorial we implemented an example comprised of two entities and a single relationship between them. The tutorial example was implemented by simultaneously using the textual and graphical syntax. Also, we explained syntax and semantics of all EER concepts to the participants lacking previous experience with EER modeling. The tool tutorial and the explanation of the EER concepts were provided to the participants in a form of a written document. It should be noted here that both HCI experts decided to skip the tutorial as they wanted to test the intuitiveness of the tool when it is used without previous explanations.

After the tutorial, all participants were asked to implement the same, already prepared example (Student Service IS) using both textual and graphical notations of EERDSL. Different implementations were possible based on the participants' experience. An average implementation comprised 12 entities, 10 relationships, and 30 attributes. All EER concepts were to be used in order to implement the example correctly. The functional requirements for the IS were formally defined on a single A4 page that was provided to the participants at the beginning of the evaluation. Although the requirements were strictly defined, we did not introduce any constraints on the time in which the participants need to finish the task and the participants had full freedom in specifying this model at their own pace. Further, the focus was on the interoperability between the two notations and not on comparison of the time participants need to specify models with each notation. Therefore, we tested only the user's perception of the tool.

We were present in the room during the entire experiment and we answered all questions. However, we did not interfere with the experiment in any other way since we only communicated with users when asked a question.

After having finished the practical work, the participants were asked to fill in a questionnaire. The questions were grouped into three sections: (i) questions about previous experience, (ii) questions about DSL quality characteristics, and (iii) a free comment section. In the first questionnaire section, the participants were asked to provide information about their previous experience in IS modeling and using other, more or less similar CASE tools. These questions are presented in the Experience section of Table 2
                        . For each question, the participants could mark one answer from a typical five-level Likert scale in which answers ranged from 1. Inexperienced to 5. Experienced. The second part of the questionnaire provides an evaluation of five DSL quality characteristics: functional suitability, usability, trustworthiness, expressiveness, and productivity. For each characteristic, several statements are provided, each covering one aspect of the characteristic as defined in [26]. These statements are also presented in Table 2, with each DSL characteristic having a separate section with statements related to its aspects. Users were able to define to what level our tool fulfilled these statements by marking one of the five answers ranging from 1. Strongly disagree to 5. Strongly agree. Based on the participants' choices for each quality aspect, we calculated if a whole quality characteristic was satisfied by EERDSL. Only the questions about the productivity characteristic did not follow the aforementioned Likert scale. As the participants evaluated the time needed to create an EER data model specification with EERDSL, answers ranged from 1. Long to 5. Short. Finally, the questionnaire has a free comment section for the participants to write their comments and remarks not covered by questions. This section was of great help for the interpretation of the participants' answers.

The questionnaire was not anonymous as we wanted to have a possibility to contact the participants in case we needed further explanations about their answers. Each participant had to enter their name and a contact e-mail address. We guaranteed that all the data would be anonymized and not given to any third-party. All of the participants were informed about the terms and they agreed with them, finishing the experiment successfully.

In Table 2 we present the results of EERDSL evaluation. For all the questions in the table, we present a percentage for each answer. This information represents the percentage of participants that chose the answer. We have evaluated the EERDSL characteristics by analyzing these data. In the rest of this subsection, we disseminate the results.

EERDSL is characterized as functionally suitable by a large majority of participants. They recognized that EERDSL covers most of the concepts from the domain and that it is suitable for data model specification needs. The participants did not write any specific comments in the free comment section about this quality characteristic.

The usability of EERDSL has been described as positive by a majority of the participants according to answers about each aspect of the characteristic. However, some of the participants wrote comments in regard to this quality characteristic. More specifically, objections were directed towards the graphical notation of EERDSL. A few participants from all three groups described the behavior of the graphical syntax as a major shortcoming. Although all participants stated that they like the appearance of graphical symbols, they agree that layouting, element filters, element moving, and element renaming mechanisms have to be improved. For the development of graphical syntax we used Sirius framework in Eclipse. As it is a framework for rapid prototyping of the graphical editors for DSLs, a large degree of customization cannot be easily achieved. We feel that this is a main reason behind these negative comments and it provides an answer to the statement about graphical symbols.

EERDSL has been described as trustworthy by a large number of participants. All participants agreed that EERDSL protects users against making syntactical errors, and shows understandable messages if a user has made a semantic error. Error messages are described as helpful in showing the cause of the error.

The expressiveness of EERDSL has been described as positive overall, with some comments from IS design experts. The objection is related to a mapping of a program solving strategy to a specification. Currently, in the MIST tool, the whole IS needs to be specified with a single EER database model. IS design experts feel that this way of modeling may represent a problem for large and complex systems. They suggest that, by separating a single EER database model specification into smaller parts, a designer could tackle more complex problems with ease. Further, once all of the data model parts are specified, integration algorithms are needed.

Finally, the participants feel that the time needed for a specification of a database model using EERDSL ranges from relatively short to medium. As answering this question requires previous experience with similar tools and other IS designing techniques, most important answers are the ones from IS design experts. All three of them selected ”short” or ”relatively short” specification time. ”Long” specification time was selected by several students. However, the participants said that the biggest contributor to the productivity of our approach is the textual notation of EERDSL that allows fast specification of database models.

We have calculated Spearman's rank correlation coefficient [27] between all questions in the questionnaire. We used the R tool [28] to perform these calculations. The only interesting correlation coefficients we have found are related to the question regarding the time needed for EERDSL database model specification (productivity category). In Table 3
                        , we present correlation coefficients with the corresponding p-values for each question related to the question about the time needed for an IS specification. The larger value of the correlation coefficient means that there is a stronger correlation between two related questions. However, only for correlations with a p-value less or equal to 0.01 we may state that the correlation is statistically significant. In our opinion, the data in Table 3 shows that participants who see the syntax as understandable, like the appearance of textual syntax, or think that there is only one good way to express every concept also feel that EERDSL reduces the database model specification time. We do not present other large calculated correlation coefficients due to the following reasons. First, we recognized large coefficients for a lot of trivial correlations. For example, for the most categories, questions within a category are correlated with a large coefficient and a p-value less than 0.01. This is to be expected since these questions cover the same quality characteristic and the answers should be correlated if users answer these questions honestly. Other questions were correlated with a large coefficient but had a p-value larger than 0.1. This makes these correlations statistically insignificant and therefore we do not present them in this paper.

Based on the evaluation results presented in Table 2, we may conclude that EERDSL satisfies the following characteristics: functional stability, usability, trustworthiness, expressiveness, and productivity. Therefore, we may accept the H
                           null
                         hypothesis introduced in Section 7.1. However, we feel that the tool can be further improved according to the participants' comments. Some of the major participant objections concern the editor for graphical notation and inability to create partial database models. We are fully aware of these weaknesses of the tool, and in the future we plan to address them first.

In order to evaluate other quality characteristics from [26], such as maintainability, extensibility, reusability, and integrability, participants must be aware of implementation details of EERDSL. As one of the main participant selection criteria was that participants are not familiar with the EERDSL implementation, these properties may be only evaluated by the authors of the approach. In the rest of the section we present a short evaluation of the implementation-specific DSL quality properties.

Maintainability, as it is defined in [26], comprises modifiability and low coupling of DSL components' subcategories. Adding a new feature to EERDSL does not degrade the existing DSL functionality. However, modifying the existing concept in the EER meta-model may require some manual changes in the textual and graphical syntax plug-ins. This is a consequence of a tight coupling between EERDSL components and inability of the framework to automatically propagate all changes. This may lead to slower overall EERDSL modifications. Extensibility is defined as a mechanism for a user to add new features to a DSL. EERDSL does not have any extension points available to a user. All modifications have to be done by the authors as there is no need for a user to extend a DSL for IS development. Similarly, we have not specified any reusability mechanisms that would allow users to extend or reuse parts of EERDSL to create new languages. Integration of EERDSL is already achieved by using model-to-model transformations. This allows the language to be easily integrated with other languages in an IS development process.

We followed the approach given in [26] and tried to minimize the threats to validity of our study. However, there are some possible threats to be discussed.

The complexity of the task performed by the participants is a threat to the external validity of our experiment. An outcome could be different if we asked the participants to implement a different example using our tool. The example was designed with a purpose to cover basic concepts of EER and allow both experienced and inexperienced participants to evaluate EERDSL in a reasonable amount of time. We acknowledge that choosing another more or less complex example could lead to different evaluation results. Although we have provided a written document containing the tutorial and EER concepts description, all participants were allowed to ask us all their questions. We acknowledge that some of the participants may have received more detailed explanations than others, as they asked more questions.

Another external threat lies in the statistical significance of our evaluation. We were not able to assemble enough people to create homogeneous groups with the same number of people and with the same average level of expertise. Also, we have only selected 16 participants to evaluate our tool due to the short time we had to perform the evaluation, analyze the results, and disseminate them in this paper. We do not know to what extent the results of this evaluation could be changed if we had more participants evaluating the tool. We also do not know to what extent the results could be changed if we had a different participant group structure. Therefore, this may be an internal threat to our experiment.

@&#RELATED WORK@&#

This paper is an extension of the conference paper [17] where the focus was on MIST components providing EER2Rel and EER2Class transformations. In this paper, particular attention is paid to the evaluation of the EER approach supported by MIST. In contrast to the conference paper [17], where the tool was evaluated only on an academic example, in this paper we evaluate it on a larger and more complex industrial example. In addition to the evaluation by example, we also present findings of an evaluation of our tool that we conducted with 16 participants. In this paper, we also present code generators in more detail. The Related Work section is improved to give an overview of other transformation approaches between different data models. Also, in the same section, we present papers dealing with EER approach and possible fuzzy and temporal extensions. The work presented in these papers overlaps with our work to some point, but also provides us with some new ideas for future improvements of our tool.

In [14], we presented the abstract and concrete EERDSL syntaxes in detail. Also, there we presented language constraints specified by Object Constraint Language (OCL) [29]. It should be noted that EERDSL was developed in accordance with the methodology and approaches presented in [30–33]. In contrast to [14], here we consider EERDSL just as a part of the EER approach in the MIST tool. In Section 6 we only present an example of EERDSL usage and not the details of its construction.

From the time when Chen proposed ER data model in [1], many papers were published discussing the ER data model, its features, extensions, and potentials for practical applications. We found only one paper presenting EER data model implementation in the Eclipse environment using MDSD principles. In [34], the authors present EER meta-model and the EERCASE tool based upon it. The tool provides all of the EER concepts covered by Elmasri–Navathe's graphical notation [18].

Although it has been used for nearly four decades, the EER data model is still the subject of research efforts. Amalfi et al. [35] describe mapping of EER schema to Answer Set Programming that allows the generation of informative examples of the relational database that is implied by a conceptual database schema. These informative examples are very important for people involved in the requirement specification and the analysis phase of IS design. Cali et al. [36] address the problem of answering conjunctive queries under constraints of the EER database model. Chen recognized the difficulty by pointing out the inability of the existing modeling techniques to cope with fast-varying world states and in [37] proposes extensions of EER to enable active conceptual modeling. Combi et al. in [38] address the capturing of temporal constraints and propose temporal EER extensions. Zhang et al. [39,40] propose a description logic approach for representing and reasoning on fuzzy ER models and implement the corresponding model transformation FER2FDLR. Ordonez et al. in [41] cope with the problem of relational queries in a data mining project that create many temporary tables (static) or views (dynamic), which are not represented as entities in the existing ER model. In the paper, they classify potential database transformations, extend an ER diagram with entities capturing database transformations and introduce an algorithm which automates the creation of such extended ER model. These results motivate our future research towards extending our EER meta-model with some of the aforementioned extensions of the EER data model. Besides, results presented in [42,43] are convergent with our research efforts according to data models meta-modeling and integration of these approaches may be the subject of our future research.

A need to share the existing data sources and, consequently, provide the interoperability at the level of conceptual models, became increasingly important. There are numerous references covering the issue of database model interoperability and approaches for database model transformations. In the paper [44], Eessaar explains why it is advantageous to create a meta-model of a data model. He demonstrates that the meta-model could be used in order to find similarities and differences between other data models. An approach to transformations and meta-model comparisons between data models like (E)ER, the class model and Object Role Model (ORM(2) [45]) is presented in [46], but it focuses on mappings of the respective graphical elements of data models.

Research work on database model transformations can be broadly classified as unidirectional model transformation algorithms and multi-model (multi-language) transformation algorithms. Lano and Kolahoduy-Rahimi in [47,48] propose a unidirectional model transformation algorithm from UML to a relational database model transformation. A solution that provides a normalized relational database from legacy COBOL files is presented in [49]. Franceschet et al. propose a mapping from the EER conceptual data model to the W3C XML schema language [50]. Xu et al. use the EER model to construct domain ontology and semantic web services efficiently and effectively. In [51] they present transformation rules from ER to the Web Ontology Language (OWL) and OWL-S (semantic markup language for web services, built on the top of the OWL). One more example of a unidirectional model transformation is presented in [52]. Karanikolas and Vassilakopoulos demonstrate that a database modelled by ER diagrams can be directly expressed to the CUDL Abstraction Level (CAL), the data model corresponding to the Conceptual Universal Database Language (CUDL), by a set of rules for direct transformation of ER diagrams to CAL. Results presented in [53] may be also classified as unidirectional. Goggola has employed UML as a meta-description language to describe two classical data models: EER and the relational data model and to specify transformations between database schemas and database states. A design decision to represent transformations as classes together with appropriate associations does not impose any transformation direction. The transformation is a relationship between syntactical elements, like pairs of database schemas (intensional view), and semantical elements, like pairs of database states (extensional view). Forward and backward engineering techniques are covered in principle by this direction-neutral design.

Multi-model transformation algorithms that are mediated by: a dictionary of common terms [54–56], a hypergraph data model [57], or a description logic language [42,43,58] we consider as important types of model transformations in the context of our approach. All of these approaches represent a different viewpoint on the transformations implemented in this paper. These approaches also provide us with additional details that we may use in the future to get more optimized and better transformations.

Similar to the tool presented in [34], our tool is also integrated with the Eclipse environment, so as to provide beginners with an easy to use tool as they are already familiar with the environment. The EERDSL component of our tool provides all concepts from the EER approach. However, unlike the tool presented in [34] that uses the Elmasri–Navathe's graphical notation, in EERDSL all concepts are represented with the widely used graphical notation presented by Thalheim in [13]. Apart from the graphical notation, provided by all of the aforementioned tools, our tool also provides EER modeling with a textual notation. Similarly to the aforementioned tools, our tool also supports generation of SQL and Java code from an EER database model. Additionally, our tool allows generation of the procedural code for implementation of the inverse referential constraints. Currently, only a generation of PL/SQL code is provided.

There are numerous Computer Aided Software Engineering (CASE) tools supporting EER approach, such as PowerDesigner [24], ERWin [20], SmartDraw [22], Oracle Designer [23], or Cameo Data Modeler [21] for MagicDraw. These are the mainly commercial and widely used CASE tools. As such, they provide a proprietary graphical notation for EER, usually supporting only selected concepts. In contrast to the aforementioned CASE tools, EERDSL provides all of the theoretical EER data modeling concepts. Our tool also supports data modeling using the textual notation. EERDSL is the component of the MIST tool that also provides modeling based on FT concepts. To the best of our knowledge, MIST is the only tool that supports the usage of the FT concepts.

The experiment presented in this paper is based on the guidelines and experiments presented in [59,60]. Although we only evaluated a DSL and have not compared it to any GPL like the authors of the aforementioned papers, the way of experiment preparation, execution, and the dissemination of the results was greatly influenced by these papers. Authors of [61] perform an evaluation of the usability characteristic of a DSL. We also evaluate the usability of EERDSL, but we feel that other quality characteristics presented in Section 7.1 have to be evaluated to get a better understanding of users' perception of a DSL. In [62], authors also evaluated usability of a DSL based on a comparison of a textual and graphical notations of the DSL. In addition to such a comparison, we investigate interoperability of the two notations as we feel that it is an important aspect of MIST. In [63], the authors present an evaluation of three different notations of a single DSL for a scenario-based test specification. The DSL notations are evaluated based on the following criteria: clarity, completeness, conciseness, expressiveness, generalizability, practicality, and scalability. Although we a covered part of these aspects in the part of our questionnaire related to textual and graphical notations of EERDSL, generalizability and scalability are not covered. We plan to cover these aspects in a future evaluation of EERDSL notations.

@&#CONCLUSION@&#

During our previous research we developed FT components for our Multi-Paradigm Information System Modeling Tool (MIST). These components provide specification of an IS database schema, business applications and their graphical user interface elements. However, designers widely use EER approach for database schema modeling. Therefore, we provided MIST components supporting EER approach, to offer designers a choice between the two alternative conceptual level approaches to create IS specifications at the platform independent level. Due to this extension, MIST currently supports several model-to-model transformations enabled by EER2Rel, EER2Class, and R2FT components. An IS designer may select the data model that is most appropriate for the problem domain, or their knowledge and preferences.

We also use our MIST tool extensively in database courses to assist students in better understanding basic concepts of EER and the rules of EER to relational database model transformations. In addition, students find it very useful in our courses on domain-specific languages and model driven software development, as they may familiarize themselves with new concepts using well-known EER concepts.

In the paper we present and discuss the results of two evaluations of MIST tool. First, an evaluation by example is performed. In order to provide an easier use of the tool by IS designers and students we also performed an evaluation that included other users not familiar with the tool implementation details. The results of such evaluation showed that EERDSL has satisfied its intended purpose. Yet it can be further improved according to the participants' comments. Therefore, we may conclude that the MIST tool prototype is ready to be used in the database and MDSD courses. This should provide us with more practical experience and user feedback, allowing further improvements of the tool and new lessons learned.

Several future research directions are possible, including a specification of MIST meta-models semantics and new features of the MIST tool. In order to formally specify semantics of our meta-models, one of the approaches presented in [64] should be used. This could allow us to fully automate the construction of tools supporting our language. Next, an implementation of EER2FT and FT2EER transformations would allow transformations from one to another conceptual level specification. In addition, the extension of EERDSL with new concepts will allow more detailed specifications of database models. These new concepts would provide new constraint specifications at the conceptual level. For example, formal specification of database check constraints at the level of a EER database model is in many approaches poorly supported, or not supported, at all. As we already provide a conceptual specification of the check constraint at the level of FT models, we plan to create the appropriate formalisms for its specification at the level of EER database model, too. Also, the participants noted several issues concerning layouting, moving, and filtering elements that would require further customization of the Sirius-based graphical editor. One of the future directions may be to develop a fully custom editor using the Standard Widged Toolkit (SWT). Further improvement concerns a specification of database model parts and their integration into one, unified, database model. This would tackle the complexity of creating a database model, however it would require further customization of the language and creation of new algorithms for integration. After all of the improvements will be done, a new evaluation study will be performed. In such an evaluation, we will try to mitigate threats to validity presented in this paper. Also, we plan to measure more reliable data, such as the time needed for task completion. This will provide valuable information about task complexity and tool performance.

@&#ACKNOWLEDGEMENTS@&#

Research presented in this paper was supported by the German Exchange Service and Ministry of Education, Science and Technological Development of Republic of Serbia as a part of the bilateral project called “Discovering Effective Methods and Architectures for Integration of Modeling Spaces with Application in Various Problem Domains”, 2014–2015.

The research is also partially supported by the Ministry of Education, Science and Technological Development of Republic of Serbia, Grant III–44010: “Intelligent Systems for Software Product Development and Business Support based on Models.”

We would also like to thank all the participants of the experiment for their time, patience, and useful comments that made this paper better. Also, we would like to thank Marko Knežević from University of Novi Sad, Faculty of Technical Sciences for his help in the analysis of evaluation results.

@&#REFERENCES@&#

