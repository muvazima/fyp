@&#MAIN-TITLE@&#Guided macro-mutation in a graded energy based genetic algorithm for protein structure prediction

@&#HIGHLIGHTS@&#


               
                  
                  
                     
                        
                           
                           Graded energy-model strategically mixes the 20×20 MJ potential matrix with 2×2 HP energy model.


                        
                        
                           
                           HP guided macro-mutation operator within GA provides efficient sampling.


                        
                        
                           
                           Proposed Algorithm outperformed other state-of-the-art approaches.


                        
                        
                           
                           Splits the energy function related complexities into two less complex functions through macro-mutation operator.


                        
                     
                  
               
            

@&#KEYPHRASES@&#




                     Ab initio protein structure prediction

Genetic algorithms

FCC lattice

Miyazawa–Jernigan model

Hydrophobic-polar model

@&#ABSTRACT@&#


               
               
                  Protein structure prediction is considered as one of the most challenging and computationally intractable combinatorial problem. Thus, the efficient modeling of convoluted search space, the clever use of energy functions, and more importantly, the use of effective sampling algorithms become crucial to address this problem. For protein structure modeling, an off-lattice model provides limited scopes to exercise and evaluate the algorithmic developments due to its astronomically large set of data-points. In contrast, an on-lattice model widens the scopes and permits studying the relatively larger proteins because of its finite set of data-points. In this work, we took the full advantage of an on-lattice model by using a face-centered-cube lattice that has the highest packing density with the maximum degree of freedom. We proposed a graded energy—strategically mixes the Miyazawa–Jernigan (MJ) energy with the hydrophobic-polar (HP) energy—based genetic algorithm (GA) for conformational search. In our application, we introduced a 2×2 HP energy guided macro-mutation operator within the GA to explore the best possible local changes exhaustively. Conversely, the 20×20 MJ energy model—the ultimate objective function of our GA that needs to be minimized—considers the impacts amongst the 20 different amino acids and allow searching the globally acceptable conformations. On a set of benchmark proteins, our proposed approach outperformed state-of-the-art approaches in terms of the free energy levels and the root-mean-square deviations.
               
            

@&#INTRODUCTION@&#

Protein folding, by which the primary protein chain with amino acid residue sequence folds into its characteristics and functional three-dimensional (3D) structure in nature, is yet a very complex physical process to simulate (Morowitz, 1968; Stouthamer, 1973; Alberts et al., 2002). Once the folded 3D shape is available, it enables protein to perform specific tasks for living organisms. Conversely, misfolded proteins are responsible for various fatal diseases, such as prion disease, Alzheimer's disease, Huntington's disease, Parkinson's disease, diabetes, and cancer (Smith, 2003; Dobson, 2003). Because of these, protein structure prediction (PSP) problem has emerged as a very important research problem.

Homology modeling, threading and ab initio are the broad categories of available computational approaches. However, while homologous template is not available, ab initio becomes the only computation approach, which aims to find the three dimensional structure of a protein from its primary amino acid sequence alone such that the total interaction energy among the amino acids is minimized.


                     Ab initio computational approach for PSP is a daunting task (Dodson, 2007) and for modeling the structure on a realistic continuum space such as off-lattice space is even more daunting. However, there are several existing off-lattice models such as Rosetta (Kaufmann et al., 2010), Quark (Xu and Zhang, 2012), I-TASSER (Lee et al., 2009), and so on which map the structures on the realistic continuum spaces rather than using discretized on-lattice spaces and hence, those approaches need to deal with the astronomical data-points incurring heavy computational cost. On-lattice model on the other hand, (i) due to reduced complexity helps fast algorithms developments and (ii) widens the scope as well as permits relatively longer protein chains to examine, which is otherwise prohibitive (Miyazawa and Jernigan, 1985; Berrera et al., 2003; Lau and Dill, 1989; Cooper et al., 2010; Das and Baker, 2008; Wroe et al., 2005). The computed on-lattice fold can be translated to off-lattice space via hierarchical approaches to provide output in real-space (Hoque et al., 2005, 2010, 2011; Iqbal et al., 2015). The Monte Carlo (MC) or, Conformational Space Annealing (CSA) used in Rosetta can be replaced with better algorithm developed using on-lattice models (Hoque et al., 2005, 2010, 2011). For instance, we embedded one of our previous on-lattice algorithm (Hoque et al., 2011) within Rosetta and the embedded algorithm improved (Higgs et al., 2012a) the average RMSD by 9.5% and average TM-Score by 17.36% over the core Rosetta (Kaufmann et al., 2010). Similarly, the embedded algorithm also outperformed (Higgs et al., 2012a) I-TASSER (Lee et al., 2009). These improvements motivated us further developing superior algorithms using on-lattice models.

The two most important building blocks of an ab initio PSP are (i) an accurate (computable) energy function (Iqbal et al., 2015) and (ii) an effective search or sampling algorithm. For a simplified model based PSP, it is possible to compute the lower bound (Giaquinta and Pozzi, 2013). It is also possible to know what would be the best score and hence the native score of a sequence by exhaustive enumeration (Unger and Moult, 1993a; Lesh et al., 2003) (which is feasible to compute for smaller sequences only). Even though, there exists no efficient sampling algorithm yet that can conveniently obtain the known final structure starting from a random structure for all possible available cases (Hoque et al., 2005, 2007a). Therefore, a number of efforts are being made, such as, different types of meta-heuristics have been used in solving the on lattice PSP problems. These include Monte Carlo Simulation (Thachuk et al., 2007), Simulated Annealing (Tantar et al., 2008), Genetic Algorithms (GA) (Hoque et al., 2005, 2007a; Unger and Moult, 1993b; Hoque, 2008), Tabu Search with GA (Böckenhauer et al., 2008), GA with twin-removal operator (Hoque et al., 2011), Tabu Search with Hill Climbing (Klau et al., 2002), Ant Colony Optimization (Blum, 2005), Particle Swarm Optimization (Kondov and Berlich, 2011; Mansour et al., 2012), Immune Algorithms (Cutello et al., 2007), Tabu-based Stochastic Local Search (Cebrián et al., 2008; Shatabda et al., 2012), Firefly Algorithm (Maher et al., 2014), and Constraint Programming (Mann et al., 2008; Dotú et al., 2011).


                     Krasnogor et al. (2002) applied HP model for PSP problem using the square, triangular, and diamond lattices and further extended their work applying fuzzy-logic (Pelta and Krasnogor, 2005). Islam et al. further improved the performance of memetic algorithms in a series of work (Islam, 2011; Islam and Chetty, 2009; Islam et al., 2011c,a) for the simplified PSP models. They also proposed a clustered architecture for the memetic algorithm with a scalable niching technique (Islam and Chetty, 2010, 2013; Islam et al., 2011b) for PSP. However, using 3D FCC lattice points, the recent state-of-the-art results for the HP energy model have been achieved by genetic algorithms (Rashid et al., 2012a; Shatabda et al., 2013b), local search approaches (Shatabda et al., 2012; Rashid et al., 2013c), a local search embedded GA (Rashid et al., 2013a), and a multi-point parallel local search approach (Rashid et al., 2013b). Kern and Liao (2013) applied hydrophobic-core guided genetic operator for efficient searching on HP, HPNX and hHPNX lattice models. Several approaches towards the 20×20 energy model include a constraint programming technique used in Dal Palù et al. (2004, 2005) by to predict tertiary structures of real proteins using secondary structure information, a fragment assembly method (Dal Palù et al., 2011) to optimize protein structures. Among other successful approaches, a population based local search (Kapsokalivas et al., 2009) and a population based genetic algorithm (Torres et al., 2007) are found in the literature that applied empirical energy functions.

In a hybrid approach, Ullah and Steinhöfel (2010) applied a constraint programming based large neighborhood search technique on top of the output of COLA (Dal Palù et al., 2007) solver. The hybrid approach produced the state-of-the-art results for several small sized (less than 75 amino acids) benchmark proteins. In another work, Ullah et al. (2009) proposed a two stage optimization approach combining constraint programming and local search using Berrera et al. (Berrera et al., 2003) deduced 20×20 energy matrix (we denote this model as BM). In a recent work, Shatabda et al. (2013a) presented a mixed heuristic local search algorithm for PSP and produced the state-of-the-art results using the BM model on 3D FCC lattice. Although the heuristics themselves are weaker than the BM energy model, their collective use in the random mixing fashion produce results better than the BM energy itself. In a previous work (Rashid et al., 2013d), we applied BM and HP energy models in a mixed manner within a GA framework and showed that hybridizing energies performs better than their individual performances.

In this work, we propose a graded as well as hybrid energy function with a genetic algorithm (GA) based sampling to develop an effective ab initio PSP tool. The graded energy-model strategically mixes 20×20 Miyazawa–Jernigan (MJ) contact-energy (Miyazawa and Jernigan, 1985; Berrera et al., 2003) with the simple 2×2 hydrophobic-polar (HP) contact-energy model (Lau and Dill, 1989), denoted as MH (MJ+HP→MH) in this paper. Specifically, we propose a hydrophobic-polar categorization of the HP model within a hydrophobic-core directed macro-mutation operator to explore the local benefits exhaustively while the GA sampling is guided by the MJ energy Matrix globally. While the fine grained details of the high resolution interaction energy matrix can become computationally prohibit, a low resolution energy model may effectively sample the search-space towards certain promising directions particularly emphasizing on the pair-wise contributions with large magnitudes—which we have implementation strategically via a macro mutation. Further, we use an enhanced genetic algorithm (GA) framework (Rashid et al., 2012a) for protein structure optimization on 3D face-centered-cube (FCC) lattice model. Prediction in the FCC lattice model can yield the densest protein core (Hoque et al., 2005) and the FCC lattice model can provide the maximum degree of freedom as well as the closest resemblance to the real or, high resolution folding within the lattice constraint. FCC orientation can therefore align a real protein into the closest conformation amongst the available lattice configurations (Hoque et al., 2007a).

On a set of standard benchmark proteins, our MH model guided GA, named as MH_GeneticAlgorithm (MH_GA), shows significant improvements in terms of interaction energies and root-mean-square deviations in comparison to the state-of-the-art search approaches (Ullah and Steinhöfel, 2010; Shatabda et al., 2013a; Torres et al., 2007) for the lattice based PSP models. For a fair comparison, we run Ullah and Steinhöfel (2010) and Shatabda et al. (2013a) using MJ energy model and in the result section, we compare our experimental results with the results produced by Ullah and Steinhöfel (2010) and Shatabda et al. (2013a). Further, we present an experimental analysis showing the effectiveness of using the hydrophobic polar categorization of the HP model to direct macro-mutation operation.

@&#BACKGROUND@&#

Anfinsen's hypothesis (Anfinsen, 1973) and Levinthal's paradox (Levinthal, 1968) form the basis and the confidence of the ab initio approach, which inform that the protein structure prediction can be relied only on the amino acid sequence of the target protein as well as there should be a non-exhaustive pathway to obtain the native fold. Thus, we set our goal to model the folding process using on-lattice model. Further, it has been argued in Alm and Baker (1999) and Baker (2000), “… protein folding mechanisms and landscapes are largely determined by the topology of the native state and are relatively insensitive to details of the interatomic interactions. This dependence on low resolution structural features, rather than on high resolution detail, suggests that it should be possible to describe the fundamental physics of the folding process using relatively low resolution models… The observation that protein folding mechanisms are determined primarily by low resolution topological features and not by high resolution details suggests that a simple theory incorporating features of the native state topology should be successful in predicting the broad outlines of folding reactions”. A rigorous discussion on on-lattice models can be found in Istrail et al. (2009) and Bahi et al. (2013). Further, exploration of an astronomically large search space and the evaluation of the conformations using a real energy models are the big challenges often being computationally prohibitive, especially for sequences >200 residues long, whereas simplified models can aid in modeling and understanding the protein folding process feasibly. Next, we describe the model that we use.

In our simplified model, we use 3D FCC lattice points to map the amino acids of a protein sequence. In the mapping, each amino acid of the sequence, occupies a point on the lattice to form a continuous chain of a self-avoiding-walk. We apply the MJ energy matrix in conjunction with the HP energy model in a genetic algorithm framework for PSP. The FCC lattice, the HP and MJ energy models, and the GA are briefly described below.

The FCC lattice has the highest packing density compared to the other existing lattices (Hales, 2005). Thus, FCC model can provide maximum degree of freedom within a constrained space. In FCC, each lattice point (the origin in Fig. 1
                           ) has 12 neighbors with closest possible distance having 12 basis vectors as follows:
                              
                                 
                                    
                                       
                                          
                                             
                                                v
                                                1
                                             
                                             =
                                             (
                                             1
                                             ,
                                             1
                                             ,
                                             0
                                             )
                                          
                                          
                                             
                                                
                                                   v
                                                   4
                                                
                                                =
                                                (
                                                −
                                                1
                                                ,
                                                −
                                                1
                                                ,
                                                0
                                                )
                                             
                                          
                                          
                                             
                                                
                                                   v
                                                   7
                                                
                                                =
                                                (
                                                −
                                                1
                                                ,
                                                1
                                                ,
                                                0
                                                )
                                             
                                          
                                          
                                             
                                                
                                                   v
                                                   10
                                                
                                                =
                                                (
                                                0
                                                ,
                                                1
                                                ,
                                                −
                                                1
                                                )
                                             
                                          
                                       
                                       
                                          
                                             
                                                
                                                   v
                                                   2
                                                
                                                =
                                                (
                                                1
                                                ,
                                                0
                                                ,
                                                1
                                                )
                                             
                                          
                                          
                                             
                                                
                                                   v
                                                   5
                                                
                                                =
                                                (
                                                −
                                                1
                                                ,
                                                0
                                                ,
                                                −
                                                1
                                                )
                                             
                                          
                                          
                                             
                                                
                                                   v
                                                   8
                                                
                                                =
                                                (
                                                1
                                                ,
                                                −
                                                1
                                                ,
                                                0
                                                )
                                             
                                          
                                          
                                             
                                                
                                                   v
                                                   11
                                                
                                                =
                                                (
                                                1
                                                ,
                                                0
                                                ,
                                                −
                                                1
                                                )
                                             
                                          
                                       
                                       
                                          
                                             
                                                
                                                   v
                                                   3
                                                
                                                =
                                                (
                                                0
                                                ,
                                                1
                                                ,
                                                1
                                                )
                                             
                                          
                                          
                                             
                                                
                                                   v
                                                   6
                                                
                                                =
                                                (
                                                0
                                                ,
                                                −
                                                1
                                                ,
                                                −
                                                1
                                                )
                                             
                                          
                                          
                                             
                                                
                                                   v
                                                   9
                                                
                                                =
                                                (
                                                −
                                                1
                                                ,
                                                0
                                                ,
                                                1
                                                )
                                             
                                          
                                          
                                             
                                                
                                                   v
                                                   12
                                                
                                                =
                                                (
                                                0
                                                ,
                                                −
                                                1
                                                ,
                                                1
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

In simplified PSP, conformations are mapped on the lattice by a sequence of basis vectors, or by the relative vectors that are relative to the previous basis vectors in the sequence.

Based on the hydrophobic property, the 20 amino acids which are the constituents of all proteins, are broadly divided into two categories: (a) hydrophobic amino acids (Gly, Ala, Pro, Val, Leu, Ile, Met, Phe, Tyr, Trp) are denoted as H; and (b) hydrophilic or polar amino acids (Ser, Thr, Cys, Asn, Gln, Lys, His, Arg, Asp, Glu) are denoted as P. In the 2×2 HP model (Lau and Dill, 1989), when two non-consecutive hydrophobic amino acids become topologically neighbors, they contribute a certain amount of negative energy, which for simplicity is considered as −1 (Table 1
                           ). The total energy E
                           
                              HP
                            (Eq. (1)) of a conformation based on the HP model becomes the sum of the contributions over all pairs of the non-consecutive hydrophobic amino acids (Fig. 2
                           a).


                           
                              
                                 (1)
                                 
                                    
                                       E
                                       HP
                                    
                                    =
                                    
                                       ∑
                                       
                                          i
                                          <
                                          j
                                          −
                                          1
                                       
                                    
                                    
                                       c
                                       ij
                                    
                                    ×
                                    
                                       e
                                       ij
                                    
                                 
                              
                           where c
                           
                              ij
                           
                           =1 if amino acids at positions i and j in the sequence are non-consecutive but topological neighbors on the lattice, otherwise c
                           
                              ij
                            = 0. The e
                           
                              ij
                           
                           =−1 if the ith and jth amino acids are both hydrophobic, otherwise e
                           
                              ij
                            = 0.

By analyzing crystallized protein structures, Miyazawa and Jernigan (1985) statistically deduced a 20×20 energy matrix (better known as MJ energy model) that considers residue contact propensities between the amino acids. BM is a similar energy matrix as MJ deduced by Berrera et al. (Berrera et al. (2003)) by calculating empirical contact energies on the basis of information available from a set of selected protein structures and following the quasi-chemical approximation. In this work, we use MJ energy model. The total energy E
                           MJ (Eq. (2)) of a conformation based on the MJ energy model is the sum of the contributions of all of the non-consecutive amino acid pairs that are topological neighbors (Fig. 2b).


                           
                              
                                 (2)
                                 
                                    
                                       E
                                       MJ
                                    
                                    =
                                    
                                       ∑
                                       
                                          i
                                          <
                                          j
                                          −
                                          1
                                       
                                    
                                    
                                       c
                                       ij
                                    
                                    ×
                                    
                                       e
                                       ij
                                    
                                 
                              
                           where c
                           
                              ij
                           
                           =1 if amino acids at positions i and j in the sequence are non-consecutive neighbors on the lattice, otherwise c
                           
                              ij
                            = 0; and e
                           
                              ij
                            is the empirical energy value between the ith and jth amino acid pair specified in the MJ energy matrix as shown in Table 2
                           .


                           
                              
                                 
                              
                           
                        

GAs (Holland, 1975) are a family of population-based search algorithms which can be applied for PSP as an optimization problem. The outline of GA as given in Algorithm 1, follows simple steps: Line 1 initializes the population; the Line 2 evaluates the solutions to rank them by relative quality; and the Lines 4–7 are repeating on generating, evaluating and replacing the least-fitted off-springs within the population until the termination criteria arises. For the coding scheme, non-isomorphic encoding (Hoque et al., 2006) has been applied and the 
                           
                              v
                              1
                           
                           ,
                           …
                           ,
                           
                              v
                              12
                           
                         (in Fig. 1) can be thought of be renamed as a, …, l respectively.

A typical crossover operator randomly splits two solutions at a randomly selected crossover point and exchanges the parts between them (Fig. 3
                        ) and a typical mutation operator alters a solution at a random point (Fig. 4
                        ). In the case of PSP, conformations are regarded as solutions of a GA population.

@&#METHODS@&#

This section describes the proposed MH_GA framework along with the implementation level detail. We implemented the framework in Java (J2EE), using Rocks clusters. The code for MH based GA is freely available online.
                        1
                     
                     
                        1
                        Download the JAR file from: http://cs.uno.edu/~tamjid/Software/MH_GA/JarFiles.zip.
                     
                  

The primitive operators that we implemented within the MH_GA framework are crossover (Fig. 5
                        a), rotation mutation (Fig. 5b), diagonal move (Fig. 5c), pull moves (Fig. 5d), and tilt moves (Fig. 5e). The Rotation, diagonal move, pull moves and tilt moves are implemented as mutation operators.
                           
                              1.
                              
                                 Crossover: At a given crossover point (dotted circle in (Fig. 5a), two parent conformations exchange their parts and generate two children. The success rate of crossover operator decreases with the increase of the compactness of the structure.


                                 Rotation: One part of a given conformation is rotated around a selected point (Fig. 5b). This move is mostly effective at the beginning of the search.


                                 Diagonal move: Given three consecutive amino acids at lattice points A, B, and C, a diagonal move at position B takes the corresponding amino acid diagonally to a free position (Fig. 5c). The diagonal moves are very effective on FCC lattice (Cebrián et al., 2008; Dotú et al., 2011) points.


                                 Pull moves: The amino acids at points A and B are pulled to the free points (Fig. 5d) and the connected amino acids are pulled as well to get a valid conformation. The pull moves (Lesh et al., 2003) are local, complete, and reversible. These are very effective especially when the conformation is compact.


                                 Tilt moves: Two or more consecutive amino acids connected in a straight line are moved by a tilt move to immediately parallel lattice positions (Hoque, 2008). The tilt-moves pull the conformation from both sides until a valid conformation is found. In Fig. 5e, the amino acids at points C and D are moved and subsequently other amino acids from both sides are moved as well.

The pseudocode of MH_GA framework is presented in Algorithm 2. It uses a set of primitive operators Fig. 5) in an exhaustive generation approach to diversify the search, a hydrophobic core-directed macro-mutation operator to intensify the search, and a random-walk algorithm to recover from the stagnation. Like other search algorithms, it requires initializing the population and the solutions need to be evaluated in each iteration.


                        
                           
                              
                           
                        
                     

The algorithm initializes (Algorithm 2: Line 7) the current population with randomly generated individuals. At each generation, it selects a genetic operator based on a given probability distribution to use through the generation (Algorithm 2: Line 9). In fact, we select the operators randomly by giving equal opportunities to all operators. The selected operator is used in an exhaustive manner (Algorithm 2: Lines 11–12 or Lines 14–16) to obtain all conformations in the new population. We ensure that no duplicate conformation is added to the new population. The add() method (Line 12 or 16 in Algorithm 2) takes care of adding the non-duplicate conformations to the new population. For a given number of generations, if the best conformation in the new population is not better than the best in the current population, our algorithm triggers a random-walk technique (Algorithm 2: Line 18) to diversify the new population. Nevertheless, after each generation, the new population becomes the current population (Algorithm 2: Line 19); and the search continues. Finally, the best conformation found so far is returned (Algorithm 2: Line 20). Along with MJ potential matrix, the HP energy model is used during move selection by the macro-mutation operator. The macro-mutation operator is used as other mutation operators Fig. 5b–e) in MH_GA. The details of initialization, evaluation of fitness, exhaustive generation, macro-mutation and stagnation recovery schemes are presented below.

Our algorithm starts with a feasible set of conformation known as population. We generate initial conformations following a self-avoiding walk on FCC lattice points. The pseudocode of the algorithm is presented in Algorithm 3. It places the first amino acid at (0, 0, 0). It then randomly selects a basis vector to place the successive amino acid at a neighboring free lattice point. The mapping proceeds until a self-avoiding walk is found for the whole protein sequence.


                           
                              
                                 
                              
                           
                        

For each iteration, the conformation is evaluated by calculating the contacts (topological neighbor) potentials where the two amino acids are non-consecutive. The pseudo-code in Algorithm 4 presents the algorithm for calculating the interaction energy of a given conformation. The contact potentials are found in MJ potential matrix (Miyazawa and Jernigan, 1985) (see Table 2).


                           
                              
                                 
                              
                           
                        

Unlike standard genetic algorithm, in MH_GA, the randomness is reduced significantly by applying exhaustive generation approach. For mutation operators, MH_GA adds one resultant conformation to the new population that corresponds to each conformation in the current population. Operators are applied to all possible point (Algorithm 5) exhaustively until finding a better solution than the parent. If no better solution is found, the parent survives through the next generation. On the other hand, for crossover operators, two resultant conformations are added to the new population from two randomly selected parent conformations. Crossover operators generate child conformations by applying the crossover operator in all possible points (Algorithm 6) on two randomly selected parents. The best two conformations from the parents and the children are then become the resultant conformations for the next generation.


                           
                              
                                 
                              
                           
                        


                           
                              
                                 
                              
                           
                        

Protein structures have hydrophobic cores (H-core) that hide the hydrophobic amino acids from water and expose the polar amino acids to the surface to be in contact with the surrounding water molecules (Yue and Dill, 1993). H-core formation is an important objective of HP based PSP. Macro-mutation operator is a composite operator (Fig. 6
                           ) that uses a series of diagonal-moves (Fig. 5c) on a given conformation to build the H-core around the hydrophobic-core-center (HCC). The macro-mutation squeezes the conformation and quickly forms the H-core. In MH_GA, macro-mutation is used as other mutation operators. Algorithm 7 presents the pseudocode of macro-mutation algorithm.


                           
                              
                                 
                              
                           
                        

In macro-mutation, the HCC is calculated by finding arithmetic means of x, y, and z coordinates of all H amino acids. In macro-mutation, for a given number of iterations, diagonal moves apply repeatedly either at each P- or at each H-type amino acid positions. Whether to apply the diagonal move on P- or H-type amino acids is determined by using a Bernoulli distribution (Algorithm 7: Line 2) with probability p (intuitively we use p
                           =20% for P-type amino acids). For a P-type amino acid, the first successful diagonal move is considered. However, for a H-type amino acid, the first successful diagonal move that does not increase the Cartesian distance of the amino acid from the HCC is taken. All the amino acids are traversed and the successful moves are applied as one composite move.

Like other search algorithm, GA can get stuck in the local minima or, can be stalled. Stall condition can occur when similarities with the chromosomes in GA increases heavily and the operators are unable to produce better diverse solutions. Further, with the PSP search, resulting solutions become phenotypically compact which reduce the likelihood of producing better solution from the population due to harder self-avoid-walk (SAW) constraints (Higgs et al., 2012b; Hoque et al., 2007b, 2011). It would rather require very intelligent moves to reform into another competitive compact SAW. To deal with such situation, we apply the following two actions:

In genetic algorithm it has been observed that with increasing generations, the similarity among the individuals within the population increases. In worst case scenario, all the individuals become similar and forces the search to stall in the local minima. In our approach, we remove duplicates from each generation to maintain the diversity of the population. During exhaustive generation, we check the existence of the newly generated child in the new population. If it does not exist then the new solution is added to the new population list. Our approach reduces the frequency of stagnations.

Sometimes, early convergence leads the search towards the stagnation situation. In the HP energy model, premature H-cores are observed at local minima. To break these H-cores, in MH_GA (Algorithm 2: Line 18), a random-walk algorithm (Algorithm 8) is applied. This algorithm uses pull moves (Lesh et al., 2003) (as shown in Fig. 5d) to break the H-core. We use pull-moves because they are complete, local, and reversible. Successful pull moves never generate infeasible conformations. During pulling, energy level and structural diversification are observed to maintain balance among these two. We allow energy level to change within 5–10% that changes the structure from 10% to 75% of the original. We try to accept the conformation that is close to the current conformation in terms of the energy level but as far as possible in structural diversity, and which is determined by the function checkDiversity() in Algorithm 8 at Line 5. For genetic algorithm, random-walk is very effective (Rashid et al., 2012b) to recover from stagnation.


                           
                              
                                 
                              
                           
                        

The complete flow of MH_GeneticAlgorithm (Algorithm: 2) is graphically presented in Fig. 7
                           . Further, it describes the steps taken within macro mutation procedure (Algorithm: 7).

@&#PERFORMANCE EVALUATION@&#

To compare and evaluate the performance of the proposed PSP predictor with respect to the state-of-the-art approaches, we used the measures Relative Improvement (RI) and RMSD comparisons. They are defined below:

The difficulty to improve energy level is increased as the predicted energy level approaches to a known lower bound of a given protein. For example, if the lower bound of free energy of a protein is −100, the efforts to improve energy level from −80 to −85 is much less than that to improve energy level from −95 to −100 though the change in energy is the same (−5). The RI computes the relative improvements that our algorithm (target,t) achieved w.r.t. the state-of-the-art approaches (reference, r).

For each protein, the relative improvement of the target (t) w.r.t. the reference (r) is calculated using the formula in Eq. (3), where E
                        
                           t
                         and E
                        
                           r
                         denote the average energy values achieved by target and reference respectively.


                        
                           
                              (3)
                              
                                 RI
                                 =
                                 
                                    
                                       
                                          E
                                          t
                                       
                                       −
                                       
                                          E
                                          r
                                       
                                    
                                    
                                       
                                          E
                                          r
                                       
                                    
                                 
                                 ×
                                 100
                                 %
                              
                           
                        
                     

The root mean square deviation (RMSD) is frequently used to measure the differences between values predicted by a model and the values actually observed. We compare the predicted structures obtained by our approach with the state-of-the-art approaches by measuring the root-mean-square w.r.t. the native structures from PDB. For any given structure the root-mean-square is calculated using Eq. (4),


                        
                           
                              (4)
                              
                                 RMSD
                                 =
                                 
                                    
                                       
                                          
                                             
                                                ∑
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                
                                                   n
                                                   −
                                                   1
                                                
                                             
                                             
                                                ∑
                                                
                                                   j
                                                   =
                                                   i
                                                   +
                                                   1
                                                
                                                n
                                             
                                             
                                                
                                                   (
                                                   
                                                      d
                                                      ij
                                                      p
                                                   
                                                   −
                                                   
                                                      d
                                                      ij
                                                      n
                                                   
                                                   )
                                                
                                                2
                                             
                                          
                                          
                                             n
                                             ×
                                             (
                                             n
                                             −
                                             1
                                             )
                                             /
                                             2
                                          
                                       
                                    
                                 
                              
                           
                        where 
                           
                              d
                              ij
                              p
                           
                         and 
                           
                              d
                              ij
                              n
                           
                         denote the distances between ith and jth amino acids respectively in the predicted structure and the native structure of the protein. The average distance between two α-carbons in native structure is 3.8Å. To calculate root-mean-square, the distance between two neighbor lattice points is considered as 3.8Å.

@&#RESULTS AND DISCUSSION@&#

In this section, we discuss the obtained results along with the comparison of the performance of MH_GeneticAlgorithm with the other state-of-the-art results (Torres et al., 2007; Ullah and Steinhöfel, 2010; Shatabda et al., 2013a). Further, we present an analysis of the results.

In our experiment, the protein instances are taken from the literatures. The first seven proteins (4RXN, 1ENH, 4PTI, 2IGD, 1YPA, 1R69, and 1CTF) in Table 3
                         are taken from Ullah and Steinhöfel (2010) and Shatabda et al. (2013a), and the next five proteins (3MX7, 3NBM, CMQO, 3MRO, and 3PNX) are taken from Shatabda et al. (2013a). The two other protein instances in Table 5 (2J61 and 2HFQ) are taken from Torres et al. (2007).

In the literature we found very few works (Kapsokalivas et al., 2009; Torres et al., 2007) that used 20×20 MJ potential-matrix (Miyazawa and Jernigan, 1985) for protein structure prediction on 3D FCC lattice. However, Torres et al. (2007) used 3D HCP lattice and Kapsokalivas et al. (2009) used 3D cubic lattice in their works for protein mapping. In other works, Ullah and Steinhöfel (2010) and Shatabda et al. (2013a) used 3D FCC lattice with 20×20 empirical energy matrix by Berrera et al. (2003). In fact, we do not have any state-of-the-art results available for similar model to compare free energy level in a straight way. Therefore, we ran the algorithms used in Ullah and Steinhöfel (2010) and Shatabda et al. (2013a) using the MJ energy model (Miyazawa and Jernigan, 1985) to compare our results. However, the constraint programming based hybrid approach (Ullah and Steinhöfel, 2010) failed to get any solution for most of the large-sized proteins. In such cases, in Table 4
                        
                        , the results are denoted by n/a.

In Table 4, we present interaction energy values in two different formats: the global lowest interaction energy (Column Best) and the average (Column Avg) of the lowest interaction energies obtained from 50 different runs. In case of the global best energy, our approach outperforms the state-of-the-art approaches in Ullah and Steinhöfel (2010) and Shatabda et al. (2013a) on 9 out of 12 benchmark proteins. However, in case of average energy, our approach outperforms both of the approaches on 10 out of 12 benchmark proteins. Based on the experimental results, the performance hierarchy of the approaches used to validate our MH_GA is shown in Fig. 8
                        .

From the Column RI of Table 4, we see that for 2 proteins our GA fail to improve over the state-of-the-art. However, for other 10 proteins it improves the average interaction energy level ranging from 0.10% to 26.58% for different proteins.

Further, in Table 5, we present another two benchmark proteins taken from a GA based approach (Torres et al., 2007). From the authors of Torres et al. (2007), we tried to get their implemented codes so that we can run that by ourselves. However, we failed to receive any response from the authors. Therefore, we present the reported values. For fair comparison, we compare the results by generation-wise instead of by running-time.

We calculate RMSD of a structure that corresponds to the lowest MJ interaction energy for a particular run. The reported RMSD values in Table 6
                            are the global minimum of 50 runs. In Tables 5 and 6, the bold-faced RMSD values indicate the winners for the corresponding proteins.

In Table 7
                           , we present corresponding MJ energy values for global minimum RMSD and corresponding RMSD values for global minimum MJ energy values over 50 runs for each proteins on identical settings. The experimental results show that the global minimum energy in our experiment does not produce minimum RMSD value.

The MJ energy model actually implicitly bear the characteristic of hydrophobicity. The matrix values present some variations within amino acids of the same class (H or P). A partition algorithm such as 2-means clustering algorithm easily reveals the H–P partitioning within the MJ model. Given this knowledge, we study the effect of explicitly using hydrophobic property within our GA.

Our macro-mutation operator biases the search towards a hydrophobic core by applying a series of diagonal moves and thus achieves improvements in terms of MJ energy values of the output conformations. We implemented three different versions of our genetic algorithm.
                              
                                 1.
                                 
                                    MH: This version is our final algorithm that we described in detail, and used in presenting our main results in Table 4 and in comparing with the state-of-the-art results. To reiterate, this version uses the MJ energy model for search and energy reporting, and hydrophobicity knowledge in the macro-mutation operator that repeatedly applies diagonal moves towards forming a hydrophobic core.


                                    MJ: This version of our GA uses the MJ energy model for search and energy reporting. This version has macro-mutation operator but not biased by hydrophobic properties of amino acids.


                                    HP: This version of our GA uses the HP energy model for search. However, we report the energy values of the final conformations returned by the GA in MJ energy model. Note that this version has the hydrophobic core directed macro-mutation operator. This version will show whether HP model is sufficient even when the energy of a conformation is to be in the MJ model.

From the Column RI in Table 8
                           , we see that MH guided GA improves the average interaction energy level over MJ model, ranging from 0.84% to 5.14% for all benchmark proteins. The improvements are not large in magnitudes but consistently better for all the proteins.

We know that the lower p-values are better. We performed the t-test with a confidence interval of 95% (i.e., significance level is 5%) and the results are presented in Table 8. For MJ and MH models, the p-values of all proteins are less than the significance level. However, for HP model, the p-value for 3MSE is below the significance level and for other five sequences those are equal to the significance level. Therefore, the experimental results are statistically significant.

To demonstrate the search progress, we periodically find the best energy values obtained so far in each run. For a given period, we then calculate the average energy values obtained for that period over 50 runs. We used a 2-min time interval. Fig. 9
                            presents the average energy values obtained at each time interval for two different proteins: 4RXN and 3PNX are the smallest and largest amongst the 12 benchmark proteins respectively. From both of the charts, we see that the final version of our algorithm MH performs better than the other two versions.

@&#DISCUSSION@&#

By encoding the conformation with angular coordinates (ϕ and ψ), our GA might easily be applied in high-resolution PSP. While the minimizing energy function is highly complex (such as molecular dynamics), a simple guidance heuristic—such as hydrophobic property or exposed surface area—could be used to guide the macro-mutation operator. Within GA framework, the macro-mutation operator could be applied optimizing the segments of secondary structures (α-helix and β-sheet).

Our approach can easily divide the whole optimization process into two stages guided by two energy models with different complexities. The macro-mutation operator can be guided by simpler energy models such as distance from hydrophobic core, exposed surface area, hydrophobicity of amino acids, hydropathy index of the amino acids, and so on. Conversely, the main objective function can be more realistic such as molecular dynamics based energy models. This two-stage optimization will reduce the overall computational complexities. As a result, our framework has a good chance to succeed in more realistic models even for large sized proteins.

@&#CONCLUSION@&#

Our guided macro-mutation in a graded energy based genetic algorithm, ‘MH GeneticAlgorithm’, is found to be an effective sampling algorithm for the convoluted protein structure space. The strategical switching in between the Miyazawa–Jernigan (MJ) energy and the hydrophobic-polar (HP) energy made the proposed algorithm perform better compared to the other state-of-the-art approaches. This is because, while the fine graded MJ energy interaction computation become computationally prohibit, the low resolution HP energy model can effectively sample the search-space towards certain promising directions. In addition, the GA framework was enhanced and made powerful, since it uses not only crossover but also three effective move operators. Further to diversify the population to keep sampling or, exploring the search space effectively, a hydrophobic core-directed macro-mutation operator, twin removal as well as a random-walk algorithm to recover from the stagnation has been applied. To compare the performance of our GA, we have extensively compared with the existing state-of-the-approaches using the available benchmark problems and found our approach to be consistently better as well as often found significantly better – t-test result in terms of p-values have been provided to support the claims. For the lattice configuration to be followed, we used 3D face-centered-cube (FCC) lattice model, because prediction in the FCC lattice model can yield the densest protein core and the FCC lattice model can provide the maximum degree of freedom as well as the closest resemblance to the real or, high resolution folding within the lattice constraint. This enables the predicted structure to be aligned and hence, migrated to a real protein (prediction) model efficiently for future extensions.

@&#ACKNOWLEDGMENTS@&#

Mahmood Rashid and Abdul Sattar would like to express their great appreciation to National ICT Australia. Sumaiya Iqbal and Md Tamjidul Hoque acknowledge the Louisiana Board of Regents through the Board of Regents Support Fund, LEQSF(2013-16)-RD-A-19.

@&#REFERENCES@&#

