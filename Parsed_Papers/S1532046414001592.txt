@&#MAIN-TITLE@&#Restricted natural language based querying of clinical databases

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A generic querying solution in the clinical domain.


                        
                        
                           
                           Translation of restricted natural language queries to SQL queries.


                        
                        
                           
                           Resolving the complexity of data extraction from Entity–Attribute–Value data model.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Restricted natural language querying

Knowledge discovery and reuse

Data analytics

@&#ABSTRACT@&#


               
               
                  Purpose
                  To elevate the level of care to the community it is essential to provide usable tools for healthcare professionals to extract knowledge from clinical data. In this paper a generic translation algorithm is proposed to translate a restricted natural language query (RNLQ) to a standard query language like SQL (Structured Query Language).
               
               
                  Methods
                  A special purpose clinical data analytics language (CliniDAL) has been introduced which provides scheme of six classes of clinical questioning templates. A translation algorithm is proposed to translate the RNLQ of users to SQL queries based on a similarity-based Top-k algorithm which is used in the mapping process of CliniDAL. Also a two layer rule-based method is used to interpret the temporal expressions of the query, based on the proposed temporal model. The mapping and translation algorithms are generic and thus able to work with clinical databases in three data design models, including Entity-Relationship (ER), Entity–Attribute–Value (EAV) and XML, however it is only implemented for ER and EAV design models in the current work.
               
               
                  Results
                  It is easy to compose a RNLQ via CliniDAL’s interface in which query terms are automatically mapped to the underlying data models of a Clinical Information System (CIS) with an accuracy of more than 84% and the temporal expressions of the query comprising absolute times, relative times or relative events can be automatically mapped to time entities of the underlying CIS and to normalized temporal comparative values.
               
               
                  Conclusion
                  The proposed solution of CliniDAL using the generic mapping and translation algorithms which is enhanced by a temporal analyzer component provides a simple mechanism for composing RNLQ for extracting knowledge from CISs with different data design models for analytics purposes.
               
            

@&#INTRODUCTION@&#

Extracting knowledge from data is essential in clinical research, decision making and hypothesis testing. These tasks are necessary for healthcare professionals to improve the level of services of care to the community. The important dichotomy between health care professionals and IT (Information Technologies) staff is that innovative tools and methods in computer science and web technologies are not applied with all their potential in the clinical domain, and the IT staff are not familiar with the clinical terminologies to create language-aware user-friendly tools. So, providing a general solution or methodology to create such tools is of prime importance.

Our substantive goal is to create a special purpose query language for clinical data analytics (CliniDAL) that can answer any answerable question from the CIS. A category scheme of six classes of increasing complexity, including point-of-care retrieval queries, descriptive statistics, statistical hypothesis testing, complex hypotheses of scientific studies, semantic record retrieval and predictive modeling has been designed to capture the scope encompassed by CliniDAL’s objectives. The formal definition of CliniDAL has been proposed in [1]. The proposed solution for CliniDAL includes automatic mapping of query terms to the underlying model of the CIS, storing the mapping result in a generic context model and then translation of the recognized query elements to the standard formats of SQL or XML based query languages. The innovative aspect of CliniDAL is that a user would be able to compose a query in the restricted natural language form of CliniDAL without any knowledge of the underlying schema of the CIS or any SQL-like or XML based query languages. In the current work, the aim is to propose a generic translation algorithm based on the mapping solution which is proposed in [2]. The proposed algorithms for mapping and translation are only implemented for ER and EAV based CIS design models in the current work and they will be extended to support XML based CIS design models as the next step. CliniDAL is a generic query language as all its underlying solutions for parsing, mapping, translation and temporal expression interpretation are generic and not dependent on any CIS, however the current version is only tested on a specific CIS [ICIP: ICU section, Royal Prince Alfred Hospital (RPAH), Sydney, Australia]. The earlier versions were successfully tested on a number of other CISs. They have been used by small number of users at RPAH on a weekly basis.

The remainder of the paper is organized as follows: The next section provides an overview of the keyword-based querying approaches in the general domain. Then the proposed translation method which has been implemented as a prototype component 
                        Query Translator
                      in CliniDAL is explained together with the details of challenges and solutions related to different data models which should be covered and the flexibilities that need to be added to CliniDAL. After that, the experimental results of translating a set of test queries are explained and finally there will be an evaluation together with conclusions and future work suggestions.

@&#BACKGROUND@&#

Keyword based search has recently attracted several researchers especially in web technologies. Generally, in the proposed techniques the aim is to enable the user to ask questions in a language close to natural language. So, there would be no need to have knowledge of data organization or schema of the underlying database or ontologies. Hence, the main challenge is the mapping of query keywords to the underlying data or schema model and then there is a need to translate or convert the initial query to a standard query form like SQL, XML or semantic web query languages. In keyword++ [3], a framework is proposed to improve existing search interfaces by translating key word queries to SQL to resolve the problem of their incompleteness and imprecision when searching a database. In the proposed approach in keyword++, the keyword queries firstly are mapped to a predicate and scored using deferential query pairs (DQPs) and then translated to SQL. The authors conducted various experiments on their system which shows its effectiveness in leveraging existing approaches. SPARK [4] is another effort to keep users away from the complexity of formal logic representations and being familiar with underlying ontologies. A ranked list of SPARQL (RDF based query language) queries is created in SPARK as the translation result of initial keyword queries. The proposed approach includes mapping of query keywords to ontology resources, representation of mapped items in graph format which is then interpreted into a SPARQL query and finally ranking the queries using a probabilistic ranking model. They evaluated their work on 750 keyword queries on 3 different domains which led to about 79% recall and 67%MRR.

In the similar work in PANTO [5], the keyword queries were translated to SPARQL. More complex query keywords including negation, comparative and superlatives were investigated in PANTO and instead of graph representation as in SPARK, a parse tree represented the intermediate results for SPARQL generation. The precision was roughly 86–91% and recall was 86–96% on 3 different domains. Keymantic [6] is another system to answer keyword queries over relational databases using intentional knowledge like schema, data types, etc. and additional knowledge available on the Web as lexical resources or ontologies. The proposed approach included generation of configurations as mappings of keywords to database terms, then determination of the best configuration and generation of SQL from it. The presence of different join paths among the elements involved in a configuration, lead to multiple queries resulting from a single configuration.

Despite the success of above works for keyword-based search in the general domain to adapt similar approaches in the clinical domain much more effort is required. The reason is that much of the important patient information can only be found in patient notes and not in the structural part of the CISs. So, some basic Natural Language Processing (NLP) tasks like Named Entity Recognition (NER) have to be performed on the narrative text to find clinical entities and make them ready for upper level question answering systems. The Mayo Clinic information extraction system [7] was developed to process and extract information from free-text clinical notes including named entities such as diseases, signs/symptoms, anatomical sites and procedures. Attributes related to the named entities including context, status and relatedness to patients are also extracted from the text. To the best of our knowledge, approaches proposed for i2b2 challenges for medical concept extraction are the leaders for NER in the Clinical domain. They mainly use one or a combination of a few Machine Learning (ML) methods or hybrid approaches of ML and rule-based systems which involve two basic tasks of concept identification and relation extraction. The best system proposed for i2b2 2009 [8] was a novel supervised learning model that incorporates two ML algorithms and several rule-based engines to automatically extract medication information related to drug names, dosage, mode, frequency, duration and reason for administration of a drug from clinical records with F-score of 85.65%. A similar hybrid approach was proposed in [9] for the i2b2/VA challenge to extract a wider range of clinical concepts which achieved a maximum F-score of 0.839 for concept extraction and 0.931 for assertion classification.

More complicated approaches have been developed for extracting temporal information from clinical narratives as an important piece of information to be used in question answering or data analytics systems. In TimeText [10] a temporal reasoning system is designed to represent, extract, and reason about temporal information in clinical text. This system has been evaluated with discharge summaries. Despite all the effort it is only capable of answering very simple questions. In more recent work rule based approaches or their combination with ML methods have been used for temporal expression extraction. HeidelTime, a cross-domain temporal tagger, is an example of rule-based approaches [11,12] is a hybrid system of rule-based and ML approaches for temporal expression extraction and classification on clinical text which achieved F-measures of 0.87 and 0.53 in the i2b2 2012 NLP challenge.

In the current work the mapping problem of keyword search is solved by using the similarity based Top-k algorithm with accuracy of more than 84%. The algorithm looks for k records of a dictionary that have the largest similarity matches with a query string x, provided that each similarity is more than a threshold. Also we have provided various versions of interfaces for users to direct them in composing restricted natural language queries for clinical databases in three data design models including Entity-Relationship (ER), Entity–Attribute–Value (EAV) and XML. While the majority of the current solutions are proposed in the general domain the main contribution of the current work is applying similar solutions in the clinical domain. The EAV approach is a popular modeling strategy for the design of Clinical Information Systems (CIS) however it introduces much more complexity in the real implementation in comparison to a conventional ER design mode. This is the focus of investigations in the current work.

@&#METHOD@&#

The conceptual framework of CliniDAL has been described extensively in [1]. As a generic query language in the clinical domain it can be setup on top of any CIS to enable naïve database users such as physicians and clinical researchers to retrieve data from the CIS without having any knowledge of the underlying data or schema of the CIS. CliniDAL’s syntax allows user to compose a restricted natural language query which can then be translated to a standard query language like SQL using automatic mapping of query terms to the underlying CIS, a generic temporal analyzer for interpreting temporal expressions and a generic translation algorithm. Current work focuses on the issues for implementation of translation processes with specific attention on the EAV design model based on our previous works [1,2,13].

The main components of CliniDAL which are involved in the translation process are shown in Fig. 1
                     . The 
                        Query Processor
                      gets a text query as input and processes it using its sub-components including the 
                        Parser
                     , the 
                        Categorizer
                      and the 
                        Optimizer
                      to generate a query or parse tree as output. Then the query tree is fed to the 
                        Query Translator
                      component of CliniDAL which consists of four sub-components. The first sub-component 
                        Mapper
                      tries to map detected query tokens to the concepts in the underlying data model of the CIS using a similarity based Top-k algorithm together with some embedded NLP tools which include tokenization, abbreviation expansion and lemmatization to prepare resources for automatic mapping [2]. Based on the various data models that CliniDAL is intended to cover, this mapper includes three sub-components 
                        EAV Mapper
                     , 
                        ER Mapper
                      and 
                        XML Mapper
                     . A generic context model, which acts like an index to provide the primary information for the translation, is proposed to store the mapping results. The 
                        Translator
                      sub-component of the 
                        Query Translator
                      performs two kinds of translation related to the general data model of the CIS. If the CIS uses an EAV or ER model the query is translated into one or a set of SQL queries while if the CIS is a document based information system, translation will be to XML. In addition, as a temporal dimension plays an important facet in CliniDAL, a 
                        Temporal Analyzer
                      is defined based on the proposed temporal model [13]. The 
                        Temporal Analyzer
                      is responsible for finding and mapping the corresponding temporal entity related to the mapped query terms to the underlying data elements of the CIS data model. It is also responsible for translating temporal comparative values which are presented in three basic forms including absolute times, relative times and relative events.

In the following sub-sections the requirements and challenges of CliniDAL’s translation process followed by the generic translation algorithm are explained. In addition, ICIP CIS has been used for evaluation of CliniDAL’s translation process, which its underlying data model is a hybrid model of ER and EAV.


                        Fig. 2
                         illustrates the proposed schema of CliniDAL’s context model for CIS data source. This model stores the required information for translation of a CliniDAL query which is a kind of metadata or context information of the CIS and facilitates accessing actual data from the CIS. So, there is no need to transfer data from the CIS. There are five major factor tables including term_dict, qualifier_range, dscontext_spec, term_dsentity_match and table_join with a suffix dsname for all of them. These reflect the real data source names which are defined in the configuration files of CliniDAL for the particular CIS it is being used with. These factor tables work with three configuration tables: ttoc_src_type_config, term_type_config and dsentity_type_config.

Term_dict_<dsname> stores all the available terms that can be used in CliniDAL statements for querying the data source which is identified by the dsname. The unified term must be unique since it is the identifier of this entity/attribute exposed to the users. The TERM_ID is the internal identifier for software processing purposes. The unified term may have synonyms, which can also be used for composing CliniDAL statements.

To facilitate creating query constraints using qualifier parameters instead of quantitative values, the table qualifier_ranges_<dsname> has been defined. Whenever, a query term is mapped to an element in data or schema part of the CIS and its information stored in the term_dict table, a new entry will be added to qualifier_ranges table to store ranges of values using a predefined dictionary to be mapped to qualifiers like “normal”, “high”, “low” or their synonyms.

To match a query term to the corresponding data source entity term_dsentity_match_<dsname> table is created. In ER translation all the information for matching a query term to underlying data exists in this table while for EAV translation the table ds_context_spec_<dsname> is required as well. The spec_id in term_dsentity_match table refers to an entry in ds_context_spec table which contains information about the data type, time field, table name and actual data field which stores any information about the query terms.

The table_join_<dsname> table contains all the information to join each distinct pair of tables in the data source. The columns TABLE_ONE and TABLE_TWO store the table names that can be joined. The column JOIN_LINK stores a foreign key relationship between the tables which is used to make the linkage to join them.

The ttoc_src_type_config stands for Medical Terminology Source Type Configuration and assigns a type ID for each TTOC accessible in the system. Users can define their own types of dictionary sources, numerical identifiers and corresponding descriptions.

The term_type_config stands for Term Type Configuration in CliniDAL’s grammar and assigns type ids to various terminal entities in CliniDAL. Each of the defined ids in this table is related to one of the constraint clauses of CliniDAL. During the mapping of a query term its type is labeled using a clinical ontology like SNOMED-CT (Systematized Nomenclature of Medicine – Clinical Terms) to be categorized in the correct category for later processing.

The ds_entity_type_config stands for Data Source Entity Type Configuration. Data source entity types are defined to give indications of the type of a data source entity. Such information is used by the query translator to choose the correct interpreting instructions.

All the required information for the first four factor tables can be stored automatically during the mapping process while the information of the table_join table is automatically fetched from the metadata of the CIS. In addition, the three configuration tables only have a few static data items which can be stored during the system setup. The detailed description of fields of all the above tables is provided in Table E in the Appendix.

Once the parsing and mapping of a CliniDAL query is finalized, two useful resources are available for starting the translation process: the 
                           query (parse) tree
                         and all information in the 
                           data source context
                        . At the moment only the translation to SQL queries in the two data models of CIS design of EAV and ER models are implemented. The aim is to extend this method to support XML based CIS as well. As the translation is based on the structure of a query tree and relates to the results of the mapping process we believe in its extensibility to support any kind of CIS data source design model. The main steps for preparing the above resources are:
                           
                              (1)
                              Parsing the input CliniDAL query using PLY a pure python implementation of the popular compiler construction tools lex and yacc and creating a binary query tree. A binary tree have been used for representation of a query tree (parse tree) since it is the simplest tree structure and easier to implement.

Categorizing the query terms based on CliniDAL’s constraint clauses using pre-defined gazetteers and also SNOMED top level hierarchies and storing them in appropriate data structures in five different categories including Patient, Medical, Location, Care provider and Time entities and comparatives. For obtaining the SNOMED top category TTSCT (Text to SNOMED CT) conversion service is used [14]. It takes free text and identifies text segments equivalent to SNOMED CT concepts.

Mapping all the entities defined in the step 2 to underlying data or schema of the CIS using content based similarity search and Top-k algorithm[2], and then storing the results in the data source context model.

Converting all the registered entities of the query to their internal representation, using data source context.

Converting the query tree to the stack data structure (Source-Stack) in a way that firstly a root node, then the left sub-tree and finally the right sub-tree inserted in the stack (in-order insertion). This conversion leads to a bottom up tree traversal which consequently sets a higher priority to the processing of lowest level query components in the form of triples (entity, operation, comparative value) in each branch of the constraint clauses.

The translation algorithm is based on the structure of the query tree. Fig. 3
                            shows the top level nodes of the query tree for RAStatement (Retrieval Aggregation Statement) query type of CliniDAL as the output of its parser. The low level nodes are not shown for simplicity but their details will be explained later.


                           Fig. 4
                            shows the query tree of the SHTStatement (Statistical Hypothesis Testing Statement). At the beginning of translation, a context free optimization process is applied to the SHTStatement query to convert it into two or more RAStatement; one as base query and the others as list of comparative set queries. Then the RAStatements are translated into SQL statements.

In Fig. 5
                            the generic template for composing a CliniDAL query is presented. The detail description of each the clauses of the template can be found in formal description of CliniDAL in [1].

The accuracy of the translation process depends on the accuracy of the mapping process (84% in the current implementation); however, due to the characteristics of the EAV design much more effort is required to translate a query from a CIS with EAV design in comparison to an ER design. In conventional ER design for clinical data, information is stored as one column for each attribute (Table 1
                           left) or, in other words, a set of facts in one row for a patient at one time stamp, whereas in an EAV model, each fact is conceptually stored in a separate row in a table with four columns[15] consisting of (Table 1 right):
                              
                                 •
                                 The entity which is usually a patient ID together with time stamps recording the event occurrence.

The attribute, which describes a feature of the entity. For instance, temperature or heart rate is stored as an attribute for patients.

The value of the attribute, e.g. 38 for temperature and 90 for heart rate.

Based on the features of clinical data (flexible and sparse data) such storage mechanism is very popular. In addition, simplifying the schema in EAV design leads to insulation against the required changes on tables, manipulating programing code and user interfaces, whenever a new change occurs in the CIS [16]. According to the comprehensive investigation of advantages and drawbacks of EAV design model for storing clinical data [16], the challenges of information extraction in EAV design model are:
                              
                                 •
                                 Considerable up-front programming is needed to do many tasks which are trivial in ER model.

Less efficient than ER model for bulk retrieval of numerous objects at a specified time.

The process of performing complex attribute-centric queries based on values of attributes, and returning a set of objects are both significantly less efficient and technically more difficult, however, it is attractive for object-centric queries.

Another challenge in the current work is that in data analytics the values of various medical attributes need to be extracted for when they occur at the same time. While in the EAV design model each attribute is stored in separate row with a time stamp. In addition the frequency of charting data for medical attributes is different. The details of the approach to resolve this case are explained in the section discussing the interpolation of temporal comparative values.

In addition, real implementations of EAV design model are mostly hybrid designs of ER and EAV which create heterogeneous schema with much more complexity in choosing the correct representation for a class of data. In our experiments on ICIP CIS as a hybrid design of EAV and ER, the mapping process was more challenging. Also, in the ICIP system the tables with ER design are called dimension tables and they store few records (in range of hundreds to thousands records), with descriptions of attributes and provide details around who, what, where and the how of the actual data. The tables with EAV design are called fact tables in ICIP and they store the actual values of the attributes or the raw patient data charted in the ICIP system such as arterial blood pressure (ABP) values and medication dosages together with other properties such as foreign keys to point to the dimension tables.

An important consideration for clarification is that the entities which are created from corresponding constraint category (Patient, Medical, etc.) during CliniDAL’s implementation are conforming to the attributes in EAV design model. Particularly, CliniDAL’s Medical entities may have their own medical attributes which are explained in Sub-section 3.2.7.

With the required resources (query tree and context model) the translation will be straight forward for the ER model. All the terms represented in the 
                              Find Entity Clause
                            are candidates for retrieval and statistical entities of a CliniDAL query. Their corresponding tables and fields are extracted from the data source context and easily added to the list in selection clause. For instance, the query terms of “Find all_values of pid, first name, last name” in the Find_Entity_Clause of a CliniDAL query on ICIP CIS will be mapped to 
                              encounterId
                           , 
                              firstName
                            and 
                              lastName
                            fields of the D_Encounter table respectively to generate a 
                              select clause
                            in a SQL statement. In addition, the value table of elements in the select clause can be extracted via the data source context model to generate an SQL 
                              from clause
                           .

All the leaf nodes in the Retrieval Constraint sub-tree (Fig. 3), represent one of CliniDAL’s constraint categories. These nodes can be extended in the query (parse) tree to reflect conjunction or disjunction of some algebraic computation among clinical attributes and their values related to each type of query constraint. For instance, one of the possible extensions for a sample medical constraint with two conjunctions and three algebraic operations is shown in Fig. 6
                           :

Other constraint categories include Patient, Location, Care provider and Time which have similar extensions in the query tree. The point is that, all the corresponding fields and tables for each of the entities (blood pressure, temperature and heart rate in Fig. 6) were identified during the mapping process and can be easily replaced by their corresponding item. In addition, there will be more computation on the comparative values during the translation based on their data type (text, number and date/time) and also the complexity of comparative values to normalize them. According to CliniDAL’s grammar subtraction from or sum with a constant value and also reference to other queries can be used in comparative values. In addition, based on the type of each extracted node from the Source-Stack (Algebraic, Junction, Medical Clause, RAStatement, etc.) some more adjustments needs to be applied to the query to generate the 
                              where clause
                            and 
                              grouping – ordering clauses
                            of a SQL statement. Finally, qualifier comparative values and also implicit entities can be used in composing a CliniDAL query. The details of handling them are explained in separate sections.

As explained above, information extraction from a CIS with EAV design model is a challenging task. One reason is that to extract information on several attributes, a self-join of a fact table, or join of different fact tables with millions of records is required. To tackle this challenge, two different solutions are available in the translation process of a CliniDAL query to an SQL query.

The first solution is generating a huge SQL statement with several conditions for joining fact tables and dimension tables. Generating selection and from clauses in this solution is the same as for the ER model. However, in the where clause there will be more conditions to join a fact table with itself or other fact or dimension tables. The number of conditions depends on the number of attributes. With “n” EAV attributes it will need n
                           *(n
                           −1)/2 conditions for a join in the where clause together with other conditions on the values of attributes if required. In addition for each join 2 different conditions are needed; one for joining tables on the same patient id and the other for joining them at the same time point. So the number of total conditions will be n
                           *(n
                           −1) which leads to poor efficiency when executing the query. On the one hand running a query on tables with millions of records is time consuming, and on the other hand the optimization process of the DBMS to find the best way to join tables is time consuming as well. As a result, queries will execute very slowly. In addition, more programing effort is required to create aliases for tables to do self-joins and also provide proper linkage on aliases.

The second solution is based on the pivoting approach proposed in [17]. The main idea is representing the row-based EAV data in columns like the conventional ER model, using a two dimensional array and 2 hash tables to reference the row and column number of the array. The revised version of this solution has been used in the current work to improve the efficiency of running the final SQL queries and also simplifying the SQL generation during the translation process. After parsing and mapping the query six set of S, P, M, L, C and T will be available which are derived from the clauses of the template defined in Fig. 5:
                              
                                 (1)
                                 S={s1, s2, …, si}, set of mapped retrieval and aggregated entities (derived from Find_Entity_Clause);

P={p1, p2,…, pj}, set of constraints on patient demographics(derived from Patient_Clause);

M={m1, m2, …, mk}, set of constraints on medical attributes (derived from Medical_Clause);

L={l1, l2, …, ll}, set of constraints on location (derived from Location_Clause);

C={c1, c2, …, cm}, set of constraints on care providers (derived from Careprovider_Clause);

T={t1, t2, …, tn}, set of constraints on temporal dimension (derived from Time_Clause).

The algorithm for generating equivalent SQL statements for the initial CliniDAL query using the pivoting approach is shown in Fig. 7
                           . The main difference of this approach from the previous one (creating a huge SQL), is performing the join between fact tables computationally instead of using the DBMS functionalities. This leads to more flexibility in integration of data analytics functionalities into CliniDAL on the one hand in such a way that users will be able to perform data analytics without any need to transfer query results to other data analytics packages like R. For instance, only a few aggregation functions are implemented in DBMSs and more sophisticated statistical functions like t-test and chi-square tests are not implemented. On the other hand, it helps to overcome some limitations of DBMSs like those on applying aggregation functions and matching them with a grouping clause. For instance, in a query patient id, max (temperature) with the time stamp in which the max (temperature) happens, may be required for a patient in a group of patients. Applying aggregation functions (or value function “max” in this case) in SQL statements has to be run by DBMS directly, and requires that all the other non-aggregated items in the selection clause appear in the grouping clause. So, to obtain the appropriate result for the initial query, two separate queries need to be run, one to find the max (temperature) and the other to find the patient id and time stamp with the extracted value for the temperature.

In Fig. 7, Matrix is conceptually a 2 dimensional array. Each row of the Matrix refers to pair of (patient id, time stamp) and each column refers to an attribute. For referring to a cell in the Matrix two hash tables are created. The hash table ATTRIB_DICT maps an attribute to a column number and the hash table ENTITY_DICT maps pair of (patient id, time stamp) to a row number of the Matrix. By executing the generated SQLs in the BaseSQL_list for each RAStatement and using the hash tables, information about the all required EAV attributes will be stored in the Matrix in tabular format while the all constraint on Patient, Location, Care provider and Time dimensions have been applied and only medical constraint on the EAV attributes are left to be applied later. According to the algorithm, the join of one fact table (related to the target EAV attribute) with all required dimension tables are provided in generation of one BaseSQL, which consequently leads to storing the information about smaller group of patients in the Matrix. The Matrix can be kept in temporary store in an SQLITE DB as a table. Then a final simpler SQL statement will be created to filter out irrelevant records from the Matrix with regard to the medical constraints. In some cases aggregation or statistical functions require some post processing actions to apply the functions and compute the desired results.

Hence, the algorithm is described for a hybrid system of EAV and ER design as most EAV systems store some part of their data, like patient demographics, conventionally since EAV makes sense only for sparse data [5]. In our experiment in the ICIP system patient demographics, location information and care providers information are stored conventionally. Although it is rare to have pure EAV design, the algorithm works for systems with pure EAV design by omitting the step 2.


                           Fig. 8
                           , represents the integration algorithm which is required to be applied on the results of the translated BaseSQLs.

Due to the capabilities of CliniDAL a user can compose queries close to natural language. So, they may omit parts of the query and it is the CliniDAL’s responsibility to identify such parts. According to the CliniDAL’s grammar implicit entities can be used in each of the constraint clauses of CliniDAL. Table 2
                            summarizes the solution for translating the implicit entities in each constraint category. The point is that during the parse of the input query a dummy entity with value of “implicit” is created so the query tree structure is the same for all implicit and explicit entities. Then during the translation based on the involving clause and also the value and data/type of the corresponding comparative of the implicit entity (Table 2) a proper action can be performed.

According to Table 2 only categorical comparative values in the Patient and Medical Clauses can be related to implicit entities. SNOMED CT has been used to find the corresponding entity in the Medical Clause while there are a small number of applicable values for patient comparatives (like male and female for gender), help resolving implicit entities in this clause. In the Location clause the implicit entities simply map to the ward and implicit care providers can be identified using the data type of the comparative value. Numeric comparative values are mapped to the id number of care providers, while text comparative values are mapped to name of the care providers. The identification of implicit temporal entities is related to the mapping of other entities. For instance, when attribute A from one fact table and attribute B from another fact table are queried, the temporal comparative value should be applied on the time fields of both the involving tables of the attributes A and B.

Another facility for a CliniDAL user in composing a restricted natural language query is the capability of using qualifier comparative values instead of numeric quantities for medical entities belonging to the medical sub-category scores and measurement. For instance, instead of “temperature>36.5 and temperature<37.5”, a user can simply say “temperature is normal” or “normal temperature”. The syntactic rules for both of these sample constraints are defined in CliniDAL’s grammar in a way that after the parse of the input query a sub-tree with a root of disjunction and two algebraic child nodes is created in the parse tree. Hence we only need to map qualifiers like “normal”, “high” and “low” to their actual values of their medical entity. All the information for accomplishing this task exists in the qualifier_range table in the context model. One problem here is that the ranges of values for qualifiers may vary from one CIS to another. So a generic dictionary has been defined and is loaded during the initialization of CliniDAL to each CIS.

Based on the experiences with the ICIP system, some Medical entities have attributes which need to be able to get more exact results when querying the CIS. The mechanism of storing these attributes may different in various CISs which affects the mapping and translation algorithms. Two solutions are available to resolve the attribute storage issues. One solution is storing the values of the attributes related to a medical entity together and then computing any extra content whenever it is required. For instance, in ICIP four attributes of systolic, diastolic, mean and site are defined for ABP. Values of ABP involve 3 parts constructed using values of systolic, diastolic and site together and the mean can be computed using systolic and diastolic. The problem of this storage solution is that the values related to different attributes have different data types which need more complicated computation strategies to deal with especially in data analytics applications. In this example, systolic and diastolic are numeric while site is string.

The other storage mechanism is storing the values related to different attributes separately. This solution has been used in ICIP, with a unique intervention identifier for ABP and four different attribute identifiers for each of the attributes. Applying attributes for medical entities filters out records of irrelevant attributes; otherwise values related to all the attributes of the interventions will be shown as a result. This solution trades off memory against the number of processes required to deal with these attributes.

A generic solution has been applied in CliniDAL to capture these attributes as well. Firstly, the grammar of the language was enhanced, so the attribute for a medical entity can be expressed optionally using square brackets (like ABP[systolic] and ABP [mean]), to be used in the Medical and Find_Entity clauses. Secondly, the data source context model has been revised by adding the field of ATTRIBUTE to the term_dict table to store surface forms of the attribute used in the query. Also, the field ATTRIB_IDENTIFIER has been added to the term_match table to store the internal representation of the attribute.

The current automatic mapping algorithm is able to map the surface form of the medical entities and their attributes to the internal representation if the first storage solution has been used in the CIS, as all values related to different attributes are stored together. Otherwise, the general mapping process needs to be enhanced by adding one more mapping step to map the attributes. In this case the definition of the table name which stores the description of the attributes in the global configuration file of CliniDAL can lead to more accurate mapping results, however it loses the generality of the mapping algorithm. The main reason to accept this loss in our practical implementation is that a similar definition has been used for medical entities and their attributes in ICIP which makes the similarity based mapping algorithm less accurate. In addition, different entities may have common attributes. For instance 44 different variations have been defined for diastolic and 45 defined for systolic in ICIP table references. Some of them have never been used for data storage so they can be filtered out by using their frequency of usage which is available as a resource in the mapping algorithm. The remaining are common terminologies which have been used for different entities. In addition, in the ICIP system only a few medical entities have different attributes, namely 6 out of 220 mapped entities in our experiment (less than 3%). So, to keep CliniDAL simple, a predefined dictionary is created manually for attribute mappings.

Based on the proposed temporal model in [13], two categories of temporal expressions are applicable in CliniDAL: explicit and implicit. If the 
                           temporal entity
                         of a temporal expression is implicit, the temporal expression is called implicit, otherwise it is called explicit. The explicit category is a constraint which is made of a comparison or junction of several comparisons on an explicit temporal entity (like chart time, admission time, and discharge time) with a time comparative value. This kind of temporal expression can be deployed in a Medical constraint clause, Patient clause and Find_Entity clause of CliniDAL. The details of translation of these temporal expressions are explained in next section.

An implicit temporal expression contains a temporal relation between a whole RAStatement and a temporal comparison clause. The temporal expressions of this category are closer to natural language so they are more complicated in implementation. They also need some special attributes like frequency to be set during the parse and to be translated properly. In this category the temporal dimension which is reflected by the temporal relation is applied to all constraint clauses of the RAStatement, particularly to the all medical entities in the medical constraint clause of CliniDAL if applicable. Here, the role of 
                           Temporal Analyzer
                         (Fig. 9
                        ) is identifying the implicit 
                           Time Entities
                         in the temporal relation and interpreting temporal comparative values including absolute time, relative time and relative event values. With respect to the type of temporal comparative values (absolute time, relative time and relative event) the 
                           Temporal Analyzer
                         performs a different task and returns a time interval. Finally, the temporal relation will be converted to conjunctions or disjunctions of several comparison operations between the interpreted explicit time entity and its related comparative values in the form of absolute time.

Using a Trainable Finite State Automata (TFSA)[18], the 
                           Temporal Analyzer
                         matches time comparative values with a set of regular-expression based patterns as one layer of patterns which then can be adjusted based on general syntactic patterns of CliniDAL’s parser as the second layer of patterns. These patterns provide a two-layer rule-based mechanism in CliniDAL for interpreting temporal expressions.

In the case where the absolute time comparative value has been used in the original CliniDAL query, the 
                           Temporal Analyzer
                         firstly gets the time fields related to each of the entities in the other clauses (principally the Medical Clause and Patient, Location and Care providers if applicable), then creates an explicit time clause using comparisons between each identified time fields and the temporal comparative values. The type of comparison operator depends on the type of temporal relation. Finally, all the explicit time clauses are joined together using a junction operator. For instance, in the query: “Using snomed find_all_values of pid, heart rate, ibw for_patient male before 12/1/2013”, heart rate is mapped to PtAssessment.valueNumber, ibw (ideal body weight) is mapped to the PtDemographic.ValueNumber and the temporal expression “before 12/1/2013” is converted to “PtAssessment.charttime<12/1/2013 and PtDemographic.chartime<12/1/2013”.

To deal with relative times like today, yesterday, the next day, two month ago, etc. firstly, the two-layer rule-based method of the 
                           Temporal Analyzer
                         has to be applied to convert each relative time to its absolute time points. Then a date/time interpreter identifies the related absolute time in the form of interval time with two time points of start and end and the granularity of the second. Then based on the existing information from the temporal relation including relation type, duration, frequency, temporal offset and also the type of matched pattern the 
                           Temporal Analyzer
                         may use one of the time points with other granularities like year, month, day, week, hour and minute rather than second. At this point the relative time is converted to two absolute time points and can be translated as explained previously.

Handling relative events as time comparatives is the most complicated task of the 
                           Temporal Analyzer
                        . To accomplish this task, firstly the event has to be recognized and mapped to proper items in the schema or data part of the CIS. A dictionary of important temporal events in the clinical domain has been created. During the initialization process of CliniDAL on each CIS, the mapping of these events is performed. Similar to relative time comparative values, there may need to be some kind of computation based on the granularity of the comparative values or the type of temporal relation and its other features. The point here is that the actual absolute time can be identified only at run time. So the 
                           Temporal Analyzer
                         creates a special kind of coding for replacement at run time after fetching the data related to the absolute time of the relative event. For instance, in the temporal expression “2days after admission”, it is necessary to find the absolute time of admission for each patient who satisfies these query constraints. Then add two days (temporal granularity) to the admission time for each patient. In addition, mapping the admission as an event may add some new constraints in the where clause under translation.

As explained in the previous section, explicit time entities have been used to create temporal expressions in the Medical, Patient and Find_Entity clauses of CliniDAL. Before translation of the temporal expression to a proper constraint in SQL, the entities need to be mapped to the underlying CIS. Depending on the clause in which the temporal expressions have been used, different directions need to be followed for mapping and translations. Moreover, besides the category of a query term in the CliniDAL main clauses, three other categories can be defined for the temporal dimension for the query term:
                              
                                 (1)
                                 Terms without a time stamp, like demographics or aggregated attributes like MEAN(temperature);

Terms with an instant time stamp, like heart rate and temperature

Terms with interval time stamps, like those related to Census, Diagnosis, and Care providers.

All these considerations make the translation of temporal expressions more challenging. One point is that the entities used in a Medical Clause to compose temporal expression are 
                              dependent entities
                           , which means they need to be attached to a medical attribute of a patient like temperature and heart rate. Based on the investigation on 3 different CISs (including ICIP, ISM and CareVue data warehouse), the dependent time entity is stored in a conventional ER model, even if the CIS design model is EAV. This means that there are one or more explicit time fields in each data table of the CISs. On the other hand, the entities used in a Patient clause are independent from any medical attribute. For instance, date of birth of a patient, or admission and discharge time of patients are in this category. In the Find_Entity clause both dependent and independent entities can be utilized in the simple form (e.g. Find all_values of temperature, chart time, etc.) or aggregated form (e.g. Find all_values of temperature, min(chart time), etc.).

The explicit time entity in a Medical Clause needs to be categorized as a time entity during the categorization process of CliniDAL. In addition the grammar of CliniDAL has been revised to accept medical natural language (MNL) temporal expressions in which relative time/events together with temporal relations like after, before, and during can be used directly. The 
                              Temporal Analyzer
                            module has been used to decode the relative time/events comparative values and also the temporal relations to a set of junctions or algebraic operations between the time entity and inferred absolute time comparatives. As the time entity in the Medical Clause is dependent and also to provide consistency, the temporal constraints have to be applied to all medical attributes in the Medical Clause. So, the mapping of the time entity has been postponed to the translation time. During the translation, equivalent time fields of the query term can be extracted from the context model for each medical entity and can be integrated into the corresponding BaseSQL for the EAV attribute.

As in explicit time entities in a Medical Clause, the time entities in Patient clauses need to be categorized as time during the categorization process and the grammar should be adjusted to accept MNL temporal expressions. But as independent time entities, they need to be mapped before translation. The mapping can be into the ER or EAV models. For instance, the query term “dob” can be mapped to the dateOfBirth field in the D_Encounter dimension table in ICIP (ER mapping), while the query term “admission” is mapped to a row in PtDemographics fact table for each encounter of a patient (EAV mode). During the translation, the constraints on the time entities with ER mapping are applied to all of the BaseSQLs of the EAV attribute as a dimension, while for the time entities with EAV mappings a separate BaseSQL is created.

In the Find_Entity clause both dependent and independent time entities can be used. They also can be used as simple retrieval entities or aggregated entities. In addition, they might have or not have constraints in Patient or Medical Clauses. So, across all of these variations, in general 8 different directions are available for translation which is summarized in the Table 3
                           . Dependent time entities like chart time, start time, end time must be accompanied with at least one medical constraint or one medical entity in the Find_Entity clause. Otherwise, an error message has to be raised during translation.

As explained earlier, based on the investigation on three CIS (including ICIP, ISM and CareVue systems), at least one time field can be found in each fact table storing the temporal dimension of medical entities. For instance, for medical entities like temperature, heart rate, and blood pressure. which need instant time stamp, two time fields of “chart time” and “store time” are preserved in ICIP system. Both of them are supposed to store time at the granularity of milliseconds. However, the former which is mostly used in data analytics stores the data at a granularity of one minute in the real implementation and the second and millisecond portions of temporal data are always zero, while the later stores temporal data exactly to the millisecond.

In addition, when asking a query about different medical attributes through the provided interfaces, it is generally assumed that all the attributes are stored in a tabular format and consequently it is supposed that the same time stamp is used for all medical attributes, while when the EAV design model has been used, the notion of the same time for medical attributes or concurrent medical attributes is a challenging task for two reasons. Firstly, each medical attribute is stored in a different row. As a result the time stamp for two medical attributes for the same patient may or may not be the same. Secondly, the frequency of charting data for different attributes is different. For instance, heart rate and blood pressure are charted at least hourly and at most quarterly while temperature is charted every four hours.

So, in the pivoting approach where the patient id together with the time stamp are used as an entity, reference time stamps need to be defined to match the concurrent attributes of the query. The time stamps of the most frequently charted data for the set of medical attributes in the query can be used as reference time stamps in pivoting. For example, in the query about values of temperature and heart rate, the chart time of heart rate is used as the reference. In the query results there would be some unknown values for temperature at some time points. To resolve the unknown values three approaches can be deployed:
                              
                                 (1)
                                 Values remain unknown so filtering based on EAV attribute constraints may reduce the number of unknown values to be shown to the user.

Use the last known value.

Use an interpolated value.

The first approach has been used in the current work. In addition, the numbers of concurrent attributes were investigated for 1000 randomly selected patients from the ICIP system on the 18 most common medical entities. The left diagram of Fig. 10
                            shows the average number of concurrent attributes per patient out of 1000 patients based on time intervals of an hour and the same information of left diagram but only for the first 50h of admission is shown at right diagram of Fig. 10 which reflects that charting data for patients follows a very regular temporal pattern of quarterly, half hourly and hourly. So, the difference between the time stamps of two known data is at least 15min and can be extended to half an hour or one hour during the interpolation of unknown values.

@&#RESULTS AND DISCUSSION@&#

Four categories of queries have been tested on the current implementation. Table 4
                      shows the categories and number of queries in each category which were all successfully tested. The distribution of test queries in Table 4 is a function of their ease of preparation and ready adaptation. Also, instead of a quality measure for evaluation of the accuracy of translation, a quality process has been used in which the translation process has been repeated several times until it leads to consistent results. In case of inconsistency, an investigation has been performed to resolve the inconsistency.


                     Table 5
                      shows a subset of terms which have been tested in simple data retrieval queries. Once the translation, data retrieval and integration of results of queries in this category have been tested successfully, any combination of their terms can be used in composing queries for other categories for tests. Three sample CliniDAL queries from the above categories together with their translation results and final retrieval query are shown in Tables 6–8
                     
                     
                     . The complete list of tested queries is presented in the Appendix. Hence, some query terms which are used in Tables 5–8 and also in Tables A–D (those will be mapped to EAV tables) have been given an integer identifier in the data storage. These numeric values are arbitrary and specific to each CIS and are a part of internal representation of query terms. For instance, in the ICIP system 997, 1352 and 2119 are internal identifiers for “heart rate”, “temperature” and “ABP” respectively.

The first CliniDAL query (Table 6) is a RAStatement which aims to extract values of heart rates of male patients with constraints on patient, medical and location variables. It is correctly translated to 2 BaseSQL queries for each of the EAV attributes heart rate and temperature. After running these two SQL statements, integrating their results in a tabular format and storing them in the temp_DB, execution of the final SQL statement will provide the required data.

The second query (Table 7) is another RAStatement in the CliniDAL representation with a statistical function (max), and temporal constraint.

The third query (Table 8) is a SHTStatement. It aims to find out whether there is a statistically significant difference, using a t-test, between the average temperature value for 2 groups of patients with ph⩾7.3 and ph<7.3 during the specified time period. During the optimization process of CliniDAL this query is reformed to two RAStatements to declare two groups of patients. So the translation of the whole SHTStatement is converted to translation of two RAStatement. The equivalent BaseSQLs for two groups of patients in ICIP CIS are as follows. After running the final SQLs on the related tables of temp_DB, a t_test is applied on the resulting sets by a post-processing module.

@&#CONCLUSIONS@&#

The test results show that, CliniDAL’s grammar performs correctly for all types of its defined query classes and the initial goal of composing restricted natural language queries is accomplished using the current grammar. However, we believe attaching a well-designed user interface based on the grammar will simplify CliniDAL query composition extensively.

In addition, the generic CliniDAL architecture ensures the portability and common characteristics with EAV data model, can be easily extended to support XML based CISs as well. However, the accuracy of the translation algorithm depends on the mapping algorithm which is more than 84% of the current implementation. One more point is that, the most popular data analytics functionalities in the clinical domain are now available in CliniDAL’s post-processing module which can be extended to support other analytics functions as required. Our experimental results revealed that composing queries in CliniDAL is much easier for clinical staff than SQL queries. An equivalent SQL query with a CliniDAL query can be hundreds of lines. This issue will be considerable for more complex queries like hypothesis testing queries and scientific experiments queries. A separate study is ongoing to use CliniDAL for scientific experimentation.

Furthermore, integrating a clinical terminology like SNOMED-CT to CliniDAL using the TTSCT service helps unify the expression of clinical concepts which can be applied to formalize the terminologies used by different CISs. However, the performance of the TTSCT module needs improvement to get better results on categorization of query terms and their unifications.

More experiments are ongoing on the RPAH-ICU corpus to test the system in answering clinically relevant questions. But the important point based on our current experiments is that the current implementation is only able to answer queries for which their answers come from structural part of the CIS. These queries are mostly related to raw charted data. Two more improvements are targeted for CliniDAL in later developments. One is the ability to answer questions whose answers are not stored in structural part of the CIS while implications of valid answers can be found in the free text part of the CIS. The other is enhancing text searching by semantic searching when the answer to queries stored in the structural part but in a text fields of the data base. The solution to these improvements is using NLP techniques which have been extensively used in our Laboratory and also integrating a clinical terminology like SNOMED-CT into CliniDAL.

The main contribution of this paper is proposing a generic solution for translation of CliniDAL queries to SQL queries. The solution enables the clinical staffs to compose simple retrieval/aggregated queries or more complex research oriented queries in the restricted natural language form of CliniDAL without any knowledge of the underlying schema of the CIS or any SQL-like query language. Particularly, the proposed method simplifies the complexity of handling data mining from CISs with EAV design model.

@&#ACKNOWLEDGMENTS@&#

We would like to give a special thanks to Dr. Stephen Crawshaw for the proof reading of this paper and also to Yuzhong Cheng for the initial work on CliniDAL. We would also like to thank the University of Zanjan for financial support of the whole research period.


                     Tables A–D
                     
                     
                     
                     
                      are tested CliniDAL queries according to generic template for composing query (Fig. 5) and the defined categories (Table 7). The query terms of Tables A–D are forms used in normal clinical language. Particularly the term ‘pid’ indicates a patient identifier.

@&#REFERENCES@&#

