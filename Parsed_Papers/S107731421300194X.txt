@&#MAIN-TITLE@&#Detecting, segmenting and tracking unknown objects using multi-label MRF inference

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We present a framework for detection, segmentation and tracking of multiple objects.


                        
                        
                           
                           The framework has minimal requirements on input for initialization.


                        
                        
                           
                           The choice of MRF inference method is less important, than how scenes are modeled.


                        
                        
                           
                           Proximities are more important than colors as cues for segmentation.


                        
                        
                           
                           For real-time application message passing is more feasible, than graph cuts.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Figure-ground segmentation

Active perception

MRF

Multi-object tracking

Object detection

GPU acceleration

@&#ABSTRACT@&#


               
               
                  This article presents a unified framework for detecting, segmenting and tracking unknown objects in everyday scenes, allowing for inspection of object hypotheses during interaction over time. A heterogeneous scene representation is proposed, with background regions modeled as a combinations of planar surfaces and uniform clutter, and foreground objects as 3D ellipsoids. Recent energy minimization methods based on loopy belief propagation, tree-reweighted message passing and graph cuts are studied for the purpose of multi-object segmentation and benchmarked in terms of segmentation quality, as well as computational speed and how easily methods can be adapted for parallel processing. One conclusion is that the choice of energy minimization method is less important than the way scenes are modeled. Proximities are more valuable for segmentation than similarity in colors, while the benefit of 3D information is limited. It is also shown through practical experiments that, with implementations on GPUs, multi-object segmentation and tracking using state-of-art MRF inference methods is feasible, despite the computational costs typically associated with such methods.
               
            

@&#INTRODUCTION@&#

Objects play a central role in computer vision, and different fields are dedicated to recognize or classify objects in images, or track such objects over time. The former tasks assume models of objects or classes of objects to be learned from sets of training examples. Given a test image, extracted features are associated to the learned models, with the goal of deducing whether a particular object or class exists in the image or not. Object tracking is a general problem, but can be facilitated by taking advantage of similar models, if the tracked object is previously known. While much focus has been given to these fields during the past decades, less focus has been given to that of discovering unknown objects in scenes and tracking these over time. Such a problem assumes that hypotheses of what could constitute real physical objects are first generated from images and then modeled, so that tracking can be initiated. Once tracked the hypothesis of an object can then either be confirmed or rejected, given multiple observations in sequence.

The benefits of doing so include: (1) allowing for finding and modeling of objects outside currently learned classes, and (2) assisting classification and recognition problems by limiting the search space. The task is related to the fields of visual attention and segmentation. Computational models of attention can be used to find regions of interest in images [1], regions that potentially have some semantic meaning to the observer. Few such models, however, are capable of segregating physical objects from the surrounding scene. Work in object segmentation [2,3] on the other hand, aim to segregate foreground objects from their backgrounds, but usually do so with no real concept of what constitutes an object. Instead, a user is needed to indicate the object in the image by for instance framing it [3]. The presented work is more related to recent work by Mishra and Aloimonos [4], where the concept of an object is more central. In their work they segment “simple”objects defined as compact regions enclosed by edge pixel that arise either due to discontinuities in depth or from contact with supporting surfaces. Similarly, we define an object as something that occupies a portion of 3D space, and exhibits some continuity in appearance and shape. Compared to [4] our framework has three main advantages though. First, it runs in real time, thus enabling tracking. Second, as a side effect of the object definition, it produces a model of an object, in terms of its size, rough shape and color distribution. Third, it allows for simultaneous segmentation and tracking of multiple objects, not just a single one.

A motivating goal of the presented work is a system that facilitates active scene and object understanding in realistic indoor settings [5,6]. Given an observed scene containing unknown objects of interests, the system should allow for objects to be modeled and refined over sequences of observations, while the camera pose changes or objects are interacted with by e.g. a robotic manipulator. In such a scenario, segmentation and tracking serve little purpose in themselves, but are used as a means to extract attributes for object understanding over time and guide exploratory actions. The system should, however, be open also to other applications, such as semi-autonomous annotation of image and video data, an application that also requires precision and high speed. Care has thus been taken not to introduce assumptions specific to particular applications.

Tracking previously unseen objects has gained some attention lately [7,8]. Similarly to our work, these methods create models of foregrounds and backgrounds, and segment objects based on measurements of e.g. image intensities and positions. Unlike our work, however, they use level sets for object tracking, and gain their speed from propagating only contours around objects, something that is possible even for multiple objects in real time, as demonstrated in [9]. However, they cannot effortlessly be used in unsupervised scenarios, as they require initial boundaries for initialization and are sensitive with respect to how these boundaries are drawn [10]. We instead take a graph based approach, similar to [4], which allows for more robust segmentation, while enabling unsupervised initialization. Our method performs tracking by modeling and segmenting each frame using not just boundary pixels, but every pixel, and letting model parameters evolve as functions of estimates from previous frames. This enables robustness to changes in object appearance, shape and topology. For additional robustness, in particular for cases when the boundary between an object and its supporting surface is ambiguous, we propose an heterogeneous scene representation that uses a combination of flat surfaces and random clutter for background modeling, with foreground objects modeled as 3D ellipsoids.

The main contributions of this work is a unified framework for principled active object segmentation by modeling the problem over a Markov Random Field (MRF) that
                        
                           •
                           allows for multi-object detection, modeling and tracking,

considers all image pixels for classification, not just those around objects of interest, and

has minimal requirements on user input for initialization.

In an effort not to sacrifice accuracy for speed, we present a thorough analysis of alternative MRF inference methods for segmentation. We study these in terms of both segmentation performance and computational costs, in particular when implemented on massively parallel GPU architectures. We also evaluate different tracking scenarios, where model parameters are predicted and tracked using sets of Kalman filters, and by doing so demonstrating the feasibility for tracking.

The outline of the presentation is as follows. In Section 2 we give an overview of the work related to our study. The theoretical basis for the tested MRF inference methods is given in Section 3. A heterogeneous scene representation for segmentation is presented in Section 4, with foreground objects modeled as 3D ellipsoids and background as a combination of planar surfaces and uniform clutter. In Section 5 the initialization procedure is described and in Section 6 the framework is extended for tracking, using Kalman filters for forward predictions of model parameters. A large series of off-line experiments, testing alternative MRF inference methods, are presented in Section 7, whereas in Section 8 these are studied from a computational point of view. Finally, the presentation is concluded in Section 9 with a discussion on future work.

@&#RELATED WORK@&#

There exists a vast amount of work on tracking of objects through sequences of images. Many of these deal with tracking of specific classes of objects, classes like human body parts [11,12] and vehicles [13,14]. Common for these is that they are all limited to one particular class, and are often optimized with respect to certain characteristics of this class. Model-based methods try to optimize some objective function on the current observation and a hypothesis created from the model. Other methods extract features from the appearance of an object and try to find a mapping to a database including a variety of poses of that object. In this work we aim for more generic solution that allows tracking of object of any kind, as long as these fit our definition of objects, which means that class specific methods are not applicable to our case.

Methods for figure-ground segmentation can be roughly divided into either variational or combinatorial methods. Variational methods assume that a functional is optimized over some continuous space. These can be expressed in terms of either object contours [15,16] or image regions [17,18]. Some methods can be adapted for specific object classes [19–21], but most are implemented as generic segmentation and tracking methods. The contour methods typically base their optimization on image gradients, which can be inherently hard to robustly extract. Our work is more related to the regions methods, where functionals are instead based on how well areas inside and outside an object contour fit some model of respective regions.

What information you use for optimization may vary, depending on use cases and need for robustness. Chan and Vese [18] model foregrounds and backgrounds with only mean intensities, whereas Freedman and Zhang [22] allow arbitrary distributions, but only for foreground regions, while Bibby and Reid [7] use color histograms for both foregrounds and backgrounds [7]. Similarly to our work, Chockalingam et al. [8] model both appearances, spatial positions and region extents. They do this in 2D, however, while the system proposed in this work exploits also 3D data, if such data is available.

Unlike the variational methods, the combinatorial ones typically define the segmentation problem as a labeling problem on a Markov Random Field (MRF), where each pixel is represented by a node that is connected to some local neighborhood. The segmentation is then based on minimizing an energy function (or maximizing a probability) over functions on individual nodes and their neighborhoods using methods like iterated conditional modes (ICM) [23], graph cuts 
                        [24,25], tree-reweighted message passing 
                        [26,27] or loopy belief propagation 
                        [28,29]. Using graph cuts, global minima can be found for binary problems (one foreground and one background), but even for non-convex multi-label problems good approximations exist [27,30].

There are relatively few comparisons made between alternative labeling methods, in particular for multi-object segmentation. Tappen and Freeman [31] compare loopy belief propagation to graph cuts for the purpose of stereo matching. Szeliski et al. [32] study most of the above mentioned methods for a variety of problems, including interactive segmentation, stereo matching, image stitching and denoising. In their work, however, they focus on the methods’ ability to minimize the energy, rather than the quality of the end results, which is not necessarily the same thing. In our work we look into the modeling problem of finding the most likely object models for image segmentation and tracking, and benchmark in terms of the quality of the final segmentation. This is done over time, which means that the energy function is in constant change, and so is the minimum energy.

A popular way of minimizing the energy functionals is formulating the problem with level-sets, introduced in [18]. In this case, a function is defined on the image region, and the object boundary is defined as the zero crossing of this function. The methods search the function that minimizes the energy by propagating this boundary, which is often done using a gradient descent approach. Herein lies two weaknesses with level set based methods; it is easy to get stuck in a local minima, and only small steps can be taken why convergence can be slow. As was shown by Grady et al. in [10], if the energy is defined over a graph instead, global methods like Graph-Cuts [33] can be used which gives a solution with a lower energy in most cases as well as finding it in orders of magnitude fewer iterations and less time. Furthermore, they demonstrate that Graph-Cut based minimization is less sensitive to difference in initialization, something that is desirable for active scene and object understanding. Although real time implementations of level set trackers have been proposed [9], the fact still remains that the solution might be a local minima. In this work we define the segmentation and tracking problem on a graph, reducing the risk of the segmentation getting stuck in a local minima.

For initialization most figure-ground segmentation methods require some form of input from a human operator, a constraint that is critical in particular for autonomous application. Different approaches have been proposed, such as scribbling in the image [2,34], framing the object of interest with a rectangle [3,35], or just indicating object positions with single points [36,37]. Scribbling allows you to directly build appearance models from the scribbled areas. In [38] users interact with an image by defining a rough, wide border around the foreground object and building a color model from the inside and outside of that border. In [2] the marked regions are used for two purposes: as hard constraints during the energy minimization, and as source pixels for intensity histograms that serve as foreground and background models. The user is further allowed to correct faulty segmentation by scribbling in misclassified areas for gradual improvements. Scribbles were also used in [34] to co-segment several images with the same foreground object. Like [2] an operator is allowed to correct for incorrect segmentation. However, rather than having the user manually search for possible improvements, the method identifies ambiguous areas and suggests where to draw new scribbles.

Both [34,39] stress the importance of quick user feedback in interactive scenarios. To speed up the following graph cut, these methods rely on an initial over-segmentation of the image and create an MRF on the segmented regions, rather than on the individual pixels. This means, however, that the final segmentation becomes highly dependent on the quality of the over-segmentation and on how well it obeys the true object boundaries, something that is hard to guarantee in practice. If the over-segmentation is incorrect, there is no way to recover. In our work we thus avoid such over-segmentation, but are still able to reach speed allowing interactive scenarios, by a careful choice of methods based not just on accuracy, but also on how well they can be implemented on parallel hardware.

There are methods that require less input from the user, than those of scribbles. In [3,35], an object is indicated by simply drawing a bounding rectangle around it. This puts other demands on the models, since the only thing known is that the exterior is part of the background – no hard constraints are provided for foreground pixels. Model parameters can therefore not be fixed like the case with scribbles, but have to be optimized along with the labeling, either using an iterative scheme [3] or jointly with the segmentation [35]. In this work we take the approach in [3] and iteratively segment and update model parameters, but do so without even having hard constraints for the background pixels, i.e., no single pixel is a priori assigned to either foreground or background.

Even if framing an object is a quick method for providing user input, it still requires a mouse interface for interaction, which limits its applicability for autonomous systems. The simplest possible method for initialization is that of using just a single seed point. After all, the system needs to know which image region is the one to be regarded as foreground for any figure-ground segmentation to be initiated. Psychophysical studies on visual attention [40,41] have long served as inspiration for computational models [42,43], out of which many have been used in robotics for applications such as gaze control [44]. Despite differences in features used and level of biological relevance, these models all generate image points or regions that are conspicuous with respect to its surroundings, so as to direct computational resources towards regions that are more likely to be of importance to the overall system. There is no guarantee, however, that generated attention points are in fact located on objects of interest. Efforts have been made to bias attention models towards image points where physical objects are more likely to reside, using e.g. contrasts [1], contextual priming [45] or symmetries [46]. In this study we find seed points by detecting high density cluster centers in 3D image disparity space using a combination of Gaussian filtering and mean-shift. Even if this approach resembles the above mentioned attention models, it was not designed to be biologically constrained.

Being given only a single point puts additional requirements on the initialization of foreground models. Mishra and Aloimonos [36] create a log-polar image representation around a selected point and run the segmentation in two passes. The first pass only uses a measure of edgeness [47] for segmentation. In the second pass the segmentation is improved from color models obtained after the first pass. Despite the impressive results, the high computational cost of the edge detector makes it impractical for interactive scenarios. Similarly to Mishra and Aloimonos we apply stereo cues to assist initialization using only single points as foreground seeds. However, while they use stereo to enhance discontinuity edges, we apply them to prune background points from the vicinity of seed points.

The segmentation framework used in this study contains a finite set of models, indexed by 
                        
                           L
                           =
                           {
                           1
                           ,
                           2
                           ,
                           …
                           ,
                           K
                           }
                        
                     , representing a number of foreground object regions and a background. Let 
                        
                           S
                           =
                           {
                           1
                           ,
                           2
                           ,
                           …
                           ,
                           N
                           }
                        
                      be a set of pixel-wise indices and 
                        
                           m
                           =
                           {
                           
                              
                                 m
                              
                              
                                 i
                              
                           
                           ;
                           
                              
                                 m
                              
                              
                                 i
                              
                           
                           ∈
                           M
                           ,
                           i
                           ∈
                           S
                           }
                        
                      a set of measurements, measurements that are observed values of a random field 
                        
                           M
                           =
                           {
                           
                              
                                 M
                              
                              
                                 i
                              
                           
                           ;
                           i
                           ∈
                           S
                           }
                        
                     , where 
                        
                           M
                        
                      is the space of measurements. Also let 
                        
                           L
                           =
                           {
                           
                              
                                 L
                              
                              
                                 i
                              
                           
                           ;
                           i
                           ∈
                           S
                           }
                        
                      be a random field of labels, with realizations 
                        
                           l
                           =
                           {
                           
                              
                                 l
                              
                              
                                 i
                              
                           
                           ;
                           
                              
                                 l
                              
                              
                                 i
                              
                           
                           ∈
                           L
                           ,
                           i
                           ∈
                           S
                           }
                        
                      denoting from which particular model, among the finite set of models, the corresponding measurements are sampled from.

Assume that L is a Markov random field (MRF), which means that dependencies between labels are only local with respect to some neighborhood system 
                        
                           N
                        
                     , and that the state of L is unobservable. Further assume that the random field M is observable and that given a particular labeling l, every measurement m
                     
                        i
                      follows a conditional probability distribution p(m
                     
                        i
                     ∣l
                     
                        i
                     ) of the same known analytic form 
                        
                           f
                           (
                           
                              
                                 m
                              
                              
                                 i
                              
                           
                           ;
                           
                              
                                 θ
                              
                              
                                 
                                    
                                       l
                                    
                                    
                                       i
                                    
                                 
                              
                           
                           )
                        
                     , where 
                        
                           θ
                           =
                           {
                           
                              
                                 θ
                              
                              
                                 l
                              
                           
                           ;
                           l
                           ∈
                           L
                           }
                        
                      is the set of model parameters for the foreground object regions and background. Given that the random variables M
                     
                        i
                      are conditionally independent, that is
                        
                           (1)
                           
                              p
                              (
                              m
                              |
                              l
                              )
                              =
                              
                                 
                                    
                                       ∏
                                    
                                    
                                       i
                                       ∈
                                       S
                                    
                                 
                              
                              p
                              (
                              
                                 
                                    m
                                 
                                 
                                    i
                                 
                              
                              |
                              
                                 
                                    l
                                 
                                 
                                    i
                                 
                              
                              )
                              ,
                           
                        
                     
                  


                     M can be recognized as a hidden Markov random field (HMRF) [48]. The segmentation problem can be summarized as that of finding an estimate 
                        
                           
                              
                                 l
                              
                              
                                 ˆ
                              
                           
                        
                      of the true labeling l
                     ∗, both of which are realizations of the unobservable L, which is related to the observable M through conditional distributions, where M depends on an unknown parameter set θ.

Since both labels and model parameters are unknown and interdependent, the problem of recovering the labeling also involves that of estimating the parameters. Similar problems are often expressed as that of finding a joint maximum a posteriori (MAP) solution to p(θ,
                     l∣m), often using graph cuts in an iterative framework [3,35]. However, by doing so only one particular labeling contributes to the estimation of the model parameters, even if there might be many alternative labelings of almost equal probability. The estimated labeling might well be an artifact due to imperfect modeling and a poor representative of the distribution as a whole.

Thus instead of searching for a joint MAP estimate of labels and parameters, one might seek a MAP estimate of the parameters θ through marginalization over all unknown labelings,
                           
                              (2)
                              
                                 
                                    
                                       θ
                                    
                                    
                                       ˆ
                                    
                                 
                                 =
                                 arg
                                 
                                 
                                    
                                       
                                          max
                                       
                                       
                                          θ
                                       
                                    
                                 
                                 p
                                 (
                                 θ
                                 |
                                 m
                                 )
                                 =
                                 arg
                                 
                                    
                                       
                                          max
                                       
                                       
                                          θ
                                       
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          l
                                          ∈
                                          
                                             
                                                L
                                             
                                             
                                                N
                                             
                                          
                                       
                                    
                                 
                                 p
                                 (
                                 m
                                 ,
                                 l
                                 |
                                 θ
                                 )
                                 p
                                 (
                                 θ
                                 )
                                 .
                              
                           
                        
                     

This can be done by first applying expectation–maximization (EM) for parameter estimation, as will be detailed below, and then find a labeling estimate in a second MAP step by
                           
                              (3)
                              
                                 
                                    
                                       l
                                    
                                    
                                       ˆ
                                    
                                 
                                 =
                                 arg
                                 
                                    
                                       
                                          max
                                       
                                       
                                          l
                                          ∈
                                          
                                             
                                                L
                                             
                                             
                                                N
                                             
                                          
                                       
                                    
                                 
                                 p
                                 (
                                 m
                                 ,
                                 l
                                 |
                                 
                                    
                                       θ
                                    
                                    
                                       ˆ
                                    
                                 
                                 )
                                 =
                                 arg
                                 
                                    
                                       
                                          max
                                       
                                       
                                          l
                                          ∈
                                          
                                             
                                                L
                                             
                                             
                                                N
                                             
                                          
                                       
                                    
                                 
                                 p
                                 (
                                 m
                                 |
                                 l
                                 ,
                                 
                                    
                                       θ
                                    
                                    
                                       ˆ
                                    
                                 
                                 )
                                 p
                                 (
                                 l
                                 )
                                 .
                              
                           
                        
                     

By summing up the influence of all possible labelings in the estimation of the true parameter set θ
                        ∗, one explicitly takes the uncertainties in the data into consideration. If two different interpretations are of equal probability, they both contribute to 
                           
                              
                                 
                                    θ
                                 
                                 
                                    ˆ
                                 
                              
                           
                         with equal weight. Thus in cases where precision and robustness are hard to simultaneously achieve, precision is traded for robustness. In that sense 
                           
                              
                                 
                                    l
                                 
                                 
                                    ˆ
                                 
                              
                           
                         can be seen as the best representation of the full distribution of labels, instead of being one particular labeling that happens to maximize the joint probability distribution.

For L we assume a neighborhood system 
                           
                              N
                           
                         based on four neighbors. We further assume that the dependencies between labels l do not in turn depend on the parameters θ. This means the distribution of labels can be written as
                           
                              (4)
                              
                                 p
                                 (
                                 l
                                 )
                                 =
                                 
                                    
                                       1
                                    
                                    
                                       Z
                                    
                                 
                                 
                                    
                                       
                                          ∏
                                       
                                       
                                          i
                                          ∈
                                          S
                                       
                                    
                                 
                                 f
                                 (
                                 
                                    
                                       l
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 
                                    
                                       
                                          ∏
                                       
                                       
                                          j
                                          ∈
                                          
                                             
                                                N
                                             
                                             
                                                i
                                             
                                          
                                       
                                    
                                 
                                 f
                                 (
                                 
                                    
                                       l
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       l
                                    
                                    
                                       j
                                    
                                 
                                 )
                                 .
                              
                           
                        Here we have also assumed that the label priors f(l
                        
                           i
                        ) are also independent on θ and the same for all pixels. More details on these priors will be given later in Section 4. Due to the conditional independence of M
                        
                           i
                         in the HMRF, measurements are only dependent on their respective labels, which means that we have
                           
                              (5)
                              
                                 p
                                 (
                                 m
                                 ,
                                 l
                                 |
                                 θ
                                 )
                                 =
                                 p
                                 (
                                 m
                                 |
                                 l
                                 ,
                                 θ
                                 )
                                 p
                                 (
                                 l
                                 )
                                 =
                                 =
                                 
                                    
                                       1
                                    
                                    
                                       Z
                                    
                                 
                                 
                                    
                                       
                                          ∏
                                       
                                       
                                          i
                                          ∈
                                          S
                                       
                                    
                                 
                                 p
                                 (
                                 
                                    
                                       m
                                    
                                    
                                       i
                                    
                                 
                                 |
                                 
                                    
                                       l
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 θ
                                 )
                                 f
                                 (
                                 
                                    
                                       l
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 
                                    
                                       
                                          ∏
                                       
                                       
                                          j
                                          ∈
                                          
                                             
                                                N
                                             
                                             
                                                i
                                             
                                          
                                       
                                    
                                 
                                 f
                                 (
                                 
                                    
                                       l
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       l
                                    
                                    
                                       j
                                    
                                 
                                 )
                                 .
                              
                           
                        
                     

The first half on the right side of Eq. (5) represents the first order cliques of the MRF, whereas the second half represents the second order cliques. Like many others we apply a contrast sensitive Potts model [49,50,2,51] for the inter-label dependencies f(l
                        
                           i
                        ,
                        l
                        
                           j
                        ).

The EM algorithm used to find the estimate 
                           
                              
                                 
                                    θ
                                 
                                 
                                    ˆ
                                 
                              
                           
                         in Eq. (2) maximizes 
                           
                              log
                              p
                              (
                              θ
                              |
                              m
                              )
                           
                         with respect to θ, which is equivalent to a maximization of p(θ∣m). This is done iteratively by updating a lower bound 
                           
                              G
                              (
                              θ
                              )
                              =
                              Q
                              (
                              θ
                              |
                              
                                 
                                    θ
                                 
                                 
                                    ′
                                 
                              
                              )
                              +
                              log
                              p
                              (
                              θ
                              )
                              ⩽
                              log
                              p
                              (
                              m
                              |
                              θ
                              )
                              +
                              log
                              p
                              (
                              θ
                              )
                           
                        , where
                           
                              (6)
                              
                                 Q
                                 (
                                 θ
                                 |
                                 
                                    
                                       θ
                                    
                                    
                                       ′
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          l
                                          ∈
                                          
                                             
                                                L
                                             
                                             
                                                N
                                             
                                          
                                       
                                    
                                 
                                 p
                                 (
                                 l
                                 |
                                 m
                                 ,
                                 
                                    
                                       θ
                                    
                                    
                                       ′
                                    
                                 
                                 )
                                 log
                                 p
                                 (
                                 m
                                 ,
                                 l
                                 |
                                 θ
                                 )
                              
                           
                        and θ′ is the parameter estimate from the previous iteration. Given an initial parameter estimate θ
                        0, the algorithm alternates between two steps until convergence. In the first step, the expectation step, the expectation 
                           
                              E
                              [
                              log
                              p
                              (
                              m
                              ,
                              l
                              |
                              θ
                              )
                              ]
                           
                         is evaluated over the conditional distribution of labels p(l∣m,
                        θ′) given the measurements m and the current parameter estimate θ′. In the second step, the maximization step, a new parameter set
                           
                              (7)
                              
                                 
                                    
                                       θ
                                    
                                    
                                       new
                                    
                                 
                                 =
                                 arg
                                 
                                    
                                       
                                          max
                                       
                                       
                                          θ
                                       
                                    
                                 
                                 G
                                 (
                                 θ
                                 )
                              
                           
                        is sought as the set that maximizes the current lower bound. Note that unlike typical maximum likelihood formulations of EM, a prior 
                           
                              log
                              p
                              (
                              θ
                              )
                           
                         is added to the lower bound G(θ). This prior can be used to include dependencies on object specific knowledge or historical estimates.

Unfortunately, since there are K
                        
                           N
                         possible labelings in total, the integration over labelings in Eq. (6) becomes computationally infeasible. However, if gradient descent is applied to maximize the lower bound G(θ) according to Eq. (7), the bound does not have to be explicitly computed, only its gradient with respect to θ. Given that the p(l) in Eq. (5) is assumed to be independent on θ, its terms disappear when the derivative of G(θ) is computed. Thus the objective function 
                           
                              Q
                              (
                              θ
                              |
                              
                                 
                                    θ
                                 
                                 
                                    ′
                                 
                              
                              )
                           
                         can be replaced by
                           
                              (8)
                              
                                 
                                    
                                       Q
                                    
                                    
                                       mrg
                                    
                                 
                                 (
                                 θ
                                 |
                                 
                                    
                                       θ
                                    
                                    
                                       ′
                                    
                                 
                                 )
                                 
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          l
                                          ∈
                                          
                                             
                                                L
                                             
                                             
                                                N
                                             
                                          
                                       
                                    
                                 
                                 (
                                 p
                                 (
                                 l
                                 |
                                 m
                                 ,
                                 
                                    
                                       θ
                                    
                                    
                                       ′
                                    
                                 
                                 )
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          ∈
                                          S
                                       
                                    
                                 
                                 log
                                 p
                                 (
                                 
                                    
                                       m
                                    
                                    
                                       i
                                    
                                 
                                 |
                                 
                                    
                                       l
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 θ
                                 )
                                 )
                              
                           
                        
                        
                           
                              (9)
                              
                                 
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          ∈
                                          S
                                       
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          
                                             
                                                l
                                             
                                             
                                                i
                                             
                                          
                                          ∈
                                          L
                                       
                                    
                                 
                                 log
                                 p
                                 (
                                 
                                    
                                       m
                                    
                                    
                                       i
                                    
                                 
                                 |
                                 
                                    
                                       l
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 θ
                                 )
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          l
                                          ⧹
                                          {
                                          
                                             
                                                l
                                             
                                             
                                                i
                                             
                                          
                                          }
                                          ∈
                                          
                                             
                                                L
                                             
                                             
                                                N
                                                -
                                                1
                                             
                                          
                                       
                                    
                                 
                                 p
                                 (
                                 l
                                 |
                                 m
                                 ,
                                 
                                    
                                       θ
                                    
                                    
                                       ′
                                    
                                 
                                 )
                              
                           
                        
                        
                           
                              (10)
                              
                                 
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          ∈
                                          S
                                       
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          
                                             
                                                l
                                             
                                             
                                                i
                                             
                                          
                                          ∈
                                          L
                                       
                                    
                                 
                                 log
                                 p
                                 (
                                 
                                    
                                       m
                                    
                                    
                                       i
                                    
                                 
                                 |
                                 
                                    
                                       l
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 θ
                                 )
                                 p
                                 (
                                 
                                    
                                       l
                                    
                                    
                                       i
                                    
                                 
                                 |
                                 m
                                 ,
                                 
                                    
                                       θ
                                    
                                    
                                       ′
                                    
                                 
                                 )
                                 .
                              
                           
                        
                     

The second equivalence is due to the fact that the terms in the Eq. (8) involve only one label each. The order of summations can thus be changed, so that an inner summation is done over all labels but l
                        
                           i
                        , while an outer summation is done over l
                        
                           i
                        . This inner-most summation can be identified as the distribution p(l
                        
                           i
                        ∣m,
                        θ′) with the remaining labels marginalized out, as shown in Eq. (10).

Since 
                           
                              
                                 
                                    Q
                                 
                                 
                                    mrg
                                 
                              
                              (
                              θ
                              |
                              
                                 
                                    θ
                                 
                                 
                                    ′
                                 
                              
                              )
                           
                         only involves KN terms, instead of K
                        
                           N
                        , the summation is computationally tractable. Note that the only assumption added to those of the HMRF is that higher-order cliques need to be independent on the parameters θ to be estimated in the EM loop. In [52], where parameters controlling the dependency between labels were also estimated by EM, an approximation based on a MAP estimation of labels computed in the previous update had to be applied in order to reach similar tractability.

The marginal distributions p(l
                           
                              i
                           ∣m,
                           θ′) in Eq. (10) can be estimated with loopy belief propagation using sum-product [28,29], a message passing method that will be referred to as LBP-S in the experiments below. A message m
                           
                              i→j
                           (l
                           
                              j
                           ) can be interpreted as the influence a node i has on a neighboring node j. All messages are initialized to 1 and then iteratively passed in parallel in both direction using the update rule
                              
                                 (11)
                                 
                                    
                                       
                                          m
                                       
                                       
                                          i
                                          →
                                          j
                                       
                                    
                                    (
                                    
                                       
                                          l
                                       
                                       
                                          j
                                       
                                    
                                    )
                                    ←
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             
                                                
                                                   l
                                                
                                                
                                                   i
                                                
                                             
                                          
                                       
                                    
                                    p
                                    (
                                    
                                       
                                          m
                                       
                                       
                                          i
                                       
                                    
                                    |
                                    
                                       
                                          l
                                       
                                       
                                          i
                                       
                                    
                                    ,
                                    θ
                                    )
                                    
                                    
                                       
                                          f
                                       
                                       
                                          i
                                       
                                    
                                    (
                                    
                                       
                                          l
                                       
                                       
                                          i
                                       
                                    
                                    )
                                    
                                    f
                                    (
                                    
                                       
                                          l
                                       
                                       
                                          i
                                       
                                    
                                    ,
                                    
                                       
                                          l
                                       
                                       
                                          j
                                       
                                    
                                    )
                                    
                                    
                                       
                                          
                                             ∏
                                          
                                          
                                             k
                                             ∈
                                             
                                                
                                                   N
                                                
                                                
                                                   i
                                                
                                             
                                             ⧹
                                             j
                                          
                                       
                                    
                                    
                                    
                                       
                                          m
                                       
                                       
                                          k
                                          →
                                          i
                                       
                                    
                                    (
                                    
                                       
                                          l
                                       
                                       
                                          i
                                       
                                    
                                    )
                                    .
                                 
                              
                           After convergence the belief
                              
                                 (12)
                                 
                                    
                                       
                                          b
                                       
                                       
                                          i
                                       
                                    
                                    (
                                    
                                       
                                          l
                                       
                                       
                                          i
                                       
                                    
                                    )
                                    =
                                    p
                                    (
                                    
                                       
                                          m
                                       
                                       
                                          i
                                       
                                    
                                    |
                                    
                                       
                                          l
                                       
                                       
                                          i
                                       
                                    
                                    ,
                                    θ
                                    )
                                    
                                    
                                       
                                          f
                                       
                                       
                                          i
                                       
                                    
                                    (
                                    
                                       
                                          l
                                       
                                       
                                          i
                                       
                                    
                                    )
                                    
                                       
                                          
                                             ∏
                                          
                                          
                                             k
                                             ∈
                                             
                                                
                                                   N
                                                
                                                
                                                   i
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          m
                                       
                                       
                                          k
                                          →
                                          i
                                       
                                    
                                    (
                                    
                                       
                                          l
                                       
                                       
                                          i
                                       
                                    
                                    )
                                 
                              
                           can be computed, which in case of graphs without loops can be shown using induction to be the exact marginal distribution p(l
                           
                              i
                           ∣m,
                           θ′). Even if the procedure is not guaranteed to converge for graphs with loops, it usually does [53,29].

With marginalization, as described above, no hard decisions are imposed on the labeling until after EM convergence, since the modeling is done through a marginalization over all labelings. This might be attractive, if the modeling is more important than the segmentation, and you wish uncertainties in the segmentation to be reflected in the models, instead of letting the models rely on the particular labeling that maximizes the joint probability. However, if the opposite is true and the most probable segmentation is the end goal, such an approach might not be ideal.

An alternative to marginalization is to instead use maximization for the labels in the expectation step of the EM algorithm. By exploiting the local characteristics of MRFs we can write the distribution of labelings in Eq. (9) as
                           
                              (13)
                              
                                 p
                                 (
                                 l
                                 |
                                 m
                                 ,
                                 
                                    
                                       θ
                                    
                                    
                                       ′
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       p
                                       (
                                       m
                                       |
                                       l
                                       ,
                                       
                                          
                                             θ
                                          
                                          
                                             ′
                                          
                                       
                                       )
                                       p
                                       (
                                       l
                                       )
                                    
                                    
                                       p
                                       (
                                       m
                                       )
                                    
                                 
                                 =
                                 
                                    
                                       
                                          ∏
                                       
                                       
                                          i
                                          ∈
                                          S
                                       
                                    
                                 
                                 p
                                 (
                                 
                                    
                                       l
                                    
                                    
                                       i
                                    
                                 
                                 |
                                 
                                    
                                       l
                                    
                                    
                                       
                                          
                                             N
                                          
                                          
                                             i
                                          
                                       
                                    
                                 
                                 ,
                                 
                                    
                                       m
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       θ
                                    
                                    
                                       ′
                                    
                                 
                                 )
                                 ,
                              
                           
                        where
                           
                              (14)
                              
                                 p
                                 (
                                 
                                    
                                       l
                                    
                                    
                                       i
                                    
                                 
                                 |
                                 
                                    
                                       l
                                    
                                    
                                       
                                          
                                             N
                                          
                                          
                                             i
                                          
                                       
                                    
                                 
                                 ,
                                 
                                    
                                       m
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       θ
                                    
                                    
                                       ′
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       p
                                       (
                                       
                                          
                                             m
                                          
                                          
                                             i
                                          
                                       
                                       |
                                       
                                          
                                             l
                                          
                                          
                                             i
                                          
                                       
                                       ,
                                       
                                          
                                             θ
                                          
                                          
                                             ′
                                          
                                       
                                       )
                                       p
                                       (
                                       
                                          
                                             l
                                          
                                          
                                             i
                                          
                                       
                                       |
                                       
                                          
                                             l
                                          
                                          
                                             
                                                
                                                   N
                                                
                                                
                                                   i
                                                
                                             
                                          
                                       
                                       )
                                    
                                    
                                       p
                                       (
                                       
                                          
                                             m
                                          
                                          
                                             i
                                          
                                       
                                       )
                                    
                                 
                              
                           
                        and 
                           
                              
                                 
                                    l
                                 
                                 
                                    
                                       
                                          N
                                       
                                       
                                          i
                                       
                                    
                                 
                              
                           
                         represents the neighboring labels of l
                        
                           i
                        . Zhang et al. [48] proposed a method, called HMRF-EM, that first computes a MAP estimate of the labeling, using the current estimate of the model parameters θ′ and then uses the conditional probabilities 
                           
                              p
                              (
                              
                                 
                                    l
                                 
                                 
                                    i
                                 
                              
                              |
                              
                                 
                                    l
                                 
                                 
                                    
                                       
                                          N
                                       
                                       
                                          i
                                       
                                    
                                 
                              
                              )
                           
                        , where 
                           
                              
                                 
                                    l
                                 
                                 
                                    
                                       
                                          N
                                       
                                       
                                          i
                                       
                                    
                                 
                              
                           
                         is assumed fixed by the MAP estimate. In practice this can be done by replacing the marginal distributions p(l
                        
                           i
                        ∣m,
                        θ′) by the conditionals 
                           
                              p
                              (
                              
                                 
                                    l
                                 
                                 
                                    i
                                 
                              
                              |
                              
                                 
                                    l
                                 
                                 
                                    
                                       
                                          N
                                       
                                       
                                          i
                                       
                                    
                                 
                              
                              ,
                              
                                 
                                    m
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    θ
                                 
                                 
                                    ′
                                 
                              
                              )
                           
                         in Eq. (10), leading to an objective function
                           
                              (15)
                              
                                 
                                    
                                       Q
                                    
                                    
                                       max
                                    
                                 
                                 (
                                 θ
                                 |
                                 
                                    
                                       θ
                                    
                                    
                                       ′
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          ∈
                                          S
                                       
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          
                                             
                                                l
                                             
                                             
                                                i
                                             
                                          
                                          ∈
                                          L
                                       
                                    
                                 
                                 log
                                 p
                                 (
                                 
                                    
                                       m
                                    
                                    
                                       i
                                    
                                 
                                 |
                                 
                                    
                                       l
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 θ
                                 )
                                 
                                 p
                                 (
                                 
                                    
                                       l
                                    
                                    
                                       i
                                    
                                 
                                 |
                                 
                                    
                                       l
                                    
                                    
                                       
                                          
                                             N
                                          
                                          
                                             i
                                          
                                       
                                    
                                 
                                 ,
                                 
                                    
                                       m
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       θ
                                    
                                    
                                       ′
                                    
                                 
                                 )
                              
                           
                        that is maximized in each EM iteration, given the previous estimate of the parameter set θ′.

In order to find a MAP estimate, we will explore four different energy minimization methods. These are all based on an energy formulation that can be written as the negative logarithm of the joint probability p(m,
                        l∣θ) in Eq. (5), that is
                           
                              (16)
                              
                                 E
                                 (
                                 l
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          ∈
                                          S
                                       
                                    
                                 
                                 
                                    
                                       ψ
                                    
                                    
                                       i
                                    
                                 
                                 (
                                 
                                    
                                       l
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 +
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          ∈
                                          S
                                       
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                          ∈
                                          
                                             
                                                N
                                             
                                             
                                                i
                                             
                                          
                                       
                                    
                                 
                                 ψ
                                 (
                                 
                                    
                                       l
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       l
                                    
                                    
                                       j
                                    
                                 
                                 )
                                 ,
                              
                           
                        where 
                           
                              
                                 
                                    ψ
                                 
                                 
                                    i
                                 
                              
                              (
                              
                                 
                                    l
                                 
                                 
                                    i
                                 
                              
                              )
                              =
                              -
                              log
                              (
                              p
                              (
                              
                                 
                                    m
                                 
                                 
                                    i
                                 
                              
                              ∣
                              
                                 
                                    l
                                 
                                 
                                    i
                                 
                              
                              ,
                              θ
                              )
                              f
                              (
                              
                                 
                                    l
                                 
                                 
                                    i
                                 
                              
                              )
                              )
                           
                         and 
                           
                              ψ
                              (
                              
                                 
                                    l
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    l
                                 
                                 
                                    j
                                 
                              
                              )
                              =
                              -
                              log
                              f
                              (
                              
                                 
                                    l
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    l
                                 
                                 
                                    j
                                 
                              
                              )
                           
                         are the negative logarithms of respective first and second order clique functions. The problem of minimizing the energy E(l) is equivalent to that of maximizing p(m,
                        l∣θ), with respect to the labeling l.

The first maximization method to be tested, Iterated Conditional Modes [54], is a very simply and fast approach that operates locally by updating each individual label, based on the current estimate of its neighbors. Labels are initiated to those that maximizes the respective data terms ψ
                           
                              i
                           (l
                           
                              i
                           ). In each subsequent iteration each label is updated by maximizing 
                              
                                 
                                    
                                       ψ
                                    
                                    
                                       i
                                    
                                 
                                 (
                                 
                                    
                                       l
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 +
                                 
                                    
                                       ∑
                                    
                                    
                                       j
                                       ∈
                                       
                                          
                                             N
                                          
                                          
                                             i
                                          
                                       
                                    
                                 
                                 ψ
                                 (
                                 
                                    
                                       l
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       l
                                    
                                    
                                       j
                                    
                                 
                                 )
                              
                           , where l
                           
                              j
                            are the neighboring labels from the previous iteration. It will later be shown in the experimental section that due to its local nature ICM quickly falls into a local minimum, often with an energy higher than those reached by other methods. However, it still serves the purpose as an easily implemented baseline method.

Graph cuts have been successfully used for a large range of labeling problems, such as image restoration [55], stereo matching [56,25] and segmentation [2]. For labeling problems with only two labels, maximum-flow methods can provide exact solutions [55]. For problems with more than two labels, the (α,
                           β)-swap and α-expansion algorithms provide approximate solutions [25], if an edge cost, i.e. a second order clique function ψ(l
                           
                              i
                           ,
                           l
                           
                              j
                           ), constitute a metric. This is true in the case for the contrast sensitive Potts model that we use. Even if graph cut based methods have the weakness of not allowing arbitrary cost functions, they have the strength of permitting earlier results to be exploited for faster convergence. This is particularly beneficial for sequences, where results from previous updates can be reused.

The α-expansion algorithm starts from an arbitrary labeling, which is conveniently given by minimizing the unitary cliques ψ(l
                           
                              i
                           ) at each point. Then the method cycles through every label α and tests whether the current label should be changed to α. Thus at each stage there are two possible hypotheses per image point, either keep the current label or change the label to α. Using a maximum-flow method (such as push-relabel 
                           [57]) this binary labeling problem is found at each stage. Since energy is guaranteed never to increase, the overall method converges. For the later experiments we use Fast-PD [30], a primal–dual alternative to α-expansion, that improves speed by exploiting information from the dual problem to limit the size of graphs in later iterations.

The message passing method max-product [58] is a modification of sum-product in which the summation in Eq. (11) is replaced by a maximization. The computed beliefs approximate the max-marginals max
                              l
                           
                           p(l∣l
                           
                              i
                           ,
                           m,
                           θ′), instead of the marginal distributions p(l
                           
                              i
                           ∣m,
                           θ′) in Eq. (10). For graphs without loops the max-marginals can be computed exactly, using the fact that any distribution of such a graph can be factorized in terms of max-marginals [59]. By maximizing the distribution for each label, a MAP solution to the labeling problem given the parameters θ′ can be obtained and used in Eq. (15). With the energy formulation of Eq. (16), we get the message update function and beliefs
                              
                                 (17)
                                 
                                    
                                       
                                          m
                                       
                                       
                                          i
                                          →
                                          j
                                       
                                       
                                          t
                                          +
                                          1
                                       
                                    
                                    (
                                    
                                       
                                          l
                                       
                                       
                                          j
                                       
                                    
                                    )
                                    =
                                    
                                       
                                          
                                             min
                                          
                                          
                                             
                                                
                                                   l
                                                
                                                
                                                   i
                                                
                                             
                                          
                                       
                                    
                                    (
                                    
                                       
                                          ψ
                                       
                                       
                                          i
                                       
                                    
                                    (
                                    
                                       
                                          l
                                       
                                       
                                          i
                                       
                                    
                                    )
                                    +
                                    ψ
                                    (
                                    
                                       
                                          l
                                       
                                       
                                          i
                                       
                                    
                                    ,
                                    
                                       
                                          l
                                       
                                       
                                          j
                                       
                                    
                                    )
                                    +
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             k
                                             ∈
                                             
                                                
                                                   N
                                                
                                                
                                                   i
                                                
                                             
                                             ⧹
                                             j
                                          
                                       
                                    
                                    
                                       
                                          m
                                       
                                       
                                          k
                                          →
                                          i
                                       
                                       
                                          t
                                       
                                    
                                    (
                                    
                                       
                                          l
                                       
                                       
                                          i
                                       
                                    
                                    )
                                    )
                                 
                              
                           and
                              
                                 (18)
                                 
                                    
                                       
                                          b
                                       
                                       
                                          i
                                       
                                    
                                    (
                                    
                                       
                                          l
                                       
                                       
                                          i
                                       
                                    
                                    )
                                    =
                                    
                                       
                                          ψ
                                       
                                       
                                          i
                                       
                                    
                                    (
                                    
                                       
                                          l
                                       
                                       
                                          i
                                       
                                    
                                    )
                                    +
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             k
                                             ∈
                                             
                                                
                                                   N
                                                
                                                
                                                   i
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          m
                                       
                                       
                                          k
                                          →
                                          i
                                       
                                    
                                    (
                                    
                                       
                                          l
                                       
                                       
                                          i
                                       
                                    
                                    )
                                    .
                                 
                              
                           
                        

In this formulation the maximization is changed to a minimization, which motivates min-sum being used as an alternative name to sum-product. Even if convergence can only be guaranteed for graphs without loops, similarly to sum-product, max-product has be successfully used for applications such decoding of turbo codes [60], super-resolution, shading and reflectance estimation [53], photo-montages and stereo matching [32].

For the experiments in Section 7, we used messages represented as integers and adopted modifications suggested by Felzenszwalb and Huttenlocher [61], to speed-up computations for both LBP-S and LBP-M. Using the fact the Potts model [49] only considers the equality and inequality of neighboring labels, Eq. (17) can be rewritten into two stages making the computational cost linear to the number of states, rather than quadratic. Memory requirements were also reduced by observing that with 4-connected labels, the graph is bipartite, which means that the two disjoint label sets can be updated in sequence, without additional temporary storage.

Unlike tree structures, there is no guarantee that max-product will converge to the true max-marginals and a labeling of lowest energy for graphs with loops. Tree-reweighted max-product methods try to overcome this by representing the graph as a convex combination of trees, with the goal of finding a labeling that is simultaneously optimal with respect to each such tree [26]. This is typically done by solving the dual problem of maximizing the lower bound of the energy, using a linear programming relaxation of the problem.

Given that there is a finite set of possible labels, the energy formulation in Eq. (16) can be rewritten as a linear combination of a set of node and edge parameters ψ
                           ={ψ
                           
                              s;i
                           ,
                           ψ
                           
                              st;ij
                           }, and indicator functions
                              
                                 (19)
                                 
                                    E
                                    (
                                    l
                                    )
                                    =
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             s
                                             ∈
                                             S
                                          
                                       
                                    
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             i
                                             ∈
                                             L
                                          
                                       
                                    
                                    (
                                    
                                       
                                          ψ
                                       
                                       
                                          s
                                          ;
                                          i
                                       
                                    
                                    
                                    
                                       
                                          δ
                                       
                                       
                                          i
                                       
                                    
                                    (
                                    
                                       
                                          l
                                       
                                       
                                          s
                                       
                                    
                                    )
                                    +
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             t
                                             ∈
                                             
                                                
                                                   N
                                                
                                                
                                                   s
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             j
                                             ∈
                                             L
                                          
                                       
                                    
                                    
                                       
                                          ψ
                                       
                                       
                                          st
                                          ;
                                          ij
                                       
                                    
                                    
                                    
                                       
                                          δ
                                       
                                       
                                          i
                                       
                                    
                                    (
                                    
                                       
                                          l
                                       
                                       
                                          s
                                       
                                    
                                    )
                                    
                                       
                                          δ
                                       
                                       
                                          j
                                       
                                    
                                    (
                                    
                                       
                                          l
                                       
                                       
                                          t
                                       
                                    
                                    )
                                    )
                                    .
                                 
                              
                           
                        

Here the indicator function δ
                           
                              i
                           (l
                           
                              s
                           ) is equal to 1 if l
                           
                              s
                           
                           =
                           i and 0 otherwise. Since the representation above is overcomplete, a node parameter can be changed by updating the connected edge parameters accordingly, without affecting the energy function. This process is called reparametrization. The message updates in max-product can be shown to be such a reparametrization, with parameters converging towards the max-marginals for trees [26]. With tree-reweighted message passing, similar updates are done for each tree and in a second operation the parameters are averaged, forcing the parameters of each tree to the same limit point.

In this study we have used the sequential tree-reweighted algorithm for this, since this algorithm guarantees the lower bound never to decrease during averaging [27]. Trees are created in terms of monotonic chains, with respect to some ordering of nodes, which is fortunately trivial for regular structures like images, with only one chain covering each edge. Doing so the update function becomes very efficient,
                              
                                 (20)
                                 
                                    
                                       
                                          m
                                       
                                       
                                          i
                                          →
                                          j
                                       
                                       
                                          t
                                          +
                                          1
                                       
                                    
                                    (
                                    
                                       
                                          l
                                       
                                       
                                          j
                                       
                                    
                                    )
                                    =
                                    
                                       
                                          
                                             min
                                          
                                          
                                             
                                                
                                                   l
                                                
                                                
                                                   i
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                
                                                   1
                                                
                                                
                                                   
                                                      
                                                         n
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   b
                                                
                                                
                                                   i
                                                
                                             
                                             (
                                             
                                                
                                                   l
                                                
                                                
                                                   i
                                                
                                             
                                             )
                                             +
                                             ψ
                                             (
                                             
                                                
                                                   l
                                                
                                                
                                                   i
                                                
                                             
                                             ,
                                             
                                                
                                                   l
                                                
                                                
                                                   j
                                                
                                             
                                             )
                                             -
                                             
                                                
                                                   m
                                                
                                                
                                                   j
                                                   →
                                                   i
                                                
                                                
                                                   t
                                                
                                             
                                             (
                                             
                                                
                                                   l
                                                
                                                
                                                   i
                                                
                                             
                                             )
                                          
                                       
                                    
                                 
                              
                           where
                              
                                 (21)
                                 
                                    
                                       
                                          b
                                       
                                       
                                          i
                                       
                                    
                                    (
                                    
                                       
                                          l
                                       
                                       
                                          i
                                       
                                    
                                    )
                                    =
                                    
                                       
                                          ψ
                                       
                                       
                                          i
                                       
                                    
                                    (
                                    
                                       
                                          l
                                       
                                       
                                          i
                                       
                                    
                                    )
                                    +
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             k
                                             ∈
                                             
                                                
                                                   N
                                                
                                                
                                                   i
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          m
                                       
                                       
                                          k
                                          →
                                          i
                                       
                                       
                                          t
                                       
                                    
                                    (
                                    
                                       
                                          l
                                       
                                       
                                          i
                                       
                                    
                                    )
                                 
                              
                           and n
                           
                              i
                            is the number of chains passing node i. Messages are iteratively passed between nodes, first according to the ordering of nodes and then in the opposite direction. Similarly to LBP-M, a locally optimal MAP solution to the labeling problem is then given by maximizing the beliefs b
                           
                              i
                           (l
                           
                              i
                           ) after convergence, a solution that is used in Eq. (15) for updating the model parameters.

For scene modeling we propose a heterogeneous scene representation comprised of 3D ellipsoids, planar surfaces and a uniform clutter model. The ellipsoids represent physical foreground objects in 3D space and are each modeled by a parameter set θ
                     
                        f
                     . Backgrounds are assumed to contain combinations of bounding planes and uniform clutter, modeled by parameters θ
                     
                        p
                      and θ
                     
                        c
                      respectively. A bounding plane is defined as a plane that limits the extent of the scene, such as walls, floors or table-top surfaces. All modeled foreground objects are assumed to be placed on the sides of such planes facing the camera. Additional details on the definition of the complete parameter set θ
                     =
                     θ
                     
                        f
                     
                     ∪
                     θ
                     
                        p
                     
                     ∪
                     θ
                     
                        c
                      will be given below. For brevity the notations assume that there is only one foreground object and a single bounding plane.

In the presented implementation the measurements at pixel i, m
                     
                        i
                     
                     =(p
                     
                        i
                     ,
                     c
                     
                        i
                     ), consists of two components, a spatial components and a color component. The spatial component p
                     
                        i
                     
                     =(x
                     
                        i
                     ,
                     y
                     
                        i
                     ,
                     d
                     
                        i
                     ) is given by image point positions (x
                     
                        i
                     ,
                     y
                     
                        i
                     ) and binocular disparities d
                     
                        i
                     . It is assumed that disparities can be undefined, i.e. accurate disparities do not have to exist for every individual image point. In lack of disparities, inference will be based on (x
                     
                        i
                     ,
                     y
                     
                        i
                     ) only. The color component c
                     
                        i
                     
                     =(h
                     
                        i
                     ,
                     s
                     
                        i
                     ,
                     v
                     
                        i
                     ) is given in HSV space, where the three values denote hue, saturation and luminance respectively.

A foreground scene part is represented by a 3D ellipsoid and assumed to be normally distributed in image-disparity space, P(p
                     
                        i
                     ∣l
                     
                        i
                     
                     =
                     l
                     
                        f
                     ,
                     θ)=
                     n(p
                     
                        i
                     ;
                     p
                     
                        f
                     ,Δ
                        f
                     ). Here 
                        
                           n
                           (
                           x
                           ;
                           
                              
                                 x
                              
                              
                                 ¯
                              
                           
                           ,
                           Δ
                           )
                        
                      denotes a normal distribution with mean 
                        
                           
                              
                                 x
                              
                              
                                 ¯
                              
                           
                        
                      and covariance Δ. The disparities of the planar background parts are modeled as a normal distribution, with the mean linearly dependent on the image coordinates, P(d
                     
                        i
                     ∣l
                     
                        i
                     
                     =
                     l
                     
                        p
                     ,
                     θ)=
                     n(d
                     
                        i
                     ;
                     a
                     
                        p
                     
                     x
                     
                        i
                     
                     +
                     b
                     
                        p
                     
                     y
                     
                        i
                     
                     +
                     d
                     
                        p
                     ,Δ
                        p
                     ). Such a plane can be shown to correspond to a planar surface also in metric 3D space. The plane, however, has some ‘thickness’ given by Δ
                        p
                     , which can be arbitrarily large. For the clutter part the disparities are modeled as a normal distribution, P(d
                     
                        i
                     ∣l
                     
                        i
                     
                     =
                     l
                     
                        c
                     ,
                     θ)=
                     n(d
                     
                        i
                     ;
                     d
                     
                        c
                     ,Δ
                        c
                     ). Finally, image point positions are assumed to be uniformly distributed for both planar and clutter parts, P(x
                     
                        i
                     ,
                     y
                     
                        i
                     ∣l
                     
                        i
                     
                     =
                     l
                     
                        p
                     ,
                     θ)=
                     P(x
                     
                        i
                     ,
                     y
                     
                        i
                     ∣l
                     
                        i
                     
                     =
                     l
                     
                        c
                     ,
                     θ)=1/N, where N is the total number of points in image space.

The color distribution of each scene part is represent by normalized 2D histograms of hue and saturation; p(h
                     
                        i
                     ,
                     s
                     
                        i
                     ∣l
                     
                        i
                     
                     =
                     l
                     
                        f
                     ,
                     θ)=
                     H
                     
                        f
                     (h
                     
                        i
                     ,
                     s
                     
                        i
                     ), p(h
                     
                        i
                     ,
                     s
                     
                        i
                     ∣l
                     
                        i
                     
                     =
                     l
                     
                        p
                     ,
                     θ)=
                     H
                     
                        p
                     (h
                     
                        i
                     ,
                     s
                     
                        i
                     ) and p(h
                     
                        i
                     ,
                     s
                     
                        i
                     ∣l
                     
                        i
                     
                     =
                     l
                     
                        c
                     ,
                     θ)=
                     H
                     
                        c
                     (h
                     
                        i
                     ,
                     s
                     
                        i
                     ). With these histograms stacked into vectors c
                     
                        f
                     , c
                     
                        p
                      and c
                     
                        c
                     , the complete set of model parameters is given by
                        
                           (22)
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             
                                                θ
                                             
                                             
                                                f
                                             
                                          
                                          =
                                          {
                                          
                                             
                                                p
                                             
                                             
                                                f
                                             
                                          
                                          ,
                                          
                                             
                                                Δ
                                             
                                             
                                                f
                                             
                                          
                                          ,
                                          
                                             
                                                c
                                             
                                             
                                                f
                                             
                                          
                                          }
                                          ,
                                       
                                    
                                 
                                 
                                    
                                    
                                       
                                          
                                             
                                                θ
                                             
                                             
                                                p
                                             
                                          
                                          =
                                          {
                                          
                                             
                                                a
                                             
                                             
                                                p
                                             
                                          
                                          ,
                                          
                                             
                                                b
                                             
                                             
                                                p
                                             
                                          
                                          ,
                                          
                                             
                                                d
                                             
                                             
                                                p
                                             
                                          
                                          ,
                                          
                                             
                                                Δ
                                             
                                             
                                                p
                                             
                                          
                                          ,
                                          
                                             
                                                c
                                             
                                             
                                                p
                                             
                                          
                                          }
                                          ,
                                       
                                    
                                 
                                 
                                    
                                    
                                       
                                          
                                             
                                                θ
                                             
                                             
                                                c
                                             
                                          
                                          =
                                          {
                                          
                                             
                                                d
                                             
                                             
                                                c
                                             
                                          
                                          ,
                                          
                                             
                                                Δ
                                             
                                             
                                                c
                                             
                                          
                                          ,
                                          
                                             
                                                c
                                             
                                             
                                                c
                                             
                                          
                                          }
                                          .
                                       
                                    
                                 
                              
                           
                        
                     
                  

These parameters are iteratively estimated using the MRF inference methods described in Section 3 above, where the unitary terms p(m
                     
                        i
                     ∣l
                     
                        i
                     ,
                     θ)f(l
                     
                        i
                     ) are given by the label priors f(l
                     
                        i
                     ) and the measurement conditionals that can be summarized as
                        
                           
                              
                                 
                                    
                                    
                                       
                                          P
                                          (
                                          
                                             
                                                m
                                             
                                             
                                                i
                                             
                                          
                                          |
                                          
                                             
                                                l
                                             
                                             
                                                i
                                             
                                          
                                          =
                                          
                                             
                                                l
                                             
                                             
                                                f
                                             
                                          
                                          ,
                                          θ
                                          )
                                          =
                                          n
                                          (
                                          
                                             
                                                p
                                             
                                             
                                                i
                                             
                                          
                                          ;
                                          
                                             
                                                p
                                             
                                             
                                                f
                                             
                                          
                                          ,
                                          
                                             
                                                Δ
                                             
                                             
                                                f
                                             
                                          
                                          )
                                          
                                          
                                             
                                                H
                                             
                                             
                                                f
                                             
                                          
                                          (
                                          
                                             
                                                h
                                             
                                             
                                                i
                                             
                                          
                                          ,
                                          
                                             
                                                s
                                             
                                             
                                                i
                                             
                                          
                                          )
                                          ,
                                       
                                    
                                 
                                 
                                    
                                    
                                       
                                          P
                                          (
                                          
                                             
                                                m
                                             
                                             
                                                i
                                             
                                          
                                          |
                                          
                                             
                                                l
                                             
                                             
                                                i
                                             
                                          
                                          =
                                          
                                             
                                                l
                                             
                                             
                                                p
                                             
                                          
                                          ,
                                          θ
                                          )
                                          =
                                          
                                             
                                                N
                                             
                                             
                                                -
                                                1
                                             
                                          
                                          
                                          n
                                          (
                                          
                                             
                                                d
                                             
                                             
                                                i
                                             
                                          
                                          ;
                                          
                                             
                                                a
                                             
                                             
                                                p
                                             
                                          
                                          
                                             
                                                x
                                             
                                             
                                                i
                                             
                                          
                                          +
                                          
                                             
                                                b
                                             
                                             
                                                p
                                             
                                          
                                          
                                             
                                                y
                                             
                                             
                                                i
                                             
                                          
                                          +
                                          
                                             
                                                d
                                             
                                             
                                                p
                                             
                                          
                                          ,
                                          
                                             
                                                Δ
                                             
                                             
                                                p
                                             
                                          
                                          )
                                          
                                          
                                             
                                                H
                                             
                                             
                                                p
                                             
                                          
                                          (
                                          
                                             
                                                h
                                             
                                             
                                                i
                                             
                                          
                                          ,
                                          
                                             
                                                s
                                             
                                             
                                                i
                                             
                                          
                                          )
                                          ,
                                       
                                    
                                 
                                 
                                    
                                    
                                       
                                          P
                                          (
                                          
                                             
                                                m
                                             
                                             
                                                i
                                             
                                          
                                          |
                                          
                                             
                                                l
                                             
                                             
                                                i
                                             
                                          
                                          =
                                          
                                             
                                                l
                                             
                                             
                                                c
                                             
                                          
                                          ,
                                          θ
                                          )
                                          =
                                          
                                             
                                                N
                                             
                                             
                                                -
                                                1
                                             
                                          
                                          
                                          n
                                          (
                                          
                                             
                                                d
                                             
                                             
                                                i
                                             
                                          
                                          ;
                                          
                                             
                                                d
                                             
                                             
                                                c
                                             
                                          
                                          ,
                                          
                                             
                                                Δ
                                             
                                             
                                                c
                                             
                                          
                                          )
                                          
                                          
                                             
                                                H
                                             
                                             
                                                c
                                             
                                          
                                          (
                                          
                                             
                                                h
                                             
                                             
                                                i
                                             
                                          
                                          ,
                                          
                                             
                                                s
                                             
                                             
                                                i
                                             
                                          
                                          )
                                          .
                                       
                                    
                                 
                              
                           
                        
                     
                  

For single images the prior distribution f(l
                     
                        i
                     ) is assumed uniform. However, in the case of tracking they are changed based on the areas of segments from the previous update. For inter-label dependencies we a contrast sensitive Potts model [49,50]
                     
                        
                           (23)
                           
                              f
                              (
                              
                                 
                                    l
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    l
                                 
                                 
                                    j
                                 
                              
                              )
                              =
                              exp
                              
                                 
                                    
                                       -
                                       γ
                                       [
                                       
                                          
                                             l
                                          
                                          
                                             i
                                          
                                       
                                       
                                       ≠
                                       
                                       
                                          
                                             l
                                          
                                          
                                             j
                                          
                                       
                                       ]
                                       exp
                                       
                                          
                                             
                                                -
                                                
                                                   
                                                      
                                                         
                                                            (
                                                            
                                                               
                                                                  v
                                                               
                                                               
                                                                  i
                                                               
                                                            
                                                            -
                                                            
                                                               
                                                                  v
                                                               
                                                               
                                                                  j
                                                               
                                                            
                                                            )
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                   
                                                   
                                                      2
                                                      
                                                         
                                                            σ
                                                         
                                                         
                                                            v
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                              ,
                           
                        
                     where [ϕ] is an indicator function equal to 1 if ϕ is true and 0 otherwise, 
                        
                           {
                           
                              
                                 v
                              
                              
                                 i
                              
                           
                           ;
                           i
                           ∈
                           S
                           }
                        
                      the image intensities for the corresponding labels, 
                        
                           
                              
                                 σ
                              
                              
                                 v
                              
                              
                                 2
                              
                           
                        
                      the variance of intensity gradients between neighbors across the whole image and γ is a constant typically set to about 50.

Initialization of scene parts relies on two sources of information (1) the number of foreground parts to be instantiated and (2) their expected sizes in 3D. This information can be provided by various means, e.g., by a human operator, an object detector tailored for the particular application or a saliency based model of visual attention [1]. For the later experiments we use a procedure that allows detection of unknown objects using 3D data, as will be explained below. There is no requirement on either framing of parts or scribbling within parts, both of which would require a human operator and a mouse interface. The intention has been to keep the required information limited, making the applicability of the system as wide as possible. In an earlier version of the system [62], single foreground parts were always expected to be found in the center of view. This was possible by letting an attention mechanism control the camera system placing the detected regions of interest in the center after a view change. For multi-object scenarios this is no longer convenient and we thus use a different approach.

The initialization begins with all image points assigned to the clutter part that is represented by θ
                     
                        c
                     . From these clutter points, planar surfaces are hypothesized through random sampling and linear fitting in (x,
                     y,
                     d)-space. For those plane hypotheses that have a high enough number of supporting 3D points, the total number of points on either side of corresponding plane is counted. If the vast majority of points are on the side facing the camera system, which means that the plane is placed along the boundaries of the visible scene, this plane is kept, while those planes that cut through the scene are disregarded. In indoor settings there are rarely more than three such bounding planes, typically corresponding to walls, floors, ceilings and table tops. Planes are then selected in a greedy manner, in the order of number of supported 3D points. For each selected plane a scene part is instantiated and represented by a θ
                     
                        p
                      set, with the corresponding clutter points reassigned to this new part. The process is repeated, until no more bounding planes can be found.

Once planar scene parts have been initiated, only clutter points located inside the boundaries of the observed scene remain. These remaining points are first sliced up into a number of overlapping intervals in depth, each represented by a binary mask of those points that exist in each slice [63]. Each slice is then blurred by a 2D Gaussian kernel that has a projective size given by the expected 3D size and the mean depth of the slice. The resulting maxima after blurring of slices serve as seed points for a mean-shift operation [64] that iteratively searches for high density cluster centers. The kernel used for mean-shift is similar to the one used for blurring, but applied to the 3D cloud of clutter points, rather than in 2D within each slice. After mean-shift has converged, centers are greedily selected based on the highest number of supporting 3D points. Since points located close to the camera are more densely distributed, there is thus a natural bias towards nearby parts, such that these are selected first.

Foreground scene parts are finally instantiated, and represented by a θ
                        
                           f
                         set each, with the selected cluster centers as their initial positions p
                        
                           f
                        . A small 3D ball is placed around each center and points located within such a ball are reassigned to the corresponding part. Like the kernels used for blurring and mean-shift, the size of these balls is also given by the expected 3D size. However, to prevent nearby scene parts from affecting the initialization, the ball size is set to a smaller fraction of the expected size. Even if the resulting initial segments do not cover the full parts, they will grow once the EM loop is started. In the beginning, the disparity cue tends to be dominating, while the color cue is able to fill the gaps for those points that lack disparities. Some experiments are given in Section 7, illustrating the trade-off between having large balls, to cover most of the target scene parts, and small balls, to prevent neighboring parts from interfering.

To extend the scene part modeling and segmentation framework to tracking, we apply temporal filters to predict the model parameters between subsequent image frames. Thus instead of directly using the results from a previous frame to initialize the EM iteration of the next, we perform the initialization using a set of predicted parameters. These parameters are also used for queries by external processes, such as the motor controller of a robotic head system. Since information survives over time, only a few EM iterations are necessary for each new frame, which allows for segmented objects to be tracked in real-time, using an implementation such at the one described in Section 8. Instead of a typical 20 iterations to reach convergence in off-line use, 3 iterations are usually enough in on-line use to reach acceptable results.

We differentiate between model parameters that are considered as intrinsic or extrinsic. Intrinsic parameters are those that are assumed constant over time, whereas extrinsic parameters change as objects and cameras are moving from one frame to the next. Among the parameters in Eq. (22) we regard the covariance matrix of foreground points Δ
                           f
                        , the ‘thickness’ of planar surfaces Δ
                           p
                        , the background clutter parameters d
                        
                           c
                         and Δ
                           c
                        , and the three color models c
                        
                           f
                        , c
                        
                           p
                         and c
                        
                           c
                        , as intrinsic parameters. All these are filtered element-wise by an exponentially decaying kernel, which in effect is the same as Kalman filtering where the filtered parameter is assumed constant over time. For the experiments in Section 6.3 we use a kernel that has decayed to 50% of its maximum value after 10 frames. Temporal filtering is particularly efficient for the color models, since it allows sampling over time and prevents sparsity in the population of histogram bins.

Among the extrinsic parameters we count the center of gravity of foreground objects in 3D image-disparity space (x
                        
                           f
                        ,
                        y
                        
                           f
                        ,
                        d
                        
                           f
                        ) and the parameters of the planar surfaces (a
                        
                           p
                        ,
                        b
                        
                           p
                        ,
                        d
                        
                           p
                        ), parameters that relate disparities to image coordinates according to d(x,
                        y)=
                        a
                        
                           p
                        
                        x
                        +
                        b
                        
                           p
                        
                        y
                        +
                        d
                        
                           p
                        . When cameras or objects are moving, these parameters change. For integration of information over time we apply extended Kalman filters (EKF). Such filters have two stages, a predict stage and an update stage, that can be summarized in two equations.
                           
                              
                                 
                                    
                                       
                                       
                                          
                                             
                                                
                                                   x
                                                
                                                
                                                   k
                                                
                                             
                                             =
                                             f
                                             (
                                             
                                                
                                                   x
                                                
                                                
                                                   k
                                                   -
                                                   1
                                                
                                             
                                             ,
                                             
                                                
                                                   u
                                                
                                                
                                                   k
                                                   -
                                                   1
                                                
                                             
                                             )
                                             +
                                             
                                                
                                                   w
                                                
                                                
                                                   k
                                                   -
                                                   1
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                                
                                                   z
                                                
                                                
                                                   k
                                                
                                             
                                             =
                                             h
                                             (
                                             
                                                
                                                   x
                                                
                                                
                                                   k
                                                
                                             
                                             )
                                             +
                                             
                                                
                                                   v
                                                
                                                
                                                   k
                                                
                                             
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        
                     

Here x
                        
                           k
                         denotes the state of a process governed by a transition function f(x
                        
                           k
                        ,
                        u
                        
                           k
                        ), where u
                        
                           k
                         is an external control input and z
                        
                           k
                         is the measurement at frame k. In our case the observation function h(x
                        
                           k
                        ) is always assumed to be an identity function with respect to the parameters of the model in question. The random variables w
                        
                           k
                         and v
                        
                           k
                         represent the process and measurement noise, and are assumed to be zero mean and normal distributed, with covariances W and V respectively.

As illustrated in Fig. 1
                        , the current state x
                        
                           k
                         after the predict stage is used as the initial parameters θ
                        
                           pred
                         of the segmentation system, while the resulting model parameters θ after segmentation are used as measurements z
                        
                           k
                         in the update stage. Note that the segmentation system does not use the filtered parameters during the EM iterations, but only for initialization, which is its most critical phase. This allows for the overall system to cope with situations such as when individual images are corrupted by motion blur or when nearby objects are temporarily merged due to poor contrasts, without making the system overly slow at responding to rapid changes.

For both foreground objects and planar surfaces, predictions of parameters over time are guided by estimates of the dominating optical flow. Scale-invariant SIFT features [65] are tracked between frames and for each component an estimate u
                        =(u
                        
                           x
                        ,
                        u
                        
                           y
                        ) is given as the median x-wise and y-wise flow, computed over the corresponding region from the segmentation of the previous frame. For real-time performance feature extraction, as well as matching, can be done using a GPU implementation such as the one detailed later in Section 8. With the median flow used as a control input u
                        
                           k
                         to the respective EKFs, the process noise w
                        
                           k
                         expresses the uncertainties in how well this median flow can predict the change in parameters.


                        Planar surface EKF. The effect a moving camera has on the planar surface parameters, depends on the nature of the motion. Rotations around the normal of the plane leave all the parameters unchanged. Similarly, only translations along the normal affect the parameters and do this as a uniform scaling of all three parameters. In most typical scenarios, however, this translation is insignificant compared to a rotation, especially if the surface is horizontal and the camera keeps a fixed distance from the ground.

Since depths are unaffected by rotations, the disparity is constant for an image point that has moved due to a rotation. Furthermore, if rotations around the camera axis are assumed to be small, the optical flow induced by a rotation can be approximated by a constant flow across the whole image. With 
                           
                              (
                              
                                 
                                    a
                                 
                                 
                                    p
                                 
                                 
                                    ′
                                 
                              
                              ,
                              
                                 
                                    b
                                 
                                 
                                    p
                                 
                                 
                                    ′
                                 
                              
                              ,
                              
                                 
                                    d
                                 
                                 
                                    p
                                 
                                 
                                    ′
                                 
                              
                              )
                           
                         being the parameters after a rotation and (u
                        
                           x
                        ,
                        u
                        
                           y
                        ) the median flow estimated by feature tracking, the disparity at point (x,
                        y) can thus be written as
                           
                              
                                 d
                                 (
                                 x
                                 ,
                                 y
                                 )
                                 =
                                 
                                    
                                       a
                                    
                                    
                                       p
                                    
                                    
                                       ′
                                    
                                 
                                 x
                                 +
                                 
                                    
                                       b
                                    
                                    
                                       p
                                    
                                    
                                       ′
                                    
                                 
                                 y
                                 +
                                 
                                    
                                       d
                                    
                                    
                                       p
                                    
                                    
                                       ′
                                    
                                 
                                 =
                                 
                                    
                                       a
                                    
                                    
                                       p
                                    
                                 
                                 (
                                 x
                                 -
                                 
                                    
                                       u
                                    
                                    
                                       x
                                    
                                 
                                 )
                                 +
                                 
                                    
                                       b
                                    
                                    
                                       p
                                    
                                 
                                 (
                                 y
                                 -
                                 
                                    
                                       u
                                    
                                    
                                       y
                                    
                                 
                                 )
                                 +
                                 
                                    
                                       d
                                    
                                    
                                       p
                                    
                                 
                                 =
                                 
                                    
                                       a
                                    
                                    
                                       p
                                    
                                 
                                 x
                                 +
                                 
                                    
                                       b
                                    
                                    
                                       p
                                    
                                 
                                 y
                                 +
                                 (
                                 
                                    
                                       d
                                    
                                    
                                       p
                                    
                                 
                                 -
                                 
                                    
                                       a
                                    
                                    
                                       p
                                    
                                 
                                 
                                    
                                       u
                                    
                                    
                                       x
                                    
                                 
                                 -
                                 
                                    
                                       b
                                    
                                    
                                       p
                                    
                                 
                                 
                                    
                                       u
                                    
                                    
                                       y
                                    
                                 
                                 )
                                 .
                              
                           
                        
                     

This leads us to the process transition function of the corresponding EKF that, using a constant velocity assumption for the surface parameters, is given by
                           
                              (24)
                              
                                 f
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       p
                                    
                                 
                                 ,
                                 u
                                 )
                                 =
                                 
                                    
                                       [
                                       
                                          
                                             a
                                          
                                          
                                             p
                                          
                                       
                                       +
                                       
                                          
                                             
                                                
                                                   a
                                                
                                                
                                                   ̇
                                                
                                             
                                          
                                          
                                             p
                                          
                                       
                                       ,
                                       
                                          
                                             b
                                          
                                          
                                             p
                                          
                                       
                                       +
                                       
                                          
                                             
                                                
                                                   b
                                                
                                                
                                                   ̇
                                                
                                             
                                          
                                          
                                             p
                                          
                                       
                                       ,
                                       
                                          
                                             d
                                          
                                          
                                             p
                                          
                                       
                                       +
                                       
                                          
                                             
                                                
                                                   d
                                                
                                                
                                                   ̇
                                                
                                             
                                          
                                          
                                             p
                                          
                                       
                                       -
                                       
                                          
                                             a
                                          
                                          
                                             p
                                          
                                       
                                       
                                          
                                             u
                                          
                                          
                                             x
                                          
                                       
                                       -
                                       
                                          
                                             b
                                          
                                          
                                             p
                                          
                                       
                                       
                                          
                                             u
                                          
                                          
                                             y
                                          
                                       
                                       ]
                                    
                                    
                                       ⊤
                                    
                                 
                                 ,
                              
                           
                        where the observation function is
                           
                              (25)
                              
                                 h
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       p
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       [
                                       
                                          
                                             a
                                          
                                          
                                             p
                                          
                                       
                                       ,
                                       
                                          
                                             b
                                          
                                          
                                             p
                                          
                                       
                                       ,
                                       
                                          
                                             d
                                          
                                          
                                             p
                                          
                                       
                                       ]
                                    
                                    
                                       ⊤
                                    
                                 
                                 .
                              
                           
                        
                     

The state consists of the three surface parameters and their corresponding velocities, that is 
                           
                              
                                 
                                    x
                                 
                                 
                                    p
                                 
                              
                              =
                              
                                 
                                    [
                                    
                                       
                                          a
                                       
                                       
                                          p
                                       
                                    
                                    ,
                                    
                                       
                                          b
                                       
                                       
                                          p
                                       
                                    
                                    ,
                                    
                                       
                                          d
                                       
                                       
                                          p
                                       
                                    
                                    ,
                                    
                                       
                                          
                                             
                                                a
                                             
                                             
                                                ̇
                                             
                                          
                                       
                                       
                                          p
                                       
                                    
                                    ,
                                    
                                       
                                          
                                             
                                                b
                                             
                                             
                                                ̇
                                             
                                          
                                       
                                       
                                          p
                                       
                                    
                                    ,
                                    
                                       
                                          
                                             
                                                d
                                             
                                             
                                                ̇
                                             
                                          
                                       
                                       
                                          p
                                       
                                    
                                    ]
                                 
                                 
                                    ⊤
                                 
                              
                           
                        . Note here that 
                           
                              
                                 
                                    
                                       
                                          d
                                       
                                       
                                          ̇
                                       
                                    
                                 
                                 
                                    p
                                 
                              
                           
                         does not really correspond to the velocity of d
                        
                           p
                        , but to a systematic bias between the change of d
                        
                           p
                         and what can be predicted by a
                        
                           p
                        
                        u
                        
                           x
                        
                        +
                        b
                        
                           p
                        
                        u
                        
                           y
                        . Due to the orientation of the plane and the centroid of the tracked features, this bias changes over time.

For the experiments given below we use a covariance matrix for the process
                           
                              
                                 
                                    
                                       W
                                    
                                    
                                       p
                                    
                                 
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   A
                                                   /
                                                   3
                                                
                                                
                                                   A
                                                   /
                                                   2
                                                
                                             
                                             
                                                
                                                   A
                                                   /
                                                   2
                                                
                                                
                                                   A
                                                
                                             
                                          
                                       
                                    
                                 
                                 ,
                              
                           
                        with A
                        =diag (0.0004,0.0025,4), which can be seen as the velocity covariance due to acceleration. For the measurement noise we use a covariance matrix V
                        
                           p
                        
                        =diag (0.001,0.001,4). The process noise was estimated by minimizing the prediction errors over a series of recorded image sequences, while the measurement noise was estimated from multiple images of the same static scenes.


                        Foreground object EKF. The combined effect of a camera rotation and translation on the foreground object parameters is a translation in the image plane. Typically, the rotational flow components dominates the translational one. Only if the camera approaches the object, do the disparities change. Given that the control input, i.e. the estimated median flow (u
                        
                           x
                        ,
                        u
                        
                           y
                        ) computed with feature tracking, gives a good prediction of the change in image positions, the process function
                           
                              (26)
                              
                                 f
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       f
                                    
                                 
                                 ,
                                 u
                                 )
                                 =
                                 
                                    
                                       [
                                       
                                          
                                             x
                                          
                                          
                                             f
                                          
                                       
                                       +
                                       
                                          
                                             u
                                          
                                          
                                             x
                                          
                                       
                                       ,
                                       
                                          
                                             y
                                          
                                          
                                             f
                                          
                                       
                                       +
                                       
                                          
                                             u
                                          
                                          
                                             f
                                          
                                       
                                       ,
                                       
                                          
                                             d
                                          
                                          
                                             f
                                          
                                       
                                       +
                                       
                                          
                                             
                                                
                                                   d
                                                
                                                
                                                   ̇
                                                
                                             
                                          
                                          
                                             f
                                          
                                       
                                       ]
                                    
                                    
                                       ⊤
                                    
                                 
                                 ,
                              
                           
                        is used for prediction of the parameters, where the state is given by 
                           
                              
                                 
                                    x
                                 
                                 
                                    f
                                 
                              
                              =
                              
                                 
                                    [
                                    
                                       
                                          x
                                       
                                       
                                          f
                                       
                                    
                                    ,
                                    
                                       
                                          y
                                       
                                       
                                          f
                                       
                                    
                                    ,
                                    
                                       
                                          d
                                       
                                       
                                          f
                                       
                                    
                                    ,
                                    
                                       
                                          
                                             
                                                d
                                             
                                             
                                                ̇
                                             
                                          
                                       
                                       
                                          f
                                       
                                    
                                    ]
                                 
                                 
                                    ⊤
                                 
                              
                           
                         and the observation function by
                           
                              (27)
                              
                                 h
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       f
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       [
                                       
                                          
                                             x
                                          
                                          
                                             f
                                          
                                       
                                       ,
                                       
                                          
                                             y
                                          
                                          
                                             f
                                          
                                       
                                       ,
                                       
                                          
                                             d
                                          
                                          
                                             f
                                          
                                       
                                       ]
                                    
                                    
                                       ⊤
                                    
                                 
                                 .
                              
                           
                        
                     

Since each object only covers a limited portion of image space and since objects are typically fronto-parallel as seen in the images, a bias similar to that of planar surface, is insignificant for most foreground objects and can thus be disregarded.

Measurement and process covariance matrices for the foreground object were found using a method similar to that of the planar surfaces. The matrices used in the experiments below were respectively set to V
                        
                           f
                        
                        =diag (4,4,1) and
                           
                              
                                 
                                    
                                       W
                                    
                                    
                                       f
                                    
                                 
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   64
                                                
                                                
                                                   0
                                                
                                                
                                                   0
                                                
                                                
                                                   0
                                                
                                             
                                             
                                                
                                                   0
                                                
                                                
                                                   64
                                                
                                                
                                                   0
                                                
                                                
                                                   0
                                                
                                             
                                             
                                                
                                                   0
                                                
                                                
                                                   0
                                                
                                                
                                                   0.12
                                                
                                                
                                                   0.18
                                                
                                             
                                             
                                                
                                                   0
                                                
                                                
                                                   0
                                                
                                                
                                                   0.18
                                                
                                                
                                                   0.36
                                                
                                             
                                          
                                       
                                    
                                 
                                 .
                              
                           
                        
                     


                        Fig. 2
                         shows some images with segmentation from a video stream when the motion is of the most problematic kind, i.e., a translation along the normal of the plane, combined with a rotation that generates a similarly directed optical flow. The camera is elevated up and down about 20cm, with a speed that can be expected by a camera equipped autonomous robot circulating the scene. To prevent segmented objects from falling out of view, the camera undergoes some quick compensatory rotations around frame 20. Segmentations were computed live in about 10Hz using Kalman filters for prediction, while images were stored for later off-line analysis using alternative prediction methods. Segmentations in Fig. 3
                        , shown for comparison, involve lateral motion over the table-top, a motion significantly easier to cope with, since in this case surface parameters only change due to noise.

The changes of the surface parameter d
                        
                           p
                         obtained after segmentation, using the EKF prediction for initialization of each new image frame, is illustrated by the thick solid lines in Fig. 4
                         for the corresponding two sequences. Predictions using the full filter are shown as thin solid lines. The figure also shows predictions without a constant velocities assumption (dashed lines), instead assuming that parameters change only due to noise, and predictions without control inputs (dash-dotted lines). For each version of filters, the optimal covariance matrices were sought using the same method. From the left graph, representing the more problematic motion, it can be concluded that the velocity assumption is essential to prevent lag in the predictions and that the control inputs reduce over-shoots during accelerations.

The average prediction errors using the full filter were 1.03 and 0.60 pixels over the full sequences, while for the predictions without control inputs, the average errors respectively increased to 1.33 and decreased to 0.45 pixels. This can be explained by the fact that the flow estimation process itself is noisy. Thus control inputs only benefit in cases of large disturbances, whereas the constant velocity assumption is important to prevent lag and keep the average errors low. For the same two sequences, the average image position errors of the foreground objects were 0.95 and 0.81 pixels, which can be compare to 3.55 and 1.98 without control inputs.

The last set of images in Fig. 5
                         show the system running close to its breaking point with the camera moving rapidly back and forth. The blue and green areas show detected planar surfaces, with a spray bottle in the center of view as foreground. In particular the fourth image show significant motion blur that affects the segmentation of the spray bottle. The maximum change in the center position is about 50 pixels from one frame to the next, i.e., a full image width in one second. Due to the nature of the motion the constant velocity assumption does not hold. Despite this the scene parts are properly segmented and tracked.

In Section 3 five different MRF inference based methods for segmentation were described. The first one, LBP-S, updates scene part models based on a marginalization over labelings, whereas the remaining four uses the MAP estimate of the labeling using the current set of model parameters in each iteration. LBP-S can thus be expected to be more tolerant to poor initializations, since it considers the full space of possible labelings, while the maximization method only uses the one that happens to maximize the a posteriori probability.

In this section we evaluate the inference methods and scene part models by performing a series of experiments on object segmentation. The focus is quite different from those in [31,32], where energy minimization methods were benchmarked based on their convergence properties and abilities to minimize a global energy. For an iterative procedure where labeling and scene part modeling are interleaved the dynamic changes, compared to cases with fixed objective functions. The experiments in this section address the effect of this dynamic. We will later return to the methods in Section 8 and study how well they can be adapted for parallel processing in real-time.

A customary stereo camera system with two conventional cameras was used for the experiments, with binocular disparities provided by correlation based stereo matching using OpenCV. Correlation is fast enough for the intended application areas, but has the weakness of not being able to provide reliable disparities in image regions without texture. Thus large areas within the tested images contain pixels without 3D measurements, a fact that complicates initialization in particular, which is illustrated by the two examples in Fig. 6
                     . Despite the availability of better performing method based on global optimization, such methods were not considered, due to their increased requirements on computational cost.

For initialization of scene part models we used the procedure described in Section 5, with some modifications to facilitate benchmarking with respect to the provided ground truth. After foreground models have been automatically initialized, the resulting segments, referred to as a target points below, are paired up with the ground truth ones in the order of decreasing overlap, so that each foreground model is benchmarked against its own ground truth segment. This is true even if a target point does not intersect any of the ground truth segments, which is thus reflected in the reported precision and recall scores.

To test the relative performance of the five methods for single object segmentation, we performed a series of experiments in 100 different scenes, where an object is placed on a table top, initially without the influence of any nearby disturbing objects. Half of these scenes have a textured table top, while in the remaining the table top is uniformly colored. Using an ball with a diameter equivalent to about 20% of the image height around the point for initialization, we got the results shown in Fig. 7
                        .

As can be seen from the results, all five methods give similar results, with one clear exception. Whereas LBP-S has a better recall rate, the maximization based methods lead to a higher average precision. Due to the marginalization, LBP-S can allow segments to grow and eventually cover regions that were initially labeled as part of the background. However, this comes at the cost of sometimes including parts that are in fact not part of the foreground object. Worth noting is that despite the fact that LBP-S and LBP-M do not aim at minimizing the total energy, i.e. the negative logarithm of the joint probability, they still end up at similar minima. Furthermore, since ICM performs optimization locally, it is most likely to get stuck in local minima and thus results in the highest average energy.

A similar set of experiments were conducted on 141 scenes that each involved three objects in close proximity, often in direct contact. Target points were selected one object at the time and the resulting segmentations were studied. As can be seen in Fig. 8
                        , the performance deteriorates for LBP-S in particular. The original seed often grows until more than one objects is covered by the foreground hypothesis, with decreasing precision as a result. Some characteristic examples of this are shown in Fig. 9
                        . For examples with ICM a strong bias towards rectangular segments can be observed, which is a result of the local nature of the method and the fact that we are using 4-neighbors. In terms of F1 scores, LBP-M, TRW-S and GC lead to very similar results, slightly worse than the single object case.

Since a target point is not necessarily located within the object targeted, it could happen that the object actually segmented is not the one originally targeted. This is particularly common for objects occluded by a more distinct foreground object. Such unintended changes in focus account for 11 test cases with LBP-S and 6 cases with the other four methods, which partly explains the lower observed F1 scores. In order to study how well the methods segment any one of the three objects, not necessarily the one originally targeted, we computed the average scores, precision and recall rates for the best matching ground truth segments out pf the three possible. These results are shown in Fig. 10
                        . Now LBP-M, TRW-S and GC perform almost as well as in the single object case and still without much differentiating the three methods. ICM lags behind slightly due to its higher sensitivity to local minima. LBP-S also improves, even if it still suffers from segments involving multiple objects, as indicated by the low precision scores.

We next performed the same experiments as before, but with three simultaneously segmented foreground hypotheses, with one target position selected per object. As can be seen in Fig. 11
                        , the scores improve considerably, in particular for LBP-S. There are two reasons for this. First, due to the introduction of two more seeds, the dynamic of the segmentation loop changes. If a method gets stuck in a poor local minima in one iteration, it is likely to fall out of this minima in the next, due to the interaction of neighboring segments. Second, with three foreground hypotheses, a segment that would otherwise have grown to include multiple objects is prevented from doing so. This is particularly true for LBP-S that despite a higher energy has an average score competitive to those of the maximization based methods. Some characteristic examples of multi-object segmentation are shown in Fig. 12
                        . The result are very similar for all methods, besides ICM that still exhibits bias towards rectangular shapes.

In many practical situations the above experiments can hardly be considered as realistic, since it is assumed not just that the number of available objects is known, but also that a target position is given for each object. For cases in which the number of objects is unknown, the scores in Fig. 10, with examples in Fig. 9, are more relevant, as they indicate the performance of segmentation one hypothesis at the time.

Most critical to typical systems for foreground segmentation is the initialization phase. What occurs in the first few iterations, directly affects the end result. Unless some post-processing is later applied to assess the quality of segmentation, there is usually no turning back after initialization. As mentioned earlier in Section 5, initialization is done by placing a 3D ball around a density peak in 3D space. The distance to and the projective size of this ball is given by a mean shift procedure. Points within the ball after convergence are assumed to belong to the initial foreground segment. Unfortunately, if the observed objects are unknown, then so are their respective sizes. In many cases, however, the sizes are known to some degree. For example, for the experiments performed here, objects are assumed to be measured in decimeters, with observation distances given in meters, which limits the range of possible projective sizes.

The results in Fig. 13
                         show how the different methods perform while varying the projective diameters of the initialization balls, in essence the size of the mean shift kernel. Worth noting is that while LBP-M, TRW-S and GC perform best with the optimal ball size, they are less robust to balls that become too small, GC slightly more robust than the message passing methods. The maximization based methods tend to miss small differently colored object regions, if they are not initially covered by the ball. LBP-S shows the best ability to gradually grow from a small seed to include also such regions, as can be seen in the example in Fig. 14
                        . However, the ability to grow comes at the cost of sometimes growing beyond the extent of the segmented object, leading to relatively low segmentation scores on average.

The benefit of disparities in the initialization is that points originating from neighboring objects can be pruned. This becomes an issue the larger the target ball is, which can be concluded from the table in Fig. 15
                        , where depth information has been ignored and only 2D discs are used for initialization. Surprisingly, for small disc sizes the segmentation may even improve without disparities. The reason is because, for some uniformly colored objects, the number of accurately computed disparities become too few, if the target ball is too small, which limits the number of samples that can be used for initialization of color histograms.

As mentioned in Section 4, the background model consists of two kinds of components, a uniform component and planar ones. The planar components are intended to capture the existence of dominating planes, such as walls, floors and table tops, while the uniform component should capture all remaining non-foreground points, including scene objects currently not targeted. The reason for introducing planar hypotheses were to better separate objects from the supporting surfaces that objects are placed upon. The importance of planar hypotheses was studied by repeating the experiments with these hypotheses removed. By comparing the results in Fig. 16
                         to those in Fig. 10, one can conclude that without planar hypotheses somewhat better recall scores come at the cost of a substantially lower precision. Foreground segments tend to grow and capture also parts of the supporting surfaces. This is particularly true for objects with color distributions similar to those of the surfaces. Since the surfaces is in direct contact with the objects, the spatial information does not provide enough evidence to separate the two. This effect occurs regardless of method, but it most critical for LBP-S.

What frequently occurs in practice is that, despite the lack of a distinct dominating plane in the scene, a planar hypothesis is still found and included to the model. This is often the case for table-top scenes, where objects are located within a narrow range just above a supporting surface, and a large enough number of 3D points from different objects are located on a plane intersecting the scene and bounding the rest of the scene. As can be seen in Fig. 17
                        , the proposed model is able to cope also with such situations. The detected planar region will grow in thickness after initialization and eventually capture a set of background objects in the scene (shown in gray), however, without affecting the quality of the segmented foreground object. In fact, this happens for many cases in the quantitative experiments when the background is uniformly colored. The incorrectly detected plane becomes just another background component.

It can be argued whether disparities are really necessary for successful segmentation. After all, most methods for figure-ground segmentation do not assume disparities and by expecting disparities, one is constrained to set-ups with multiple cameras or time-of-flight cameras. Disparities can in fact do more harm than good in scenes with large textureless areas, where accurate disparities are hard to determine. Stereo matching may also suffer from fattening of textured objects placed in front of uniformly colored backgrounds. As shown by the results in Fig. 18
                        , where disparities have been disregarded, segmentation is helped by disparities, even if the impact is moderate compared to the scores in Fig. 10.

More important is the color information, as can be seen from the results in Fig. 19
                        , where such information has been ignored and only luminance is used, together with 3D distance measures. Both precision and recall deteriorate to a similar extent for all methods. In a concluding experiment we try the same methods with only color information and ignore the distance measures altogether. Here the GC case is very similar to GrabCut [3], but with histograms, rather than mixtures of Gaussians for color modeling. From the poor results in Fig. 20
                        , the importance of distance measures for segmentation is highlighted. For all five methods recall suffers considerably, which is an indication that without such measures they all fail to grow beyond the original seeds, when different parts of objects are of colors not included in the initial foreground segment.

The question is which method to select for object segmentation, considering the differences and similarities in performance and implementation complexities. From the quantitative experiments it can be concluded the most simplistic method, ICM, is only competitive in the case of single object segmentation without any nearby obstructing objects. Among the top contenders, LBP-M, TRW-S and GC, no single method showed to be superior, which is somewhat contradictory to the study in [32] that suggests that LBP-M ought to be less competitive to the other two, at least when benchmarked in terms of energy minimization. Due to the dynamics of the segmentation loop, LBP-M is helped from being stuck in local minima. The marginalization based method, LBP-S, show somewhat different properties than the other methods. Despite lower scores in almost all experiments, LBP-S is by far the most robust method to too small initialization seeds. In fact, in most cases LBP-S is able to grow from only a handful of pixels, while the maximization methods easily get stuck.

More important than the choice of method is the scene part modeling. Planar background models help to separate foreground objects from the surfaces they are placed on in cases of similarities in color. Even if a false planar model is instantiated, it becomes just another background model, without affecting the foreground object segments. When it comes to the importance of cues for segmentation, disparities are less valuable than colors and image positions. Its most important benefit is in pruning of neighboring pixels in the initialization phase, the most critical part of a complete system. Color information is important, but only when combined with image distance measures, as can be seen by comparing Figs. 18 and 20.

In this section we study the alternative methods in the context of a complete segmentation and tracking system for real-time use. As illustrated in Fig. 1 the system consists of four steps running in two loops, an inner segmentation loop with Labeling and Modeling, and an outer loops that also include the Kalman filter steps Update and Predict. In terms of computational cost these two last steps are insignificant. However, the Predict step also relies on control inputs u
                     
                        k
                     , that originate from SIFT features being tracked over time. One might argue against SIFT for this purpose, given that scale invariance is hardly a necessity under the given conditions. The reason for using SIFT anyway, is to allow for future applications that include on-line object recognition as a mean to initialize new segments as soon as previously seen objects are detected. This is, however, not covered within the scope of this paper.

The inner segmentation loops is heavily dominated by the Labeling step that applies MRF inference for segmentation. The table in Fig. 21
                      includes a summary of average computational costs on a four-core Intel Core i7-860 CPU for the five tested methods, using a representative set of 27 test images with varying number of labels. The GC method, the fastest among the five, uses Fast-PD [30], a primal–dual energy minimization method that improves the speed, compared to α-expansion, by exploiting information from the dual problem to limit the size of graphs in later iterations. For 7-label problems the improvement in average speed is about 2.5 times on our particular test set, but is likely to be larger for problems with more labels.

From the table it can be concluded that the benefit of multiple threads for message passing with LBP-M and TRW-S is smaller than one would hope for. This is due to the sheer amount of messages and beliefs that has to be loaded and stored in each iteration, which makes the methods highly bandwidth limited. Since data are accessed sequentially and are more than what the cache hierarchy allows, the memory bandwidth is exhausted already with a few threads. Further optimization using e.g. assembly intrinsics do not lead to any improvements in speed. Furthermore, with multiple threads neither LBP-M nor TRW-S can cut the memory consumption for messages by half, by reusing the memory used for incoming and outgoing messages, which is possible for single threaded implementation [61,27], since the ordering of processing cannot be guaranteed with multiple threads. With push-relabel [66] applied for graph cuts, GC does a much better job at limiting the amount of accessed memory.

Due to its better convergence properties, the sequential tree-reweighted message passing algorithm [27] is usually superior to max-product [58]. However, when run in a coarse-to-fine hierarchy [61] with only a few iterations per level, this benefit is not as clear. In fact, with the same number of iterations per level LBP-M is slightly faster than TRW-S, because TRW-S not only updates the messages in each iteration, but also the beliefs (21). In our case, where we used 5-level hierarchies, we were unable to show that TRW-S would need fewer iterations than 8 per level to reach convergence.

Unfortunately, none of the tested methods showed to be fast enough for real-time use cases, at least for multi-object tracking that requires an update rate of at least 10Hz. As a consequence of this, implementations on graphics cards (GPUs) were considered for the purpose. Even if it has been argued that the benefits of GPUs for general purpose programming have been exaggerated [67], there are few applications that can benefit from GPUs as well as image processing applications, as long as they are complex enough to motivate the cost of transferring images from main to GPU memory. SIFT feature extraction [65] is one such application and so is MRF inference in regular grids. Thus to show that the work presented in this paper can feasibly be run in real-time, we implemented the most time-consuming parts of the complete system on a GPU, an NVidia GeForce GTX 580, and compare the performance to that of the CPU implementations.

GPUs from NVidia, as well as from AMD, consist of a set of multiprocessors (MP) that each has a number of stream processors (SP) working in parallel. The GTX 580 GPU, for example, has 16 MPs with 32 SPs each. SPs act in a simple-instruction multiple-thread (SIMT) fashion, which is very similar to SIMD with a few exceptions. If all SPs in a MP access the same memory address or if they access a sequence of consecutive addresses, this can be exploited by the MP for maximum bandwidth. GPU software is written as kernels that express work is terms of thousands of threads, with multiple threads grouped into blocks. During execution each block is scheduled to a MP, with its threads mapped to the SPs of that MP. To hide memory latencies and keep all SPs fully active, multiple blocks can simultaneously be scheduled to the same MP.

Thanks to the mass of computational power available by the total set of SPs, the real challenge of GPU programming is understanding the memory architecture and making sure that each SP is working at its full potential. GPUs typically have a multi-level memory architecture, much like of conventional cache hierarchies of CPUs. Each MP has a couple of hundred kilobytes of high-speed local memory available, some of which is shared between its SPs, while the rest is local to each SP. Maximum performance is achieved, if implementations are designed such that most accesses are limited to this local memory, without relying on the slower, but larger, off-chip global memory that is available to all MPs.

In Section 7 it was shown, that for multi-object segmentation, LBP-M, TRW-S and GC all lead to very similar end results, despite their differences in ability to minimize the objective functions. Among these, GC was the fastest method on the CPU and was thus first to be considered for GPU implementation. GC uses Fast-PD that in turn relies on the push-relabel [66] algorithm, an algorithm that gains its speed from only updating those nodes for which you have excess flow to push and a path towards the drain, this using a distance to drain value for each node. However, this also makes it particularly hard to extend for parallel processing.

Vineet and Narayanan [68] used two different kernels in their GPU implementation of push-relabel, one for pushing of excess flow and one for relabeling of distance values. These kernels are interleaved in multiple iterations and to improve speed, thread blocks were deactivated, if no excess flow could be pushed in the last iteration. If Fast-PD were to be implemented on a GPU using such an approach, it should take about 100–150ms,
                              1
                              This conclusion is drawn from extrapolating results of binary to multi-label problems using code available by the authors of [30,68].
                           
                           
                              1
                            assuming the same speed-up as the case of the binary labels. This is, however, overly optimistic given the harder problem of parallelization. The reason why GPU optimization is not more beneficial is likely to be because of the substantial additional cost of either using atomic functions or larger global memory buffers for propagation of excess flow between thread blocks.

A factor that complicates graph cut based labeling on GPUs is that a labeling is not available until convergence is reached and a minimum cut is found. Typically, small islands of activation exist around the boundaries of segments, islands that might remain for hundreds of iterations. Even if thread blocks are deactivated when no excess flow remains, multiple kernel calls are still required with only a handful SPs being used in each call. In contrast, even if deactivation of blocks is harder to achieve with belief propagation, it is possible to interrupt message passing after a given number of iterations and still get satisfactory results. Thus we also considered the LBP-M method for GPU implementation.

Most GPU implementations of belief propagation applies a coarse-to-fine structure [61] for faster convergence, some using extensions to OpenGL [69,70] and others using more recent general purpose APIs [71,72]. Yang et al. [70] uses deactivation of converged pixels to improve speed. This is, however, hard to extend to large SIMD-like architectures, where deactivation is preferably done per block. Overlapping tiles have also been proposed [71,73], with most computations done locally within each tile. However, due to the local memory required for storing of messages, one becomes limited to relatively small tiles, which makes it harder to keep all SPs fully active. One further needs to propagate messages between tiles, which means that multiple kernel calls are still required, with propagated messages stored to global memory. Since a hierarchical framework reduces the number of iterations per level anyway, its hard to simultaneously exploit the joint benefits of both local tile processing and hierarchies [73].

For our GPU implementation of LBP-M we apply the max-product (min-sum) method as proposed by Felzenszwalb and Huttenlocher [61], but without reusing memory for incoming and outgoing messages, due to the parallelism. To keep the majority of operations as SIMD-like as possible and exploit the total bandwidth of the GPU, we ignored the potentials of deactivation and local processing in tiles, and kept all processing in one compact kernel that is called iteratively, 8 times per hierarchy level. Assuming that Potts model is used, the operations executed in this kernel can be summarized in two steps:
                              
                                 
                                    
                                       
                                          
                                          
                                             
                                                (
                                                S
                                                1
                                                )
                                                
                                                foreach
                                                
                                                
                                                   
                                                      l
                                                   
                                                   
                                                      i
                                                   
                                                
                                                
                                                do
                                                
                                                
                                                   
                                                      h
                                                   
                                                   
                                                      ij
                                                   
                                                
                                                (
                                                
                                                   
                                                      l
                                                   
                                                   
                                                      i
                                                   
                                                
                                                )
                                                ←
                                                
                                                   
                                                      ψ
                                                   
                                                   
                                                      i
                                                   
                                                
                                                (
                                                
                                                   
                                                      l
                                                   
                                                   
                                                      i
                                                   
                                                
                                                )
                                                +
                                                
                                                   
                                                      
                                                         ∑
                                                      
                                                      
                                                         k
                                                         ∈
                                                         
                                                            
                                                               N
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                         ⧹
                                                         j
                                                      
                                                   
                                                
                                                
                                                   
                                                      m
                                                   
                                                   
                                                      k
                                                      →
                                                      i
                                                   
                                                
                                                (
                                                
                                                   
                                                      l
                                                   
                                                   
                                                      i
                                                   
                                                
                                                )
                                             
                                          
                                       
                                       
                                          
                                          
                                             
                                                (
                                                S
                                                2
                                                )
                                                
                                                foreach
                                                
                                                
                                                   
                                                      l
                                                   
                                                   
                                                      j
                                                   
                                                
                                                
                                                do
                                                
                                                
                                                   
                                                      m
                                                   
                                                   
                                                      i
                                                      →
                                                      j
                                                   
                                                
                                                (
                                                
                                                   
                                                      l
                                                   
                                                   
                                                      j
                                                   
                                                
                                                )
                                                ←
                                                
                                                   min
                                                
                                                (
                                                
                                                   
                                                      h
                                                   
                                                   
                                                      ij
                                                   
                                                
                                                (
                                                
                                                   
                                                      l
                                                   
                                                   
                                                      j
                                                   
                                                
                                                )
                                                ,
                                                
                                                
                                                   
                                                      
                                                         min
                                                      
                                                      
                                                         
                                                            
                                                               l
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                      h
                                                   
                                                   
                                                      ij
                                                   
                                                
                                                (
                                                
                                                   
                                                      l
                                                   
                                                   
                                                      i
                                                   
                                                
                                                )
                                                +
                                                
                                                   
                                                      d
                                                   
                                                   
                                                      ij
                                                   
                                                
                                                )
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

Here d
                           
                              ij
                            represents the pair-wise cost of assigning nodes i and j to two different labels. The first step S1 involves four global memory reads and one local store, whereas S2 requires one local read and one global write, per label and message passing direction. If we assume 4-connectedness, it is possible to interleave message computations from the same node, but in different directions, and reduce the total number of global memory operations. By doing so, S1 will be limited to five global reads in total per label, and S2 to four global writes, including d
                           
                              ij
                            that requires one global read per pair. Fewer global memory operations than that is not possible to achieve, unless the structure of the graph is changed.

Operations are scheduled to MPs in terms of thread blocks. In our implementation we use one thread per node in the graph, since do not assume to know the number of labels beforehand, just that its limited. Unfortunately, with the above mentioned scheme the optimal number of threads per block is only 128 threads for 7-label problems. The reason for this is that the h
                           
                              ij
                           (l
                           
                              i
                           ) values have to be computed and stored, and cannot be used in S2 until 
                              
                                 
                                    
                                       min
                                    
                                    
                                       
                                          
                                             l
                                          
                                          
                                             i
                                          
                                       
                                    
                                 
                                 
                                    
                                       h
                                    
                                    
                                       ij
                                    
                                 
                                 (
                                 
                                    
                                       l
                                    
                                    
                                       i
                                    
                                 
                                 )
                              
                            has been determined. This requires local memory for temporary storage of h
                           
                              ij
                           (l
                           
                              i
                           ), which will sets a limit on the number of threads that can be kept in each block. A solution to this problem is to change the order of S1 and S2, and store h
                           
                              ij
                           (l
                           
                              i
                           ), instead of m
                           
                              i→j
                           (l
                           
                              j
                           ) in each iteration. First the kernel runs S2 completing the operations from the previous iterations and then S1 for the following one. Regardless of the number of labels, 768 threads can then be used at all time, since the local memory requirement does not depend on the number of labels. As soon as h
                           
                              ij
                           (l
                           
                              i
                           ) is computed it is stored, and it is not read back until needed. Since the order of S1 and S2 is changed, the procedure has to start with a S1-only iteration and end with a S2-only one. Furthermore, one additional global load and store per direction is necessary for 
                              
                                 
                                    
                                       min
                                    
                                    
                                       
                                          
                                             l
                                          
                                          
                                             i
                                          
                                       
                                    
                                 
                                 
                                    
                                       h
                                    
                                    
                                       ij
                                    
                                 
                                 (
                                 
                                    
                                       l
                                    
                                    
                                       i
                                    
                                 
                                 )
                              
                           . This extra memory cost is low compared to the per label cost of storing h
                           
                              ij
                           (l
                           
                              i
                           ).

A summary of the computational cost for the alternative GPU kernels can be seen in Fig. 22
                           . The first (M1) performs all the operations one message passing direction at the time, while the second (M2) interleaves the message computations in different directions. The reduction from 16 (four per direction) global reads to only five, clearly has a large influence on the performance. The third alternative (M3) also interleaves messages, but stores h
                           
                              ij
                           (l
                           
                              i
                           ) instead of m
                           
                              i→j
                           (l
                           
                              j
                           ) to global memory. Since the kernel is already bandwidth limited, this only slightly improves the performance, despite the increased SP utilization. However, with 13 or more labels M2 run out of local memory and M3 becomes the only alternative. Note that even if an additional cost of 4.9ms for setting up the graph structure, allocating memory and transferring data between CPU and GPU memory is included, M3 is still about 50 times faster than the single-threaded CPU version or 23 times faster than the multi-threaded one.

Another time-consuming part of the complete system is the Predict step that relies on SIFT features that are tracked over time. The SIFT extractor [65] has two componentsa detector based on maximization of Differences of Gaussians in image space and scale, and a descriptor based on local gradient histograms. While the descriptor works per detected feature and has a random access like memory access pattern, the detector is computed for every pixel in a Gaussian pyramid, which makes it more easily parallelized. Thus even if the detector performs considerably more operations, the computational cost of the two components are similar for an heavily optimized CPU version, as can be seen in Fig. 23
                           . The numbers are given for a 30 scale Gaussian pyramid, where the resolution has been reduced to half every 6 scales (octave). The cost of the detector is also proportional to the number of pixels, while the descriptor instead depends on the number of extracted features.

This dependency cannot be seen for a naive GPU implementation that is similar to the CPU version in that the detector and descriptor are run once per scale. Since images quickly become very small when subsampling is done for every octave, there is not enough work for all SPs to stay active, when the number of pixels and extracted features become too few. In an optimized GPU version, features are instead extracted simultaneously for all scales within an octave. Thus instead of creating a Gaussian pyramid one scale at the time through gradual low-pass filtering, all scale are created in parallel by directly blurring the finest scale with filter kernels of different sizes. Once features have been detected, descriptors for all these features are similarly created in parallel regardless of scale. As shown in the table, this leads to a radical reduction in computational cost, for the descriptor in particular.

Other costs that have to be considered in GPU implementations are those of memory allocation and transfer of image data to and SIFT features from the GPU. The memory allocation is particularly costly on the GPU when it is done naively, that is when it is done just before it is needed. Some cost is associated to the amount of memory allocated, but dominating is a fixed cost per memory allocation call. Even if temporary buffers were reused as much as possible in the naive implementation, ten different allocations were needed per octave. To reduce the memory allocation cost, these were instead replaced by one large allocation at the beginning of the process and left the software divide this memory upon need.

With these two seemingly trivial optimizations, the SIFT extractor becomes almost three times faster for a QuadVGA (1280×960 pixel) image and even faster for VGA (640×480 pixel) images. Compared to the optimized CPU version, it is between 12 and 19 times faster depending on resolution. The total cost of 5.4ms required for the optimized GPU version in VGA can also be compared to about 440ms for the same image and settings on the same CPU using VLFeat [74], one of the most frequently used implementation of SIFT. In fact, for our particular application it is even faster, since we can disregard the cost of transferring SIFT feature data back from the GPU. Features are instead matched over time, as explained in Section 6.2, with the features kept on the GPU. The cost of brute force matching of all matching between two frame is about 1.2ms in VGA on the GPU, about six times faster than optimized on a CPU.

@&#SUMMARY@&#

With the above mentioned GPU optimizations the full system running LPB-M, with images and disparities provided by a Kinect unit, runs in 13.0Hz with 3 scene part models, 11.1Hz with 5 models and 9.8Hz with 7 models, when the system runs in tracking mode with 3 segmentation iterations per update. The Modeling step, with one CPU thread running per model, takes about 16ms and the Labeling step 45ms in total with 7 models. The Predict step, including SIFT extraction, matching and tracking, takes 6ms and 4ms is associated to overhead, such as image extraction and color conversions. Despite the additional cost of about 30ms for Kinect disparity extraction and disparity to image alignment, as well as visualization, the system is fast enough for real-time tracking as exemplified by the sequences of Figs. 2 and 3.

@&#CONCLUSIONS@&#

We have studied the problem of multi-object segmentation and tracking, and done so without letting the real-time constraint prevent us from using state-of-the-art energy minimization techniques for labeling. From experiments is has been concluded that the modeling of the problem is more important than the choice of MRF inference method. We have proposed a heterogeneous scene representation that consists of a background model of planar surfaces and uniform clutter, with foreground objects hypotheses modeled as 3D ellipsoids. It has further been concluded for grouping of pixels, distance measures in either 2D or 3D are just as important as colors, and that planar background models help to disambiguate objects from the surfaces that are placed on.

In experiments it has been shown that modern maximization based methods, such as max-product belief propagation (LBP-M), tree reweighted message passing (TRW-S) or primal–dual graph cuts (GC), lead to very similar end results, when run in an EM-like iterative framework with labeling and modeling interleaved. Unlike labeling problems with fixed energy terms, the dynamics prevent methods, LBP-M in particular, from being stuck in local minima. What cannot be directly observed from the quantitative experiments, however, is that the paths to the final segmentation can be quite different. Foreground object seeds tend to evolve faster, but sometimes more erratic, with TRW-S and GC, which is reasonable given their better convergence properties for energy minimization. However, the minimization problem solved in each iteration is based only on statistics from the previous iteration, which might still be incomplete, if the full extent of an object has not yet been captured. Thus better convergence in the energy minimization does not necessarily translate into faster convergence overall.

Given that LBP-S was the only marginalization based approach in our study, it has properties rather different from those of the others. By considering all possible labeling in each iteration, not just the current MAP labeling, is shows the best ability to grow from very small initial foreground seeds to full object segmentation. Unfortunately, this also means that it is more likely to connect objects located close to each others, especially if these have overlaps in their color distributions. However, if competing seeds can be simultaneously initiated on each object, LBP-S do just as well as the top contenders, and should thus not be disregarded as a candidate method. The same is true if the end goal is object modeling, not segmentation per se, since with marginalization the full space of labeling is taken into consideration for modeling.

As soon as you apply segmentation in a real-time settings, computational speed becomes an issue. Due to the costs associated with multi-label MRF inference methods, in terms of both speed and memory, such methods are rarely used for real-time purposes. We have in this study shown that MRF methods are in fact feasible, even for the purpose of object tracking, using GPUs for accelerations and given recommendations on how to use the hardware to its full potential. It has been concluded that, given the pattern of memory accesses, message passing methods are more suitable for high levels of parallelism, even if graph cut based methods are faster on single threaded CPUs. Given the similarities in segmentation results, message passing methods are thus recommended for real-time purposes.

A choice made in designing the real-time system was to let the segmentation in one frame only depend on the scene part models of the previous frame, but not on the previous segmentation, despite the temporal consistency that can often be expected. From one frame to the next, only the model parameters remain. The motivation for this modeling centric approach, was to allow for initialization of previously seen objects in new scenes, using as little prior information as possible. In later studies we intend to study the problem of re-initialization of such objects, when the scene has undergone different degrees of changes, from gradual changes in view points, to larger changes where objects temporarily leave the visual field, and to complete scene changes. For tracking we have already made an exception from the general rule and do in fact exploit segmentation from previous frames. The question is what information to use when more radical changes occur and no previous segmentations can be applied. A possible avenue is to combine SIFT features, extracted during earlier tracking, and the intrinsic scene part parameters, the shape and color information, for detection and re-initialization.

A segmentation system can never perform better than what its models and prior assumptions allow. As soon as you introduce abstractions in its representations, you may run into problems, if the object to be represented diverges from what can typically be assumed. What frequently occurs in multi-object segmentation is the difficulty to disambiguate objects in direct contact. Are there two objects placed next to each others or is there just one of an unusual shape or texture? We believe that such questions cannot always be resolved from single images alone and are exploring methods for active object hypothesis testing and validation [75]. We also use the presented system to learn more about objects through tactile exploration of object shape [76] and study objects in terms of object-related sensorimotor contingencies [77].

This leads to the more general question of active scene understanding, the theme of our current research, which involves the problem of representing scenes with objects and their relations, updating representations over time, as well as planning and executing hypothesis testing through actions to understand the scene well enough to solve whatever task is placed on the system. In the presented experiments, foreground models were automatically inserted on start-up, given the number of models and expected size. This does not necessarily have to be the case. In a fixating system, e.g., new models can sequentially be inserted each time a part of the scene that has not yet been visited is fixated on. If a previously fixated, and currently tracked, object is to be revisited, the corresponding model keeps information on where it is located in the scene and how to make a saccade towards it. Thus even if the presented multi-object segmentation and tracking system can be used for many different applications, applications vary in the way scene part models should be inserted, exploited and eventually discarded.

Supplementary data associated with this article can be found, in the online version, at http://dx.doi.org/10.1016/j.cviu.2013.10.007.


                     
                        
                           Supplementary Video 1
                           
                        
                     
                  


                     
                        
                           Supplementary Video 2
                           
                        
                     
                  


                     
                        
                           Supplementary Video 3
                           
                        
                     
                  

@&#REFERENCES@&#

