@&#MAIN-TITLE@&#On planning sightseeing tours with TripBuilder
            

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           The formal problem of planning a tourist visit as a fully-automatic two-step process.


                        
                        
                           
                           An unsupervised method for mining common patterns of movements of tourists.


                        
                        
                           
                           A comprehensive evaluation of TripBuilder.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Recommender systems

Trajectory mining

Sightseeing tours

@&#ABSTRACT@&#


               
               
                  We propose TripBuilder, an unsupervised framework for planning personalized sightseeing tours in cities. We collect categorized Points of Interests (PoIs) from Wikipedia and albums of geo-referenced photos from Flickr. By considering the photos as traces revealing the behaviors of tourists during their sightseeing tours, we extract from photo albums spatio-temporal information about the itineraries made by tourists, and we match these itineraries to the Points of Interest (PoIs) of the city. The task of recommending a personalized sightseeing tour is modeled as an instance of the Generalized Maximum Coverage (GMC) problem, where a measure of personal interest for the user given her preferences and visiting time-budget is maximized. The set of actual trajectories resulting from the GMC solution is scheduled on the tourist’s agenda by exploiting a particular instance of the Traveling Salesman Problem (TSP). Experimental results on three different cities show that our approach is effective, efficient and outperforms competitive baselines.
               
            

@&#INTRODUCTION@&#

Tourists approaching their destination for the first time have to deal with the problem of planning a sightseeing itinerary that covers the most subjectively interesting attractions, and fits the time available for their visit. Precious information can be nowadays gathered from many digital sources, e.g., travel guides, maps, institutional sites, travel blogs. Nevertheless, the users still need to choose the preferred PoIs, guess how much time is needed to visit them and to move from one attraction to the next one. In this paper we discuss TripBuilder, an unsupervised system helping tourists to build their own personalized sightseeing tour. Given the target destination, the time available for the visit, and the user’s profile, our system recommends a time-budgeted tour that maximizes user’s interests and takes into account both the time needed to enjoy the attractions and to move from one PoI to the next one. Moreover, the knowledge base feeding TripBuilder recommendation model is entirely and automatically extracted from publicly available Web services, namely, Wikipedia, Flickr and Google maps.

We observe that an increasing number of tourists share on social networks their travel photos. Unofficial estimates state that Flickr, one of the most popular photo-sharing platforms, collected about 518 million of public photos in 2012.
                        2
                        
                           http://www.flickr.com/photos/franckmichel/6855169886/.
                     
                     
                        2
                      Each photo comes with very useful information such as: tags, comments and likes from Flickr social network, number of views, information about the user, timestamp, GPS coordinates of the place where the photo was taken. This allows us to roughly reconstruct the movements of users and their interests by analyzing the time-ordered sequence of their photos. However, the process of recognizing relevant PoIs given such set of photos is not trivial due to the noise present in the data. User tags are in many cases missing, wrong, or irrelevant for our purposes (e.g., me and Ann, travel to Europe, Easter 2012). Moreover, information available may be sparse and characterized by a skewed distribution.

Fortunately, in Wikipedia,
                        3
                        
                           http://www.wikipedia.org.
                     
                     
                        3
                      we can find that most entities of interest for tourism are described in a dedicated page from which we can extract: the (multilingual) name of the PoI, its precise geographic coordinates, the categories to which the PoI belongs according to a weak but robust ontology (i.e., the PoI is a church, a square, a museum, a historical building, a bridge, etc.). By spatially joining and re-conciliating tourists’ photo albums and related information from Flickr with relevant PoIs data extracted from Wikipedia pages, we can derive a knowledge base that represents the behavior of people visiting a given city.
                        4
                        Thereinafter, we will consider cities as the destination targets of our users, although our technique is general and scale-independent.
                     
                     
                        4
                      In this knowledge base the popularity of a PoI is estimated from the number of visitors that shot photos there, while from the timestamps of the first and last photos taken in a PoI we estimate the average time spent for the visit. Finally, we exploit the Wikipedia categories of the PoIs visited by a given tourist to build her user profile. For example, when a user takes many pictures of churches and museums, we can infer a preference for cultural/historical attractions. Analogously, we can aggregate this information at the level of itinerary to build a profile for each frequent visiting pattern.

We address the problem of planning the visit to the city as a two-step process. First, given the profile of the user and the amount of time available for the visit, we formalize and address the TripCover problem: choosing the set of itineraries across the PoIs that best fits user interest and respects the given time constraint. Then, the selected itineraries are joined in a sightseeing itinerary by means of a heuristic algorithm addressing the Trajectory Scheduling Problem (TrajSP), a particular instance of Traveling Salesman Problem (TSP). The formalization of TripCover as an instance of the Generalized Maximum Coverage (GMC) problem can be found in Brilhante, Macedo, Nardini, Perego, and Renso (2013), while (Brilhante, Macedo, Nardini, Perego, & Renso, 2014) demos the capabilities of the TripBuilder application.
                        5
                        
                           http://tripbuilder.isti.cnr.it/.
                     
                     
                        5
                      In this paper, we extend the previous research with the following relevant and original contributions:
                        
                           •
                           we detail our unsupervised method for mining common patterns of movements of tourists in a given geographic area. To this purpose we use: (i) Flickr, to gather public photos (and their metadata), (ii), Wikipedia to gather information regarding PoIs in the given city, (iii) Google maps to estimate the time needed to move from a PoI to the next one in the sightseeing itinerary. The resulting knowledge base stores PoIs, their popularity, the time needed in average to visit them, the categories for which each PoI is relevant, and the patterns of movement of tourists that visited them in the past. In order to assess our system, we report about the building of a knowledge base covering three Italian cities, which are important for tourism and guarantee variety and diversity in terms of size and the richness of public user-generated content available: Rome, Florence, and Pisa. The resulting knowledge base, available for download to favor the reproducibility of results, is analyzed and its characteristics are here discussed;

we adopt the result discussed in Brilhante et al. (2013) where TripCover is defined and an approximate algorithm is proposed to compute the set of trajectories in the knowledge base that best fits user interests given a time budget. In this paper, we address the subsequent step that consists in processing this set of trajectories to build a schedule of the complete sightseeing itinerary over the tourist’s agenda. To this end, we define TrajSP as a variation of the TSP problem. It aims at finding the shortest path crossing all the trajectories in the TripCover solution. We investigate the TrajSP problem and its peculiarities, which are exploited to devise an efficient and effective heuristic algorithm;

finally, we report on several new experiments to evaluate effectiveness and efficiency of all the components of our system and show that our solution outperforms competitive baselines. In particular, we assess TripBuilder performance in providing budgeted sightseeing itineraries made up of actual PoI patterns tailored to the specific preferences of the tourist.

The paper is structured as follows: Section 2 introduces the TripCover problem and the approximation algorithm used to solve it. Moreover, the TrajSP problem is defined and addressed in Section 3. Section 4 details the unsupervised method that builds the knowledge base, while Section 5 presents the experiments we perform to assess the effectiveness and the efficiency of our solution. Finally, Section 6 discusses related work and Section 7 draws the conclusions of the work.

Let 
                        
                           P
                           =
                           {
                           
                              
                                 p
                              
                              
                                 1
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 p
                              
                              
                                 N
                              
                           
                           }
                        
                      be the set of PoIs in our city. Each PoI p is univocally identified by its geographic coordinates, a name, a radius specifying its spatial extent, and a relevance vector, 
                        
                           
                              
                                 
                                    
                                       v
                                    
                                    
                                       p
                                    
                                 
                              
                              
                                 →
                              
                           
                           ∈
                           
                              
                                 [
                                 0
                                 ,
                                 1
                                 ]
                              
                              
                                 |
                                 C
                                 |
                              
                           
                        
                     , measuring the normalized relevance of p w.r.t a set of categories C.

Symmetrically, let u be a user from the set 
                        
                           U
                        
                     , and 
                        
                           
                              
                                 
                                    
                                       v
                                    
                                    
                                       u
                                    
                                 
                              
                              
                                 →
                              
                           
                           ∈
                           
                              
                                 [
                                 0
                                 ,
                                 1
                                 ]
                              
                              
                                 |
                                 C
                                 |
                              
                           
                        
                      the preference vector stating the normalized interest of u for the categories in 
                        
                           C
                        
                     . The preference vector can be explicitly given by the user, or implicitly learned. Without loss of generality, in this paper we assume to know in advance the categories C, the relevance vectors 
                        
                           
                              
                                 
                                    
                                       v
                                    
                                    
                                       p
                                    
                                 
                              
                              
                                 →
                              
                           
                        
                     , and the preference vectors 
                        
                           
                              
                                 
                                    
                                       v
                                    
                                    
                                       u
                                    
                                 
                              
                              
                                 →
                              
                           
                        
                      for all PoIs and users.
                        Definition 1
                        User-PoI Interest


                        Given a PoI p, its relevance vector 
                              
                                 
                                    
                                       
                                          
                                             v
                                          
                                          
                                             p
                                          
                                       
                                    
                                    
                                       →
                                    
                                 
                              
                           , a user u, and the associated preference vector 
                              
                                 
                                    
                                       
                                          
                                             v
                                          
                                          
                                             u
                                          
                                       
                                    
                                    
                                       →
                                    
                                 
                              
                           , we define the User-PoI Interest function as a the following function 
                              
                                 Γ
                                 (
                                 p
                                 ,
                                 u
                                 )
                                 :
                                 P
                                 ×
                                 U
                                 →
                                 [
                                 0
                                 ,
                                 1
                                 ]
                              
                           : 
                              
                                 
                                    Γ
                                    (
                                    p
                                    ,
                                    u
                                    )
                                    =
                                    α
                                    ·
                                    sim
                                    (
                                    
                                       
                                          
                                             
                                                v
                                             
                                             
                                                p
                                             
                                          
                                       
                                       
                                          →
                                       
                                    
                                    ,
                                    
                                       
                                          
                                             
                                                v
                                             
                                             
                                                u
                                             
                                          
                                       
                                       
                                          →
                                       
                                    
                                    )
                                    +
                                    (
                                    1
                                    -
                                    α
                                    )
                                    ·
                                    pop
                                    (
                                    p
                                    )
                                 
                              
                           where 
                              
                                 sim
                                 (
                                 
                                    
                                       
                                          
                                             v
                                          
                                          
                                             p
                                          
                                       
                                    
                                    
                                       →
                                    
                                 
                                 ,
                                 
                                    
                                       
                                          
                                             v
                                          
                                          
                                             u
                                          
                                       
                                    
                                    
                                       →
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   v
                                                
                                                
                                                   p
                                                
                                             
                                          
                                          
                                             →
                                          
                                       
                                       ·
                                       
                                          
                                             
                                                
                                                   v
                                                
                                                
                                                   u
                                                
                                             
                                          
                                          
                                             →
                                          
                                       
                                    
                                    
                                       |
                                       |
                                       
                                          
                                             
                                                
                                                   v
                                                
                                                
                                                   p
                                                
                                             
                                          
                                          
                                             →
                                          
                                       
                                       |
                                       |
                                       
                                       |
                                       |
                                       
                                          
                                             
                                                
                                                   v
                                                
                                                
                                                   u
                                                
                                             
                                          
                                          
                                             →
                                          
                                       
                                       |
                                       |
                                    
                                 
                              
                            is the cosine similarity between the user preference and the PoI relevance vectors, 
                              
                                 pop
                                 (
                                 p
                                 )
                              
                            is a function, ranging from 0 to 1, measuring the popularity of p, and 
                              
                                 α
                                 ∈
                                 [
                                 0
                                 ,
                                 1
                                 ]
                              
                            is a parameter controlling how much user preference and popularity of PoIs have to be taken into account.

Given a user u and the PoIs 
                              
                                 P
                              
                           , the PoI history 
                              
                                 
                                    
                                       H
                                    
                                    
                                       u
                                    
                                 
                              
                            of u is the temporally ordered sequence of m points of interest visited by u. Each PoI p of 
                              
                                 
                                    
                                       H
                                    
                                    
                                       u
                                    
                                 
                              
                            is annotated with the two timestamps indicating the start time and the end time of the visit:
                              
                                 
                                    
                                       
                                          H
                                       
                                       
                                          u
                                       
                                    
                                    =
                                    〈
                                    (
                                    
                                       
                                          p
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    [
                                    
                                       
                                          t
                                       
                                       
                                          11
                                       
                                    
                                    ,
                                    
                                       
                                          t
                                       
                                       
                                          21
                                       
                                    
                                    ]
                                    )
                                    ,
                                    …
                                    (
                                    
                                       
                                          p
                                       
                                       
                                          m
                                       
                                    
                                    ,
                                    [
                                    
                                       
                                          t
                                       
                                       
                                          1
                                          m
                                       
                                    
                                    ,
                                    
                                       
                                          t
                                       
                                       
                                          2
                                          m
                                       
                                    
                                    ]
                                    )
                                    〉
                                 
                              
                           
                        

We can notice that having the start time and the end time we have an implicit representation of the time the user u has spent for her visit of p.
                        Definition 3
                        Trajectory


                        Given a PoI History 
                              
                                 
                                    
                                       H
                                    
                                    
                                       u
                                    
                                 
                              
                            and a time threshold δ, we define a trajectory 
                              
                                 
                                    
                                       T
                                    
                                    
                                       u
                                    
                                 
                              
                            any subsequence of 
                              
                                 
                                    
                                       H
                                    
                                    
                                       u
                                    
                                 
                              
                           
                           
                              
                                 
                                    〈
                                    (
                                    
                                       
                                          p
                                       
                                       
                                          k
                                       
                                    
                                    ,
                                    [
                                    
                                       
                                          t
                                       
                                       
                                          1
                                          k
                                       
                                    
                                    ,
                                    
                                       
                                          t
                                       
                                       
                                          2
                                          k
                                       
                                    
                                    ]
                                    )
                                    ,
                                    …
                                    ,
                                    (
                                    
                                       
                                          p
                                       
                                       
                                          k
                                          +
                                          i
                                       
                                    
                                    ,
                                    [
                                    
                                       
                                          t
                                       
                                       
                                          1
                                          (
                                          k
                                          +
                                          i
                                          )
                                       
                                    
                                    ,
                                    
                                       
                                          t
                                       
                                       
                                          2
                                          (
                                          k
                                          +
                                          i
                                          )
                                       
                                    
                                    ]
                                    )
                                    〉
                                 
                              
                           such that:
                              
                                 
                                    
                                       
                                          
                                          
                                             
                                                i
                                                ⩾
                                                1
                                             
                                          
                                       
                                       
                                          
                                          
                                             
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      1
                                                      k
                                                   
                                                
                                                -
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      2
                                                      (
                                                      k
                                                      -
                                                      1
                                                      )
                                                   
                                                
                                                >
                                                δ
                                                ,
                                                
                                                if
                                                
                                                
                                                k
                                                >
                                                1
                                             
                                          
                                       
                                       
                                          
                                          
                                             
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      1
                                                      (
                                                      k
                                                      +
                                                      i
                                                      +
                                                      1
                                                      )
                                                   
                                                
                                                -
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      2
                                                      (
                                                      k
                                                      +
                                                      i
                                                      )
                                                   
                                                
                                                >
                                                δ
                                                ,
                                                
                                                if
                                                
                                                (
                                                k
                                                +
                                                i
                                                )
                                                <
                                                m
                                             
                                          
                                       
                                       
                                          
                                          
                                             
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      1
                                                      (
                                                      k
                                                      +
                                                      j
                                                      )
                                                   
                                                
                                                -
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      2
                                                      (
                                                      k
                                                      +
                                                      j
                                                      -
                                                      1
                                                      )
                                                   
                                                
                                                ⩽
                                                δ
                                                ,
                                                
                                                ∀
                                                j
                                                
                                                s.t.
                                                
                                                1
                                                ⩾
                                                j
                                                ⩽
                                                i
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

Let John Smith be a tourist who visited the city of Rome for two-days. John Smith’s PoI history consists in the temporally ordered sequence of PoIs visited in the two days. As an example:
                              
                                 
                                    
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         H
                                                      
                                                      
                                                         JohnSmith
                                                      
                                                   
                                                
                                             
                                             =〈 (Colusseum, Tue[09.00,10.30]), (Roman forum, Tue[11.00,12.00]), (Spagna square, Tue[14.30,17.30], (St. Peter’s Church, Wed[10.00–11.00]), (Vatican Museum, Wed[11.10,15.00]), (Trevi Fountain, Wed[16.30,17.00]), (Navona Square, Wed[17.20,18.00]), (via Veneto, Wed[18.35,20.00])〉.
                                       
                                    
                                 
                              
                           
                        

By using a threshold of 5h as trajectory splitting criterium, from 
                              
                                 
                                    
                                       H
                                    
                                    
                                       JohnSmith
                                    
                                 
                              
                            we obtain the following two trajectories:
                              
                                 
                                    
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         T
                                                      
                                                      
                                                         JohnSmith
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                
                                             
                                             =〈(Colusseum,Tue[09.00,10.30]), (Roman forum, Tue[11.00,12.00]), (Spagna square, Tue[14.30,17.30]〉
                                       
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         T
                                                      
                                                      
                                                         JohnSmith
                                                      
                                                      
                                                         2
                                                      
                                                   
                                                
                                             
                                             =〈(St. Peter’s Church, Wed[10.00–11.00]), (Vatican Museum, Wed[11.10,15.00]), (Trevi Fountain, Wed[16.30,17.00]), (Navona Square, Wed[17.20,18.00]), (via Veneto, Wed[18.35,20.00]〉
                                       
                                    
                                 
                              
                           
                        

The time interval between the visits to Spagna square and St. Peters Church is in fact the only interval larger than the given threshold.
                              
                                 □
                              
                           
                        

By applying the same temporal splitting criterium to all the PoI histories of users 
                        
                           U
                        
                      we obtain the set 
                        
                           S
                           =
                           {
                           
                              
                                 S
                              
                              
                                 1
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 S
                              
                              
                                 M
                              
                           
                           }
                        
                      of relevant trajectories. Note that 
                        
                           S
                        
                      results from a set-union operation disregarding timestamps. Finally, let 
                        
                           ρ
                           (
                           p
                           )
                           :
                           P
                           →
                           R
                        
                      be an estimate of the time needed to visit 
                        
                           p
                           ,
                           τ
                           (
                           
                              
                                 p
                              
                              
                                 i
                              
                           
                           ,
                           
                              
                                 p
                              
                              
                                 j
                              
                           
                           )
                           :
                           P
                           ×
                           P
                           →
                           R
                        
                      an estimate of the time a user needs to move from 
                        
                           
                              
                                 p
                              
                              
                                 i
                              
                           
                        
                      to 
                        
                           
                              
                                 p
                              
                              
                                 j
                              
                           
                        
                     , and 
                        
                           
                              
                                 z
                              
                              
                                 →
                              
                           
                           =
                           (
                           
                              
                                 z
                              
                              
                                 1
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 z
                              
                              
                                 M
                              
                           
                           )
                        
                      be the total traveling time associated with each of the M trajectories in 
                        
                           S
                        
                     , obtained by exploiting 
                        
                           τ
                           (
                           ·
                           ,
                           ·
                           )
                        
                     . We are now ready to formulate the TripCover problem, i.e., the problem of generating an optimal personalized itinerary given tourist’s preferences and her budget in term of available time to spend in the city.

TripCover(B): Given a tourist u, a set of PoIs 
                        
                           P
                        
                     , a time budget B, a set of trajectories 
                        
                           S
                        
                     , an User-PoI Interest function Γ, a cost function 
                        
                           ρ
                           (
                           p
                           )
                        
                      and a vector 
                        
                           
                              
                                 z
                              
                              
                                 →
                              
                           
                        
                     . Find a subset of trajectories 
                        
                           
                              
                                 S
                              
                              
                                 ∗
                              
                           
                        
                      of 
                        
                           S
                        
                      that
                        
                           (1)
                           
                              maximize
                              
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       =
                                       1
                                    
                                    
                                       |
                                       S
                                       |
                                    
                                 
                              
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       j
                                       =
                                       1
                                    
                                    
                                       |
                                       P
                                       |
                                    
                                 
                              
                              Γ
                              (
                              
                                 
                                    p
                                 
                                 
                                    j
                                 
                              
                              ,
                              u
                              )
                              
                              
                                 
                                    y
                                 
                                 
                                    ij
                                 
                              
                           
                        
                     
                     
                        
                           (2)
                           
                              such
                              
                              that
                              
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       =
                                       1
                                    
                                    
                                       |
                                       S
                                       |
                                    
                                 
                              
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       j
                                       =
                                       1
                                    
                                    
                                       |
                                       P
                                       |
                                    
                                 
                              
                              ρ
                              (
                              
                                 
                                    p
                                 
                                 
                                    j
                                 
                              
                              )
                              
                              
                                 
                                    y
                                 
                                 
                                    ij
                                 
                              
                              +
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       =
                                       1
                                    
                                    
                                       |
                                       S
                                       |
                                    
                                 
                              
                              
                                 
                                    z
                                 
                                 
                                    i
                                 
                              
                              
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                              ⩽
                              B
                           
                        
                     
                     
                        
                           (3)
                           
                              
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       =
                                       1
                                    
                                    
                                       |
                                       S
                                       |
                                    
                                 
                              
                              
                                 
                                    y
                                 
                                 
                                    ij
                                 
                              
                              ⩽
                              1
                              ,
                              
                              ∀
                              j
                              ∈
                              {
                              1
                              ,
                              …
                              ,
                              |
                              P
                              |
                              }
                           
                        
                     
                     
                        
                           (4)
                           
                              
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       =
                                       1
                                    
                                    
                                       |
                                       S
                                       |
                                    
                                 
                              
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                              ⩾
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       =
                                       1
                                    
                                    
                                       |
                                       S
                                       |
                                    
                                 
                              
                              
                                 
                                    y
                                 
                                 
                                    ij
                                 
                              
                              ,
                              
                              ∀
                              j
                              ∈
                              {
                              1
                              ,
                              …
                              ,
                              |
                              P
                              |
                              }
                           
                        
                     where
                        
                           
                              
                                 
                                    y
                                 
                                 
                                    ij
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          
                                             
                                                1
                                             
                                             
                                                if
                                                
                                                PoI
                                                
                                                j
                                                
                                                in
                                                
                                                trajectory
                                                
                                                i
                                                
                                                is
                                                
                                                selected
                                                ;
                                             
                                          
                                          
                                             
                                                0
                                             
                                             
                                                otherwise
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          
                                             
                                                1
                                             
                                             
                                                if
                                                
                                                trajectory
                                                
                                                i
                                                
                                                is
                                                
                                                selected
                                                ;
                                             
                                          
                                          
                                             
                                                0
                                             
                                             
                                                otherwise
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     Without loss of generality, we assume 
                        
                           ∀
                           
                              
                                 S
                              
                              
                                 ′
                              
                           
                           ∈
                           S
                           ,
                           
                           
                              
                                 ∑
                              
                              
                                 p
                                 ∈
                                 
                                    
                                       S
                                    
                                    
                                       ′
                                    
                                 
                              
                           
                           Γ
                           (
                           p
                           ,
                           u
                           )
                           >
                           0
                        
                     . In fact, if this would not hold for a given user u and some trajectories, these trajectories could be filtered out. The TripCover(
                     B
                     ) problem as formulated in (2) is an instance of the Generalized Maximum Coverage (GMC) problem that is proven to be NP-hard (Cohen & Katzir, 2008). The constraint (2) and (3) ensure the time budget is satisfied, and each selected PoI is associated with only one trajectory, respectively. Moreover, (4) guarantees a selected trajectory if a PoI is selected. In particular, given a tourist u, TripCover(
                     B
                     ) can be captured by the GMC formulation in the following way: (i) the bins in GMC represent the collection 
                        
                           S
                        
                      of trajectories; (ii) the profit function 
                        
                           Γ
                           (
                           p
                           ,
                           u
                           )
                        
                      and the cost function 
                        
                           ρ
                           (
                           p
                           )
                        
                      are bins-independent. They only depend on p and u. The TripCover(
                     B
                     ) problem is thus NP-hard. An efficient greedy approximation algorithm for solving the GMC problem that achieves an approximation ratio of 
                        
                           e
                           /
                           (
                           e
                           -
                           1
                           )
                           +
                           ∊
                           ,
                           
                           ∀
                           ∊
                           >
                           0
                        
                      is proposed in Cohen and Katzir (2008). We thus adapted this algorithm, whose source code has been kindly provided us by the authors, in order to take into account TripCover(
                     B
                     ) specific constraints.

Once the solution of a given TripCover instance is computed, the trajectories in 
                        
                           
                              
                                 S
                              
                              
                                 ∗
                              
                           
                        
                      need to be scheduled on the user agenda. To this purpose, we model trajectory scheduling as a Traveling Salesman Problem (TSP) aimed at finding the shortest path crossing all these trajectories. In the classic TSP, the goal is to find the shortest path connecting a given set of geographical points. Here, the task is different as it is defined over a set 
                        
                           
                              
                                 S
                              
                              
                                 ∗
                              
                           
                        
                      of disjoint trajectories, i.e., trajectories not sharing any PoI. We consider these trajectories as bi-directional paths representing tourists’ behaviors that must be preserved in the final solution. Therefore we have to connect trajectories in a single sightseeing tour by only considering their terminal PoIs (endPoIs).

In the following, we formally define our trajectory scheduling problem (TrajSP), we propose a local-search based algorithm to efficiently address it and, finally, we describe the simple approach used to schedule the final sightseeing tour on the user agenda.


                     Trajectory Scheduling Problem. Let 
                        
                           
                              
                                 S
                              
                              
                                 ∗
                              
                           
                           ⊆
                           S
                        
                      be a set of disjoint trajectories, 
                        
                           
                              
                                 P
                              
                              
                                 ∗
                              
                           
                        
                      the set of endPoIs, and 
                        
                           E
                           =
                           (
                           
                              
                                 e
                              
                              
                                 ij
                              
                           
                           )
                        
                      the endPoIs matrix where 
                        
                           
                              
                                 e
                              
                              
                                 ij
                              
                           
                           =
                           1
                        
                      if i and j are endPoIs of the same trajectory of 
                        
                           
                              
                                 S
                              
                              
                                 ∗
                              
                           
                           ,
                           0
                        
                      otherwise. Moreover, let C be the symmetric cost matrix where 
                        
                           
                              
                                 c
                              
                              
                                 ij
                              
                           
                        
                      is the time needed to move from endPoI i to endPoI j. TrajSP is defined as follows:

TrajSP: Given the set of endPoIs 
                        
                           
                              
                                 P
                              
                              
                                 ∗
                              
                           
                        
                     , the endPoIs matrix E, and the cost matrix C, find the tour 
                        
                           
                              
                                 P
                              
                              
                                 ^
                              
                           
                        
                      that:
                        
                           (5)
                           
                              minimize
                              
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       =
                                       1
                                    
                                    
                                       |
                                       
                                          
                                             P
                                          
                                          
                                             ∗
                                          
                                       
                                       |
                                    
                                 
                              
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       j
                                       =
                                       i
                                       +
                                       1
                                    
                                    
                                       |
                                       
                                          
                                             P
                                          
                                          
                                             ∗
                                          
                                       
                                    
                                 
                              
                              |
                              
                                 
                                    c
                                 
                                 
                                    ij
                                 
                              
                              
                              
                                 
                                    η
                                 
                                 
                                    ij
                                 
                              
                           
                        
                     
                     
                        
                           (6)
                           
                              such that
                              
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       =
                                       1
                                    
                                    
                                       k
                                       -
                                       1
                                    
                                 
                              
                              
                                 
                                    η
                                 
                                 
                                    ik
                                 
                              
                              +
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       j
                                       =
                                       k
                                       +
                                       1
                                    
                                    
                                       |
                                       
                                          
                                             P
                                          
                                          
                                             ∗
                                          
                                       
                                       |
                                    
                                 
                              
                              
                                 
                                    η
                                 
                                 
                                    kj
                                 
                              
                              =
                              1
                              ,
                              
                              ∀
                              k
                              ∈
                              {
                              1
                              ,
                              …
                              ,
                              |
                              
                                 
                                    P
                                 
                                 
                                    ∗
                                 
                              
                              |
                              }
                           
                        
                     
                     
                        
                           (7)
                           
                              
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       ,
                                       j
                                       ∈
                                       S
                                    
                                 
                              
                              
                                 
                                    η
                                 
                                 
                                    ij
                                 
                              
                              +
                              
                                 
                                    e
                                 
                                 
                                    ij
                                 
                              
                              ⩽
                              |
                              S
                              |
                              -
                              1
                              ,
                              
                              (
                              S
                              ⊂
                              
                                 
                                    P
                                 
                                 
                                    ∗
                                 
                              
                              ,
                              |
                              S
                              |
                              >
                              2
                              )
                              ,
                              
                              i
                              <
                              j
                           
                        
                     
                     
                        
                           (8)
                           
                              
                              
                                 
                                    η
                                 
                                 
                                    ij
                                 
                              
                              ⩽
                              1
                              -
                              
                                 
                                    e
                                 
                                 
                                    ij
                                 
                              
                              ,
                              
                              ∀
                              i
                              ,
                              j
                              
                              i
                              
                              ≠
                              
                              j
                           
                        
                     where
                        
                           
                              
                                 
                                    η
                                 
                                 
                                    ij
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          
                                             
                                                1
                                             
                                             
                                                if endPoI
                                                
                                                i
                                                
                                                is
                                                
                                                connected
                                                
                                                to
                                                
                                                endPoI
                                                
                                                j
                                                ,
                                             
                                          
                                          
                                             
                                                0
                                             
                                             
                                                otherwise
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     In the above formulation, only the costs between different trajectories’ endPoIs have to be considered for minimizing cost (5), while (6) and (7) impose constraints on the degree of each endPoI and on sub-tour elimination, respectively (Rajesh Matai & Mittal, 2010). Note that the degree constraint in (6) is set to 1 since each endPoI already has one fixed connection to the next PoI of the associated trajectory. The last constraint in (8) ensures that two endPoIs of the same trajectory are never connected together in the solution.

Although the number of possible solutions for TrajSP is lower than whose of the corresponding TSP formulation,
                        6
                        We have exactly 
                              
                                 (
                                 k
                                 -
                                 1
                                 )
                                 !
                                 
                                 ∗
                                 
                                 
                                    
                                       2
                                    
                                    
                                       (
                                       k
                                       -
                                       1
                                       )
                                    
                                 
                              
                            solutions for k trajectories in the case of TrajSP, and 
                              
                                 (
                                 2
                                 k
                                 -
                                 1
                                 )
                                 !
                                 /
                                 2
                              
                            for the corresponding TSP formulation considering the two endPoIs of each trajectory.
                     
                     
                        6
                      finding the exact solution to TrajSP is still infeasible even for instances involving a small number of trajectories (we have about 82 billions of possible solutions with only 12 trajectories). Hence, we address TrajSP by proposing a Local Search heuristics that starts from a (given or random) tour 
                        
                           
                              
                                 P
                              
                              
                                 ^
                              
                           
                        
                      connecting all trajectories in 
                        
                           
                              
                                 S
                              
                              
                                 ∗
                              
                           
                        
                     , and then applying local changes to 
                        
                           
                              
                                 P
                              
                              
                                 ^
                              
                           
                        
                      by means of 2-OPT or 3-OPT strategies (Rajesh Matai & Mittal, 2010).

We now introduce an interesting property of the TrajSP problem that allows us to formalize how 2-OPT or 3-OPT strategies have to be applied. Given endPoI i, let 
                        
                           e
                           (
                           i
                           )
                           =
                           j
                        
                      be the other endPoI of the same trajectory. Obviously 
                        
                           e
                           (
                           j
                           )
                           =
                           i
                        
                      holds as well. Since we start from a tour connecting all the trajectories, each endPoI i is connected to both 
                        
                           e
                           (
                           i
                           )
                        
                      and to an endPoI d of another trajectory in 
                        
                           
                              
                                 S
                              
                              
                                 ∗
                              
                           
                        
                     . Let denote with 
                        
                           n
                           (
                           i
                           )
                        
                      the connected endPoI d. Note that only the link between endPoIs i and 
                        
                           n
                           (
                           i
                           )
                        
                      can be modified, since the path between i and 
                        
                           e
                           (
                           i
                           )
                        
                      is fixed by definition.

We now introduce a basic local-change operation 
                        
                           op
                           (
                           i
                           ,
                           k
                           )
                        
                      over two endPoIs 
                        
                           i
                           ,
                           k
                        
                     , such that 
                        
                           k
                           
                           ≠
                           
                           e
                           (
                           i
                           )
                        
                     . The local-change operation works by adding link 
                        
                           (
                           i
                           ,
                           k
                           )
                        
                      and removing links 
                        
                           (
                           n
                           (
                           i
                           )
                           ,
                           i
                           )
                        
                      and 
                        
                           (
                           n
                           (
                           k
                           )
                           ,
                           k
                           )
                        
                     . It is clear that the application of 
                        
                           op
                           (
                           ·
                           ,
                           ·
                           )
                        
                      leads to a non-admissible solution for TrajSP, since we remove two links of the tour while we add only one. We thus need to perform some additional changes to reconnect the two endPoIs that remain disconnected. The result below formalizes how such changes aimed at restoring the feasibility of the current solution have to be done. In particular, given two endPoIs 
                        
                           i
                           ,
                           
                           k
                        
                     , it states that we can apply 2-OPT or 3-OPT strategies chosen according to the value of 
                        
                           l
                           (
                           i
                           ,
                           k
                           )
                        
                     , a function returning the minimum number of endPoIs connections between i and k.
                        Lemma 1
                        
                           Given a tour 
                           
                              
                                 
                                    
                                       P
                                    
                                    
                                       ^
                                    
                                 
                              
                            
                           and a local-change operation 
                           
                              
                                 op
                                 (
                                 i
                                 ,
                                 k
                                 )
                              
                            
                           performed over two endPoIs 
                           
                              
                                 i
                                 ,
                                 k
                              
                            
                           such that 
                           
                              
                                 l
                                 (
                                 i
                                 ,
                                 k
                                 )
                                 >
                                 1
                              
                           
                           , if 
                           
                              
                                 l
                                 (
                                 i
                                 ,
                                 k
                                 )
                              
                            
                           is even, then a 2-OPT strategy needs to be applied to produce a feasible tour, a 3-OPT strategy otherwise.
                        

Given two endPoIs 
                              
                                 i
                                 ,
                                 
                                 k
                                 ,
                                 
                                 l
                                 (
                                 i
                                 ,
                                 k
                                 )
                              
                            can be either even or odd. First, suppose 
                              
                                 l
                                 (
                                 i
                                 ,
                                 k
                                 )
                              
                            is even. It means that the minimum number of connections between the endPoIs i and k is even. As a consequence, starting from the link 
                              
                                 (
                                 n
                                 (
                                 i
                                 )
                                 ,
                                 i
                                 )
                              
                            (crossed line), by walking anti-clockwise from i to k, we arrive at 
                              
                                 (
                                 e
                                 (
                                 k
                                 )
                                 ,
                                 k
                                 )
                              
                            (solid line), or from 
                              
                                 (
                                 i
                                 ,
                                 e
                                 (
                                 i
                                 )
                                 )
                              
                            (solid line) by walking clockwise, we arrive at 
                              
                                 (
                                 k
                                 ,
                                 n
                                 (
                                 k
                                 )
                                 )
                              
                            (crossed line) as shown in Fig. 1
                           (a).

Operation 
                              
                                 op
                                 (
                                 i
                                 ,
                                 k
                                 )
                              
                            removes 
                              
                                 (
                                 n
                                 (
                                 i
                                 )
                                 ,
                                 i
                                 )
                              
                            and 
                              
                                 (
                                 n
                                 (
                                 k
                                 )
                                 ,
                                 k
                                 )
                              
                           . Moreover, it adds 
                              
                                 (
                                 i
                                 ,
                                 k
                                 )
                              
                            (see Fig. 1(b)). Note that, at this point the tour is disconnected. To have a feasible tour, we need to add the new link 
                              
                                 (
                                 n
                                 (
                                 i
                                 )
                                 ,
                                 n
                                 (
                                 k
                                 )
                                 )
                              
                            that joins the two disconnected endPoIs. Because this process adds two links 
                              
                                 (
                                 i
                                 ,
                                 k
                                 )
                                 ,
                                 
                                 (
                                 n
                                 (
                                 i
                                 )
                                 ,
                                 n
                                 (
                                 k
                                 )
                                 )
                              
                            and removes two other links 
                              
                                 (
                                 n
                                 (
                                 i
                                 )
                                 ,
                                 i
                                 )
                                 ,
                                 
                                 (
                                 n
                                 (
                                 k
                                 )
                                 ,
                                 k
                                 )
                              
                           , it corresponds to applying a 2-OPT strategy.

We now study the case 
                              
                                 l
                                 (
                                 i
                                 ,
                                 k
                                 )
                              
                            is odd. Starting from 
                              
                                 (
                                 i
                                 ,
                                 n
                                 (
                                 i
                                 )
                                 )
                              
                           , leads us to 
                              
                                 (
                                 k
                                 ,
                                 n
                                 (
                                 k
                                 )
                                 )
                              
                            (crossed line). Moreover, from 
                              
                                 (
                                 i
                                 ,
                                 e
                                 (
                                 i
                                 )
                                 )
                              
                            we arrive at 
                              
                                 (
                                 k
                                 ,
                                 e
                                 (
                                 k
                                 )
                                 )
                              
                            (solid line). This configuration is shown in Fig. 1(c). Applying 
                              
                                 op
                                 (
                                 i
                                 ,
                                 k
                                 )
                              
                            to this particular case generates a different configuration (see Fig. 1(d)), i.e., one sub-tour (i.e., a closed path) from i to k, and one path from 
                              
                                 n
                                 (
                                 i
                                 )
                              
                            and 
                              
                                 n
                                 (
                                 k
                                 )
                              
                           . To merge the sub-tour and the path, we need to remove one link from the sub-tour and connect it to the path, e.g., 
                              
                                 n
                                 (
                                 i
                                 )
                              
                            and 
                              
                                 n
                                 (
                                 k
                                 )
                              
                           . So, we can remove 
                              
                                 (
                                 e
                                 (
                                 i
                                 )
                                 ,
                                 n
                                 (
                                 e
                                 (
                                 i
                                 )
                                 )
                              
                           . We then need to add 
                              
                                 (
                                 e
                                 (
                                 i
                                 )
                                 ,
                                 n
                                 (
                                 i
                                 )
                                 )
                              
                            and 
                              
                                 (
                                 n
                                 (
                                 e
                                 (
                                 i
                                 )
                                 )
                                 ,
                                 n
                                 (
                                 k
                                 )
                                 )
                              
                            to obtain a tour crossing all the endPoIs. Because we add three new links and remove three other ones, we applied a 3-OPT strategy.
                           
                              
                                 □
                              
                           
                        


                     Local search algorithm. From the above discussion, it is easy to devise a local search algorithm that iteratively optimizes a given tour by applying 2-OPT or 3-OPT strategies and stops after a fixed number of iterations or when it converges to a locally optimal solution.


                     Scheduling the tour on the user agenda. Given the sightseeing tour 
                        
                           
                              
                                 P
                              
                              
                                 ^
                              
                           
                        
                      computed for a given user and a time budget by our local search TrajSP algorithm, we schedule it on the user agenda by splitting the tour into the desired number m of slots (e.g., days). The solution involves identifying a starting endPoI in the tour and assigning the successive PoIs in 
                        
                           
                              
                                 P
                              
                              
                                 ^
                              
                           
                        
                      to the current slot until the slot is filled and the next slot is considered. The choice of the starting endPoI can be done in two different ways: either by removing the most “expensive” connection (e.g., in terms of traveling time) between two endPoIs of the tour or by taking into account the closest endPoI to a given spatial position (e.g. user’s hotel).


                     Fig. 2
                      depicts an overview of the TripBuilder architecture. The component related to “Data Collection” retrieves relevant data from Flickr, Wikipedia, and Google Maps. The second component called “Data Processing” extracts the knowledge used to devise relevant PoIs and model users’ visiting behaviors from data provided by the “Data Collection” component. Given a budget B, the third component “Covering” deals with the exploitation of the models and the knowledge base to compute the solution to the TripCover(
                     B
                     ) problem. The result is a set of trajectories in the chosen city on the basis of user interests and time budget that are finally scheduled on the user agenda by the fourth component “Scheduling”.

In order to assess TripBuilder we generate – in a complete unsupervised process – a knowledge base covering three Italian cities which are important from a sightseeing point of view and guarantee variety and diversity in terms of size and richness of public user-generated content available for download: Rome, Florence, and Pisa. The generation of the knowledge base for each of the cities is a multi-steps process that we are going to detail in the following.


                     PoIs. The first step is to identify the set of PoIs in the target geographical region. Given the bounding box 
                        
                           
                              
                                 BB
                              
                              
                                 city
                              
                           
                        
                      containing the city of interest, we download all the geo-referenced Wikipedia pages falling within this region. We assume each geo-referenced Wikipedia named entity, whose geographical coordinates falls into 
                        
                           
                              
                                 BB
                              
                              
                                 city
                              
                           
                        
                     , to be a fine-grained Point of Interest. For each PoI, we retrieve its descriptive label, its geographic coordinates as reported in the Wikipedia page, and the set of categories the PoI belongs to. Categories are reported at the bottom of the Wikipedia page, and are used to link articles under a common topic. They form a hierarchy, although sub-categories may be a member of more than one category. By considering the set C of categories associated with all the PoIs, we generate the normalized relevance vector of each PoI. We then perform a density-based clustering to group in a single PoI sightseeing entities which are very close one to each other.
                        7
                        Consider for example the beautiful marble statues in the Loggia dei Lanzi in Florence which are only a few meters far one from each other but have a distinct dedicated page in Wikipedia.
                     
                     
                        7
                      Clustering very close PoIs is important since a tourist in a given place can enjoy all the attractions in the surroundings even if she do not take photos to all of them. Moreover, it aims at reducing the sparsity that might affect trajectory data. To cluster the PoIs we use DBScan (Ester, Peter Kriegel, Sander, & Xu, 1996). To build our dataset, we set 1 as the minimum number of points and 200m as ∊. Finally, we obtain the relevance vector for the clustered PoIs by considering the occurrences of each category in the members of the clusters and by normalizing the resulting vector. At the end of this first step we have the set 
                        
                           P
                           =
                           {
                           
                              
                                 p
                              
                              
                                 1
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 p
                              
                              
                                 N
                              
                           
                           }
                        
                      of PoIs and the relevance vector 
                        
                           
                              
                                 
                                    
                                       v
                                    
                                    
                                       p
                                    
                                 
                              
                              
                                 →
                              
                           
                           ∈
                           
                              
                                 [
                                 0
                                 ,
                                 1
                                 ]
                              
                              
                                 |
                                 C
                                 |
                              
                           
                        
                      for each of these PoIs in a fully automatic way by exploiting Wikipedia as an external source of knowledge.


                     Users and PoI histories. As second step we need a method for collecting users 
                        
                           U
                        
                      and the long-term itineraries crossing the discovered PoIs. We query Flickr to retrieve the metadata (user id, timestamp, tags, geographic coordinates, etc.) of the photos taken in the given area 
                        
                           
                              
                                 BB
                              
                              
                                 city
                              
                           
                        
                     . The assumption we are making is that photo albums made by Flickr users implicitly represent sightseeing itineraries within the city. To strengthen the accuracy of our method, we retrieve only the photos having the highest geo-referenced accuracy given by Flickr.
                        8
                        
                           http://www.flickr.com/services/api/flickr.photos.search.html.
                     
                     
                        8
                      This process thus collects a large set of geo-tagged photo albums taken by different users within 
                        
                           
                              
                                 BB
                              
                              
                                 city
                              
                           
                        
                     . We preliminary discard photo albums containing only one photo. Then, we spatially match the remaining photos against the set of PoIs previously collected. We associate a photo to a PoI when it has been taken within a circular buffer of a given radius having the PoI as its center. To build our dataset, we empirically set it to 100m this radius. Note that in order to deal with clustered PoIs, we consider the distance of the photo from all constituent members: in the case the photo falls within the circular region of at least one of the members, it is assigned to the clustered PoI. Moreover, since several photos by the same user are usually taken close to the same PoI, we consider the timestamps associated with the first and last of these photos as the starting and ending time of the user visit to the PoI. The PoI visiting time 
                        
                           ρ
                           (
                           p
                           )
                        
                      is then estimated by computing for each PoI the average of these times. Moreover, the popularity of each PoI is computed as the number of distinct users that take at least one photo in its circular region. The above process allows us to generate the set of users 
                        
                           U
                        
                     , their PoI history, and estimate for the popularity and visiting time of each PoI. Finally, the preference vector for each user is built by summing up and normalizing the relevance vectors of all the PoIs occurring in her PoI history.


                     Trajectories. In order to build the set 
                        
                           S
                        
                      of trajectories we split users’ PoI histories as detailed in Definition 2. To choose the splitting threshold δ, we derive the users’ wisdom-of-crowds behavior by analyzing the inter-arrival time of each pair of consecutive photos taken in different PoIs. Therefore, for each city we compute the distribution of probability of the inter-arrival time 
                        
                           P
                           (
                           x
                           ⩽
                           δ
                           )
                        
                      of pairs of consecutive photos. Then, we devise the time threshold δ such that 
                        
                           P
                           (
                           x
                           ⩽
                           δ
                           )
                           =
                           0.9
                        
                     . Fig. 3
                     (a) shows the distributions of probability of inter-arrival times, i.e., 
                        
                           P
                           (
                           x
                           ⩽
                           δ
                           )
                        
                     , for all the pairs of consecutive photos in each dataset. Results show that while for Rome and Florence the resulting δ is about 5 and 6h respectively, for the smallest city of Pisa it decreases to about 3h.


                     Traveling time estimation. An important aspect of TripBuilder is that we recommend sightseeing tours fitting the available time budget and not just the set of PoIs to be visited. The sightseeing tour building step should therefore consider not only the PoI visiting time 
                        
                           ρ
                           (
                           p
                           )
                        
                      but also the time 
                        
                           τ
                           (
                           ·
                           ,
                           ·
                           )
                        
                      needed to move between consecutive PoIs in the itinerary. Since measuring intra-PoI moving time from the photo albums resulted to be inaccurate for not popular PoIs, we resort to an external service. Given a pair 
                        
                           (
                           
                              
                                 p
                              
                              
                                 i
                              
                           
                           ,
                           
                              
                                 p
                              
                              
                                 j
                              
                           
                           )
                        
                      of PoIs in a trajectory, we estimate 
                        
                           τ
                           (
                           
                              
                                 p
                              
                              
                                 i
                              
                           
                           ,
                           
                              
                                 p
                              
                              
                                 j
                              
                           
                           )
                        
                      by querying Google Maps for the walking time between the PoIs. Naturally, this is an approximation since several variations may happen: the user having a car, using public transportation, taking a taxi. However, our method is parametric to these aspects, and the system can be easily adapted to consider the different choices. Moreover, most PoIs in our sightseeing cities are actually at walking distances.


                     Datasets statistics. 
                     Table 1
                      shows the main characteristics of the three datasets. The second column reports the number of PoIs for each of the three cities. Note that these numbers refer to the result of the clustering phase, while the number of entities extracted from Wikipedia is 124, 1022, and 671 for Pisa, Florence and Rome, respectively. Furthermore, columns “Users” and “Photos” report the number of distinct users and photos retrieved from Flickr. Finally, column “Trajectories” reports the number of trajectories crossing at least two PoIs, while column “Traj. per PoI (avg.)” reports the average number of trajectories crossing each PoI.


                     Fig. 3(b)–(d) show three plots regarding the characteristics of the three datasets that have been made available for download to favor the reproducibility of experiments.
                        9
                        Interested readers can download the datasets from the URL: https://github.com/igobrilhante/TripBuilder.
                     
                     
                        9
                      A general consideration common to all the three figures regards the skewness of the distributions that are plotted in log–log scale. In particular, Fig. 3(b) reports the distribution of trajectory length expressed in term of the number of crossed PoIs. We can see that the slope of the three curves is very similar, only absolute values vary as expected. Note that the most frequent trajectory length in the plot is just 1. These are obviously noisy trajectories, corresponding to the cases in which we can match only one single PoI to a photo album. These spurious trajectories are maintained in the datasets only for their contribution to the measure of PoI popularity, but do not belong to the set 
                        
                           S
                        
                      of trajectories used by TripBuilder.


                     Fig. 3(c) shows the distribution of PoI popularity in the three cities involved. Even in this case we can note strong similarities in the distributions, although the curves of Rome and Florence cross in the tail. This happens for a peculiarity in these two datasets: while we have more users and photos for Rome than for Florence, the opposite holds for the number of PoIs reported in the X axis.

The last plot reported in Fig. 3(d) shows the popularity of categories associated with the PoIs. Even in this case we have a power-law distribution with a few very popular categories and most categories associated with relatively few PoIs. Wikipedia categories form in fact a (weak) hierarchy, and the most general topics are associated with many pages, while sub-categories are relevant only for precisely identified subsets of homogeneous PoIs.

Finally, Table 2
                      report the top-3 most popular PoIs and categories in Pisa, Florence and Rome. We also report three examples per city of trajectories extracted from the dataset. Note that a popular PoI in Florence and Pisa is the baptistery which is entitled, in both cities, to Saint John the Baptist.

@&#EXPERIMENTS@&#

We now assess the effectiveness of TripBuilder in: (i) selecting a set of trajectories of interest for a given user (TripCover), and (ii) scheduling that set on the user agenda (TrajSP). This is done by comparing its performance with those obtained by competitive baseline by means of evaluation metrics that consider the actual behavior of test users as mined from Flickr. Moreover, we present an evaluation of the efficiency of the TripBuilder framework together with a detailed evaluation of both TripCover and TrajSP solutions.
                        10
                        All the experiments have been conducted on a Ubuntu Linux box with two Intel®Xeon®E5520 CPUs and 32GB of RAM.
                     
                     
                        10
                     
                  

We conduct our experiments on the three datasets of Pisa, Florence, and Rome by varying the time budget and the parameter α affecting the contribution of PoIs/user-similarity and PoI-popularity to user profit. Moreover, we perform two different set of experiments that differ for the methodology used to choose the test users:
                        
                           •
                           
                              Random selection. Here the set of users used to assess TripBuilder performance is randomly chosen. In particular, we consider for all the three cases a set of 100 test users randomly selected among the visitors having a Poi history longer than 10, 15, and 20 PoIs for Pisa, Florence and Rome, respectively. The threshold on the length of the PoI history is set in order to be able to vary in a significant range the time budgets. This is because it is not feasible to evaluate a personalized 4-days itinerary in Rome with test users that actually visited only a few popular PoIs during a single day of visit. By using the above cutoff values, the users among which the 100 test users were chosen are 
                                 
                                    153
                                    ,
                                    679
                                 
                              , and 930 in Pisa, Florence, and Rome, respectively.


                              Profile-based selection. Here we select the test users among users who actually visited at least two of the three cities. In particular, given a user visiting two cities A and B, we used the preference vector obtained from the PoIs visited in city A to generate the personalized sightseeing tour in city B and vice versa. In this way we avoid any possible bias to the specific categories used in the Wikipedia pages of a given city.


                     Effectiveness – TripCover. We compare the effectiveness of TripBuilder in selecting a budgeted set of trajectories of interest for a given user against the following baselines:
                        
                           •
                           
                              Trajectory Popularity (Tpop). This baseline builds the tour by taking into account the normalized popularity of the trajectories in 
                                 
                                    S
                                 
                               computed as the sum of the popularity of the constituent PoIs divided by the length of the trajectory. It greedily adds to the visiting plan the most popular trajectories until the time budget is reached.


                              Trajectory Personalized Profit (Tppro). Given the preference vector of a tourist, this baseline sorts the trajectories in 
                                 
                                    S
                                 
                               by decreasing normalized user/PoI similarity. Such trajectory score is computed as the sum of user/PoI similarities of all the PoIs in the trajectory divided by the trajectory length. The baseline builds the personalized itinerary by adding once at a time the trajectories having the highest profit for the specific tourist until the total time budget is reached.

Experiments are conducted by providing to TripBuilder and the baseline algorithms the preference vector of each one of the test users in each city, along with a time budget varying in the range 
                        
                           1
                           ,
                           
                           2
                        
                     , and 4days (
                        
                           1
                           /
                           2
                           ,
                           1
                        
                      day in the case of the small city of Pisa).
                        11
                        We assume the normal daily activity of a tourist in a city to be of twelve hours. Our solution is, however, completely agnostic w.r.t. the daily agenda and works with tourist-provided agenda defining different time slots as well.
                     
                     
                        11
                      We evaluate the performance of the three methods by means of the metrics defined in Table 3
                     . Moreover, we also employ recall (Baeza-Yates & Ribeiro-Neto, 1999), a well-known IR metrics that in our settings measure the ability of the methods to predict PoIs and categories that match actual PoI histories of the users in the test set.


                     Random Selection. 
                     Tables 4–6
                     
                     
                      report the effectiveness measured for the recommended sightseeing tours on the basis of the metrics defined in Table 3 in Pisa, Florence, and Rome, respectively. In particular, each table details the average per-user performance and its standard deviation for each previously-defined metrics, and highlights in bold fonts the best per-budget figures. The first observation from the results is that, despite of their simplicity, both popularity (Tpop) and profit-based (Tppro) greedy strategies perform well, thus forming competitive baselines. In terms of Personal Profit Score (
                        
                           
                              
                                 S
                              
                              
                                 u
                              
                              
                                 pro
                              
                           
                        
                     ), our solution improves the baselines up to 86% in Pisa with an absolute improvement 
                        
                           Δ
                           
                              
                                 S
                              
                              
                                 u
                              
                              
                                 pro
                              
                           
                        
                      of 0.30 (Tpop vs. TripBuilder, 
                        
                           α
                           =
                           0.75
                        
                     ), 178% in Florence with an improvement 
                        
                           Δ
                           
                              
                                 S
                              
                              
                                 u
                              
                              
                                 pro
                              
                           
                        
                      of 0.203 (Tpop vs. TripBuilder, 
                        
                           α
                           =
                           1
                        
                     ), and 213% in Rome with an improvement 
                        
                           Δ
                           
                              
                                 S
                              
                              
                                 u
                              
                              
                                 pro
                              
                           
                        
                      of 0.382 (Tpop vs. TripBuilder, 
                        
                           α
                           =
                           0.75
                        
                     ). In terms of 
                        
                           
                              
                                 S
                              
                              
                                 u
                              
                              
                                 pro
                              
                           
                        
                     , TripBuilder outperforms the baselines showing a behavior which is sensitive to the parameter α.

Results in Pisa (see Table 4) compared to Tppro demonstrate that our approach is better for 
                        
                           1
                           /
                           2
                        
                     -day budget with 6% of improvement, while Tppro is better for 1-day budget, but it improves only 1%. It is worth highlighting two situations: (1) when 
                        
                           α
                           =
                           0
                        
                     , TripBuilder works by considering only the popularity (as Tpop) showing a performance in terms of 
                        
                           
                              
                                 S
                              
                              
                                 u
                              
                              
                                 pro
                              
                           
                        
                      that is similar to the Tpop baseline; (2) when 
                        
                           α
                           =
                           1
                        
                     , TripBuilder considers only users’ interest, and its performance becomes comparable with Tppro. We conclude that α plays an important role in TripBuilder to balance the contribution of users’ profit/interest and PoI’s popularity. For instance, the highest 
                        
                           
                              
                                 S
                              
                              
                                 u
                              
                              
                                 pro
                              
                           
                        
                      score in Pisa for the time budget of 1day can be found when 
                        
                           α
                           =
                           0.75
                        
                      (i.e., 0.79). Moreover, TripBuilder builds tours that increase the Visiting Time Score (
                        
                           
                              
                                 S
                              
                              
                                 vt
                              
                           
                        
                     ) up to 36min in Pisa (
                        
                           Δ
                           
                              
                                 S
                              
                              
                                 vt
                              
                           
                           =
                           0.05
                        
                     ), about 279min in Florence, and approximately 9.2h in Rome. Therefore, our algorithm is able to suggest itineraries that better match users’ preferences w.r.t the baselines. In addition, TripBuilder works by favoring higher visiting time while contributing to lower intra-PoI movement time in its solutions.

In terms of Visiting Time Score (
                        
                           
                              
                                 S
                              
                              
                                 vt
                              
                           
                        
                     ), the higher it is, the more relevant the itinerary can be considered for the user, since it is likely that she prefer to spend time visiting the PoIs than moving between them. As TripCover takes this factor into account (as a cost), it tends to exploit trajectories containing PoIs closer to each other to maximize the user profit. Consequently, we claim that TripBuilder is able to build tours that globally maximize 
                        
                           
                              
                                 S
                              
                              
                                 vt
                              
                           
                        
                     . We can see from the results in the tables that TripBuilder uses more appropriately the time budget. The difference in terms of 
                        
                           
                              
                                 S
                              
                              
                                 vt
                              
                           
                        
                      increases when larger budgets are considered. Moreover, this phenomenon is even more highlighted when dealing with larger cities. Indeed, in the case of Pisa, the three algorithms (i.e., Tpop, Tppro, TripBuilder) have quite similar 
                        
                           
                              
                                 S
                              
                              
                                 vt
                              
                           
                        
                     , with slight gains for TripBuilder (from 30 to 34min, with 
                        
                           α
                           =
                           0.75
                        
                     ). In the case of larger cities, i.e., Florence and Rome, TripBuilder remarkably outperforms the baselines. The rationale behind this result can be that in larger cities the intra-PoI traveling time tends to impact more the 
                        
                           
                              
                                 S
                              
                              
                                 vt
                              
                           
                        
                      metrics.

In terms of Popularity Score (
                        
                           
                              
                                 S
                              
                              
                                 pop
                              
                           
                        
                     ), results achieved with 
                        
                           α
                           =
                           0
                        
                      confirm that TripBuilder always outperforms Tpop. Moreover, figures for TripBuilder decreases for increasing values of α as expected.

In terms of PoIs and categories recall, all algorithms get at least 69% of the relevant PoIs and 81% of the categories for Pisa. Regarding categories recall in Pisa (see Table 4), TripBuilder and Tpop present similar results, while both of them outperform Tppro. Moreover, looking at PoIs recall, TripBuilder gets better results than the baselines (with 
                        
                           α
                           =
                           0.5
                        
                     ): 92.7% compared with 89.4% of Tpop and 90.9% of Tppro for the 1-day time budget. Comparing the results for Florence and Rome, we observe that TripBuilder outperforms in both recall figures the baselines depending on α setting. Moreover, when larger budgets are employed (2 and 4-days budget), it always outperforms the baselines independently from the value of α (see Tables 5 and 6). This behavior is due to the capability of TripBuilder of building tours with a higher Visiting Time Score within the time budgets. Consequently, more PoIs relevant for the specific user are likely to be visited. Moreover, we can see that the α parameter allows to fit the expectations of the user. For small values of α, results report higher recall values because trajectories crossing popular PoIs are preferred. When α increases, recall decreases because unexpected PoIs in the selected trajectories fitting the user interests are suggested. We believe these trajectories may constitute a source of serendipitous recommendations. Finally, the low standard deviations associated with the results in Tables 4–6 prove that the performance of the three techniques are stable w.r.t. different users’ profiles.


                     Profile-based Selection. In these experiments we select test users who visited two different cities A and B. We employ their preferences in city A to build and evaluate tours in city B and vice versa. Due to a lack of space, we report only the results obtained by considering Rome as target city B and Florence as city A. However, the results obtained considering different pairs of cities are similar thus confirming the behavior identified. Among the 2224 users visiting both Florence and Rome, we randomly chose 100 users having PoI histories longer than the thresholds discussed above. It is worth noting that for these experiments we need to “uniform” the categories of the PoIs in the three cities, since Wikipedia provides different categories for each city. Therefore, we exploit the general categorization used within the TripBuilder Web application available online
                        12
                        
                           http://tripbuilder.isti.cnr.it/.
                     
                     
                        12
                     : Architecture, Arts, Churches, Entertainment, Monuments, Museums, Nature & Landmarks.

The results of the experiments are reported in Table 7
                     . As we can see, the results confirm the trends reported for the previous experiments showing that TripBuilder remarkably outperforms the baselines. Moreover, the similarity of these results with those obtained in the tests using random selection confirm that the performance of TripBuilder is not affected by the “over-specific” categorization used in Wikipedia pages. Finally, it is worth noting that the recall figures computed at the category level are remarkably higher that in the previous experiments. This is motivated by the lower number of categories used to conduct the experiments: covering the whole set of categories with a sightseeing itinerary is in this case much simpler. It is also worth noting that we do not report results of TripBuilder with 
                        
                           α
                           =
                           0
                        
                      here because we are conducting a profile-based experiment. TripBuilder with 
                        
                           α
                           =
                           0
                        
                      does not exploit personalization. For this reason, we do not consider it in this analysis.


                     Effectiveness – T
                     
                        raj
                     
                     SP. We now evaluate the effectiveness of TripBuilder in scheduling the candidate set of trajectories on the user agenda. We evaluate effectiveness by considering the average path cost, the ratio between the cost of the TrajSP solution – i.e., the length of the connections between trajectories endPoIs – over the total budget available (see Fig. 4
                     ). The lower the ratio is, the better TripBuilder employes the time by minimizing the connections when solving the TrajSP instance. Our Local Search algorithm is compared with two baselines: (i) Random, which builds the sightseeing tours by randomly connecting the endPoIs of the trajectories; and (ii) Nearest Trajectory, which is an adaptation of the well-known “nearest neighbor” TSP greedy heuristic (Rajesh Matai & Mittal, 2010) that greedily constructs the solution by always selecting the trajectory with the closest endPoI. The results reported are referred to the whole set of 100 users in the test set. However, since we are evaluating heuristic approaches that might be very sensitive to the starting conditions, we ran each experiment 5 times and averaged the results achieved. The stop condition for our TrajSP local search algorithm used in all tests is reaching 1000 iterations or 100 iterations without improvement in the solution cost.

Results show that the Random baseline immediately diverges from the other competitors getting the worst paths. Nearest Trajectory performs better than Random and it is always able to provide an average connection cost lower than 0.3. On the other hand, our Local Search algorithm always outperforms both Random and Nearest Trajectories, with a notable improvement in all the three cities considered. In particular, it provides solutions having an average connection cost lower than 0.2. In other words, TripBuilder is able to address TrajSP even in big cities like Rome by adding at most 20% of the total time budget for inter-trajectory connections.


                     Efficiency. We now report results of experiments conducted to evaluate the efficiency of TripBuilder as a function of the time budget available for the three cities. In particular, we consider time budgets of 
                        
                           1
                           ,
                           2
                        
                     , and 4days (1/2, 1days in the case of the small city of Pisa), and, for each instance of the experiment (time budget, city), we run the algorithm for all the 100 distinct users in the test set and all the values of α used in the experiments reported in Tables 4–6. Fig. 5
                      shows the average runtime of TripBuilder along with standard deviation. Moreover, the plot highlights the contributions of TripCover (bottom bars) and of our TrajSP local search algorithm (upper bars) to the overall runtime. It is worth noting that TripBuilder always completes the tour building process in a few seconds. Moreover, the lower the number of trajectories in the dataset, the more similar the runtime is for all budgets. On the other hand, long time budgets (e.g. 4days) and large datasets impact the total runtime, as expected. Results also reveals low standard deviation of the average runtime thus confirming that the whole process is feasible for online applications.


                     Fig. 6
                      details the average runtime of the techniques employed to solve TrajSP. As before, we compute the efficiency by averaging the runtime obtained in 5 runs for each one of the 100 users of the test set. The Random technique obviously has the best runtime performance even if it is not effective in providing solutions as good as the other approaches do. For this reason, we do not report its results in Fig. 6. Results confirm that both the approaches for TrajSP can be exploited in practice. In general, Nearest Trajectory is always faster than Local Search. However, since the execution times are in any case limited, and Local Search remarkably outperforms Nearest Trajectory in effectiveness it has to be preferred.

@&#RELATED WORK@&#

Several works in the literature propose methods to recommend a list of PoIs based on the actual location of the user (location-based services) (Huang & Bian, 2009; Monreale, Pinelli, Trasarti, & Giannotti, 2009; Yoon, Zheng, Xie, & Woo, 2010, 2012; Lucchese, Perego, Silvestri, Vahabi, & Venturini, 2012). However, in this paper we focus on a method for suggesting “sightseeing tours” based on time-budgeted itineraries matching the user preferences. Even if TripBuilder could be easily adapted to fit a location-based service (LBS) model, we enhance classical LBS services by precomputing itineraries recommended to the user before the visit, thus at the planning stage. The task of designing a trip for a tourist approaching a new city has been investigated in the literature as we can see in the interesting survey on the topic presented in Vansteenwegen and Souffriau (2010).

An early work on recommending sightseeing itineraries is (Godart, 1999). Here authors use the Traveling Salesman Problem (TSP) as a core problem to plan trips. They automatically select PoIs and lodging trying to minimizing transport and accommodation costs while maximizing the attractiveness of the accommodation and the activities. Although interesting, this model is very complex and computationally expensive, making it very difficult to use in practice.

Shang et al. propose and investigate a problem called User Oriented Trajectory Search (UOTS) for trip recommendation (Shang et al., 2012). Given a trajectory data set, the query input contains a set of intended places given by the tourist and a set of textual attributes describing the tourist preference. If a trajectory is connecting/close to the specified query locations, and the textual attributes of the trajectory are similar to the tourist preference, it will be recommended to the tourist. This type of queries can bring benefits to tourists in many popular applications such as trip planning and recommendation. However, this approach does not take into account the user’s time budget in order to optimize her trip.

An interesting approach to the trip recommendation problem is the one proposed by Vansteenwegen et al., where authors define the Tourist Trip Design Problems (TTDP) (Souffriau, Vansteenwegen, Vertommen, Berghe, & Van Oudheusden, 2008; Vansteenwegen & Van Oudheusden, 2007). The orienteering problem, from the operational research literature, is a starting point for modeling the TTDP. They start with a set of possible locations with a score (indicating the user interest) and the objective is to maximize the total score of the visited locations, while keeping the total time (or distance) below the available time budget. They applied their algorithm, based on a guided local search, and a competitor, Dynamic Tour Guide, to a real data set of tourist points of interest with descriptions from the city of Ghent. Their approach turns out to be faster than the competitor and produces solutions of better quality. They also develop (Vansteenwegen, Souffriau, Berghe, & Oudheusden, 2011) a tourist expert system, called the “City Trip Planner” for planning routes.

The orienteering problem is also employed in De Choudhury et al. (2010). Here, De Choudhury et al. construct intra-city travel itineraries automatically by tapping a latent source reflecting geo-temporal traces left by millions of tourists. To do so, as in our case they firstly extract photo streams of individual users from Flickr. In the second step, they aggregate all user photo streams into a PoI graph. Itineraries are then automatically constructed from the graph based on the popularity of the PoIs and subject to the user’s time and destination constraints. However, the proposed orienteering problem does not model user preferences and it also does not model co-visitation of different PoIs. Furthermore, the greedy algorithm solving the orienteering problem explicitly needs a source PoI, a destination PoI, the total number of PoIs to be visited in the trip and a possible set of PoIs to not be visited.


                     Lu, Lin, and Tseng (2011), propose Trip-Mine to efficiently find the optimal trip which satisfies the user’s travel time constraint based on the user’s location. The authors evaluate Trip-Mine in terms of mining efficiency and memory storage requirement for optimal trip finding. In Zheng and Xie (2011), Zheng et al. discuss the issue of mining interesting locations and classical travel sequences. In this work, they propose a HITS-based inference model to mine interesting locations and classical travel sequences based on multiple users GPS trajectories in a given geospatial region.

TripBuilder overcomes some of the limitations of the works listed above. At the best of our knowledge it is the only system that solves the budgeted trip planning problem in a completely unsupervised way by exploiting user-generated content mined from Wikipedia and Flickr. Our principled modeling of the tour planning problem as a sequence of TripCover and TrajSP instances along with the algorithms we proposed to address these problem allowed us to build an efficient and robust system to efficiently compute personalized itineraries that fits precisely the user preferences.

@&#CONCLUSIONS@&#

In this paper, we comprehensively discussed TripBuilder, our unsupervised framework for recommending personalized sightseeing tours. TripBuilder addresses the problem of planning the visit to a city of touristic interest as a two-steps process. First, given the profile of the user and the amount of time available for the visit, the set of itineraries across the PoIs that best fits the user interests and respect the time constraint is chosen. This is done by solving the TripCover problem by means of an approximation algorithm. Then, the selected trajectories are joined in a sightseeing itinerary by means of a local search algorithm addressing TrajSP, a particular instance of the Traveling Salesman Problem. TripBuilder generates the budgeted sightseeing tours by composing popular trajectories performed by real tourists as mined from Flickr Photo albums. Moreover, since both PoIs characteristics and user preferences are mapped into the same categorization automatically extracted from Wikipedia, it is able to personalize the recommended itinerary and even consider the popularity of each PoIs as estimated from the number of photos available for it.

We experimented TripBuilder with data collected for three cities different for their size and the amount of user-generated content available for download. The process exploited to mine such content from Flickr, Wikipedia and Google Maps and to build the TripBuilder knowledge base has been detailed, and an analysis of the data collected has been provided. We evaluated our framework by considering the performance of the algorithms proposed to address both the TripCover and the TrajSP problems. The proposed solutions resulted to outperforms the baselines in terms of all the metrics adopted for assessment. Our solution suggests itineraries that better match user preferences. Moreover, such itineraries present higher visiting time and, consequently, lower intra-PoI movement time than the baselines. Furthermore, we assessed the performance of our TSP-based local search heuristic to schedule a set of trajectories into the user agenda. Finally, the tests conducted to demonstrate the efficiency of TripBuilder show that it computes a four-day personalized sightseeing tours of Rome in about 3s thus confirming that our approach can be fruitfully deployed in online applications.

@&#ACKNOWLEDGMENTS@&#

We acknowledge Liran Katzir and all authors of Cohen and Katzir (2008) for providing us their GMC source code. This work was partially supported by EU FP7 Marie Curie project SEEK (No. 295179), PRIN 2011 project ARS TECNOMEDIA, CNPQ Scholarship (No. 306806/2012-6), CNPQ Casadinho/PROCAD Project (No. 552578/2011-8), CNPQ-CNR Bilateral Project (No. 490459/2011-0), CNPQ Scholarship (No. 211836/2013-3), and by the Italian Ministry of Economic Development Project MOTUS (No. MS01 00015 – Industria2015).

@&#REFERENCES@&#

