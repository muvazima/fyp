@&#MAIN-TITLE@&#Spectral Collaborative Representation based Classification for hand gestures recognition on electromyography signals

@&#HIGHLIGHTS@&#


               
                  
                  
                     
                        
                           
                           Spectral Collaborative Representation based Classification (S-CRC) method is proposed.


                        
                        
                           
                           S-CRC yields overwhelming pattern recognition accuracy over 97% for stochastic signals.


                        
                        
                           
                           S-CRC is tested for EMG signal pattern recognition for 10 hand gestures.


                        
                        
                           
                           The recognition is performed in a continuous manner eliminating to pattern spotting.


                        
                        
                           
                           The methods introduced allow on the spot training, thus it can be used for other applications.


                        
                        
                           
                           The SCRC is a fast classification method, it can be used for mobile computing environments.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

EMG gesture

Continuous gesture recognition

Spectral representation

Gesture training matrix

MYO armband

@&#ABSTRACT@&#


               
               
                  The classification of the bio-signal has been used for various purposes in the literature as they are versatile in diagnosis of anomalies, improvement of overall health and sport performance and creating intuitive human computer interfaces. However, automatic identification of the signal patterns on a streaming real-time signal requires a series of complex procedures. A plethora of heuristic methods, such as neural networks and fuzzy systems, have been proposed as a solution. These methods stipulate certain conditions, such as preconditioning the signals, manual feature selection and large number of training samples.
                  In this study, we introduce a novel variant and application of the Collaborative Representation based Classification (CRC) in spectral domain for recognition of hand gestures using raw surface electromyography (EMG) signals. The CRC based methods do not require large number of training samples for an efficient pattern classification. Additionally, we present a training procedure in which a high end subspace clustering method is employed for clustering the representative samples into their corresponding class labels. Thereby, the need for feature extraction and spotting patterns manually on the training samples is obviated.
                  We presented the intuitive use of spectral features via circulant matrices. The proposed Spectral Collaborative Representation based Classification (SCRC) is able to recognize gestures with higher levels of accuracy for a fairly rich gesture set compared to the available methods. The worst recognition result which is the best in the literature is obtained as 97.3% among the four sets of the experiments for each hand gestures. The recognition results are reported with a substantial number of experiments and labeling computation.
               
            

@&#INTRODUCTION@&#

Electromyographic (EMG) signal based applications beyond clinical and rehabilitation purposes have been extensively studied in the literature. The classification of EMG signals in the kinesiological field has been investigated to analyze and improve sport [1,2], art [3] and occupational [4] performance. Human Computer Interface research field is another niche where the EMG signals have been utilized including, but not limited to control of exoskeletons, robotic prosthetic arms and hands.

The success of the EMG signal classification highly depends on three stages which are pre-processing, feature selection and the classification. In the pre-processing stage, noise and artifacts are removed from the signals. In [5], the authors propose a time lagged Recurrent Neural Networks (RNN) to eliminate the noise on the EMG signals. Wavelet transforms [6], higher order statistics [7,6] and empirical mode decomposition [8] method have also shown to be effective for removing artifacts and noise from the EMG signals.

The success of the EMG signal classification highly depends on three stages: pre-processing, manual feature selection and the classification. In the pre-processing stage, noise and artifacts are removed from the signals. The authors in [5] propose a time lagged Recurrent Neural Networks (RNN) to eliminate the noise on the EMG signals. Wavelet transforms [6,9], higher order statistics [7,6] and empirical mode decomposition [8] method have also shown to be effective methods for removing artifacts and noise from the bio-signals [10].

Feature extraction deals with extracting discriminating information hidden in the data which require experience in the field and tedious investigation of all possible features. Statistical features such as mean, variance and zero-crossing and derivatives have been predominantly examined and used in the bio-signal studies. No matter how pure the signal and how accurate the classification method is, without discriminating features it is difficult to obtain reliable classification results for any signal. In recent years, with the introduction of the auto-encoders and new network architectures [11], the dormant neural network has been revived in the burgeoning deep learning researches. The premise of this field is the self-learning neural networks which learn the features in an unsupervised manner from the big data.

Heuristic methods and variants of classical neural networks have been extensively used in classification of the stochastic bio-signals [12–16]. The authors in [12] use a classical neural network and statistical features for classification of the EMG signals obtained on from the face muscles to steer a power wheelchair. A feed-forward error backpropagation and wavelet neural networks were trained in [13] with a relatively sufficient number of the training samples with respect to that in [12]. In the studies [14,15] a combination of fuzzy and neural network methods was used to classify EMG signals.

Depending on the number of signal patterns to be classified, various kinds of features and methods for pre-processing and filtering, the accuracy of the classification methods ranges between 88 and 99.75% [17,10]. The common points of the listed methods are the large number of procedures to obtain a substantial recognition accuracy and the difficulty in the implementation. On the other hand, neural network can only result in a generative model provided that a sufficient number of training samples are fed through.

The EMG signal measured on skin surface is not a mere signal but rather the superposition of the Motor Unit Action Potential (MUAP) of the many tiny muscle fibers [18,19]. Due to the stochastic nature of MUAPs, the EMG signal pattern might exhibit intra and interpersonal variations for the same muscle activity. These variations make the EMG pattern classification an intricate task for creating robust classifiers.

In concert with the advancements in pervasive computing technologies, the wearable gadgets in which high grade sensors embedded have been released to the market. Thalmic Labs’ MYO armband [20] is one of the state of the art sensors which consists of eight surface EMG sensors. The sensor kit contains an inertial measurement unit as well. Inevitably, accessibility to such kind of devices with an affordable price tag garnered public attention both from academic and non-academic environments.

In this article, we introduce a signal pattern classification method in spectral domain and training procedures to classify the forearm EMG signals. The signals are obtained by 8-channel MYO armband real-time. The classification method is based on the Collaborative Representation based Classification (CRC) [21] which competes with the Sparse Representation based Classification (SRC) [22] with the same accuracy levels but much faster computation times. The drawback of the CRC compared to the SRC is that the CRC requires the observed and training signal patterns to be of equal length. This restricts the use of CRC methods for gesture and posture recognition in which the duration of the gestures might vary for each repetition. On the other hand, the SRC methods rely on the representation fidelity, whereas the CRC data fidelity. Therefore, the CRC methods lead lower recognition accuracy levels, if the data do not exhibit fidelity [23]. As the EMG signals are the products of complex stochastic processes, the performance of the CRC methods is low as we detail comparisons in the proceeding sections.

The Spectral Collaborative Representation based Classification (SCRC) proposed in this paper overcomes these drawbacks and yields high recognition accuracy for a fairly rich hand gesture set. Since the observed and training signal patterns must have equal lengths, a special training scheme is adapted to build a training dictionary. Therefore, the need for spotting signal patterns and manual feature selection is automatically eliminated and the boundary of the representative columns is implicitly embedded in the training matrix.

The contributions of this study to the literature are:
                        
                           •
                           The spectral content; complex conjugate eigenvalue pairs are obtained from 1D vectors by converting the observed signal pattern to a trajectory or a circulant matrix to capture the representative features of the EMG signals.

The gesture and posture recognition is performed in a continuous manner eliminating the requirements for spotting or picking the signal patterns on the streaming signals due to the proposed training scheme which implicitly embeds the signal boundaries on the representative columns.

The training phase is easy to implement; thus the end user can obtain a training dictionary on the spot. The flexibility in building a training dictionary paves the way for the use of the procedures and methods introduced here to implement different applications, such as control of a bionic prosthesis.

The number of hand gestures are the highest among the similar studies. Our worst recognition result is over 97% with a substantial number of gesture labeling computation.

The rest of the paper is organized as follows. In Section 2, a brief review of the CRC method is given and then the circulant matrix approach is detailed. In Section 3, after giving the technical details of the MYO armband, training phase for the gestures and SCRC is elaborated. The experiment and simulation results are discussed in Section 4. The paper ends with conclusion and future works in Section 5.

Spectral methods have been used for decades in variety of science disciplines where random signal or stochastic processes are involved.

Although randomness in the systems might render analysis of the features difficult in time domain, the spectral features such as eigenvalues and frequencies might reveal valuable information of the underlying processes [24]. Fourier analysis is the widely used spectral analysis method for this purpose. In this study, as the EMG signals show randomness, we exploit the spectral analysis by employing the circulant matrix structure for eigenvalue decomposition.

Both of the methods, the SRC and CRC address finding the linear representation coefficients vector x for the observed pattern y
                        =
                        Ax where 
                           A
                           =
                           [
                           
                              A
                              1
                           
                           ,
                           
                              A
                              2
                           
                           ,
                           …
                           ,
                           
                              A
                              n
                           
                           ]
                           ∈
                           
                              
                                 
                                    ℝ
                                 
                              
                              mxn
                           
                         is the dictionary matrix. The representative samples are stacked as column vectors in the dictionary. In the objective function of the solution (Eq. (1)) different vector norms are utilized depending on the methods and requirements.


                        
                           
                              (1)
                              
                                 
                                    
                                       x
                                       ˆ
                                    
                                 
                                 =
                                 
                                    
                                       arg
                                       
                                       min
                                    
                                    x
                                 
                                 
                                    ∥
                                    y
                                    −
                                    Ax
                                    
                                       ∥
                                       p
                                    
                                    +
                                    σ
                                    ∥
                                    x
                                    
                                       ∥
                                       q
                                    
                                 
                              
                           
                        
                     

In the SRC solution ℓ1 regularization is used (p
                        =2, q
                        =1), whereas the norms p and q become 1 or 2 in the CRC methods depending on the requirements such robustness of the classifier. If the objective function is solved by Regularized Least Square (RLS) in which ℓ2 norm used for both terms of the objective function the solution turns out the ridge regression.

We used the least square version of the CRC method which is dubbed as CRC_RLS by the authors in [23]. The ridge regression solution of Eq. (1) is obtained as 
                           
                              
                                 x
                                 ˆ
                              
                           
                           =
                           Py
                         where 
                           P
                           =
                           
                              
                                 (
                                 
                                    
                                       A
                                       T
                                    
                                 
                                 A
                                 +
                                 σ
                                 I
                                 )
                              
                              
                                 −
                                 1
                              
                           
                           
                              
                                 A
                                 T
                              
                           
                         and σ is the regularization parameter. Once the solution vector 
                           
                              x
                              ˆ
                           
                         is obtained the label of the observed signal is computed evaluating the minimum representation residuals r
                        
                           i
                         given in Eq. (2) where 
                           
                              δ
                              i
                           
                           :
                           
                              
                                 
                                    ℝ
                                 
                              
                              n
                           
                           →
                           
                              
                                 
                                    ℝ
                                 
                              
                              n
                           
                         is the selection operator that selects the coefficients of ith class while keeping other coefficients zero in the solution vector 
                           
                              x
                              ˆ
                           
                        .


                        
                           
                              (2)
                              
                                 
                                    min
                                    i
                                 
                                 
                                 
                                    r
                                    i
                                 
                                 (
                                 y
                                 )
                                 =
                                 ∥
                                 y
                                 −
                                 A
                                 
                                    δ
                                    i
                                 
                                 (
                                 
                                    
                                       x
                                       ˆ
                                    
                                 
                                 )
                                 
                                    ∥
                                    2
                                 
                              
                           
                        
                     

The SRC methods yield good classification results as long as the dictionary matrix is over-complete whereas the CRC do not require over-complete dictionaries. In addition with the lower number of dictionary representatives, the regression operator P is only computed and stored once and is coded over the new observed patterns for the solution vector x. This convenience makes the classification method perform faster than the SRC in real time applications.

In fact, new approaches have been introduced in the literature such as Block Sparse or Structured Sparse ℓ1 solvers [25,26] and Block SRC methods perform much better than the plain SRC in terms of the computational time without compromising the accuracy levels [27]. However, as the ℓ1 solvers are mostly based on iterative algorithms, the computation times are not satisfactory on the mobile devices such as phones and tablets [28].

Circulant matrices appear naturally in many systems of equation such as that of dynamical systems, convolution and vibration theories [24,29,30]. A circulant matrix is constructed from a vector by shifting its elements in clockwise or counterclockwise directions circularly. Depending on the direction of their diagonals (right or left circulants) they take the form of Toeplitz and Hankel matrices respectively which have wide range of application areas from compressing sensing, filter design, singular spectrum analysis to inverse eigenvalue problems [31–34].

In this respect, assuming a vector 
                           a
                           =
                           [
                           
                              v
                              0
                           
                           ,
                           
                              v
                              1
                           
                           ,
                           …
                           ,
                           
                              v
                              n
                           
                           ]
                        , the right circulant 
                           C
                           =
                           circ
                           (
                           a
                           )
                           ∈
                           
                              
                                 
                                    ℝ
                                 
                              
                              nxn
                           
                         becomes


                        
                           
                              (3)
                              
                                 
                                    C
                                    a
                                 
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      v
                                                      0
                                                   
                                                
                                                
                                                   
                                                      v
                                                      1
                                                   
                                                
                                                
                                                   
                                                      v
                                                      2
                                                   
                                                
                                                
                                                   ⋯
                                                
                                                
                                                   
                                                      v
                                                      
                                                         n
                                                         −
                                                         1
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      v
                                                      
                                                         n
                                                         −
                                                         1
                                                      
                                                   
                                                
                                                
                                                   
                                                      v
                                                      0
                                                   
                                                
                                                
                                                   
                                                      v
                                                      1
                                                   
                                                
                                                
                                                   ⋯
                                                
                                                
                                                   
                                                      v
                                                      
                                                         n
                                                         −
                                                         2
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      v
                                                      
                                                         n
                                                         −
                                                         2
                                                      
                                                   
                                                
                                                
                                                   
                                                      v
                                                      
                                                         n
                                                         −
                                                         1
                                                      
                                                   
                                                
                                                
                                                   
                                                      v
                                                      0
                                                   
                                                
                                                
                                                   ⋯
                                                
                                                
                                                   
                                                      v
                                                      
                                                         n
                                                         −
                                                         3
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   ⋮
                                                
                                                
                                                   ⋮
                                                
                                                
                                                   ⋮
                                                
                                                
                                                   ⋱
                                                
                                                
                                                   ⋮
                                                
                                             
                                             
                                                
                                                   
                                                      v
                                                      1
                                                   
                                                
                                                
                                                   
                                                      v
                                                      2
                                                   
                                                
                                                
                                                   
                                                      v
                                                      3
                                                   
                                                
                                                
                                                   ⋯
                                                
                                                
                                                   
                                                      v
                                                      0
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

Any circulant can be diagonalized by a unitary or Discrete Fourier Transformation (DFT) matrix due to their cyclic structure. This factorization is also a similarity transformation. If any two matrices A and B are similar, one of the them can be expressed as B
                        =
                        T
                        −1
                        AT where T is an invertible matrix. If T is a DFT matrix F
                        
                           n
                         (Eqs. (5) and (4)), the matrix A becomes a diagonal matrix, the entries of which are the eigenvalues of the circulant transformed.


                        
                           
                              (4)
                              
                                 Λ
                                 =
                                 
                                    F
                                    n
                                    H
                                 
                                 
                                    CF
                                    n
                                 
                              
                           
                        
                     

In this equation diag(Λ)={λ
                        1, λ
                        2, …, λ
                        
                           n
                        } and the matrix operator (o)
                           H
                         is the Hermitian transpose.


                        
                           
                              (5)
                              
                                 
                                    F
                                    n
                                 
                                 =
                                 
                                    1
                                    
                                       
                                          n
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   1
                                                
                                                
                                                   1
                                                
                                                
                                                   1
                                                
                                                
                                                   ⋯
                                                
                                                
                                                   1
                                                
                                             
                                             
                                                
                                                   1
                                                
                                                
                                                   W
                                                
                                                
                                                   
                                                      W
                                                      2
                                                   
                                                
                                                
                                                   ⋯
                                                
                                                
                                                   
                                                      W
                                                      
                                                         N
                                                         −
                                                         1
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   1
                                                
                                                
                                                   
                                                      W
                                                      2
                                                   
                                                
                                                
                                                   
                                                      W
                                                      4
                                                   
                                                
                                                
                                                   ⋯
                                                
                                                
                                                   
                                                      W
                                                      2
                                                   
                                                   
                                                      N
                                                      −
                                                      2
                                                   
                                                
                                             
                                             
                                                
                                                   ⋮
                                                
                                                
                                                   ⋮
                                                
                                                
                                                   ⋱
                                                
                                                
                                                   ⋮
                                                
                                                
                                             
                                             
                                                
                                                   1
                                                
                                                
                                                   
                                                      W
                                                      
                                                         N
                                                         −
                                                         1
                                                      
                                                   
                                                
                                                
                                                   
                                                      W
                                                      
                                                         2
                                                         (
                                                         N
                                                         −
                                                         2
                                                         )
                                                      
                                                   
                                                
                                                
                                                   ⋯
                                                
                                                
                                                   
                                                      W
                                                      
                                                         (
                                                         N
                                                         −
                                                         1
                                                         )
                                                         (
                                                         N
                                                         −
                                                         1
                                                         )
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The columns of the DFT matrix F
                        
                           n
                         with the entries W
                        =exp−2πi/n thus become the eigenvectors of the circulant matrix. Since all the eigenvectors of the decomposed circular matrices with the same size are the same, the resultant eigenvalues constitute a discriminative subspace. Thus, these subspaces which are shift invariant can be used as a dictionary matrix in the representation based classifications. The time complexity of the eigenvalue decomposition with a number of operation 
                           O
                           (
                           n
                           log
                           
                           n
                           )
                         is lower than the conventional decomposition methods; therefore, eigenvalue decomposition of the circulants is faster than the conventional eigenvalue decomposition algorithms [32].

In the SCRC, we build a training dictionary using the eigenvalues of the observed signal as the features. Since, complex numbers are involved, the Hermitian transpose of the vectors is used in the inner product space. In the complex domain, the solution vector 
                           
                              x
                              ˆ
                           
                         is obtained by the equation 
                           
                              
                                 x
                                 ˆ
                              
                           
                           =
                           
                              P
                              c
                           
                           x
                         where
                           
                              (6)
                              
                                 
                                    P
                                    c
                                 
                                 =
                                 
                                    
                                       (
                                       
                                          
                                             A
                                             H
                                          
                                       
                                       A
                                       +
                                       σ
                                       I
                                       )
                                    
                                    
                                       −
                                       1
                                    
                                 
                                 
                                    
                                       A
                                       H
                                    
                                 
                              
                           
                        
                     

The training matrix is normalized and centered in the CRC methods while the observed signal y is only centered. It is important to note that since the spectral features are used in the Fourier domain, Hermitian conjugate transpose is used for all inner product operations.

MYO armband which has been recently released to the market by Thalmic Labs revolutionized the EMG based studies because of affordable price tag and easy data collection. The sensor armband has a 8-channel EMG sensor group along with an Inertial Measurement Unit (IMU) which reports linear and rotational acceleration as well as the rotation angles around 3-axes. The sensor readings are transferred over a low power blue-tooth adapter to the computer (Fig. 1
                        ).

The Software Development Kit (SDK) allows the developers to access the EMG signals and motion parameters on the worn arm. As the measured EMG signals depend on the sensor location on the muscles, the MYO armband applications require a special calibration gesture every time when the armband is put on the arm or taken off. In this way, the application calibrates the sensor locations depending on the sensor direction and rotation of the armband. In our experiments we collected the experimental data without giving a break and taking off without needing re-calibrating the device. The armband location in the experiments is close to the elbow. Palmaris longus, flezor carpi radialis, brachioradialis, and flexor carpi ulnaris muscles on the anterior, extensor carpi ulranis, extensor digitorum, extensor carpi radialis brevis, extensor carpi radialis longus muscles on the posterior form arm are located under the armband sensors.

The IMU unit reports the motion related parameters at a frequency of 50Hz, whereas the frequency for the EMG signal is 200Hz as given on the company website [20]. The SDK provides a gesture object by which five different hand gestures are recognized. The same hand gesture set which is composed of hand fist, wave in, wave out, hand spread and double tap is used to test the SCRC performance (Fig. 2
                        ). If none of them is performed, the hand is assigned to the hand relax gesture.

The location of the EMG sensors is important for certain types of gestures as different hand and finger movements are controlled by the different muscle groups on the forearm. The armband configuration is put on close to the elbow where the discriminant EMG signals can be captured for hand movements. In order to classify individual finger gestures, the EMG sensors must be placed on the related muscle groups responsible for the fingers.

In gesture recognition studies, one of the open problems is spotting the gestures on the streaming signals. A gesture has start and end points which can be spotted on a continuously monitored signal; however gestures might differ among the people even for the same performer. Along with these variations, the time length of the different gestures in a set might also show variations. The spotting problem manifests itself in building a training dictionary for the representation based classification methods. This problem can be solved by using a switch that can mark the beginning and end points of the gestures in the real world and a trigger or switch event in the software applications.

The authors in [35] collect gestures by drawing in the air using an IR pen which is tracked by an IR camera of Wiimote. The performer presses and releases the switch of the IR pen at the beginning and the end of the gestures respectively. Spotting can also be done visually by analyzing the trajectory or the visually discriminating features which requires tedious effort for fairly rich gesture sets.

In this study, since the EMG signals consist of MUAP spikes, the gesture patterns cannot be spotted visually on the figures of the signal. Therefore, we employ subspace clustering methods for the repeated couple gestures. The subspace clustering methods fall in unsupervised.

We tested this approach for our previous studies [28,36]. The reason is twofold to adapt this approach. The first is the drawback of the constant sliding window which is very important for the CRC methods. The signals are captured by a sliding window both in the real-time application and the training phase for building a representative dictionary. The second is finding representatives for every gesture state in any time window which affect the recognition accuracy.

As the tracked body part, in our case, the hand might switch between gestures while being tracked and in the transition regions gestures overlap. Overlapping gesture regions degenerate the robustness and accuracy of the recognition. However, subspace clustering methods can separate the overlapping regions into their corresponding gesture classes. At least two gestures are necessary for clustering.

The state of art subspace clustering methods exploit the self-similarity property of the signals to be clustered. The most prominent of these algorithms are the Sparse and Low Rank Subspace Clustering (SSC, LRR) methods which make use of ℓ1 and nuclear norm in their objective functions [37,38].

We use a variant of SSC, the Ordered Subspace Clustering (OSC) method which puts an additional penalty in the self-similarity objective function for sequential data [39]. The additional term in the objective function enforces the neighboring representative samples to be same by penalizing the differences of two neighbors.

We collected gesture couples for all of the classes represented in the training dictionary. The hand performs two gestures repeatedly for the gesture couples. One of the gestures in each of the couples is hand relax state in which hand stays at a relaxed position. This state is assumed to be gesture mate of the each gesture. As a concrete explanation, let us assume that a hand performs the hand wave in gesture and returns to the hand relax position repeatedly as in demonstrated in Fig. 3
                        .

A constant length sliding window with an increment of sampling interval captures the content on the recorded EMG signal. The length of the sliding window in our application corresponds to 100 samples (half second at 200Hz). The measurements taken by the sliding window are put into the unclustered dictionary matrix. The subspace clustering method is used in this step to distill the pure representatives into their respective classes. A sample clustering result is given in Fig. 4
                         for the double tap gesture on a single channel EMG signals. As seen, the period of the one gesture cycle is approximately 0.5s corresponding to 100 time samples.

In fact, although it is not seen on the figure, there are four hand states in repetitions of the gesture couples; two static hand postures where the hand stays at the hand relax and terminal waved in positions, and the dynamic hand gestures through these postures. However, since the number of subspaces are chosen as two for the gesture couples, the posture states are embedded into the clusters automatically and every observable hand states are represented in these clusters. The training dictionary contains 10 gesture classes in this case and we map every return states to the hand relax position from any hand gesture are mapped to the five hand gestures.

We collected five gesture couple experiments, one for training and the rest for testing. In addition, we perform an arbitrary hand gesture sequence in which the hand visits arbitrary gesture states. The simulations are repeated using the conventional CRC_RLS for comparison of recognition performance of the CRC_RLS and SCRC. The duration of the each hand gesture couple experiments is approximately 6s corresponding to 1200 sampled data. A sliding window with a length of 100 samples (0.5s) and one sampling time increment is used to compute the label of the gesture at the sampling time. Therefore, on the figures given in this section, at least 1200 labeling results are given. The labels are shown as a bin on the bar figures.

Although the conventional CRC_RLS yields the same recognition accuracy for some of the experimental data, it can not discriminate the hand wave in and fist gestures labeling the wave in gesture as the fist gesture in all the experiments (Fig. 5
                     ) with some number of misclassification with the hand spread gesture. However, the worst recognition result for the hand wave in gestures among the four test sets is 99.36% for the SCRC method.


                     Fig. 6
                      shows the worst result of the wave in–hand relax test experiment. The bottom figure is the gesture label of the MYO gesture recognition module. Since the SRC recognizes 10 gestures, the number of labels are different than the MYO gesture module which labels the gestures as 1 – hand relax, 2 – fist, 3 – wave in, 4 – wave out, 5 – hand spread and 6 – double tap. The number of labeling computation in the figure is 1219 and the SCRC misclassifies the signal patterns as the fist gesture eight times.

As seen in Fig. 6, the misclassified gestures seem to occur at the transition states (after the 200th sample in the figure) in which hand goes from the hand relax states toward the hand fist. This is due to the fact that we compute the label of the each instantaneous hand position at a frequency of 200Hz and the length of the sliding window is 100 samples. There are 400 representative samples for each class in the training dictionary implying only four representatives of the each instantaneous hand position.

The recognition accuracy the fist and the double-tap gestures is 100% for all the test experiments (Figs. 7 and 8
                     
                     ). The fist and double tap gestures are well separated from the hand relax state. In Fig. 8 only two ripples are seen around 600 and 1100th samples where the algorithms change the label from the intended gesture. In other words at these sampling times, the state of the hand is labeled either as the hand relax or double tap while the hand is intended to stay at the other state. These two instances are not misclassification. As seen in the figure, the hand performs three double tap gestures in a second which is a quick hand movement and the fingers tap each other in this experiments.

The results of the fingers spread recognition is given in Fig. 9
                     . The worst recognition accuracy in the study among all the experiments is obtained for this hand gesture as 97.3%. The algorithm gives some misclassifications for finger spreads and the wave out couple as there are overlapping wrist contraction and flexion states for the two hand movements that the hand might visit involuntarily.

The hand wave out gesture recognition results are given in Fig. 10
                      without mapping the hand relax return gesture to the hand relax state. In all the figures, the mapped hand relax state is labeled as one. In the following figure the label six shows that the hand is moving toward to the hand relax position. The worst recognition accuracy out of four test experiments is 98.34% for 1274 labeling computation in the wave out experiment. The results for the CRC_RLS is given in Fig. 11
                     , in which the accuracy is less than 85%.

As the final experiment we give the results of an arbitrary gesture sequence. In this experiment, unlike the other experiments where the hand only performs two hand gestures, different gestures are performed arbitrarily (Fig. 12
                     ). The recognition accuracy is 98.47% for this experiment.

In this section, we discussed the simulation results of the SCRC method and compared with the conventional CRC. The labels are computed for each of the sampling time 200 computations for a second. Even with this resolution, the recognition accuracy competes with the proposed complex procedures in the literature with a higher number of hand gestures and postures. It is not necessary to compute the labels at a such high rates. As we implemented a real-time hand posture and gesture recognition application using the CRC method and Leap Motion sensor for steering a power wheelchair, 20Hz is sufficient for smooth, continuous and high accuracy recognition and steering.

In this study we introduced a novel application of the CRC methods in Fourier domain and elaborated the methodologies and experimental results for the hand gesture recognition using the EMG measurements on a forearm. The accuracy levels for the fairly rich gesture set is promising for the raw EMG signals; therefore, they can be further improved by analyzing the signal noise and introducing appropriate filtering methods. The use of Fourier features is explained intuitively using the circulant approach which reveals shift invariant features in an elegant way. The approach detailed in the training phase which we used for detecting braking maneuvers of a mobility robot first time [40] leads to a dictionary with a high power of discrimination. The embedding of the gesture boundaries into the representative states is implicitly realized by the subspace clustering methods.

The methods and procedures we detailed in this paper are a small portion of a project by which a multi-modal intuitive HCI have been developed for the elderly or severely handicapped people. The motivation of the project is to enable these people to steer a robotic wheelchair without excessive cognitive or physical efforts. On the other hand the developed systems will be employed for augmented and virtual reality environments to establish training theaters for people who are prescribed power wheelchairs first time.

@&#ACKNOWLEDGMENTS@&#

The study is supported by the Japan Society for the Promotion of Science (JSPS) fellowship program and the KAKENHI Grant (Grant Number 15F13739).

@&#REFERENCES@&#

