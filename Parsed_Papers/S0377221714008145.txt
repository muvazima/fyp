@&#MAIN-TITLE@&#A perturbation based variable neighborhood search heuristic for solving the Vehicle Routing Problem with Simultaneous Pickup and Delivery with Time Limit


@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           The Vehicle Routing Problem with Simultaneous Pickup and Delivery with Time Limit is presented and the literature is summarized.


                        
                        
                           
                           A mixed-integer linear programming formulation of the problem is proposed.


                        
                        
                           
                           Designed small sized test instances with time limit and no time limit are solved with the CPLEX solver.


                        
                        
                           
                           A perturbation based variable neighborhood search heuristic based on classic savings heuristic, variable neighborhood search, and perturbation mechanism is developed.


                        
                        
                           
                           A number of well-known benchmark problems with time limit and no time limit are solved and the solutions are compared.


                        
                        
                           
                           A perturbation based variable neighborhood search heuristic proposed new best and robust solutions for benchmark problem instances.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Vehicle routing with simultaneous pickup and delivery

Meta-heuristics

Perturbation based neighborhood search

@&#ABSTRACT@&#


               
               
                  The Vehicle Routing Problem with Simultaneous Pickup and Delivery with Time Limit (VRPSPDTL) is a variant of the basic Vehicle Routing Problem where the vehicles serve delivery as well as pick up operations of the clients under time limit restrictions. The VRPSPDTL determines a set of vehicle routes originating and terminating at a central depot such that the total travel distance is minimized. For this problem, we propose a mixed-integer mathematical optimization model and a perturbation based neighborhood search algorithm combined with the classic savings heuristic, variable neighborhood search and a perturbation mechanism. The numerical results show that the proposed method produces superior solutions for a number of well-known benchmark problems compared to those reported in the literature and reasonably good solutions for the remaining test problems.
               
            

@&#INTRODUCTION@&#

The Vehicle Routing Problem (VRP) is a combinatorial optimization problem seeking to service a set of clients from a central depot with a homogeneous fleet of capacitated vehicles. This problem aims to determine a set of vehicle routes originating and terminating at the central depot and visiting all clients such that the total travel distance is minimized. A variant of the VRP is the Vehicle Routing Problem with Backhauls (VRPB) where the vehicles dispatch goods (delivery) from the depot to linehaul clients and collect goods (pickup) from backhaul clients to the depot. The VRPB can be basically categorized into four classes (Parragh, Doerner, & Hartl, 2008):

                        
                           -
                           VRP with Clustered Backhauls (VRPCB): the vehicles first dispatch delivery goods to linehaul clients, then collect pickup goods from backhaul clients.

VRP Mixed linehauls and Backhauls (VRPMB): the vehicles serve delivery or pick up operations to linehaul or backhaul clients in any sequence.

VRP with Divisible Delivery and Pickup (VRPDDP): clients demanding both delivery and pickup operations could be visited separately.

VRP with Simultaneous Pickup and Delivery (VRPSPD): clients demanding both delivery and pickup operations have to be visited once.

For extended variants of Pickup and Delivery Problems (PDP) see Berbeglia, Cordeau, Gribkovskaia, and Laporte (2007) and Parragh et al. (2008) and for Location Routing Problems (LRP) see Prodhon and Prins (2014). In the literature, the VRPSPD was first proposed by Min (1989). In the VRPSPD, the current load of the vehicle has to be checked at each client to ensure that the vehicle capacity is not violated. This problem can be classified according to the notation proposed by Berbeglia et al. (2007). They use the 3-tuple notation [Structure|Visits|Vehicles] to describe the characteristics of a PDP. In this notation, structure represents the number of origins and destinations of goods, visits represents information on the way pickup and delivery operations are performed at clients, and vehicles represents the number of vehicles employed. The VRPSPD investigated in this paper can be characterized as [1-M-1|PD|m] where 1-M-1 indicates one-to-many-to-one problems, i.e. goods are initially available at the depot and are transported to clients, and goods available at the clients are transported to the depot; PD means each client being visited exactly once for a combined pickup and a delivery operation; m denotes the availability of more than one vehicle (multi-vehicle problem).

The VRPSPD can also be categorized into three classes as follows:

                        
                           -
                           VRPSPD with Maximum Distance Length (MLVRPSPD): a maximum voyage distance constraint for returning to the central depot is imposed for each of the vehicles.

VRPSPD with Time Windows (VRPSPDTW): the vehicles have to start their service at the clients' locations between a given earliest and latest time.

VRPSPD with Time Limit (VRPSPDTL): the vehicles have to return to the central depot before a time deadline is reached.

In this study, we consider the VRPSPDTL that additionally includes service times for the clients and a maximum total duration (travel 
+ 
service time) restriction for the vehicles as an extension of the VRPSPD.


                     Dethloff (2001) defined the VRPSPD as an NP-hard combinatorial optimization problem, meaning that practical large-scale problem instances are hard to solve by use of exact solution methodologies within acceptable computational times. In the VRPSPDTL the objective and constraints are the same as in the VRPSPD, except for the service time limit of vehicles for returning to the central depot. This makes the problem more complicated due to the difficulty in controlling the voyage duration of the vehicles in addition to the service time of the clients along the route. As a result, this problem can be described as NP-hard, as well. In the literature, the interest was therefore on the development of heuristic or meta-heuristic solution approaches.

Since 1989, many heuristic and meta-heuristic solution approaches for solving VRPSPD benchmark problems have been proposed. See Goksal, Karaoglan, and Altiparmak (2013), Subramanian, Drummond, Bentes, Ochi, and Farias (2010), Zachariadis, Tarantilis, and Kiranoudis (2009) and Zachariadis and Kiranoudis (2011) for recent studies on the VRPSPD, Montané and Galvão (2006) and Zhang, Tian, Zhang, and Liu (2008) for the MLVRPSPD and Liu, Xie, Augusto, and Rodriguez (2013) and Mingyong and Erbao (2010) for the VRPSPDTW. Furthermore, some authors consider the VRPSPD as a special case of the VRPDDP where vehicles are allowed to visit clients separately for delivery and pick-ups (Nagy, Wassan, Speranza, & Archetti, 2014). Although, Salhi and Nagy (1999) defined benchmark problem instances for the VRPSPD with “time limit”, since then most of the studies disregarded this case. A possible reason could be the increased complexity of the problem. So far just a few studies considered benchmark problems under time limit restrictions. Some authors proposed heuristic and meta-heuristic implementations for the VRPSPD as well as VRPSPDTL. These studies are as follows: Cluster Insertion Heuristics (CIH) by Salhi and Nagy (1999), Insertion Based Heuristics (IBH) by Dethloff (2001), Alternating Heuristic Algorithms (ALT) by Nagy and Salhi (2005), Large Neighborhood Search (LNS) by Ropke and Pisinger (2006), Tabu Search (TS) by Montané and Galvão (2006), Reactive Tabu Search (RTS) by Wassan
, Wassan, and Nagy (2008), Ant Colony System (ACS) by Gajpal and Abad (2009), Particle Swarm Optimization (PSO) by Ai and Kachitvichyanukul (2009), Savings Based Ant Algorithm (SBAA) by Catay (2010) and Nearest Sweep with Perturbation (NSP) by Jun and Kim (2012).


                     Subramanian and Cabral (2008) presented the first investigation that deals with the pure VRPSPDTL considering the CMT 6-7-8-9-10-13-14 X&Y benchmark problems of Salhi and Nagy (1999). The authors proposed an Iterated Local Search (ILS) procedure in order to solve this problem.

In this study, we propose a perturbation based neighborhood search (PVNS) approach for solving the VRPSPDTL. The remainder of this study is organized as follows. In Section 2, we present a model formulation for the problem at hand. Next, the solution procedure is developed in Section 3. Detailed numerical results are presented in Section 4. Finally, conclusions are drawn and suggestions for further research are given in Section 5.

The problem considered in this study is designing the network of service vehicles, e.g. simultaneously dispatching/collecting cargo parcels from a central post station to/from regional post stations via trucks, simultaneously dispatching/collecting containers from a hub port to/from feeder ports via containerships, simultaneously dispatching/collecting passengers from a continental center airport to/from national airports via airplanes, etc. In this context, the VRPSPDTL can be stated as follows: A set of clients is located on a distribution network where clients require both delivery and pickup operations. Each client has to be served once for both operations with a given fleet of identical capacitated vehicles. Each vehicle leaves the central depot carrying the total amount of goods that it has to deliver and returns to the depot carrying the total amount of goods that it must pick-up. Each client also has a specified service time which is the loading and unloading operation time of the vehicle at the client. Therefore, the voyage time of a vehicle is the sum of total travel time of the route and total service time of the clients. In order to determine the vehicle schedules and the staffing balance, each vehicle has to finish its voyage before the maximum allowed duration is reached.
                  

A mixed-integer linear programming (MILP) formulation for the VRPSPDTL is proposed with the following notation by extending the VRPSPD formulation of Montané and Galvão (2006):


                     
                        Indices


                        
                           i, j ∈ N
                        
                        
                           
                              
the set of nodes (clients and depot (0))


                              
the set of vehicles

maximum allowed voyage duration of vehicles


                              
maximum loading capacity of a vehicle

average travel speed of a vehicle

number of nodes, i.e., n = |N|


                              
distance between nodes i and j
                           

service time at client i
                           

delivery goods demand of client i
                           

pick-up goods demand of client i
                           

1, if the arc (i,j) belongs to the route served by vehicle k; 0, otherwise

pick-up goods transported on arc (i,j)

delivery goods transported on arc (i,j)

sub-cycle elimination variable used for client i
                           

The model formulation is given as follows.

                        
                           (1)
                           
                              
                                 min
                                 
                                    ∑
                                    
                                       k
                                       ∈
                                       K
                                    
                                 
                                 
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          N
                                       
                                    
                                    
                                       
                                          ∑
                                          
                                             i
                                             ∈
                                             N
                                          
                                       
                                       
                                          
                                             c
                                             
                                                i
                                                j
                                             
                                          
                                          
                                             x
                                             
                                                i
                                                j
                                             
                                             k
                                          
                                       
                                    
                                 
                              
                           
                        
                     s.t.

                        
                           (2)
                           
                              
                                 
                                    ∑
                                    
                                       i
                                       ∈
                                       N
                                    
                                 
                                 
                                    
                                       ∑
                                       
                                          k
                                          ∈
                                          K
                                       
                                    
                                    
                                       
                                          x
                                          
                                             i
                                             j
                                          
                                          k
                                       
                                       =
                                       1
                                       
                                       ∀
                                       j
                                       ∈
                                       N
                                       /
                                       
                                          {
                                          0
                                          }
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (3)
                           
                              
                                 
                                    ∑
                                    
                                       i
                                       ∈
                                       N
                                    
                                 
                                 
                                    x
                                    
                                       i
                                       j
                                    
                                    k
                                 
                                 −
                                 
                                    ∑
                                    
                                       i
                                       ∈
                                       N
                                    
                                 
                                 
                                    x
                                    
                                       j
                                       i
                                    
                                    k
                                 
                                 =
                                 0
                                 
                                 ∀
                                 j
                                 ∈
                                 N
                                 ,
                                 k
                                 ∈
                                 K
                              
                           
                        
                     
                     
                        
                           (4)
                           
                              
                                 
                                    ∑
                                    
                                       j
                                       ∈
                                       N
                                       /
                                       {
                                       0
                                       }
                                    
                                 
                                 
                                    x
                                    
                                       0
                                       j
                                    
                                    k
                                 
                                 ≤
                                 1
                                 
                                 ∀
                                 k
                                 ∈
                                 K
                              
                           
                        
                     
                     
                        
                           (5)
                           
                              
                                 
                                    ∑
                                    
                                       i
                                       ∈
                                       N
                                       /
                                       {
                                       0
                                       }
                                    
                                 
                                 
                                    x
                                    
                                       i
                                       0
                                    
                                    k
                                 
                                 ≤
                                 1
                                 
                                 ∀
                                 k
                                 ∈
                                 K
                              
                           
                        
                     
                     
                        
                           (6)
                           
                              
                                 
                                    ∑
                                    
                                       i
                                       ∈
                                       N
                                    
                                 
                                 
                                    y
                                    
                                       j
                                       i
                                    
                                 
                                 −
                                 
                                    ∑
                                    
                                       i
                                       ∈
                                       N
                                    
                                 
                                 
                                    y
                                    
                                       i
                                       j
                                    
                                 
                                 =
                                 
                                    p
                                    j
                                 
                                 
                                 ∀
                                 j
                                 ∈
                                 N
                                 /
                                 
                                    {
                                    0
                                    }
                                 
                              
                           
                        
                     
                     
                        
                           (7)
                           
                              
                                 
                                    ∑
                                    
                                       i
                                       ∈
                                       N
                                    
                                 
                                 
                                    z
                                    
                                       i
                                       j
                                    
                                 
                                 −
                                 
                                    ∑
                                    
                                       i
                                       ∈
                                       N
                                    
                                 
                                 
                                    z
                                    
                                       j
                                       i
                                    
                                 
                                 =
                                 
                                    d
                                    j
                                 
                                 
                                 ∀
                                 j
                                 ∈
                                 N
                                 /
                                 
                                    {
                                    0
                                    }
                                 
                              
                           
                        
                     
                     
                        
                           (8)
                           
                              
                                 
                                    y
                                    
                                       i
                                       j
                                    
                                 
                                 +
                                 
                                    z
                                    
                                       i
                                       j
                                    
                                 
                                 ≤
                                 Q
                                 
                                    ∑
                                    
                                       k
                                       ∈
                                       K
                                    
                                 
                                 
                                    x
                                    
                                       i
                                       j
                                    
                                    k
                                 
                                 
                                 ∀
                                 i
                                 ,
                                 j
                                 ∈
                                 N
                              
                           
                        
                     
                     
                        
                           (9)
                           
                              
                                 
                                    ∑
                                    
                                       i
                                       ∈
                                       N
                                    
                                 
                                 
                                    
                                       ∑
                                       
                                          j
                                          ∈
                                          N
                                       
                                    
                                    
                                       
                                          c
                                          
                                             i
                                             j
                                          
                                       
                                       v
                                    
                                 
                                 
                                    x
                                    
                                       i
                                       j
                                    
                                    k
                                 
                                 +
                                 
                                    ∑
                                    
                                       i
                                       ∈
                                       N
                                       /
                                       {
                                       0
                                       }
                                    
                                 
                                 
                                    
                                       ∑
                                       
                                          j
                                          ∈
                                          N
                                       
                                    
                                    
                                       
                                          s
                                          i
                                       
                                       
                                          x
                                          
                                             i
                                             j
                                          
                                          k
                                       
                                    
                                 
                                 ≤
                                 R
                                 
                                 ∀
                                 k
                                 ∈
                                 K
                              
                           
                        
                     
                     
                        
                           (10)
                           
                              
                                 
                                    π
                                    i
                                 
                                 ≥
                                 
                                    π
                                    j
                                 
                                 +
                                 1
                                 −
                                 n
                                 
                                    (
                                    
                                       1
                                       −
                                       
                                          ∑
                                          
                                             k
                                             ∈
                                             K
                                          
                                       
                                       
                                          x
                                          
                                             i
                                             j
                                          
                                          k
                                       
                                    
                                    )
                                 
                                 
                                 ∀
                                 i
                                 ,
                                 j
                                 ∈
                                 N
                                 ,
                                 
                                 i
                                 ≠
                                 j
                              
                           
                        
                     
                     
                        
                           (11)
                           
                              
                                 
                                    x
                                    
                                       i
                                       j
                                    
                                    k
                                 
                                 ∈
                                 
                                    {
                                    
                                       0
                                       ,
                                       1
                                    
                                    }
                                 
                                 ,
                                 
                                 
                                    y
                                    
                                       i
                                       j
                                    
                                 
                                 ≥
                                 0
                                 ,
                                 
                                 
                                    z
                                    
                                       i
                                       j
                                    
                                 
                                 ≥
                                 0
                                 ,
                                 
                                 
                                    π
                                    i
                                 
                                 ≥
                                 0
                                 
                                 ∀
                                 i
                                 ,
                                 j
                                 ∈
                                 N
                                 ,
                                 k
                                 ∈
                                 K
                              
                           
                        
                     
                  

The objective function (1) aims to minimize the total travelled distance. Constraints (2) ensure that each client is served by exactly one vehicle while Eq. (3) guarantees that the same vehicle arrives at and departs from each client. Constraints (4) and (5) ensure that at most K vehicles are used. Eqs. (6) and (7) satisfy the pick-up and delivery demand of the clients, respectively. Constraints (8) are the vehicle capacity constraints and constraints (9) represent the maximum voyage duration limit. Constraints (10) are introduced to eliminate illegal sub-cycles. Finally, constraints (11) define the variable domains. In short, these constraints ensure that each vehicle departs from the central depot with a load equivalent to the total delivery goods and each vehicle arrives at the central depot with a load equivalent to the total pick-up goods from clients on the route served by that vehicle.

As mentioned in Sections 1 and 2, exact solution approaches for solving VRPSPDTL problems are not practical for large-scale instances. In this study, we therefore propose a heuristic approach based on a perturbation based neighborhood search (PVNS) algorithm. The structure of the heuristic is given in Fig. 1 in pseudo-code.

The algorithm starts with a Savings Algorithm (SA) in order to obtain a fast and effective initial solution (see Section 3.1). A variable neighborhood search (VNS) algorithm is applied to improve the initial solution over several generations (see Section 3.2). The respective neighborhood structures are explained in Section 3.3. Finally, a perturbation mechanism (PM) is introduced to escape from local optima (see Section 3.4).

The initial solution is constructed by use of the savings algorithm of Clarke and Wright (1964) considering route time limits and vehicle capacity. This well-known heuristic aims at merging sub-tours based on cost savings which can be achieved by combining two sub-tours into a composite tour to be served by the same vehicle. In literature, some enhancements of the classic Clarke and Wright savings algorithm have been suggested by adding new terms and parameterizing the savings formula. In this study, since the VRPSPDTL is a generalization of the VRP, we construct the initial solution according to the savings formula proposed by Altınel and Öncan (2005) for solving the VRP. The savings formula is given in Eq. (12) where c
                        
                           i0 is the distance from customer i to the depot, c
                        0j
                         the distance from the depot to customer j, cij
                         the distance between customers i and j, di
                         and dj
                         are the demand of customer i and j, respectively, and 
                           
                              d
                              ¯
                           
                         is the average demand.

                           
                              (12)
                              
                                 
                                    
                                       S
                                       
                                          i
                                          j
                                       
                                    
                                    =
                                    
                                       c
                                       
                                          i
                                          0
                                       
                                    
                                    +
                                    
                                       c
                                       
                                          0
                                          j
                                       
                                    
                                    −
                                    λ
                                    
                                       c
                                       
                                          i
                                          j
                                       
                                    
                                    +
                                    μ
                                    
                                       |
                                       
                                          
                                             c
                                             
                                                0
                                                i
                                             
                                          
                                          −
                                          
                                             c
                                             
                                                j
                                                0
                                             
                                          
                                       
                                       |
                                    
                                    +
                                    ν
                                    
                                       
                                          
                                             d
                                             i
                                          
                                          +
                                          
                                             d
                                             j
                                          
                                       
                                       
                                          d
                                          ¯
                                       
                                    
                                 
                              
                           
                        
                     

Here the first positive parameter λ aims to redesign the routes in order to find better solutions. The second positive parameter μ may exploit the asymmetry of information between customers i and j regarding their distances to the depot. The third positive parameter ν gives an assignment priority to customers with larger demands (Doyuran & Çatay, 2011). Since this savings function is designed for the VRP, we assume d'
                           i
                         as the maximum value of delivery (di
                        ) and pick-up (pi
                        ) of customer i (d'
                           i
                         = max(di, pi
                        )) in the VRPSPDTL. Thus, by simultaneously considering route time limits and vehicle capacity in the savings methodology, the problem is converted from VRPSPDTL to the vehicle routing problem with time limit (VRPTL). Therefore, feasibility of the routes created by the savings methodology can easily be checked and ensured in each step by comparing the sum of the d'
                           i
                         values of the route and the total route duration. Note that a feasible solution to the VRPTL by using d'
                           i
                         also provides a feasible solution to the VRPSPDTL.

After an initial solution is constructed using the savings heuristics for the VRPTL, this solution is evaluated with an improvement algorithm according to the VRPSPDTL. For this purpose a general variable neighborhood search (VNS) approach proposed by Mladenović and Hansen (1997) and (2010) is used. VNS employs the idea of systematically changing the neighborhoods in order to improve the current solution and aims to further explore the solution space, which may not be explored by a simple local search technique (Hansen et al., 2010). Hemmelmayr, Doerner, and Hartl (2009), Kytöjoki, Nuortio, Bräysy, and Gendreau (2007), Polat, Günther, and Kulak (2014) and Stenger, Vigo, Enz, and Schwind (2013) showed the effectiveness of VNS for VRP applications.


                        Shaking, local search and move or not operators are used in the implementation of the VNS. The shaking operator decides the search direction of the VNS from a set of neighborhoods. After a set of preliminary experiments, we observed that the probability of escaping from local optima increases when the shaking operator is integrated with local search rather than using a single shaking operator. Therefore, each solution obtained by the shaking operator is further evaluated with the local search operator in order to explore new promising neighborhoods of the current solution. In this study, we implemented the Variable Neighborhood Descent (VND) algorithm as the local search operator. If we exclude the randomness in VNS, then the VND is achieved. While this variant of VNS can be used in its original form individually, VND is also useful as a local search within a VNS. The VND algorithm aims to combine the set of neighborhoods (m-max) in a deterministic order expecting that using more than one neighborhood structure results in better solutions. At the end of the VND algorithm, if there is an improvement, then the shaking operations start from the first operation. Otherwise, shaking continues with the next operation. After reaching the maximum number of shaking operations (k-max), the search procedure continues with the first operation in the new iteration.

In this study, a number of intra-route and inter-route structures are employed in a deterministic order for shaking and local search operators (Fig. 2
                        ). In our methodology, both VNS and VND use four intra-route [3-opt, swap, insertion, 2-opt] and four inter-route neighborhood structures [Exchange (m,n), Cross, Shift (0,1), Replace (1,1)]. When the algorithm is in the shaking step, it randomly selects two sub-tours, and then, if the next VNS operator is an inter-route operator, the operator is applied to these sub-tours randomly. On the other hand, if the next operator is an intra-route operator, the operator is applied to both sub tours randomly. In the VND step of the algorithm, these two sub tours taken from the shaking step are deterministically searched by all of the eight operators. At the end of the VND step, the best local result obtained from the VND is compared with the best global result.

Contrary to the classical VRP, if supply intensive clients are in the first sequences and demand intensive clients are in the latter sequences, a route could be infeasible even if its departure and arrival loads are feasible in the VRPSPD. However, reversing the same route could result in a feasible solution. Therefore, load feasibility of incumbent routes is checked in two steps. In the first step, both departure and arrival loads of the vehicles are checked. If they are feasible, in the next step departure loads of vehicles for all clients on the route are also checked for both directions. In order to avoid redundant moves, only moves within violation acceptance limits are allowed to be considered in the shaking operator. The total route duration violation acceptance limit (α
                        1) is used to allow clients to join another route for possible further improvements. Also the vehicle capacity violation acceptance limit (α
                        2) is used as the maximum of all pick-up and delivery loads. The violation limit allows an infeasible solution to enter the VND step, meaning that an infeasible solution may result in a feasible and good candidate after applying local search structures. However, just one of the routes is allowed to use this violation acceptance limit and the travel duration of this route is penalized with a huge penalty cost in order to increase the improvement probability of routes. In the local search phase, only feasible moves are allowed, i.e. those which do not violate the vehicle capacity and the time limit. For instance, when an inter-route operator applied to two routes provides an infeasible but effective solution in the shaking step, an additional operator applied to one of these infeasible routes could, in combination with another feasible route from the network, create two feasible and effective routes in the local search step.

In the calculation of the fitness value, we first check the total delivery (starting) and total pick up (returning) load. If any of these loads exceeds the capacity, the route is directly classified as an infeasible solution. On the other hand, if the total starting or retuning load falls below the violation limit but exceeds the capacity, then this route is penalized with a very high penalty value. If the total starting or retuning load falls below the capacity, then we further check the load of the vehicle at each client step-by-step on the route. If there is a violation of any client departure time, then the route is again penalized. Similarly, we also check arrival times for each client (including the depot). If there is no violation, the route becomes feasible and the fitness value is calculated as the total travel distance. On the other hand, after the shaking step, if an infeasible solution that enters the local search step is still infeasible after applying various local search operations, at the end of the local search step the best solution will not change since the temporary solution will not be able to get rid of its penalty value.

The 3-opt, swap, insertion and the 2-opt are intra-route neighborhood structures defined according to an initial configuration. Fig. 2 illustrates the different neighborhood structures. The initial configuration used to explain these operations is shown in Fig. 2
a.

                           
                              •
                              The 3-opt operation, which was introduced by Lin (1965), tries all shifts of some sub-sequence to different positions in the same route. In this particular example, three edges are deleted and replaced by three other edges. In Fig. 2a the links [1,2] (connecting customers 1 and 2), [3,4] and [5,6] were deleted from route 1 and the links [1,4], [5,2] and [3,6] were inserted (Fig. 2b).


                                 Swap is a random permutation movement of two customers in the same route. In Fig. 2c the order of customers 2 and 5 in the route were swapped (Fig. 2c.)

The insertion operation selects a customer randomly and inserts it at a random position in the same route. In the example of Fig. 2d customer 3 was selected and inserted at the 6th position of the route.

The 2-opt heuristic looks for improvements by swapping pairs of links (Croes, 1958). In Fig. 2e links [1,2] and [4,5] were deleted and links [1,4] and [2,5] were inserted.


                        Exchange (m,n), Cross, Shift (0,1) and Replace (1,1) represent inter-route improvement operations, i.e. they consider different routes within the network. An example of an initial configuration is given in Fig. 2
f.

                           
                              •
                              The exchange (m, n) structure is developed according to Osman (1993). In the example of Fig. 2g m sequential customers from one route (route 1) are transferred to another route (route 2) and in turn n sequential customers from route 2 are transferred to route 1. In this study, m is randomly selected between 1 and 5, and n is randomly selected equal to m or m − 1.


                                 Cross exchange is a basic crossover structure between routes. In this structure, the link [2,3] from route 1 and the link [7,8] from route 2 are removed. To complete the routes, links [2,8] and [7,3] are inserted (see Fig. 2h).


                                 Shift (0,1) is a random transposition movement of a customer from one route to another. In Fig. 2i customer 2 from route 1 is transferred to route 2.


                                 Replace (1,1) is a random permutation movement between two customers from different routes. In Fig. 2j customer 1 from route 1 is permutated with customer 7 from route 2.

In all inter-route neighborhood structures, the route pairs are selected according to the roulette wheel technique in order to eliminate the number of infeasible exchange operations. In this selection, the center of gravity coordinates of each route are calculated. After one route is randomly selected, the distances between the center of this route and the center of other routes are determined. All distances between the selected route and the remaining routes are scaled by a 1/distance0.5 factor in order to give sufficient exchange opportunity to distant routes. Another route is selected among these routes according to the principles of the roulette wheel method.

The temporary solution obtained via the shaking and local search operators is compared with the current solution in order to decide whether to move or not. In the proposed VNS and VND, the acceptance criterion of the temporary solution is only to accept a solution if there is an improvement. However, this procedure may cause the search to get stuck in a local optimum. Therefore, it is necessary to employ a strategy of accepting non-improving solutions. Perturbation is an effective strategy used to jump out of a local optimum and to search a new promising region. A commonly used perturbation strategy is to deconstruct the previous local optimum partially in a random way as in Subramanian et al. (2010). Another strategy is the destroy-and-repair based perturbation mechanism as in Jun and Kim (2012).

The previously obtained local optimum solution combines global and local statistical information of good individual solutions. In this study, the current solution is, therefore, used to develop a perturbation method called perturbation mechanism (PM). This perturbation mechanism runs after a number of non-improving iterations counted starting from the last improving solution (see Fig. 3
                         for details of the algorithm). In the PM, a set of perturbation structures [double replace, double cross, triple shift, triple replace, and triple cross] is randomly run whenever the perturbation is called. In addition to the perturbation move, a local optimization method with the previously defined four intra-route neighborhood structures is applied to improve the perturbed solution quality. The solution quality of the perturbed solution is significant, since a perturbation move that satisfies the vehicle capacity and total route duration limit is always accepted. Moreover, violating moves are accepted by the shaking operator. The developed perturbation structures for the PM are defined as follows.

                           
                              •
                              
                                 Double Replace is a combination of two times sequential Replace (1,1) movements to the same routes which are selected by the roulette wheel method. A random client from route 1 is permutated with a random client from route 2; next, another random client from route 1 is permutated with a client from route 2. After intra-local search is applied to both route1 and route 2, the total vehicle duration and vehicle loading capacity are checked according to the acceptance limits.


                                 Double Cross applies the Cross exchange. Otherwise, it is similar to the Double Replace structure.


                                 Triple Shift is a newly developed fast and effective perturbation movement to jump out from local optima. A route (route 1) is randomly selected, and two another routes (routes 2 and 3) are selected by using the defined roulette wheel method. Next, similar to the Shift (0,1) movement, a random client from route 2 is transferred to route 1, and a client from route 1 is transferred to route 3. Similar to double structures, vehicle duration and capacity are checked according to the acceptance limit after intra-local search is applied to routes.


                                 Triple Replace is similar to Triple Shift by using the Replace (1,1) movement.


                                 Triple Cross is similar to Triple Shift by using the Cross exchange structure.

As local optimization, a set of intra-neighborhood structures [3-opt, Swap, Insertion, 2-opt] are repeated z-max times in a deterministic order. If no acceptable solution is generated after z-max attempts in a perturbation structure, the algorithm then tries another perturbation structure.

@&#IMPLEMENTATION@&#

The model formulation proposed in Section 2 has been implemented by use of the IBM ILOG CPLEX Optimization Studio 12.5 solver. The PVNS approach presented in the previous section has been coded and implemented using Matlab R2009a and Visual C++ 2010. All numerical experiments were run on an Intel Core-2-Duo T5750 2.0 gigahertz
 processor with 3 gigabytes RAM.

First of all, the performance of the proposed heuristic approach is compared against the CPLEX solver for small problem instances in which client numbers vary between 10 and 40. Once a basic problem data set consisting of 40 clients is created, the remaining small instances (30, 20, 15, 10) are derived from this first problem instance. Each of these instances has two versions according to the location distribution of the clients: randomly distributed (R) and randomly distributed in clusters (C). All of these ten instances may cover at most 10 homogenous vehicles whose capacity is 250 units. The average speed of the vehicles is 1 kilometer per minute
 and they should return to the depot after 300 minutes due to operational regulations. Table A.1 in the Appendix A shows related demand, supply, service duration, and location information of clients. Ten problem instances are solved for both service time limit and no time limit versions. Each instance was allowed a maximum of 43,200 seconds of CPU time (12 hours) using the CPLEX solver. Table 1
                        
                         shows the results of both the CPLEX solver and the proposed PVNS approach in detail.

According to results of Table 1, for small sized problems (with 10 clients), both methods were able to reach optimal solutions. However, CPLEX could solve the no-time limit version of the problem to optimality in 21.39 seconds while it required 8366.13 seconds to solve the time limit version to optimality for randomly distributed client locations. Similarly, for the clustered locations version, CPLEX could solve the no-time limit version of the problem to optimality in 16.93 seconds while it required 4440.58 seconds to solve the time limit version to optimality. Moreover, CPLEX was able to generate solutions for small sized problems (up to 20 clients) within the preset time limit of 43,200 seconds (12 hours) under the system specifications stated above. For larger sized problems with 30 and 40 clients CPLEX did not provide feasible solutions within the predefined solution time limit. On the other hand, the PVNS approach yielded optimal solutions for the 10-client instances with and without time limit in just a few hundredths of seconds. For the 15 and 20-client instances solutions obtained by PVNS within a few seconds of CPU time were superior to the best CPLEX solutions found within the CPU time limit of 12 hours. Finally, the PVNS approach showed its efficiency in solving the remaining large sized problem instances by generating solutions within less than a minute of CPU time.

Next, the performance of the proposed PVNS approach and the CPLEX solver are compared using small-sized VRPSPD benchmark instances of Nagy et al. (2014) who generated these instances by modifying VRP instances of Christofides and Eilon (1969), namely CE22, CE23, CE30 and CE33. In this study, we generated additional instances by imposing a time limit (see Table 2). Note that in order to evaluate the effect of the route time limit, no service time is considered in these benchmark instances. The instances with and without time limit were solved by using both the CPLEX solver and the proposed PVNS approach. Results shown in Table 2 reveal that CPLEX was able to generate feasible solutions for all no time limit instances within the predefined solution time limit of 12 hours. For the time limit instances, CPLEX yielded feasible solutions for the CE22 and CE23 instances, but not for the other instances. On the other hand, the PVNS approach achieved equally good or better solutions than CPLEX in very short computation time. However, the optimality of these solutions is not proven as no exact optima are known from the literature. The results of Table 2 also show that time limits do affect both the total travel distance and the number of vehicles.

As a general result, it can be concluded that the only way to solve problem instances of realistic size is to use heuristic or meta-heuristic solution procedures since exact solution methodologies are prohibitive especially for problems with time limit.

Next, pre-tests on the determination of the appropriate parameter values to be used in the meta-heuristic approach were performed. The savings-based heuristic presented in Section 3.1 contains three parameters whose values were varied in the intervals λ ∈ [0, 5], μ ∈ [0, 3] and ν ∈ [0, 2], respectively, with an increment of 0.1. In the pre-tests it was observed that there is a high interrelation between these savings parameters and other parameters like vehicle capacity, total duration and service time of the VRPSPDTL. As a result, the following settings were chosen which provide the most promising initial solutions to general subsets of VRPSPDTL: λ = 3.5, μ = 1.6 and ν = 1.0.

A second pre-test was conducted in order to determine the most effective sequence of the shaking operators in the VNS algorithm. The results showed the effectiveness of the following sequence: N
                        1: 3-opt, N
                        2: Swap, N
                        3: Insertion, N
                        4: 2-opt, N
                        5: Exchange (m,n), N
                        6: Cross, N
                        7: Shift (0,1), N
                        8: Replace (1,1). The same sequence is used in the local search (VND) part of the VNS algorithm. Therefore, k-max and m-max parameters of the VNS algorithm were set to 8 in the experiments. The total route duration violation acceptance limit is determined as α
                        1 
= 
3 and the vehicle capacity violation acceptance limit is as α
                        2 
= 
1.2.

In addition, the proposed PVNS has two major parameters that affect the quality of solutions. These are the PM perturbation counter (p-max) and the PVNS termination counter (s-max). In the proposed PVNS approach, the perturbation mechanism is executed after p-max iterations counted from the last accepted move. The PVNS algorithm is terminated after s-max iterations counted from the last accepted move. To determine optimal parameter values, an experimental study was conducted using the CMT6X benchmark problem instance of Salhi and Nagy (1999) with service time. Results are summarized in Table 3
                        .


                        Table 3 highlights the importance of perturbation mechanisms to reach near optimal solutions. As can be seen from the sensitivity analysis, less perturbation calls work faster but approach the best known solution more slowly and the solutions are less robust over 10 replications. On the other hand, settings with too many perturbation calls work a bit slower but approach the best known more quickly. However, solutions are less robust, as well. Settings with a balanced number of calls work slower than other options, approach the best known more quickly too, and the solutions are more robust. Hence, the optimal parameter combination for p-max and s-max is 50 (1 × 50) and 25,000 (500 × 50). Fig. 4
                         shows the improvement of the solution with the iteration counter and the improvement of the solution with the improvement counter for the best solution to the CMT13X problem instance with service time. Fig. 4 also shows how perturbation mechanisms improve the solution during the iterations by escaping from local optima.

The positive effect of the neighborhood structures are shown in Table 4
                        . Entries indicate the number of effective (positive) improvements of the various neighborhood structures in the shaking and local search phases. After a set of preliminary experiments, the best combinations of shaking and local search neighborhood structures are found to be N
                        1 and N
                        4 and N
                        1 and N
                        5. While intra-route structures are more effective in early stages, the inter-route structures are more effective in later stages of the proposed PVNS. Indeed, the combinations of shaking and local search with intra-route structures are more effective in the early stages of the proposed PVNS. However, although the combinations with inter-route structures show a less quantitative effect, they play a critical role on route structures. In conclusion, while double perturbation structures are effective in early stages, the triple perturbation structures are more effective in later stages of the solution process.

In addition, a sensitivity analysis is carried out for selected problem parameters (time limit and vehicle capacity) in order to evaluate how these two parameters affect the route length. The tests are run using the CMT6X instance by varying the vehicle capacity between 70 and 190 and the time limit between 120 and 320 (see Table 5
                        ). Results show that for the considered problem instance the time limit has a stronger impact on the total travel time than the vehicle capacity. For a vehicle capacity of 70 units, a time limit of more than 160 has no effect on the total travel distance as the vehicle capacity becomes a bottleneck. In contrast, at a vehicle capacity of 130 and more the time limit becomes the limiting factor. It should be noted that increasing the time limit to a sufficiently high number converts the problem into a VRPSPD. On the other hand, at a given time limit the vehicle capacity is a limiting factor only for capacities of 70 and 100 units. Note that increasing the vehicle capacity makes simultaneous pick-up and delivery ineffective and converts the problem into an un-capacitated VRPTL. As expected, simultaneously increasing the vehicle capacity and the time limit decreases the total travel distance and the problem transforms to un-capacitated VRP.

In real applications the vehicle capacity constitutes a hard constraint that cannot be violated whereas the time limit could possibly be considered as a soft constraint. For instance, in the transport of perishable foods, keeping the delivery time limits is essential, while in maritime transportation where shipping and port operations are highly influenced by weather conditions time limits could be regarded as flexible. In such cases, penalties for violating time limits can be introduced. The value of the penalties depends on how important it is in the specific application to keep the given deadlines. Therefore, in an extended model formulation penalties are included in the fitness function. Accordingly, Eqs. (1) and (9) from the VRPSPDTL formulation must be replaced by Eqs. (13) and (14), where α represents the penalty value and 
                           
                              b
                              j
                              
                                 k
                                 +
                              
                           
                         and 
                           
                              b
                              j
                              
                                 k
                                 −
                              
                           
                         indicate the delay and earliness of vehicle k in reaching client j, respectively. Eq. (15) defines the additional variable domains.

                           
                              (13)
                              
                                 
                                    min
                                    
                                       ∑
                                       
                                          k
                                          ∈
                                          K
                                       
                                    
                                    
                                       
                                          ∑
                                          
                                             i
                                             ∈
                                             N
                                          
                                       
                                       
                                          
                                             ∑
                                             
                                                j
                                                ∈
                                                N
                                             
                                          
                                          
                                             
                                                c
                                                
                                                   i
                                                   j
                                                
                                             
                                             
                                                x
                                                
                                                   i
                                                   j
                                                
                                                k
                                             
                                          
                                       
                                    
                                    +
                                    α
                                    
                                       ∑
                                       
                                          k
                                          ∈
                                          K
                                       
                                    
                                    
                                       
                                          ∑
                                          
                                             i
                                             ∈
                                             N
                                          
                                       
                                       
                                          b
                                          i
                                          
                                             k
                                             +
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (14)
                              
                                 
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          N
                                       
                                    
                                    
                                       
                                          ∑
                                          
                                             j
                                             ∈
                                             N
                                          
                                       
                                       
                                          
                                             c
                                             
                                                i
                                                j
                                             
                                          
                                          v
                                       
                                    
                                    
                                       x
                                       
                                          i
                                          j
                                       
                                       k
                                    
                                    +
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          N
                                          ∖
                                          {
                                          0
                                          }
                                       
                                    
                                    
                                       
                                          ∑
                                          
                                             j
                                             ∈
                                             N
                                          
                                       
                                       
                                          
                                             s
                                             i
                                          
                                          
                                             x
                                             
                                                i
                                                j
                                             
                                             k
                                          
                                       
                                    
                                    +
                                    
                                       b
                                       j
                                       
                                          k
                                          −
                                       
                                    
                                    −
                                    
                                       b
                                       j
                                       
                                          k
                                          +
                                       
                                    
                                    =
                                    R
                                    
                                    ∀
                                    j
                                    ∈
                                    N
                                    ,
                                    
                                    k
                                    ∈
                                    K
                                 
                              
                           
                        
                        
                           
                              (15)
                              
                                 
                                    
                                       b
                                       i
                                       
                                          k
                                          −
                                       
                                    
                                    ≥
                                    0
                                    ,
                                    
                                    
                                    
                                       b
                                       i
                                       
                                          k
                                          +
                                       
                                    
                                    ≥
                                    0
                                    
                                    ∀
                                    i
                                    ∈
                                    N
                                    ,
                                    
                                    k
                                    ∈
                                    K
                                 
                              
                           
                        
                     

For the case of soft time limit constraints another sensitivity analysis is conducted in order to evaluate the effect of the penalty value α. Results are summarized in Table 6. As expected, both the fitness value of the solution and the total travel distance increase with the penalty value while the total delay approaches zero if the penalty value is sufficiently high. Increasing the penalty value to 500 percent and more, time limits are treated like hard constraints. On the other hand, in the case of no penalty the problem is converted into a VRPSDP. As for the number of vehicles, there is an increase from three to six depending on the penalty value.

The performance of the proposed PVNS is tested using the benchmark problem set CMT for the VRPSPDTL from Salhi and Nagy (1999) based on Christofides, Mingozzi, and Toth (1979). This problem set includes 14 problem instances in which client numbers vary between 50 and 199. Salhi and Nagy (1999) modified the original VRP benchmark problem instances of Christofides et al. (1979) by splitting the original demand between pickup and delivery loads, imposing a maximum time limit for the vehicles, and setting a predefined service time according to Eilon, Watson-Gandy, and Christofides (1971).

In all VRPSPDTL benchmark instances of Salhi and Nagy (1999), service time for all clients are considered the same. In the corresponding literature, Ai and Kachitvichyanukul (2009), Catay (2010), Dethloff (2001), Gajpal and Abad (2009), Jun and Kim (2012), Nagy and Salhi (2005), Ropke and Pisinger (2006), and Salhi and Nagy (1999) solved these instances by including service time. Montané and Galvão (2006) determined solutions by excluding service time and Subramanian and Cabral (2008) and Wassan et al. (2008) considered both situations.

The proposed PVNS heuristic is first compared in Table 7
                         with reference solutions known from the literature for benchmark problem instances with service time, namely CIH by Salhi and Nagy (1999), IBH by Dethloff (2001), ALT by Nagy and Salhi (2005), LNS by Ropke and Pisinger (2006), RTS by Wassan et al. (2008), ILS by Subramanian and Cabral (2008), ACS by Gajpal and Abad (2009), PSO by Ai and Kachitvichyanukul (2009), SBAA by Catay (2010), and NSP by Jun and Kim (2012) for benchmark problem instances with service time of Salhi and Nagy (1999).

In the fifth column of Table 7, references which achieved the so far best known solutions are shown. The proposed PVNS algorithm was run ten times with the same seed sets for each parameter combination. Best and average solutions as well as computational times for the PVNS are given in the right part of Table 7. Overall best solutions of each problem instance are highlighted in bold. Comparing PVNS with the reference solutions from literature it can be seen that PVNS reaches the best known solution for 8 out of 14 problem instances. For three of the instances, namely CMT 9X, 9Y and 10Y, the PVNS approach was able to generate new best solutions. For the remaining three instances, the gap between the results of the PVNS and the best-known solution is around 0.1 percent
.

Secondly, the proposed PVNS is compared with studies excluding service time. Comparisons with the best solutions of TS by Montané and Galvão (2006), RTS by Wassan et al. (2008) and ILS by Subramanian and Cabral (2008) are given in Table 8
                        . Again overall best solutions are highlighted in bold. Results show that for five out of 14 problem instances without service time the PVNS approach was able to generate new best solutions, namely for instances CMT8Y, 13X, 13Y, 9X and 9Y. In addition, PVNS reproduces the best-known solutions for two instances. For the remaining seven instances, the average gap between the results of the PVNS and the best-known solutions is 0.74 percent. On average over 14 problem instances, PVNS performs 0.32 percent
 better than the best counterparts from literature.

In Table 9
                        
                        
                        , computational results have been rearranged in order to compare the various heuristics against each other. Results for problem instances with and without service time are shown in the left and the right part of Table 9, respectively. From the comparison of the individual heuristics the following conclusions can be drawn. PVNS shows the best average solution (1033.73) for problem instances with service time compared to 10 benchmark heuristics. For problem instances without service time PVNS provided superior average solutions (746.70) compared to the three benchmark heuristics known from the literature. Moreover, PVNS shows the smallest gap when compared with the average of best known solutions for the range of problem instances with/without service time over all solution approaches.

Generally, it is difficult to compare CPU times since different approaches are tested on different computers. In order to make a fair comparison of execution times, the computers which are used in the various studies are compared with the help of the Passmark Performance Test 7.0 software. Since there are many factors that affect CPU times, approximate equivalent computers are used in the benchmark test (see Table A.2 in Appendix A). The average computational time for the PVNS approach is around 360 seconds for the benchmark problem instances of Salhi and Nagy (1999). Compared with the CPU times estimated for the benchmark heuristics the scaled average solution time of PVNS is definitely higher but still in a range which is tolerable in practical applications. Despite the effectiveness of the repetitive perturbation mechanism, it took fairly more computation time (more than 80 percent) within PVNS approach. We note here that for several of the published solution approaches computational times are not provided. Concerning sensitivity, PVNS is favorable since it provides the lowest mean of average solutions for all instances.

The general conclusion that can be drawn from Tables 7–9 is that the PVNS algorithm produces adequate solutions in reasonable time for the benchmark problems of Salhi and Nagy (1999). Details for the achieved best solutions for CMT10Y with service time and CMT13Y without service time are given in Tables A.3 and A.4 in Appendix A.

In addition, the proposed PVNS is compared to the studies without time limit in order to show the effectiveness for the VRPSPD (see Table 10). Note that, assuming the service time at clients as zero and setting the maximum route limit to a sufficiently high value turns the VRPSPDTL into the VRPSPD. For Salhi and Nagy's (1999) without time limit instances we compared the results of PVNS with the best known solutions in the literature. From the results presented in Table 10 it can be concluded that the proposed PVNS approach is also able to provide effective solutions on the CMT set of instances with no time limit by reaching best known solutions for 10 of 14 problem instances. Furthermore, the gap for the remaining instances is under 0.26 percent. In comparison to individual heuristics from literature, the proposed PVNS approach yields superior solutions on average except for the PILS heuristic, whose difference to PVNS is less than 0.02 percent.
                     

Finally, the performance of the proposed PVNS heuristic is tested using the large sized VRP benchmark problem instances of Christofides and Eilon (1969). For this purpose the VRP instances are converted to VRPSPD instances as suggested by Nagy et al. (2014). Then these instances are converted to VRPSPDTL instances by imposing a time limit (see Table 11). Contrary to the CMT instances of Salhi and Nagy (1999), these instances contain no service time. We also set the vehicle speed to 1 which makes the total duration equal to the total travel distance since service time at clients is set to 0. Results obtained by the PVNS heuristic for instances with and without time limit are given in Table 11. The results highlight the effect of the time limit on the total travel distance. As can be seen the results presented in Tables 10 and 11 show that the PVNS approach provides effective results for problem instances with and without time limit.

@&#CONCLUSIONS@&#

In this study, we proposed a heuristic search method called perturbation based neighborhood search (PVNS) algorithm based on the savings algorithm, variable neighborhood search and the perturbation mechanism to solve the Vehicle Routing Problem
 with simultaneous pick-up and delivery with time limit (VRPSPDTL). Eight local neighborhood search structures were used as shaking and local search operators of the PVNS algorithm. A Variable Neighborhood Descent
 procedure was used to perform the local search. Five different perturbation structures were applied in order to escape from local optima. The numerical results show that the proposed PVNS algorithm generated efficient and high-quality solutions compared to the existing solution methods for the VRPSPDTL. For 19 out of the 28 benchmark instances with and without service time from Salhi and Nagy (1999), the PVNS algorithm was able to obtain new best solutions or reached to best known solutions. Furthermore, since the VRPSPDTL turns into the VRPSPD when the time limit is considered to be infinite, the VRPSPD instances of Salhi and Nagy (1999) are also solved by the proposed approach with competitive results compared to those provided in the literature. New additional VRPSPDTL benchmark instances are also introduced by extending the VRPSPD instances of Nagy et al. (2014) and solved by the proposed approach. Sensitivity analyses are carried out for determining the effect of time limit and vehicle capacity. The proposed PVNS algorithm is specifically designed to cover the total vehicle time limit, which is not included in the existing pure VRPSPD solution methods with its sub-procedures as part of the construction heuristic, the improvement algorithm and perturbation mechanism. As a future research direction, the proposed PVNS algorithm can be adapted to consider heterogeneous fleet conditions, divisible demands and the dynamic environment of the VRPSPDTL.

@&#ACKNOWLEDGMENTS@&#

This research is partially funded by the German Academic Exchange Service (DAAD) with the grant number A/08/77565 and the Scientific Research Projects Unit of Pamukkale University (PAUBAP) under the project number 2013BSP022. The authors wish to acknowledge this valuable support. The authors are also grateful to the anonymous reviewers whose constructive comments have led to improve the quality of this study.


                     Table A.1–Table A.4
                     
                     
                     
                  

@&#REFERENCES@&#

