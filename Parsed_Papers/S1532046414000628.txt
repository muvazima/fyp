@&#MAIN-TITLE@&#An ensemble heterogeneous classification methodology for discovering health-related knowledge in social media messages

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Propose 5 heterogeneous features for identifying health messages in social media.


                        
                        
                           
                           Propose ensemble methods that allow base classifiers to make collective decisions.


                        
                        
                           
                           Validate the proposed methods based on empirical evaluations.


                        
                        
                           
                           Generalize the proposed methodology across multiple social media domains.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Social media

Machine learning

Classification

@&#ABSTRACT@&#


               
               
                  Objectives
                  The role of social media as a source of timely and massive information has become more apparent since the era of Web 2.0.Multiple studies illustrated the use of information in social media to discover biomedical and health-related knowledge.Most methods proposed in the literature employ traditional document classification techniques that represent a document as a bag of words.These techniques work well when documents are rich in text and conform to standard English; however, they are not optimal for social media data where sparsity and noise are norms.This paper aims to address the limitations posed by the traditional bag-of-word based methods and propose to use heterogeneous features in combination with ensemble machine learning techniques to discover health-related information, which could prove to be useful to multiple biomedical applications, especially those needing to discover health-related knowledge in large scale social media data.Furthermore, the proposed methodology could be generalized to discover different types of information in various kinds of textual data.
               
               
                  Methodology
                  Social media data is characterized by an abundance of short social-oriented messages that do not conform to standard languages, both grammatically and syntactically.The problem of discovering health-related knowledge in social media data streams is then transformed into a text classification problem, where a text is identified as positive if it is health-related and negative otherwise.We first identify the limitations of the traditional methods which train machines with N-gram word features, then propose to overcome such limitations by utilizing the collaboration of machine learning based classifiers, each of which is trained to learn a semantically different aspect of the data.The parameter analysis for tuning each classifier is also reported.
               
               
                  Data sets
                  Three data sets are used in this research.The first data set comprises of approximately 5000 hand-labeled tweets, and is used for cross validation of the classification models in the small scale experiment, and for training the classifiers in the real-world large scale experiment.The second data set is a random sample of real-world Twitter data in the US.The third data set is a random sample of real-world Facebook Timeline posts.
               
               
                  Evaluations
                  Two sets of evaluations are conducted to investigate the proposed model’s ability to discover health-related information in the social media domain: small scale and large scale evaluations.The small scale evaluation employs 10-fold cross validation on the labeled data, and aims to tune parameters of the proposed models, and to compare with the stage-of-the-art method.The large scale evaluation tests the trained classification models on the native, real-world data sets, and is needed to verify the ability of the proposed model to handle the massive heterogeneity in real-world social media.
               
               
                  Findings
                  The small scale experiment reveals that the proposed method is able to mitigate the limitations in the well established techniques existing in the literature, resulting in performance improvement of 18.61% (F-measure).The large scale experiment further reveals that the baseline fails to perform well on larger data with higher degrees of heterogeneity, while the proposed method is able to yield reasonably good performance and outperform the baseline by 46.62% (F-Measure) on average.
               
            

@&#INTRODUCTION@&#

Social media such as Twitter and Facebook are increasingly being used as tools for real-time knowledge discovery relating to social events, emerging threats, epidemics, and even product trends [1,2]. For example, real time analysis of Twitter users’ tweet content can be or is being used to detect earthquakes and provide warnings [3], to identify needs (e.g., medical emergencies, food and water shortages) during recovery from natural disasters such as the Haiti Earthquake [4], track emergence of specific syndromic characteristics of influenza-like illness [5], and collect epidemic-related tweets [6].

The role of social media in biomedical domain has become significant in recent years [7–13]. Researchers and physicians have utilized social media data to (1) communicate and share information between patients and health care decision makers, (2) develop large scale, dynamic disease surveillance systems and (3) mining biomedical and health-related information.

An immediate and direct use of social media in the biomedical domain is a means for patients and professionals to communicate and exchange information. Web 2.0 along with ubiquitous mobile computing devices allows individuals to dynamically and seamlessly interact with each other in real time, regardless of their locations. PatientsLikeMe
                        1
                        
                           http://www.patientslikeme.com/.
                     
                     
                        1
                      is a social network for patients that improves lives and a real-time research platform that advances medicine. On PatientsLikeMe’s network, patients connect with others who have the same disease or condition, allowing them to track and share their own experiences. Eijk et al. illustrated the use of Online Health Communities (OHCs) for ParkinsonNet,
                        2
                        
                           http://www.parkinsonnet.info/.
                     
                     
                        2
                      a social network for Parkinson disease patients whose participants (both patients and professionals) use various types of OHCs to deliver patient-centered care [14]. Merolli et al. explored different ways that chronic disease sufferers engage in social media in order to better tailor these online interventions to individually support patients in specific groups [9]. Additionally, Twitter, Facebook, and other social blogging services provide conduits for patients and medical practitioners to collaborate, exchange, and disseminate information through official broadcasting channels/webpages or discussion groups [12,10,13,11,15].

Most popular social media providers such as Twitter and Facebook allow their posts to be geo-located. These properties provide researchers in the healthcare community the ability to monitor the medical related emergences. Culotta proposed a methodology to study the predictability of Twitter data on future influenza rates [16]. A correlation of 95% was observed between the tweets containing the flu keywords and the actual national health statistics. A similar study was conducted by Corley et al. who found a high correlation between the frequency of the tweets (weekly) containing influenza keywords and the CDC
                        3
                        
                           http://www.cdc.gov/flu/.
                     
                     
                        3
                      influenza-like-illness surveillance data [17]. Bodnar et al. compared different regression-based models for disease detection using Twitter, and discovered that the SVM regression model gave the best correlation with the actual CDC disease report [18]. Heaivilin et al. introduced Twitter as a potential source for dental surveillance and research [19]. The findings suggest that people who experience dental pain usually turn to social network to seek comfort and advice from others who also suffer from dental pain. In all such applications, systems are needed to automatically, accurately, and efficiently identify and interpret health-related content in short text “micro” messages.

Even though social media is high in noise due to the heterogeneity of the writing styles, formality, and creativity, such noise also bears undiscovered wisdom of the crowd, and hence should not be regarded as a threat, but an opportunity for discovering knowledge that can be useful in biomedical domains. Indeed literature illustrates rich research in mining biomedical and health related knowledge in social media. Paul and Dredze utilized a modified Latent Dirichlet Allocation [20] model to identify 15 ailments along with descriptions and symptoms in Twitter data [21,22]. Cameron et al. proposed a web platform PREDOSE (PREscription Drug abuse Online Surveillance and Epidemiology), which aims to facilitate research in prescription-related drug abuse practices using social media [23]. Greene et al. studied the quality of communication of the content in Facebook communities dedicated to diabetes. They classified each Facebook post into one of the 5 categories: Advertisements, Providing Information, Requesting Information, Support, and Irrelevant, and found that roughly two third of the information is about sharing diabetes management strategies [15]. Yang et al. proposed a method utilizing association mining and Proportional Reporting Ratios to discover the relationship between drugs and averse reactions from the user contributed content in social media [24].

This paper presents a novel machine learning based methodology that combines multi-aspect learners to make collective decisions in order to discover health-related information in the heterogeneous pool of social media. Such a system could prove useful to multiple biomedical research and applications aiming to employ the power of large-scale, realtime social media. Social media posts/comments are usually represented as short textual expressions. We formulate the problem as a text classification problem, where the objective is to correctly classify health-related content, given a large, dynamic stream of data. A message is said to be health-related if at least one of these two following conditions is met:
                        
                           •
                           The message indicates its author has health issues; e.g. Fever, back pain, headache…ugh!
                           

The message talks about someone else getting sick, or expresses health concern; e.g. I completely understand, more than anyone! Try a warm bath too. That always helped me w/ Pauly. & drinking water.
                           

The health-related content-identification problem is transformed into the health-related short text classification, where a system is given a short text message and asked to determine whether it is health-related or not. Studies [25–27] show that traditional text classification approaches which represent a document as a “bag of words” are not well suited for processing short texts, as they do not provide sufficient word co-occurrence or shared semantics for effective similarity measures. Specifically, traditional techniques such as N-gram feature extraction limit the ability to recognize high-discriminative terms that include health-related keywords and/or obtain meaning from the topical semantics of the entire text. We propose and test the efficacy of ensemble methods wherein multiple base classifiers that learn different aspects of the data are used together to make collective decisions in order to enhance performance of health-related message classification.

In an effort to mitigate the limitations of existing health-related text mining methodologies, this work:
                        
                           1.
                           Proposes to use 5 heterogeneous feature types which represent different aspects of semantics for identification of health-related messages in social media. Parameter sensitivity is studied to find the best parameter configuration and base classifier for each feature type.

Explores the use of different ensemble methods that allow base classifiers trained with different feature types to make collective decisions.

Validates the proposed classification algorithms using empirical evaluation. Additionally, we strengthen the reasons for choosing the proposed features by showing how each feature type impacts the classification.

Evaluates the proposed classification algorithms on large scale, real world datasets, and shows that our proposed solutions do not only perform well on real-world data, but also generalize across multiple domains of social media with minimum assumption on the specific social media characteristics.

The rest of the paper is organized as follows. Section 2 provides background of the related works. Section 3 explains the characteristics of the dataset we use in our experiments. Section 4 discusses our proposed methods, including feature extraction along with analysis on parameter sensitivity and ensemble techniques in detail. Section 5 describes the evaluation of our proposed methods against the baseline on both small labeled data and large scale datasets. Section 6 concludes the paper.

@&#RELATED WORKS@&#

The literature on text classification is extensive, hence we only discuss works closely related to ours.

Two approaches have been widely used to identify health-related content: keyword based and learning based methods. The former requires a dictionary containing the relevant words. A message is identified as relevant if it contains one or more keywords. Ginsberg et al. demonstrated that a regression model of influenza-like illness can be estimated using the proportion of flu-related Google search queries over the same period. They classified the query logs by detecting the presence of flu-related keywords [28]. Their method was implemented in Google Flu Trends,
                           4
                           
                              http://www.google.org/flutrends.
                        
                        
                           4
                         a Google based service providing almost real-time estimates of flu activity for a number of countries around the world. Culotta claimed that Twitter data yielded better prediction on the actual flu rates than query logs, and proposed a methodology to correlate the quantity of flu-related tweets, identified by flu-related keyword detection, with the actual influenza-like-illness rates [29]. Corley et al. did a similar study on web blogs [17]. They identified flu-related blog posts using keywords influenza and flu. Yang et al. proposed to use association mining and the Proportional Reporting Ratios the mine relationship between drugs and their averse reactions in social media, which basically employ the co-occurrence frequency of the drug names and averse reactions [24]. They identified content containing the averse drug reactions by detecting the presence of the health-care keywords generated by applying Consumer Health Vocabulary (CHV) [30]. The keyword matching based approaches are simple to implement and do not consume much computing resources; however, such approaches do not only fail to capture keywords unknown to the dictionary, they also fail to deal with polysemy words.

Other widely used approaches transform identification problems into classification problems and utilize machine learning based classifiers to classify the data into classes. Traditional machine learning based approaches for text classification first trains a learner with a collection of labeled documents, then uses the trained learner to classify unlabeled documents. Learning based approaches solve the term disambiguation problems posed by the keyword matching approaches as they are able to learn some level of semantics of specific words from the surrounding contexts in which they appear. Collier and Doan proposed an algorithm for detecting disease-related tweets [5]. Specifically, the algorithm categorizes a tweet into musculoskeletal, respiratory, gastrointestinal, hemorrhagic, dermatological, or neurological related ailment. Their algorithm first (1) filters tweets that contain syndromic keywords defined in the BioCaster public health ontology [31], and then (2) classifies the filtered messages into one of the six predefined ailments using binary uni-grams as features. Their problem is similar to ours, except that they aim to identify tweets corresponding to specific ailments; while we address a broader range of messages related to health issues. For example, ‘having a slight headache.’ would not fall into any ailment categories in their proposed methodology as the message only describes a general symptom (i.e. headache). In our work, we aim to capture such messages as well since a large collective knowledge of small-signal messages could reveal significant insights into the emerging trends [2]. Aramaki et al. proposed to use a Support Vector Machine based classifier to detect flu-related tweets [32]. The machine is trained with unigrams collected within the same proximity of the flu-related keywords. Paul and Dredze address the same problem as ours and propose a machine learning based classification algorithm used for identifying health-related tweets [21]. Uni-gram, bi-gram, and tri-gram binary word features are used to train a linear kernel SVM classifier. They further use the collected tweets to mine public health information using a LDA-like technique [22]. The parameters of the classifier are then tuned to obtain 90.04% precision and 32.0% recall, since classifiers with higher precision are preferred in their task which is to collect high quality health-related tweets. Besides using traditional binary N-gram features to train the classifier, which we point out later not to be sufficient and accurate enough for social media settings, their classification model was built and tuned on a small dataset of roughly 5 thousands Twitter messages. Our large scale experiments (see Section 5.7) reveal that their method does not adopt very well when being used on real-world, highly diversified data. Even though literature showed that N-gram features are sufficient for text classification tasks, such features fall short when dealing with document in social media domain.

The major differences between a short message or “microtext”, and a traditional document includes the length and the formality of language. Classification algorithms that work for traditional documents may not succeed in the microtext domain due to the lower dimension and higher noise characterizing the data. This subsection explores literature on short text classification in addition to Section 2.1. Sriram et al. point out the limitation of bag-of-word strategies for tweet classification, and propose 8F features, which primarily capture the information about authors and reply-to users [33]. While authorship is proved to be a potential source of information, our dataset (see Section 3) does not have such information available. Caragea et al. propose the system EMERSE for classifying and aggregating tweets and text messages about the Haiti earthquake disaster [4]. They train a SVM classifier with the combination of 4 feature sets: uni-grams, uni-grams with Relief feature selection [34], abstractions 
                        [35], and topic words generated by LDA [20]. Since the first 2 feature sets are N-gram based, they encounter similar limitations as our baseline. The other two feature sets are based on groups of terms, and would partially solve the disambiguation problem, but not the keyword recognition problem.

3 Datasets are used in the experiments: a small Twitter dataset (TwitterA), a large Twitter dataset (TwitterB), and a large Facebook dataset. TwitterA is a labeled, almost balanced dataset and is mainly used to experiment and tuning the configurations of the classifiers. The other large datasets have natural distribution of the health-related messages, and are used to test the ability to generalize to real world, large scale data of the proposed methods.

For consistency and scientific comparison, we use the same dataset as [21] which consists of 5,128 manually labeled tweets. This dataset is used for the small scale experiments employing the 10-fold cross validation protocol, and for training classifiers for the large scale experiments. Since we want to minimize the assumption about the properties of social text, all hashtags, retweets and user information are removed and only textual content is kept. Future steps of our research involve expanding the data sources to include other kinds of social media (such as Facebook, Google+, blogs, etc.), which may not have hashtags and other Twitter-like features, thus we focus on common features (such as textual information and timestamps) to develop a generic algorithm. Each tweet is a tuple of tweet ID and its textual content, and is labeled as either positive or negative. A message is positive if it is health related, and negative otherwise. The dataset contains 1832 (35.73%) positive and 3296 (64.27%) negative instances.

We note that although the size of the dataset may not completely capture the noise and lexical diversity presented in social media, the hundreds of millions tweets generated each day constrain the viability of established ground truth data of substantial proportion. Examining the literature, comparable or smaller sizes of manually labeled tweets are often used to validate the models proposed in many reputable and high-impact works such as [3,33,36,37]. Moreover, the dataset has much higher distribution of positive samples than real-world data (i.e. 35.73% vs. 1.34% in real-world Twitter data, see Section 3.2). This would allow the classifiers to learn more information about the positive class, which is of interest here.

The TwitterB dataset comprises roughly 700 million public tweets in the United States during the period of 18months from April 2011 to September 2012. These tweets were collected at random, hence representing a pseudo-uniform distribution of the overall tweets without biases to any topics. Only the tweet ID, time stamp, and textual information of each tweet are extracted. The extracted information is stored in compressed text files, yielding the total size of 25GB. A random sample of 10,000 tweets from this dataset was manually labeled by 5 graduate students. We found 134 (1.34%) health-related messages. Unlike the TwitterA dataset, the TwitterB dataset has a natural distribution of health-related messages and is used for the large scale experiment (Section 5.7).

The Facebook dataset comprises 1,348,800 Timeline statuses and 3,541,772 associated comments of 113 participant Facebook users and their friends (a total of 60,776 Facebook users). Each participant user was asked for permission to collect their and their friends’ Timeline posts. All identification was removed prior to storage. All the Facebook data will be destroyed upon acceptable progress of our research. Each Timeline status message and comment is treated as an individual message, from which the ID, timestamp, and textual information are extracted, for consistency with the other datasets. The final Facebook data contains roughly 5 millions messages, yielding 155MB of size. A random sample of 10,000 messages was manually labeled by 5 graduate students, which reveals 107 (1.07%) health-related messages. Similar to the TwitterB dataset, this dataset is used for the large scale experiment (Section 5.7).

@&#METHODOLOGY@&#

Even though Twitter and Facebook data is used to verify our model, the expansion into diverse types of social media such as web blogs and Google+ provides a broader foundation for public health surveillance. The need to accommodate heterogeneous types of data means that it is important for us to design a method that easily generalizes across data sources with different properties.

We propose to combine 5 heterogeneous base classifiers, selected from different families of classification algorithms and shown to be state-of-the-art for text classification, each of which is trained with a different feature type explained in Section 4.2. For each feature type, 5 base classifiers listed in Section 4.1 are tried using 10-fold cross validation with different feature extraction parameter configurations. The base classifier and parameter configuration that yield the highest F-measure is chosen for ensemble experiments outlined in Section 4.3. Table 1
                      lists the abbreviations used in this paper for quick reference.

On each feature type, we employ 5 classification algorithms drawn from different classification families namely:


                        Random Forest (RF) 
                        [38] is a tree-based ensemble classifier consisting of many decision trees. Random Forest is known for its resilient embedded feature selection algorithm, allowing it to feasibly learn from high-dimensional data such as text data. We use 100 trees for each RF classifier as suggested by [39].


                        Support Vector Machine (SVM) 
                        [40] is a function based classifier built upon the concept of decision planes that define decision boundaries. In our experiment we use the linear kernel SVM with C
                        =1.0. SVM has long been known for superior performance in text classification with word features [41].


                        Repeated Incremental Pruning to Produce Error Reduction (RIPPER) 
                        [42] is a rule-based classifier which implements a propositional rule learner. For each RIPPER classifier, we set the number of folds to 3, and the minimum weight of instances to 2.0.


                        Bernoulli NaiveBayes (NB) 
                        [43] is a simple probabilistic classifier implementing Bayes’ theorem. NaiveBayes has been shown to perform superior in some text classification tasks such as spam filtering [44].


                        Multinomial NaiveBayes (MNB) 
                        [45] implements the Naive Bayes algorithm for multinomially distributed data, and is one of the two classic Naive Bayes variants used in text classification (where the data is typically represented as word vector counts). McCallum and Nigamcite [46] found Multinomial NaiveBayes to perform better than simple NaiveBayes, especially at larger vocabulary sizes.

We use LibSVM
                           5
                           
                              http://www.csie.ntu.edu.tw/cjlin/libsvm/.
                        
                        
                           5
                         implementation for SVM, and Weka
                           6
                           
                              http://www.cs.waikato.ac.nz/ml/weka/
                           
                        
                        
                           6
                         implementation for the other classifiers.

This section discusses the extraction of the 5 feature sets representing different views of the dataset.


                           N-gram features have been used extensively in text classification to learn word patterns in the training data. Let a document d be an ordered set of terms. An N-gram is a sequence of contiguous N terms in d. Here we represent a document with a union of its uni- to N-grams. Three different weighting schemes are explored: Binary, Frequency, and TF-IDF. Let S be the set of training documents, 
                              
                                 V
                                 =
                                 〈
                                 
                                    
                                       v
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    
                                       v
                                    
                                    
                                       M
                                    
                                 
                                 〉
                              
                            be the vocabulary extracted from 
                              
                                 S
                                 ,
                                 t
                              
                            be the test document, and 
                              
                                 F
                                 (
                                 t
                                 )
                                 =
                                 〈
                                 
                                    
                                       f
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    
                                       f
                                    
                                    
                                       M
                                    
                                 
                                 〉
                              
                            be the feature vector of the test document t. We define the weighting schemes as follows:
                              
                                 
                                    
                                       
                                          
                                          
                                             
                                                
                                                   
                                                      f
                                                   
                                                   
                                                      i
                                                   
                                                   
                                                      bin
                                                   
                                                
                                                =
                                                
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  1
                                                               
                                                               
                                                                  if
                                                                  
                                                                  
                                                                     
                                                                        v
                                                                     
                                                                     
                                                                        i
                                                                     
                                                                  
                                                                  ∈
                                                                  t
                                                                  
                                                                  and
                                                                  
                                                                  
                                                                     
                                                                        v
                                                                     
                                                                     
                                                                        i
                                                                     
                                                                  
                                                                  ∈
                                                                  V
                                                               
                                                            
                                                            
                                                               
                                                                  0
                                                               
                                                               
                                                                  otherwise
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                          
                                             
                                                
                                                   
                                                      f
                                                   
                                                   
                                                      i
                                                   
                                                   
                                                      freq
                                                   
                                                
                                                =
                                                TF
                                                (
                                                
                                                   
                                                      v
                                                   
                                                   
                                                      i
                                                   
                                                
                                                ,
                                                t
                                                )
                                             
                                          
                                       
                                       
                                          
                                          
                                             
                                                
                                                   
                                                      f
                                                   
                                                   
                                                      i
                                                   
                                                   
                                                      tfidf
                                                   
                                                
                                                =
                                                
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     
                                                                        TF
                                                                        (
                                                                        
                                                                           
                                                                              v
                                                                           
                                                                           
                                                                              i
                                                                           
                                                                        
                                                                        ,
                                                                        t
                                                                        )
                                                                     
                                                                     
                                                                        Max
                                                                        (
                                                                        TF
                                                                        (
                                                                        w
                                                                        ,
                                                                        t
                                                                        )
                                                                        :
                                                                        w
                                                                        ∈
                                                                        t
                                                                        )
                                                                     
                                                                  
                                                                  ·
                                                                  log
                                                                  
                                                                     
                                                                        
                                                                           
                                                                              
                                                                                 S
                                                                              
                                                                           
                                                                        
                                                                     
                                                                     
                                                                        1
                                                                        +
                                                                        
                                                                           
                                                                              
                                                                                 s
                                                                                 ∈
                                                                                 S
                                                                                 :
                                                                                 
                                                                                    
                                                                                       v
                                                                                    
                                                                                    
                                                                                       i
                                                                                    
                                                                                 
                                                                                 ∈
                                                                                 s
                                                                              
                                                                           
                                                                        
                                                                     
                                                                  
                                                               
                                                               
                                                                  if
                                                                  
                                                                  
                                                                     
                                                                        v
                                                                     
                                                                     
                                                                        i
                                                                     
                                                                  
                                                                  ∈
                                                                  t
                                                               
                                                            
                                                            
                                                               
                                                                  0
                                                               
                                                               
                                                                  otherwise
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 TF
                                 (
                                 w
                                 ,
                                 d
                                 )
                              
                            is the number of occurrences of term w in document d. Since social media messages do not conform with standard English, we also study how data cleaning and stemming have effects on the performance. Table 2
                            lists all the configuration parameters and their possible values for the NG feature extraction. Note, the features used in the baseline method proposed by Paul and Dredze [21] uses the 
                              
                                 〈
                                 clean
                                 =
                                 F
                                 ,
                                 stem
                                 =
                                 F
                                 ,
                                 N
                                 =
                                 3
                                 ,
                                 W
                                 =
                                 binary
                                 〉
                              
                            configuration.

As mentioned in Section 2.1, two drawbacks of N-gram features are (1) words with multiple meanings are treated the same (Ex. cold can be used in both disease or temperature contexts) and (2) important keywords are treated as normal words (Ex. Xeroderma pigmentosum is a disease name, but may not be identified as a discriminative feature by N-gram approaches since it is a rare disease and appears in only a few documents). Figueiredo et al. [47] propose compound features (c-features) for text classification. A compound of C terms is a group of C terms that occur in the same document. A compound with 
                              
                                 C
                                 =
                                 2
                              
                            is a generalized definition of term co-occurrence. Like NG features, we represent a document with the union of uni- to N-grams.

Compound features address the disambiguation problem, since they can identify different sets of term used in different scenarios. However, such features would not be able to address the keyword recognition problem as they cannot interpret the meaning of each term. Another problem of using full compound features is that the feature set can grow very large once all possible compounds are enumerated.

To overcome these challenges, we propose a feature selection strategy for the compound feature extraction, which we call Dictionary-based compound features (DC). Our DC feature extraction algorithm first generates all possible compounds from a document. Next, a compound that contains at least one term defined in the dictionary is kept. In our experiment we use 3 vocabularies: disease, symptom, and anatomy. We obtain such vocabularies from the Gemina project.
                              7
                              
                                 http://gemina.igs.umaryland.edu.
                           
                           
                              7
                            The disease and symptom vocabularies contain human disease and symptom names respectively, and are used due to the fact that there is a high chance that authors of the messages use these terms to identify their own or others’ health conditions (i.e. ‘I think I’m havin an 
                           
                              
                                 asthma
                              
                            
                           attack….wtf am I tweeting?’ and ‘feeling better. still have a bit of a 
                           
                              
                                 headache
                              
                            
                           though.’). The anatomy vocabulary contains words used to name physical parts of a human body, and is used because the existence of body organ words may help disambiguating health-related terms (i.e. ‘i’ll throw pillows from my couch here…my 
                           
                              
                                 knees
                              
                            
                           are burning’. In this example, burning can mean either very hot or painful. The presence of the word knees may help identify that burning actually has the latter meaning.). Table 3
                            lists all the configuration parameters and their possible values.

The intuition behind topic modeling is that an author has a set of topics in mind when writing a document. A topic is defined as a distribution of terms. The author then chooses a set of terms from the topics to compose the document. With such assumption, the whole document can be represented using a mixture of different topics. Topic modeling has also been successfully used to reduce the dimension of a document (where the number of dimensions is equal to the number of topics). Topic modeling strategies have also been applied in a variety of applications such as citation recommendation [48], document annotation [49,50], and text classification [4,51,52]. We employ the Latent Dirichlet Allocation algorithm for modeling topics in our work. We briefly describe the algorithm here for quick reference.

In text mining, the Latent Dirichlet Allocation (LDA) [20] is a generative model that allows a document to be represented with a mixture of topics. Past literature such as [53–55,27] demonstrates successful usage of LDA to model topics from given corpora. The basic intuition of LDA for topic modeling is that an author has a set of topics in mind when writing a document. A topic is defined as a distribution of terms. The author then chooses a set of terms from the topics to compose the document. With such assumption, the whole document can be represented using a mixture of different topics. LDA serves as a means to trace back the topics in the author’s mind before the document is written. Mathematically, the LDA model is described as follows:
                                 
                                    (1)
                                    
                                       P
                                       
                                          
                                             
                                                
                                                   
                                                      w
                                                   
                                                   
                                                      i
                                                   
                                                
                                                |
                                                d
                                             
                                          
                                       
                                       =
                                       
                                          
                                             
                                                ∑
                                             
                                             
                                                j
                                                =
                                                1
                                             
                                             
                                                |
                                                Z
                                                |
                                             
                                          
                                       
                                       P
                                       
                                          
                                             
                                                
                                                   
                                                      w
                                                   
                                                   
                                                      i
                                                   
                                                
                                                |
                                                
                                                   
                                                      z
                                                   
                                                   
                                                      i
                                                   
                                                
                                                =
                                                j
                                             
                                          
                                       
                                       ·
                                       P
                                       (
                                       
                                          
                                             z
                                          
                                          
                                             i
                                          
                                       
                                       =
                                       j
                                       |
                                       d
                                       )
                                       .
                                    
                                 
                              
                              
                                 
                                    P
                                    (
                                    
                                       
                                          w
                                       
                                       
                                          i
                                       
                                    
                                    |
                                    d
                                    )
                                 
                               is the probability of term 
                                 
                                    
                                       
                                          w
                                       
                                       
                                          i
                                       
                                    
                                 
                               being in document d. 
                                 
                                    
                                       
                                          z
                                       
                                       
                                          i
                                       
                                    
                                 
                               is the latent (hidden) topic. 
                                 
                                    |
                                    Z
                                    |
                                 
                               is the number of all topics, which needs to be predetermined. 
                                 
                                    P
                                    (
                                    
                                       
                                          w
                                       
                                       
                                          i
                                       
                                    
                                    |
                                    
                                       
                                          z
                                       
                                       
                                          i
                                       
                                    
                                    =
                                    j
                                    )
                                 
                               is the probability of term 
                                 
                                    
                                       
                                          w
                                       
                                       
                                          i
                                       
                                    
                                 
                               being in topic j. 
                                 
                                    P
                                    (
                                    
                                       
                                          z
                                       
                                       
                                          i
                                       
                                    
                                    =
                                    j
                                    |
                                    d
                                    )
                                 
                               is the probability of picking a term from topic j in the document d.

Essentially, the aim of LDA model is to find 
                                 
                                    P
                                    (
                                    z
                                    |
                                    d
                                    )
                                 
                              , the topic distribution of document d, with each topic described by the distribution over all terms 
                                 
                                    P
                                    (
                                    w
                                    |
                                    z
                                    )
                                 
                              .

After the topics are modeled, we can assign a distribution of topics to a given document using a technique called inference 
                              [56]. A document then can be represented by a vector of numbers, each of which represents the probability of the document belonging to a topic:
                                 
                                    (2)
                                    
                                       Infer
                                       (
                                       d
                                       ,
                                       Z
                                       )
                                       =
                                       〈
                                       
                                          
                                             z
                                          
                                          
                                             1
                                          
                                       
                                       ,
                                       
                                          
                                             z
                                          
                                          
                                             2
                                          
                                       
                                       ,
                                       …
                                       ,
                                       
                                          
                                             z
                                          
                                          
                                             Q
                                          
                                       
                                       〉
                                       ;
                                       
                                       |
                                       Z
                                       |
                                       =
                                       Q
                                       ,
                                    
                                 
                              where Z is a set of topics, d is a document, and 
                                 
                                    
                                       
                                          z
                                       
                                       
                                          i
                                       
                                    
                                 
                               is a probability of the document d falling into topic i.

Here we use topic distribution to represent a document. Since a topic is represented by a group of weighted terms, one can think of a set of topics as a form of compound features, where the weighted terms in a topic represent the components in a compound, and hence we hypothesize that using topic distribution as features can address the term disambiguation problem. For example, the term cold may be the top terms in two topics; one is temperature-related, and the other sickness-related.

In our work, we model topics from the training documents using LDA algorithm implemented in MALLET,
                                 8
                                 
                                    http://mallet.cs.umass.edu/.
                              
                              
                                 8
                               a MAchine Learning for Language Toolkit, with 3000 maximum iterations and using Gibbs sampling. We obtain the topic distribution for each test document using the inference algorithm proposed by [56]. Table 4
                               lists all the configuration parameters for TD feature extraction.

Our proposed sentiment features can be divided into two groups: physical and emotional based. The physical based ST features quantify the explicit illness by measuring frequency of health related keywords in each document. We use the same sets of vocabularies as in Section 4.2.2 for health-related keywords. The emotional based features measure the level of positive and negative emotions in the message, using the SentiStrength algorithm proposed by Thelwall et al. [37]. Table 5
                            lists all the features.

Our physical based ST features also serve as a dimension reduction of the DC features (with 
                              
                                 C
                                 =
                                 1
                              
                           ). Hence, such features have the potential to address the keyword recognition problem as they capture the frequency of highly relevant keywords. We also aim to investigate whether emotional based ST features can be discriminative as social messages are contaminated with emotions. All the configuration parameters are listed in Table 6
                           .

Having a classifier that learns all the aspects of the data may be helpful when combined with other one-aspect classifiers. We create such an overall classifier by training a base classifier with combined features generated by merging all the four feature sets discussed above into a single feature set.

In this subsection, we explain the motivation for combining base classifiers and discuss the choices of ensemble methods.

We replicated the feature set used by Paul and Dredze [21] on the original dataset and 10-fold cross validated it with a SVM classifier, which yields precision of 76.68%, recall of 47.63%, and F-measure of 58.76% (we later use these classification results as a baseline). In post hoc examination we observed that many of the misclassifications had the following characteristics:
                              
                                 
                                    Keyword Recognition Problem. Messages containing highly discriminative health-related words such as swine, chill, and burn are classified as non-health related. E.g. yep he’s fine…was only a mild case of the 
                                    
                                       swine
                                    .


                                    Term Disambiguation Problem. Messages containing highly discriminative health-related words used in a non-health-related context are classified as health-related. E.g. This is 
                                    
                                       sick
                                    , it’s snowing again.: – It’s like i am living in Russia.
                                 

Additionally, we trained 4 classifiers based on DC, TD, ST, and DC–TD–ST (combined) feature sets (see Section 4.2), respectively, and examined the classification results. The magnitude of overlaps between the misses (false positives+false negatives) produced by the classifier trained with the baseline feature set and the hits (true positives+true negatives) produced by the DC (7.21%), TD (9.26%), ST (10.82%), DC–TD–ST (9.95%) based classifiers as seen in Table 7
                            suggests that the addition of these features may potentially increase overall performance of social media message classification.

The 5 base classifiers trained with different feature types are combined using standard ensemble methods listed below:
                              
                                 
                                    Majority Voting (VOTE) Each classifier outputs either a ‘yes’ or ‘no’. The final outcome is the majority vote of all the classifiers.


                                    Weighted Probability Averaging (WPA) Each classifier is given a weight, where the sum of all weights is 1. Each classifier outputs a probability estimate of the positive class. The final output is the weighted average of all the classifiers.


                                    Multi Staging (MS) Classifiers operate in order. If a classifier says ‘yes’, the final output is yes; otherwise the instance in passed to the next classifier to decide.


                                    Reverse Multi Staging (RevMS) Similar to the MS technique, except that an instance is passed to the next classifier if the prior classifier says ‘yes’.

For the VOTE, MS, and RevMS methods, each base classifier classifies an instance as positive if the probability estimate is equal to or greater than the probability cutoff, and negative otherwise. For the WPA method, an instance is classified as positive if the final probability estimate is equal to or greater than the probability cutoff, and negative otherwise. We use 10-fold cross validation to validate the classification performance. A validation set of 10% is held-out of each training fold for setting probability cutoff and selecting the weights for WPA based classifiers.

For each feature type, all the parameter configurations are 10-fold cross validated on the dataset TwitterA using the 5 different base classifiers listed in Section 4.1. The parameters and probability cutoff are tuned with the 10% validation data held-out of each training fold. In order to tune the probability cutoff, we scan through different cutoff values with an increment of 0.01, and choose the one that results in the best F1 when tested with the held-out data. Note that this operation can be cheaply carried out, since the probability score of each test instance is already pre-computed. The best combination of the parameter configuration and base classifier in terms of F-measure is chosen. Parameter sensitivity is also investigated. The performance of the best configuration of each feature type summarized in Table 8
                        .

SVM is chosen for the NG feature type with configuration 
                              
                                 〈
                                 clean
                                 =
                                 T
                                 ,
                                 stem
                                 =
                                 T
                                 ,
                                 N
                                 =
                                 2
                                 ,
                                 W
                                 =
                                 tfidf
                                 〉
                              
                           , with F-measure of 68.19%. To study the parameter sensitivity of the NG feature extraction, we investigate (1) the effects of document preprocessing and (2) how different weighting schemes affect the performance (F-measure) of the SVM classifier. Fig. 1
                            shows the results as a function of the maximum size of grams (N). Fig. 1(a) compares the performance of the feature sets with different clean and stem parameters. According to the results, cleaning and stemming the data lead to higher quality of the feature sets. Fig. 1(b) compares the results of NG feature extraction with different weighting schemes. It is clearly seen that features with TFIDF weight outperform the other weighting schemes.

A SVM classifier with the configuration 
                              
                                 〈
                                 stem
                                 =
                                 true
                                 ,
                                 vocab
                                 =
                                 all
                                 ,
                                 N
                                 =
                                 1
                                 ,
                                 C
                                 =
                                 2
                                 ,
                                 W
                                 =
                                 tfidf
                                 〉
                              
                            yields the best F-measure (56.47%). Fig. 2
                            shows the parameter sensitivity analysis (F-measure) as functions of the maximum size of grams (N) on the SVM classifier. Fig. 2(a) compares the performances when different vocabularies are used. It is evident that combining all the three vocabularies yields the best results. Note that the symptom vocabulary gives the best results among individual vocabulary sets, this is because a large number of sickness-related tweets only talk about symptoms (headache, stomachache, sore throat, etc.) without mentioning the causing disease names. Fig. 2(b) compares the results achieved with different weighting schemes. First point to note, the performances of all the weighting schemes decrease as N increases. This is because compounds with bigger grams tend to generate sparse and idiosyncratic features. Similar to the NG features, the TFIDF weighting scheme outperforms the others.

Our results show that the configuration 
                              
                                 〈
                                 clean
                                 =
                                 F
                                 ,
                                 Z
                                 =
                                 200
                                 〉
                              
                            with a Random Forest classifier yields the best F-measure (54.50%). As part of the parameter impact on the RF classifier, we vary the number of topics, and also model topics from both ‘cleaned’ and ‘uncleaned’ datasets. Fig. 3
                            shows that the optimum number of topics is 200. Too few topics may lead to broad topics, hence low discriminative power; whereas, too many topics can result in spurious, meaningless topics consisting of idiosyncratic word combinations. An unexpected research finding is that uncleaned data gives a better performance, contrasting with the analysis of the NG, DC, and ST features which agree that cleaning the data in the preprocess step helps remove noise and boost the performance.

A RIPPER classifier with the configuration 
                              
                                 〈
                                 stem
                                 =
                                 T
                                 ,
                                 N
                                 =
                                 2
                                 ,
                                 type
                                 =
                                 both
                                 〉
                              
                            yields the best F-measure (51.08%). Fig. 4
                            shows the results from varying type and stem parameters as a function of the maximum size of grams (N) when tested with a RIPPER classifier. From Fig. 4(a), it is interesting to see that the emotional-based features do not significantly help to increase the performance. This is because most Twitter users who tweet about their sicknesses do not always express negative feelings. Oftentimes, they make the messages sound humorous by adding positive emotions or use positive tones, e.g. GWS ya bang:P T Oh no I’m sick! Gotta use some rest:) LOL
                        

The combined features include all the previous 4 feature types generated with the chosen configurations mentioned earlier. The 5 base classifiers are tried and SVM is found to perform the best with F-measure of 68.47%.

We evaluate each ensemble method using 10-fold cross validation on the labeled dataset TwitterA, using standard precision, recall, and F-measure (F1) as the evaluation metrics [57]. Unlike existing approaches in the literature [21] in which the quality of the retrieved data is more important than the amount, we aim to apply our algorithm in disease surveillance situations where the ability to detect non-obvious health-related messages (e.g. “I’m not feeling good today, and prolly can’t go to class.”) is also important. Hence, we treat both precision and recall as having equal importance, and F-measure is used to mainly compare the results from each method.

The weight vectors used in the WPA method, the orderings of base classifiers used in the MS and RevMS methods, and the probability cutoff are tuned using 10% held-out data of the training set (the other 90% is used to train the base classifiers).

We compare our proposed methods with the baseline features used in related works trained with a SVM classifier tuned to achieve the best F-measure. Table 8 lists the results (in terms of precision, recall, F-measure, and F-measure improvement over the baseline) of each ensemble strategy, along with other base classifiers and the baseline classifier.

The best performance in terms of F-measure is yielded by the WPA ensemble method. This method gives some weight to all the base classifiers learning different aspects of the dataset. The MS method gives the best recall of 91.93%. The RevMS yields the best precision of 90.08%. Since we treat precision and recall as equal important, we conclude that the WPA ensemble method works best for our task. This might be because the WPA method allows all the base classifiers to make partial quantitative contribution to the final decision, hence allowing the different semantic aspects of the data to be effectively combined, as opposed to the other ensemble methods whose some base classifiers may be ignored. These results agree with a prior study of ensemble classification by Kittler et al. which found that the sum rule (which is a special case of the WPA with equal weights) outperformed other ensemble methods (i.e. multi-staging, product, maximum, median, and minimum rules) on the identity verification and the handwritten digit recognition tasks [58].

Two tests of statistical significance are performed to understand the statistical difference between each proposed method and the baseline: McNemar’s Chi-Square Test [59] and 5×2 CV Paired t Test [60]. These two tests are chosen due to the reported low type I error by Dietterich when used to compare two supervised classification learning models [60]. Here, the null hypothesis is that each proposed model is identical to the baseline model, which is rejected if the calculated p-value is smaller than the significance level 
                           
                              α
                              =
                              0.05
                           
                        .

To apply McNemar’s test [61], the data S from the dataset TwitterA is randomly divided into a training set R (90%) and the test set T (10%). The baseline and each of the proposed models are trained using the data from R, and tested on the data from T. For each proposed algorithm 
                              
                                 
                                    
                                       f
                                    
                                    
                                       A
                                    
                                 
                              
                           , the classified results are recorded in a contingency table against the baseline 
                              
                                 
                                    
                                       f
                                    
                                    
                                       B
                                    
                                 
                              
                           : 
                              
                                 
                                    
                                    
                                    
                                       
                                          Number of test instances misclassified by both 
                                                
                                                   
                                                      
                                                         f
                                                      
                                                      
                                                         A
                                                      
                                                   
                                                
                                              and 
                                                
                                                   
                                                      
                                                         f
                                                      
                                                      
                                                         B
                                                      
                                                   
                                                
                                              (
                                                
                                                   
                                                      
                                                         n
                                                      
                                                      
                                                         00
                                                      
                                                   
                                                
                                             )
                                          Number of test instances misclassified by 
                                                
                                                   
                                                      
                                                         f
                                                      
                                                      
                                                         A
                                                      
                                                   
                                                
                                             , but not 
                                                
                                                   
                                                      
                                                         f
                                                      
                                                      
                                                         B
                                                      
                                                   
                                                
                                              (
                                                
                                                   
                                                      
                                                         n
                                                      
                                                      
                                                         01
                                                      
                                                   
                                                
                                             )
                                       
                                    
                                    
                                       
                                          Number of test instances misclassified by 
                                                
                                                   
                                                      
                                                         f
                                                      
                                                      
                                                         B
                                                      
                                                   
                                                
                                             , but not 
                                                
                                                   
                                                      
                                                         f
                                                      
                                                      
                                                         A
                                                      
                                                   
                                                
                                              (
                                                
                                                   
                                                      
                                                         n
                                                      
                                                      
                                                         10
                                                      
                                                   
                                                
                                             )
                                          Number of test instances misclassified by neither 
                                                
                                                   
                                                      
                                                         f
                                                      
                                                      
                                                         A
                                                      
                                                   
                                                
                                              nor 
                                                
                                                   
                                                      
                                                         f
                                                      
                                                      
                                                         B
                                                      
                                                   
                                                
                                              (
                                                
                                                   
                                                      
                                                         n
                                                      
                                                      
                                                         11
                                                      
                                                   
                                                
                                             )
                                       
                                    
                                 
                              
                           
                        

Under the null hypothesis the two algorithms should have the same error rate (i.e. 
                              
                                 
                                    
                                       n
                                    
                                    
                                       01
                                    
                                 
                              
                            = 
                              
                                 
                                    
                                       n
                                    
                                    
                                       10
                                    
                                 
                              
                           ). McNemar’s test is based on a 
                              
                                 
                                    
                                       χ
                                    
                                    
                                       2
                                    
                                 
                              
                            test with 1 degree of freedom and is calculated as follows:
                              
                                 (3)
                                 
                                    
                                       
                                          χ
                                       
                                       
                                          2
                                       
                                    
                                    =
                                    
                                       
                                          
                                             
                                                (
                                                |
                                                
                                                   
                                                      n
                                                   
                                                   
                                                      01
                                                   
                                                
                                                -
                                                
                                                   
                                                      n
                                                   
                                                   
                                                      10
                                                   
                                                
                                                |
                                                -
                                                1
                                                )
                                             
                                             
                                                2
                                             
                                          
                                       
                                       
                                          
                                             
                                                n
                                             
                                             
                                                01
                                             
                                          
                                          +
                                          
                                             
                                                n
                                             
                                             
                                                10
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

The above equation incorporates a continuity correction term (i.e. the −1 in the numerator) to account for the fact that the statistic is discrete while 
                              
                                 
                                    
                                       χ
                                    
                                    
                                       2
                                    
                                 
                              
                            distribution is continuous [60].

McNemar’s test has a drawback when dealing with small datasets: it does not measure the variability in choosing the training sets, which can significantly affect the performance of the classification models. To mitigate such an issue, Dietterich proposed the 5×2 cross validation paired t test which performs five replications of twofold cross validation. In each replication, the dataset TwitterA is randomly divided into two equal subsets, 
                              
                                 
                                    
                                       S
                                    
                                    
                                       1
                                    
                                 
                              
                            and 
                              
                                 
                                    
                                       S
                                    
                                    
                                       2
                                    
                                 
                              
                           . For each proposed model 
                              
                                 
                                    
                                       f
                                    
                                    
                                       A
                                    
                                 
                              
                            and the baseline 
                              
                                 
                                    
                                       f
                                    
                                    
                                       B
                                    
                                 
                              
                           , the models are trained on each set and tested with the other set. This produces four error estimates: 
                              
                                 
                                    
                                       p
                                    
                                    
                                       A
                                    
                                    
                                       (
                                       1
                                       )
                                    
                                 
                              
                            and 
                              
                                 
                                    
                                       p
                                    
                                    
                                       B
                                    
                                    
                                       (
                                       1
                                       )
                                    
                                 
                              
                            (trained on 
                              
                                 
                                    
                                       S
                                    
                                    
                                       1
                                    
                                 
                              
                            and tested on 
                              
                                 
                                    
                                       S
                                    
                                    
                                       2
                                    
                                 
                              
                           ) and 
                              
                                 
                                    
                                       p
                                    
                                    
                                       A
                                    
                                    
                                       (
                                       2
                                       )
                                    
                                 
                              
                            and 
                              
                                 
                                    
                                       p
                                    
                                    
                                       B
                                    
                                    
                                       (
                                       2
                                       )
                                    
                                 
                              
                            (trained on 
                              
                                 
                                    
                                       S
                                    
                                    
                                       2
                                    
                                 
                              
                            and tested on 
                              
                                 
                                    
                                       S
                                    
                                    
                                       1
                                    
                                 
                              
                           ). Let 
                              
                                 
                                    
                                       p
                                    
                                    
                                       (
                                       1
                                       )
                                    
                                 
                                 =
                                 
                                    
                                       p
                                    
                                    
                                       A
                                    
                                    
                                       (
                                       1
                                       )
                                    
                                 
                                 -
                                 
                                    
                                       p
                                    
                                    
                                       B
                                    
                                    
                                       (
                                       1
                                       )
                                    
                                 
                              
                           , 
                              
                                 
                                    
                                       p
                                    
                                    
                                       (
                                       2
                                       )
                                    
                                 
                                 =
                                 
                                    
                                       p
                                    
                                    
                                       A
                                    
                                    
                                       (
                                       2
                                       )
                                    
                                 
                                 -
                                 
                                    
                                       p
                                    
                                    
                                       B
                                    
                                    
                                       (
                                       2
                                       )
                                    
                                 
                              
                           , and 
                              
                                 
                                    
                                       p
                                    
                                    
                                       ¯
                                    
                                 
                                 =
                                 (
                                 
                                    
                                       p
                                    
                                    
                                       (
                                       1
                                       )
                                    
                                 
                                 +
                                 
                                    
                                       p
                                    
                                    
                                       (
                                       2
                                       )
                                    
                                 
                                 )
                                 /
                                 2
                              
                           , the estimated variance 
                              
                                 
                                    
                                       s
                                    
                                    
                                       2
                                    
                                 
                              
                            is defined as:
                              
                                 (4)
                                 
                                    
                                       
                                          s
                                       
                                       
                                          2
                                       
                                    
                                    =
                                    
                                       
                                          (
                                          
                                             
                                                p
                                             
                                             
                                                (
                                                1
                                                )
                                             
                                          
                                          -
                                          
                                             
                                                p
                                             
                                             
                                                ¯
                                             
                                          
                                          )
                                       
                                       
                                          2
                                       
                                    
                                    +
                                    
                                       
                                          (
                                          
                                             
                                                p
                                             
                                             
                                                (
                                                2
                                                )
                                             
                                          
                                          -
                                          
                                             
                                                p
                                             
                                             
                                                ¯
                                             
                                          
                                          )
                                       
                                       
                                          2
                                       
                                    
                                 
                              
                           The 5×2 CV 
                              
                                 
                                    
                                       t
                                    
                                    
                                       ̃
                                    
                                 
                              
                            statistic is defined as follows:
                              
                                 (5)
                                 
                                    
                                       
                                          t
                                       
                                       
                                          ̃
                                       
                                    
                                    =
                                    
                                       
                                          
                                             
                                                p
                                             
                                             
                                                1
                                             
                                             
                                                (
                                                1
                                                )
                                             
                                          
                                       
                                       
                                          
                                             
                                                
                                                   
                                                      1
                                                   
                                                   
                                                      5
                                                   
                                                
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      i
                                                      =
                                                      1
                                                   
                                                   
                                                      5
                                                   
                                                
                                                
                                                   
                                                      s
                                                   
                                                   
                                                      i
                                                   
                                                   
                                                      2
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           where 
                              
                                 
                                    
                                       s
                                    
                                    
                                       i
                                    
                                    
                                       2
                                    
                                 
                              
                            is the calculated 
                              
                                 
                                    
                                       s
                                    
                                    
                                       2
                                    
                                 
                              
                            of the replication i, and 
                              
                                 
                                    
                                       p
                                    
                                    
                                       1
                                    
                                    
                                       (
                                       1
                                       )
                                    
                                 
                              
                            is the 
                              
                                 
                                    
                                       p
                                    
                                    
                                       (
                                       1
                                       )
                                    
                                 
                              
                            of the first replication. Under the null hypothesis, 
                              
                                 
                                    
                                       t
                                    
                                    
                                       ̃
                                    
                                 
                              
                            has approximately a t distribution with 5 degrees of freedom [60].

The p-values of the McNemar’s Chi-square and 5×2 CV paired t tests are reported in Table 8, along with the significance interpretations using 
                              
                                 α
                                 =
                                 0.05
                              
                            (i.e. YES or NO). Both tests agree that the performance of DC, ST, CB, and WPA models are statistically significantly different from the baseline. It is interesting to see that the NG method is not reported significantly different from the baseline by both tests. This may be because both the methods rely on the N-gram features, which result in similar classification results.

100 false positive and 100 false negative instances misclassified by the best proposed method (i.e. WPA), are randomly selected and analyzed to determine the sources of classification error. We found that the false positive samples can be classified into one of the three categories based on their characteristics, as listed below:
                           
                              1.
                              
                                 The health-related keywords are presented but used in the non-health related context. (59%) E.g.:
                                    
                                       •
                                       
                                          my laptop is kinda 
                                          
                                             choking
                                           
                                          every 2
                                          
                                          s! gonna install UBUNTU 1.10! any tip or suggestion?
                                       

Note that is type of error is also one of the two main weaknesses posed by the baseline. Even though error of this type is still produced by the proposed WPA method, the magnitude is much smaller.


                                 The message provides health related information in a sub context, but the super context is non-health related. (21%) E.g.:
                                    
                                       •
                                       
                                          I got some facebook heat for my seemingly progressive 
                                          breast cancer 
                                          statement. seems to me that people DO want and end to 2nd Base
                                       


                                 The message is mislabeled. (20%) Some health related messages are mislabeled as non-health related. This can happen due to both accidents and misunderstanding of the labellers. E.g.
                                    
                                       •
                                       
                                          Rain, sick, in bed sounds good til work
                                       

Analyzing the 100 false negative samples, we also found that the error can be classified into four categories:
                           
                              1.
                              
                                 The health-related information is small, hence may produce weak signals, compared to the surrounding context. (39%) E.g.:
                                    
                                       •
                                       
                                          I’m going to have my tuition at 10.30 & 
                                             I am sick
                                          
                                          . Well, it isn’t that i love studying. It’s just that the $ is given. I HAVE TO GO!
                                       

Though the word sick can imply that the poster is sick. However, such a word has also extensively been used in other non-health related context that the classifier may treat such a word as a weak signal. Especially when the health related content is among non-health related content, the signal can be impeded by the surrounding context.


                                 The message mentions health related content which can be identified from an uncommon keyword. (29%) E.g.:
                                    
                                       •
                                       
                                          KFMA Day in the Old Pueblo…might have a serious 
                                          
                                             sunburn
                                           
                                          tomorrow. But Switchfoot is here!:)
                                       

This problem would have been corrected by the DC features if the keyword is known to the vocabulary. Note that sunburn is a type of skin inflammation; however, the vocabulary that we use to generate the DC features do not contain such a word. As a result, the classifier may not be aware that sunburn implies health-related information.


                                 The message is mislabeled. (23%) E.g.:
                                    
                                       •
                                       
                                          Hey pregnant chick smoking in front of the burrito place, just how do you find a brand classy enough for ya? This example message is not health related, but was labeled as positive.


                                 Other. (9%) We are not able to find common characteristics among these misclassified messages.

Our results show that the WPA method, wherein each base classifier is given some decision weight, yields the best performance. This section further attempts to assess the importance of each base classifier when making collaborative decisions. We analyse the results of the WPA classifier from the first fold of the 10-fold cross validation performed in Section 5.2. The best performance is yielded by the weight vector 
                           
                              〈
                              NG
                              =
                              0.1
                              ,
                              DC
                              =
                              0.2
                              ,
                              TD
                              =
                              0.1
                              ,
                              ST
                              =
                              0.1
                              ,
                              CB
                              =
                              0.5
                              〉
                           
                         with 74.76% precision, 68.93% recall, and 71.88% F-measure. The CB classifier is given most weight due to having the most extensive view of the data. The DC classifier is given a twice higher weight compared to TD and ST classifiers since it addresses both the problems posed by the baseline, while the others address only one problem.

Each of our feature set reflects a different view of the dataset–the NG features reflect the word patterns used in each document, the MC features capture the semantics of the health related terms by capturing the usage of terms appearing together in the same document, the TD features extract topical semantics of the document, and the ST features capture the sentiment semantics of document in terms of level of illness and emotional variants. According to the results in Table 8, combining all the proposed feature sets results in a better classification. This is because classifiers trained with different views of the dataset can catch the errors of the others. In this subsection, we investigate how each of our proposed feature types increases the information learned by the baseline features.

We generate another 4 feature sets, each of which is a combination of the baseline feature set and one of our NG, DC, TD, ST feature sets. We train a SVM classifier with each of the combined feature sets, and run a 10-fold cross validation on the dataset. We compare the results with the classifier trained solely with the baseline feature set. Table 9
                         lists the results.

The impact (
                           
                              Δ
                           
                         F) of the NG features is not significant since the baseline and our NG features are both N-gram based; hence, they provide redundant information to the classifier. The DC features have the most impact on the performance, because it addresses both the drawbacks of N-gram features, hence allowing the classifier to learn a different perspective of the dataset. The TD features capture the topics associated with a document. However, since a topic is defined as a distribution of terms, which is similar to N-gram features (where a term is given a weight), the impact of TD features is not as dominant as that of the DC features. The ST features capture both health-related keywords used and emotion in a document. Since these properties are not captured in the baseline feature set, combining the ST features with the baseline allows the classifier to learn more information as expected.

Additionally, Table 10
                         lists the significance test results of each non-NG base classifiers with respect to the NG base classifier, using the McNemar 
                           
                              
                                 
                                    χ
                                 
                                 
                                    2
                                 
                              
                           
                         test outlined in Section 5.3.1. Here, the null hypothesis states that the performance of each non-NG base classifier is the same as the NG base classifier. According to Table 10, DC, TD, and ST base classifiers are shown to be statistically significant from the NG base classifier with the significance level 
                           
                              α
                           
                        
                        =0.05, suggesting that the proposed base classifiers learn significantly different aspects of the data that, when combined together, result in a better performance than using the NG feature alone. Note also that, even though each non-NG base classifier performs worse than or equivalent to the NG base classifier (according to Table 8), the WPA ensemble method allows these base classifiers to contribute their semantically heterogeneous knowledge to correct each other, resulting in final decisions which are more accurate than those produced by individual experts. This phenomenon also explains why the performance (in term of F-measure) of the WPA method is much better than that of the NG base classifier.

Note that the classification of the CB base classifier does not seem to be statistically significantly different from the NG base classifier, according to Table 10. This is consistent with the classification performance in Table 8 which reports that the classification performance (in terms of F-measure) of both the NG and CB base classifiers are roughly the same, while it may be intuitive that a classifier that learns all the aspects of the data should perform much better than individual experts. An explanation for this phenomenon might be the fact that the feature space of the NG features (64% of the combined feature space) is much larger than those of other feature types. This huge amount of NG features could impede the significance of other feature types when altogether learned by a base classifier. This opens a pathforward to investigate feature selection techniques, which we consider for our future work.

This subsection addresses three obvious questions:
                           
                              1.
                              Is smaller dataset like TwitterA large and diverse enough to reflect the characteristics of social media, which is full of lexical diversity and noise?

Are our proposed heterogeneous features able to gain insight from such a small dataset to capture the characteristics of much larger, real-world data?

Are our methods generalizable to other kinds of social media?

To address the above questions, we conduct another set of experiments on real-world, large scale datasets such as TwitterB and Facebook (Section 3). Each feature type is used to trained a base classifier as outlined in Section 4.1, using 90% of the data of the TwitterA dataset (another 10% held-out data is used to tune the parameters when combining the base classifiers). Table 11
                         summarized the base classifiers trained with the proposed feature types and the baseline feature, including the number of features and training time.

A random sample of 10,000 messages are drawn from each the TwitterB and Facebook datasets, and manually labeled by 5 graduate students. The sample data of the TwitterB dataset contains 134 (1.34%) health-related messages. The sample data of the Facebook dataset contains 107 (1.07%) health-related messages. It is not surprising to see a lower percentage of health-related messages in the Facebook dataset, since most Facebook messages are comments to existing main posts. These comments, when treated individually, may not be able to express true semantics without presented with the accompanied comments and the original posts. Hence a Facebook message may have health-related semantics (especially those comments to a health-related post), but may be classified otherwise when interpreted individually. Fig. 6
                         provides an example of a Facebook Timeline post and its accompanied comments. As shown in the figure, if each message is treated individually, then only the original post and comment #1 would be classified as health-related; however, when treated as a whole conversation, all the messages should be classified as health-related since they discuss the same topic (about the original poster getting the swine flu).

The baseline classifier, our base classifiers, and our proposed ensemble classifiers are used to classify these samples. Table 12
                         lists the results in terms of precision, recall, F1, and F-measure improvement over the baseline (
                           
                              Δ
                           
                         F1). The italicised numbers are the highest number in the columns.

There are four points to note:

First, it is important to note that the performance in terms of F-measure of the baseline classifier drops significantly (66.72% drop in precision and 41.47% drop in F1), compared to that of the 10-fold validation results in Table 8. This is because the baseline classifier is trained with a binary-based N-grams features on a small dataset of roughly 5000 messages. The binary features allow the classifier to take into account only the presence of terms without considering the importance of them. The obvious drawback of such scheme is that terms with high discriminative power such as flu, cold, headache, etc. would be treated the same as common terms (e.g. tomorrow, the, when) and terms with low discriminative power (i.e. terms that do not imply health-related meaning such as Xbox, iPhone, water, etc). When testing such a classifier on a much larger and diverse data, it is expected to see a rise in recall and a drop in precision. Our NG features, though also based on N-grams, remedy both the problems by cleaning the messages (removing common stopwords and stemming terms) and utilizing TF-IDF weights to represent each term. Cleaning messages allow the classifier to ignore the common terms. Learning TF-IDF weights enable the classifier to recognize terms with highly discriminative power. Hence, the magnitude of performance reduction of the large scale performance (47.3% drop in precision, 12.55% drop in recall, and 32.14% drop in F1) of our NG classifier is relatively smaller compared to that of the baseline.

Second, it is worth noting that the baseline classifier tend to produce relatively high false positive rate, due to the very low precision (9.96%) and high recall rate (65.36%). To support this claim, we run the baseline classifier and our best method (WPA) on the whole TwitterB and Facebook datasets. The TwitterB data is processed on a server with a 16-core Intel Xenon E5630 (2.5GHz) processer and 32GB available RAM. The process was run using 40 threads (roughly 14day’s of data per thread) and was finished within 30h. The Facebook data was processed on a server with an 8-core Intel Xenon E5420 (2.50GHz) processor and 16GB of available RAM. The process was run using 30 threads (roughly 48day’s of data per thread) and was finished in 24h. Fig. 5
                         plots the normalized results (grouped by months) from April 2011 to August 2012 in log scale. According to the large scale results in Table 12, the baseline classifier tends to favor positive classes, and hence detect health-related messages at a higher proportion than our WPA method in both TwitterB and Facebook datasets. According to the results from the large scale performance evaluation shown in Table 12, our WPA methods yields comparable recall rate with that of the baseline, but much higher precision, we conclude that the higher quantity of health-related messages detected by the baseline are mostly false positives.

Third, even though the performance of all methods tend to decrease when evaluated with large scale data, our WPA method still yields reasonable good performance with small performance degrade (17.88% drop in precision, 10.08% drop in recall, and 13.88% drop in F1). Our WPA method outperforms the baseline by 46.20% in terms of F-measure on the TwitterB dataset and 47.04% on the Facebook dataset. We note also that, when combining base classifiers using the WPA method, a prominent increase in the performance is observed in both TwitterB and Facebook datasets. This advocates our assumption earlier that a proper ensemble of individual classifiers that learn different aspects of the data could improve the efficacy of the classification.

Fourth, the large scale evaluation of all the methods on both the datasets are similar. This suggests that the textual information of both social media sources is similar in nature. Hence, a classifier trained with a data source could be expected to perform reasonably equally to other social media domains as to the one it is trained with. On another hand, this also suggests that our proposed methods can easily generalize to other domains of social media.

@&#CONCLUSIONS AND FUTURE WORK@&#

We investigate using 5 heterogeneous feature sets representing different views of the data on machine learning ensemble methods for health-related short text classification problem. We analyse the parameter sensitivity of the feature extraction algorithms in order to obtain the best possible features from each feature type. We study the mutual effects of the feature sets by combining the base classifiers, each of which is trained with a different feature type, using standard ensemble methods. We are able to outperform the baseline by 18.61% in the small scale evaluation and 46.62% on average in the large scale evaluation, using the weighted probability averaging method. Our results are very promising and reaffirm our assumption that the limitation of the N-gram features on the social media domain can be reduced by combining classifiers that learn different characteristics of the data. Future works could seek to improve the classification algorithm [62,63] and to employ semi-supervised methods such as the co-training technique [64] to expand the training data with unlabeled data.

@&#ACKNOWLEDGMENTS@&#

We gratefully acknowledge financial support from the Penn State Center for Integrated Healthcare Delivery Systems (CIHDS), along with useful suggestions from Paronkasom Indradat and Sung Woo Kang.

@&#REFERENCES@&#

