@&#MAIN-TITLE@&#Optimal addressing-based routing for 6LoWPAN

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           The addressing algorithm based on an address tree is proposed.


                        
                        
                           
                           The optimal routing algorithm based on an address tree is proposed.


                        
                        
                           
                           An address update algorithm is proposed.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

6LoWPAN

WSN

Addressing

Routing

@&#ABSTRACT@&#


               
               
                  The addressing-based routing solutions usually adopt a tree topology, but the routing paths along a tree are not optimal and the resources of nodes around a root are excessively consumed. Moreover, the descendants of a failed node need to rejoin a tree and reacquire addresses, and during this process they cannot perform communications. In order to overcome the above deficiencies, this paper proposes an optimal addressing-based routing scheme for 6LoWPAN. This scheme takes advantages of one-hop and two-hop neighbors to calculate optimal paths. Since a root is not involved in most of optimal paths, the excessive resource consumption is avoided. This scheme also proposes an address update algorithm and the descendants of a failed node can use this algorithm to update their addresses rather than reacquire the new addresses. During the address update process, the descendants can still use the original addresses to perform communications.
               
            

@&#INTRODUCTION@&#

With the extensive use of wireless sensor networks (WSNs) and the emergence of various new applications, it is necessary and urgent for WSNs to connect to the Internet in order to satisfy the demands for these applications. IPv6 over Low-Power Wireless Personal Area Networks (6LoWPAN) may be an ideal solution to achieving this objective. 6LoWPAN WSN is usually connected to the Internet via an access router (AR) and each 6LoWPAN sensor node can use the IPv6 protocol to achieve the communications with the Internet.

Two important issues, namely addressing and routing, must be addressed before 6LoWPAN WSN can perform the proper communications. The 6LoWPAN standards [1–2] separately address these two issues. That is, 6LoWPAN first performs the standard [1] to achieve the address configuration. After the addressing process is complete, 6LoWPAN performs the standard [2] to establish the routing paths and achieve the communications. In order to improve the performances of addressing and routing, some addressing-based routing solutions [3–6] are proposed. In these solutions, via the addressing process, WSN is constructed in a special topology which is usually a tree. After the addressing process is complete, the routing can be achieved through this special topology without route discovery. Since the addressing and routing are achieved only via the addressing process, their performances are improved. In these addressing-based routing solutions, WSN is typically organized into a tree topology [3–6], and this might bring the following deficiencies:
                        
                           1.)
                           The routing paths along a tree are not optimal sometimes. As shown in Fig. 1
                              , nodes X1 and X2 are located in different branches, and the distance between them is 2-hop. However, the length of the routing path along a tree is 6-hop.

The root in a tree usually deals with most of messages coming from the tree. As a result, the resources of both the root and the nodes around the root are excessively consumed and the failure probabilities grow. Meanwhile, the links around the root become congested and the network performance is degraded. In Fig. 1, root R has two branches. If node X1 located in one branch communicates with node X2 located in the other branch, then all the messages during this communication need to be forwarded by R.

If a node in a tree becomes invalid, then its descendants need to rejoin a tree and reacquire addresses. During this process the descendants cannot communicate with other nodes. In Fig. 1, node X is X2's father. If X fails, then X2 must rejoin a tree and reacquire an address. Before X2 rejoins the tree, it cannot communicate because no routing path along the tree can reach X2.

In order to overcome the above deficiencies, this paper proposes an optimal addressing-based routing scheme, and it has the following contributions:
                        
                           1)
                           The addressing algorithm based on an address tree is proposed. Via the addressing algorithm, a node acquires a unique address from a neighbor and an address tree is constructed.

The optimal routing algorithm based on an address tree is proposed, and one-hop and two-hop neighbors are used to optimize the routing paths. Since a root is not involved in most of these optimal paths, the excessive resource consumption and the link congestion are avoided.

An address update algorithm is proposed. If a node in a tree fails, then its descendants can still maintain the tree and update the addresses instead of rejoining the tree and reacquiring the new addresses. During the address update process, the descendants can still use the original addresses to communicate with other nodes. As a result, even if a node fails, its descendants can still communicate with other nodes.

The remainder of this paper is organized as follows. In Section 2, the related work on the addressing and routing schemes is discussed. The proposed scheme is presented in Sections 3 and 4, and the performance of this scheme is evaluated in Sections 5 and 6. This paper concludes with a summary in Section 7.

@&#RELATED WORK@&#

The addressing solutions are classified into stateless schemes and stateful schemes. In stateless schemes, each node configures itself with an address, and then performs duplicate address detection (DAD) to ensure the address uniqueness. Usually these solutions suffer from network-wide flooding, so the addressing cost and delay are relatively high.

The DAD optimization standard for 6LoWPAN [1] defines the duplicate address request and the duplicate address confirmation to perform DAD. After a new node generates an address, it performs DAD to ensure the address uniqueness. If the node does not receive any one negative response, then this address is considered unique. Otherwise, this node generates another address and performs DAD. This process is repeated until the new node gets a unique address. The hierarchical and low-power addressing protocol [7] performs DAD for cluster members within one cluster, so the addressing cost and delay are reduced to some extent. The probability-based addressing protocol [8] uses the filter functionalities and probabilistic analysis for address configuration, and then employs DAD to check the address duplication. If the address is in use, then a new address configuration process is launched. Otherwise, this address is considered unique. The PDAD-based addressing protocol [9] divides a network into a few grids. A node constructs an address based on its location information, and then performs DAD in the grid. If another node in the grid claims that it occupies this address, then a new addressing process is initiated. In the filter-based addressing protocol [10], a node randomly selects an address from the address space and performs DAD for this address. If a negative response is returned, then the node randomly chooses another address and broadcasts this address in the network. This process is repeated until the node gets a conflict-free address.

In stateful schemes, some so-called servers are used to maintain address allocation states, and these states are usually maintained by an address allocation table that records the addresses currently in use. Stateful solution can ensure the address uniqueness without DAD.

The tree-based addressing protocol [11] organizes a network into a tree and includes three kinds of nodes: normal nodes, leader nodes, and a root node. A normal node acts as a relay. A leader node has a disjoint address pool and is responsible for assigning an address to a new node. A root maintains the information on all leader nodes and is also responsible for address reclamation. In the distributed addressing protocol [12], an address structure is made up of network ID, node ID and 16-bit port. The network is organized into a tree where an intermediate node is configured with two addresses and a leaf node is configured with one address. A new node acquires a unique address by joining a tree. The dynamic readdressing protocol [13] assumes that a node knows its next location before actual handover occurs. This prior knowledge is exploited by a node to launch the communication with a dynamical host configuration protocol (DHCP) server located in the destination network. In this way, from the DHCP server the node can acquire an address in the next location. In IDSDDIP [14], a new node periodically broadcasts a Discovery message. The neighbor proxy node returns the new node an Offer message with an assigned address. The new node selects the address in the first received Offer and sends a Select message. After receiving this Select, the proxy node returns an ACK message. After receiving the ACK, the new node configures itself with the address in the first received Offer. In the cellular addressing protocol [15], the whole IP address pool is available to each server in the network and each server maintains a database to record the utilization states of the IP addresses. After a server assigns an address to a device, it registers this address with the IP domain name server (IP-DNS). If the server receives a negative acknowledgement from the IP-DNS, it means that the address is in use. In this case, the server assigns another address to the node and registers this address again. If the server detects that the addressing failure rate is above a certain threshold, then it advertises the database throughout the network to notify other servers of the utilization states of the IP addresses.

In general, WSN is constructed in a special topology and the routing is achieved along the special topology. This special topology is usually a tree because a tree topology is suitable for WSN [16].

In the routing standard [2], the routing is achieved based on a directed acyclic graph (DAG), and a tree is a special case of DAG. DAG uses as a metric a value called Rank, which approximates the node's distance from a destination-oriented DAG root and is analogous to the depth in a tree. A message is routed along DAG and ultimately reaches destination node. The cluster-tree routing protocol [17] divides a network into a few clusters, and the cluster heads depend on the cluster associate nodes to achieve the communications. All the cluster heads and cluster associate nodes form a cluster tree and the routing is performed along this cluster tree. The multi-sink routing protocol [16] includes two routing algorithms for small-scale WSN and large-scale WSN, respectively. These two algorithms are based on a tree topology and the routing is achieved along the tree topology. The tree-based routing protocol [18] focuses on the construction of a stable route framework. This framework adopts a tree topology and combines a node's routing metric with its neighbors' ones to evaluate the quality of a route. The anycast-based routing protocol [19] organizes WSN into a tree topology, and a sensor node joins a tree by sending a routing request. Anycast is used to establish a path from a sensor node to a root. After the path is established, the messages are routed from the root to the destination in a unicast way.

In the addressing-based routing solutions, WSN is organized into a special topology through the addressing process and this special topology is usually a tree topology. After the addressing process is complete, the routing is achieved through this topology. That is, the addressing and routing can be achieved only via the addressing process.

The path-connected-cluster routing protocol [3] divides WSN into a few clusters. Through the addressing process, these cluster heads form a cluster tree. Based on the destination address, the routing can be achieved via this cluster tree. In the neighbor-based routing protocol [4], a node obtains a unique IPv6 address by joining a tree topology. That is, a node acquires a unique address from its neighbor, and then marks the neighbor as its father. After all the nodes are configured with an address, they form a tree and the routing can be performed through this tree. In the cluster-based routing protocol [5], WSN is divided into multiple clusters and a cluster head acquires an address by joining a cluster tree. After a cluster head is configured with an address, it performs the address configuration for its cluster members. After a cluster member acquires an address, it communicates with other nodes via the cluster tree. In the hierarchical routing protocol [6], a new node is configured with an address by joining a tree, and then communicates with other nodes along the tree. After a new node is configured with an address, it registers this address with a gateway in order to achieve the routing. If a node in the tree fails, then its descendants need to rejoin the tree and reacquire the addresses. Before the descendants are reconfigured with new addresses, they are unable to communicate with other nodes.

From the above discussion, it can be seen that the addressing-based routing solutions usually adopt a tree topology to perform the routing. Although these addressing-based routing solutions improve the routing performance, they might have the following limitations:
                           
                              1)
                              The routing paths along a tree are not optimal sometimes.

The resources of nodes around a root are consumed excessively and the links around a root are congested.

The descendants of a failed node must be reconfigured with new addresses and during this address reconfiguration process they cannot communicate.

In order to overcome the above limitations, this scheme proposes the following strategies:
                           
                              1)
                              This scheme makes full use of one-hop and two-hop neighbors to calculate the optimal paths.

Since a root is not involved in most of these optimal paths, the excessive resource consumption and link congestion are avoided.

The descendants of a failed node maintain the tree and update the addresses. During the address update process, the descendants can still use the original addresses to perform the communications.

The link protocol in 6LoWPAN is IEEE 802.15.4 [20] which defines two kinds of nodes: full-function device (FFD) with a routing function and reduced-function device (RFD) without a routing function. As shown in Fig. 2
                        , 6LoWPAN WSN is connected to the Internet through an AR. An AR and all FFDs form a tree structure which is called an address tree, and in the tree the root is the AR. An RFD communicates with other nodes through an address tree, and the FFD which directly communicates with an RFD is called the RFD's associate node. In Fig. 2, FFD Y is an associate node of RFD X, and X achieves the communications with other nodes via Y.

Based on the address tree, the hierarchical IPv6 address structure for 6LoWPAN WSN is proposed, as shown in Table 1
                        .

In Table 1, an IPv6 address is made up of four parts. The first part is the tree ID which is the global network prefix and uniquely identifies an address tree. All nodes in WSN have the same tree ID, and the value is defined by the AR. The second part is the 1-bit type which indicates the type of a node. Value 0 means that a node is an FFD, and value 1 indicates that a node is an RFD. The third part is the i-bit branch ID which uniquely identifies an FFD and the fourth part is the j-bit RFD ID which uniquely identifies an RFD. The address of an AR is preset, the type and the branch ID are 0 and the RFD ID is not zero. The RFD ID of an FFD is 0. The type, the branch ID and RFD ID form a link address. Based on [20], the length of a link address is 16 or 64. The valid length l (l
                        ≤
                        i) of an FFD's branch ID is proportional to the depth d of the FFD in the tree, as shown in Eq. (1) where 2
                           c
                        
                        −1 is the maximum number of child nodes which an FFD has.
                           
                              (1)
                              
                                 l
                                 =
                                 d
                                 ⋅
                                 c
                              
                           
                        
                     

After an FFD is configured with an address, it regularly broadcasts a beacon [20] where the payload includes the tree ID, the number of the branch IDs available and the number of the RFD IDs available. Each node in a tree maintains a branch ID table which includes 2
                           c
                        
                        −1 entries, and each entry consists of three fields: the branch ID, the allocation state which has two values Unassigned and Assigned, and the lifetime. If the allocation state in one entry is Assigned, the lifetime attenuates with the machine clock. If a beacon is received from the node with the branch ID in the entry within the lifetime, then the lifetime is reset. If the lifetime decays to 0, then the allocation state changes into Unassigned.

After new FFD X starts, it uses the hardware ID such as media access control (MAC) address as its temporary link address (TLA), listens to the beacons from the neighbors FFDs/AR, selects AR/FFD Y with both the minimum tree depth and the free branch IDs, and acquires an address from Y based on the following process:
                           
                              1)
                              X sends Y an FFD-Req command frame where the source address is its TLA.

After Y receives this FFD-Req, it selects the minimum branch ID with Unassigned, returns X an FFD-Rep frame where the payload is the branch ID, and sets the allocation state of the branch ID to Assigned and the lifetime to the maximum lifetime.

After X receives this FFD-Rep, it sets its branch ID to Y's one, expands its branch ID by c bits, and sets the expanded c bits to the branch ID in the FFD-Rep. Then, X uses the branch ID to construct a link address where the type is 0 and the RFD ID is 0, and finally combines the tree ID with the link address to form an IPv6 address, as shown in Fig. 3
                                  where c and j are set to 3.

In Fig. 3, after Y obtains a branch ID from AR1, it constructs link address 0x3000 and combines the link address with the tree ID to form an address. Then, X starts and gets a branch ID from Y. Finally, X constructs link address 0x3400 and combines the link address with the tree ID to form an IPv6 address.

In this scheme, all the control frames are implemented by expanding IEEE 802.15.4 command frames [5].

Each node in a tree stores an RFD ID table which contains 2
                           j
                        
                        −1 entries, and each entry includes three fields: the RFD ID, the allocation state which has two values Unassigned and Assigned, and the lifetime. If the allocation state in one entry is Assigned, the lifetime attenuates with the machine clock. If a beacon is received from the node with the RFD ID in the entry within the lifetime, then the lifetime is reset. If the lifetime attenuates to 0, then the allocation state changes into Unassigned.

After new RFD Z starts, it uses the hardware ID as its TLA, listens to the beacons from the neighbor FFDs, and selects FFD X which is closest to the AR and has the free RFD IDs. Then, Z obtains an address from X based on the following process:
                           
                              1)
                              Z sends X an RFD-Req frame where the source address is its TLA.

After X receives this RFD-Req, it selects the minimum RFD ID with Unassigned, returns Z an RFD-Rep frame where the payload is the RFD ID, and sets the allocation state of the branch ID to Assigned and the lifetime to the maximum lifetime.

After Z receives this RFD-Rep, it sets its branch ID to X's one and its RFD ID to the one in the RFD-Rep. Then, X combines X's branch ID with its RFD ID to form a link address where the type is 1, and finally combines X's tree ID with the link address to construct an IPv6 address, as shown in Fig. 3.

In Fig. 3, after Z obtains an RFD ID from X, it first constructs link address 0xB401 and combines its link address with X's tree ID to form an IPv6 address.

After an FFD is configured with an address, it begins to construct the one-hop and two-hop neighbor tables. The one-hop neighbor table maintains the information on the FFDs within one-hop scope, and each entry contains two fields: the link address of one-hop neighbor and the lifetime. The two-hop neighbor table stores the information on the FFDs within two-hop scope, and each entry includes three fields: the link address of two-hop neighbor, the link address of one-hop neighbor reaching the two-hop neighbor, and the lifetime. After an FFD is configured with an address, its beacon also consists of the one-hop and two-hop neighbor tables.

FFD X1 constructs the one-hop and two-hop neighbor tables based on the following process:
                           
                              1)
                              X1 listens to the beacons from the neighbor FFDs within one-hop scope. If the neighbor FFD is not in X1's one-hop table, it adds the FFD in the one-hop table.

X1 checks each one-hop table included in the received beacons. If the FFD specified by an entry is not included in X1's one-hop table, then it adds in the two-hop table an entry where the two-hop link address is the FFD's one and the one-hop link address is the source link address of the beacon including the entry.

X1 repeats step 1) and 2) until it constructs the one-hop and two-hop tables, as shown in Fig. 4
                                 .

In this scheme, if FFD Y1 is the common ancestor of FFDs Y2 and Y3, and the valid lengths of Y1 and Y2's branch IDs are l1 and l2 (l2>
                        l1)respectively, then the distance h between Y1 and Y2 can be calculated through Eq. (2). If Eq. (3) is satisfied, then Y1 is called the nearest common ancestor of Y2 and Y3. In Eq. (3), Value(B, s, e) is a function which returns the value from the sth to the eth bit of branch ID B, B2 represents Y2's branch ID and B3 means Y3's branch ID.
                           
                              (2)
                              
                                 h
                                 =
                                 
                                    
                                       l
                                       2
                                       /
                                       c
                                    
                                 
                                 −
                                 
                                    
                                       l
                                       1
                                       /
                                       c
                                    
                                 
                              
                           
                        
                        
                           
                              (3)
                              
                                 Value
                                 
                                    
                                       B
                                       2
                                    
                                    
                                       
                                          
                                             l
                                             1
                                             /
                                             c
                                          
                                       
                                       ⋅
                                       c
                                    
                                    
                                       
                                          
                                             
                                                
                                                   l
                                                   1
                                                   /
                                                   c
                                                
                                             
                                             +
                                             1
                                          
                                       
                                       ⋅
                                       c
                                       −
                                       1
                                    
                                 
                                 ≠
                                 Value
                                 
                                    
                                       B
                                       3
                                    
                                    
                                       
                                          
                                             l
                                             1
                                             /
                                             c
                                          
                                       
                                       ⋅
                                       c
                                    
                                    
                                       
                                          
                                             
                                                
                                                   l
                                                   1
                                                   /
                                                   c
                                                
                                             
                                             +
                                             1
                                          
                                       
                                       ⋅
                                       c
                                       −
                                       1
                                    
                                 
                              
                           
                        
                     

In this scheme, the branch ID is used for routing. If the branch ID of the destination address in a data frame is equal to FFD X's branch ID, then this frame is routed to X based on the following process where the current FFD is defined as the FFD which is dealing with a data frame:
                           
                              1)
                              The current FFD generating/receiving this frame checks its one-hop and two-hop tables, and routes this frame based on the following 4 cases (the priorities are Case 1
                                 >
                                    Case 2
                                 >
                                    Case 3
                                 >
                                    Case 4):

X is in the current FFD's one-hop table. The current FFD forwards this frame to X and goes to step 2).

X is in the current FFD's two-hop table. The current FFD forwards this frame to the FFD specified by the one-hop neighbor filed in X's entry and goes to step 1).

There are n entries in the current FFD's one-hop table L1, and the FFD specified by each entry is denoted as Y
                                 k
                               (1≤
                              k
                              ≤
                              n). There are m entries in the current FFD's two-hop table L2, and the FFD specified by each entry is denoted as Z
                                 b
                               (1≤
                              b
                              ≤
                              m). The nearest common ancestor of Y
                                 k
                               and X is FFD A
                                 k
                              , and the sum of the distance from Y
                                 k
                               to A
                                 k
                               and the one from X to A
                                 k
                               is h
                              
                                 k
                              . The nearest common ancestor of Z
                                 b
                               and X is FFD A
                                 b
                              , and the sum of the distance from Z
                                 b
                               to A
                                 b
                               and the one from X to A
                                 b
                               is h
                              
                                 b
                              . If node Y
                                 p
                               (1≤
                              p
                              ≤
                              n) in L1 satisfies Eq. (4), then the current FFD forwards this frame to Y
                                 p
                               and goes to step 1). In Eq. (4), the nearest common ancestor of Y
                                 p
                               and X is FFD A
                                 p
                              , and the sum of the distance from Y
                                 p
                               to A
                                 p
                               and the one from X to A
                                 p
                               is h
                              
                                 p
                              .

If node Z
                                 q
                               (1≤
                              q
                              ≤
                              m) in L2 satisfies Eq. (5), then the current FFD forwards this frame to the next hop reaching Z
                                 q
                               and goes to step 1). In Eq. (5), the nearest common ancestor of Z
                                 q
                               and X is FFD A
                                 q
                              , and the sum of the distance from Z
                                 q
                               to A
                                 q
                               and the one from X to A
                                 q
                               is h
                              
                                 q
                              .

The frame reaches X, as shown in Fig. 4(a) and (b).

In Fig. 4(a), FFD X1 sends a data frame to FFD X2 and Case 1 is satisfied, so X1 directly forwards this frame to X2. X1 sends a data frame to FFD X3 and Case 2 is satisfied, so X1 first sends this frame to X2. After X2 receives this frame, Case 1 is satisfied and X2 directly forwards this frame to X3. FFD X5 sends a data frame to FFD X7 and Case 3 is satisfied, so X5 first sends this frame to X2. After X2 receives this frame, Case 2 is satisfied and X2 forwards this frame to X3. After X3 receives this frame, Case 1 is satisfied and X3 forwards this frame to X7. FFD X4 sends a data frame to FFD X8 and Case 4 is satisfied, so X4 first sends this frame to X3. After X3 receives this frame, Case 2 is satisfied and X3 forwards this frame to X7. After X7 receives this frame, Case 1 is satisfied and X7 forwards this frame to X8.

If FFD X1 detects that its father Y1 fails, it listens to the beacons from the neighbor FFDs/AR, requests a new branch ID from FFD Y2 which is not Y1's descendant and updates the addresses of its descendants based on the following process:
                           
                              1)
                              After X1 (or X1's descendant) obtains (updates) a new branch ID, it constructs a new link address and broadcasts a beacon where the source address is the new link address and the payload is the original link address.

If the branch ID of the RFD receiving this beacon is equal to the branch ID of the address encapsulated in the beacon, the RFD updates its branch ID with the branch ID of the sources address of the beacon.

If the FFD receiving this beacon is X1's child, it sets its branch ID to the branch ID of the source address of the beacon, expands its branch ID by c bits and sets the expanded c bits to Value(B4,(⌈
                                    l4/c
                                 ⌉−1)⋅
                                 c
                                 ,⌈
                                    l4/c
                                 ⌉⋅
                                 c
                                 −1, where B4 is the original branch ID of the FFD and l4 is the valid length of B4.

Repeat steps 1), 2) and 3) until X1's descendants all updates their link addresses, as shown in Fig. 5
                                 .

After an FFD updates its address, its neighbor adds an entry for the FFD's updated address in its one-hop and two-hop tables via receiving the beacons, and deletes the entry for the FFD's original address after the lifetime expires.


                        Fig. 5(a) shows the addressing scenario before FFD Y1 fails. Y1 had two child nodes X1 and X2. In Fig. 5(b), Y1 fails, and X1 acquires a new link address from FFD Y2 and broadcasts a beacon. After X1's child nodes X4 and X5 update their link addresses and broadcast a beacon, RFD Z1 also updates its link address. Similarly, after X2 receives a beacon from X1, it acquires a new link address from X1 and broadcasts a beacon. After X2's child node X3 receives this beacon, it also updates its link address.

If FFD Y1 fails, its descendants can still use the original addresses to achieve the communication in order to avoid the communication disruption caused by the address update.

If Y1's neighbor generates/receives a data frame destined for node Y3 which is not Y1's descendant and the next hop of this frame is Y1, then it routes this frame to Y3 based on the following process:
                           
                              1)
                              The current FFD generating/receiving this frame checks the one-hop and two-hop tables, and routes this frame based on the following 5 cases (the priorities are Case 1
                                 >
                                    Case 2
                                 >
                                    Case 3
                                 >
                                    Case 4
                                 >
                                    Case 5):

Y3 is in the current FFD's one-hop table. The current FFD forwards this frame to Y3 and goes to step 3).

Y3 is in the current FFD's two-hop table. The current FFD forwards this frame to the FFD specified by the one-hop neighbor filed in Y3's entry and goes to step 1).

The current FFD has n (1≤
                              n) neighbor FFDs which are not Y1's descendants and these FFDs are denoted as N
                                 k
                               (1≤
                              k
                              ≤
                              n). The nearest common ancestor of N
                                 k
                               and Y3 is FFD A
                                 k
                              , and the sum of the distance from N
                                 k
                               to A
                                 k
                               and the one from Y3 to A
                                 k
                               is h
                              
                                 k
                              . If node N
                                 p
                               (1≤
                              p
                              ≤
                              n) satisfies Eq. (6), then the current FFD forwards this frame to N
                                 p
                               and goes to step 2). In Eq. (6), the nearest common ancestor of N
                                 p
                               and Y3 is FFD A
                                 p
                              , and the sum of the distance from N
                                 p
                               to A
                                 p
                               and the one from Y3 to A
                                 p
                               is h
                              
                                 p
                              .

The current FFD has m (1≤
                              m) two-hop neighbor FFDs which are not Y1's descendants and these FFDs are denoted as M
                                 b
                               (1≤
                              b
                              ≤
                              m). The nearest common ancestor of M
                                 b
                               and Y3 is FFD A
                                 b
                              , and the sum of the distance from M
                                 b
                               to A
                                 b
                               and the one from Y3 to A
                                 b
                               is h
                              
                                 b
                              . If node M
                                 q
                               (1≤
                              q
                              ≤
                              m) satisfies Eq. (7), then the current FFD forwards this frame to M
                                 q
                               and goes to step 1). In Eq. (7), the nearest common ancestor of M
                                 q
                               and Y3 is FFD A
                                 q
                              , and the sum of the distance from M
                                 q
                               to A
                                 q
                               and the one from Y3 to A
                                 q
                               is h
                              
                                 q
                              .

The current FFD forwards this frame to the neighbor which is closest to the AR and has a relative large number of neighbors, and goes to step 1).

N
                                    p
                                  routes this frame to AR AR1 along the tree and then AR1 routes this frame to Y3 along the tree.

The routing ends, as shown in Fig. 6(a) and (b).

In Fig. 6(a), FFD X6 sends a data frame to FFD Y3 and the next hop of this frame is Y1. Since Case 5 is satisfied, X6 forwards this frame to X2. After X2 receives this frame, Case 4 is satisfied and X2 forwards this frame to X1. After X1 receives this frame, Case 3 is satisfied and X1 forwards this frame to Y2. Then, Y2 forwards this frame to AR1 which then forwards this frame to Y3.

After an FFD establishes its one-hop table, it registers this table with the AR. As a result, an AR can acquire the one-hop tables of all the FFDs in the tree. If Y1's neighbor receives a data frame destined for X6 which is Y1's descendant and the next hop of this frame is Y1, then it routes this frame to X6 based on the following process:
                           
                              1)
                              Y1's neighbor first forwards this frame to AR1.

AR1 checks the one-hop tables of Y1's descendants and routes this frame to X6 based on the following cases:

If X6 has a neighbor which is not Y1's descendant, then AR1 routes this frame to the neighbor which then forwards this frame to X6 and goes to step 4).

If all the FFDs with X6's w-hop (w
                              ≥1) scope are Y1's descendants, AR1 executes w
                              =
                              w
                              +1. If X6 has a w-hop neighbor which is not Y1's descendant and the routing path between X6 and the neighbor does not include Y1, then AR1 adds a routing header in this frame, routes this frame to the neighbor and goes to step 3). The routing header includes the FFDs involved in the routing path from the neighbor to X6. Otherwise, AR1 repeats Case 2.

The neighbor routes the frame to X6 based on the routing header.

The routing ends, as shown in Fig. 6.

In Fig. 6, AR1 receives a data frame destined for X6 and the next hop of this frame is Y1. Since Y1 fails, AR1 checks the one-hop tables of X6's 3-hop neighbors (Case 2) and detects that X6's 3-hop neighbor Y2 is not Y1's descendant. Therefore, AR1 adds a routing header which includes FFDs X1 and X2 involved in the routing path from Y2 to X6, and routes this frame to Y2 which then routes this frame to X6 based on the routing header.

Based on the above process, even if Y1 fails and X6 updates its address, the communication between X6 and Y3 can still be achieved.

In fact, based on the routing algorithm in Section 3.4, Y1 is seldom involved in the communication processes of its descendants, so most of its descendants can achieve the communications in the normal way even if Y1 fails. For example, the communication process between Y2/Y4 and X1/X2/X3/X4/X5 is not affected by Y1's failure.

@&#ANALYSIS@&#

The cost and latency of constructing an address tree are actually the addressing ones of all the FFDs in the tree. The addressing cost is measured by the number of command frames used for address configuration, and the addressing latency is the delay taken by address configuration.

Based on Section 3.2, the addressing cost C
                        
                           FFD-addr
                         for an FFD and the addressing cost C
                        
                           Tree-addr
                         for all the FFDs in an address tree are shown in Eqs. (8)–(10), where n
                        
                           FFD
                         is the number of the FFDs in an address tree, c
                        
                           FFD-Req
                        /c
                        
                           FFD-Rep
                         is the cost of transmitting an FFD-Req/FFD-Rep between neighbors, d
                        
                           neig
                         is the distance between neighbors, ρ1 is the FFD density and A is the area covered by the tree. The addressing latency T
                        
                           FFD-addr
                         for an FFD and the addressing latency T
                        
                           Tree-addr
                         for all the FFDs in a tree are shown in Eqs. (11) and (12), where d is the maximum depth of an address tree, and t
                        
                           FFD-Req
                        /t
                        
                           FFD-Rep
                         is the latency of transmitting an FFD-Req/FFD-Rep between neighbors.
                           
                              (8)
                              
                                 
                                    C
                                    
                                       FFD
                                       ‐
                                       addr
                                    
                                 
                                 =
                                 
                                    
                                       
                                          c
                                          
                                             FFD
                                             ‐
                                             Req
                                          
                                       
                                       +
                                       
                                          c
                                          
                                             FFD
                                             ‐
                                             Rep
                                          
                                       
                                    
                                 
                                 ⋅
                                 
                                    d
                                    neig
                                 
                              
                           
                        
                        
                           
                              (9)
                              
                                 
                                    C
                                    
                                       Tree
                                       ‐
                                       addr
                                    
                                 
                                 =
                                 
                                    n
                                    FFD
                                 
                                 ⋅
                                 
                                    C
                                    
                                       FFD
                                       ‐
                                       addr
                                    
                                 
                              
                           
                        
                        
                           
                              (10)
                              
                                 
                                    n
                                    FFD
                                 
                                 =
                                 ρ
                                 1
                                 ⋅
                                 A
                              
                           
                        
                        
                           
                              (11)
                              
                                 
                                    T
                                    
                                       FFD
                                       ‐
                                       addr
                                    
                                 
                                 =
                                 
                                    
                                       
                                          t
                                          
                                             FFD
                                             ‐
                                             Req
                                          
                                       
                                       +
                                       
                                          t
                                          
                                             FFD
                                             ‐
                                             Rep
                                          
                                       
                                    
                                 
                                 ⋅
                                 
                                    d
                                    neig
                                 
                              
                           
                        
                        
                           
                              (12)
                              
                                 
                                    T
                                    
                                       Tree
                                       ‐
                                       addr
                                    
                                 
                                 =
                                 d
                                 ⋅
                                 
                                    T
                                    
                                       FFD
                                       ‐
                                       addr
                                    
                                 
                              
                           
                        
                     

Based on Section 3.3, the addressing cost C
                        
                           RFD-addr
                         for an RFD and the addressing cost C
                        
                           WSN-addr
                         for all the RFDs in WSN are shown in Eqs. (13)–(15), where n
                        
                           RFD
                         is the total number of the RFDs, c
                        
                           RFD-Req
                        /c
                        
                           RFD-Rep
                         is the cost of transmitting an RFD-Req/RFD-Rep between neighbors, and ρ2 is the RFD density. The addressing latency T
                        
                           RFD-addr
                         for an RFD and the addressing latency T
                        
                           WSN-addr
                         for all the RFDs are shown in Eqs. (16) and (17), where n
                        
                           a-RFD
                         is the maximum number of the RFDs associated with one FFD, and t
                        
                           RFD-Req
                        /t
                        
                           RFD-Rep
                         is the latency of transmitting an RFD-Req/RFD-Rep between neighbors. The total addressing cost C
                        
                           addr
                         and delay T
                        
                           addr
                         for all the nodes are shown in Eqs (18) and (19).
                           
                              (13)
                              
                                 
                                    C
                                    
                                       RFD
                                       ‐
                                       addr
                                    
                                 
                                 =
                                 
                                    
                                       
                                          c
                                          
                                             RFD
                                             ‐
                                             Req
                                          
                                       
                                       +
                                       
                                          c
                                          
                                             RFD
                                             ‐
                                             Rep
                                          
                                       
                                    
                                 
                                 ⋅
                                 
                                    d
                                    neig
                                 
                              
                           
                        
                        
                           
                              (14)
                              
                                 
                                    C
                                    
                                       WSN
                                       ‐
                                       addr
                                    
                                 
                                 =
                                 
                                    n
                                    RFD
                                 
                                 ⋅
                                 
                                    C
                                    
                                       RFD
                                       ‐
                                       addr
                                    
                                 
                              
                           
                        
                        
                           
                              (15)
                              
                                 
                                    n
                                    RFD
                                 
                                 =
                                 ρ
                                 2
                                 ⋅
                                 A
                              
                           
                        
                        
                           
                              (16)
                              
                                 
                                    T
                                    
                                       RFD
                                       ‐
                                       addr
                                    
                                 
                                 =
                                 
                                    
                                       
                                          t
                                          
                                             RFD
                                             ‐
                                             Req
                                          
                                       
                                       +
                                       
                                          t
                                          
                                             RFD
                                             ‐
                                             Rep
                                          
                                       
                                    
                                 
                                 ⋅
                                 
                                    d
                                    neig
                                 
                              
                           
                        
                        
                           
                              (17)
                              
                                 
                                    T
                                    
                                       WSN
                                       ‐
                                       addr
                                    
                                 
                                 =
                                 
                                    n
                                    
                                       a
                                       ‐
                                       RFD
                                    
                                 
                                 ⋅
                                 
                                    T
                                    
                                       RFD
                                       ‐
                                       addr
                                    
                                 
                              
                           
                        
                        
                           
                              (18)
                              
                                 
                                    C
                                    addr
                                 
                                 =
                                 
                                    C
                                    
                                       Tree
                                       ‐
                                       addr
                                    
                                 
                                 +
                                 
                                    C
                                    
                                       WSN
                                       ‐
                                       addr
                                    
                                 
                              
                           
                        
                        
                           
                              (19)
                              
                                 
                                    T
                                    addr
                                 
                                 =
                                 
                                    T
                                    
                                       Tree
                                       ‐
                                       addr
                                    
                                 
                                 +
                                 
                                    T
                                    
                                       WSN
                                       ‐
                                       addr
                                    
                                 
                              
                           
                        
                     

Based on Section 4.2, if an FFD fails, its descendants need to update their addresses. The address update cost C
                        
                           Update-addr
                         for the descendants is shown in Eq. (20) where n
                        
                           Child
                         is the number of the child nodes of the failed FFD. The address update latency T
                        
                           Update-addr
                         is shown in Eq. (21) where d
                        
                           failed
                         is the maximum depth of the sub-tree whose root is the failed FFD, T
                        
                           beacon
                         is the interval between two beacons and t
                        
                           beacon
                         is the latency of broadcasting a beacon within one-hop scope.
                           
                              (20)
                              
                                 
                                    C
                                    
                                       Update
                                       ‐
                                       addr
                                    
                                 
                                 =
                                 
                                    C
                                    
                                       FFD
                                       ‐
                                       addr
                                    
                                 
                                 ⋅
                                 
                                    n
                                    Child
                                 
                              
                           
                        
                        
                           
                              (21)
                              
                                 
                                    T
                                    
                                       Update
                                       ‐
                                       addr
                                    
                                 
                                 =
                                 
                                    T
                                    
                                       FFD
                                       ‐
                                       addr
                                    
                                 
                                 ⋅
                                 
                                    n
                                    Child
                                 
                                 +
                                 
                                    d
                                    failed
                                 
                                 ⋅
                                 
                                    
                                       
                                          T
                                          beacon
                                       
                                       +
                                       
                                          t
                                          beacon
                                       
                                    
                                 
                              
                           
                        
                     

The performance parameters of this optimal routing scheme including the path length and routing latency are analyzed. The path length is assessed by the hops from a source to a destination, and the routing latency is the delay taken by establishing a route from a source to a destination.

Based on Section 3.4, in Case 1 (C1), the source and destination are one-hop neighbors so the maximum routing path length R
                        
                           C1 and the maximum routing latency T
                        
                           C1 are shown in Eqs. (22) and (23) where t is the latency of transmitting a data frame between neighbors. In Case 2 (C2), the source and destination are two-hop neighbors, so the maximum routing path length R
                        
                           C2 and the maximum routing latency T
                        
                           C2 are shown in Eqs. (24) and (25). In Case 3 (C3), the source selects as the next hop the one-hop neighbor which is closest to the destination, so the maximum routing path length R
                        
                           C3 and the maximum routing latency T
                        
                           C3 are shown in Eqs. (26) and (27) where h
                        
                           one-neig-a
                         is the distance from the next hop to the nearest common ancestor and h
                        
                           one-dest-a
                         is the distance from the destination to the ancestor. In Case 4 (C4), the source selects as the next hop the two-hop neighbor which is closest to the destination, so the maximum routing path length R
                        
                           C4 and the maximum routing latency T
                        
                           C4 are shown in Eqs. (28) and (29) where h
                        
                           two-neig-a
                         is the distance from the next hop to the nearest common ancestor and h
                        
                           two-dest-a
                         is the distance from the destination to the ancestor.
                           
                              (22)
                              
                                 
                                    R
                                    
                                       C
                                       1
                                    
                                 
                                 =
                                 
                                    d
                                    neig
                                 
                              
                           
                        
                        
                           
                              (23)
                              
                                 
                                    T
                                    
                                       C
                                       1
                                    
                                 
                                 =
                                 
                                    R
                                    
                                       C
                                       1
                                    
                                 
                                 ⋅
                                 t
                              
                           
                        
                        
                           
                              (24)
                              
                                 
                                    R
                                    
                                       C
                                       2
                                    
                                 
                                 =
                                 2
                                 
                                    d
                                    neig
                                 
                              
                           
                        
                        
                           
                              (25)
                              
                                 
                                    T
                                    
                                       C
                                       2
                                    
                                 
                                 =
                                 
                                    R
                                    
                                       C
                                       2
                                    
                                 
                                 ⋅
                                 t
                              
                           
                        
                        
                           
                              (26)
                              
                                 
                                    R
                                    
                                       C
                                       3
                                    
                                 
                                 =
                                 
                                    h
                                    
                                       one
                                       ‐
                                       neig
                                       ‐
                                       a
                                    
                                 
                                 +
                                 
                                    h
                                    
                                       one
                                       ‐
                                       dest
                                       ‐
                                       a
                                    
                                 
                                 +
                                 1
                              
                           
                        
                        
                           
                              (27)
                              
                                 
                                    T
                                    
                                       C
                                       3
                                    
                                 
                                 =
                                 
                                    R
                                    
                                       C
                                       3
                                    
                                 
                                 ⋅
                                 t
                              
                           
                        
                        
                           
                              (28)
                              
                                 
                                    R
                                    
                                       C
                                       4
                                    
                                 
                                 =
                                 
                                    h
                                    
                                       two
                                       ‐
                                       neig
                                       ‐
                                       a
                                    
                                 
                                 +
                                 
                                    h
                                    
                                       two
                                       ‐
                                       dest
                                       ‐
                                       a
                                    
                                 
                                 +
                                 2
                              
                           
                        
                        
                           
                              (29)
                              
                                 
                                    T
                                    
                                       C
                                       4
                                    
                                 
                                 =
                                 
                                    R
                                    
                                       C
                                       4
                                    
                                 
                                 ⋅
                                 t
                              
                           
                        
                     

The existing work in [6] is selected to compare with our work due to the following reasons:
                           
                              1)
                              The existing work in [6] presents the latest addressing-based routing solution.

The existing work in [6] is based on a tree topology.

In the existing work [6], a node is configured with an address by joining a tree, and then performs communications along the tree. That is, the work in [6] achieves the routing along a tree. Therefore, the routing path length R
                        
                           existing
                         is shown in Eq. (30) where h
                        
                           source-a
                         is the distance from a source to the nearest common ancestor and h
                        
                           dest-a
                         is the distance from a destination to the nearest common ancestor.
                           
                              (30)
                              
                                 
                                    R
                                    existing
                                 
                                 =
                                 
                                    h
                                    
                                       source
                                       ‐
                                       a
                                    
                                 
                                 +
                                 
                                    h
                                    
                                       dest
                                       ‐
                                       a
                                    
                                 
                              
                           
                        
                     

In Case 1:
                           
                              
                                 
                                    
                                       
                                          
                                             R
                                             existing
                                          
                                          –
                                          
                                             R
                                             
                                                C
                                                1
                                             
                                          
                                          =
                                          
                                             h
                                             
                                                source
                                                ‐
                                                a
                                             
                                          
                                          +
                                          
                                             h
                                             
                                                dest
                                                ‐
                                                a
                                             
                                          
                                          –
                                          
                                             d
                                             neig
                                          
                                       
                                    
                                    
                                       
                                          ∵
                                          
                                             h
                                             
                                                source
                                                ‐
                                                a
                                             
                                          
                                          +
                                          
                                             h
                                             
                                                dest
                                                ‐
                                                a
                                             
                                          
                                          ≥
                                          
                                             d
                                             neig
                                          
                                       
                                    
                                    
                                       
                                          ∴
                                          
                                             R
                                             existing
                                          
                                          ≥
                                          
                                             R
                                             
                                                C
                                                1
                                             
                                          
                                          .
                                       
                                    
                                 
                              
                           
                        
                     

In Case 2:
                           
                              
                                 
                                    
                                       
                                          
                                             R
                                             existing
                                          
                                          –
                                          
                                             R
                                             
                                                C
                                                2
                                             
                                          
                                          =
                                          
                                             h
                                             
                                                source
                                                ‐
                                                a
                                             
                                          
                                          +
                                          
                                             h
                                             
                                                dest
                                                ‐
                                                a
                                             
                                          
                                          ‐
                                          2
                                          
                                             d
                                             neig
                                          
                                       
                                    
                                    
                                       
                                          ∵
                                          
                                             h
                                             
                                                source
                                                ‐
                                                a
                                             
                                          
                                          +
                                          
                                             h
                                             
                                                dest
                                                ‐
                                                a
                                             
                                          
                                          ≥
                                          2
                                          
                                             d
                                             neig
                                          
                                       
                                    
                                    
                                       
                                          ∴
                                          
                                             R
                                             existing
                                          
                                          ≥
                                          
                                             R
                                             
                                                C
                                                2
                                             
                                          
                                          .
                                       
                                    
                                 
                              
                           
                        
                     

In Case 3:
                           
                              
                                 
                                    R
                                    existing
                                 
                                 −
                                 
                                    R
                                    
                                       C
                                       3
                                    
                                 
                                 =
                                 
                                    h
                                    
                                       source
                                       ‐
                                       a
                                    
                                 
                                 +
                                 
                                    h
                                    
                                       dest
                                       ‐
                                       a
                                    
                                 
                                 –
                                 
                                    
                                       
                                          h
                                          
                                             one
                                             ‐
                                             neig
                                             ‐
                                             a
                                          
                                       
                                       +
                                       
                                          h
                                          
                                             one
                                             ‐
                                             dest
                                             ‐
                                             a
                                          
                                       
                                       +
                                       1
                                    
                                 
                                 .
                              
                           
                        
                     

Based on Eq. (4),
                           
                              
                                 
                                    
                                       
                                          
                                             h
                                             
                                                source
                                                ‐
                                                a
                                             
                                          
                                          +
                                          
                                             h
                                             
                                                dest
                                                ‐
                                                a
                                             
                                          
                                          −
                                          1
                                          ≥
                                          
                                             h
                                             
                                                one
                                                ‐
                                                neig
                                                ‐
                                                a
                                             
                                          
                                          +
                                          
                                             h
                                             
                                                one
                                                ‐
                                                dest
                                                ‐
                                                a
                                             
                                          
                                       
                                    
                                    
                                       
                                          ⇒
                                          
                                             h
                                             
                                                source
                                                ‐
                                                a
                                             
                                          
                                          +
                                          
                                             h
                                             
                                                dest
                                                ‐
                                                a
                                             
                                          
                                          ≥
                                          
                                             h
                                             
                                                one
                                                ‐
                                                neig
                                                ‐
                                                a
                                             
                                          
                                          +
                                          
                                             h
                                             
                                                one
                                                ‐
                                                dest
                                                ‐
                                                a
                                             
                                          
                                          +
                                          1
                                       
                                    
                                    
                                       
                                          ⇒
                                          
                                             R
                                             existing
                                          
                                          ≥
                                          
                                             R
                                             
                                                C
                                                3
                                             
                                          
                                          .
                                       
                                    
                                 
                              
                           
                        
                     

In Case 4:
                           
                              
                                 
                                    R
                                    existing
                                 
                                 –
                                 
                                    R
                                    
                                       C
                                       4
                                    
                                 
                                 =
                                 
                                    h
                                    
                                       source
                                       ‐
                                       a
                                    
                                 
                                 +
                                 
                                    h
                                    
                                       dest
                                       ‐
                                       a
                                    
                                 
                                 –
                                 
                                    
                                       
                                          h
                                          
                                             two
                                             ‐
                                             neig
                                             ‐
                                             a
                                          
                                       
                                       +
                                       
                                          h
                                          
                                             two
                                             ‐
                                             dest
                                             ‐
                                             a
                                          
                                       
                                       +
                                       2
                                    
                                 
                                 .
                              
                           
                        
                     

Based on Eq. (5),
                           
                              
                                 
                                    
                                       
                                          
                                             h
                                             
                                                source
                                                ‐
                                                a
                                             
                                          
                                          +
                                          
                                             h
                                             
                                                dest
                                                ‐
                                                a
                                             
                                          
                                          −
                                          2
                                          ≥
                                          
                                             h
                                             
                                                two
                                                ‐
                                                neig
                                                ‐
                                                a
                                             
                                          
                                          +
                                          
                                             h
                                             
                                                two
                                                ‐
                                                dest
                                                ‐
                                                a
                                             
                                          
                                       
                                    
                                    
                                       
                                          ⇒
                                          
                                             h
                                             
                                                source
                                                ‐
                                                a
                                             
                                          
                                          +
                                          
                                             h
                                             
                                                dest
                                                ‐
                                                a
                                             
                                          
                                          ≥
                                          
                                             h
                                             
                                                one
                                                ‐
                                                neig
                                                ‐
                                                a
                                             
                                          
                                          +
                                          
                                             h
                                             
                                                one
                                                ‐
                                                dest
                                                ‐
                                                a
                                             
                                          
                                          +
                                          2
                                       
                                    
                                    
                                       
                                          ⇒
                                          
                                             R
                                             existing
                                          
                                          ≥
                                          
                                             R
                                             
                                                C
                                                4
                                             
                                          
                                          .
                                       
                                    
                                 
                              
                           
                        
                     

From the above analysis, it can be seen that this scheme has a shorter path length than the existing scheme.

NS-2 is used to evaluate the performance of this scheme and the simulation parameters are shown in Table 2
                     .

The addressing cost and latency are evaluated, as shown in Fig. 7
                        .

The addressing process consists of the FFD addressing and RFD addressing. From Fig. 7, it can be seen that the FFD addressing cost is nearly the same as the RFD one. The main reason is that either an RFD or an FFD obtains an address from a neighbor. As shown in Fig. 7, when the number of nodes is smaller than 32, the FFD addressing delay is greater than the RFD one and slightly grows with the FFD population. The reason is that the depth of an address tree has a slight increment with the FFD population. When the node population is greater than 32, the FFD addressing latency is smaller than the RFD one and tends to be stable. The main reason is that the tree depth tends to be stable when the FFD population is greater than 32. With the growth in RFD population, the number of RFDs associated with one FFD also grows, so the RFD addressing latency has also an increment.

The address configuration cost and latency are compared with the address update ones, as shown in Fig. 8
                        .

From Fig. 8, it can be seen that the address update cost is much smaller than the address configuration one. In the address configuration, the addressing cost increases with the node population. In the address update, the update cost has a slight increment with node population when the node population is smaller than 15. When the node population is greater than 15, the update cost tends to be stable. The address configuration delay is slightly greater than the address update one. The main reason is that the address configuration is achieved in the request-response mode whereas the address update is performed in the normal beacon routine.

The routing performance is evaluated, as shown in Fig. 9
                         where h is the sum of the distance from the source to the nearest common ancestor and the distance from the destination to the nearest common ancestor.

As shown in Fig. 9, in C1 and C2, the routing path length and delay are hardly affected by h. The main reason is that in these two cases the destination is the source's one-hop or two-hop neighbor and the source can directly forward the frame to the destination. In C3 and C4, the routing path length and delay slightly increase with h and tend to be equal. This means that C3 and C4 have the same optimization effect on routing.

This scheme is compared with existing scheme [6], as shown in Figs. 10–12
                        
                        
                        .

In this scheme, a node acquires an address from the neighbor, so the addressing cost and delay are hardly affected by node population and tend to be stable, as shown in Fig. 10. In the existing scheme, after a node acquires an address, it needs to register the address with the AR. As a result, the addressing cost and delay are greater than the ones in this scheme. With the growth in node population, the registration cost and delay slightly increase, so the address cost and delay also slightly grow.

In this scheme, the address update process is also the routing path recovery process. From Fig. 11, it can be seen that the address update cost and delay in this scheme are smaller than the address reconfiguration ones in the existing scheme. The main reason is that the address update is performed via receiving beacons whereas the address reconfiguration is achieved via the addressing and registration. As shown in Fig. 12, the routing path length and latency in this scheme and existing scheme grow with h, and the length and latency in the existing scheme are greater than the ones in this scheme. In the existing scheme the routing is performed along a tree, but the routing along a tree is sometimes not optimal. In this scheme, the one-hop and two-hop neighbor tables are used to obtain the optimal paths, so the route length and delay are smaller.

In the existing scheme, if a node fails, then its descendants must rejoin a tree and reacquire a new address. Before the descendants join a tree, they cannot communicate with other nodes. In this scheme, if a node fails, its descendants can use the original address to communicate with other nodes. In the simulation, an FFD is randomly selected and becomes failed, and the simulation data show that the probability of its descendants successfully performing the communications is 94.5%.

To sum up, this scheme has better addressing and routing performances because of the following reasons:
                           
                              1)
                              In the existing scheme, after a node is configured with an address it registers the address with the AR. In this scheme, a node obtains an address from its neighbor and does not register the address.

In the existing scheme, the routing is performed along a tree, but the routes along a tree are not optimal sometimes. In this scheme, the one-hop and two-hop neighbor tables are used to calculate the optimal routes.

In the existing scheme, if a node fails, then its descendants must reacquire an address and register this address. During the address reacquisition process, the descendants cannot communicate. In this scheme, the descendants of a failed node update their addresses instead of reacquiring the addresses and can still use the original address to communicate with other nodes.

@&#CONCLUSIONS@&#

In this paper, we look into the addressing-based routing schemes. Based on the observations that the routing paths along a tree topology are not always optimal and the resources of nodes around a root are excessively consumed, we are motivated to utilize one-hop and two-hop neighbors to optimize routing paths. Based on this idea, we propose an optimal addressing-based routing scheme. This scheme is evaluated to justify its advantages. The data results show that one-hop and two-hop neighbors can effectively optimize routing paths and a root is not involved in most of optimal paths. As a result, the routing latency is reduced and the excessive resource consumption is avoided.

In our future work, we are going to take advantage of AR's computing capabilities and storage resources to exploit its potential for assisting routing for 6LoWPAN.

@&#ACKNOWLEDGMENTS@&#

This work is supported by Jiangsu Provincial Natural Science Foundation (BK20141230) and National Natural Science Foundation of China (61202440).

@&#REFERENCES@&#

