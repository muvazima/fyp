@&#MAIN-TITLE@&#The discrete time window assignment vehicle routing problem

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We provide a time window assignment model in a VRP setting with demand uncertainty.


                        
                        
                           
                           We develop a state-of-the-art exact branch-price-and-cut method.


                        
                        
                           
                           We develop column generation heuristics for good solutions in large instances.


                        
                        
                           
                           Numerical experiments show that using multiple demand scenarios is better than one.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Vehicle routing

Time window assignment

Column generation

Uncertain demand

@&#ABSTRACT@&#


               
               
                  In this paper we introduce the discrete time window assignment vehicle routing problem (DTWAVRP) that can be viewed as a two-stage stochastic optimization problem. Given a set of customers that must be visited on the same day regularly within some period of time, the first-stage decisions are to assign to each customer a time window from a set of candidate time windows before demand is known. In the second stage, when demand is revealed for each day of the time period, vehicle routes satisfying vehicle capacity and the assigned time windows are constructed. The objective of the DTWAVRP is to minimize the expected total transportation cost. To solve this problem, we develop an exact branch-price-and-cut algorithm and derive from it five column generation heuristics that allow to solve larger instances than those solved by the exact algorithm. We illustrate the performance of these algorithms by means of computational experiments performed on randomly generated instances.
               
            

@&#INTRODUCTION@&#

In distribution networks, it is common for a supplier and a customer to agree on a time window in which a delivery will be made. This time window is often used repeatedly within some period of time in which multiple deliveries are made at regular intervals. At the moment of choosing a time window for a customer, its demand is usually unknown and may fluctuate for different deliveries. When the demands of all customers become known for a given day, a vehicle routing problem with time windows (VRPTW) must be solved to construct a delivery schedule within the agreed time windows.

The time window assignment vehicle routing problem (TWAVRP) was recently introduced by Spliet and Gabor (2014). This problem can be viewed as a two-stage stochastic optimization problem (see Birge and Louveaux, 1997). Given a set of customers to be visited on the same day regularly during some period of time (e.g., a season), the TWAVRP consists of assigning in the first stage a time window to each customer before customer demand is known. In the second stage, when demand is revealed for each day of the time period, vehicle routes that respect the assigned time windows are constructed. The assigned time windows have a predetermined width and can start at any time within an exogenous time window that can be customer-dependent. The objective of the TWAVRP is to minimize the expected total transportation cost over the whole time period that is equivalent to minimizing the expected cost for a single day.

In this paper, we study the discrete TWAVRP (DTWAVRP) that differs from the TWAVRP by considering for each customer a finite set of candidate time windows from which one has to be selected. For example, a customer might divide the day in blocks of 2 hours commencing on the hour and require one of these blocks to be the assigned time window. We have encountered such time window assignment problems (discrete or not) while collaborating with Dutch retail chains, and believe they are common in this industry. Here, the retailers (customers) are heavily dependent on the time window to be fixed in advance and kept for some time. For instance, a retailer might receive all its deliveries on the same day of the week and more or less the same hour of the day for an entire year. This is crucial for many operational purposes like inventory management and the scheduling of personnel. Considering a discrete set of time windows is often more practical for the retailers, especially to ease the personnel scheduling process which must take into account various regulations. Furthermore, it can give them the opportunity to express preferences for the time windows. Maximizing the satisfaction of these preferences might be taken into account as a secondary objective during the optimization process, an option that is not considered in this paper.

As is common for two-stage stochastic optimization problems, we suggest to approximate the probability distributions of the customer demands by a finite set of possible scenarios of demand realizations. In this framework, the DTWAVRP is clearly NP-hard as, in the case of one scenario and one candidate time window per customer, it reduces to the VRPTW. When it involves several scenarios, the DTWAVRP corresponds to solving several VRPTWs (one per scenario) that are linked together by the choice of the time windows. The VRPTW is a well-studied problem for which many exact and heuristic algorithms have been developed (see, e.g., the surveys of Baldacci, Mingozzi, and Roberti, 2012; Bräysy and Gendreau, 2005a; 2005b; Kallehauge, Larsen, Madsen, and Solomon, 2005).

We believe that in the scientific literature, the problem of assigning time windows before knowing demand has been largely overlooked so far. It was only tackled recently by Spliet and Gabor (2014) who designed an exact branch-price-and-cut algorithm for the TWAVRP that can solve instances with up to 25 customers and three scenarios. In their solution approach, the pricing problem is modeled as an elementary shortest path problem with linear node costs (induced because the set of time windows is not discrete) and capacity and time window constraints. Due to the complexity of this problem route relaxation is required, but only basic route relaxation can be utilized efficiently: allowing all cyclic routes and eliminating 2-cycles. For the DTWAVRP we also develop a branch-price-and-cut algorithm, but in this case we are able to employ the more sophisticated ng-route relaxation introduced by Baldacci, Mingozzi, and Roberti (2011). The complexity of the pricing problem of Spliet and Gabor (2014) also prohibits the use of certain types of valid inequalities as these add to the complexity. For instance subset row inequalities, introduced by Jepsen, Petersen, Spoorendonk, and Pisinger (2008), are not used in the algorithm for the TWAVRP, whereas they are used in our algorithm for the DTWAVRP. Furthermore, as opposed to the algorithm for the TWAVRP, we add a heuristic pricing algorithm to speed up computations and develop several column generation heuristics.

Introduced by Groër, Golden, and Wasil (2009), the consistent vehicle routing problem (ConVRP) shares some similarities with the DTWAVRP when considering demand scenarios. In this deterministic problem, each customer must be visited on different days of a given horizon (not all customers must be serviced each day) following a consistent schedule, that is, the arrival times at a customer from one day to another cannot differ by more than a limited amount of time. Moreover, it is required that each customer is always visited by the same driver. Groër et al. (2009) found optimal solutions to ConVRP instances involving up to 12 customers and three scenarios using a commercial mixed integer programming solver. They reported computation times of up to several days. Furthermore, they developed a local search heuristic to solve instances with over 3700 customers.


                     Jabali, Leus, van Woensel, and de Kok (2013) considered another related problem that involves the assignment of time windows in a vehicle routing problem with stochastic travel times and deterministic demands. They developed a tabu search algorithm for solving it. Also, Agatz, Campbell, Fleischmann, and Savelsbergh (2011) studied a stochastic problem faced by e-tailers providing home delivery that consists of selecting which time slots to offer per zip code for making deliveries. They developed a local search heuristic.

The main contributions of this paper are as follows. First, we propose a new problem, the DTWAVRP. Second, we develop a state-of-the-art exact branch-price-and-cut algorithm to solve it and report computational results obtained on randomly generated instances to evaluate the effectiveness of some of its components. Third, from this exact algorithm, we derive several column generation heuristics that can find good solutions to the DTWAVRP in limited computation times. This allows to find solutions to instances that are larger than those solved by the exact algorithm. We report computational results to compare the performance of five such algorithms. Finally, we also provide additional results to assess the benefits of using several demand scenarios to assign time windows to the customers instead of using a single one defined by the average demands as it is usually done in practice.

In the next section, we define the DTWAVRP using demand scenarios and we present an integer programming formulation for it. In Section 3, we introduce the proposed branch-price-and-cut algorithm. In Section 4, we describe the five column generation heuristics. The results of our computational experiments are reported in Section 5. Finally, conclusions are drawn in Section 6.

Consider a complete graph G = (N, A), where N = {0, …, n + 1} is a set of locations such that 0 and n + 1 represent the depot at the start and the end of a day, respectively, and N′ = {1, …, n} the set of customers. Let cij
                      ≥ 0 be the cost to travel along arc (i, j) and tij
                      ≥ 0 the corresponding travel time (including, if any, the service time at i). Both the travel costs and travel times satisfy the triangle inequality. Furthermore, an unlimited number of vehicles of equal capacity Q is available.

Let the random variable 
                        
                           d
                           i
                        
                      with known distribution represent the demand of customer i ∈ N′. We distinguish between two stages, in the first stage the demand realization is not yet known, but in the second stage it is. Furthermore, the realization di
                      of demand is such that 0 < di
                      ≤ Q.

Associate with each customer i a set Wi
                      of candidate time windows that may or may not overlap. In the first stage, one time window 
                        
                           w
                           =
                           
                              [
                              
                                 w
                                 ̲
                              
                              ,
                              
                                 w
                                 ¯
                              
                              ]
                           
                           ∈
                           
                              W
                              i
                           
                        
                      must be selected for each customer such that service at customer i starts between 
                        w
                      and 
                        
                           w
                           ¯
                        
                     . For the starting and ending depot only one time window exists. Note that waiting at a location is allowed, i.e., a vehicle can arrive prior to the time window lower bound and start service later.

The DTWAVRP is a two-stage stochastic programming problem that consists of assigning one time window to each customer in the first stage and determining in the second stage an optimal vehicle routing schedule satisfying the assigned time windows. The expected total travel cost must be minimized.

We can express the DTWAVRP more formally as follows. Let yiw
                     , for i ∈ N′ and w ∈ Wi
                     , be the time window assignment variables. These are the first-stage decision variables indicating whether time window w is selected for customer i. Note that we do not associate costs with the first-stage decisions. We denote by VRPTW(y, d) the minimal transportation costs as a function of a time window assignment described by y and demand d. This is the recourse function that provides the second stage costs which are obtained by solving the corresponding VRPTW to optimality. Below we first introduce additional notation to express VRPTW(y, d) using a set-partitioning formulation.

Using the set of candidate time windows for each customer, we can construct an auxiliary graph 
                        
                           
                              G
                              ^
                           
                           =
                           
                              (
                              
                                 N
                                 ^
                              
                              ,
                              
                                 A
                                 ^
                              
                              )
                           
                           ,
                        
                      where 
                        
                           
                              N
                              ^
                           
                           =
                           
                              {
                              
                                 (
                                 i
                                 ,
                                 w
                                 )
                              
                              
                              |
                              
                              i
                              ∈
                              N
                              ,
                              w
                              ∈
                              
                                 W
                                 i
                              
                              }
                           
                        
                      contains a copy of each customer node i for each of its possible time windows w ∈ Wi
                     . Moreover, 
                        
                           A
                           ^
                        
                      contains an arc between two nodes (i, w) and (i′, w′), i ≠ i′, if and only if 
                        
                           
                              w
                              ̲
                           
                           +
                           
                              t
                              
                                 i
                                 
                                    i
                                    ′
                                 
                              
                           
                           ≤
                           
                              
                                 w
                                 ¯
                              
                              ′
                           
                        
                     .

We use the term route to refer to a pair 
                        
                           (
                           
                              P
                              ^
                           
                           ,
                           t
                           )
                        
                      where 
                        
                           P
                           ^
                        
                      is a path in 
                        
                           G
                           ^
                        
                      starting at 0 and ending at n + 1 and t is a vector containing the service start time at each location on the path. Associated with each route r is the parameter eiwr
                      indicating the number of times customer i is visited within time window w ∈ Wi
                      on route r (note that eiwr
                      ∈ {0, 1} if P is an elementary path). To each route r whose path contains the arcs {a
                     1, …, ak
                     } we assign the cost 
                        
                           
                              c
                              r
                           
                           =
                           
                              ∑
                              
                                 i
                                 =
                                 1
                              
                              k
                           
                           
                              c
                              
                                 a
                                 i
                              
                           
                        
                     .

Let R(d) be the set of all feasible routes corresponding to demand realization d. A route 
                        
                           (
                           
                              P
                              ^
                           
                           ,
                           t
                           )
                        
                      is considered feasible if (i) it satisfies the capacity constraint, (ii) t is such that, for each customer i on the route, service begins within a time window in Wi
                     , and (iii) if location j is visited directly after i on route r then ti
                      + tij
                      ≤ tj
                     .

Let the variables xr, r ∈ R(d), be route variables indicating whether route r is selected. We formulate the recourse function VRPTW(y, d) using the following set-partitioning formulation.

                        
                           (1)
                           
                              
                                 
                                    
                                       
                                          VRPTW
                                          (
                                          y
                                          ,
                                          d
                                          )
                                       
                                    
                                    
                                       =
                                    
                                    
                                       
                                          min
                                          
                                          
                                          
                                             ∑
                                             
                                                r
                                                ∈
                                                R
                                                (
                                                d
                                                )
                                             
                                          
                                          
                                             c
                                             r
                                          
                                          
                                             x
                                             r
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (2)
                           
                              
                                 
                                    
                                       s.t.
                                    
                                    
                                    
                                       
                                          
                                             ∑
                                             
                                                r
                                                ∈
                                                R
                                                (
                                                d
                                                )
                                             
                                          
                                          
                                             e
                                             
                                                i
                                                w
                                                r
                                             
                                          
                                          
                                             x
                                             r
                                          
                                          =
                                          
                                             y
                                             
                                                i
                                                w
                                             
                                          
                                          
                                          ∀
                                          i
                                          ∈
                                          
                                             N
                                             ′
                                          
                                          ,
                                          
                                          
                                          ∀
                                          w
                                          ∈
                                          
                                             W
                                             i
                                          
                                          ,
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (3)
                           
                              
                                 
                                    
                                    
                                    
                                       
                                          
                                             x
                                             r
                                          
                                          ∈
                                          
                                             {
                                             0
                                             ,
                                             1
                                             }
                                          
                                          
                                          ∀
                                          r
                                          ∈
                                          R
                                          
                                             (
                                             d
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                  

The objective function (1) represents total traveling costs. Constraints (2) impose that each customer is visited exactly once within the selected time window as indicated by y. Note that all constraints (2) for which yiw
                      takes value 0 can be removed if the set R(d) is filtered accordingly. Finally, (3) are the integrality requirements on the x variables.

Using the recourse function VRPTW(y, d) and denoting by E the expected value function, the DTWAVRP can be formulated as the following minimization problem:

                        
                           (4)
                           
                              
                                 
                                    
                                       
                                          min
                                          
                                       
                                    
                                    
                                    
                                       
                                          E
                                          (
                                          VRPTW
                                          (
                                          y
                                          ,
                                          d
                                          )
                                          )
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (5)
                           
                              
                                 
                                    
                                       
                                          s.t.
                                          
                                       
                                    
                                    
                                    
                                       
                                          
                                             ∑
                                             
                                                w
                                                ∈
                                                
                                                   W
                                                   i
                                                
                                             
                                          
                                          
                                             y
                                             
                                                i
                                                w
                                             
                                          
                                          =
                                          1
                                          
                                          ∀
                                          i
                                          ∈
                                          
                                             N
                                             ′
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (6)
                           
                              
                                 
                                    
                                    
                                    
                                       
                                          
                                             y
                                             
                                                i
                                                w
                                             
                                          
                                          ∈
                                          
                                             {
                                             0
                                             ,
                                             1
                                             }
                                          
                                          
                                          ∀
                                          i
                                          ∈
                                          
                                             N
                                             ′
                                          
                                          ,
                                          
                                          ∀
                                          w
                                          ∈
                                          
                                             W
                                             i
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                  

Here, the objective function (4) aims at minimizing the expected costs. Constraints (5) ensure that for every customer exactly one time window is selected and (6) are the integrality requirements on the y variables.

We assume in this paper that the demand follows a discrete distribution and present next the deterministic equivalent problem (DEP) of the DTWAVRP. We do this for the following two reasons. First, in many applications goods are delivered in integer amounts, on pallets or in roll cages. Hence only a finite (but possibly large) number of demand realizations are possible. Second, the DEP can also be used for a sample average approximation strategy when the number of realizations is too large or demand follows a continuous distribution. In this case exact optimization can likely not be done in a limited amount of computation time due to the complexity of the recourse function, which entails solving a VRPTW.

To present the DEP we introduce S which is a set of demand scenarios, where each scenario is characterized by a realization of the demand at every customer. Let 
                           
                              d
                              i
                              s
                           
                         be the demand of customer i in scenario s ∈ S such that 
                           
                              0
                              <
                              
                                 d
                                 i
                                 s
                              
                              ≤
                              Q
                           
                        . The probability that scenario s occurs is ps
                        . For ease of notation, we replace R(ds
                        ) by R(s) to denote the set of feasible routes corresponding to realization ds
                        .

Introducing the variables 
                           
                              
                                 x
                                 r
                                 s
                              
                              ,
                           
                         
                        s ∈ S, r ∈ R(s), as the route variables indicating whether route r is selected in scenario s, the DEP of the DTWAVRP can be formulated as the following integer linear program.

                           
                              (7)
                              
                                 
                                    
                                       
                                          
                                             min
                                             
                                          
                                       
                                       
                                       
                                          
                                             
                                                ∑
                                                
                                                   s
                                                   ∈
                                                   S
                                                
                                             
                                             
                                                p
                                                s
                                             
                                             
                                                ∑
                                                
                                                   r
                                                   ∈
                                                   R
                                                   (
                                                   s
                                                   )
                                                
                                             
                                             
                                             
                                                c
                                                r
                                             
                                             
                                                x
                                                r
                                                s
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (8)
                              
                                 
                                    
                                       
                                          
                                             s.t.
                                             
                                          
                                       
                                       
                                       
                                          
                                             
                                                ∑
                                                
                                                   w
                                                   ∈
                                                   
                                                      W
                                                      i
                                                   
                                                
                                             
                                             
                                                y
                                                
                                                   i
                                                   w
                                                
                                             
                                             =
                                             1
                                             
                                             ∀
                                             i
                                             ∈
                                             
                                                N
                                                ′
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (9)
                              
                                 
                                    
                                       
                                       
                                       
                                          
                                             
                                                ∑
                                                
                                                   r
                                                   ∈
                                                   R
                                                   (
                                                   s
                                                   )
                                                
                                             
                                             
                                                e
                                                
                                                   i
                                                   w
                                                   r
                                                
                                             
                                             
                                                x
                                                r
                                                s
                                             
                                             =
                                             
                                                y
                                                
                                                   i
                                                   w
                                                
                                             
                                             
                                             
                                             ∀
                                             i
                                             ∈
                                             
                                                N
                                                ′
                                             
                                             ,
                                             
                                             
                                             ∀
                                             w
                                             ∈
                                             
                                                W
                                                i
                                             
                                             ,
                                             
                                             ∀
                                             s
                                             ∈
                                             S
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (10)
                              
                                 
                                    
                                       
                                       
                                       
                                          
                                             
                                                x
                                                r
                                                s
                                             
                                             ∈
                                             
                                                {
                                                0
                                                ,
                                                1
                                                }
                                             
                                             
                                             ∀
                                             s
                                             ∈
                                             S
                                             ,
                                             
                                             ∀
                                             r
                                             ∈
                                             R
                                             
                                                (
                                                s
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (11)
                              
                                 
                                    
                                       
                                       
                                       
                                          
                                             
                                                y
                                                
                                                   i
                                                   w
                                                
                                             
                                             ∈
                                             
                                                {
                                                0
                                                ,
                                                1
                                                }
                                             
                                             
                                             ∀
                                             i
                                             ∈
                                             
                                                N
                                                ′
                                             
                                             ,
                                             
                                             ∀
                                             w
                                             ∈
                                             
                                                W
                                                i
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The objective function (7) minimizes the expected costs over all scenarios resulting from a time window assignment. Constraints (8) ensure that exactly one time window is selected for each customer. Constraints (9) enforce that each customer is visited exactly once within its selected time window in each scenario. Integrality requirements on the x and y variables are provided by (10) and (11).

Next, let us discuss how to reformulate the integrality requirements. Consider the linear programming (LP) relaxation of formulation (7)–(11) where the integrality requirements on the x and y variables are relaxed continuously. For each scenario, let the arc flow in 
                           
                              G
                              ^
                           
                         be the cumulative value by which each arc 
                           
                              a
                              ∈
                              
                                 A
                                 ^
                              
                           
                         is selected in a solution to this LP relaxation. More precisely, if 
                           
                              e
                              a
                              r
                           
                         represents the number of times route r traverses arc a, the arc flow in 
                           
                              G
                              ^
                           
                         on arc a in scenario s is given by 
                           
                              
                                 
                                    F
                                    ^
                                 
                                 a
                                 s
                              
                              =
                              
                                 ∑
                                 
                                    r
                                    ∈
                                    R
                                    (
                                    s
                                    )
                                 
                              
                              
                                 e
                                 a
                                 r
                              
                              
                                 x
                                 r
                                 s
                              
                           
                        . It is straightforward that when the arc flow in 
                           
                              G
                              ^
                           
                         is integer for every scenario, it also provides an integer solution to the DTWAVRP.

Moreover, a solution to the LP relaxation also corresponds to an arc flow in G for each scenario. Observe that when the arc flow in 
                           
                              G
                              ^
                           
                         is integer for every scenario, so is the arc flow in G. However, when the arc flow in G is integer, the arc flow in 
                           
                              G
                              ^
                           
                         might not be. Nevertheless, in this case an integer solution can always be derived by selecting for each customer the time window with the earliest start time among the time windows that are fractionally selected in the LP relaxation. The corresponding routes can now straightforwardly be found using the integer arc flow in G and the selected time windows. This result is stated more formally in Proposition 1.

                           Proposition 1
                           
                              Let (x, y) be a solution to the LP relaxation of formulation 
                              (7)–(11). When the corresponding arc flow in Gis integer for every scenario, there exists an integer solution (x*, y*) to the DTWAVRP of equal value.

The proof of Proposition 1 can be found in Appendix A. In this proof, it is verified that the integer solution found as described above is indeed feasible. We would like to emphasize that integrality of the time window assignment variables is not required at all. Also, integrality of the arc flow in the auxiliary graph 
                           
                              G
                              ^
                           
                         is not required, but merely integer arc flow in the aggregate graph G. In the rest of this paper, we relax the integrality conditions (10) and (11), and instead only impose integrality on the arc flow in G. As a result, the amount of branching necessary in our algorithm is reduced.

In this section, we provide an exact algorithm to solve the DEP of the DTWAVRP. We first describe the column generation algorithm that we use to solve the LP relaxation of (7)–(11). In particular, we present the ng-route relaxation introduced by Baldacci et al. (2011) and discuss acceleration strategies to speed up the pricing algorithm. Next, we suggest valid inequalities to strengthen the LP bound. Finally, we describe the branch-price-and-cut algorithm.

In practice, the LP relaxation of (7)–(11), also called the master problem, contains a very large number of variables. To overcome this difficulty, we solve the master problem using a column generation algorithm as introduced by Ford and Fulkerson (1958) for multi-commodity flow problems and by Dantzig and Wolfe (1960) for general linear programming problems. This algorithm iteratively solves a restricted master problem (RMP) and a pricing problem. The RMP is the master problem where only a subset of the route variables are included. It is solved to find a feasible primal solution and the values of the dual multipliers associated with constraints (8) and (9). The pricing problem is solved to identify route variables with negative reduced costs that have not yet been added to the RMP. When a route with a negative reduced cost is identified, its variable is added to the RMP and the procedure is repeated. If no route with a negative reduced cost exists, the current solution to the RMP is also optimal for the master problem.

For the DTWAVRP, the pricing problem can be decoupled into several problems, one for each scenario. The pricing problem for scenario s aims at finding a feasible route for that scenario with the least reduced cost. Let λ be the vector of unrestricted dual multipliers associated with constraints (9). The reduced cost of a route r ∈ R(s) is given by

                           
                              (12)
                              
                                 
                                    
                                       p
                                       s
                                    
                                    
                                       c
                                       r
                                    
                                    −
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          
                                             N
                                             ′
                                          
                                       
                                    
                                    
                                       ∑
                                       
                                          w
                                          ∈
                                          
                                             W
                                             i
                                          
                                       
                                    
                                    
                                       λ
                                       
                                          i
                                          w
                                       
                                       s
                                    
                                    
                                       e
                                       
                                          i
                                          w
                                          r
                                       
                                    
                                    .
                                 
                              
                           
                        
                     

This pricing problem can be modeled as an elementary shortest path problem with resource constraints defined on network 
                           
                              G
                              ^
                           
                        . To do so, associate with each node 
                           
                              
                                 (
                                 i
                                 ,
                                 w
                                 )
                              
                              ∈
                              
                                 N
                                 ^
                              
                           
                         the demand 
                           
                              d
                              i
                              s
                           
                         and with each arc 
                           
                              
                                 (
                                 
                                    (
                                    i
                                    ,
                                    w
                                    )
                                 
                                 ,
                                 
                                    (
                                    
                                       i
                                       ′
                                    
                                    ,
                                    
                                       w
                                       ′
                                    
                                    )
                                 
                                 )
                              
                              ∈
                              
                                 A
                                 ^
                              
                           
                         the (reduced) cost 
                           
                              
                                 p
                                 s
                              
                              
                                 c
                                 
                                    i
                                    
                                       i
                                       ′
                                    
                                 
                              
                              −
                              
                                 λ
                                 
                                    
                                       i
                                       ′
                                    
                                    
                                       w
                                       ′
                                    
                                 
                                 s
                              
                           
                         and the travel time 
                           
                              t
                              
                                 i
                                 
                                    i
                                    ′
                                 
                              
                           
                        . The pricing problem consists of finding a shortest elementary (0, n + 1)-path in 
                           
                              G
                              ^
                           
                         that respects time windows and vehicle capacity (the resource constraints). Note, however, that elementarity is required for the customers. This means that for each customer i ∈ N′ at most one node 
                           
                              
                                 (
                                 i
                                 ,
                                 w
                                 )
                              
                              ∈
                              
                                 N
                                 ^
                              
                           
                         can be included in an elementary path.

To solve the pricing problem, we use the labeling algorithm proposed by Desrochers (1988) and enhanced by Feillet, Dejax, Gendreau, and Gueguen (2004) which we modify to consider elementarity of the customers instead of the nodes in network 
                           
                              G
                              ^
                           
                        . In this algorithm, constructed partial paths are represented by labels. Let l be a label representing a partial path from the starting depot to a specific node 
                           
                              
                                 (
                                 i
                                 ,
                                 w
                                 )
                              
                              ∈
                              
                                 N
                                 ^
                              
                           
                        . Let c(l) be the total reduced cost of the partial path represented by label l, t(l) its earliest start of service time at customer i in time window w, and q(l) its total load. Finally, let fj
                        (l), j ∈ N′, be a binary parameter equal to 1 if customer j has already been visited on the partial path associated with label l or if this path cannot be feasibly extended to reach any node representing customer j as this would violate capacity or time window constraints. In this respect, we define the function 
                           
                              
                                 U
                                 j
                                 s
                              
                              
                                 (
                                 l
                                 )
                              
                           
                         that takes value 1 if 
                           
                              q
                              
                                 (
                                 l
                                 )
                              
                              +
                              
                                 d
                                 j
                                 s
                              
                              >
                              Q
                           
                         or 
                           
                              t
                              
                                 (
                                 l
                                 )
                              
                              +
                              
                                 t
                                 
                                    i
                                    j
                                 
                              
                              >
                              
                                 w
                                 ¯
                              
                           
                         for all w ∈ Wj
                        , indicating whether l can be extended to j.

The labeling algorithm starts with a single label associated with depot node 0. Next, labels are extended along the arcs in 
                           
                              G
                              ^
                           
                        . A label l associated with a node (i, w) can be extended to a node (i′, w′) only if 
                           
                              
                                 (
                                 
                                    (
                                    i
                                    ,
                                    w
                                    )
                                 
                                 ,
                                 
                                    (
                                    
                                       i
                                       ′
                                    
                                    ,
                                    
                                       w
                                       ′
                                    
                                    )
                                 
                                 )
                              
                              ∈
                              
                                 A
                                 ^
                              
                           
                         and 
                           
                              
                                 f
                                 
                                    i
                                    ′
                                 
                              
                              
                                 (
                                 l
                                 )
                              
                              =
                              0
                           
                        . To perform this extension and create a label l′, we use the following extension functions:

                           
                              (13)
                              
                                 
                                    c
                                    
                                       (
                                       
                                          l
                                          ′
                                       
                                       )
                                    
                                    =
                                    c
                                    
                                       (
                                       l
                                       )
                                    
                                    +
                                    
                                       p
                                       s
                                    
                                    
                                       c
                                       
                                          i
                                          
                                             i
                                             ′
                                          
                                       
                                    
                                    −
                                    
                                       λ
                                       
                                          
                                             i
                                             ′
                                          
                                          
                                             w
                                             ′
                                          
                                       
                                       s
                                    
                                 
                              
                           
                        
                        
                           
                              (14)
                              
                                 
                                    s
                                    
                                       (
                                       
                                          l
                                          ′
                                       
                                       )
                                    
                                    =
                                    max
                                    
                                       {
                                       t
                                       
                                          (
                                          l
                                          )
                                       
                                       +
                                       
                                          t
                                          
                                             i
                                             
                                                i
                                                ′
                                             
                                          
                                       
                                       ,
                                       
                                          
                                             w
                                             ̲
                                          
                                          ′
                                       
                                       }
                                    
                                 
                              
                           
                        
                        
                           
                              (15)
                              
                                 
                                    q
                                    
                                       (
                                       
                                          l
                                          ′
                                       
                                       )
                                    
                                    =
                                    q
                                    
                                       (
                                       l
                                       )
                                    
                                    +
                                    
                                       d
                                       
                                          i
                                          ′
                                       
                                       s
                                    
                                 
                              
                           
                        
                        
                           
                              (16)
                              
                                 
                                    
                                       
                                          
                                             
                                                f
                                                j
                                             
                                             
                                                (
                                                
                                                   l
                                                   ′
                                                
                                                )
                                             
                                             =
                                             
                                                {
                                                
                                                   
                                                      
                                                         1
                                                      
                                                      
                                                         
                                                            if
                                                            
                                                            
                                                            j
                                                            =
                                                            
                                                               i
                                                               ′
                                                            
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            max
                                                            
                                                               {
                                                               
                                                                  f
                                                                  j
                                                               
                                                               
                                                                  (
                                                                  l
                                                                  )
                                                               
                                                               ,
                                                               
                                                                  U
                                                                  j
                                                                  s
                                                               
                                                               
                                                                  (
                                                                  
                                                                     l
                                                                     ′
                                                                  
                                                                  )
                                                               
                                                               }
                                                            
                                                         
                                                      
                                                      
                                                         otherwise
                                                      
                                                   
                                                
                                             
                                             
                                             ∀
                                             j
                                             ∈
                                             
                                                N
                                                ′
                                             
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        Label l′ is deemed feasible if 
                           
                              s
                              
                                 (
                                 
                                    l
                                    ′
                                 
                                 )
                              
                              ≤
                              
                                 
                                    w
                                    ′
                                 
                                 ¯
                              
                           
                        . Otherwise, it is discarded. Note that it is not necessary to check if q(l′) ≤ Q because 
                           
                              
                                 f
                                 
                                    i
                                    ′
                                 
                              
                              
                                 (
                                 l
                                 )
                              
                              =
                              0
                           
                        .

In order to avoid the enumeration of all partial paths, a dominance procedure is applied. The aim of this procedure is to remove all non-Pareto optimal labels. A label that is not Pareto optimal is said to be dominated. Label l′ is dominated if there exists a label l associated with the same customer and c(l) ≤ c(l′), t(l) ≤ t(l′), q(l) ≤ q(l′) and fj
                        (l) ≤ fj
                        (l′) for all j ∈ N′. We want to emphasize the fact that we check dominance for labels at the same customer instead of at the same node as we require elementarity for the customers and not for the nodes. This increases the number of dominated labels.

This labeling algorithm might provide multiple routes with negative reduced costs. In our implementation of the column generation algorithm, we add to the RMP all route variables with a negative reduced cost identified by the labeling algorithm.

As solving the elementary shortest path problem with resource constraints is computationally expensive, it is common to relax elementarity. Generating routes containing cycles and adding them to the formulation does not alter the optimal integer solution as each customer is visited exactly once. However, the LP bound becomes weaker. For the VRPTW, Desrochers, Desrosiers, and Solomon (1992) were the first to suggest a branch-and-price algorithm using a non-elementary shortest path problem as the pricing problem. They eliminate 2-cycles, i.e., cycles of the form i − j − i, to strengthen the LP bound at the expense of limited additional computation time. Irnich and Villeneuve (2006) extended this approach by providing an algorithm to solve the shortest path problem with resource constraints and k-cycle elimination, for arbitrary values of k.

Recently, Baldacci et al. (2011) proposed the ng-route relaxation. For each customer i ∈ N′ a neighborhood Ni
                        ⊆N′ with i ∈ Ni
                         is introduced. An ng-path is not necessarily an elementary path. Indeed, cycles starting and ending at a customer i are allowed if this cycle contains a customer i′ such that 
                           
                              i
                              ∉
                              
                                 N
                                 
                                    i
                                    ′
                                 
                              
                           
                        . Similar to, e.g., Baldacci et al. (2011) and Ribeiro, Desaulniers, and Desrosiers (2012), we construct neighborhoods of a fixed size Δng
                         for each customer i ∈ N′. They contain the closest customers with respect to travel costs, including i itself. This way, any cycle in an ng-path will be relatively long or expensive.

In our branch-price-and-cut algorithm we use the ng-route relaxation which means that not all routes might be elementary. We adjust the labeling algorithm for the elementary shortest path problem with resource constraints to solve a shortest ng-path problem with resource constraints by modifying the extension functions for the customer resources. When extending label l from a node (i, w) to (i′, w′) to create label l′, customer resource fj
                        (l′) is set to zero if 
                           
                              j
                              ∉
                              
                                 N
                                 
                                    i
                                    ′
                                 
                              
                           
                         even when fj
                        (l) = 1. Hence, expression (16) is replaced by:

                           
                              (17)
                              
                                 
                                    
                                       
                                          
                                             
                                                f
                                                j
                                             
                                             
                                                (
                                                
                                                   l
                                                   ′
                                                
                                                )
                                             
                                             =
                                             
                                                {
                                                
                                                   
                                                      
                                                         1
                                                      
                                                      
                                                         
                                                            if
                                                            
                                                            
                                                            j
                                                            =
                                                            
                                                               i
                                                               ′
                                                            
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            max
                                                            
                                                               {
                                                               
                                                                  f
                                                                  j
                                                               
                                                               
                                                                  (
                                                                  l
                                                                  )
                                                               
                                                               ,
                                                               
                                                                  U
                                                                  j
                                                                  s
                                                               
                                                               
                                                                  (
                                                                  
                                                                     l
                                                                     ′
                                                                  
                                                                  )
                                                               
                                                               }
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            if
                                                            
                                                            
                                                            j
                                                            ∈
                                                            
                                                               N
                                                               
                                                                  i
                                                                  ′
                                                               
                                                            
                                                            ∖
                                                            
                                                               {
                                                               
                                                                  i
                                                                  ′
                                                               
                                                               }
                                                            
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         0
                                                      
                                                      
                                                         otherwise
                                                      
                                                   
                                                
                                             
                                             
                                             ∀
                                             j
                                             ∈
                                             
                                                N
                                                ′
                                             
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        In this case, label l′ is declared feasible if 
                           
                              t
                              
                                 (
                                 
                                    l
                                    ′
                                 
                                 )
                              
                              ≤
                              
                                 
                                    w
                                    ′
                                 
                                 ¯
                              
                           
                         and q(l′) ≤ Q. Here the latter condition must be checked because it can be violated even if 
                           
                              
                                 f
                                 
                                    i
                                    ′
                                 
                              
                              
                                 (
                                 l
                                 )
                              
                              =
                              0
                           
                        .

During the label dominance check at a node 
                           
                              
                                 (
                                 i
                                 ,
                                 w
                                 )
                              
                              ∈
                              
                                 
                                    N
                                    ^
                                 
                                 ′
                              
                              ,
                           
                         only the customer resources for j ∈ Ni
                         need to be considered, that is, the dominance rule involves only the conditions fj
                        (l) ≤ fj
                        (l′), ∀j ∈ Ni
                        , for the customer resources. This is sufficient because fj
                        (l) = fj
                        (l′) = 0, ∀j ∈ N′∖Ni
                        . Using ng-paths typically increases the number of dominated labels and, thus, speeds up the labeling algorithm. Low values of Δng
                         yield a fast labeling algorithm at the expense of a decreased LP bound, whereas high values slow down the labeling algorithm but increase the value of the LP bound. Observe that all cycles are allowed in an ng-path when Δng
                         = 1, and only elementary paths are allowed when Δng
                         = n.

It is well known that, in a column generation algorithm, there is no need to solve the pricing problems to optimality at each iteration. As long as negative reduced cost columns are found, the pricing problems can be solved heuristically and it is even possible to skip some pricing problems. The algorithm remains exact if the pricing problems are solved to optimality in the last column generation iteration when solving a linear relaxation. Below, we discuss two strategies to potentially generate negative reduced cost columns in fast computation times.

At each iteration of the column generation algorithm, a pricing problem is solved for each scenario. Because these pricing problems are very similar, solutions to the pricing problem of one scenario might also be feasible for another. Reusing a solution in this way potentially decreases the number of pricing problems that have to be solved at each iteration. Therefore, we propose the column generation algorithm described in Algorithm 1
                           , in which routes are reused for other scenarios when they are feasible and have a negative reduced cost.

Note that the order in which the scenarios are solved at each iteration might affect the performance of the algorithm. However, in preliminary experiments, we tested different scenario selection strategies and none seems to outperform the others. The computational results presented in Section 5 were obtained by using a fixed order of the scenarios over all iterations. In our experiments this corresponds to the order in which the scenarios are generated as described in Section 5.1. This effectively means that the lowest demand scenario is selected first, followed by the second lowest, etc.

The column generation algorithm can be further accelerated by using a heuristic to solve the pricing problem. A heuristic might be able to identify feasible routes with negative reduced costs in less time than it takes to solve the pricing problem exactly. When using a heuristic at each iteration of the column generation algorithm, the exact algorithm is only used to find new routes or prove optimality when the heuristic fails.

As done by, e.g., Desaulniers, Lessard, and Hadjar (2008), we developed a tabu search algorithm to solve the pricing problem. In this algorithm an initial route is considered, which is iteratively replaced by a neighboring route. The neighborhood of each route contains all feasible elementary routes that can be obtained by performing one move. We consider two types of moves: adding a single node at any position in the route and removing a single node from the route.

At each iteration, the best neighbor in terms of reduced cost is selected as the new route. Note that this might yield a route with a larger reduced cost than that of the previous route. To avoid cycling, selecting the inverse of the move used to obtain the current route is tabu for TStabu iterations. If the reduced cost of the new route is negative, it is added to the RMP. To diversify the search, at every TSIt iterations, it is restarted using a completely new route. The initial route and those used to restart the search correspond to the routes selected in the current solution of the RMP for the scenario associated with the pricing problem. When such a route is not elementary, the first visit to each customer is maintained and all other visits to the same customer are removed from the route. The algorithm stops when all selected routes have been used to restart, or a total of TSmax new routes have been added to the RMP during the current search.

For the vehicle routing problem, many valid inequalities have been studied: for example, capacity, comb, hypotour and multistar inequalities (Lysgaard, Letchford, and Eglese, 2004), k-path inequalities (Kohl, Desrosiers, Madsen, Solomon, and Soumis, 1999) and subset row inequalities (Jepsen et al., 2008). These inequalities are also applicable to each scenario in the DTWAVRP.

We have tested all the above mentioned valid inequalities in our algorithm. However, preliminary experiments showed that adding capacity inequalities and subset row inequalities provide the lowest computation time. Below, we describe these inequalities in more detail.

Let δVr
                         be the number of times route r traverses an arc (i, j) such that i ∈ V and j∉V for V⊆N′. Let b(V) be the minimum number of vehicles needed to visit all customers in V⊆N′. The capacity inequalities are as follows:

                           
                              (18)
                              
                                 
                                    
                                       ∑
                                       
                                          r
                                          ∈
                                          R
                                          (
                                          s
                                          )
                                       
                                    
                                    
                                       δ
                                       
                                          V
                                          r
                                       
                                    
                                    
                                       x
                                       r
                                       s
                                    
                                    ≥
                                    b
                                    
                                       (
                                       V
                                       )
                                    
                                    
                                    
                                    ∀
                                    V
                                    ⊆
                                    
                                       N
                                       ′
                                    
                                    ,
                                    
                                    ∀
                                    s
                                    ∈
                                    S
                                 
                              
                           
                        As it is common, we replace b(V) by the lower bound 
                           
                              ⌈
                              
                                 
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          V
                                       
                                    
                                    
                                       d
                                       i
                                       s
                                    
                                 
                                 Q
                              
                              ⌉
                           
                        . The separation problem of these rounded capacity inequalities is strongly NP-hard. We use the heuristic of Lysgaard et al. (2004) to separate them, more precisely, we use the implementation that can be found in the package by Lysgaard (2003).

When capacity inequalities are added to the master problem, the pricing problems remain the same. However, the reduced cost of a route may be altered. Let 
                           
                              μ
                              V
                              s
                           
                         be the dual variable associated with the capacity inequality for subset V in scenario s. We modify the pricing problem for scenario s by subtracting 
                           
                              μ
                              V
                              s
                           
                         from the reduced cost of the arcs 
                           
                              
                                 (
                                 
                                    (
                                    i
                                    ,
                                    w
                                    )
                                 
                                 ,
                                 
                                    (
                                    
                                       i
                                       ′
                                    
                                    ,
                                    
                                       w
                                       ′
                                    
                                    )
                                 
                                 )
                              
                              ∈
                              
                                 A
                                 ^
                              
                           
                         such that i ∈ V and 
                           
                              
                                 i
                                 ′
                              
                              ∉
                              V
                           
                        .

The subset row inequalities are a special case of the Chvátal-Gomory rank 1 cuts. They were introduced by Jepsen et al. (2008). Let 
                           
                              
                                 e
                                 
                                    i
                                    r
                                 
                              
                              =
                              
                                 ∑
                                 
                                    w
                                    ∈
                                    
                                       W
                                       i
                                    
                                 
                              
                              
                                 e
                                 
                                    i
                                    w
                                    r
                                 
                              
                           
                         be the number of times i is visited on route r. The subset row inequalities can be expressed as follows:

                           
                              (19)
                              
                                 
                                    
                                       ∑
                                       
                                          r
                                          ∈
                                          R
                                          (
                                          s
                                          )
                                       
                                    
                                    
                                       ⌊
                                       
                                          1
                                          k
                                       
                                       
                                          ∑
                                          
                                             i
                                             ∈
                                             V
                                          
                                       
                                       
                                          e
                                          
                                             i
                                             r
                                          
                                       
                                       
                                       ⌋
                                    
                                    
                                       x
                                       r
                                       s
                                    
                                    ≤
                                    
                                       ⌊
                                       
                                          
                                             |
                                             V
                                             |
                                          
                                          k
                                       
                                       
                                       ⌋
                                    
                                    
                                    ∀
                                    V
                                    ⊆
                                    
                                       N
                                       ′
                                    
                                    ,
                                    
                                    2
                                    ≤
                                    k
                                    ≤
                                    
                                       |
                                       V
                                       |
                                    
                                    ,
                                    
                                    ∀
                                    s
                                    ∈
                                    S
                                    .
                                 
                              
                           
                        
                     

The subset row separation problem is NP-complete. As suggested by e.g. Jepsen et al. (2008) and Desaulniers et al. (2008), we separate only subset row inequalities for subsets V of size three, using k = 2, by enumeration. In this case, the inequalities ensure that for any set of three customers, at most one route can be selected that includes more than one of these customers.

Adding subset row inequalities to the formulation for scenario s changes the corresponding pricing problem. Let 
                           
                              σ
                              V
                              s
                           
                         be the dual variable associated with the subset row inequality for subset V in scenario s. For every k customers in V visited by a path in the pricing problem, 
                           
                              σ
                              V
                              s
                           
                         is subtracted from the reduced cost of that path.

The labeling algorithm is adjusted to include the dual values of the subset row inequalities in the reduced cost of each path. For the pricing problem associated with scenario s, the labels are modified by incorporating a new resource 
                           
                              h
                              V
                              s
                           
                         for every generated subset row inequality associated with a subset V and scenario s. When extending a label to a customer in V, 
                           
                              h
                              V
                              s
                           
                         is increased by one. When this resource reaches k, then 
                           
                              σ
                              V
                              s
                           
                         is subtracted from the reduced cost and the resource is reset to 0. Hence, 
                           
                              
                                 h
                                 V
                                 s
                              
                              
                                 (
                                 l
                                 )
                              
                           
                         gives the number of visits to the nodes in V by the partial path corresponding to label l since the last time 
                           
                              σ
                              V
                              s
                           
                         was subtracted from the reduced cost.

As proposed by Jepsen et al. (2008), the dominance check is modified as follows. When trying to establish whether a label l dominates a label l′, instead of checking whether c(l) ≤ c(l′), we check whether 
                           
                              c
                              
                                 (
                                 l
                                 )
                              
                              −
                              
                                 ∑
                                 
                                    V
                                    :
                                    
                                       h
                                       V
                                       s
                                    
                                    
                                       (
                                       l
                                       )
                                    
                                    >
                                    
                                       h
                                       V
                                       s
                                    
                                    
                                       (
                                       
                                          l
                                          ′
                                       
                                       )
                                    
                                 
                              
                              
                                 σ
                                 V
                                 s
                              
                              ≤
                              c
                              
                                 (
                                 
                                    l
                                    ′
                                 
                                 )
                              
                           
                        . Note that the subset row resources 
                           
                              
                                 h
                                 V
                                 s
                              
                              
                                 (
                                 l
                                 )
                              
                           
                         and 
                           
                              
                                 h
                                 V
                                 s
                              
                              
                                 (
                                 
                                    l
                                    ′
                                 
                                 )
                              
                           
                         are not compared during the dominance check. This way, more labels might be dominated.

As adding subset row inequalities slows down the labeling algorithm, we limit the number of inequalities added simultaneously as proposed by Desaulniers et al. (2008). In each iteration only a maximum number of 
                           
                              SR
                              i
                              max
                           
                         subset row inequalities might be added for subsets that include customer i. Furthermore, we limit the number of subset row inequalities added at once by 
                           
                              SR
                              It
                              max
                           
                        . Finally, we limit the total number of added subset row inequalities to SRmax . To ensure that the limited number of subset row inequalities are likely to make an impact on the LP bound, we only add subset row inequalities that are violated by at least 
                           
                              SR
                              Vio
                              min
                           
                        .

We propose the following branch-price-and-cut algorithm to solve the DTWAVRP to optimality. Lower bounds are found by solving the LP relaxation using column generation (see Algorithm 1) and adding valid inequalities. Capacity inequalities are separated in each iteration of the column generation algorithm where no new routes with negative reduced costs are identified. Because of their negative impact on the computation time of the algorithm that solves the pricing problem, subset row inequalities are only generated when no violated capacity constraint can be found. Branching is performed on the arcs in G, as by Proposition 1, integer arc flow in G is sufficient to identify an integer optimal solution.

We perform special ordered subset branching on the arcs (SOS branching). More specifically, for scenario s and customer i, let 
                           
                              
                                 δ
                                 
                                    s
                                 
                                 −
                              
                              
                                 (
                                 i
                                 )
                              
                           
                         and 
                           
                              
                                 δ
                                 
                                    s
                                 
                                 +
                              
                              
                                 (
                                 i
                                 )
                              
                           
                         be the sets of in and out arcs of a node representing customer i, respectively. Next, a customer i′, a scenario s′ and an arc type o′ ∈ { −, +} is selected such that the number of arcs a in 
                           
                              
                                 δ
                                 
                                    
                                       s
                                       ′
                                    
                                 
                                 
                                    o
                                    ′
                                 
                              
                              
                                 (
                                 
                                    i
                                    ′
                                 
                                 )
                              
                           
                         for which the arc flow is greater than zero, 
                           
                              
                                 F
                                 a
                                 
                                    s
                                    ′
                                 
                              
                              >
                              0
                              ,
                           
                         is the largest set. Let 
                           
                              
                                 δ
                                 
                                    
                                       s
                                       ′
                                    
                                 
                                 
                                    o
                                    ′
                                 
                              
                              
                                 (
                                 
                                    i
                                    ′
                                 
                                 )
                              
                              =
                              
                                 {
                                 
                                    a
                                    1
                                 
                                 ,
                                 …
                                 ,
                                 
                                    a
                                    k
                                 
                                 }
                              
                           
                         be ordered with respect to the arc flow in G, such that 
                           
                              
                                 F
                                 
                                    a
                                    u
                                 
                                 
                                    s
                                    ′
                                 
                              
                              ≥
                              
                                 F
                                 
                                    a
                                    v
                                 
                                 
                                    s
                                    ′
                                 
                              
                           
                         if u < v. The arcs are divided into two groups, V and its complement 
                           
                              
                                 V
                                 ¯
                              
                              ,
                           
                         where V = {a
                        1, …, au
                        } is such that 
                           
                              
                                 ∑
                                 
                                    a
                                    ∈
                                    V
                                 
                              
                              
                                 F
                                 a
                                 
                                    s
                                    ′
                                 
                              
                              ≥
                              0.5
                           
                         and 
                           
                              
                                 ∑
                                 
                                    a
                                    ∈
                                    V
                                    ∖
                                    {
                                    
                                       a
                                       u
                                    
                                    }
                                 
                              
                              
                                 F
                                 a
                                 
                                    s
                                    ′
                                 
                              
                              <
                              0.5
                           
                        . In one branch we disallow the use of the arcs in V and in the other we disallow the use of the arcs in 
                           
                              V
                              ¯
                           
                        . This does not alter the nature of the pricing problem, in fact the number of arcs in the network decreases.

In our branch-price-and-cut algorithm, upper bounds are obtained when computing an integer RMP solution. The search tree is explored using a best-first strategy, that is, the node with the lowest lower bound is selected to process next.

In this section, we introduce five column generation heuristics for the DTWAVRP that are derived from the above branch-price-and-cut algorithm and that can be used to find good solutions in less computation time than the exact algorithm. According to the terminology used in the survey of Joncour, Michel, Sadykov, Sverdlov, and Vanderbeck (2010), we propose one restricted master heuristic, two diving heuristics, and two rounding heuristics. Our goal here is to show how the branch-price-and-cut algorithm can be adapted to tackle larger instances. Other types of heuristics could be devised but such an endeavor does not fall within the scope of this paper.

The proposed heuristics rely on the formulation (7)–(11). These heuristics focus on the first-stage decisions, which means that they do not consider integrality requirements on the route variables but only on the time window assignment variables. This speeds up the solution process, while the fractional route variables may still guide the search well enough to find good time window assignments for the DTWAVRP. Given a time window assignment, the corresponding solution value of the DTWAVRP can be evaluated by solving a VRPTW for each scenario using these time windows. Note that because we consider an unlimited amount of vehicles, a feasible routing schedule can be found for any time window assignment.

The restricted master heuristic is based on a MIP solver used as a black-box after generating routes at the root node. First, the LP relaxation of the DTWAVRP is solved using the column generation algorithm described in Section 3. Valid inequalities are then separated and, if violated ones are found, they are added to the RMP which is then reoptimized by column generation. This process is iterated until no violated inequalities are found. Next, the resulting RMP (in the last column generation iteration) is used to find an integer time window assignment. Hence, no new routes are generated beyond this stage. To solve the RMP, a MIP solver is invoked but only integrality of the time window assignment variables is required, that is, we do not require the selection of integer routes.

In the first diving heuristic, called the TWDiving heuristic, the LP relaxation of the DTWAVRP is solved using the exact column generation algorithm, alternating as before with the generation of valid inequalities. Next, we fix the assignment of the highest fractionally selected time window among all customers, i.e., the time window variable that has a fractional value closest to 1 is fixed to 1. We iterate these two steps of column generation and variable fixing until an integer time window assignment is found. Here again, we do not require the route selection to be integer.

At each iteration of the TWDiving heuristic, the column generation algorithm is used to solve to optimality the LP relaxation of the DTWAVRP with a partially fixed time window assignment. Even though the optimal solution to the LP relaxation at each iteration might provide a good indication of the time windows to assign, there is no guarantee that this gives a better indication than a suboptimal solution. Therefore, we also consider a second diving heuristic in which, at each column generation iteration, the pricing problem is only solved using the tabu search algorithm described in Section 3.3.2. In this case, the exact pricing algorithm is never invoked during the execution of the heuristic. This speeds up the heuristic, while the solution quality may not suffer too much as most routes that are important for determining a good time window assignment might be generated by the tabu search algorithm anyway. We refer to this heuristic as the TWDiving-Tabu heuristic.

The TWRounding heuristic is a rounding heuristic in which we round time window assignment variables that are fractionally selected. First, the LP relaxation of the DTWAVRP is solved using the column generation algorithm (possibly adding valid inequalities). Next, to each customer we assign the highest fractionally selected time window, i.e., for each customer separately, the time window variable that has a fractional value closest to 1 is set to 1. This way an integer time window assignment is obtained, but no integer route selection.

As for the TWDiving heuristic, we also consider a variant of the TWRounding heuristic in which the pricing problem is only solved using the tabu search algorithm. We refer to this heuristic as the TWRounding-Tabu heuristic.

In this section we present the results of our computational experiments. First, we elaborate on the instances that were used. Next, we report the results obtained with the exact branch-price-and-cut algorithm (Subsection 5.2) and with the five column generation heuristics (Subsection 5.3). Finally, we provide results to compare a multiple-scenario approach with the approach currently used in practice that considers a single scenario (Subsection 5.4).

All our tests were performed on an Intel(R) Core(TM) i5-2450M CPU 2.5 gigahertz processor. The algorithms were coded in C++ and the IBM ILOG Cplex optimizer, version 12.4, was used to solve the RMP in the column generation algorithm and also to derive an integer solution in the restricted master heuristic. Unless stated otherwise, a time limit of one hour was enforced to solve each instance.

The instances used for our experiments were randomly generated.
                           1
                        
                        
                           1
                           All instances can be found online at http://people.few.eur.nl/spliet.
                         For each instance, n customers are generated using a uniform distribution over a square with sides of length 5. The depot is located in the center of the square. Travel costs and times are computed as the Euclidean distance between two locations rounded to two digits. Vehicle capacity is 30. The depot has time window [6,22]. We construct three sets of candidate time windows which we randomly assign to each customer, such that each set of candidate time windows is assigned with fixed frequency. We assign the set {[10, 12], [12, 14], [14, 16]} to 10 percent of the customers, the set {[8, 10], [10, 12], [12, 14], [14, 16], [16, 18]} to 60 percent of the customers, and {[7, 9], [9, 11], [11, 13], [13, 15], [15, 17], [17, 19], [19, 21]} to 30 percent of the customers.

For each instance, we generate three demand scenarios, each occurring with equal probability. The scenarios are generated such that the first scenario has low demand, the second scenario has medium demand, and the final scenario has high demand. We accomplish this by randomly generating a basic demand 
                           
                              
                                 d
                                 ¯
                              
                              i
                           
                         for all i ∈ N′ according to a normal distribution with expectation 5 and variance 1.5. Next we generate multipliers 
                           
                              
                                 u
                                 i
                                 1
                              
                              ,
                           
                        
                        
                           
                              u
                              v
                              2
                           
                         and 
                           
                              u
                              v
                              3
                           
                         for all i ∈ N′ uniformly distributed on [0.7, 0.8], [0.95, 1.05] and [1.2, 1.3], respectively. Finally, we generate the demand for each customer i ∈ N′ and each scenario s ∈ {1, 2, 3} by computing 
                           
                              
                                 d
                                 i
                                 s
                              
                              =
                              
                                 ⌈
                                 
                                    u
                                    i
                                    s
                                 
                                 
                                    
                                       d
                                       ¯
                                    
                                    i
                                 
                                 ⌉
                              
                           
                        . Generating scenarios in this way resembles demand behavior that is encountered in the case, for instance, of ice cream vendors. When the weather is exceptionally good or bad, demand for ice cream goes up or down respectively. Moreover, all vendors in the network are affected similarly by the weather, leading to an increase or decrease of demand for all vendors simultaneously.

These settings are inspired by experience with a Dutch retail chain. The time window and capacity constraints ensure that no more than roughly seven or eight customers can be visited by a single vehicle in any scenario. We have generated 10 instances for eight different sizes, namely, 10, 15, 20, 25, 30, 40, 50 and 60 customers, making a total of 80 instances.

This section is divided in two parts. We present results for the column generation algorithm first, before reporting results for the full branch-price-and-cut algorithm. For this section, our tests were restricted to instances involving 25 customers or less.

In this section we present the results obtained by the column generation algorithm when solving the LP relaxation of (7)–(11). As initial routes in the RMP, we use routes visiting a single node, i.e., routes of the form (0, w
                           0) − (i, w) − (n + 1, w
                           
                              n + 1) for all 
                              
                                 
                                    (
                                    i
                                    ,
                                    w
                                    )
                                 
                                 ∈
                                 
                                    N
                                    ^
                                 
                              
                            and for all scenarios s ∈ S. We will distinguish between using only the exact algorithm to generate routes, and using the tabu search heuristic to generate routes as well. No valid inequalities are added during these experiments.


                           Table 1
                            shows the results of using Algorithm 1, without the tabu search column generator, for the cases when all cycles are allowed, when only ng-paths are allowed for a neighborhood size of Δng
                            = 5, and when only elementary paths are allowed. Recall that the same implementation of this algorithm can be used for these route relaxations by setting Δng
                            = 1, Δng
                            = 5, and Δng
                            = n, respectively. The first and second columns of Table 1 show the instance number and the number of customers in this instance. For each instance and each type of pricing problem, we report the total time in seconds needed by the column generation algorithm to solve the LP relaxation (T.Time), the time spent on solving pricing problems (P.Time), the number of column generation iterations needed (Iter.), and the LP optimal value (LP).

Observe that almost all of the computation time is spent on solving the pricing problems. For four of the instances with 25 customers, the time limit is exceeded before solving the LP relaxation, when using only elementary paths. When comparing the use of elementary paths versus allowing all cycles, we observe that the computation times are in general significantly faster when all cycles are allowed (instance 1 is an obvious exception) but the LP values are significantly lower. When using ng-paths with Δng
                            = 5, the LP values are very close to those obtained when using only elementary paths. Moreover, for the largest instances, the computation times are significantly lower. Hence, using ng-paths provides bounds that are comparable to those obtained when using only elementary paths, in much less time.


                           Table 2
                            shows the results of using the column generation algorithm in which the tabu search algorithm is used to find routes with negative reduced costs. We use the settings TStabu = 5, TSIt = 15 and TSmax = 150.

When comparing the results in Tables 1 and 2, one can observe a significant decrease in computation time when using the tabu search heuristic in the elementary route case. In this case, all instances are now solved within the time limit of one hour. When the ng-route relaxation is used, a smaller decrease in computation time is observed. When all cycles are allowed, using the tabu search algorithm leads to an increase in computation time in many instances. Recall that the tabu search heuristic generates only elementary routes. Therefore the routes produced by this heuristic may be less useful when cycles are allowed. Note that we also developed a similar tabu search algorithm for generating ng-routes. It was not successful because checking whether a route is an ng-route is computationally expensive.

All results presented in the next section were obtained using the tabu search column generator as well as the ng-route relaxation. Moreover, preliminary experiments with various values of Δng
                            showed that the algorithm yields its best results with Δng
                            = 5.

Next, we present the results of our experiments using the exact branch-price-and-cut algorithm. Table 3
                            reports the results obtained when only capacity inequalities are considered. The column Opt.Gap shows the percentage difference between the best obtained upper and lower bounds after termination of the algorithm. The column UB gives the best upper bound found. The column LP Gap shows the percentage difference between the value of the LP relaxation, without adding valid inequalities, and the best upper bound found. The column Root Gap specifies the same difference but after adding valid inequalities. The column Nodes indicates the number of nodes processed in the search tree and the column CI gives the number of added capacity inequalities. Note that a dash indicates that no integer solution was obtained within the time limit.

Observe that the total computation time increases rapidly with the number of customers in the instances. Three of the instances with 20 customers and eight with 25 customers could not be solved within 1 hour. For four 10-customer instances, the LP bound is already tight. For 14 more instances the gap is completely closed by adding capacity cuts, including the instance with the largest (observed) LP gap.


                           Table 4
                            shows the results of using the branch-price-and-cut algorithm while adding both the capacity inequalities and the subset row inequalities. Recall that subset row inequalities are only separated when no violated capacity inequalities are identified. We limit the subset row inequalities that we add as described in Section 3.4. We use the settings 
                              
                                 
                                    SR
                                    i
                                    max
                                 
                                 =
                                 5
                                 ,
                              
                           
                           
                              
                                 
                                    SR
                                    It
                                    max
                                 
                                 =
                                 10
                                 ,
                              
                            SRmax  = 30 and 
                              
                                 
                                    SR
                                    Vio
                                    min
                                 
                                 =
                                 0.1
                              
                           . In this table, the column SRI indicates the number of generated subset row inequalities.

Three instances (28, 30 and 40) that were previously unsolved are now solved by adding subset row inequalities. Out of the twenty other instances in which subset row inequalities were added, seven instances were solved faster than without adding them, eight remained unsolved, while the others required more computation time. The LP gap of one additional instance, instance 26, is closed after adding subset row inequalities. Adding subset row inequalities improves the lower bounds that are obtained and yields less nodes in the branching tree. However, the additional time spent on solving the pricing problems as a result of adding these inequalities often outweighs the gains of these improved bounds, especially for the smaller instances.

Next, we present the results of our computational experiments using the five column generation heuristics. In these heuristics, the column generation algorithm is set as specified in Section 5.2 except for the TWDiving-Tabu and TWRounding-Tabu heuristics that only used the tabu search algorithm to generate columns. As mentioned in Section 4, valid inequalities are separated in each heuristic but preliminary experiments (with no inequalities, only capacity inequalities, only subset row inequalities or both types) showed that it is better to not use the same strategy for all heuristics. Indeed, for the restricted master heuristic, the quality of the solutions is dependent on the number and quality of the generated routes. Adding valid inequalities increases the number of routes that are generated by the column generation algorithm and potentially has a positive effect on the quality of the routes. Therefore, for the restricted master heuristic we separate both capacity inequalities and subset row inequalities (using the same parameter setting described in Section 5.2). For the other four heuristics, the results of the preliminary tests showed that no single setting produced the best results over all instances with respect to solution quality and computation time. Adding more inequalities typically yields better solutions but increases computation time. Furthermore, it was not clear which type of valid inequalities provides the best results. Nevertheless, we chose to only present results of experiments in which we separate only the subset row inequalities during the execution of the TWDiving, TWDiving-Tabu, TWRounding and TWRounding-Tabu heuristics.


                        Table 5
                         presents the results of solving DTWAVRP instances using the five proposed column generation heuristics. The column Opt. indicates the optimal solution value for the instances that were solved to optimality with the exact algorithm. Furthermore, the ten rightmost columns show the solution value and computation time of solving the instances with each heuristic. Note that the computation time for the heuristics does not include the time to evaluate the solution, that is, the time to solve a VRPTW for each scenario using the time windows provided by the heuristics.

First, observe that the restricted master heuristic terminates before reaching the time limit for the instances with up to 25 customers, but for the larger instances, it only terminates within the time limit for one instance. Moreover, note that there are instances in which the time limit is exceeded, but still a solution value is reported. In these cases, the best integer solution found by the branch-and-bound algorithm after one hour of computation time is used. In the other cases where the time limit is exceeded, no integer time window assignment was found.

Furthermore, the TWDiving heuristic terminates before reaching the time limit for all instances with up to 25 customers. It fails to do so for 2 of the 30 customer instances, 8 of the 40 customer instances, and all of the instances with 50 and 60 customers. The TWRounding heuristic terminates within the time limit for all instances except for 4 of the 60 customer instances. The TWDiving-Tabu and TWRounding-Tabu heuristic terminate well within the time limit for all instances. The TWRounding-Tabu heuristic yields the lowest computation times.

To compare the heuristics with respect to solution quality, we distinguish between small and large instances, that is, the instances with up to 25 customers and the instances with 30 or more customers, respectively. For the 40 small instances, the five heuristics (in order of their presentation) provide the best solution for 27, 20, 19, 8 and 8 instances, respectively. Thus, the restricted master heuristic provides the best solution most often. The cost of its solutions is on average 0.29 percent above the optimal value for all instances that have been solved to optimality. For the other four heuristics, the average optimality gap is 0.51 percent for TWDiving, 0.39 percent for TWDiving-Tabu, 4.30 percent for TWRounding, and 3.17 percent for TWRounding-Tabu. Clearly, the diving heuristics produce solutions of much better quality than the counterpart rounding heuristics. However, they are more time-consuming. It seems that using only the tabu search column generator does not affect solution quality.

For the 40 large instances, the five heuristics (in the same order) provide the best solution for 3, 4, 32, 1 and 0 instances, respectively. In this case, the TWDiving-Tabu heuristic yields the best solution most often. The restricted master heuristic and TWDiving heuristic are unable to produce solutions in many of these instances due to exceeding the time limit. In consequence, the TWDiving-Tabu heuristic seems to be the heuristic offering the best compromise between solution quality and computation time.

In practice, time windows are typically assigned based on historical average demand. In this case, a VRP with multiple time windows can be solved (by branch-price-and-cut), where the time windows are the candidate time windows of each customer. The time window in which a customer is visited in the computed solution is then declared as the assigned time window. We refer to this approach as the average demand based time window assignment, ADTWA.

In this section, we present the results of computational experiments in which we compare the 1-scenario ADTWA approach with several sample average approximation approaches. To perform this comparison, we generated 30 new instances involving 20, 25, and 30 customers (10 instances for each size). We considered 25 different demand scenarios that were created using the following procedure. Basic demand 
                           
                              
                                 
                                    d
                                    ¯
                                 
                                 i
                              
                              ,
                           
                         for all i ∈ N′, is generated as described in Section 5.1. For every customer i ∈ N′ and scenario s ∈ S, a perturbation factor 
                           
                              ϵ
                              i
                              s
                           
                         to the basic demand is generated using a uniform distribution on [ − 1.5, 1.5]. Next, for each scenario s ∈ S, we generate a multiplier us
                         uniformly distributed on [0.625, 1.375]. Finally, demand for each customer i ∈ N′ and each scenario s ∈ S is computed as 
                           
                              
                                 d
                                 i
                                 s
                              
                              =
                              
                                 ⌈
                                 
                                    u
                                    s
                                 
                                 
                                    (
                                    
                                       
                                          d
                                          ¯
                                       
                                       i
                                    
                                    +
                                    
                                       ϵ
                                       i
                                       s
                                    
                                    )
                                 
                                 ⌉
                              
                           
                        .

As sample average approximation approaches, the TWDiving-Tabu heuristic is used, first considering a sample of three scenarios and secondly a sample of five scenarios. Furthermore, the exact branch-price-and-cut algorithm is used considering a sample of three scenarios, for the 20-customer instances only. The sample of three scenarios is generated as described in Section 5.1. The sample of five scenarios is generated in the same way except that five multipliers 
                           
                              u
                              i
                              s
                           
                         per customer i ∈ N′ are generated using uniform distributions on [0.65, 0.75], [0.8, 0.9], [0.95, 1.05], [1.1, 1.2] and [1.25, 1.35], respectively. Note that, for a given instance, the same basic demand 
                           
                              
                                 
                                    d
                                    ¯
                                 
                                 i
                              
                              ,
                           
                         
                        i ∈ N′, is used in each scenario. In particular, it is considered as the average demand in the ADTWA approach.

No time limit was imposed for these experiments. To compute the expected total transportation cost resulting from the assigned time windows obtained with each method, we solved for each of the 25 scenarios the corresponding VRPTW to optimality. The average optimal value over these scenarios gives the expected total transportation cost. We would like to emphasize that this means that the exact approach for the approximate 3-scenario DTWAVRP instance might not yield the lowest expected costs when evaluated over 25 scenarios.


                        Table 6
                         shows the results of these experiments. For each instance, we report in the column BPC the expected transportation cost (ETC) of the time window assignment obtained by applying the branch-price-and-cut algorithm considering three scenarios. In the first two TWDiving-Tabu columns, we provide the ETC yielded by the solutions produced by the TWDiving-Tabu heuristic with three and five scenarios, respectively. The difference between these ETCs is given in the third TWDiving-Tabu column. In the column ADTWA, the ETC of the ADTWA approach solution is reported. The last column shows the difference between the ETCs of the solutions computed by the ADTWA approach and the TWDiving-Tabu heuristic with five scenarios. For each instance, the best ETC value is highlighted in boldface.

First, observe that the ADTWA approach provides the worst results for all instances. Moreover, the TWDiving-Tabu heuristic with five scenarios yields the best solution for most instances. In fact, the ETC of the ADTWA solutions are on average 3.64 percent higher than those of the solutions produced by the TWDiving-Tabu heuristic with five scenarios. For all instances except one, this difference is greater than 1.35 percent. Hence, these results suggest that the quality of the time window assignment benefits from considering multiple scenarios.

Secondly, the difference in the ETCs of the solutions computed by the TWDiving-Tabu heuristic with three scenarios and with five scenarios is on average only 0.31 percent in favor of the 5-scenario variant and never exceeds 1.32 percent. From these statistics, we deduce that the benefits of considering additional scenarios when assigning time windows diminish when the number of scenarios increase. This phenomenon is due to the high correlation between the demand scenarios, that is, all demands either increase or decrease at the same time. When no such correlation exists, one would expect that a large number of scenarios would be required to reach the best solutions.

Finally, the quality of the solutions obtained by the exact branch-price-and-cut algorithm and by the TWDiving-Tabu heuristic with 3 scenarios are similar for the 20-customer instances. Indeed, the heuristic yields the best solution for 4 of the 10 instances and an equivalent solution for two instances. The ETC produced by the exact algorithm is on average only 0.01 percent better. These results show that a “good” heuristic solution to an approximate model might be better than an optimal solution to this approximate model.

@&#CONCLUSIONS@&#

In this paper, we have introduced a new problem, the DTWAVRP. We have developed an exact branch-price-and-cut algorithm to solve it. The column generation algorithm exploits the fact that columns for one scenario can be reused in another scenario. Furthermore, we use an ng-route relaxation to speed up the pricing problem while limiting the decrease of the LP value and we also generate columns using a tabu search heuristic. Finally, the branch-price-and-cut algorithm incorporates valid inequalities that are known from vehicle routing, namely, capacity and subset row inequalities. We are able to solve to optimality instances of up to 25 customers and three scenarios within one hour of computation time.

Furthermore, we implemented five column generation heuristics, each incorporating our column generation algorithm and valid inequalities. They are a restricted master heuristic, two diving heuristics and two rounding heuristics. For the small instances (up to 25 customers), the restricted master heuristic produces the best solutions most often. The solution values are on average 0.29 percent above the optimal value for the instances solved to optimality. For the instances with more than 30 customers, the TWDiving-Tabu heuristic (that only uses the tabu search column generator) produces the best solutions most often and offers the best quality/time compromise.

Finally, we performed experiments to compare a multiple-scenario approach with a single-scenario approach that is typically used in practice. Our results show that considering five scenarios instead of one produces significantly better quality solutions, with an average reduction of 3.64 percent on the expected transportation cost.

In the future, various research directions ensuing from this work can be explored. One of them would be to consider customer preferences on the candidate time windows that can be assigned to them and to include in the DTWAVRP a secondary objective consisting of maximizing the customer preference satisfaction. Another line of research would be to enhance the proposed method or develop a new one to tackle instances involving a large number of scenarios.

Below we provide a proof of Proposition 1 that we restate here.

                        Proposition 1
                        
                           Let (x, y) be a solution to the LP relaxation of formulation 
                           (7)–(11). When the corresponding arc flow in G is integer for every scenario, there exists an integer solution (x*, y*) to the DTWAVRP of equal value.
                        

For each customer i ∈ N′, let 
                              
                                 w
                                 
                                    (
                                    i
                                    ,
                                    y
                                    )
                                 
                                 ∈
                                 arg
                                 min
                                 
                                    {
                                    
                                       w
                                       ̲
                                    
                                    
                                    |
                                    
                                    w
                                    ∈
                                    
                                       W
                                       i
                                    
                                    ,
                                    
                                       y
                                       
                                          i
                                          w
                                       
                                    
                                    >
                                    0
                                    }
                                 
                              
                            be the candidate time window with the earliest start time among the ones selected in solution (x, y).

Let Fs
                            be the integer arc flow in G for scenario s, corresponding to solution (x, y). This arc flow can be represented as a set of (0, n + 1) − paths in G, Fs
                            = {P
                           1, …, P
                           
                              k(s)}. Furthermore, denote by 
                              
                                 F
                                 a
                                 s
                              
                            the flow on arc a ∈ A in scenario s.

For any path P ∈ Fs
                            visiting the customers {i
                           1, …, il
                           }, consider the path 
                              
                                 P
                                 ^
                              
                            in 
                              
                                 G
                                 ^
                              
                            visiting the nodes {(i
                           1, w(i
                           1, y)), …, (il, w(il, y))}, that is, the path using for each customer the selected time window with the earliest start time. Using path 
                              
                                 P
                                 ^
                              
                            for all P ∈ Fs, s ∈ S, and the time windows w(i, y) for each i ∈ N′, yields a solution whose value is equal to that of (x, y). To complete the proof, we need to show that this solution is feasible. Because a path 
                              
                                 P
                                 ^
                              
                            visits the same customers as its parent path P, the capacity constraints are satisfied by the routes in the new solution. Hence, all that remains to be shown is that the time window constraints are also satisfied along those routes.

Consider the graph 
                              
                                 
                                    G
                                    ^
                                 
                                 
                                    (
                                    
                                       F
                                       s
                                    
                                    ,
                                    y
                                    )
                                 
                                 =
                                 
                                    (
                                    
                                       N
                                       ^
                                    
                                    
                                       (
                                       y
                                       )
                                    
                                    ,
                                    
                                       A
                                       ^
                                    
                                    
                                       (
                                       
                                          F
                                          s
                                       
                                       ,
                                       y
                                       )
                                    
                                    )
                                 
                                 ,
                              
                            where 
                              
                                 
                                    N
                                    ^
                                 
                                 
                                    (
                                    y
                                    )
                                 
                                 =
                                 
                                    {
                                    
                                       (
                                       i
                                       ,
                                       w
                                       )
                                    
                                    ∈
                                    
                                       N
                                       ^
                                    
                                    
                                    |
                                    
                                    
                                       y
                                       
                                          i
                                          w
                                       
                                    
                                    >
                                    0
                                    }
                                 
                              
                           
                           
                              ⋃
                           {(0, w
                           0), (n + 1, w
                           
                              n + 1)} contains the combinations of locations and time windows that are selected in solution (x, y), and 
                              
                                 
                                    A
                                    ^
                                 
                                 
                                    (
                                    
                                       F
                                       s
                                    
                                    ,
                                    y
                                    )
                                 
                                 =
                                 
                                    {
                                    
                                       (
                                       
                                          (
                                          i
                                          ,
                                          w
                                          )
                                       
                                       ,
                                       
                                          (
                                          
                                             i
                                             ′
                                          
                                          ,
                                          
                                             w
                                             ′
                                          
                                          )
                                       
                                       )
                                    
                                    ∈
                                    
                                       A
                                       ^
                                    
                                    
                                    |
                                    
                                    
                                       (
                                       i
                                       ,
                                       w
                                       )
                                    
                                    ,
                                    
                                       (
                                       
                                          i
                                          ′
                                       
                                       ,
                                       
                                          w
                                          ′
                                       
                                       )
                                    
                                    ∈
                                    
                                       N
                                       ^
                                    
                                    
                                       (
                                       y
                                       )
                                    
                                    ,
                                    
                                       F
                                       
                                          (
                                          i
                                          ,
                                          
                                             i
                                             ′
                                          
                                          )
                                       
                                       s
                                    
                                    >
                                    0
                                    }
                                 
                              
                           . Observe that all paths from (0, w
                           0) to (n + 1, w
                           
                              n + 1) in 
                              
                                 
                                    G
                                    ^
                                 
                                 
                                    (
                                    
                                       F
                                       s
                                    
                                    ,
                                    y
                                    )
                                 
                              
                            can be represented in 
                              
                                 G
                                 ^
                              
                           . Moreover, any such path visits the same customers as some path P ∈ Fs
                            and in the same order.

Let 
                              
                                 
                                    t
                                    ̲
                                 
                                 
                                    i
                                    w
                                 
                                 s
                              
                            be the earliest possible start of service time in node (i, w) by any path in 
                              
                                 
                                    G
                                    ^
                                 
                                 
                                    (
                                    
                                       F
                                       s
                                    
                                    ,
                                    y
                                    )
                                 
                              
                            starting at node (0, w
                           0). Let 
                              
                                 
                                    
                                       t
                                       ̲
                                    
                                    
                                       0
                                       
                                          w
                                          0
                                       
                                    
                                    s
                                 
                                 =
                                 
                                    
                                       w
                                       ̲
                                    
                                    0
                                 
                              
                           . Observe that as yiw
                            > 0 for 
                              
                                 
                                    (
                                    i
                                    ,
                                    w
                                    )
                                 
                                 ∈
                                 
                                    N
                                    ^
                                 
                                 
                                    (
                                    y
                                    )
                                 
                                 ,
                              
                            constraints (9) ensure that there is a route r ∈ R(s) such that xr
                            > 0 for all s ∈ S. Hence, 
                              
                                 
                                    t
                                    ̲
                                 
                                 
                                    i
                                    w
                                 
                                 s
                              
                            exists for all 
                              
                                 
                                    (
                                    i
                                    ,
                                    w
                                    )
                                 
                                 ∈
                                 
                                    N
                                    ^
                                 
                                 
                                    (
                                    y
                                    )
                                 
                              
                            and all s ∈ S.

Let Wi
                           (y) = {w|w ∈ Wi, yiw
                            > 0}. Next, let 
                              
                                 
                                    
                                       t
                                       ̲
                                    
                                    i
                                    s
                                 
                                 =
                                 
                                    min
                                    
                                       w
                                       ∈
                                       
                                          W
                                          i
                                       
                                       
                                          (
                                          y
                                          )
                                       
                                    
                                 
                                 
                                    {
                                    
                                       
                                          t
                                          ̲
                                       
                                       
                                          i
                                          w
                                       
                                       s
                                    
                                    }
                                 
                              
                            be the earliest start of service time at customer i in 
                              
                                 
                                    G
                                    ^
                                 
                                 
                                    (
                                    
                                       F
                                       s
                                    
                                    ,
                                    y
                                    )
                                 
                              
                           . Observe that 
                              
                                 
                                    
                                       t
                                       ̲
                                    
                                    0
                                    s
                                 
                                 =
                                 
                                    
                                       t
                                       ̲
                                    
                                    
                                       0
                                       
                                          w
                                          0
                                       
                                    
                                    s
                                 
                              
                           . For every pair (i, i′) such that 
                              
                                 
                                    F
                                    
                                       (
                                       i
                                       ,
                                       
                                          i
                                          ′
                                       
                                       )
                                    
                                    s
                                 
                                 >
                                 0
                                 ,
                              
                            it holds that

                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   t
                                                   ̲
                                                
                                                
                                                   
                                                      i
                                                      ′
                                                   
                                                   w
                                                   
                                                      (
                                                      
                                                         i
                                                         ′
                                                      
                                                      ,
                                                      y
                                                      )
                                                   
                                                
                                                s
                                             
                                          
                                          
                                             =
                                          
                                          
                                             
                                                max
                                                
                                                   {
                                                   
                                                      
                                                         w
                                                         (
                                                         
                                                            i
                                                            ′
                                                         
                                                         ,
                                                         y
                                                         )
                                                      
                                                      ̲
                                                   
                                                   ,
                                                   
                                                      
                                                         t
                                                         ̲
                                                      
                                                      i
                                                      s
                                                   
                                                   +
                                                   
                                                      t
                                                      
                                                         i
                                                         
                                                            i
                                                            ′
                                                         
                                                      
                                                   
                                                   }
                                                
                                                ≤
                                                max
                                                
                                                   {
                                                   
                                                      w
                                                      ̲
                                                   
                                                   ,
                                                   
                                                      
                                                         t
                                                         ̲
                                                      
                                                      i
                                                      s
                                                   
                                                   +
                                                   
                                                      t
                                                      
                                                         i
                                                         
                                                            i
                                                            ′
                                                         
                                                      
                                                   
                                                   }
                                                
                                             
                                          
                                       
                                       
                                          
                                          
                                             =
                                          
                                          
                                             
                                                
                                                   
                                                      t
                                                      ̲
                                                   
                                                   
                                                      
                                                         i
                                                         ′
                                                      
                                                      w
                                                   
                                                   s
                                                
                                                
                                                ∀
                                                w
                                                ∈
                                                
                                                   W
                                                   
                                                      i
                                                      ′
                                                   
                                                
                                                
                                                   (
                                                   y
                                                   )
                                                
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

Therefore, 
                              
                                 
                                    
                                       t
                                       ̲
                                    
                                    i
                                    s
                                 
                                 =
                                 
                                    
                                       t
                                       ̲
                                    
                                    
                                       i
                                       w
                                       (
                                       i
                                       ,
                                       y
                                       )
                                    
                                    s
                                 
                              
                            and it follows that 
                              
                                 
                                    
                                       t
                                       ̲
                                    
                                    
                                       
                                          i
                                          ′
                                       
                                       w
                                       
                                          (
                                          
                                             i
                                             ′
                                          
                                          ,
                                          y
                                          )
                                       
                                    
                                    s
                                 
                                 ≥
                                 
                                    
                                       t
                                       ̲
                                    
                                    
                                       i
                                       w
                                       (
                                       i
                                       ,
                                       y
                                       )
                                    
                                    s
                                 
                                 +
                                 
                                    t
                                    
                                       i
                                       
                                          i
                                          ′
                                       
                                    
                                 
                              
                           . This shows that using path 
                              
                                 P
                                 ^
                              
                            and the earliest start of service time in the time window with the earliest start time 
                              
                                 
                                    t
                                    ̲
                                 
                                 
                                    i
                                    w
                                    (
                                    i
                                    ,
                                    y
                                    )
                                 
                                 s
                              
                            for each node (i, w(i, y)) visited on this path provides a feasible route for each P ∈ Fs
                            and each scenario s ∈ S.□

@&#REFERENCES@&#

