@&#MAIN-TITLE@&#A fast algorithm to estimate inverse consistent image transformation based on corresponding landmarks

@&#HIGHLIGHTS@&#


               
                  
                  
                     
                        
                           
                           We propose a simple and efficient inverse consistent image transformation estimation algorithm.


                        
                        
                           
                           Forward and backward transformations between two corresponding point sets are estimated simultaneously.


                        
                        
                           
                           Inverse consistency errors of transformations between two images are reduced.


                        
                        
                           
                           Convergence of our algorithm is analyzed.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Image registration

Inverse consistency

Forward transformation

Backward transformation

@&#ABSTRACT@&#


               
               
                  Inverse consistency is an important feature for non-rigid image transformation in medical imaging analysis. In this paper, a simple and efficient inverse consistent image transformation estimation algorithm is proposed to preserve correspondence of landmarks and accelerate convergence. The proposed algorithm estimates both the forward and backward transformations simultaneously in the way that they are inverse to each other based on the correspondence of landmarks. Instead of computing the inverse functions and the inverse consistent transformations, respectively, we combine them together, which can improve computation efficiency significantly. Moreover, radial basis functions (RBFs) based transformation is adopted in our algorithm, which can handle deformation with local or global support. Our algorithm maps one landmark to its corresponding position exactly using the forward and backward transformations. Moreover, our algorithm is employed to estimate the forward and backward transformations in robust point matching, as well to demonstrate the application of our algorithm in image registration. The experiment results of uniform grids and test images indicate the improvement of the proposed algorithm in the aspect of inverse consistency of transformations and the reduction of the computation time of the forward and the backward transformations. The performance of our algorithm applying to robust point matching is evaluated using both brain slices and lung slices. Our experiments show that by combing robust point matching with our algorithm, the registration accuracy can be improved and the smoothness of transformations can be preserved.
               
            

@&#INTRODUCTION@&#

Image transformation is widely used to map images, and plays an important role in imaging analysis such as image registration, animation and shape atlases construction. In image registration, one of the key issues is the transformation model used between the source image and the target image. Transformations between two images are expected to be one-to-one to make sure that each point in the source image just has one corresponding point in the target image and vice versa. In particular, for medical image registration, symmetry and inverse consistency are two commonly required properties of transformations [1] to produce the kind of deformation results, which are smoother and present more biological meaning. Symmetric or inverse consistent registration methods guarantee that the registration results are invariant to the order of the choice of source and target images. However, most registration methods are asymmetric. The registration results depend on the order of images, which lead to algorithm-induced artifacts in detected changes [2].

Symmetric registration algorithms construct symmetric objective functions and use exact inverse transformations guaranteed by diffeomorphisms, to make unbiased registration results when the order of input images are interchanged [3–10]. Beg et al. [3] introduced two consistent constraints into the Large Deformation Diffeomorphic Metric Mapping (LDDMM) algorithm to make the registration results invariant to the order in which the images are chosen. Avants et al. [4] proposed the symmetric diffeomorphic normalisation method which balanced transformation smoothness against the cross-correlation of intensities between images. The symmetric diffeomorphic normalisation methods are employed to perform the registration of diffusion-weighted images [5], automated segmentation of mouse heart using gated 4D mirco-CT data [7]. Transformations estimated by symmetric algorithms are invertible, differentiable and bijective. Werner et al. compared the performance of diffeomorphic registration with that of symmetric diffeomorphic registration applied to the lung motion estimation in thoracic 4D CT data. They found that diffeomorphic registration and symmetric force definition led to an increased smoothness of the estimated motion fields [8]. However, symmetric diffeomorphic registration has high computational cost generally. Lorenzi et al. [9] utilized stationary velocity fields (SVFs) to simplify the transformations in the log space for symmetric diffeomorphic registration. In addition, symmetric algorithms led to an increased smoothness of the deformation fields when the register images are very similar (small deformation), but might lead to non-topology-preserving deformation results for large non-linear deformation in images.

Inverse consistent registration algorithms jointly estimate the forward and backward transformations, and impose a constraint that the forward and backward transformations are inverse to each other [11–16]. That is, the correspondence made by the forward transformation is consistent with the one by the backward transformation. The inverse consistency of the forward and backward transformations defines a unique correspondence between two images, which can produce smoother deformation results with more biological meaning. Christensen et al. [11] first proposed the idea of consistent image registration. They jointly estimated the forward and backward transformations subject to the constraint that the forward transformation is the inverse function of the backward transformation, and vice versa, to estimate a differentiable and one-to-one transformation. Compared with symmetric algorithms, inverse consistent registration algorithms explicitly penalize asymmetry and lead to more coherent results, such as coherent dose accumulation in image guided radiotherapy [17]. Bender et al. [18] demonstrated the possible utility of consistency metrics for contour based deformable image registration using TPS and EBS deformation; they pointed that good performance in consistency metrics is a necessary but not sufficient condition for an accurate deformation method. Most importantly, inverse consistent transformations preserve the natural topology of an image, that is, they ensure the neighborhood relationships between structures to be same before and after deformation, maintain connected structures remain connected, and avoid artifacts such as “folding” and “tearing” of images. In addition, inverse consistent registration algorithms also make the mapped results be invariant to the mapping direction. In some applications, they seem to be more robust and produce accurate registration [14].

Let I
                     ⊂Ω
                        h
                      and J
                     ⊂Ω
                        g
                      be the source and target images, h and g be the forward and backward transformations, h
                     :Ω
                        h
                     
                     →Ω
                        g
                     , g
                     :Ω
                        g
                     
                     →Ω
                        h
                     , respectively. An inverse consistent registration satisfies h
                     ∘
                     I
                     =
                     J, g
                     ∘
                     J
                     =
                     I, g
                     ∘
                     h
                     =
                     id
                     
                        h
                     , and h
                     ∘
                     g
                     =
                     id
                     
                        g
                     , where the symbol ∘ represents function composition which applies one function to the result of another to produce a third function. id
                     
                        h
                      and id
                     
                        g
                      are the identity maps, id
                     
                        h
                     
                     :Ω
                        h
                     
                     →Ω
                        h
                     , id
                     
                        g
                     
                     :Ω
                        g
                     
                     →Ω
                        g
                     , id
                     
                        h
                      assigns to each element x of Ω
                        h
                      the element x of Ω
                        h
                     , the identity function id
                     
                        g
                      assigns to each element y of Ω
                        g
                      the element y of Ω
                        g
                     . h
                     ∘
                     g
                     =
                     h(g(y)) and g
                     ∘
                     h
                     =
                     g(h(x)) are the composition functions of h and g. For image registration, Ω
                        h
                     
                     =Ω
                        g
                     
                     =Ω is supposed. The method of introducing the inverse consistent constraints into the registration procedure can be divided into two categories: intensity-based and landmark-based. Intensity-based inverse consistent methods aimed at aligning dense image intensities by including inverse consistent penalties in the optimization algorithm [19–23]. Intensity-based algorithms work better for small deformation problem, but lead to mis-registration for large deformation in images.

The other one is landmark-based method, which attempts to find the correspondence of landmarks between images [12,24–27]. Commonly used point landmarks are the unique points in intensity map, such as tip-like, saddle-like and sphere-line structure. Compared with intensity-based image registration algorithms, landmark-based image registration algorithms avoid solving large system of equations and can handle image registration problem with large deformation. Moreover, landmark-based methods are more flexible because registration features can be customized for the particular study [28].

For transformations based on the corresponding landmarks, a set of corresponding landmarks in the images is given, and the estimated transformation is required to map the given landmarks to their corresponding landmarks. Johnson et al. [12] added consistent constraints in the cost function to minimize the error between the forward transformation and the inverse of the backward transformation, and vice versa, given a set of corresponding points. The initial forward and backward transformations are estimated by the thin-plat spline algorithm with periodic boundary conditions based on the correspondence of landmarks. Johnson et al.'s algorithm is useful for image registration with small deformation. He and others [29] expanded Johnson et al.'s algorithm and concatenated a sequence of small deformation transformations to estimate the forward and backward transformations, which are inverse to each other for large deformation registration. However, since inverse of transformations are computed many times during the iterative procedure, Johnson et al.'s algorithm takes long time to compute. Moreover, the correspondence between control points cannot be ensured for Johnson et al.'s algorithm [30].

Researchers have done much work in accelerating the computation of inverse consistent transformations. Chen et al. [19] sought for two pair of half-way transformations that deform source image and target image to an intermediate image and vice versa in a variational registration model. These half-way transformations are inverse to each other to avoid the directional computation of the inverse transformations, and the computational cost of estimating these half-way transformations is much less than the one that estimate the forward and backward transformations between source and target images. Leow et al. [20] proposed a numerical algorithm to solve minimization the inverse consistent constraints in only the forward direction and uni-directionally without explicitly involving the inverse function. Yang et al. [21] computed the forward and backward displacement fields that are inverse to each other in smaller incremental steps by minimizing a symmetric optical flow cost function. A triangulation interpolation is employed to compute the inverse displacement fields quickly. Guetteret et al. [22] used an interleaved optimization scheme constrained by inverse consistency to estimate forward and backward transformations that are inverse to each other. It costs 45% additional time than one-directional registration algorithm. Papiez et al. [23] adopted a Newton–Raphson like method to calculate the inverse transformation, which is more accurate and robust than the method proposed by Christensen and Johnson. Rogelj et al. [10] treated both the source and the target images equally and interacted both of them through forces. The forces that appear on the source image to match it with the target image is related to the image similarity and transformations. As a consequence, transformations put the whole system into the equilibrium state of minimal energy. The advantage of Rogelj et al.'s algorithm is that it does not compute transformation inverses at all. Bondar et al. [27] simultaneously estimated the forward and backward transformations using the robust point matching algorithm. It did not compute the inverses of these two transformations.

Improvement of image registration accuracy can be achieved by solving inverse consistent transformation between images. However, solving the inverse consistent transformations problem is usually much more complicate, and is also very time consuming. In this paper, we propose a fast and efficient algorithm to estimate inverse consistent transformations between images. The proposed algorithm finds the forward and backward transformations that are inverse to each other based on the given correspondence of landmarks. Through using the proposed algorithm, there is no procedure of computing the inverse functions. The forward and backward deformation fields are updated according to the consistent error in the procedure iteratively. Compared with the algorithm proposed by Johnson et al., our algorithm takes much less computation of inverse consistent transformations, which makes it possible for problems with iterative optimization procedures. Moreover, landmarks are mapped exactly to their target positions during the procedure in our algorithm instead of swinging around their target positions in Johnson et al.'s method. Furthermore, we employ our algorithm to estimate the transformations between two point set used in robust point matching to demonstrate the performance of our algorithm in image registration.

The remainder of this paper is organized as follows. We describe our algorithm to estimate inverse consistent transformations in Section 2. Application of our algorithm in robust point matching is given in Section 3. Experiments on random point sets and medical images demonstrate the feasibility of our algorithm in Section 4. Finally, conclusion is presented in Section 5.

@&#METHODOLOGY@&#

In landmark-based registration, corresponding landmarks are used to compute the transformation that maps a source image onto a target image. Given the source landmark set X
                        ={x
                        
                           i
                        , i
                        =1, …, N} extracted from the source image I
                        ⊂Ω, and the target landmark set Y
                        ={y
                        
                           i
                        , i
                        =1, …, N} extracted from the target image J
                        ⊂Ω, x
                        
                           i
                         is corresponding to y
                        
                           i
                        , i
                        =1, …, N, respectively. The deformation fields of RBFs-based transformations are computed by combining the displacements defined on the landmarks using different basis functions. The weighting coefficient of each basis function is calculated so that the resultant deformation field fits the landmark displacements [31,32]. The forward transformation h
                        :
                        I
                        →
                        J is calculated by
                           
                              (1)
                              
                                 h
                                 (
                                 x
                                 )
                                 =
                                 
                                    β
                                    0
                                 
                                 +
                                 
                                    ∑
                                    
                                       j
                                       =
                                       1
                                    
                                    S
                                 
                                 
                                    β
                                    j
                                 
                                 
                                    x
                                    
                                       (
                                       j
                                       )
                                    
                                 
                                 +
                                 
                                    ∑
                                    
                                       i
                                       =
                                       1
                                    
                                    N
                                 
                                 
                                    ω
                                    i
                                 
                                 R
                                 (
                                 ∥
                                 x
                                 −
                                 
                                    x
                                    i
                                 
                                 ∥
                                 )
                                 ,
                              
                           
                        where R(r) is a radial basis function with r
                        ≥0 defined as the distance between two points, ∥x−
                        x
                        
                           i
                        
                        ∥ is the Euclidean distance between a point x
                        ∈
                        R
                        
                           S
                         and the landmark x
                        
                           i
                        
                        ∈
                        R
                        
                           S
                        . x
                        (j) is the jth component of x. N is the number of control points. β
                        
                           j
                         and ω
                        
                           i
                         are the affine transformation coefficients and elastic transformation coefficients, respectively. The coefficients 
                           β
                        
                        =(β
                        0, …, β
                        
                           S
                        )
                           T
                         and 
                           ω
                        
                        =(ω
                        1, …, ω
                        
                           N
                        )
                           T
                         are derived by solving the following equation
                           
                              (2)
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         K
                                                      
                                                   
                                                
                                                
                                                   
                                                      
                                                         X
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         
                                                            X
                                                         
                                                      
                                                      T
                                                   
                                                
                                                
                                                   0
                                                
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         ω
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         β
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         Y
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   0
                                                
                                             
                                          
                                       
                                    
                                 
                                 .
                              
                           
                        The elements of the matrix 
                           K
                         are k
                        
                           ij
                        
                        =
                        R(∥
                        x
                        
                           i
                        
                        −
                        x
                        
                           j
                        
                        ∥). The matrix 
                           X
                         and 
                           Y
                         are homogeneous coordinates matrices of X and Y, details can be referred in [33]. Similarly, the backward transformation g
                        :
                        J
                        →
                        I is estimated using Eq. (1) by considering Y and X as source and target landmarks.

The forward transformation h(x) maps the landmarks in the source image to the corresponding landmarks in the target image. Accordingly, the backward transformation g(x) maps the landmarks in the target image to the corresponding landmarks in the source image. Thin-plat splines are the most commonly used radial basis function in RBFs-based transformations, where the radial basis function is R(r)=−
                        r
                        2logr
                        2, and minimize the bending energy function of transformations. Unfortunately, RBFs-based transformations do not define a consistent correspondence between two images except at the landmarks. That is, when point p in the source image is mapped to an only point q in the target image by the forward transformation h, but, point q in the target image cannot be assured to be mapped to point p in the source image by the backward transformation g.

The goal of our algorithm is to estimate the forward and backward transformations for source and target images using two given corresponding point sets from these two images. First, we introduce several notations used in this paper. The inverse of the forward transformation is h
                        −1, and the backward transformation is g
                        −1. The displacements of the forward and backward transformations are u(x)=
                        f(x)−
                        x and 
                           w
                           (
                           x
                           )
                           =
                           g
                           (
                           x
                           )
                           −
                           x
                        , respectively. Johnson et al. [12] introduced the inverse consistency constraint ∥h−
                        g
                        −1
                        ∥+∥
                        g
                        −
                        h
                        −1
                        ∥ to a cost function, which enforces that the forward transformation is as close to the inverse of the backward transformation as possible. Moreover, the backward transformation is as close to the inverse of the forward transformation as possible. That is, the inverse consistent transformations are required to satisfy h
                        =
                        g
                        −1 and g
                        =
                        h
                        −1. The cost function is given by
                           
                              (3)
                              
                                 E
                                 (
                                 h
                                 ,
                                 g
                                 )
                                 =
                                 
                                    ∑
                                    
                                       i
                                       =
                                       1
                                    
                                    N
                                 
                                 (
                                 ∥
                                 
                                    y
                                    i
                                 
                                 −
                                 h
                                 (
                                 
                                    x
                                    i
                                 
                                 )
                                 
                                    ∥
                                    2
                                 
                                 +
                                 ∥
                                 
                                    x
                                    i
                                 
                                 −
                                 g
                                 (
                                 
                                    y
                                    i
                                 
                                 )
                                 
                                    ∥
                                    2
                                 
                                 )
                                 +
                                 λ
                                 ∥
                                 Lh
                                 
                                    ∥
                                    2
                                 
                                 +
                                 λ
                                 ∥
                                 Lg
                                 
                                    ∥
                                    2
                                 
                                 +
                                 χ
                                 (
                                 ∥
                                 h
                                 −
                                 
                                    g
                                    
                                       −
                                       1
                                    
                                 
                                 
                                    ∥
                                    2
                                 
                                 +
                                 ∥
                                 g
                                 −
                                 
                                    h
                                    
                                       −
                                       1
                                    
                                 
                                 
                                    ∥
                                    2
                                 
                                 )
                                 ,
                              
                           
                        where L is a symmetric linear differential operator, which is used to measure the bending energy of the deformation field. Johnson et al. [12] proposed the consistent landmark thin-plate spline (CL-TPS) registration algorithm originally to solve the inversely consistent transformations between two corresponding point sets. In CL-TPS, the manually identified landmarks are given, and thin-plate splines (TPS) are employed to estimate an initial global transformation. Next, an iterative procedure is performed to minimize the cost function (3). Details of CL-TPS algorithm are shown in Algorithm 1 
                        [12]. However, there is a swing problem in CL-TPS. That is, x
                        
                           i
                         can be mapped to a position near y
                        
                           i
                         by the forward transformation h, but cannot be mapped to y
                        
                           i
                         exactly [30]. The same goes for the backward transformation also. Moreover, computation of the inverse functions, such as h
                        −1 and g
                        −1, is performed many times in the iterative procedure of CL-TPS, which is very time consuming and makes it less suitable for problems with iterative optimization procedures.


                        
                           Algorithm 1
                           Consistent Landmark Thin-Plate Spline (CL-TPS) registration algorithm.
                                 
                                    1:
                                    Let r
                                       
                                          i
                                       
                                       =
                                       x
                                       
                                          i
                                       , s
                                       
                                          i
                                       
                                       =
                                       y
                                       
                                          i
                                       ; u(x)=0, 
                                          w
                                          (
                                          x
                                          )
                                          =
                                          0
                                       , the steps α and β, the mapping error threshold ξ of control point, and the maximum number of iteration m
                                       
                                          iter
                                       , k
                                       =1.

The periodic boundary TPS is performed to estimate the temporary forward transformation f
                                       1(x) based on the correspondence between r
                                       
                                          i
                                        and y
                                       
                                          i
                                       , and the temporary backward transformation f
                                       2(x) based on the correspondence between s
                                       
                                          i
                                        and x
                                       
                                          i
                                       .

Update the displacements, u(x)=
                                       u(x)+
                                       αu(x) and 
                                          w
                                          (
                                          x
                                          )
                                          =
                                          w
                                          (
                                          x
                                          )
                                          +
                                          α
                                          w
                                          (
                                          x
                                          )
                                          .
                                       
                                    


                                       r
                                       
                                          i
                                        and s
                                       
                                          j
                                        are updated as r
                                       
                                          i
                                       
                                       =
                                       x
                                       
                                          i
                                       
                                       +
                                       u(x
                                       
                                          i
                                       ), 
                                          
                                             s
                                             j
                                          
                                          =
                                          
                                             y
                                             j
                                          
                                          +
                                          w
                                          (
                                          
                                             y
                                             j
                                          
                                          )
                                       .

Get h
                                       −1(x), the inverse function of forward transformation and g
                                       −1(x), the inverse function of backward transformation.

Update displacement field of forward and backward transformation. u(x)=
                                       u(x)−
                                       β[u(x)−
                                       g
                                       −1(x)+
                                       x], meanwhile, 
                                          w
                                          (
                                          x
                                          )
                                          =
                                          w
                                          (
                                          x
                                          )
                                          −
                                          β
                                          [
                                          w
                                          (
                                          x
                                          )
                                          −
                                          
                                             h
                                             
                                                −
                                                1
                                             
                                          
                                          (
                                          x
                                          )
                                          +
                                          x
                                          ]
                                       .

Check whether the termination condition is met. If k
                                       >
                                       m
                                       
                                          iter
                                        or 
                                          |
                                          u
                                          (
                                          
                                             x
                                             i
                                          
                                          )
                                          −
                                          (
                                          
                                             v
                                             i
                                          
                                          −
                                          
                                             x
                                             i
                                          
                                          )
                                          |
                                          <
                                          ξ
                                        or 
                                          |
                                          w
                                          (
                                          
                                             y
                                             j
                                          
                                          )
                                          −
                                          (
                                          
                                             z
                                             j
                                          
                                          −
                                          
                                             y
                                             j
                                          
                                          )
                                          |
                                          <
                                          ξ
                                       , the iteration is terminated; otherwise, k
                                       =
                                       k
                                       +1, go to step 2.

We propose a novel algorithm to estimate the forward and backward transformations that are inverse to each other based on the correspondence between points. Instead of computing the inverse of transformations, a new cost function is defined as
                           
                              (4)
                              
                                 
                                    E
                                    c
                                 
                                 (
                                 h
                                 ,
                                 g
                                 )
                                 =
                                 
                                    ∑
                                    
                                       i
                                       =
                                       1
                                    
                                    N
                                 
                                 (
                                 ∥
                                 
                                    y
                                    i
                                 
                                 −
                                 h
                                 (
                                 
                                    x
                                    i
                                 
                                 )
                                 
                                    ∥
                                    2
                                 
                                 +
                                 ∥
                                 
                                    x
                                    i
                                 
                                 −
                                 g
                                 (
                                 
                                    y
                                    i
                                 
                                 )
                                 
                                    ∥
                                    2
                                 
                                 )
                                 +
                                 λ
                                 ∥
                                 Lh
                                 
                                    ∥
                                    2
                                 
                                 +
                                 λ
                                 ∥
                                 Lg
                                 
                                    ∥
                                    2
                                 
                                 +
                                 χ
                                 (
                                 ∥
                                 
                                    id
                                    g
                                 
                                 −
                                 h
                                 ∘
                                 g
                                 
                                    ∥
                                    2
                                 
                                 +
                                 ∥
                                 
                                    id
                                    h
                                 
                                 −
                                 g
                                 ∘
                                 h
                                 
                                    ∥
                                    2
                                 
                                 )
                                 .
                              
                           
                        The term ∥h
                        −
                        g
                        −1
                        ∥
                        2
                        +∥
                        g
                        −
                        h
                        −1
                        ∥
                        2 in Eq. (3) is replaced by the term ∥id
                        
                           g
                        
                        −
                        h
                        ∘
                        g
                        ∥
                        2
                        +∥
                        id
                        
                           h
                        
                        −
                        g
                        ∘
                        h
                        ∥
                        2 in Eq. 4, while ∥id
                        
                           g
                        
                        −
                        h
                        ∘
                        g
                        ∥
                        2
                        +∥
                        id
                        
                           h
                        
                        −
                        g
                        ∘
                        h
                        ∥
                        2 is only related to two transformations h and g, rather than four transformations h, h
                        −1, g
                        −1 and g.

Here, we briefly prove the equivalent between id
                        
                           g
                        
                        =
                        h
                        ∘
                        g and h
                        =
                        g
                        −1, and the equivalent between id
                        
                           h
                        
                        =
                        g
                        ∘
                        h and g
                        =
                        h
                        −1. Let h
                        :Ω
                           h
                        
                        →Ω
                           g
                         be an arbitrary bijective function, based on the definition of inverse function, the function g
                        :Ω
                           g
                        
                        →Ω
                           h
                         is an inverse of h if and only if
                           
                              (5)
                              
                                 
                                    
                                       
                                          for
                                             
                                          all
                                             
                                          x
                                          ∈
                                          
                                             Ω
                                             h
                                          
                                          ,
                                             
                                          g
                                          (
                                          h
                                          (
                                          x
                                          )
                                          )
                                          =
                                          x
                                          ,
                                       
                                       
                                    
                                    
                                       
                                          for
                                             
                                          all
                                             
                                          y
                                          ∈
                                          
                                             Ω
                                             g
                                          
                                          ,
                                             
                                          h
                                          (
                                          g
                                          (
                                          y
                                          )
                                          )
                                          =
                                          y
                                          .
                                       
                                       
                                    
                                 
                              
                           
                        Another way of stating the same property is that g
                        ∘
                        h
                        =
                        id
                        
                           h
                         and h
                        ∘
                        g
                        =
                        id
                        
                           g
                        . It means when h
                        ∘
                        g
                        =
                        id
                        
                           g
                        , g
                        ∘
                        h
                        =
                        id
                        
                           h
                        , and h and g are bijective functions, h is the inverse function of g and g is the inverse function of h. It implies that minimizing ∥id
                        
                           g
                        
                        −
                        h
                        ∘
                        g
                        ∥
                        2
                        +∥
                        id
                        
                           h
                        
                        −
                        g
                        ∘
                        h
                        ∥
                        2 is equivalent to minimizing ∥h
                        −
                        g
                        −1
                        ∥
                        2
                        +∥
                        g
                        −
                        h
                        −1
                        ∥
                        2. Therefore, the cost function (3) is equivalent to the cost function (4). Thus, there is no extra conditions to be included before we use the new cost function to estimate the inverse consistent transformations. Most importantly, computation of g
                        ∘
                        h and h
                        ∘
                        g will cost less time than computation of inverse functions h
                        −1 and g
                        −1. Next, we will propose a fast inverse consistent landmark-based (FCL) registration algorithm to minimize the cost function (4) as Algorithm 2.


                        
                           Algorithm 2
                           Fast inverse consistent landmark-based registration algorithm.
                                 
                                    
                                       Require:
                                    

  The source point set X and the corresponding target point set Y;

  The step parameters α, 0<
                                       α
                                       <1, the minimum mapping error threshold of points ξ, and the maximum number of iteration m
                                       
                                          iter
                                       ;


                                       Ensure:
                                       
                                          
                                             1:
                                             Estimate the initial forward transformation h(x) and the initial backward transformation g(y) using RBFs-based transformations by subjecting to h(x
                                                
                                                   i
                                                )=
                                                y
                                                
                                                   i
                                                 and g(y
                                                
                                                   i
                                                )=
                                                x
                                                
                                                   i
                                                ; k
                                                =1;

Compute the inverse consistent errors, δ
                                                1(x)=
                                                x
                                                −
                                                g(h(x)), and δ
                                                2(y)=
                                                y
                                                −
                                                f(g(y));

Update the forward and backward transformations h(x)=
                                                h(x)+
                                                αδ
                                                1(x), and g(y)=
                                                g(y)+
                                                αδ
                                                2(y);


                                                k
                                                =
                                                k
                                                +1, check whether the termination criterion is satisfied. If k
                                                >
                                                m
                                                
                                                   iter
                                                , or the inverse consistent error δ
                                                1(x) or δ
                                                2(y) is less than ξ, then the iteration is terminated; otherwise, go to 2;


                                                return 
                                                h and g;

Our algorithm is initialized with the forward and reverse transformation h and g estimated using RBFs-based transformations based on the correspondence of landmarks. In cases where the topology-preserving transformation assumption holds, the forward and backward transformations are with minimum Jacobian greater than zero in generally. The inverse consistent errors are computed as g(h(x))−
                        x and f(g(y))−
                        y, instead of ∥h
                        −
                        g
                        −1
                        ∥
                        2 and ∥g
                        −
                        h
                        −1
                        ∥
                        2. Since computation of the inverse functions is not performed, it will take less time to compute the inverse consistent errors. The forward inverse consistent error δ
                        1(x) and the backward inverse consistent error δ
                        2(y) are used to update the current estimate of the forward and backward transformation, respectively. Parameter α should generally be a small value to preserve the topology of the updated transformations. Fig. 1
                         illustrates the idea of the inverse consistent errors. The point x in image I is mapped to the point h(x) in image J by the forward transformation. Next, the point h(x) is mapped to g(h(x)) by the backward transformation g(y). The forward consistent error is illustrated as δ
                        1. At the same time, the point y in image J is mapped to the point g(y) in image I by the backward transformation, and the point g(y) is mapped to h(g(y)) in image J next by the forward transformation h(x). The backward consistent error is shown as δ
                        2. The consistent errors δ
                        1 and δ
                        2 are used to update the forward and backward transformation, respectively. This procedure is repeated until the consistent error is satisfied or the maximum iteration number is reached.

Indeed, the FCL algorithm is a procedure of updating the forward transformation to ensure g
                        =
                        h
                        −1, and updating the backward transformation to ensure h
                        =
                        g
                        −1 simultaneously. Take the update of the forward transformation for instance, g is expected to be the inverse of h. We treat g as the current estimated inverse of h. if g
                        =
                        h
                        −1, then g(h(x))=
                        x, the forward consistent error is zero, and the forward transformation remains unchanged. Otherwise, the forward consistent error δ
                        1
                        =
                        x
                        −
                        g(h(x)) is the error of the inverse of the current h. Fig. 2
                         shows an example which takes the convergence process of forward transformation. x is mapped to the red point after updating the forward transformation by adding αδ
                        1. Next, the red point is mapped to the blur point by the backward transformation. If the backward deformation is small and topology-preserving, the error of the inverse of the updated forward transformation 
                           
                              δ
                              1
                              ′
                           
                         is less than that before update. After several times of iterative computation, g will get closer and closer to h
                        −1.

In this subsection, we will prove the convergence of the fast inverse consistent landmark-based registration algorithm. It is assumed that the forward and backward transformation h, g are continuously differentiable mapping from Ω→Ω with positive Jacobian determinants for all x
                        ∈Ω and y
                        ∈Ω, respectively. In FCL, the forward and backward transformation subjecting to g
                        ∘
                        h
                        =
                        id
                        
                           h
                         and h
                        ∘
                        g
                        =
                        id
                        
                           g
                         can be found by selecting a point x
                        ∈Ω and a point y
                        ∈Ω, and perform an optimization process to search for a mapped value of x and a mapped value of y using the forward transformation h(x) and the backward transformation g(x), which make the distance ∥x
                        −
                        g
                        ∘
                        h(x)∥
                        2
                        +∥
                        y
                        −
                        h
                        ∘
                        g(y)∥
                        2 smaller than a given threshold ξ. This can be denoted as an unconstrained minimization problem with the object function f(h, g)=∥
                        x
                        −
                        g
                        ∘
                        h(x)∥
                        2
                        +∥
                        y
                        −
                        h
                        ∘
                        g(y)∥
                        2, ∀x
                        ∈Ω, y
                        ∈Ω. That is, find h
                        *
                        ∈Ω and g
                        *
                        ∈Ω for which f(h
                        *, g
                        *)≤
                        f(h, g) for every (x, y)∈Ω×Ω.

We denote the current h(x) as h
                        
                           k
                         and the current g(y) as g
                        
                           k
                        . During the procedure of FCL, h
                        
                           k
                         and g
                        
                           k
                         are updated as
                           
                              (6)
                              
                                 
                                    
                                       
                                       
                                          
                                             h
                                             
                                                k
                                                +
                                                1
                                             
                                          
                                          =
                                          
                                             h
                                             k
                                          
                                          +
                                          α
                                          (
                                          x
                                          −
                                          
                                             g
                                             k
                                          
                                          (
                                          
                                             h
                                             k
                                          
                                          )
                                          )
                                          ,
                                       
                                    
                                    
                                       
                                       
                                          
                                             g
                                             
                                                k
                                                +
                                                1
                                             
                                          
                                          =
                                          
                                             g
                                             k
                                          
                                          +
                                          α
                                          (
                                          y
                                          −
                                          
                                             h
                                             k
                                          
                                          (
                                          
                                             g
                                             k
                                          
                                          )
                                          )
                                          ,
                                       
                                    
                                 
                              
                           
                        where d
                        
                           k
                        
                        =[x
                        −
                        g
                        
                           k
                        (h
                        
                           k
                        )
                        y
                        −
                        h
                        
                           k
                        (g
                        
                           k
                        )]
                           T
                         is the perturbation direction. Next, we will prove that d
                        
                           k
                         is the descent direction of f(h, g) from (h
                        
                           k
                        , g
                        
                           k
                        ). Since f(h
                        
                           k
                        , g
                        
                           k
                        ) is a scalar with two parameters, the directional derivative of f(h, g) at (h
                        
                           k
                        , g
                        
                           k
                        ) is
                           
                              (7)
                              
                                 ∇
                                 f
                                 (
                                 
                                    h
                                    k
                                 
                                 ,
                                 
                                    g
                                    k
                                 
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   −
                                                   2
                                                   
                                                      J
                                                      g
                                                      T
                                                   
                                                   (
                                                   
                                                      h
                                                      k
                                                   
                                                   )
                                                   (
                                                   x
                                                   −
                                                   
                                                      g
                                                      k
                                                   
                                                   (
                                                   
                                                      h
                                                      k
                                                   
                                                   )
                                                   )
                                                
                                             
                                             
                                                
                                                   −
                                                   2
                                                   
                                                      J
                                                      h
                                                      T
                                                   
                                                   (
                                                   
                                                      g
                                                      k
                                                   
                                                   )
                                                   (
                                                   y
                                                   −
                                                   
                                                      h
                                                      k
                                                   
                                                   (
                                                   
                                                      g
                                                      k
                                                   
                                                   )
                                                   )
                                                
                                             
                                          
                                       
                                    
                                 
                                 ,
                              
                           
                        where J
                        
                           g
                        (h
                        
                           k
                        ) is the Jacobian matrix of g
                        
                           k
                         at h
                        
                           k
                        , and J
                        
                           h
                        (g
                        
                           k
                        ) is the Jacobian matrix of h
                        
                           k
                         at g
                        
                           k
                        . Then, the directional derivative of f(h, g) at (h
                        
                           k
                        , g
                        
                           k
                        ) in the direction of d
                        
                           k
                         is
                           
                              (8)
                              
                                 
                                    
                                       [
                                       ∇
                                       f
                                       (
                                       
                                          h
                                          k
                                       
                                       ,
                                       
                                          g
                                          k
                                       
                                       )
                                       ]
                                    
                                    T
                                 
                                 
                                    d
                                    k
                                 
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      −
                                                      2
                                                      
                                                         J
                                                         g
                                                         T
                                                      
                                                      (
                                                      
                                                         h
                                                         k
                                                      
                                                      )
                                                      (
                                                      x
                                                      −
                                                      
                                                         g
                                                         k
                                                      
                                                      (
                                                      
                                                         h
                                                         k
                                                      
                                                      )
                                                      )
                                                   
                                                
                                                
                                                   
                                                      −
                                                      2
                                                      
                                                         J
                                                         h
                                                         T
                                                      
                                                      (
                                                      
                                                         g
                                                         k
                                                      
                                                      )
                                                      (
                                                      y
                                                      −
                                                      
                                                         h
                                                         k
                                                      
                                                      (
                                                      
                                                         g
                                                         k
                                                      
                                                      )
                                                      )
                                                   
                                                
                                             
                                          
                                       
                                    
                                    T
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   x
                                                   −
                                                   
                                                      g
                                                      k
                                                   
                                                   (
                                                   
                                                      h
                                                      k
                                                   
                                                   )
                                                
                                             
                                             
                                                
                                                   y
                                                   −
                                                   
                                                      h
                                                      k
                                                   
                                                   (
                                                   
                                                      g
                                                      k
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                    
                                 
                                 =
                                 −
                                 2
                                 [
                                 
                                    
                                       (
                                       x
                                       −
                                       
                                          g
                                          k
                                       
                                       (
                                       
                                          h
                                          k
                                       
                                       )
                                       )
                                    
                                    T
                                 
                                 
                                    J
                                    g
                                 
                                 (
                                 
                                    h
                                    k
                                 
                                 )
                                 (
                                 x
                                 −
                                 
                                    g
                                    k
                                 
                                 (
                                 
                                    h
                                    k
                                 
                                 )
                                 )
                                 +
                                 
                                    
                                       (
                                       y
                                       −
                                       
                                          h
                                          k
                                       
                                       (
                                       
                                          g
                                          k
                                       
                                       )
                                       )
                                    
                                    T
                                 
                                 
                                    J
                                    h
                                 
                                 (
                                 
                                    g
                                    k
                                 
                                 )
                                 (
                                 y
                                 −
                                 
                                    h
                                    k
                                 
                                 (
                                 
                                    g
                                    k
                                 
                                 )
                                 )
                                 ]
                                 .
                              
                           
                        
                     

Since the initial forward and backward transformations h
                        0 and g
                        0, are computed using non-rigid RBFs transformations, h
                        
                           k
                         and g
                        
                           k
                         should be non-rigid transformations also. Unfortunately, it is difficult to derive J
                        
                           g
                        (h
                        
                           k
                        ) and J
                        
                           h
                        (g
                        
                           k
                        ) for non-rigid transformations. We approximate h
                        
                           k
                         at x by an affine transformation. Take two dimensional affine transformations for example, x
                        =(x
                        (1), x
                        (2)), h
                        
                           k
                        (x)=(h
                        
                           k,1(x), h
                        
                           k,2(x)). h
                        
                           k
                         can be approximated as an affine transformation h
                        
                           k
                        (x)=
                        Hx
                        +
                        s
                        
                           h
                        , where 
                           H
                           =
                           
                              
                                 
                                    
                                       
                                          
                                             
                                                a
                                                11
                                             
                                          
                                          
                                             
                                                a
                                                12
                                             
                                          
                                       
                                       
                                          
                                             
                                                a
                                                21
                                             
                                          
                                          
                                             
                                                a
                                                22
                                             
                                          
                                       
                                    
                                 
                              
                           
                         is a affine matrix, and 
                           
                              s
                              h
                           
                           =
                           
                              
                                 
                                    
                                       
                                          
                                             
                                                a
                                                10
                                             
                                          
                                       
                                       
                                          
                                             
                                                a
                                                20
                                             
                                          
                                       
                                    
                                 
                              
                           
                         is the translation vector. Similarly, g
                        
                           k
                         is modelled at y
                        =(y
                        (1), y
                        (2)) by an affine transformation also, g
                        
                           k
                        
                        =
                        Gy
                        +
                        s
                        
                           g
                        , where 
                           G
                           =
                           
                              
                                 
                                    
                                       
                                          
                                             
                                                b
                                                11
                                             
                                          
                                          
                                             
                                                b
                                                12
                                             
                                          
                                       
                                       
                                          
                                             
                                                b
                                                21
                                             
                                          
                                          
                                             
                                                b
                                                22
                                             
                                          
                                       
                                    
                                 
                              
                           
                         is the affine matrix and 
                           
                              s
                              g
                           
                           =
                           
                              
                                 
                                    
                                       
                                          
                                             
                                                b
                                                10
                                             
                                          
                                       
                                       
                                          
                                             
                                                b
                                                20
                                             
                                          
                                       
                                    
                                 
                              
                           
                         is the translation vector. So, the Jacobian matrices become J
                        
                           h
                        (g
                        
                           k
                        )=
                        H, and J
                        
                           g
                        (h
                        
                           k
                        )=
                        G.

Take the forward transformation for example, the Jacobian matrix H can be used to represent a linear mapping that maps the standard basis vectors (1, 0) to (a
                        11, a
                        21), and (0, 1) to (a
                        12, a
                        22). In this case, a unit square is mapped to a parallelogram with vertices at (0, 0), (a
                        11, a
                        21), (a
                        11
                        +
                        a
                        12, a
                        21
                        +
                        a
                        22), and (a
                        12, a
                        22), as shown in Fig. 3
                        . The Jacobian determinant |J
                        
                           h
                        (g
                        
                           k
                        )|=
                        a
                        11
                        a
                        22
                        −
                        a
                        12
                        a
                        21 is the area of the parallelogram, and represents the scale factor by which areas are transformed by H. It is noted that in cases where the topology-preserving transformation assumption holds, the minimum Jacobian of the forward transformation is greater than zero, that is, |J
                        
                           h
                        (g
                        
                           k
                        )|=
                        a
                        11
                        a
                        22
                        −
                        a
                        12
                        a
                        21
                        >0. The above equation implies that the linear mapping defined by H is orientation-preserving, the oriented area of the parallelogram is the same as the usual area. For most cases in medical image registration, it is reasonable to assume that a
                        11
                        >0 and a
                        22
                        >0, moreover, a
                        11
                        ≫
                        a
                        21, and a
                        22
                        ≫
                        a
                        12. Then


                        
                           
                              (9)
                              
                                 
                                    
                                       
                                          
                                          
                                             
                                                
                                                   (
                                                   y
                                                   −
                                                   
                                                      h
                                                      k
                                                   
                                                   (
                                                   
                                                      g
                                                      k
                                                   
                                                   )
                                                   )
                                                
                                                T
                                             
                                             
                                                J
                                                h
                                             
                                             (
                                             
                                                g
                                                k
                                             
                                             )
                                             (
                                             y
                                             −
                                             
                                                h
                                                k
                                             
                                             (
                                             
                                                g
                                                k
                                             
                                             )
                                             )
                                          
                                       
                                       
                                          
                                          
                                             =
                                             
                                                a
                                                11
                                             
                                             
                                                
                                                   (
                                                   
                                                      y
                                                      
                                                         (
                                                         1
                                                         )
                                                      
                                                   
                                                   −
                                                   
                                                      h
                                                      
                                                         k
                                                         ,
                                                         1
                                                      
                                                   
                                                   (
                                                   
                                                      g
                                                      k
                                                   
                                                   )
                                                   )
                                                
                                                2
                                             
                                             +
                                             
                                                a
                                                22
                                             
                                             
                                                
                                                   (
                                                   
                                                      y
                                                      
                                                         (
                                                         2
                                                         )
                                                      
                                                   
                                                   −
                                                   
                                                      h
                                                      
                                                         k
                                                         ,
                                                         2
                                                      
                                                   
                                                   (
                                                   
                                                      g
                                                      k
                                                   
                                                   )
                                                   )
                                                
                                                2
                                             
                                             +
                                             (
                                             
                                                a
                                                12
                                             
                                             +
                                             
                                                a
                                                21
                                             
                                             )
                                             (
                                             
                                                y
                                                
                                                   (
                                                   1
                                                   )
                                                
                                             
                                             −
                                             
                                                h
                                                
                                                   k
                                                   ,
                                                   1
                                                
                                             
                                             (
                                             
                                                g
                                                k
                                             
                                             )
                                             )
                                             (
                                             
                                                y
                                                
                                                   (
                                                   2
                                                   )
                                                
                                             
                                             −
                                             
                                                h
                                                
                                                   k
                                                   ,
                                                   2
                                                
                                             
                                             (
                                             
                                                g
                                                k
                                             
                                             )
                                             )
                                          
                                       
                                       
                                          
                                          
                                             =
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  a
                                                                  11
                                                               
                                                            
                                                         
                                                         (
                                                         
                                                            y
                                                            
                                                               (
                                                               1
                                                               )
                                                            
                                                         
                                                         −
                                                         
                                                            h
                                                            
                                                               k
                                                               ,
                                                               1
                                                            
                                                         
                                                         (
                                                         
                                                            g
                                                            k
                                                         
                                                         )
                                                         )
                                                         +
                                                         
                                                            
                                                               
                                                                  a
                                                                  12
                                                               
                                                               +
                                                               
                                                                  a
                                                                  21
                                                               
                                                            
                                                            
                                                               2
                                                               
                                                                  
                                                                     
                                                                        a
                                                                        11
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                         (
                                                         
                                                            y
                                                            
                                                               (
                                                               2
                                                               )
                                                            
                                                         
                                                         −
                                                         
                                                            h
                                                            
                                                               k
                                                               ,
                                                               2
                                                            
                                                         
                                                         (
                                                         
                                                            g
                                                            k
                                                         
                                                         )
                                                         )
                                                      
                                                   
                                                
                                                2
                                             
                                             +
                                             
                                                
                                                   
                                                      
                                                         a
                                                         22
                                                      
                                                      −
                                                      
                                                         
                                                            
                                                               
                                                                  (
                                                                  
                                                                     a
                                                                     12
                                                                  
                                                                  +
                                                                  
                                                                     a
                                                                     21
                                                                  
                                                                  )
                                                               
                                                               2
                                                            
                                                         
                                                         
                                                            4
                                                            
                                                               a
                                                               11
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   (
                                                   
                                                      y
                                                      
                                                         (
                                                         2
                                                         )
                                                      
                                                   
                                                   −
                                                   
                                                      h
                                                      
                                                         k
                                                         ,
                                                         2
                                                      
                                                   
                                                   (
                                                   
                                                      g
                                                      k
                                                   
                                                   )
                                                   )
                                                
                                                2
                                             
                                             .
                                          
                                       
                                    
                                 
                                 .
                              
                           
                        As we know, for small deformation, a
                        11
                        ≫
                        a
                        21 and a
                        22
                        ≫
                        a
                        12 holds, then 
                           
                              
                                 
                                    
                                       a
                                       22
                                    
                                    −
                                    
                                       
                                          
                                             
                                                (
                                                
                                                   a
                                                   12
                                                
                                                +
                                                
                                                   a
                                                   21
                                                
                                                )
                                             
                                             2
                                          
                                       
                                       
                                          4
                                          
                                             a
                                             11
                                          
                                       
                                    
                                 
                              
                           
                           >
                           0
                         is easily satisfied. Even for large deformation in medical image registration, above conditions can be satisfied in most cases (following experiments demonstrate this point). Then, (y
                        −
                        h
                        
                           k
                        (g
                        
                           k
                        ))
                           T
                        
                        J
                        
                           h
                        (g
                        
                           k
                        )(y
                        −
                        h
                        
                           k
                        (g
                        
                           k
                        ))>0 can be derived. Similarly, we can prove (x
                        −
                        g
                        
                           k
                        (h
                        
                           k
                        ))
                           T
                        
                        J
                        
                           h
                        (h
                        
                           k
                        )(x
                        −
                        g
                        
                           k
                        (h
                        
                           k
                        ))>0 for the backward deformation. Therefore, for most cases in medical image registration, the following is satisfied
                           
                              (10)
                              
                                 
                                    
                                       [
                                       ∇
                                       f
                                       (
                                       
                                          h
                                          k
                                       
                                       ,
                                       
                                          g
                                          k
                                       
                                       )
                                       ]
                                    
                                    T
                                 
                                 
                                    d
                                    k
                                 
                                 <
                                 0
                                 .
                              
                           
                        That is, d
                        
                           k
                         is a descent direction from (h
                        
                           k
                        , g
                        
                           k
                        ). If Eq. (10) holds, then it is guaranteed that for small positive α, f((h
                        
                           k
                        , g
                        
                           k
                        )+
                        αd
                        
                           k
                        )≤
                        f(h
                        
                           k
                        , g
                        
                           k
                        ).

Gradient descent method is a first-order optimization algorithm to find a local minimum of the multi-variable function f(h, g)=∥
                        x
                        −
                        g
                        ∘
                        h(x)∥
                        2
                        +∥
                        y
                        −
                        h
                        ∘
                        g(y)∥
                        2, ∀x
                        ∈Ω
                           h
                        , y
                        ∈Ω
                           g
                        . If f(h, g) is differentiable at the point (h, g), the way gradient descent method works in is we take the gradient (or of the approximate gradient) of the function at (h, g), ∇f(h, g), and update the current point (h, g) by taking steps proportional to the direction of the negative gradient −∇
                        f(h, g), 
                           
                              h
                              
                                 k
                                 +
                                 1
                              
                           
                           =
                           
                              h
                              k
                           
                           +
                           2
                           α
                           
                              J
                              g
                              T
                           
                           (
                           
                              h
                              k
                           
                           )
                           (
                           x
                           −
                           
                              g
                              k
                           
                           (
                           
                              h
                              k
                           
                           )
                           )
                           ,
                           
                              g
                              
                                 k
                                 +
                                 1
                              
                           
                           =
                           
                              g
                              k
                           
                           +
                           2
                           α
                           
                              J
                              h
                              T
                           
                           (
                           
                              g
                              k
                           
                           )
                           (
                           y
                           −
                           
                              h
                              k
                           
                           (
                           
                              g
                              k
                           
                           )
                           )
                        . Then f(h, g) decreases fastest along the −∇
                        f(h, g) direction. It will eventually converge to a local minimum where the gradient is zero. Unfortunately, the negative gradient −∇
                        f(h, g) in the classic gradient descent method is sensitive to the noisy of f(h, g), which means too expanded or shrunken deformation will result in large gradient, and lead to (h, g) deviation from the optimal solution.

In FCL, the initially selected value of (h, g) should not be far from the final estimate (h
                        *, g
                        *). In this case, FCL should work almost as well as gradient descent method. While it may seem totally ad hoc, it also turns out to work well. Although the convergence of the FCL is slightly slower than a properly chosen gradient descent method, the computation complexity of FCL is smaller than that of the classic gradient descent method. It is usually more efficient in terms of f(h, g) evaluations required to achieve a specified accuracy.

During the procedure of FCL algorithm, source landmarks are mapped to the corresponding positions using the current forward transformation, and target landmarks are mapped to the corresponding positions using the current backward transformation exactly. Taking the forward transformation for instance, the source landmark x
                        
                           i
                         is mapped to y
                        
                           i
                         using the initial forward transformation h
                        0(x). Since y
                        
                           i
                         is mapped to x
                        
                           i
                         using the initial backward transformation also, the forward inverse consistent error is zero, δ
                        1(x
                        
                           i
                        )=0. Then, the forward transformation is not updated at point x
                        
                           i
                        . That is, the correspondence of landmarks is maintained throughout the procedure of FCL algorithm. A similar situation applies to the backward transformation also.

This section we apply the FCL algorithm to the robust point matching (RPM) algorithm to demonstrate the performance of our approach applied to image registration. Robust point matching-based image registration is a kind of feature-based image registration method, aiming to search for an optimal transformation function as well as the correspondence between two point sets. Given the source point set U
                     ={u
                     
                        i
                     , i
                     =1, 2, …, K} and the target point set 
                        V
                        =
                        {
                        
                           v
                           j
                        
                        ,
                        j
                        =
                        1
                        ,
                        2
                        ,
                        …
                        ,
                        W
                        }
                      in a region Ω, the goal of RPM is to find the optimal transformation h
                     :Ω→Ω that maps the source point-set U to the target point-set V, as well as estimating the corresponding relationship between U and V. Chui et al. [34] employed thin plate splines as the transformation function used in RPM, and proposed TPS-RPM algorithm to match two point sets. A fuzzy correspondence matrix M with dimension (K
                     +1)×(W
                     +1) is defined to describe the correspondence between points. TPS-RPM employed soft assign and deterministic annealing technique to estimate the fuzzy correspondence matrix M and the transformation h simultaneously, which minimize the following cost function
                        
                           (11)
                           
                              E
                              (
                              M
                              ,
                              h
                              )
                              =
                              
                                 ∑
                                 
                                    j
                                    =
                                    1
                                 
                                 W
                              
                              
                                 
                                    ∑
                                    
                                       i
                                       =
                                       1
                                    
                                    K
                                 
                                 
                                    
                                       
                                          m
                                          ij
                                       
                                    
                                    |
                                    |
                                    
                                       
                                          v
                                          j
                                       
                                    
                                    −
                                    h
                                    (
                                    
                                       
                                          u
                                          i
                                       
                                    
                                    )
                                 
                              
                              |
                              
                                 
                                    |
                                    2
                                 
                              
                              +
                              λ
                              |
                              |
                              Lh
                              |
                              
                                 
                                    |
                                    2
                                 
                              
                              +
                              T
                              
                                 ∑
                                 
                                    j
                                    =
                                    1
                                 
                                 W
                              
                              
                                 
                                    ∑
                                    
                                       i
                                       =
                                       1
                                    
                                    K
                                 
                                 
                                    
                                       
                                          m
                                          ij
                                       
                                    
                                    log
                                 
                              
                              
                                 
                                    m
                                    ij
                                 
                              
                              −
                              ζ
                              
                                 ∑
                                 
                                    j
                                    =
                                    1
                                 
                                 W
                              
                              
                                 
                                    ∑
                                    
                                       i
                                       =
                                       1
                                    
                                    K
                                 
                                 
                                    
                                       
                                          m
                                          ij
                                       
                                    
                                 
                              
                              ,
                           
                        
                     where λ and ζ are the weighting parameters to balance these terms. T is the anneal temperature during the robust point matching. Chui et al. approximated the cost function (11) as
                        
                           (12)
                           
                              E
                              (
                              M
                              ,
                              h
                              )
                              =
                              
                                 ∑
                                 
                                    i
                                    =
                                    1
                                 
                                 K
                              
                              
                                 |
                                 |
                                 
                                    
                                       z
                                       i
                                    
                                 
                                 −
                                 h
                                 (
                                 
                                    
                                       u
                                       i
                                    
                                 
                                 )
                              
                              |
                              
                                 
                                    |
                                    2
                                 
                              
                              +
                              λ
                              |
                              |
                              Lh
                              |
                              
                                 
                                    |
                                    2
                                 
                              
                              +
                              T
                              
                                 ∑
                                 
                                    j
                                    =
                                    1
                                 
                                 W
                              
                              
                                 
                                    ∑
                                    
                                       i
                                       =
                                       1
                                    
                                    K
                                 
                                 
                                    
                                       
                                          m
                                          ij
                                       
                                    
                                    log
                                 
                              
                              
                                 
                                    m
                                    ij
                                 
                              
                              −
                              ζ
                              
                                 ∑
                                 
                                    j
                                    =
                                    1
                                 
                                 W
                              
                              
                                 
                                    ∑
                                    
                                       i
                                       =
                                       1
                                    
                                    K
                                 
                                 
                                    
                                       
                                          m
                                          ij
                                       
                                    
                                 
                              
                              ,
                           
                        
                     where 
                        
                           
                              z
                              i
                           
                        
                        =
                        
                           ∑
                           
                              j
                              =
                              1
                           
                           W
                        
                        
                           
                              
                                 m
                                 ij
                              
                           
                           
                              
                                 v
                                 j
                              
                           
                        
                      is the weighted target point, which can be treated as the virtual target point. Given the correspondence matrix M, the transformation function between two point sets is estimated by minimizing the following energy function [34]
                     
                        
                           (13)
                           
                              E
                              (
                              h
                              )
                              =
                              
                                 ∑
                                 
                                    i
                                    =
                                    1
                                 
                                 K
                              
                              
                                 |
                                 |
                                 
                                    
                                       z
                                       i
                                    
                                 
                                 −
                                 h
                                 (
                                 
                                    
                                       u
                                       i
                                    
                                 
                                 )
                              
                              |
                              
                                 
                                    |
                                    2
                                 
                              
                              +
                              λ
                              |
                              |
                              Lh
                              |
                              
                                 
                                    |
                                    2
                                 
                              
                              .
                           
                        
                     TPS is adopted to construct the forward transformation h between U and V by considering the u
                     
                        i
                      and the corresponding z
                     
                        i
                      as the source and target control point sets, respectively. Correspondingly, the backward transformation g is estimated by considering the z
                     
                        i
                      and the corresponding u
                     
                        i
                      as the source and target control point sets, respectively. As we know, TPS is an uni-directional transformation which cannot ensure the inverse consistency of the forward and backward transformations. We introduce the FCL algorithm to the TPS-RPM to estimate the forward and backward transformations simultaneously. Then, the cost function (12) is updated as
                        
                           (14)
                           
                              E
                              (
                              M
                              ,
                              h
                              )
                              =
                              
                                 ∑
                                 
                                    i
                                    =
                                    1
                                 
                                 K
                              
                              (
                              
                                 |
                                 |
                                 
                                    
                                       z
                                       i
                                    
                                 
                                 −
                                 h
                                 (
                                 
                                    
                                       u
                                       i
                                    
                                 
                                 )
                              
                              |
                              
                                 
                                    |
                                    2
                                 
                              
                              +
                              
                                 |
                                 |
                                 
                                    
                                       u
                                       i
                                    
                                 
                                 −
                                 g
                                 (
                                 
                                    
                                       z
                                       i
                                    
                                 
                                 )
                              
                              |
                              
                                 
                                    |
                                    2
                                 
                              
                              )
                              +
                              λ
                              (
                              |
                              |
                              Lh
                              |
                              
                                 
                                    |
                                    2
                                 
                              
                              +
                              |
                              |
                              Lg
                              |
                              
                                 
                                    |
                                    2
                                 
                              
                              )
                              +
                              χ
                              (
                              ∥
                              
                                 id
                                 g
                              
                              −
                              h
                              ∘
                              g
                              
                                 ∥
                                 2
                              
                              +
                              ∥
                              
                                 id
                                 h
                              
                              −
                              g
                              ∘
                              h
                              
                                 ∥
                                 2
                              
                              )
                              +
                              T
                              
                                 ∑
                                 
                                    j
                                    =
                                    1
                                 
                                 W
                              
                              
                                 
                                    ∑
                                    
                                       i
                                       =
                                       1
                                    
                                    K
                                 
                                 
                                    
                                       
                                          m
                                          ij
                                       
                                    
                                    log
                                 
                              
                              
                                 
                                    m
                                    ij
                                 
                              
                              −
                              ζ
                              
                                 ∑
                                 
                                    j
                                    =
                                    1
                                 
                                 W
                              
                              
                                 
                                    ∑
                                    
                                       i
                                       =
                                       1
                                    
                                    K
                                 
                                 
                                    
                                       
                                          m
                                          ij
                                       
                                    
                                 
                              
                              ,
                           
                        
                     where h and g are the forward and backward transformations estimated by considering the u
                     
                        i
                      and the corresponding z
                     
                        i
                      as the source and target control point sets, respectively. Correspondingly, given the correspondence matrix M, the energy function used to estimate the forward and backward transformations in RPM is
                        
                           (15)
                           
                              E
                              (
                              h
                              ,
                              g
                              )
                              =
                              
                                 ∑
                                 
                                    i
                                    =
                                    1
                                 
                                 K
                              
                              (
                              
                                 |
                                 |
                                 
                                    
                                       z
                                       i
                                    
                                 
                                 −
                                 h
                                 (
                                 
                                    
                                       u
                                       i
                                    
                                 
                                 )
                              
                              |
                              
                                 
                                    |
                                    2
                                 
                              
                              +
                              
                                 |
                                 |
                                 
                                    
                                       u
                                       i
                                    
                                 
                                 −
                                 g
                                 (
                                 
                                    
                                       z
                                       i
                                    
                                 
                                 )
                              
                              |
                              
                                 
                                    |
                                    2
                                 
                              
                              )
                              +
                              λ
                              (
                              |
                              |
                              Lh
                              |
                              
                                 
                                    |
                                    2
                                 
                              
                              +
                              |
                              |
                              Lg
                              |
                              
                                 
                                    |
                                    2
                                 
                              
                              )
                              +
                              χ
                              (
                              ∥
                              
                                 id
                                 g
                              
                              −
                              h
                              ∘
                              g
                              
                                 ∥
                                 2
                              
                              +
                              ∥
                              
                                 id
                                 h
                              
                              −
                              g
                              ∘
                              h
                              
                                 ∥
                                 2
                              
                              )
                              .
                           
                        
                     Optimization of h and g can be solved by the FCL algorithm. Similar to TPS-RPM, regularized TPS is adopted to be the RBFs-based transformation used in FCL algorithm.

@&#EXPERIMENTS@&#

This section presents the experimental results of our algorithm. To demonstrate the performance of the different algorithms, uniform grids, test images, brain slices and lung slices are employed.

We use the coordinates of randomly spaced control points to estimate the forward and backward transformations simultaneously. 10 and 20 random landmark pairs are generated separately to deform a 100×100 uniform grid. In order to demonstrate the behaviors of different transformation models, non-rigid and rigid transformations derived by randomly generated landmarks are created. For non-rigid transformation, the randomly generated source landmarks are shifted to generate target landmarks. The displacements between source landmarks and target landmarks are also random, and are limited to 4, 8, 12 and 16, respectively. It is important to note that the deformation fields derived by the random control points should be topology-preserving. For rigid transformation, we generate source landmarks randomly and obtained target points using rigid transformations, the rigid parameters used in this experiment are selected randomly also.

We employ TPS, CL-TPS algorithm, and FCL algorithm to estimate transformations based on the given corresponding landmarks. Furthermore, we implement the gradient descent (GD) to solve inverse consistent cost function (4), in order to compare the performance of our algorithm and class gradient descent method. To save computation time, fixed step is used in gradient descent method. In experiments with non-rigid transformation, the TPS algorithm with periodic boundary conditions(TPS) [12] is employed to perform the RBFs-based transformation in the Step 2 of FCL algorithm. That is, landmarks are replicated in the four adjacent domains to control the deformation at the boundaries of image. In the experiments with rigid transformation, the TPS algorithm without periodic boundary conditions(TPS) is employed due to rigid deformation.

Our experiments are repeated 20 times, and the parameters used in CL-TPS is as follow: α
                        =0.5 and β
                        =0.5. α in FCL is 0.5, and in GD is 0.1(we found the large α in GD will result in non-topology-preserving transformations). The deformation results are evaluated using the following parameters:

(1) The average image errors (AIE) of the forward and backward transformation, which are evaluated by summing the forward consistency error and the backward consistency error as follows.
                           
                              (16)
                              
                                 AIE
                                 =
                                 
                                    1
                                    
                                       |
                                       Ω
                                       |
                                    
                                 
                                 
                                    ∫
                                    Ω
                                 
                                 ∥
                                 h
                                 −
                                 
                                    g
                                    
                                       −
                                       1
                                    
                                 
                                 ∥
                                 +
                                 ∥
                                 
                                    h
                                    
                                       −
                                       1
                                    
                                 
                                 −
                                 g
                                 ∥
                                 ,
                              
                           
                        where |Ω| is the number of point in the deformation field.

(2) The average landmark errors (ALE) between the target points and mapped source points using the forward transformation, and between the source points and mapped target points using the backward transformation.
                           
                              (17)
                              
                                 ALE
                                 =
                                 
                                    1
                                    N
                                 
                                 max
                                 {
                                 
                                    ∑
                                    i
                                 
                                 (
                                 ∥
                                 
                                    y
                                    i
                                 
                                 −
                                 h
                                 (
                                 
                                    x
                                    i
                                 
                                 )
                                 ∥
                                 )
                                 ,
                                 
                                    ∑
                                    i
                                 
                                 (
                                 ∥
                                 
                                    x
                                    i
                                 
                                 −
                                 g
                                 (
                                 
                                    y
                                    i
                                 
                                 )
                                 ∥
                                 )
                                 }
                                 .
                              
                           
                        
                     

(3) Bending energy of the forward and backward deformation fields.

(4) The average computation time, which is the average time used to compute the forward and backward transformations.


                        Figs. 4 and 5
                        
                         show the evaluation results for 10 (sparely spaced) and 20 (densely spaced) random landmarks, respectively. Figs. 4(a) and 5(a) show box plots of ALE versus 8 and 12 landmark displacement magnitude for four algorithms. The number followed each algorithm name is the maximum displacement magnitude of landmarks, for example, “TPS-8” means the TPS algorithm and the maximum displacement magnitude of landmarks used in this experiment is 8. It can be seen that whether the sparely spaced landmarks or the densely spaced landmarks used, the average landmark errors of the forward and backward transformations using TPS, FCL, GD are smaller than that using CL-TPS, since the correspondence of landmarks are preserved exactly for TPS, GD and FCL. Figs. 4(b) and 5(b) show AIE of registration results, where the outlier is any value that lies more than one and a half times the length of the box from either end of the box. It is noted that TPS has significant average image error while the error is minimized by using CL-TPS, GD and FCL, which means CL-TPS, GD and FCL can reduce inverse consistency errors for the forward and backward transformations significantly. In order to compare the inverse consistency errors of CL-TPS, GD and FCL in detail, the average image errors of CL-TPS, GD and FCL are shown in Figs. 4(c) and 5(c) again. It shows that our algorithm reduces the inverse consistency error by about 10 times, compared with CL-TPS and GD algorithms in our experiments. Moreover, it is noted that when the displacements of landmarks are large, the inverse consistency errors are large accordingly for CL-TPS and GD algorithm, while the errors change little for our algorithm. Figs. 4(d) and 5(d) show the rigid registration results of uniform grids using 10 and 20 random landmarks, respectively. Similar to the results of non-rigid transformations, FCL outperforms TPS, CL-TPS and GD in aspect of average image errors significantly.

Moreover, the bending energy of the forward and backward transformations using FCL and GD are comparable to that using TPS, as shown in Fig. 4(e)–(f) and Fig. 5(e)–(f). Since TPS minimizes the bending energy function, while the bending energy of the forward and backward transformations using our algorithm and GD are similar to each other and are close to that of TPS, which implies that the transformations estimated by our algorithm is close to the optimal results in spatial smoothness, accompanied by less inverse consistency errors. On the other hand, the bending energy of the forward and backward transformations using our algorithm and GD are smaller than that using CL-TPS, which shows that the our algorithm outperforms the CL-TPS algorithm in spatial smoothness.


                        Fig. 6
                         shows the computation time of four algorithms for the experiments. Obviously, the computation time of FCL algorithm is near to that of TPS, which is less than that of GD and CL-TPS significantly. The reason why the computation time of GD is more than that of FCL is that the Jacobian matrix is computed during the iteration procedure. The computation time of FCL algorithm consists of two parts, one is calculating RBFs-based transformations according to Eq. (1), the other one is updating the forward and backward transformations. Calculating RBFs-based transformations takes a lot of time. The more landmarks are used, the more time it will take. By contrast, the computation time of update of the forward and backward transformations is fixed when iteration number is given. In other word, the computation time of FCL algorithm is comparable to that of TPS when a lot of landmarks are used.

Registration results for test images using TPS, CL-TPS, GD and our algorithm are presented in this subsection. The compact supported thin plate spline (CSTPS) [35] is adopted to perform the step 2 of FCL and GD algorithm, to evaluate performance of our algorithm when compact support radial basis functions are employed to perform the RBFs-transformations. CSTPS is a good choice because of its better performance in topology preservation.


                        Fig. 7
                         shows the test images and manually chosen corresponding landmarks, where three source images are included as subject04, subject05 and subject06. These slices are extracted from 3D images of different subjects (the number is the subject index), and the brain skulls are removed manually. The original images are the target images, and are deformed manually to be the source images. Registration of subject04 and subject05 demonstrate the performance of our algorithm for global and local deformation, and subject06 demonstrates that for small deformation. In our experiments, whether the deformation from the source image to the target image, or the deformation from the target image to the source image, they are topology-preserving. So, a
                        11
                        ≫
                        a
                        21 and a
                        22
                        ≫
                        a
                        12 are satisfied. In this experiment, landmarks are replicated in the four adjacent domains to control the deformation at the boundaries of image. After warping using TPS, CL-TPS, GD and FCL, the difference between the deformed source image and the target image, and the difference between the deformed target image and the source image are computed.


                        Table 1
                         lists the Mean Square Difference (MSD) between the deformed source image and the target image, and that between the deformed target image and the source image. It is required to emphasize that the registration accuracy is depended on the transformations and the correspondence of landmarks as well. Experiments here are used to demonstrate the performance of transformations, instead of the correspondence accuracy of landmarks. From the results shown in Table 1, it can be seen that the bidirectional registration results using our algorithm and GD are better than that using TPS. Especially, for the global deformation in subject04, it is observed that the our algorithm, GD and CL-TPS outperform TPS in aspect of backward registration due to the inverse consistency constraint involved. Although the registration result using FCL is not better than that using CLTPS for subject04, the backward transformation estimated by CL-TPS cannot preserved topology well, as shown in Fig. 8
                        , while the forward and backward transformations estimated by our algorithm are bijective and topology-preserving. For registration of subject05 and subject06, our algorithm and GD outperformed TPS and CL-TPS in forward and backward registration. Noted that the displacement of landmarks are relatively small in this experiment, registration results using FCL and GD are comparable due to the same cost function used.

To further compare the estimated forward and backward transformations, we compute the mean and standard deviation of the value of the Jacobian determinant at all points of the forward and backward transformations. The absolute value of the Jacobian determinant at a point gives us the factor by which the transformation expands or shrinks volumes near the point. When the Jacobian determinant at a point is closer to 1, the local volume difference between the source and target image is less. As listed in Table 2
                        , the mean of Jacobian determinant for the forward and backward transformation using our algorithm and GD are more closer to 1 than that using TPS and CL-TPS in most cases. So it indicates that the deformation results using GD and our algorithm preserve the volume better than using TPS and CL-TPS algorithms.

If the forward and backward transformations are inverse consistent, the composite function h(g(x)) and g(h(x)) should map a point x to itself. These composite functions are visualized by deforming a uniformly space grid in Fig. 8 also. The less the uniformly spaced grid deformed, the better the pair of the inverse consistent transformations are. It can be seen from Fig. 8 that there are a considerable amount of inverse consistency errors in the TPS algorithm, while there are no obvious inverse consistent errors produced by CL-TPS, GD and our algorithm.

To validate our algorithm we also use MR brain data sets provided by the BrainWeb [36]. 10 brain slices, named subject01-subject10, extracted from 10 subjects brain data are registered to each other. All these slices are re-sampled as 128×128 in size. Among these 10 slices, the subject01 is selected as the target image, and other nine slices are registered to the target image. To compare the performance of different algorithms, RPM with TPS (TPS-RPM), symmetric TPS-RPM (S-TPS-RPM) [27], RPM with CL-TPS (CL-TPS-RPM) and RPM with FCL (FCL-RPM) are employed to register brain slices. Here, TPS-RPM only estimates the forward transformation, while FCL-RPM, CL-TPS-RPM and S-TPS-RPM estimate the forward and backward transformations at the same time. TPS-RPM, FCL-RPM and CL-TPS-RPM algorithms are the same in the whole procedure of RPM, but different in the estimation of transformations. S-TPS-RPM imposes a symmetry correspondence matrix based on both the forward and the backward transformations and does not compute the inverse of the forward and the backward transformations. Because the anatomical structures of brain slices between subjects are different significantly, non-rigid transformations are required to match the source image to the target image. The parameters used in four algorithms to register brain slices are: λ
                        1
                        =0.2, λ
                        2
                        =0.1.

Four basic tissue types are coded in the brain slices: background, CSF, Gray Matter and White Matter. Relative overlap is employed to (RO) evaluate how well two tissues of the same type match to each other [37]. For the source image I and target image J, relative overlap is defined as
                           
                              (18)
                              
                                 
                                    RO
                                    i
                                 
                                 (
                                 
                                    I
                                    i
                                 
                                 ,
                                 
                                    J
                                    i
                                 
                                 )
                                 =
                                 
                                    
                                       |
                                       
                                          I
                                          i
                                       
                                       ∩
                                       
                                          J
                                          i
                                       
                                       |
                                    
                                    
                                       |
                                       
                                          I
                                          i
                                       
                                       ∪
                                       
                                          J
                                          i
                                       
                                       |
                                    
                                 
                                 ;
                              
                           
                        where |I
                        
                           i
                        
                        ∩
                        J
                        
                           i
                        | is the number of pixels that intersect between the ith tissue of images I and J.


                        Fig. 9
                        (a)–(c) shows the relative overlap of CSF, Gray Matter and White Matter for the registration results of brain slices using four algorithms. Noted that FCL-RPM outperforms CL-TPS-RPM, TPS-RPM and S-TPS-RPM in respect of relative overlay in most cases. It demonstrates that our algorithm is capable of obtaining smaller registration error than the traditional RPM (TPS-RPM), the bidirectional RPM(S-TPS-RPM) and traditional inverse consistent algorithm (CL-TPS-RPM). The traditional RPM algorithm uses a unidirectional transformation that only tended to map the source points to the target points, instead of constraining the whole deformation field to be inversely consistent. In contrast, the bidirectional RPM (S-TPS-RPM) not only maps the source points to the target points, but also maps the target points to the fixed feature points at the same time. However, there are no inverse consistent constraints embedded in S-TPS-RPM and control points distributed non-uniformly, which results in large inverse consistent errors (shown in Fig. 9(d)) in our experiments. Obviously, our algorithm converges to smaller values of inverse consistent errors, which are too small to be observed in Fig. 9(d). Although the traditional inverse consistent algorithm (CL-TPS-RPM) introduces inverse consistent constraints to the cost function, the computation of inverse functions leads computation errors into the transformations and makes it sensitive to the mapping errors of control points. Fig. 10
                        (a) illustrates the histograms of the Jacobian determinants of the forward and the backward transformations of brain slices registration using four algorithms. The Jacobian determinants of all registration results of nine brain slice pairs are count together. We observe that there are large values of Jacobian determinants using CL-TPS-RPM, which means the forward and the backward transformation estimated by CL-TPS-RPM changes greatly. Especially, for subject03, subject05 and subject06, the transformations do not preserve topology and the inverse consistent errors cannot be computed and are not shown in Fig. 9(d). An example is demonstrated in Fig. 10(b), where an uniform grid is deformed using the forward and the backward transformations estimated by four algorithms for the registration of subject03. It can be seen that in this experiment, our algorithm preserves topology of transformations as well as TPS-RPM and S-TPS-RPM, and CL-TPS-RPM leads to non-topology-preserving transformations.

We evaluate the registration accuracy of our algorithm on lung images, which are provided by DIR-lab (www.DIR-lab.com). All 10 cases of lung images are provided, and each case has a 4D lung image at with six phases, labelled as T00 to T50. T00 phase is the maximum inhale phase; T50 phase is the maximum exhale phase. We extract a slices from the image at T00 as the source image, and a slice from the image at T50 phases as the target image for a case. Hence, all 10 pairs of images are registered by using TPS-RPM, S-TPS-RPM, CL-TPS-RPM and FCL-RPM algorithms, respectively. Because the anatomical structures of lung slices at T00 are similar to that at T50, the transformations that map the source image to the target image are similar to affine transformations to some extent. The parameters used in four algorithms to register lung slices are: λ
                        1
                        =2, λ
                        2
                        =0.1.


                        Fig. 11
                         illustrates the MSD of the registered images and the reference images, and the inverse consistent errors of the forward and backward transformations for ten cases. Obviously, the registration accuracy of our algorithm is better than that of TPS-RPM, S-TPS-RPM and CL-TPS-RPM (Fig. 11(a)). Moreover, the inverse consistent errors of the forward and backward transformations estimated by our algorithm are smaller than that by other algorithms significantly (Fig. 11(b)). Especially, the FCL-RPM performs better than CL-TPS-RPM in respect of inverse consistent error greatly, which almost cannot be observed in Fig. 11(b). Noted that the transformations estimated by CL-TPS-RPM are non-topology-preserving for case 4, the inverse consistent error of them cannot be computed and is not shown in Fig. 11(b).

To further compare the registration results using different algorithms, the slices extracted from case 1 are used to demonstrate the performance of four algorithms. The source and target images are shown in Fig. 12
                        . Because of the respiratory motion, the bronchi in the source image are different from that in the target image obviously and there are many points in the source image that have not corresponding points in the target image. Then the transformations estimated by RPM might be mis-led by these outliers. The backward difference between the deformed target image and the source image, and the forward difference between the deformed source image and the target image using four algorithms are shown in Fig. 12, respectively. Noted in both directions, the registered results by FCL-RPM match the template images better than other algorithms. Especially, the improvement of the registration accuracy at the inner regions of the lung images can be observed also. It demonstrates that our algorithm outperforms TPS-RPM, S-TPS-RPM and CL-TPS-RPM when robust point matching is used in image registration to estimate the forward and backward transformations at the same time.


                        Tables 3 and 4
                        
                         list the mean and standard deviations of Jacobian determinants for the forward and backward transformations, respectively. As we know, TPS-RPM provides more freedom for the affine transformation to avoid unphysical reflection mappings [34], which leads to transformations that are similar to affine ones. From Table 3 it is observed that, whether the standard deviations of Jacobian determinants of the forward transformation or of the backward transformation by FCL-RPM are similar to that by TPS-RPM, and less than that by CL-TPS-RPM and S-TPS-RPM. It implies that the deformation results using our algorithm are smoother than that using CL-TPS-RPM and S-TPS-RPM. At the same time, our algorithm maintains the elastic deformation between two point sets and enforces the smoothness of the forward and backward transformations. It exactly demonstrates the advantage of introducing the inverse consistent transformations to non-rigid image registration by our algorithm. Fig. 13
                         shows the forward and backward grid transformations by four algorithms, respectively. It can be seen that the transformations estimated by FCL-RPM and TPS-RPM are smoother than by CL-TPS-RPM and S-TPS-RPM.

@&#CONCLUSIONS@&#

This paper proposed a fast and efficient algorithm to estimate the forward and backward transformations at the same time based on the correspondence of landmarks. The forward and backward transformations are required to be inverse to each other, but no computation of the inverse transformation fields is needed in our algorithm. The convergence of our algorithm is proved in theory. Theoretical analysis results also show that the corresponding relationships between source landmarks and target landmarks are preserved exactly using the forward and backward transformations estimated by our algorithm. By introducing our algorithm to the robust point matching, the forward and backward transformations can be estimated without given corresponding control points. Our algorithm is extensively evaluated based on brain and lung dataset in both inter and intro-subject registration settings. Experiment results indicate that the inverse consistency error of the forward and backward transformations using our algorithm is smaller than CL-TPS algorithm, and the computation time of our algorithm is reduced significantly. Moreover, by combing our algorithm and robust point matching, image registration accuracy can be improved and more smooth transformations can be obtained.

The authors declared that they have no conflicts of interest to this work.

@&#ACKNOWLEDGEMENTS@&#

This paper is supported by National Natural Science Foundation of China (U1301251) and Shenzhen Science and Technology Projection (JCYJ20130326112132687).

@&#REFERENCES@&#

