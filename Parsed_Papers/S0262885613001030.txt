@&#MAIN-TITLE@&#Recognizing hand gestures using the weighted elastic graph matching (WEGM) method

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           The HEGM method for classifying hand postures with a hit rate of 97.08% on average over uniform and complex backgrounds.


                        
                        
                           
                           This method allows computing only features corresponding to highly discriminative nodes, thus decreasing computing time.


                        
                        
                           
                           A semi-automatic technique to annotate bunch graphs is described which is efficient and leads to faster graph creation.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Elastic bunch graph

Graph matching

Feature weight

Hand gesture recognition

@&#ABSTRACT@&#


               Graphical abstract
               
                  
                     
                        
                           
                        
                     
                  
               
            

@&#INTRODUCTION@&#

One of the main goals in the human–computer interaction (HCI) field is the study of innovative ways to enhance the user experience through natural communication and develop the technology that enables such interaction. In this context, new trends include the development of a new generation of smaller, cheaper and versatile sensors [1,2]. Users' subjective satisfaction favors those systems that provide an enhanced interaction experience based on the naturalness and expressiveness that they offer [3]. Among those modalities relying on natural interaction, gestures are found explicitly, as one of the main channels to interact with computers in many fronts; such as sign language interpretation [2], assistive technologies [4], and game control applications [5] to mention a few. Gestures are being adopted also in areas where touch can be a vehicle of infection transmissions (e.g. browsing medical images in the operating room) [6] or in outpatient clinics [7]. Common approaches for vision based-hand posture recognition involve [8] (1) 3D model based methods [9], (2) appearance based model [10], and (3) shape analysis [11]. See [12] for a detailed review on gesture based interfaces.

Elastic graph matching (EGM) is a technique used for object recognition [13], where the object is represented by a labeled bunch graph. The bunch graph consists of a connected graph where the most salient features on the image are represented as series of nodes. A bunch graph is built on a set of template images (also called ‘dictionary’). To compare the similarity between one template image within the bunch and a target image, the graph obtained from the template image is matched against the target image. Filter responses are computed at each node in the graph, and a cost function is minimized based on a metric applied to the nodes assignment. Over the years, EGM was implemented for tasks such as face recognition [13,14], face verification [15] and gesture recognition [16]. In Wiskott et al. [13], EGM was used to recognize the facial expressions in images where features were extracted from typical face parts (e.g. the pupils, the beard, the nose, and the corners of the mouth). Triesch et al. employed EGM to develop a classification approach for hand gestures against complex backgrounds [16]. EGM was also shown to have better performance over eigenfaces [17] and auto-association and classification neural networks [18]. EGM outperformed the aforementioned two methods due to its robustness to lighting variation, face position and expression changes. Another variant of EGM is morphological elastic graph matching (MEGM) [19], which was applied for frontal face authentication based on multi-scale dilation–erosion operations. One of the main drawbacks of this method is the computational complexity involved in the detection and classification processes.

@&#MOTIVATION@&#

One significant contribution of this paper is a procedure to determine the graph nodes' weights thus validating the importance of weighting the features for classification purposes. We propose the weighted elastic graph matching (WEGM) method for hand posture recognition. In our method, those features with higher likelihood to appear in the target image have higher weight compared to those features which are less consistent with the graph model. Using weight allows us to allocate more computational resources to those features that are more discriminative while ignoring those features with lower importance [20]. Three metrics are used in our experiments to show that features with more discriminative power dominate the recognition performance of the system. A secondary contribution is a comparative study on efficient annotation techniques to create the bunch graphs.

The rest of the paper is organized as follows: in Section 2 the elastic bunch graph matching (EBGM) and adaptive boosting algorithm are described. In Section 3 the proposed annotation methods and the weighted hand gesture recognition algorithm (WEGM) are presented. Experimental results in Section 4 demonstrate the feasibility and efficiency of the proposed techniques. Finally the discussion and conclusions are presented in Section 5.

The section below describes briefly the principles of elastic bunch graph. For more details see [16]. Bunch graphs were used to represent and recognize hand postures [16,21] in grayscale images. Each bunch graph is a collection of individual graphs representing a posture. Salient points on the underlying image are labeled as nodes of a graph over the object. The links connecting the nodes express some topological metric, such as the Euclidian distance. A Gabor jet is defined as the set of responses on specific locations in the images obtained when convolving a set of images (the dictionary set) with a bank of Gabor filters. The jet is a vector of complex responses at a given pixel 
                           
                              x
                              ⃗
                           
                         which follows the form:
                           
                              (1)
                              
                                 
                                    
                                       ψ
                                       k
                                    
                                    
                                       x
                                    
                                    =
                                    
                                       
                                          
                                             k
                                             ⃗
                                          
                                          2
                                       
                                       
                                          σ
                                          2
                                       
                                    
                                    exp
                                    
                                       
                                          −
                                          
                                             
                                                
                                                   
                                                      k
                                                      ⃗
                                                   
                                                   2
                                                
                                                
                                                   
                                                      x
                                                      ⃗
                                                   
                                                   2
                                                
                                             
                                             
                                                2
                                                
                                                   σ
                                                   2
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          exp
                                          
                                             
                                                i
                                                
                                                   k
                                                   ⃗
                                                
                                                
                                                   x
                                                   ⃗
                                                
                                             
                                          
                                          −
                                          exp
                                          
                                             
                                                −
                                                
                                                   
                                                      σ
                                                      2
                                                   
                                                   2
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where ψ
                        
                           k
                        (x) is the Gabor-based kernel with the wave vector 
                           
                              k
                              ⃗
                           
                         which describes the variation of spatial frequencies and orientations, represented by the index ν
                        ∈[0, …, L
                        −1] and μ
                        ∈[0, …, D
                        −1]. Different values of 
                           
                              k
                              ⃗
                           
                         are found using:
                           
                              (2)
                              
                                 
                                    
                                       k
                                       νμ
                                    
                                    =
                                    
                                       k
                                       ν
                                    
                                    
                                       
                                          
                                             
                                                cos
                                                
                                                   ϕ
                                                   μ
                                                
                                                
                                             
                                          
                                          
                                             
                                                sin
                                                
                                                   ϕ
                                                   μ
                                                
                                             
                                          
                                       
                                    
                                    with
                                    
                                    
                                       k
                                       ν
                                    
                                    =
                                    
                                       
                                          k
                                          max
                                       
                                       
                                          f
                                          ν
                                       
                                    
                                    ,
                                    
                                       ϕ
                                       μ
                                    
                                    =
                                    
                                       μπ
                                       D
                                    
                                    
                                 
                              
                           
                        where L is the number of frequency levels and D is the number of orientations. The following parameters were chosen based on empirical studies [16]: f
                        =
                        
                           
                              1
                              /
                              
                                 2
                              
                           
                        , and k
                        max
                        =1.7. The width of the Gaussian envelope function is σ/k with σ=2.5. The jet is a complex vector consisting of L
                        ×
                        D filter responses and it is defined as J
                        
                           j
                        
                        =
                        a
                        
                           j
                        
                        exp(iϕ
                        
                           j
                        ). Jj
                         is used to compute the similarity of a target image and a bunch graph (obtained from dictionary images), whose node positions are annotated a priori. In this paper, the objects of interest are hand postures. Thus, the classification of a given image as a gesture is obtained by measuring the likelihood of two jets (one from the target image and one from the bunch graph). The similarity function using the magnitude aj
                         and phase ϕ
                        
                           j
                         of the two jets to find a matching score between the target image and the bunch graph is stated as follows:
                           
                              (3)
                              
                                 
                                    
                                       S
                                       pha
                                    
                                    
                                       
                                          
                                          J
                                          ,
                                          
                                             J
                                             '
                                          
                                       
                                    
                                    =
                                    
                                       1
                                       2
                                    
                                    
                                       
                                          1
                                          +
                                          
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   j
                                                
                                                
                                                   a
                                                   j
                                                
                                                
                                                   a
                                                   j
                                                   '
                                                
                                                cos
                                                
                                                   
                                                      
                                                         ϕ
                                                         j
                                                      
                                                      −
                                                      
                                                         ϕ
                                                         j
                                                         '
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         ∑
                                                      
                                                      j
                                                   
                                                   
                                                      a
                                                      j
                                                      2
                                                   
                                                   
                                                      
                                                         ∑
                                                      
                                                      j
                                                   
                                                   
                                                      a
                                                      j
                                                      '
                                                   
                                                   
                                                      
                                                      2
                                                   
                                                
                                             
                                          
                                       
                                    
                                    
                                 
                              
                           
                        where a
                        
                           j
                        
                        ' and ϕ
                        
                           j
                        
                        ' is obtained from J
                        
                           j
                        
                        '
                        =
                        a
                        
                           j
                        
                        '
                        exp(iϕ
                        
                           j
                        
                        '), the jet is derived from the target image. The phase information varies rapidly between continuous pixels, thus providing an advantageous mean to have a good initial estimate about the position of the hand within the target image.

The classification task is done by finding the position of the template which maximizes the similarity between the bunch graph and the target image. The detailed elastic bunch graph matching (EBGM) procedure consists of three steps [16]:
                           
                              •
                              Approximately position the graph: The bunch graph is applied on the image and scanned in steps of 3pixels in both the x and y directions. All the nodes in each bunch graph are visited and compared, the similarity score of the matching is given by a linear combination of the scores between the nodes in the bunch graph and the target image.

Rescale the graph: The bunch graph can be resized by up to +20% and −20% (five scales are used) without relative changes of the edge lengths.

Refining position of each node: All nodes are allowed to vary +3 and −3pixels from the position found in step 1. A penalty cost is introduced to prevent great distortion of the graph:
                                    
                                       (4)
                                       
                                          
                                             C
                                             =
                                             
                                                1
                                                M
                                             
                                             
                                                
                                                   ∑
                                                   i
                                                
                                                
                                                   d
                                                   
                                                      
                                                         E
                                                         i
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 where d(E
                                 
                                    i
                                 ) is the cost of the difference of edges before and after shifting the graph relative to the original lengths. Considering the distortions of the nodes, the total score of the matching becomes:
                                    
                                       (5)
                                       
                                          
                                             
                                                S
                                                total
                                             
                                             =
                                             
                                                S
                                                pha
                                             
                                             −
                                             λC
                                          
                                       
                                    
                                 where λ determines the extent of penalizing the solutions that depart from the original positions. In this paper, the value of λ is chosen the same as the state-of-art approach [16] in order to perform the comparison analysis.

During the overall matching process, the best fitting jet is selected according to the maximum similarity score in Eq. (5) among the bunch graphs. The classification is determined by the maximum score over all the detectors (Max–Wins rule [22]).

In this paper we use boosting to assign weighted values to the nodes within the bunch graph to maximize the recognition accuracy. These weights are in practice coefficients that maximize the discriminative function between feature vectors that are retrieved from specific positions in the hand and negative observations.

Boosting [23–25] is a general machine learning technique used to design, train and test classifiers by combining a series of weak classifiers to create a strong classifier. This technique was adopted in our posture recognition algorithm to reflect the weight of nodes in the bunch graphs. In the boosting technique, a family of weak classifiers forms an additive model:
                           
                              (6)
                              
                                 
                                    F
                                    
                                       v
                                    
                                    =
                                    
                                       
                                          ∑
                                          m
                                          M
                                       
                                       
                                          f
                                          
                                             v
                                          
                                       
                                    
                                 
                              
                           
                        where f(v) denotes a weak detector, v is a feature vector, and M is the number of iterations (or number of weak detectors) to form a strong classifier, F(v). When training, a weight is associated with each of the training samples, which is updated in each iteration. The updates increase the weight of the samples which are misclassified at the current iteration and decrease the weights of those which were correctly classified. The weights 
                           
                              
                                 ω
                                 i
                              
                              =
                              
                                 e
                                 
                                    −
                                    
                                       z
                                       i
                                    
                                    F
                                    
                                       
                                          v
                                          i
                                       
                                    
                                 
                              
                           
                         for each training sample i with class label zi
                         are defined so the cost of misclassification is minimized by adding a new optimal weak classifier that meets:
                           
                              (7)
                              
                                 
                                    
                                       argmin
                                       
                                          f
                                          m
                                       
                                    
                                    
                                       
                                          ∑
                                          
                                             i
                                             =
                                             1
                                          
                                          N
                                       
                                       
                                          
                                             ω
                                             i
                                          
                                          
                                             
                                                
                                                   
                                                      z
                                                      i
                                                   
                                                   −
                                                   
                                                      f
                                                      m
                                                   
                                                   
                                                      
                                                         v
                                                         i
                                                      
                                                   
                                                
                                             
                                             2
                                          
                                       
                                    
                                    .
                                 
                              
                           
                        
                     

Upon choosing the weak classifier and adding to F(v
                        
                           i
                        ), the estimates are updated: F(v
                        
                           i
                        )=
                        F(v
                        
                           i
                        )+
                        f
                        
                           m
                        (v
                        
                           i
                        ). Accordingly, the weights over the samples are updated by:
                           
                              (8)
                              
                                 
                                    
                                       ω
                                       i
                                    
                                    =
                                    
                                       ω
                                       i
                                    
                                    
                                       e
                                       
                                          −
                                          
                                             z
                                             i
                                          
                                          
                                             f
                                             m
                                          
                                          
                                             
                                                v
                                                i
                                             
                                          
                                       
                                    
                                    .
                                 
                              
                           
                        
                     

In this paper, the gentleboost cost function [23] is used to minimize the error.

The bunch graph was created by selecting a set of nodes for each image which belongs to the dictionary set. Each node has to represent the same landmark in the hand in every image in the set. The process of selecting these nodes is called “annotation”. Two types of nodes were annotated: edge nodes (nodes lying on the contour of the hand) and inner nodes (nodes lying inside the contour). Three methods to accomplish the annotation task were compared in this paper: manual, semi-automatic and automatic. Among these three methods, the semi-automatic and automatic approaches were proposed to compare with the standard manual annotation approach. The manual method consists of selecting by hand every landmark in every image and ensuring that every landmark corresponds roughly to the same point in all the images in the dictionary set. In the automatic method, the landmarks are automatically selected by applying a Harris corner detector [26], which responds to highly textured regions within the hand. The semi-automatic approach is the same as the automatic approach except that it allows the user to correct manually those points that were detected automatically but had an offset with respect to visually identified landmarks. All the methods rely on the fact that the contour in every image was annotated manually for precise alignment.

The difference among these three methods is the manner on which the nodes are selected within the hand region. For the two methods (automatic and semi-automatic), one reference graph is chosen and the remaining five graphs are aligned with respect to it. A linear assignment problem (LAP) is applied to find the points in each graph in the bunch that better correspond to those points in the reference graph. The objective is to find the least displacement pairs of nodes from a larger set of candidates of the current graph. This is a minimization problem whose formulation is provided in Eqs. (9) and (10):
                           
                              (9)
                              
                                 
                                    
                                       min
                                       
                                          z
                                          i
                                       
                                    
                                    
                                       
                                          
                                             ∑
                                             
                                                i
                                                =
                                                1
                                             
                                             
                                                
                                                   N
                                                   1
                                                
                                                ×
                                                
                                                   N
                                                   2
                                                
                                             
                                          
                                          
                                             
                                                z
                                                i
                                             
                                             
                                                d
                                                i
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (10)
                              
                                 
                                    s
                                    .
                                    t
                                    .
                                    
                                       
                                          ∑
                                          
                                             j
                                             =
                                             1
                                          
                                          
                                             N
                                             2
                                          
                                       
                                       
                                          
                                             z
                                             j
                                          
                                          =
                                          
                                             N
                                             1
                                          
                                          ,
                                          
                                             z
                                             j
                                          
                                          =
                                          0
                                          
                                          or
                                          
                                          1
                                       
                                    
                                 
                              
                           
                        where d
                        
                           k
                        
                        =‖(x
                        
                           i
                        
                        1,y
                        
                           i
                        
                        1)−(x
                        
                           i
                        
                        2,y
                        
                           i
                        
                        2)‖ is the Euclidian distance between the nodes (i
                        =1…
                        N
                        1, j
                        =1…
                        N
                        2), (x
                        
                           i
                        
                        1,y
                        
                           i
                        
                        1) is the node of the reference graph, and (x
                        
                           i
                        
                        2,y
                        
                           i
                        
                        2) is the node of the graph to be matched. The detailed process is summarized in the following Algorithm table.
                           Algorithm
                           Node Annotation


                           
                              
                                 
                                    
                                 
                              
                           

The effectiveness of the proposed annotation methods is evaluated by three different metrics: (1) Costs entailed to match the nodes. Relative displacements of the nodes with respect to each other in the different graphs result in a matching ‘cost’. The Euclidean distances of each pair of nodes are summed up as the total matching costs. (2) Transformation errors are those errors resulting from affine transformation disparities between the reference graph and the ones aligned to it [27] (see Eq. (11) below). (3) Errors in recognition accuracy are those errors that can be observed once the bunch graph is built and used to classify the postures in the testing state.
                           
                              (11)
                              
                                 
                                    E
                                    =
                                    
                                       
                                          
                                             
                                                Ω
                                                1
                                             
                                             −
                                             
                                                R
                                                *
                                             
                                             
                                                Ω
                                                2
                                             
                                             −
                                             
                                                t
                                                *
                                             
                                             
                                                
                                                T
                                             
                                          
                                       
                                       T
                                    
                                    
                                       
                                          
                                             Ω
                                             1
                                          
                                          −
                                          
                                             R
                                             *
                                          
                                          
                                             Ω
                                             2
                                          
                                          −
                                          
                                             t
                                             *
                                          
                                          
                                             
                                             T
                                          
                                       
                                    
                                 
                              
                           
                        where R* is the optimal rotational (θ) and scaling matrix (s) (least-square minimization approach is used to reach the optimal) applied to Ω:
                           
                              (12)
                              
                                 
                                    
                                       R
                                       *
                                    
                                    =
                                    
                                       
                                          
                                             
                                                s
                                                cos
                                                θ
                                             
                                             
                                                −
                                                s
                                                sin
                                                θ
                                             
                                          
                                          
                                             
                                                s
                                                sin
                                                θ
                                             
                                             
                                                s
                                                cos
                                                θ
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where Ω is the vector representation of the coordinates the points in each image (x
                        
                           i
                        
                        
                           l
                        ,y
                        
                           i
                        
                        
                           l
                        ), l
                        ∈{1,2}. Also, 
                           t
                        * is the optimal translation parameter.

The semi-automatic approach allows the user to correct manually those points that were detected automatically. The correction is done by subjective observation, while the automatic method does not allow re-placing the nodes once found. To this end, the tradeoffs between the semi-automatic and automatic approaches are the time-saving with higher matching cost and transformation error and thus affecting the recognition accuracy.

We propose to assign a weight to each node of the graph. The standard approach assumes that equal weights are given to every node in the bunch graph when determining the similarity function for graph matching. However, some features of the hand are more dominant than others, in terms of their discriminative power. Thus, the importance (weight) over the nodes should be considered to reflect this attribute within the total similarity metric 
                           
                              
                                 S
                                 ˆ
                              
                              pha
                           
                        . The similarity metric is weighted by the coefficient vector c that represents the discriminatory degree of each node:
                           
                              (11)
                              
                                 
                                    
                                       
                                          S
                                          ˆ
                                       
                                       pha
                                    
                                    =
                                    
                                       
                                          ∑
                                          
                                             k
                                             =
                                             1
                                          
                                          K
                                       
                                       
                                          
                                             c
                                             k
                                          
                                          
                                             S
                                             pha
                                          
                                          
                                             
                                                
                                                   B
                                                   
                                                      k
                                                   
                                                
                                                ,
                                                J
                                                
                                                   
                                                      x
                                                      
                                                         k
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where B is the bunch graph with node index k, and J(x) is the jet computed from the target image taken at node vector x. The adaptive boosting described in Section 2.3 is used to train a strong classifier to classify the observed vectors based on the score 
                           
                              
                                 S
                                 ˆ
                              
                              pha
                           
                        . For different hand postures, the classifiers are trained separately. Positive samples (true hits) are created by extracting the feature vectors assigned the nodes in the positive images. Negative samples are feature vectors extracted by searching the best matching location of a bunch graph in the negative set of images from the training set (this method is broadly used to find negative instances that could potentially be recognized as true hits). Fig. 1
                         shows the similarity response of a sample image when the similarity metric is computed with and without weight assignment (the bunch graph is scanned over the entire image with an increment of 4pixels).

As can be seen, the similarity response when weight is used (the left image) is more ‘focused’ in a single point than the response without weight (the right image). In other words, the similarity scores of the entire image exhibit global maxima when weight is applied. The more focused the response is, the fewer local maxima, which provides more effective and reliable decision criterion.


                        Fig. 2
                         shows the importance of the nodes represented by a heat map (the edges are omitted to emphasize the nodes' coloring system). Warm colors represent high weight, while cold ones represent low weight. As can be seen, for those nodes with positions that blend with the background, lower weights are assigned (yellow color). On the other hand, those nodes over the rim of the hand are assigned higher weights (warmer colors) since they are more distinct from the background and more descriptive of the hand.

According to the testing results shown in Section 3.2, the ability to better discriminate features leads to a better decision surface which enables a more reliable classification. Furthermore, the fact that some features have assigned lower hierarchies indicates that their effect on the classification performance is low compared to those features assigned with higher hierarchies. Thus, the computation of these features can be skipped without affecting the recognition accuracy substantially. To explore the effect of the number of features selected on the algorithm, performance (the classification results) of the three scenarios was studied, where in each, the features (the nodes) were selected in different fashions:
                           
                              1.
                              Selection by weight: Sort the features by their assigned weights in descending order and select the N highest ranked features.

Selection by the magnitude of similarity: Sort the features by their magnitude of similarity score and select N highest ranked features.

Random selection: Randomly order the feature in a list, and select the N highest ranked features.

@&#EXPERIMENTAL RESULTS@&#

The proposed methods were validated with the Triesch's hand posture dataset [28]. The dataset consists of 10 different hand gestures against complex, light and dark backgrounds performed by 24 people. This results in a total of 710 gray-scale 128×128pixel images. Each bunch graph was created by selecting two instances of a given posture performed by three subjects against light and dark backgrounds (a total of six instances in each bunch graph). This constitutes the dictionary used. The geometry of the nodes (their position) on the bunch graph was averaged from the six graphs. Overall 60 images were used to create the bunch graphs. The remaining 650 images were used for the training and testing datasets. The results presented correspond to the classification performance among the extracted features from those 650 images. Examples showing the WEGM's detection performance are showed in Fig. 3
                     . The corresponding bunch graphs were fitted to 10 hand postures. Each image was scanned in increments of 4pixels in the horizontal and vertical directions.

The various colors from warm to cold colors were used to represent the nodes' weights. Light blue lines indicate the edges. The edges were allowed to distort to reflect the variation of gesture among images within the same category.

Several RGB images were captured to test the WEGM detection algorithm. The images were resized to 128×128pixels and the bunch graphs were scanned over the image by an increment of 4pixels. The matching results of several examples of three hand gestures' images with light, dark, and complex backgrounds are shown in Fig. 4
                     .

The receiver operating characteristic (ROC) curves are presented in Fig. 5
                        . The curves were generated using 5-fold cross-validation for the 10 hand gestures. A true positive was determined based on whether the classification score was greater than a given threshold (found empirically), otherwise it was regarded as a miss. When an observation was classified as a certain gesture, which was in fact a true negative, this event was considered as a false alarm. Following this guideline, ROC curves were plotted to show the relationship between the true positives and false alarms among the 10 classes, one for each hand gesture. The average recognition accuracy was 91.84%. This value was found by averaging all the 10 recognition accuracies on the operational point (the point closest to the top left corner of the graph).

The second metric to evaluate the hand gesture classification performance was the maximum score over the 10 classifiers (Max–Wins rule). This metric always assures a single detection (correct or incorrect) and no false positive cases. If the maximum score fell on the incorrect class, that gesture was misclassified (it was considered a confusion). The confusion matrix (see Fig. 6
                        ) was calculated by comparing the scores delivered by each classifier on a given sample image, and taking the maximum from all the classifiers. The average accuracy of correct classification over the confusion matrix reached 97.08%. Both these values show better performance than those reported in the literature [16,21]. In order to show that the improvement is significant, the t-test of paired two samples (650 observations for each) for equal means is conducted on the classification results of WEGM and EGM [16]. The one tailed p-value (1.5665E−06<.05) of the statistical test indicated that the classification is statistically significant regarding the performance.

To illustrate the generality of the weighted feature approach, the algorithm was tested on the MacBrain Face Stimulus database [29]. The dataset consists of 16 emotions performed by 40 people. The dictionary includes 96 faces to build the bunch graph per face. The nodes of the bunch graph are annotated on the fiducial points such as the inner and outer corners of the eyes, the inner and outer end of the eyebrows, the tips of the nose, and the corners of the mouth. We use 480 images (30 faces per facial expression) to conduct 5-fold cross-validation. The confusion matrix (see Fig. 7
                        ) of classified emotions presents 96.88% accuracy of correct classification. Fig. 8
                         shows 16 facial expressions when the bunch graph showing the weighted node is applied. The results show that the WEGM algorithm is also applicable to other types of human feature (facial expression) classification.

Three different scenarios were studied to validate the effect of the number of features selected (and how they were selected) on the classification accuracy. Fig. 9 shows the recognition results when applying the three different feature reduction policies (weights, magnitude of similarity and random). Once the features/nodes were sorted, only the N top percentage of the sorted list was selected to determine the effects on recognition accuracy. Nine cases were evaluated from 100% (no reduction) to 10% with decrements of 10% of the total number of features. The responses are presented in Fig. 9
                        . It can be seen that up to 30% of the nodes can be discarded without reducing the recognition accuracy below 90% when the first selection policy was applied. The recognition accuracy decreases at a pace slower than the other two scenarios (selected by magnitude of the similarity and randomly). The worst results occurred when features were discarded randomly. When the second scenario was applied (the features were selected by the sorted magnitude of similarity score), 50% of the nodes were required to assure 90% of recognition accuracy. It can be seen that in this scenario, the overall performance was not as good as in the first scenario, but still better than when the selection of nodes was random. Thus, the experimental results show that using the WEGM method, the computation time can be reduced by 30% by discarding those nodes which have no significant effect on the overall recognition accuracy.

In this section the performance of each annotation technique used to create the bunch graph is discussed. In the automatic and semi-automatic methods candidate nodes were found in highly textured regions inside the hand. The semi-automatic method allowed nodes to be adjusted manually after being detected. The results displayed in Fig. 10
                         illustrate the performance measures when using the three different methods to annotate the nodes used in the bunch graphs. Three classifiers were trained using the three different annotation methods, and tested with light and dark background images. When using the semi-automatic technique tested with light and dark background images, the recognition error (7.88%) was less than the other two methods (9.07%, and 10.74% for manual and automatic, respectively). The normalized matching cost was the highest for the automatic technique due to the inconsistency of the nodes' position among the graphs. For the similar reason, the normalized transformation error was also the highest for the automatic technique. However, the costs and errors of matching between manual and semi-automatic approaches were comparable. The recognition error was slightly greater for the manual case. Although matching costs and errors of the semi-automatic method were slightly greater than those using the manual method, these measures were substantially less than those when using the automatic method. Therefore, there is a trade-off between recognition error and the speed of creating the annotation, which is expressed by the high matching costs and transformation errors. The proposed semi-automatic technique is an efficient annotation method for building up the bunch graph faster when desired recognition accuracy is acceptable.

@&#CONCLUSION@&#

This research proposed an enhanced graph-based approach incorporating the concept of node weight (WEGM) to recognize a lexicon of ten hand gestures. The WEGM algorithm was validated using a standard dataset of postures against three different backgrounds: light, dark and complex. The WEGM algorithm classified the postures with a recognition accuracy of 97.08% on average. This shows that introducing weight in the bunch graphs improves the overall performance. The reason for this is that the WEGM augments the discriminatory power of the nodes for each gesture with respect to the remaining gestures. Furthermore, by computing the features of only the nodes with a relatively high weight and discarding the rest, the recognition performance is not significantly affected. Thus, the WEGM approach improves the recognition performance while reducing the computational time required for computing the features.

Additionally, semi-automatic and automatic annotation techniques were proposed which allow the flexible selection of nodes which are consistent between images of the same posture. The semi-automatic approach was shown to deliver the highest recognition accuracy (lowest recognition error) though not the least matching and transformation costs, compared to the manual and automatic methods in constructing the bunch graphs.

Future work includes extending the WEGM algorithm to include depth information with color. One simple approach would be to use the range information to have a good initial region of interest for matching the WEGM with the target image. This will result in a smaller search and will reduce the overall computation time. In addition, we are interested in experimenting with multimodal images (thermal, depth and color) and suggest an efficient method to combine these modalities to enhance overall performance. We plan to experiment with other features, like wavelets and HOGs, and include larger and more complex datasets. Finally, we will develop a parallel implementation of this algorithm for real-time detection and classification of hand gestures.

@&#REFERENCES@&#

