@&#MAIN-TITLE@&#Integration of electromagnetism with multi-objective evolutionary algorithms for RCPSP

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Electromagnetism (EM) is integrated with multi-objective evolutionary algorithms (MOEAs).


                        
                        
                           
                           Performance of EM integration to NSGA-II, SPEA2 and MOEA/D for RCPSP is compared.


                        
                        
                           
                           Employment of EM to NSGA-II is the most effective.


                        
                        
                           
                           EM does not improve the performance of MOEA/D on RCPSP.


                        
                        
                           
                           Explanation of why EM heuristics plays different roles in the studied algorithms is given.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Multiple objective programming

Heuristics

Resource-constrained project scheduling

Electromagnetism

Evolutionary algorithms

@&#ABSTRACT@&#


               
               
                  As one of the most challenging combinatorial optimization problems in scheduling, the resource-constrained project scheduling problem (RCPSP) has attracted numerous scholars’ interest resulting in considerable research in the past few decades. However, most of these papers focused on the single objective RCPSP; only a few papers concentrated on the multi-objective resource-constrained project scheduling problems (MORCPSP). Inspired by a procedure called electromagnetism (EM), which can help a generic population-based evolutionary search algorithm to obtain good results for single objective RCPSP, in this paper we attempt to extend EM and integrate it into three reputable state-of-the-art multi-objective evolutionary algorithms (MOEAs) i.e. non-dominated sorting based multi-objective evolutionary algorithm (NSGA-II), strength Pareto evolutionary algorithm (SPEA2) and multi-objective evolutionary algorithm based on decomposition (MOEA/D), for MORCPSP. We aim to optimize makespan and total tardiness. Empirical analysis based on standard benchmark datasets are conducted by comparing the versions of integrating EM to NSGA-II, SPEA2 and MOEA/D with the original algorithms without EM. The results demonstrate that EM can improve the performance of NSGA-II and SPEA2, especially for NSGA-II.
               
            

@&#INTRODUCTION@&#

The research on the classical resource-constrained project scheduling problem (RCPSP) has been widely expanded over the past several decades. According to the reviews provided by Herroelen, Demeulemeester, and Reyck (1999, chap. 1), Brucker, Drexl, Möhring, Neumann, and Pesch (1999), Icmeli, Erenguc, and Zappe (1993), Kolisch and Padman (2001) and ÖZdamar and Ulusoy (1995), the RCPSP can be stated as follows. A set of activities N numbered from 0 to n is to be scheduled without preemption. Activity i has a duration di
                      and needs some resources which are limited during every moment to be completed. We assume that the renewable resource set is R and the availability of each resource type k, k ∈ R, which is a constant ak
                      throughout the project horizon. Each activity i needs rik
                      units of resource k during each period of its duration, i ∈ N, k ∈ R. The dummy start and end activities 0 and n have zero duration and do not require any resource. The precedence relation among the activities is that one activity cannot be started until all its predecessors have been finished. A solution for RCPSP is feasible if and only if the precedence and resource constraints are satisfied. In general, a solution of RCPSP is represented as a schedule or a list of start times 
                        
                           s
                           =
                           (
                           
                              s
                              0
                           
                           ,
                           …
                           ,
                           
                              s
                              n
                           
                           )
                        
                      that implies a corresponding finishing times 
                        
                           f
                           =
                           (
                           
                              f
                              0
                           
                           ,
                           …
                           ,
                           
                              f
                              n
                           
                           )
                        
                     . Obviously, as every manager usually wants to finish projects as quickly as possible with minimum cost and high quality, RCPSP is a multi-objective optimization problem. Słowiński (1981) is the first to describe the multi-objective resource-constrained project scheduling problem (MORCPSP) framework and list all kinds of objectives. After the further research on MORCPSP, the primary objectives include makespan, activity tardiness, net present value (NPV), resource investment (RI), and robustness. MORCPSP is strongly NP-hard.

As one kind of the most effective algorithms used for solving NP-hard problems, metaheuristic algorithms have been developed and proved to be successful in practice. Certainly many multi-objective metaheuristic approaches named MOEAs (multi-objective evolutionary algorithms) have been developed rapidly and applied for multi-objective optimization problems widely. Fonseca et al. (1993) proposed multi-objective genetic algorithm (MOGA); Srinivas and Deb (1994) proposed non-dominated sorting genetic algorithm (NSGA) and Horn, Nafpliotis, and Goldberg (1994) proposed niched Pareto genetic algorithm (NPGA). These algorithms were generally classified as the first generation of MOEAs in which selecting individuals based on Pareto ranks and maintaining population diversity by fitness sharing were the common features. The second generation of MOEAs based on elitism strategy has been proposed successively since 1999. Zitzler and Thiele (1999) presented Strength Pareto Evolutionary Algorithm (SPEA) and the improved version SPEA2 was described in Zitzler, Laumanns, and Thiele (2001). Pareto Archived Evolution Strategy (PAES) was proposed by Knowles and Corne (2000). Pareto Envelope-Based Selection Algorithm (PESA) and its improved version of PESA-II were introduced in Corne, Knowles, and Oates (2000) and Corne, Jerram, Knowles, and Oates (2001) respectively. Erickson, Mayer, and Horn (2001, chap. 48) advanced NPGA2, and the famous NSGA-II was proposed by Deb, Pratap, Agarwal, and Meyarivan (2002). On the other hand, Zhou, Zhang, Jin, Sendhoff, and Tsang (2007) presented Regularity Model Based Multi-objective Estimation of Distribution Algorithm (RM-MEDA), and Zhang and Li (2007) introduced Multi-objective Evolutionary Algorithm Based on Decomposition (MOEA/D) by combining traditional mathematical programming with evolutionary algorithms.

Even though the MOEAs of the second generation have been proved to be successful in handling multi-objective optimization problems with high performance, only a few MOEAs such as NSGA-II have been used for dealing with MORCPSP. Meanwhile, many excellent hybrid algorithms have been presented and applied for classical single objective RCPSP successfully. As the electromagnetism (EM) heuristics has been applied for many unconstrained global optimization problem, Debels, De Reyck, Leus, and Vanhoucke (2006) extended the electromagnetism heuristics and integrated it into a scatter search (SS) frame for single objective RCPSP. By utilizing the principle that the EM force generated by two solutions would guide the search direction, scatter search integrated with EM outperformed other state-of-the-art heuristics for single objective RCPSP in this literature. However, to the best of our knowledge, no paper was found in literature integrating EM heuristics into MOEAs to solve MORCPSP. Inspired by the method presented by Debels, we modify the EM heuristics to make it suitable for MORCPSP and combine it with several state-of-the-art MOEAs i.e. NSGA-II, SPEA2 and MOEA/D in this paper.

The paper is organized as follows: in Section 2, a literature review is presented. In Section 3, some basic concepts concerning MORCPSP are introduced. Then the representation and evaluation measurements for MORCPSP are defined in Section 4. In Section 5, we show how the EM methodology can be modified to be used for MORCPSP. Brief introductions of NSGA-II, SPEA2, MOEA/D and the method of integrating EM heuristics into the three algorithms are given in Section 6. Section 7 shows experimental results and comparison analysis. Finally, some concluding remarks are given in Section 8.

@&#LITERATURE REVIEW@&#


                     Słowiński (1981) presented the first multi-objective RCPSP framework that applied multi-objective linear programming to a MORCPSP with splittable activities, multiple modes, renewable, non-renewable and doubly constrained resources. It is notable that this procedure belonged to single objective optimization process actually because it could only optimize one objective each time. Furthermore, Słowiński, Soniewicki, and Wȩglarz (1994) proposed a decision support system to optimize several objectives including project completion time, smoothness of the resource profile, total resource consumption, weighted resource consumption, weighted flow time and net present value by using parallel priority rules, simulated annealing, branch and bound. Hapke, Jaszkiewicz, and Slowinski (1997) considered a multi-mode project scheduling problem under multi-category resource constraints with fuzzy time parameters of activities. A metaheuristic procedure Pareto simulated annealing (PSA) was presented to generate approximation solutions. Hapke, Jaszkiewicz, and Słowiński (1999, chap. 16), Pan and Yeh (2003, chap. 145) conducted the similar research. These three papers employed PSA frequently, and were partial to the fuzzy version of MORCPSP. Hapke, Jaszkiewicz, and Słowiński (1998) proposed a two-stage interactive search over a non-dominated solution space to handle a multiple-criteria PSP with multiple modes, renewable, non-renewable and doubly constrained resources. In order to optimize makespan, resource utilization smoothness, maximum lateness, NPV and project cost, in the first stage the approach applied PSA to generate a large representative sample of approximately non-dominated schedules. An iterative search over the sample based on the discrete version of the Light Beam Search (LBS) procedure was organized in the secondary stage.


                     Nabrzyski and Wȩglarz (1995) described a decision support system that could generate a set of feasible schedules using tabu search (TS) for individual criteria. In Nabrzyski and Wȩglarz (1999, chap. 17), they presented a knowledge-based multi-objective project scheduling system that handled a class of non-preemptive scheduling problems. The system made decisions during search. The optimization procedure was separated into several steps, and the trade-off solutions generated by each step guided the next step. These two models proposed by Nabrzyski considered the similar objective functions to Hapke et al. (1998), but difficult to obtain enough non-dominated solutions. In order to minimize the makespan, the “weighted” lateness of activities and the violation of resource constraints, Viana and Pinho de Sousa (2000) applied multi-objective versions of simulated annealing (MOPSA) and tabu search (MOTS) to RCPSP. In consequence of the absence of resource constraints, the procedure generated different schedules; it seemed difficult to obtain excellent solutions for medium or large instances in various performance measurements. Al-Fawzan and Haouari (2005) took two objectives of makespan and robustness (maximize the sum of the free slack of activities) into account. A MOTS that ran a single-objective TS with a different linearly aggregated function several times was implemented for this model. The approach could obtain good solutions in terms of makespan while one of the drawbacks was that it would probably miss the solutions with good performance for robustness but not good enough at makespan. Abbasi, Shadrokh, and Arkat (2006) aggregated two objectives of minimizing makespan and maximizing robustness into a linear objective and applied SA to solve it.

Most of the aforementioned papers applied SA and TS to solve MORCPSP, but failed to obtain enough Pareto solutions. Apart from the methods motioned above, other algorithms have been used to solve MORCPSP. Kazemi and Tavakkoli-Moghaddan (2008) presented a mathematical model for MORCPSP with discounted cash flows that aimed at minimizing makespan and maximizing net present value. Due to the computational complexity of MORCPSP, the software proposed for solving the model only could handle the test instances with small number of activities and resources. NSGA-II was applied to this model for the same test instances as well. Aboutalebi, Najafi, and Ghorashi (2012) compared the performance of NSGA-II and Multi-objective Particle Swarm Optimization (MOPSO) for the bi-objective RCPSP. The adopted objectives were the minimization of project makespan and maximization of net present value. The computation result demonstrated the superior performance of NSGA-II in terms of metric C and maximum spread metric. Ballestín and Blanco (2011) focused on the theoretical study and gave some proof for MOPSP with regular objective functions(ROFs). Comparisons among NSGA-II, SPEA2 and PSA in several performance measures were presented. However, the representation of a solution was complicated and the measures to evaluate the quality of a solution obtained by algorithms were intricate because of all kinds of artificial parameters. Wang, Fang, Mu, and Liu (2013) presented a Pareto-archived estimation-of-distribution algorithm (PAEDA) for the multi-objective resource-constrained project scheduling problem with makespan and resource investment criteria. The numerical experiment results showed that the PAEDA outperformed the existing methods. Gomes, de Assis das Neves, and Souza (2014) implemented five multi-objective metaheuristic algorithms, based on multi-objective GRASP (MOG), multi-objective variable neighborhood search (MOVNS), a MOG using NVS as local search (GMOVNS), a MOVNS with an intensification procedure (MOVNS_I) and Pareto iterated local search (PILS), for MORCPSP to optimize makespan and total weighted start time of the activities. Four performance measurements: distance metric, hypervolume indicator, epsilon metric and error ratio were used for comparisons. A detailed experimental analysis indicated MOVNS as the most efficient one in terms of the distance metric, MOG and MOVNS to be superior in terms of the hypervolume and epsilon metrics and PILS as the best in terms of the error ratio.

From all the reviews, the research on MORCPSP is still limited and there are only a few papers which applied MOEAs to MORCPSP. No paper is found in literature combining popular MOEAs i.e., NSGA-II, SPEA2 and MOEA/D with other heuristic approaches for dealing with MORCPSP.

A multi-objective optimization problem (MOP) can be stated as follows:

                        
                           (1)
                           
                              
                                 m
                                 i
                                 n
                                 i
                                 m
                                 i
                                 z
                                 e
                                 
                                 F
                                 
                                    (
                                    x
                                    )
                                 
                                 =
                                 (
                                 
                                    f
                                    1
                                 
                                 
                                    (
                                    x
                                    )
                                 
                                 ,
                                 …
                                 ,
                                 
                                    f
                                    m
                                 
                                 
                                    (
                                    x
                                    )
                                 
                                 )
                                 
                                 s
                                 u
                                 b
                                 j
                                 e
                                 c
                                 t
                                 
                                 t
                                 o
                                 
                                 
                                 
                                 x
                                 ∈
                                 Ω
                              
                           
                        
                     where Ω is the decision (variable) space, Rm
                      is the objective space, and F: Ω → Rm
                      consists of m objective functions. If the variable space is continuous, the MOP is considered as a multi-objective continuous optimization problem and the MOP is termed a multi-objective combinatorial optimization problem when the variable is discrete. Very often, no solution in Ω can minimize all the objectives simultaneously since the objectives in (1) contradict with each other. As a decision maker, the tradeoffs among the objectives have been taken into consideration usually. The best tradeoffs among the objectives can be defined in terms of Pareto optimality.

Let xa, xb
                      in Ω, xa
                      dominates xb
                     , (xa
                     ≺xb
                     ) if and only if

                        
                           (2)
                           
                              
                                 
                                    
                                       
                                          ∀
                                          i
                                       
                                    
                                    
                                       =
                                    
                                    
                                       
                                          1
                                          ,
                                          2
                                          ,
                                          …
                                          ,
                                          m
                                          ,
                                          
                                          
                                             f
                                             i
                                          
                                          
                                             (
                                             
                                                x
                                                a
                                             
                                             )
                                          
                                          ≤
                                          
                                             f
                                             i
                                          
                                          
                                             (
                                             
                                                x
                                                b
                                             
                                             )
                                          
                                          
                                          ∧
                                       
                                    
                                 
                                 
                                    
                                       
                                          ∃
                                          j
                                       
                                    
                                    
                                       =
                                    
                                    
                                       
                                          1
                                          ,
                                          2
                                          ,
                                          …
                                          ,
                                          m
                                          ,
                                          
                                          
                                             f
                                             i
                                          
                                          
                                             (
                                             
                                                x
                                                a
                                             
                                             )
                                          
                                          <
                                          
                                             f
                                             i
                                          
                                          
                                             (
                                             
                                                x
                                                b
                                             
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                  

A solution x
                     * ∈ Ω is Pareto optimal (non-dominated) if and only if

                        
                           (3)
                           
                              
                                 ¬
                                 ∃
                                 x
                                 ∈
                                 Ω
                                 
                                 x
                                 ≺
                                 
                                    x
                                    *
                                 
                              
                           
                        
                     
                     F(x
                     *) is then called a Pareto optimal (objective) vector. The set of all Pareto optimal solutions (non-dominated solutions) is called Pareto set (PS) and the set of all Pareto optimal objective vectors is called Pareto front (PF), referring to Miettinen (1999).

In MORCPSP, the precedence relationship among activities is illustrated by a directed acyclic graph and every node in the graph has a series of attributes associated with time and resource constraints. There are many objective functions of interest for managers. Some of them can be listed as follows in Table 1
                      by referring to Ballestín and Blanco (2011). Some problem notations are necessary for formal description: ddi
                      and rdi
                      denote the due date and release date of activity i respectively; wi
                      is the weight associated with cost or reward; α is the discount rate. In the final formula in Table 1, the slack of i on s is the amount of time that activity i can slip without delaying the start of the next activities while maintaining resource feasibility. All the objectives aim to be minimized but NPV and robustness should be maximized. In this paper, we focus on the makespan fn
                      and total tardiness (TWT without considering the weights).

Once the fundamental definitions of MORCPSP have been established, we discuss the representation scheme and evaluation procedure of solutions for RCPSP. It is well known that a solution for RCPSP is a schedule, but most metaheuristic algorithms for RCPSP do not operate on a schedule directly. It is convenient and effective when a solution is represented in some particular ways which can be transformed into a schedule using a scheduled generation scheme (SGS). According to Brucker et al. (1999), even though there are many representations for schedules of heuristics for the RCPSP, random-key (RK) and activity-list (AL) are the most important ones. The corresponding recombination methods generally include traditional one point or two point crossover and other proven effective conventional crossover such as parameterized uniform crossover (Mendes, Goncalves, & Resende, 2009). Due to the disadvantage that a single schedule can be represented by different activity lists or random keys, Debels et al. (2006) modified the standard random-key (SRK) representation in order to guarantee that each RK corresponded to a unique schedule. Taking a project depicted in Fig. 1
                     , for example, we can give a brief illustration for SRK. Assuming that activity i only need one kind of renewable resource, and the amount of resource units required for activity i is ri
                     . The duration and due date of activity i are di
                      and ddi
                      respectively; a feasible schedule could be depicted as Fig. 2
                      if each type of resource availability is 2 (we omit the dummy start and end activity, horizontal axis represents the time and vertical axis represents the resource). According to the starting time of each activity, we assign a priority for each activity. The activity with the earliest starting time receives the highest priority denoted by 1, so we can obtain a RK vector 
                        
                           x
                           =
                           [
                           1
                           ;
                           5
                           ;
                           3
                           ;
                           2
                           ;
                           4
                           ;
                           6
                           ;
                           7
                           ;
                           8
                           ;
                           9
                           ]
                        
                      for the schedule in Fig. 2. Because the priorities of the activities which have the same starting time can be exchanged without affecting the associated schedule, a schedule has multiple representations. A unique standardized random key (SRK) representation for schedule in Fig. 2 can be gained when we attribute the lowest priority to all activities starting at the same time such as 1 for activity 1 and activity 4, 4 for activity 2 and activity 5. By doing this for x, we finally obtain the unique SRK vector 
                        
                           
                              x
                              ′
                           
                           =
                           
                              [
                              1
                              ;
                              4
                              ;
                              3
                              ;
                              1
                              ;
                              4
                              ;
                              6
                              ;
                              7
                              ;
                              8
                              ;
                              9
                              ]
                           
                        
                     . For every new priority vector created in the algorithm, it is convenient to transform it into SRK form by using serial SGS. We can convert it to a SRK vector in accordance with the starting time obtained by serial SGS.

Before we use SGS to generate SRK vector, we can get an initial random key chromosome vector RK. In the initial step, we can generate initial chromosomes by topological sorting. The precedence relationship between each task is depicted with an acyclic graph G which includes n vertices. Assuming that Idpv
                      denotes the amount number of the precursor tasks of vertex v and Sucv
                      represents all the successor tasks of vertex v, we can obtain an initial random key chromosome vector RK as follows.

∀v ∈ G, 
                        
                           
                              ∝
                              v
                           
                           =
                           I
                           d
                           
                              p
                              v
                           
                        
                     ;


                     
                        
                           s
                           =
                           {
                           }
                           ,
                           i
                           =
                           1
                           ,
                           p
                           r
                           i
                           o
                           =
                           1
                        
                     ;

Repeat until 
                        
                           i
                           =
                           n
                        
                     
                  

 
                     
                        
                           V
                           =
                           {
                           v
                           ∉
                           s
                           ∣
                           
                              ∝
                              v
                           
                           =
                           0
                           }
                        
                     
                  

 Push all v ∈ V onto a stack in an arbitrary order;

 Pop a task w from the stack, 
                        
                           i
                           =
                           i
                           +
                           1
                        
                     ;

 
                     
                        
                           s
                           =
                           s
                           ∪
                           {
                           w
                           }
                        
                     ;

 
                     
                        
                           R
                           K
                           [
                           w
                           ]
                           =
                           p
                           r
                           i
                           o
                           ,
                           p
                           r
                           i
                           o
                           =
                           p
                           r
                           i
                           o
                           +
                           1
                        
                     ;

 
                     
                        
                           ∀
                           v
                           ∈
                           S
                           u
                           
                              c
                              w
                           
                           ,
                           
                              ∝
                              v
                           
                           =
                           
                              ∝
                              v
                           
                           −
                           1
                        
                     ;

Then, we can build a schedule from any one chromosome by using SGS procedure. The SGS procedure is briefly described as follows:


                     Prew
                     : the precursor tasks of task w;


                     Sucw
                     : the successor tasks of task w;


                     sw
                     : start time of task w;


                     fw
                     : finish time of task w;


                     rwk
                     : request quantity resource k of task w;


                     
                        
                           
                              R
                              k
                              ′
                           
                           
                              (
                              t
                              )
                           
                        
                     : current quantity of resource k at time t;


                     
                        
                           ∀
                           v
                           ∈
                           G
                           ,
                           
                              ∝
                              v
                           
                           =
                           I
                           d
                           
                              p
                              v
                           
                        
                     ;


                     
                        
                           f
                           e
                           a
                           s
                           i
                           b
                           l
                           e
                           t
                           a
                           s
                           k
                           =
                           {
                           }
                        
                     ;

For 
                        
                           i
                           =
                           1
                        
                      to 
                        
                           i
                           =
                           n
                        
                     
                  

 
                     
                        
                           V
                           =
                           {
                           v
                           ∉
                        
                      feasibletask 
                        
                           ∣
                           
                              ∝
                              v
                           
                           
                              =
                              0
                              }
                           
                        
                     
                  

 Insert all v ∈ V into a queue q in ascendent order with RK[v];

 Delete the head task w from queue q;

 if 
                        
                           P
                           r
                           
                              e
                              w
                           
                           =
                           ϕ
                           
                           t
                           h
                           e
                           n
                           
                           
                              s
                              w
                           
                           =
                           0
                           
                           e
                           l
                           s
                           e
                           
                           
                              s
                              w
                           
                           =
                           m
                           a
                           
                              x
                              
                                 j
                                 ∈
                                 P
                                 r
                                 
                                    e
                                    w
                                 
                              
                           
                           
                              {
                              
                                 f
                                 j
                              
                              }
                           
                        
                     ;

 
                     
                        
                           
                              s
                              w
                           
                           =
                           m
                           i
                           n
                           
                              {
                              t
                              ∣
                              
                                 r
                                 
                                    w
                                    k
                                 
                              
                              ≤
                              
                                 R
                                 k
                                 ′
                              
                              
                                 (
                                 τ
                                 )
                              
                              
                              ∀
                              k
                              ∈
                              K
                              ,
                              τ
                              ∈
                              
                                 [
                                 t
                                 ,
                                 t
                                 +
                                 
                                    d
                                    w
                                 
                                 ]
                              
                              ,
                              t
                              ≥
                              
                                 s
                                 w
                              
                              }
                           
                        
                     ;

 
                     
                        
                           
                              f
                              w
                           
                           =
                           
                              s
                              w
                           
                           +
                           
                              d
                              w
                           
                        
                     ;

 Update resource profile;

 feasibletask = feasibletask ∪{w};

 
                     
                        
                           ∀
                           v
                           ∈
                           S
                           u
                           
                              c
                              w
                           
                           ,
                           
                              ∝
                              v
                           
                           =
                           
                              ∝
                              v
                           
                           −
                           1
                        
                     ;

With the above SGS procedure, we can obtain the SRK chromosome when we give the tasks the same random keys if the tasks start at the same time.

As we have known that a feasible schedule could be obtained by using serial SGS, in order to improve the solution quality, Li and Willis (1992) and Özdamar and Ulusoy (1996) presented an iterative scheduling technique. The principle contains two stages as follows.

                        
                           Stage 1.
                           Backward shift: when a schedule for example as Fig. 2 has been obtained by serial SGS, we consider the end time of activities as priority rule by assigning the highest priority to the activity with maximum end time. Let the maximum finish time be a start point, according to the above priority rule and the precedence relationships between activities, we can schedule the activities in the direction from right to left and obtain a new schedule. The new schedule is depicted in Fig. 3
                              .

Forward shift: in reverse, we rank the priorities in descending order by the starting time of activities generated in Stage 1. With this order we schedule the activities from left to right to obtain another schedule illustrated by Fig. 4
                              .

Assuming that 
                        
                           d
                           d
                           =
                           [
                           2
                           ;
                           5
                           ;
                           5
                           ;
                           2
                           ;
                           4
                           ;
                           8
                           ;
                           10
                           ;
                           10
                           ;
                           12
                           ]
                        
                      is the due date set of this example project (see Fig. 1), according to the objective functions, the makespan and total tardiness of the schedule depicted in Fig. 2 are 18 and 23 respectively. The makespan and total tardiness of another schedule depicted in Fig. 4 are equal to 15 and 21. It is obvious to show the improvement of the schedule by using backward and forward shifts. It has also been proved that the schedule makespan obtained by backward and forward shifts is never higher than the makespan of the schedule without shifting. In fact, we reduce the makespan by shifting each activity as much as possible to the right without affecting the project completion time and then shifting them to left as much as possible in a similar way. Attributing to the left shift, the starting time of most activities will be minimized, of course the total tardiness of a schedule will be reduced too. In this paper, we iteratively perform backward and forward shifts until no further improvement can be found.

Before introducing the EM heuristics, we illustrate how to use traditional two-point crossover operator to recombine offspring. If p
                     1 and p
                     2 are two parents, we can get two offspring c
                     1 and c
                     2 with two-point crossover operation as follows.

Randomly generate two integers γ
                     1 and γ
                     2, 1 < γ
                     1 < γ
                     2 < n.

For i ∈ [1, γ
                     1] and 
                        
                           i
                           ∈
                           
                              [
                              
                                 γ
                                 2
                              
                              +
                              1
                              ,
                              n
                              ]
                           
                           ,
                           
                              c
                              1
                           
                           
                              [
                              i
                              ]
                           
                           =
                           
                              p
                              1
                           
                           
                              [
                              i
                              ]
                           
                           ,
                           
                              c
                              2
                           
                           
                              [
                              i
                              ]
                           
                           =
                           
                              p
                              2
                           
                           
                              [
                              i
                              ]
                           
                        
                     ;

For 
                        
                           i
                           ∈
                           
                              [
                              
                                 γ
                                 1
                              
                              +
                              1
                              ,
                              
                                 γ
                                 2
                              
                              ]
                           
                           ,
                           
                              c
                              1
                           
                           
                              [
                              i
                              ]
                           
                           =
                           
                              p
                              2
                           
                           
                              [
                              i
                              ]
                           
                           ,
                           
                              c
                              2
                           
                           
                              [
                              i
                              ]
                           
                           =
                           
                              p
                              1
                           
                           
                              [
                              i
                              ]
                           
                        
                     .

Consider as an example

 
                     
                        
                           
                              p
                              1
                           
                           =
                           
                              [
                              1
                              ;
                              3
                              ;
                              6
                              ;
                              ∣
                              1
                              ;
                              5
                              ;
                              4
                              ;
                              ∣
                              7
                              ;
                              8
                              ;
                              9
                              ]
                           
                        
                     
                  

 
                     
                        
                           
                              p
                              2
                           
                           =
                           
                              [
                              1
                              ;
                              1
                              ;
                              3
                              ;
                              ∣
                              6
                              ;
                              4
                              ;
                              4
                              ;
                              ∣
                              8
                              ;
                              7
                              ;
                              8
                              ]
                           
                        
                     
                  

then

 
                     
                        
                           
                              c
                              1
                           
                           =
                           
                              [
                              1
                              ;
                              3
                              ;
                              6
                              ;
                              ∣
                              6
                              ;
                              4
                              ;
                              4
                              ;
                              ∣
                              7
                              ;
                              8
                              ;
                              9
                              ]
                           
                        
                     
                  

 
                     
                        
                           
                              c
                              2
                           
                           =
                           
                              [
                              1
                              ;
                              1
                              ;
                              3
                              ;
                              ∣
                              1
                              ;
                              5
                              ;
                              4
                              ;
                              ∣
                              8
                              ;
                              7
                              ;
                              8
                              ]
                           
                        
                     
                  

Finally, we also should build schedules and get SRK chromosomes by using SGS on offspring.

Electromagnetism (EM) heuristics for unconstrained global optimization problems is proposed by Birbil and Fang (2003). Each point represented a solution has a charge related to an objective function value in a multi-objective solution space by analogy with electromagnetism. Two arbitrary points in a population of solutions will generate a force with each other. In an evolutionary search algorithm, each point (solution) in the population will exert attraction or repulsion on other points with the force which is proportional to the product of the charges and inversely proportional to the distance between the points. The principle of EM heuristics to guide the search is that a point with a relatively good objective function value attracts the other ones and the points with inferior objective values repel the other population members. Based on the research of Birbil and Fang (2003), for RCPSP, Debels et al. (2006) modified and integrated the EM heuristics into SS procedure for new solution recombination. The main idea of his modification is as follows.

Let xi
                      and xj
                      be two feasible solutions of RCPSP, which are represented by SRK. A charge qij
                      that depends on the relative difference in objective function value between xi
                      and xj
                      can be defined as:

                        
                           (4)
                           
                              
                                 
                                    q
                                    
                                       i
                                       j
                                    
                                 
                                 =
                                 
                                    
                                       f
                                       
                                          (
                                          
                                             x
                                             i
                                          
                                          )
                                       
                                       −
                                       f
                                       
                                          (
                                          
                                             x
                                             j
                                          
                                          )
                                       
                                    
                                    
                                       f
                                       
                                          (
                                          
                                             x
                                             
                                                w
                                                o
                                                r
                                                s
                                                t
                                             
                                          
                                          )
                                       
                                       −
                                       f
                                       
                                          (
                                          
                                             x
                                             
                                                b
                                                e
                                                s
                                                t
                                             
                                          
                                          )
                                       
                                    
                                 
                              
                           
                        
                     where xworst
                      and xbest
                      are the worst and best solutions in population. If f(xi
                     ) < f(xj
                     ), i.e. xi
                      is better than xj, qij
                      is negative and xj
                      repels xi
                     . The opposite, i.e. xj
                      attracts xi
                      when xi
                      is worse than xj
                     . The force exerted on solution xi
                      by solution xj
                      can be defined as:

                        
                           (5)
                           
                              
                                 
                                    F
                                    
                                       i
                                       j
                                    
                                 
                                 =
                                 
                                    (
                                    
                                       x
                                       j
                                    
                                    −
                                    
                                       x
                                       i
                                    
                                    )
                                 
                                 ·
                                 
                                    q
                                    
                                       i
                                       j
                                    
                                 
                              
                           
                        
                     
                  

It is notable that xi
                      and xj
                      are vectors, so Fij
                      is a vector as well. Finally, the search can move from solution xi
                      to 
                        
                           
                              x
                              i
                           
                           +
                           
                              F
                              
                                 i
                                 j
                              
                           
                        
                      in the direction of xj
                     .

For the RCPSP, forces are exerted in changing in the priority of each activity. Two boundaries 
                        
                           
                              p
                              
                                 m
                                 i
                                 n
                              
                           
                           ∈
                           
                              [
                              1
                              ;
                              n
                              −
                              1
                              ]
                           
                        
                      and pmax
                      ∈ [2; n] (n denotes the total amount of activities) are selected randomly and the SRK values between pmin
                      and pmax
                      are updated according to the force exerted in these dimensions. Be different from the activities with SRK values between pmin
                      and pmax
                     , the activities with SRK values lower than pmin
                      or higher than pmax
                      preserve the priorities structure from the original solution through subtracting a large constant from all SRK values lower than pmin
                      and adding a large constant to all those larger than pmax
                     . The last step is transforming the resulting RK vector into SRK format. A hybrid two-point/EM crossover operator can be described briefly as follows:

                        
                           1.
                           
                              SRK < pmin
                              : a large constant value is subtracted from the priority.


                              pmin
                               ≤ SRK ≤ pmax
                              : a force calculated by EM is added to the priority value.


                              SRK > pmax
                              : a large constant value is added to the priority value.

Due to the definition of formula (4) considers only single objective, we extend it for MOP as:

                        
                           (6)
                           
                              
                                 
                                    q
                                    
                                       i
                                       j
                                    
                                 
                                 =
                                 
                                    ∑
                                    
                                       k
                                       =
                                       1
                                    
                                    m
                                 
                                 
                                    φ
                                    k
                                 
                                 
                                    
                                       
                                          f
                                          k
                                       
                                       
                                          (
                                          
                                             x
                                             i
                                          
                                          )
                                       
                                       −
                                       
                                          f
                                          k
                                       
                                       
                                          (
                                          
                                             x
                                             j
                                          
                                          )
                                       
                                    
                                    
                                       
                                          f
                                          k
                                          
                                             w
                                             o
                                             r
                                             s
                                             t
                                          
                                       
                                       −
                                       
                                          f
                                          k
                                          
                                             b
                                             e
                                             s
                                             t
                                          
                                       
                                    
                                 
                              
                           
                        
                     where m is the number of objectives, fk
                     (xi
                     ) is the kth objective value of xi
                     , 
                        
                           f
                           k
                           
                              w
                              o
                              r
                              s
                              t
                           
                        
                      and 
                        
                           f
                           k
                           
                              b
                              e
                              s
                              t
                           
                        
                      are the worst and best values of kth objective, φ
                        k
                      is a constant factor. We can obtain the worst and best values for each objective in the initial population and define them as the f
                      
                        worst
                      and f best
                     . In the next generations, we update the f
                      
                        worst
                      and f best
                      by obtaining the objective values worse than current f
                      
                        worst
                      and better than current f best
                     . Similar to single objective case, qij
                      is positive and xj
                      attracts xi
                      in its direction if xi
                      is dominated by xj
                     . On the contrary, xj
                      repels xi
                      when xi
                      dominates xj
                     . For example, xj
                      will guide the move direction of xi
                      with the attractive force Fij
                      when xj
                      dominates xi
                      in Fig. 5
                     .

We will demonstrate how to implement hybrid two-point/EM crossover operator by the case of example project depicted in Fig. 1 in Section 3. Let 
                        
                           
                              x
                              1
                           
                           =
                           
                              [
                              1
                              ;
                              3
                              ;
                              6
                              ;
                              1
                              ;
                              5
                              ;
                              4
                              ;
                              7
                              ;
                              8
                              ;
                              9
                              ]
                           
                        
                      and 
                        
                           
                              x
                              2
                           
                           =
                           
                              [
                              1
                              ;
                              1
                              ;
                              3
                              ;
                              6
                              ;
                              4
                              ;
                              4
                              ;
                              8
                              ;
                              7
                              ;
                              8
                              ]
                           
                        
                      are two feasible SRK vectors associated with two schedules depicted in Figs. 6
                      and 7
                     . According to the due date set 
                        
                           d
                           d
                           =
                           [
                           2
                           ;
                           5
                           ;
                           5
                           ;
                           2
                           ;
                           4
                           ;
                           8
                           ;
                           10
                           ;
                           10
                           ;
                           12
                           ]
                           ,
                        
                      two bi-objective solutions 
                        
                           f
                           
                              (
                              
                                 x
                                 1
                              
                              )
                           
                           =
                           
                              (
                              19
                              ,
                              22
                              )
                           
                        
                      and 
                        
                           f
                           
                              (
                              
                                 x
                                 2
                              
                              )
                           
                           =
                           
                              (
                              15
                              ,
                              21
                              )
                           
                        
                      are able to be calculated using the objective functions presented in Section 3. The first objective is makespan and total tardiness value is the second objective. We assume that 22 and 15 are the worst and best values of makespan, and the worst and best values of total tardiness equal to 25 and 18, so that the charge 
                        
                           
                              q
                              12
                           
                           =
                           5
                           /
                           7
                           ≈
                           0.71
                        
                     . According to 
                        
                           
                              F
                              12
                           
                           =
                           
                              q
                              12
                           
                           
                              (
                              
                                 x
                                 2
                              
                              −
                              
                                 x
                                 1
                              
                              )
                           
                           ,
                        
                      force F
                     12 on x
                     1 can be calculated. In Table 2
                      (an adaptation of Debels et al. (2006)), the components of x
                     1 between [pmin
                     ; pmax
                     ] are bolded and we can obtain a new schedule 
                        
                           x
                           1
                           ′
                        
                      with 
                        
                           
                              x
                              1
                              ′
                           
                           =
                           
                              x
                              1
                           
                           +
                           
                              F
                              
                                 12
                              
                              ′
                           
                        
                      where 
                        
                           F
                           
                              12
                           
                           ′
                        
                      is represented as a vector and calculated by updating F
                     12 with substracting or adding a constant according to the hybrid two-point/EM crossover operator. Finally, 
                        
                           x
                           1
                           ′
                        
                      can be converted to its SRK form 
                        
                           x
                           1
                           
                              ′
                              ′
                           
                        
                      by using SGS. The schedule corresponded to 
                        
                           x
                           1
                           
                              ′
                              ′
                           
                        
                      is depicted in Fig. 8
                     , with 
                        
                           f
                           
                              (
                              
                                 x
                                 1
                                 
                                    ′
                                    ′
                                 
                              
                              )
                           
                           =
                           
                              (
                              18
                              ,
                              21
                              )
                           
                        
                     . This hybrid two-point/EM crossover operator on x
                     1 not only preserves the part of SRK vector larger than pmax
                      and lower than pmin
                      but also results in the middle part between pmin
                      and pmax
                      attracted by x
                     2. Meanwhile, we can reproduce another offspring that copies the lowest and highest priorities from x
                     2, with a middle part repelled by x
                     1.

The hybrid two point/EM crossover operator illustrated above will be used for generating offsprings instead of the traditional two-point crossover in the recombination steps of three MOEAs introduced in Section 6.

In this section we will introduce three multi-objective evolutionary algorithms which are applied to solve MORCPSP. On the other hand, we also demonstrate how to integrate EM heuristics with MOEAs in the pivotal steps. NSGA-II and SPEA2 are two most popular algorithms which have been widely used for many MOPs successfully and effectively. By combining mathematical programming with evolutionary algorithm, MOEA/D decomposes a multi-objective optimization problem into a number of scalar optimization subproblems and optimizes them simultaneously. It has been shown that MOEA/D receives a fairly good effect in continuous MOP and discrete MOP.

Firstly, the outline of the NSGA-II is as follows:

                           
                              
                                 Input: 
                                 N (population size)


                                 Output: 
                                 NS (non-dominated set)


                                 Step 1: Create an initial population P
                                 0 of size N and an empty population Q
                                 0. Set t=0 //initialization


                                 Step 2:
                                 
                                    
                                       
                                          R
                                          t
                                       
                                       =
                                       
                                          P
                                          t
                                       
                                       ⋃
                                       
                                          Q
                                          t
                                       
                                    
                                  //combine parent and children population


                                 Step 3:
                                 
                                    
                                       F
                                       =
                                    
                                  fast-non-dominated-sort(Rt
                                 ) // 
                                    
                                       F
                                       =
                                       (
                                       
                                          F
                                          1
                                       
                                       ,
                                       
                                          F
                                          2
                                       
                                       ,
                                       …
                                       )
                                    
                                  all non-dominated fronts of Rt
                                 
                              


                                 Step 4:
                                 
                                    
                                       
                                          P
                                          
                                             t
                                             +
                                             1
                                          
                                       
                                       =
                                       ∅
                                    
                                  and 
                                    
                                       i
                                       =
                                       1
                                    
                                 
                              

Until 
                                    
                                       
                                          P
                                          
                                             t
                                             +
                                             1
                                          
                                       
                                       <
                                       N
                                    
                                  //till the parent population is filled

crowding-distance-assignment (Fi
                                 ) //calculate crowding distance in Fi
                                 
                              


                                 
                                    
                                       
                                          P
                                          
                                             t
                                             +
                                             1
                                          
                                       
                                       =
                                       
                                          P
                                          
                                             t
                                             +
                                             1
                                          
                                       
                                       ⋃
                                       
                                          F
                                          i
                                       
                                    
                                  //include i-th non-dominated front in the parent pop


                                 Step 5: sort
                                    
                                       (
                                       
                                          P
                                          
                                             t
                                             +
                                             1
                                          
                                       
                                       ,
                                       
                                          ⪰
                                          n
                                       
                                       )
                                    
                                  //sort in descending order using ≽
                                    n
                                 )


                                 Step 6:
                                 
                                    
                                       
                                          P
                                          
                                             t
                                             +
                                             1
                                          
                                       
                                       =
                                       
                                          P
                                          
                                             t
                                             +
                                             1
                                          
                                       
                                       
                                          [
                                          0
                                          :
                                          N
                                          ]
                                       
                                    
                                  //choose the first N elements of 
                                    
                                       P
                                       
                                          t
                                          +
                                          1
                                       
                                    
                                 
                              


                                 Step 7: If stopping condition is satisfied, NS is set of the non-dominated solutions in 
                                    
                                       P
                                       
                                          t
                                          +
                                          1
                                       
                                    
                                 . Stop.


                                 Step 8:
                                 
                                    
                                       
                                          Q
                                          
                                             t
                                             +
                                             1
                                          
                                       
                                       =
                                    
                                  make-new-pop 
                                    
                                       (
                                       
                                          P
                                          
                                             t
                                             +
                                             1
                                          
                                       
                                       )
                                    
                                  //using selection, traditional crossover (or hybrid two-point/EM crossover) and mutation to create a new population 
                                    
                                       Q
                                       
                                          t
                                          +
                                          1
                                       
                                    
                                 
                              


                                 Step 9:
                                 
                                    
                                       t
                                       =
                                       t
                                       +
                                       1
                                    
                                 . Go to Step 2.

As another classical algorithm, the main frame of SPEA2 can be described as follows:

                           
                              
                                 Input: 
                                 N (population size) 
                                    
                                       N
                                       ¯
                                    
                                  (archive size)


                                 Output: 
                                 NS (non-dominated set)


                                 Step 1: Generate an initial population P
                                 0 and empty archive 
                                    
                                       
                                          p
                                          0
                                       
                                       ¯
                                    
                                 . Set t = 0; // initialization


                                 Step 2: Calculate fitness values of individuals in Pt
                                  and 
                                    
                                       
                                          P
                                          t
                                       
                                       ¯
                                    
                                 ; // fitness assignment


                                 Step 3: Copy all non-dominated individuals in Pt
                                  and 
                                    
                                       
                                          P
                                          t
                                       
                                       ¯
                                    
                                  to 
                                    
                                       
                                          P
                                          
                                             t
                                             +
                                             1
                                          
                                       
                                       ¯
                                    
                                 . If the size of 
                                    
                                       
                                          P
                                          
                                             t
                                             +
                                             1
                                          
                                       
                                       ¯
                                    
                                  exceeds 
                                    
                                       N
                                       ¯
                                    
                                  then reduce 
                                    
                                       
                                          P
                                          
                                             t
                                             +
                                             1
                                          
                                       
                                       ¯
                                    
                                  by truncation. Otherwise if the size of 
                                    
                                       
                                          P
                                          
                                             t
                                             +
                                             1
                                          
                                       
                                       ¯
                                    
                                  is less than 
                                    
                                       N
                                       ¯
                                    
                                  then fill 
                                    
                                       
                                          P
                                          
                                             t
                                             +
                                             1
                                          
                                       
                                       ¯
                                    
                                  with dominated individuals in Pt
                                  and 
                                    
                                       
                                          P
                                          t
                                       
                                       ¯
                                    
                                  // environmental selection


                                 Step 4: If stopping criterion is satisfied then set NS to the set of decision vectors represented by the non-dominated individuals in 
                                    
                                       
                                          P
                                          
                                             t
                                             +
                                             1
                                          
                                       
                                       ¯
                                    
                                 . Stop. // termination


                                 Step 5: Perform binary tournament selection with replacement on 
                                    
                                       
                                          P
                                          
                                             t
                                             +
                                             1
                                          
                                       
                                       ¯
                                    
                                  in order to fill the mating pool.// mating selection


                                 Step 6: Apply recombination and mutation operators to the mating pool and set 
                                    
                                       
                                          P
                                          
                                             t
                                             +
                                             1
                                          
                                       
                                       ¯
                                    
                                  to the resulting population. Increment generation counter 
                                    
                                       t
                                       =
                                       t
                                       +
                                       1
                                    
                                  and go to Step 2.//variation, we can apply hybrid two-point/EM crossover for recombination here

In SPEA2, each individual i in population Pt
                         and archive 
                           
                              
                                 P
                                 t
                              
                              ¯
                           
                         will be assigned a strength S(i) representing the number of solutions it dominates and a density estimation D(i) representing the distance to its nearest kth nearest data point. The fitness of individual i used for Step 3 to fill 
                           
                              
                                 P
                                 
                                    t
                                    +
                                    1
                                 
                              
                              ¯
                           
                         is the summation of strengths of solutions that dominates i, plus density estimation D(i). For the truncation operator, the k-th nearest distance is adopted: the individual which has the minimum distance to another individual is truncated at each stage; if there are several individuals with minimum distance, consider the second smallest distances and so forth. We apply hybrid two-point/EM algorithm to generate new solutions instead of the traditional two-point crossover in Step 6 when EM heuristics is integrated into SPEA2.

Unlike NSGA-II and SPEA2, MOEA/D does not treat a MOP as a whole. MOEA/D explicitly decomposes the MOP into N scalar optimization subproblems which can be solved simultaneously by evolving a population of solutions. Let 
                           
                              
                                 λ
                                 1
                              
                              ,
                              …
                              ,
                              
                                 λ
                                 N
                              
                           
                         be a set of uniform weight vector and z
                        * be the reference point. These parameters are used for defining the scalar functions of subproblems. With different decomposition approaches, the scalar functions are different. In MOEA/D, each weight vector λi
                         has a neighborhood consisted of its several closest weight vectors in 
                           
                              
                                 λ
                                 1
                              
                              ,
                              …
                              ,
                              
                                 λ
                                 N
                              
                           
                        . The neighborhood of weight vector λi
                         decides the neighborhood of ith subproblem. The neighborhood of each subproblem is used for generating new solutions. The population is composed of the best solution called current solution found so far for each subproblem. At each generation t, MOEA/D maintains a population of N solutions corresponding to N subproblems and 
                           
                              z
                              =
                              
                                 
                                    (
                                    
                                       z
                                       1
                                    
                                    ,
                                    …
                                    ,
                                    
                                       z
                                       m
                                    
                                    )
                                 
                                 T
                              
                           
                         (a set of the best value found so far for each objective). FV is the objective function value of a solution. In the same way, the hybrid two-point/EM crossover operator will be used for recombination if we apply EM heuristics for MOEA/D in the part of reproduction in Step 2.1. The algorithm works as follows:

                           
                              
                                 Input: 
                                 N the number of the subproblems considered in MOEA/D


                                 A uniform spread of N weight vector: 
                                    
                                       
                                          λ
                                          1
                                       
                                       ,
                                       …
                                       ,
                                       
                                          λ
                                          N
                                       
                                    
                                 ;


                                 T the number of the weight vectors in the neighborhood of each weight vector.


                                 Output: 
                                 EP
                              


                                 Step 1: Initialization.

                                    
                                       
                                          Step 1.1: Set 
                                             
                                                E
                                                P
                                                =
                                                ∅
                                             
                                          
                                       


                                          Step 1.2: Compute the Euclidean distance between any two weight vectors and then work out the T closest weight vectors to each weight vector. For each 
                                             
                                                i
                                                =
                                                1
                                                ,
                                                …
                                                ,
                                                N
                                                ,
                                             
                                           set 
                                             
                                                B
                                                
                                                   (
                                                   i
                                                   )
                                                
                                                =
                                                
                                                   
                                                      i
                                                      1
                                                   
                                                   ,
                                                   …
                                                   ,
                                                   
                                                      i
                                                      T
                                                   
                                                
                                                ,
                                             
                                           where 
                                             
                                                
                                                   λ
                                                   
                                                      i
                                                      1
                                                   
                                                
                                                ,
                                                …
                                                ,
                                                
                                                   λ
                                                   
                                                      i
                                                      T
                                                   
                                                
                                             
                                           are the closest weight vectors to λi
                                          .


                                          Step 1.3: Generate an initial population 
                                             
                                                
                                                   x
                                                   1
                                                
                                                ,
                                                …
                                                ,
                                                
                                                   x
                                                   N
                                                
                                             
                                           randomly. Set 
                                             
                                                F
                                                
                                                   V
                                                   i
                                                
                                                =
                                                F
                                                
                                                   (
                                                   
                                                      x
                                                      i
                                                   
                                                   )
                                                
                                             
                                          .


                                          Step 1.4: Initialize by a problem-specific method.


                                 Step 2: Update.

For 
                                    
                                       i
                                       =
                                       1
                                       ,
                                       …
                                       ,
                                       N
                                    
                                  do

                                    
                                       
                                          Step 2.1: Reproduction: Randomly select two indexes k, l from B(i), and then generate a new solution y from xk
                                           and xl
                                           by using recombination operators. // recombination operators include traditional crossover (or hybrid two-point/EM crossover) and mutation


                                          Step 2.2: Update of z: For each 
                                             
                                                j
                                                =
                                                1
                                                ,
                                                …
                                                ,
                                                m
                                                ,
                                             
                                           if zj
                                           < fj
                                          (y) then set 
                                             
                                                
                                                   z
                                                   j
                                                
                                                =
                                                
                                                   f
                                                   j
                                                
                                                
                                                   (
                                                   y
                                                   )
                                                
                                             
                                          .


                                          Step 2.3: Update of Neighboring Solutions: For each index j ∈ B(i), if y is better than xj
                                           for j-th subproblem, the set 
                                             
                                                
                                                   x
                                                   j
                                                
                                                =
                                                y
                                             
                                           and 
                                             
                                                F
                                                
                                                   V
                                                   j
                                                
                                                =
                                                F
                                                
                                                   (
                                                   y
                                                   )
                                                
                                             
                                          .


                                          Step 2.4: Update of EP: Remove from EP all the solutions dominated by F(y). Add F(y) to EP if no solution in EP dominates F(y).


                                 Step 3: If stopping criteria is satisfied, stop and output EP. Otherwise, go to Step 2.

We implement NSGA-II, SPEA2, MOEA/D and the EM integration versions of these three algorithms in C for Windows. The performance of these algorithms are compared and analyzed too. As test instances, we choose 160 instances from the standard j30,j60,j90,j120 set, each set contains 40 instances, introduced in Kolisch, Sprecher, and Drexl (1995) for the RCPSP and borrow the due date generated by Ballestín, Valls, and Quintanilla (2006, chap. 4) where the procedure to generate the due date in dataset is presented.

In our experiments, the following performance measures are adopted to evaluate the solution sets produced by different evolutionary algorithms.

                           
                              (i)
                              Set Coverage (C-Metric), which computes the percentage of solutions of one set dominated by solutions of another set. Let A and B be two sets of solutions. The set coverage is defined as:

                                    
                                       (7)
                                       
                                          
                                             C
                                             
                                                (
                                                A
                                                ,
                                                B
                                                )
                                             
                                             =
                                             
                                                
                                                   |
                                                   {
                                                   u
                                                   ∈
                                                   B
                                                   
                                                   |
                                                   
                                                   ∃
                                                   v
                                                   ∈
                                                   A
                                                   :
                                                   v
                                                   ≺
                                                   u
                                                   }
                                                   |
                                                
                                                
                                                   |
                                                   B
                                                   |
                                                
                                             
                                             ×
                                             100
                                             %
                                          
                                       
                                    
                                 The value 
                                    
                                       C
                                       (
                                       A
                                       ,
                                       B
                                       )
                                       =
                                       100
                                       %
                                    
                                  means that all solutions of B are dominated by solutions of A and 
                                    
                                       C
                                       (
                                       A
                                       ,
                                       B
                                       )
                                       =
                                       0
                                    
                                  implies no solution of B is dominated by solution of A. It is notable that C(A, B) is not necessarily equal to 
                                    
                                       100
                                       %
                                       −
                                       C
                                       (
                                       B
                                       ,
                                       A
                                       )
                                    
                                 .

Distance from the PF (D-Metirc) is a value representing how “far” an approximation set is from the Pareto front. Assuming P
                                 * be a set of uniformly distributed points along the PF. Let A be a set of solutions, the average distance from A to P
                                 * is defined as:

                                    
                                       (8)
                                       
                                          
                                             D
                                             
                                                (
                                                A
                                                ,
                                                
                                                   p
                                                   *
                                                
                                                )
                                             
                                             =
                                             
                                                
                                                   
                                                      ∀
                                                      
                                                         
                                                            v
                                                            ∈
                                                         
                                                         A
                                                      
                                                   
                                                   d
                                                   
                                                      (
                                                      v
                                                      ,
                                                      
                                                         p
                                                         *
                                                      
                                                      )
                                                   
                                                
                                                
                                                   |
                                                   A
                                                   |
                                                
                                             
                                          
                                       
                                    
                                 where d(v, p*) is the minimum Euclidean distance between v and the points in P
                                 *. If P
                                 * is large enough to represent the PF very well, set A must be very close to the PF when D(A, p
                                 *) is low enough. In our experiments, we do not know the actual PF. The non-dominated solutions obtained from all algorithms are used as the reference set P
                                 * for each instance. On the other hand, we incorporate a simple objective normalization technique into D-metric measure since the difference between two objectives is large in the MORCPSP. A simple normalization method is to replace objective 
                                    
                                       
                                          f
                                          i
                                       
                                       
                                          (
                                          i
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          m
                                          )
                                       
                                    
                                  by

                                    
                                       (9)
                                       
                                          
                                             
                                                
                                                   f
                                                   i
                                                
                                                ¯
                                             
                                             =
                                             
                                                
                                                   
                                                      f
                                                      i
                                                   
                                                   −
                                                   
                                                      z
                                                      i
                                                      
                                                         m
                                                         i
                                                         n
                                                      
                                                   
                                                
                                                
                                                   
                                                      z
                                                      i
                                                      
                                                         m
                                                         a
                                                         x
                                                      
                                                   
                                                   −
                                                   
                                                      z
                                                      i
                                                      
                                                         m
                                                         i
                                                         n
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 where 
                                    
                                       z
                                       i
                                       
                                          m
                                          a
                                          x
                                       
                                    
                                  and 
                                    
                                       z
                                       i
                                       
                                          m
                                          i
                                          n
                                       
                                    
                                  is the maximum and minimum value of i-th objective in reference set P
                                 *.

@&#RESULTS AND DISCUSSION@&#

In our experimental studies, for standard j30, j60, j90, j120 set, the number of iterations is 50, 75, 100, 125,the population size is 100, 200, 300, 400. φ
                           k
                         for every objectives in formula (6) is equal to 1.0. We use Tchebycheff approach and set neighborhood size T to 10 for MOEA/D. The mutation rate of 0.06 is considered for all algorithms. 10 runs are performed for each algorithm on each instance.


                        Table 3
                         presents the average mean of D-Metric values of the final solutions for each dataset compared to the original algorithms without EM. The better D-Metric values for each dataset are highlighted in bold. This table reveals that both NSGA-II_EM (NSGA-II integrated with EM heuristics) and SPEA2_EM (SPEA2 integrated with EM heuristics) obtain lower D-Metric values than original NSGA-II and SPEA2 for j120 dataset, and higher D-Metric values for j30,j60 datasets. MOEA/D_EM (MOEA/D integrated with EM heuristics) does not outperform MOEA/D for all datasets. In order to evaluate the convergence of all algorithms, Figs. 9
                         and 10
                         present the change of average D-Metric values along with the increasing number of schedules on some test instances. We find that MOEAs integrated with EM heuristics converges faster than their original versions in most j90,j120 cases. As the number of activities grows, NSGA-II_EM outperforms other algorithms.


                        Fig. 11
                         shows the potential non-dominated solutions obtained by 10 runs of each algorithm for the instances of dataset j120 in Fig. 10. RPF is the reference Pareto front set and it consists of all the solutions using the six algorithms studied in this paper for that instance for each run. From Fig. 10, we can observe that almost all solutions gained by NSGA-II are dominated by solutions founded by NSGA-II_EM. SPEA2_EM works out a majority of solutions which dominate the solutions obtained by SPEA2, but most of the solutions gained by MOEA/D and MOEA/D_EM are dominated by each other. It means that the EM heuristics cannot help to improve the performance of MOEA/D. Figs. 12
                         and 13
                         show that in terms of C-Metric, the final solutions obtained by NSGA-II are better than NSGA-II_EM in most j30,j60 cases, but in most j90,j120 cases, NSGA-II_EM is better. SPEA2_EM gets similar results but MOEA/D_EM cannot receive better performance than MOEA/D.

From the above experiments, integrating EM with NSGA_II and SPEA2 has a better performance in standard j120 set. Table 4
                         shows the running time and we can see that integrating EM does not bring computing burden. We also compare NSGA-II and SPEA2 with or without EM given the same running time. Table 5
                         shows the D-Metric values of dataset j120 with the same running time. Lower D-Metric is highlighted in bold. The results show that NSGA_II_EM is better than NSGA_II in most instances, while SPEA2_EM performs slightly better than SPEA2. Fig. 14
                         shows the C-Metric values. We can get the same conclusion as we discussed D-Metric values in Table 5.

From the experiment results showed above, obviously, in j90,j120 set, combing EM heuristics with NSGA-II and SPEA2 can receive performance improvement, especially for NSGA-II. NSGA-II_EM outperforms NSGA-II in terms of solution quality and convergence, so does SPEA2_EM. Comparing with MOEA/D, MOEA/D_EM does not have a better effect. The reason why EM plays different roles in these three algorithms is derived from the different individual selection strategy for crossover operator. In Step 8 of NSGA-II, the whole population is used for selection and crossover. For SPEA2, the mating pool used for recombination and mutation is constructed with the individuals selected from the archive population. According to the principle of EM, the larger the difference between two individuals used for crossover is, the more obvious the effect is. Because EM will guide the search direction in terms of the objective values, EM can hardly work when the two individuals used for crossover have similar objective values. In NSGA-II, all individuals in population take part in crossover operator, so the diversity and differences in individuals can be guaranteed for EM. SPEA2 only selects individuals from archive population for crossover, so EM heuristics integrated into SPEA2 cannot work as well as in NSGA-II due to the fact that individuals in archive are elitist and the similarities among them reduce the effectiveness of the EM heuristics. Nevertheless, the approach to generate new solutions in MOEA/D is quite different from NSGA-II and SPEA2. In Step 2.1 of MOEA/D, a new solution is generated from two neighbors which are similar by using crossover and mutation operator. Furthermore, updating the neighborhood with this new solution will make the neighbor individuals more similar in Step 2.3. So it may be the important reason why EM could not improve the performance of MOEA/D. To sum up, NSGA-II_EM is probably the most effective algorithm for MORCPSP among the algorithms we studied.

@&#CONCLUSIONS@&#

In this paper, we have studied if the electromagnetism (EM) heuristic procedure could be integrated into multi-objective evolutionary algorithms (MOEAs) for the multi-objective resource-constrained project scheduling problem (MORCPSP), one of the most challenging combinatorial optimization problems in scheduling. Not only the approach of extending EM heuristics to multi-objective optimization but also how to combine it with MOEAs framework for MORCPSP have been introduced. We have conducted experiments on integrating EM heuristics with three state-of-the-art MOEAs including NSGA-II, SPEA2 and MOEA/D, and compared with their corresponding original versions for 160 standard test instances. The computational results show that integrating EM heuristics with NSGA-II and SPEA2, especially for NSGA-II, could improve various aspects of performance, and it may not suitable to combine EM with MOEA/D. We also give a brief explanation that why EM plays different roles in these three algorithms. Finally , we can get a conclusion that NSGA-II integrated with EM heuristics may be the most effective algorithm for MORCPSP among the algorithms we studied. The further research will consist of doing research on the other objectives mentioned in this paper and developing exact algorithms capable of calculating the real Pareto front for MORCPSP.

@&#ACKNOWLEDGMENTS@&#

We would like to thank the anonymous reviewers to improve the quality of this paper. This work was partially supported by the National Natural Science Foundation of China (NSFC) Projects nos. 61202296, 71102146 and 61272067, the National High-Technology Research and Development Program (“863” Program) of China under Grant no. 2013AA01A212, the Natural Science Foundation of Guangdong Province Project no. S2012030006242.

@&#REFERENCES@&#

