@&#MAIN-TITLE@&#Recognizing lexical and semantic change patterns in evolving life science ontologies to inform mapping adaptation

@&#HIGHLIGHTS@&#


               
                  
                  
                     
                        
                           
                           Algorithms identifying lexical and semantic change patterns in ontology evolution.


                        
                        
                           
                           The relevance of the change patterns to support mapping adaptation.


                        
                        
                           
                           The influence of the similarity calculated on the performance of the algorithms.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Biomedical ontologies

Ontology evolution

Ontology versions

Ontology changes

Mapping evolution

Mapping adaptation

Mapping maintenance

@&#ABSTRACT@&#


               
               
                  Background
                  Mappings established between life science ontologies require significant efforts to maintain them up to date due to the size and frequent evolution of these ontologies. In consequence, automatic methods for applying modifications on mappings are highly demanded. The accuracy of such methods relies on the available description about the evolution of ontologies, especially regarding concepts involved in mappings. However, from one ontology version to another, a further understanding of ontology changes relevant for supporting mapping adaptation is typically lacking.
               
               
                  Methods
                  This research work defines a set of change patterns at the level of concept attributes, and proposes original methods to automatically recognize instances of these patterns based on the similarity between attributes denoting the evolving concepts. This investigation evaluates the benefits of the proposed methods and the influence of the recognized change patterns to select the strategies for mapping adaptation.
               
               
                  Results
                  The summary of the findings is as follows: (1) the Precision (>60%) and Recall (>35%) achieved by comparing manually identified change patterns with the automatic ones; (2) a set of potential impact of recognized change patterns on the way mappings is adapted. We found that the detected correlations cover ∼66% of the mapping adaptation actions with a positive impact; and (3) the influence of the similarity coefficient calculated between concept attributes on the performance of the recognition algorithms.
               
               
                  Conclusions
                  The experimental evaluations conducted with real life science ontologies showed the effectiveness of our approach to accurately characterize ontology evolution at the level of concept attributes. This investigation confirmed the relevance of the proposed change patterns to support decisions on mapping adaptation.
               
            

@&#INTRODUCTION@&#

Mappings interconnect entities of domain-related ontologies through semantic relations [1]. They play a key role for enabling the interoperability between information systems, allowing software applications to semantically interpret annotated data using different ontologies [2]. In particular, recent work has explored the definition of mappings between medical terminologies for healthcare interoperability reasons [3]. This demands that mappings remain up to date despite the continuous evolution of ontologies. Besides errors at ontology alignment time, changes affecting ontology entities are one of the main reasons for invalidating mappings [4].

This leads to the mapping adaptation problem, referring to the way existing mappings are modified according to changes affecting ontology entities, to keep them semantically valid and complete over time [5,6]. Mapping adaptation remains challenging for many reasons. While knowledge engineers can manually accomplish this complex task on small ontologies, those of some specific domains, e.g., the biomedical domain, require automatic software applications by virtue of their volume, the dynamic nature and the significant quantity of mappings impacted by ontology evolution [4]. Although sophisticated ontology changes can be discovered by modern tools (e.g., OBO-Edit [7], OBO2OWL [8], Conto-Diff 
                     [9]), it is still difficult to exploit them for the adaptation of mappings impacted by ontology evolution. The reason for this is a lack of adequate characterization of ontology evolution that would be suitable for supporting mapping adaptation. Indeed, we have demonstrated that even if concepts are interrelated in their entirety via mappings, only some partial information about concepts (e.g., a set of most significant attributes) is useful for defining mappings [10,11]. In consequence, better describe the evolution of specific ontological entities will serve to inform the mapping adaptation task more effectively.

An example of a real situation observed in our studies refers to the transfer of information between concepts. We found cases where textual statements, which consist in values of attributes describing concepts, are completely transferred from one concept to sibling concepts. This has affected the associated mappings, since their definition relies on such textual information. We observed this case with the concept “560.39” of the ICD-9-CM
                        1
                     
                     
                        1
                        
                           http://www.cdc.gov/nchs/icd/icd9cm.htm (accessed 26.11.14).
                      (ICD for short). Such concept contains three attributes and one of them has as value “Fecal impaction” (release 2009). Five mappings are defined having this concept as domain, and one of these mappings has a range called “Fecal impaction (disorder)”, in SNOMED CT
                        2
                     
                     
                        2
                        
                           http://www.ihtsdo.org/snomed-ct (accessed 26.11.14).
                      (SCT for short). After evolution (i.e., ICD release 2010), the attribute value “Fecal impaction” is no longer associated with the ICD concept 560.39 and the previously mentioned mapping has been removed. Moreover, the concept “Fecal impaction” has been newly created in ICD (release 2010) and is reconnected to “Fecal impaction (disorder)” of SCT. The example clearly highlights the need of methods for the characterization of the evolution of ontology concepts, by analysing changes in the attributes values to use this information to adapt invalid mappings.

Although significant research efforts have dealt with issues related to ontology evolution, understanding how this evolution affects dependent artefacts, such as mappings, has received very little attention [6]. Recent research work on ontology evolution mainly concerns internal logical inconsistencies of an ontology [12]. Even though existing researches investigate the evolution of specific life science ontologies like SCT [13,14], they fail to address the impact of the evolution on established mappings. For instance, Gonçalves et al. [13] analyze the changes between two ontology versions and use SCT to show the applicability of their approach. Spackman [14] investigates rates of change in large clinical terminologies using SCT as an object of study, although mappings are not taken into consideration. Groß et al. [15] study how mappings in life sciences ontologies change. They empirically analyze which ontology changes can lead to an addition or deletion of correspondences between concepts. Using a computed dataset of mappings, the study demonstrates how ontology changes can impact mapping changes, and the ratio of changes in mappings according to three general categories of ontology changes. The findings of the aforementioned studies have motivated a new study to gain a more in-depth understanding of how a more fine-grained classification of ontology changes would affect mapping adaptation, considering also real-world sets of mappings in the experiments.

In this article, we propose a formal definition of ontological change patterns that are relevant for supporting the automatic mapping adaptation. More specifically, the objectives are two-fold:
                        
                           •
                           We introduce a novel approach to automatically recognize instances of the proposed ontology change patterns by comparing successive ontology versions. This research examines whether techniques based on linguistic characteristics of attribute values combined with similarity measures play a role in supporting change pattern identification at the level of concepts’ attributes.

We experimentally assess the outcomes of the proposed methods and their ability to support mapping adaptation on realistic case studies using real mappings between large life science ontologies. We specifically explore, through our experiments, whether identified change patterns may influence different mapping adaptation actions.

We organize the remainder of this article as follows: Section 2 introduces the notations used throughout the article as well as the research problem. Section 3 presents the related work on change pattern identification and gives an overview of our original contributions. Section 4 reports on our approach to recognize lexical and semantic change patterns. Section 5 describes our experimental objectives and used materials. Sections 6–8 present the obtained results. We then discuss several aspects of our change pattern recognition approach in Section 9, prior to concluding this article and outlining directions for future work.

@&#BACKGROUND@&#

We introduce the notations and definitions used in this article (Section 2.1) and describe the research problem (Section 2.2).

We present the notations used in this article in Table 1
                        .


                        Ontology. An ontology O explicitly specifies a conceptualization [16]. More specifically, it describes a conceptualization of a domain by means of concepts, attributes and relationships. The definition adopted in this article considers an ontology O as a set of concepts interrelated by various relationships, e.g., “is-a”, “part-of”, “related-to”. The set of concepts of an ontology is defined as C(O
                        
                           x
                        )={c
                        1, c
                        2, …, c
                        
                           n
                        }. Each concept, characterized by a set of attributes, has a unique identifier and a set of relationships with other concepts of the same ontology. Given a concept c
                        
                           k
                         in ontology O
                        
                           x
                        , we denote 
                           
                              O
                              x
                              j
                           
                         as ontology O
                        
                           x
                         at time 
                           j
                           ∈
                           
                              
                                 ℕ
                              
                           
                         and thus 
                           
                              c
                              k
                              j
                           
                           ∈
                           C
                           (
                           
                              O
                              x
                              j
                           
                           )
                        .

We define the set of attributes defining a concept c as A(c)={a
                        1, a
                        2, …, a
                        
                           n
                        } (e.g., name, definition, synonym, etc.). The attributes can differ from one ontology to another, but in general an attribute describing a concept has a name and an associated value, e.g., “name:cardio_vascular_diseases”. Each attribute has particular semantics. For instance, the attribute “name” is used for denoting concept labels or the attribute “definition” is used for giving the meaning of a concept in a particular context. In some situations, we can have equivalent attributes in terms of meanings, e.g., attribute “name:hypotension” is equivalent to “synonym:low_blood_pressure” because they are used to denote the same concept. To simplify, from now on we will use a
                        
                           i
                         to denote a
                        
                           i
                        
                        .
                        value. Two attributes a
                        
                           i
                         and a
                        
                           h
                         are considered as totally “equivalent”, denoted as a
                        
                           i
                        
                        =
                        a
                        
                           h
                        , if and only if they satisfy the following conditions:


                        
                           
                              (1)
                              
                                 
                                    
                                       a
                                       i
                                    
                                    =
                                    
                                       a
                                       h
                                    
                                    ⇔
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      ∀
                                                      
                                                         w
                                                         
                                                            k
                                                            i
                                                         
                                                      
                                                      ∈
                                                      W
                                                      (
                                                      
                                                         a
                                                         i
                                                      
                                                      )
                                                      ,
                                                      
                                                         w
                                                         
                                                            k
                                                            i
                                                         
                                                      
                                                      ∈
                                                      W
                                                      (
                                                      
                                                         a
                                                         h
                                                      
                                                      )
                                                      ∧
                                                      O
                                                      r
                                                      d
                                                      (
                                                      
                                                         w
                                                         
                                                            k
                                                            i
                                                         
                                                      
                                                      )
                                                      =
                                                      O
                                                      r
                                                      d
                                                      (
                                                      
                                                         w
                                                         
                                                            k
                                                            h
                                                         
                                                      
                                                      )
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      ∀
                                                      
                                                         w
                                                         
                                                            k
                                                            h
                                                         
                                                      
                                                      ∈
                                                      W
                                                      (
                                                      
                                                         a
                                                         h
                                                      
                                                      )
                                                      ,
                                                      
                                                         w
                                                         
                                                            k
                                                            h
                                                         
                                                      
                                                      ∈
                                                      W
                                                      (
                                                      
                                                         a
                                                         i
                                                      
                                                      )
                                                      ∧
                                                      O
                                                      r
                                                      d
                                                      (
                                                      
                                                         w
                                                         
                                                            k
                                                            h
                                                         
                                                      
                                                      )
                                                      =
                                                      O
                                                      r
                                                      d
                                                      (
                                                      
                                                         w
                                                         
                                                            k
                                                            i
                                                         
                                                      
                                                      )
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

Eq. (1) expresses that two given attributes are only considered totally equivalent if they contain exactly the same words in the same order. Otherwise, the attributes are different, denoted as a
                        
                           i
                        
                        ≠
                        a
                        
                           h
                        .

Similarly, we define the set of relationships of concept c as R(c)={r
                        1, r
                        2, …, r
                        
                           m
                        }. Each relationship r
                        
                           i
                        
                        ∈
                        R(c
                        
                           k
                        ) is typically a couple r
                        
                           i
                        
                        =(type, c
                        
                           h
                        ), where type denotes the relationship symbol (e.g., “is-a”, “part-of”, “adviced-by”, etc.) used to interconnect the concept c
                        
                           k
                         to the concept c
                        
                           h
                        .


                        Context. The context of a concept c
                        
                           a
                         in the ontology stands for a set of super concepts, sub concepts and sibling concepts, as follows:


                        
                           
                              (2)
                              
                                 CT
                                 (
                                 
                                    c
                                    a
                                 
                                 )
                                 =
                                 sup
                                 (
                                 
                                    c
                                    a
                                 
                                 )
                                 ∪
                                 sub
                                 (
                                 
                                    c
                                    a
                                 
                                 )
                                 ∪
                                 sib
                                 (
                                 
                                    c
                                    a
                                 
                                 )
                              
                           
                        
                     

where
                           
                              (3)
                              
                                 
                                    
                                       
                                          sup
                                          (
                                          
                                             c
                                             a
                                          
                                          )
                                       
                                       
                                          =
                                       
                                       
                                          {
                                          
                                             c
                                             b
                                          
                                          |
                                          
                                             c
                                             b
                                          
                                          ∈
                                          C
                                          (
                                          
                                             O
                                             x
                                          
                                          )
                                          ,
                                          
                                             c
                                             a
                                          
                                          ⊏
                                          
                                             c
                                             b
                                          
                                          ∧
                                          
                                             c
                                             a
                                          
                                          ≠
                                          
                                             c
                                             b
                                          
                                          }
                                       
                                    
                                    
                                       
                                          sub
                                          (
                                          
                                             c
                                             a
                                          
                                          )
                                       
                                       
                                          =
                                       
                                       
                                          {
                                          
                                             c
                                             b
                                          
                                          |
                                          
                                             c
                                             b
                                          
                                          ∈
                                          C
                                          (
                                          
                                             O
                                             x
                                          
                                          )
                                          ,
                                          
                                             c
                                             b
                                          
                                          ⊏
                                          
                                             c
                                             a
                                          
                                          ∧
                                          
                                             c
                                             a
                                          
                                          ≠
                                          
                                             c
                                             b
                                          
                                          }
                                       
                                    
                                    
                                       
                                          sib
                                          (
                                          
                                             c
                                             a
                                          
                                          )
                                       
                                       
                                          =
                                       
                                       
                                          {
                                          
                                             c
                                             b
                                          
                                          |
                                          
                                             c
                                             b
                                          
                                          ∈
                                          C
                                          (
                                          
                                             O
                                             x
                                          
                                          )
                                          ,
                                          sup
                                          (
                                          
                                             c
                                             b
                                          
                                          )
                                          ∩
                                          sup
                                          (
                                          
                                             c
                                             a
                                          
                                          )
                                          ≠
                                          ∅
                                          ∧
                                          
                                             c
                                             a
                                          
                                          ∉
                                          sup
                                          (
                                          
                                             c
                                             b
                                          
                                          )
                                          }
                                       
                                    
                                    
                                       
                                       
                                       
                                    
                                 
                              
                           
                        
                     

where c
                        
                           a
                        
                        ⊏
                        c
                        
                           b
                         means that “c
                        
                           a
                         is a sub concept of c
                        
                           b
                        ”. We define the context of a particular concept c
                        
                           a
                         (cf. Eq. (3)), denoted as CT(c
                        
                           a
                        ), as the set of concepts in the neighborhood of c
                        
                           a
                        , i.e., direct parents, direct children and sibling concepts. This excludes concepts linked to c
                        
                           a
                         by other relationships than “is-a” relationship. Indeed, in our previous investigation on mapping evolution [4], we pointed out that concepts outside the context have a very low impact on mapping evolution and are thus less relevant for this study.


                        Mapping. We define a mapping m
                        
                           st
                        , established at time j, between two given concepts c
                        
                           s
                         and c
                        
                           t
                         from two different ontologies as:


                        
                           
                              (4)
                              
                                 
                                    m
                                    st
                                    j
                                 
                                 =
                                 (
                                 
                                    c
                                    s
                                    j
                                 
                                 ,
                                 
                                    c
                                    t
                                    j
                                 
                                 ,
                                 
                                    semType
                                    st
                                    j
                                 
                                 ,
                                 
                                    conf
                                    j
                                 
                                 ,
                                 
                                    status
                                    j
                                 
                                 )
                              
                           
                        where 
                           
                              semType
                              st
                              j
                           
                         concerns the semantic relation connecting c
                        
                           s
                         and c
                        
                           t
                        . In this article, we differentiate relation from relationship by considering that the former belongs to a mapping while the latter belongs to an ontology. The following types of semantic relations are considered: unmappable [⊥], equivalent [≡], narrow-to-broad [≤], broad-to-narrow [≥] and overlapped [≈]. The conf
                        
                           τ
                         argument represents the similarity value between c
                        
                           s
                         and c
                        
                           t
                         indicating the confidence of their relation [1]. The status
                        
                           j
                         argument is useful for describing the state of a mapping during the adaptation process (e.g., ‘valid’, ‘invalid’, ‘inactive’, etc.). We define 
                           
                              M
                              ST
                              j
                           
                           =
                           {
                           
                              
                                 (
                                 
                                    m
                                    st
                                    j
                                 
                                 )
                              
                              i
                           
                           |
                           i
                           ∈
                           
                              
                                 ℕ
                              
                           
                           }
                         as the set of different mappings at time j between ontology 
                           
                              O
                              S
                              j
                           
                         and 
                           
                              O
                              T
                              j
                           
                        .

The final objective of our research deals with mapping adaptation. Assuming two versions of the same source ontology, namely 
                           
                              O
                              S
                              0
                           
                         at time j and 
                           
                              O
                              S
                              1
                           
                         at time j
                        +1, one target ontology 
                           
                              O
                              T
                              0
                           
                        , and an initial set of valid mappings 
                           
                              M
                              ST
                              0
                           
                         between 
                           
                              O
                              S
                              0
                           
                         and 
                           
                              O
                              T
                              0
                           
                         at time j, supposing that the frequency of new releases of O
                        
                           S
                         and O
                        
                           T
                         differs and at time j
                        +1 only O
                        
                           S
                         evolves, mapping adaptation consists in applying the necessary actions to 
                           
                              M
                              ST
                              0
                           
                         in order to guarantee that the mapping remains valid, generating 
                           
                              M
                              ST
                              1
                           
                        . Considering the components of a mapping, an adaptation action aims at changing 
                           
                              c
                              s
                              j
                           
                         and/or 
                           
                              semType
                              st
                              j
                           
                         so the new definition of 
                           
                              m
                              st
                              
                                 j
                                 +
                                 1
                              
                           
                         is valid from the semantic point of view.

As depicted in Fig. 1
                        , the mapping adaptation process is composed of several steps motivated by our experimental observations [4,10]. In particular, this article focuses on the characterization of ontology evolution by analysing changes affecting concept attributes. This is accomplished through the design of a set of change patterns and algorithms able to instantiate those with the analysis of 
                           
                              Diff
                              S
                              
                                 j
                                 ,
                                 j
                                 +
                                 1
                              
                           
                        .

Given an attribute a
                        
                           i
                         from a concept c at time j, we investigate a way to characterize how such attribute evolves by considering the context of the concept c
                        1 at time j
                        +1 (i.e., in the new version of ontology O
                        
                           x
                        ). The evolution of ontology entities usually remains restricted in an ontology space like the context [4]. We focus on a
                        
                           i
                        
                        .
                        value to identify useful behaviours of evolution concerning the attributes, and search for describing these behaviours as well-delineated change patterns. We face issues to determine which attribute at time j
                        +1 represents the most adequate candidate in the recognition process to identify occurrences of change patterns. We apply syntactic analysis techniques to recognize textual values of attributes in different versions of the same ontology.

The task of change pattern identification deals with the classification of changes that may affect entities of ontologies at evolution time [17]. This task aims to characterize basic and complex changes in order to handle the ontology evolution, which can be interpreted as the process of adaptation of an ontology to changes appearing in the corresponding domain, while maintaining both the consistency of the ontology itself as well as the consistency of depending artefacts [18]. Change patterns have been explored to characterize complex changes and evolution scenarios, simplifying the management of ontologies to control the impact of the evolution and to ensure consistency in ontology [19].

Change patterns can provide a way of determining what information to analyze, or the necessary constraints in order to identify a specific (complex) change. Castano et al. [20] define change patterns as the capability of classifying the different situations which trigger ontology evolution by characterizing the results of the semantic interpretation process. According to them, change patterns also consist in a (formal) definition of an appropriate activity to correctly modify the ontology in each specific evolution situation. Two types of patterns have been introduced: (i) to populate the ontology and (ii) to enrich the ontology when concepts are missing. These patterns cannot be applied on some domain-specific ontologies because (i) in their approach, there is no instance in the considered ontologies and (ii) only enrichment is possible but deletion and merge of concepts are not supported.

Change patterns may allow identifying complex changes between different versions of the same ontology. Groner et al. [21] address the problem of refactoring recognition using reasoning to semantically compare different versions of an web ontology language (OWL) DL ontology. To do so, they propose a high-level categorization of ontology changes like the refactoring patterns in software engineering, and applying this to OWL ontology. A refactoring pattern refers to an abstract description of an ontology change to drive the reconstruction as part of the ontology [21]. Groner et al. apply a semantic comparison using heuristic algorithms to recognize such patterns between ontology versions. On the other hand, Hartung et al. [22] have proposed the COnto-Diff tool approach to automatically identify the difference (diff) between ontology versions. They specify change patterns using the dedicated change operation generating rules (COG) to reach a more compact and semantically more expressive diff representation, capturing complex ontology changes such as merging, splitting and moving of concepts or adding and deleting entire subgraphs. According to the authors, the rule-based approach supports an easy extension of the COnto-Diff to identify additional types of changes, but it seems that the complexity of the rules tends to increase, making it hard to define a specific order to apply them.

Some approaches define change patterns at the level of resource description framework (RDF) data model. Auer and Herre [23] propose to support ontology evolution by using basic changes and aggregate them into more complex changes in RDF. Their approach consists in annotating the derived compound changes with meta-information and classifying them as ontology evolution patterns to facilitate ontology evolution. This work classifies change operations on OWL ontologies according to specific patterns reflecting common change intentions. The provided patterns are suited to specify whether a label value of a concept or an attribute changes, but they fail to precisely characterize the nature of the change, which is relevant for mapping adaptation. For instance, a concept can be labeled “kappa light chain disease” before evolution and “kappa chain disease” after evolution. This corresponds to a generalization of the concept and needs to be explicitly recognized to be exploitable.

Rieß et al. [24] proposed a pattern-based approach to data evolution and refactoring RDF knowledge bases. Their approach defines basic evolution patterns that can be combined into compound ones. Their work formally specifies modular evolution patterns in a declarative manner, capturing simple evolution and refactoring operations on both data and schema levels. The authors use RDF vocabulary for representing evolution patterns, and expressing pattern behaviours in the form of SPARQL queries. Although interesting, these patterns are strictly dependent on the implemented technology, and can thus only be applied for RDF triples.

Djedidi and Aufaure define an ontology evolution methodology driven by a pattern-oriented modeling. They propose the change management patterns to guide the ontology evolution process by driving and controlling change applications while maintaining the consistency of the evolving ontology [25,26]. They define four kinds of consistency concerning the OWL DL language: structural, logical, conceptual and domain modeling consistency [26]. The solution looks for invariances in change management that repeatedly appear when ontologies evolve. They propose three types of patterns: change patterns classifying types of changes, inconsistency patterns classifying types of logical inconsistencies, and alternative patterns classifying types of inconsistency resolution alternatives [25]. According to the authors, pattern-centered modeling aims to offer, for each of the three dimensions (change, inconsistency and resolution alternative) different levels of abstraction and to establish links between them [26]. They formally define the patterns using OWL DL change operations. Designed for OWL ontologies and following their assumptions, these patterns can hardly be applicable to ontologies expressed in other formats like open biomedical ontologies (OBO) for instance or for ontologies simply represented in databases.

Javed et al. suggest an approach to deal with ontology evolution through a framework of compositional operators representing domain changes as patterns [27]. They compose this framework with different levels of change operators, and empirically study ontology evolution to investigate the relationships between generic and domain-specific changes to determine common change patterns. The authors identify four levels of change operators and patterns based on the granularity of changes. This approach considers domain-specific change patterns as more general operations than complex changes. Javed et al. observe that ontology changes are driven by certain types of common, often frequent changes in the application domain, and argue that change patterns rely on the viewpoints and activities of the users. Their approach allows ontology engineers to define their own change patterns which can be executed many times.

The provided literature review clearly highlights that, although existing techniques somehow perform efficiently for characterizing ontology evolution, they lack important aspects with respect to the mapping adaptation problem:
                        
                           1.
                           Although useful tools exist to identify the most traditional and frequent ontology changes between different ontology versions [9,28], taking into account the nature of changes (e.g., atomic or complex) and the type of changes (e.g., addition, removal, splitting, merging of entities), these tools fail to automatically identify ontology modifications at a finer level of detail required for automatic mapping adaptation as underlined in our previous studies [4,10]. In other words, these tools are working at concept level and not at attribute level. We have pointed out the need to precisely characterize the evolution of the conceptual information (especially attributes denoting concepts) for maintaining mappings valid over time. Even if the work of Travillian et al. [29] tackles the attribute level, it fails to clearly characterize (from the semantic point of view) the differences that exist between concept attributes of sucessive ontology versions.

Existing change pattern identification methods fail to clearly show the evidence of ontology changes for mapping adaptation. In fact, ontology modifications that impact mappings must enable to specify more adequately the evolution of each entity describing a concept (e.g., attributes) to remain useful for maintaining mappings valid over time. Even though literature has proposed change patterns in an attempt to improve the characterization of ontology changes, it requires in-depth studies to evaluate the adequateness and usefulness for mapping adaptation. Therefore, we need to further investigate which types of change patterns might concretely help to inform techniques of mapping adaptation and how to correctly apply them. Existing methods for change patterns definition seem insufficient as their design fails to consider requirements for adapting mappings. They were conceptualized taking ontologies in an isolated way.

Our empirical studies have shown a need to characterize the evolution of concepts from the semantic point of view. This means to determine, from one ontology version to another, if a concept becomes more or less specific. This requires performing a comparison between different ontology versions. To this end, approaches aiming at aligning concepts via the subsumption relationships ([≤] or [≥]) deserve our attention because the discovery of these relationships can be particularly relevant in helping to calculate advanced change operations between ontology versions, with evolutionary mappings between ontology versions which characterize the semantic evolution of concepts. However, very few investigations appear in literature with this purpose [30–32]. In addition to the lack of conclusive work, existing approaches are only tailored to ontology alignment purposes. Nevertheless, from an ontology evolution perspective, we must reconsider design choices to handle the specificities of our investigated scenario of biomedical ontology evolution and mappings adaptation.

The main contribution of this work relies on the following key points:
                        
                           1.
                           We propose two novel algorithms for identifying lexical and semantic change patterns by exploiting linguistic characteristics of attributes denoting concepts under evolving ontologies. We measure their effectiveness by comparing the obtained results to a reference dataset.

We conduct a series of experiments to evaluate the relevance and the impact of the different types of change patterns proposed to support mapping adaptation solutions.

We study the distribution of similarity values used for identifying change patterns in order to understand the effects of the similarity in the recognition of correct change pattern instances for mapping adaptation.

To the best of our knowledge, there is no work investigating change patterns for supporting mapping adaptation, even though some efforts have been made for handle ontology evolution, which attests the originality of our first contribution. Motivated by related work on change pattern identification, we studied several linguistic characteristics related to changed attributes to better understand the evolution of ontologies, and especially the associated mappings impacted by changes in the involved concepts. This article proposes two different types of change patterns namely lexical and semantic change patterns. The difference refers to the fact that the former is mainly based on exploiting the lexical content (determine the diffusion of concept attribute values between concepts in different ontology versions), while the latter is mainly based on exploiting the semantic of the attribute value relying also on the structure of the ontologies (how attribute values become more or less semantically specific).

Our second and third contributions concern the evaluation of the relevance of the change patterns for decision support of actions suited to adapt mappings. We attempt to integrate several factors related to the similarity between changed attributes that we deem relevant for handling mapping adaptation under evolving ontologies. Unlike existing approaches, we aim to originally demonstrate that the lexical and semantic change patterns are relevant for addressing the mapping adaptation problem. Indeed, through the experiments, we aim to show that the change patterns can be taken into account for guiding the process of selecting the appropriate mapping adaptation actions.

Considering change patterns (CPs) as means to deal with ontology entity changes, we focus on change patterns related to concept attribute values. We distinguish two independent types of change patterns, namely lexical and semantic. While the former relates to the linguistic characteristics of the content value of attributes before and after their evolution, the latter concerns their semantics. Given a concept c
                        
                           k
                         in ontology O
                        
                           x
                        , we define a change pattern between an attribute 
                           
                              a
                              p
                              0
                           
                         of concept 
                           
                              c
                              k
                              0
                           
                           ∈
                           C
                           (
                           
                              O
                              x
                              0
                           
                           )
                         and an attribute 
                           
                              a
                              q
                              1
                           
                         of concept 
                           
                              c
                              cand
                              1
                           
                           ∈
                           C
                           (
                           
                              O
                              x
                              1
                           
                           )
                         (k
                        ≠
                        cand), such that 
                           
                              c
                              cand
                              1
                           
                           ∈
                           CT
                           (
                           
                              c
                              k
                              1
                           
                           )
                        . In addition, we suppose that any change pattern must satisfy the constraint 5, which states that the attribute a
                        
                           q
                         is new or its value differs at time j
                        +1.
                           
                              (5)
                              
                                 
                                    a
                                    q
                                    0
                                 
                                 ∉
                                 A
                                 (
                                 
                                    c
                                    cand
                                    0
                                 
                                 )
                                 ∨
                                 
                                    a
                                    q
                                    0
                                 
                                 ≠
                                 
                                    a
                                    q
                                    1
                                 
                              
                           
                        
                     


                        Candidate attribute in the context. To recognize lexical and semantic CPs we first determine the candidate attribute 
                           
                              a
                              q
                              1
                           
                         in the context. To this end, we designed Algorithm 1 which explores attributes from the source and target concepts of mappings.


                        
                           Algorithm 1
                           Find candidate attribute in context


                              
                                 
                                    
                                       
                                       
                                          
                                             
                                                Require: 
                                                   
                                                      a
                                                      p
                                                      0
                                                   
                                                   ∈
                                                   A
                                                   (
                                                   
                                                      c
                                                      k
                                                      0
                                                   
                                                   )
                                                   ;
                                                   CT
                                                   (
                                                   
                                                      c
                                                      k
                                                      1
                                                   
                                                   )
                                                   ⊂
                                                   C
                                                   (
                                                   
                                                      O
                                                      S
                                                      1
                                                   
                                                   )
                                                   ;
                                                   
                                                      a
                                                      t
                                                      0
                                                   
                                                   ∈
                                                   A
                                                   (
                                                   
                                                      c
                                                      t
                                                      0
                                                   
                                                   )
                                                   ∈
                                                   
                                                      O
                                                      T
                                                      0
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                   maxSim
                                                   ←
                                                   0
                                                   ;
                                                   
                                                      a
                                                      q
                                                      1
                                                   
                                                   ←
                                                   ∅
                                                   ;
                                                   
                                                      c
                                                      cand
                                                      1
                                                   
                                                   ←
                                                   ∅
                                                   ;
                                                   
                                                      s
                                                      highest
                                                   
                                                   ←
                                                   0
                                                   ;
                                                
                                             
                                          
                                          
                                             
                                                
                                                for all 
                                                
                                                   
                                                      c
                                                      i
                                                      1
                                                   
                                                   ∈
                                                   CT
                                                   (
                                                   
                                                      c
                                                      k
                                                      1
                                                   
                                                   )
                                                 
                                                do
                                             
                                          
                                          
                                             
                                                  
                                                for all 
                                                
                                                   
                                                      a
                                                      i
                                                      1
                                                   
                                                   ∈
                                                   A
                                                   (
                                                   
                                                      c
                                                      i
                                                      1
                                                   
                                                   )
                                                 
                                                do
                                             
                                          
                                          
                                             
                                                    
                                                if 
                                                
                                                   
                                                      a
                                                      i
                                                      0
                                                   
                                                   ∉
                                                   A
                                                   (
                                                   
                                                      c
                                                      i
                                                      0
                                                   
                                                   )
                                                   ∨
                                                   
                                                      a
                                                      i
                                                      0
                                                   
                                                   ≠
                                                   
                                                      a
                                                      i
                                                      1
                                                   
                                                 
                                                then
                                             
                                          
                                          
                                             
                                                      
                                                
                                                   
                                                      s
                                                      p
                                                   
                                                   ←
                                                   
                                                      s
                                                      highest
                                                   
                                                   ←
                                                   sim
                                                   (
                                                   
                                                      a
                                                      p
                                                      0
                                                   
                                                   .
                                                   value
                                                   ,
                                                   
                                                      a
                                                      i
                                                      1
                                                   
                                                   .
                                                   value
                                                   )
                                                   ;
                                                
                                             
                                          
                                          
                                             
                                                      
                                                if 
                                                
                                                   
                                                      a
                                                      t
                                                      0
                                                   
                                                   ≠
                                                   ∅
                                                 
                                                then
                                             
                                          
                                          
                                             
                                                        
                                                
                                                   
                                                      s
                                                      t
                                                   
                                                   ←
                                                   sim
                                                   (
                                                   
                                                      a
                                                      t
                                                      0
                                                   
                                                   .
                                                   value
                                                   ,
                                                   
                                                      a
                                                      i
                                                      1
                                                   
                                                   .
                                                   value
                                                   )
                                                   ;
                                                
                                             
                                          
                                          
                                             
                                                        
                                                if 
                                                s
                                                
                                                   t
                                                
                                                >
                                                s
                                                
                                                   highest
                                                 
                                                then
                                             
                                          
                                          
                                             
                                                          
                                                s
                                                
                                                   highest
                                                
                                                ←
                                                s
                                                
                                                   t
                                                
                                             
                                          
                                          
                                             
                                                        
                                                end if
                                             
                                          
                                          
                                             
                                                      
                                                end if
                                             
                                          
                                          
                                             
                                                      
                                                if 
                                                maxSim
                                                <
                                                s
                                                
                                                   highest
                                                 
                                                then
                                             
                                          
                                          
                                             
                                                        
                                                maxSim←
                                                s
                                                
                                                   highest
                                                
                                                ;
                                          
                                          
                                             
                                                        
                                                
                                                   
                                                      a
                                                      q
                                                      1
                                                   
                                                   ←
                                                   
                                                      a
                                                      i
                                                      1
                                                   
                                                   ;
                                                   
                                                      c
                                                      cand
                                                      1
                                                   
                                                   ←
                                                   
                                                      c
                                                      i
                                                      1
                                                   
                                                   ;
                                                
                                             
                                          
                                          
                                             
                                                      
                                                end if
                                             
                                          
                                          
                                             
                                                    
                                                end if
                                             
                                          
                                          
                                             
                                                
                                                end for
                                             
                                          
                                          
                                             
                                                end for
                                             
                                          
                                          
                                             
                                                return 
                                                
                                                   (
                                                   
                                                      a
                                                      q
                                                      1
                                                   
                                                   ;
                                                   maxSim
                                                   ;
                                                   
                                                      c
                                                      cand
                                                      1
                                                   
                                                   )
                                                   ;
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           

Given an attribute 
                           
                              a
                              p
                              0
                           
                           ∈
                           A
                           (
                           
                              c
                              k
                              0
                           
                           )
                         from 
                           
                              O
                              S
                              0
                           
                         and 
                           
                              a
                              t
                              0
                           
                           ∈
                           A
                           (
                           
                              c
                              t
                              0
                           
                           )
                         from 
                           
                              O
                              T
                              0
                           
                        , such that 
                           
                              c
                              k
                              0
                           
                         refers to a corresponding concept to 
                           
                              c
                              t
                              0
                           
                        , we suppose that the candidate attribute stands for the attribute coming from a concept in the context (cf. Eq. (3)) of the concept 
                           
                              c
                              k
                              0
                           
                        . The algorithm selects the candidate attribute from the whole set of changed attributes of the context of c
                        
                           k
                         at time j
                        +1, which refers to the most similar to attribute 
                           
                              a
                              p
                              0
                           
                        . In addition, if there exists an attribute 
                           
                              a
                              t
                              0
                           
                        , which is the most similar to 
                           
                              a
                              p
                              0
                           
                        , and the candidate attribute contains a similarity value with 
                           
                              a
                              t
                              0
                           
                         greater than that with 
                           
                              a
                              p
                              0
                           
                        , the algorithm will rank this candidate in a higher priority position.

We consider the types of attributes as a parameter in our approach. For example, we can take only attributes of type name and synonym into consideration when comparing the values of attributes. Our method excludes all types of attributes out of the comparable set of attributes defined beforehand. The best candidate contains the higher similarity value with 
                           
                              a
                              p
                              0
                           
                         (or 
                           
                              a
                              t
                              0
                           
                        , whether or not the attribute from the target concept of mapping is given, since it is optional in the algorithm).

The function 
                           sim
                           (
                           
                              a
                              i
                              0
                           
                           .
                           value
                           ,
                           
                              a
                              j
                              1
                           
                           .
                           value
                           )
                         in the algorithm refers to the similarity of two attribute values. The used similarity measure indicates the degree of relatedness between two given textual values. In our approach we adopted the bi-gram method to calculate the similarity values. In the implemented tools we can configure the similarity measure that is used.

In the following, we present our definition of lexical (Section 4.2) and semantic (Section 4.3) CPs and the methods to recognize them. We use the notations presented in Table 1.

We define lexical CP (LCP) classes as “Total Copy” (TC), “Total Transfer” (TT), “Partial Copy” (PC), and “Partial Transfer” (PT). Table 2
                         illustrates lexical change patterns in ontology. In the following, we formalize each type of lexical CP between attributes 
                           
                              a
                              p
                              0
                           
                           ∈
                           A
                           (
                           
                              c
                              k
                              0
                           
                           )
                         and 
                           
                              a
                              q
                              1
                           
                           ∈
                           A
                           (
                           
                              c
                              cand
                              1
                           
                           )
                        . Note that the definitions are valid only when a candidate attribute exists. We use the γ parameter to control the overlap in terms of words between two attribute values.
                           
                              •
                              
                                 Total Copy. A Total Copy of content occurs between attribute 
                                    
                                       a
                                       p
                                       0
                                    
                                  in concept 
                                    
                                       c
                                       k
                                       0
                                    
                                  and attribute 
                                    
                                       a
                                       q
                                       1
                                    
                                  in concept 
                                    
                                       c
                                       cand
                                       1
                                    
                                  if and only if a minimal degree γ of words in a
                                 
                                    p
                                  appears in attribute a
                                 
                                    q
                                  and a minimal similarity value τ exists between them. Formally:
                                    
                                       (6)
                                       
                                          TC
                                          (
                                          
                                             a
                                             p
                                             0
                                          
                                          ,
                                          
                                             a
                                             q
                                             1
                                          
                                          )
                                          ⇔
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               a
                                                               p
                                                               0
                                                            
                                                            ∈
                                                            A
                                                            (
                                                            
                                                               c
                                                               k
                                                               0
                                                            
                                                            )
                                                         
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               c
                                                               k
                                                               1
                                                            
                                                            ∈
                                                            C
                                                            (
                                                            
                                                               O
                                                               x
                                                               1
                                                            
                                                            )
                                                         
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               a
                                                               p
                                                               1
                                                            
                                                            ∈
                                                            A
                                                            (
                                                            
                                                               c
                                                               k
                                                               1
                                                            
                                                            )
                                                         
                                                         
                                                      
                                                      
                                                         
                                                            sim
                                                            (
                                                            
                                                               a
                                                               p
                                                               0
                                                            
                                                            ,
                                                            
                                                               a
                                                               q
                                                               1
                                                            
                                                            )
                                                            ≥
                                                            τ
                                                         
                                                         
                                                      
                                                      
                                                         
                                                            ‖
                                                            W
                                                            (
                                                            
                                                               a
                                                               p
                                                               0
                                                            
                                                            )
                                                            ∩
                                                            W
                                                            (
                                                            
                                                               a
                                                               q
                                                               1
                                                            
                                                            )
                                                            ‖
                                                            /
                                                            ‖
                                                            W
                                                            (
                                                            
                                                               a
                                                               p
                                                               0
                                                            
                                                            )
                                                            ‖
                                                            ≥
                                                            γ
                                                         
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              


                                 Total Transfer. A Total Transfer of content occurs between attribute 
                                    
                                       a
                                       p
                                       0
                                    
                                  in concept 
                                    
                                       c
                                       k
                                       0
                                    
                                  and attribute 
                                    
                                       a
                                       q
                                       1
                                    
                                  in concept 
                                    
                                       c
                                       cand
                                       1
                                    
                                  if and only if a minimal degree γ of words in a
                                 
                                    p
                                  appears in attributes a
                                 
                                    q
                                  and a minimal similarity value τ exists between them, while the original attribute a
                                 
                                    p
                                  is removed from 
                                    
                                       c
                                       k
                                       1
                                    
                                    ∈
                                    
                                       O
                                       x
                                       1
                                    
                                 . Note that in Total Copy (cf. Eq. (6)) a
                                 
                                    p
                                 
                                 ∈
                                 A(c
                                 
                                    k
                                 ) is instant at both times, while in Total Transfer (cf. Eq. (7)) a
                                 
                                    p
                                 
                                 ∉
                                 A(c
                                 
                                    k
                                 ) only in j
                                 +1. Formally:
                                    
                                       (7)
                                       
                                          TT
                                          (
                                          
                                             a
                                             p
                                             0
                                          
                                          ,
                                          
                                             a
                                             q
                                             1
                                          
                                          )
                                          ⇔
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               a
                                                               p
                                                               0
                                                            
                                                            ∈
                                                            A
                                                            (
                                                            
                                                               c
                                                               k
                                                               0
                                                            
                                                            )
                                                         
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               a
                                                               p
                                                               1
                                                            
                                                            ∉
                                                            A
                                                            (
                                                            
                                                               c
                                                               k
                                                               1
                                                            
                                                            )
                                                         
                                                         
                                                      
                                                      
                                                         
                                                            sim
                                                            (
                                                            
                                                               a
                                                               p
                                                               0
                                                            
                                                            ,
                                                            
                                                               a
                                                               q
                                                               1
                                                            
                                                            )
                                                            ≥
                                                            τ
                                                         
                                                         
                                                      
                                                      
                                                         
                                                            ‖
                                                            W
                                                            (
                                                            
                                                               a
                                                               p
                                                               0
                                                            
                                                            )
                                                            ∩
                                                            W
                                                            (
                                                            
                                                               a
                                                               q
                                                               1
                                                            
                                                            )
                                                            ‖
                                                            /
                                                            ‖
                                                            W
                                                            (
                                                            
                                                               a
                                                               p
                                                               0
                                                            
                                                            )
                                                            ‖
                                                            ≥
                                                            γ
                                                         
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              


                                 Partial Copy. A Partial Copy of content occurs between attribute 
                                    
                                       a
                                       p
                                       0
                                    
                                  in concept c
                                 
                                    k
                                  and attribute 
                                    
                                       a
                                       q
                                       1
                                    
                                  in concept c
                                 
                                    cand
                                  if and only if there exists a partial overlap between words constituting attribute 
                                    
                                       a
                                       p
                                       0
                                    
                                  and attribute 
                                    
                                       a
                                       q
                                       1
                                    
                                  superior to 0 and inferior to γ, while respecting a minimal similarity value τ. Formally:
                                    
                                       (8)
                                       
                                          PC
                                          (
                                          
                                             a
                                             p
                                             0
                                          
                                          ,
                                          
                                             a
                                             q
                                             1
                                          
                                          )
                                          ⇔
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               a
                                                               p
                                                               0
                                                            
                                                            ∈
                                                            A
                                                            (
                                                            
                                                               c
                                                               k
                                                               0
                                                            
                                                            )
                                                         
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               c
                                                               k
                                                               1
                                                            
                                                            ∈
                                                            C
                                                            (
                                                            
                                                               O
                                                               x
                                                               1
                                                            
                                                            )
                                                         
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               a
                                                               p
                                                               1
                                                            
                                                            ∈
                                                            A
                                                            (
                                                            
                                                               c
                                                               k
                                                               1
                                                            
                                                            )
                                                         
                                                         
                                                      
                                                      
                                                         
                                                            sim
                                                            (
                                                            
                                                               a
                                                               p
                                                               0
                                                            
                                                            ,
                                                            
                                                               a
                                                               q
                                                               1
                                                            
                                                            )
                                                            ≥
                                                            τ
                                                         
                                                         
                                                      
                                                      
                                                         
                                                            0
                                                            <
                                                            ‖
                                                            W
                                                            (
                                                            
                                                               a
                                                               p
                                                               0
                                                            
                                                            )
                                                            ∩
                                                            W
                                                            (
                                                            
                                                               a
                                                               q
                                                               1
                                                            
                                                            )
                                                            ‖
                                                            /
                                                            ‖
                                                            W
                                                            (
                                                            
                                                               a
                                                               p
                                                               0
                                                            
                                                            )
                                                            ‖
                                                            <
                                                            γ
                                                         
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              


                                 Partial Transfer. A Partial Transfer of content occurs between attribute 
                                    
                                       a
                                       p
                                       0
                                    
                                  in concept c
                                 
                                    k
                                  and attribute 
                                    
                                       a
                                       q
                                       1
                                    
                                  in concept c
                                 
                                    cand
                                  if, and only if there exists a partial overlap between words constituting attribute 
                                    
                                       a
                                       p
                                       0
                                    
                                  and attribute 
                                    
                                       a
                                       q
                                       1
                                    
                                  superior to 0 and inferior to γ, while respecting a minimal similarity value τ, and the original attribute a
                                 
                                    p
                                  is removed from 
                                    
                                       c
                                       k
                                    
                                    ∈
                                    
                                       O
                                       x
                                       1
                                    
                                 . Formally:
                                    
                                       (9)
                                       
                                          PT
                                          (
                                          
                                             a
                                             p
                                             0
                                          
                                          ,
                                          
                                             a
                                             q
                                             1
                                          
                                          )
                                          ⇔
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               a
                                                               p
                                                               0
                                                            
                                                            ∈
                                                            A
                                                            (
                                                            
                                                               c
                                                               k
                                                               0
                                                            
                                                            )
                                                         
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               a
                                                               p
                                                               1
                                                            
                                                            ∉
                                                            A
                                                            (
                                                            
                                                               c
                                                               k
                                                               1
                                                            
                                                            )
                                                         
                                                         
                                                      
                                                      
                                                         
                                                            sim
                                                            (
                                                            
                                                               a
                                                               p
                                                               0
                                                            
                                                            ,
                                                            
                                                               a
                                                               q
                                                               1
                                                            
                                                            )
                                                            ≥
                                                            τ
                                                         
                                                         
                                                      
                                                      
                                                         
                                                            0
                                                            <
                                                            ‖
                                                            W
                                                            (
                                                            
                                                               a
                                                               p
                                                               0
                                                            
                                                            )
                                                            ∩
                                                            W
                                                            (
                                                            
                                                               a
                                                               q
                                                               1
                                                            
                                                            )
                                                            ‖
                                                            /
                                                            ‖
                                                            W
                                                            (
                                                            
                                                               a
                                                               p
                                                               0
                                                            
                                                            )
                                                            ‖
                                                            <
                                                            γ
                                                         
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              


                        Algorithm 2 describes the method to identify lexical CP. The best candidate 
                           
                              c
                              cand
                              1
                           
                         (cf. 
                        Algorithm 1) refers to the concept denoted by attribute 
                           
                              a
                              q
                              1
                           
                        , who has the highest similarity with concept 
                           
                              c
                              k
                              0
                           
                        , denoted by attribute 
                           
                              a
                              p
                              0
                           
                        . For each candidate 
                           
                              a
                              q
                              1
                           
                        , the algorithm checks whether its similarity with attribute 
                           
                              a
                              p
                              0
                           
                         is greater than or equal to a threshold τ. We exploit the change operations (calculated by ontology diff tools) related to each attribute 
                           
                              a
                              p
                              0
                           
                           ∈
                           A
                           (
                           
                              c
                              k
                              0
                           
                           )
                         and 
                           
                              a
                              q
                              1
                           
                           ∈
                           A
                           (
                           
                              c
                              cand
                              1
                           
                           )
                         and remove stop words from the original attributes. Non-stopwords are stemmed using the Porter stemming algorithm [33]. The proposed algorithm applies the conditions to each type of CPs on the couple of attributes 
                           
                              a
                              p
                              0
                           
                         and 
                           
                              a
                              q
                              1
                           
                        . To this end, it calculates the number of common words between 
                           
                              a
                              p
                              0
                           
                         and 
                           
                              a
                              q
                              1
                           
                         (considering a threshold γ) and assigns the adequate LCP mainly based on these metrics combined with the changes affecting 
                           
                              a
                              p
                              0
                           
                        .


                        
                           Algorithm 2
                           Lexical change pattern identification


                              
                                 
                                    
                                       
                                       
                                          
                                             
                                                Require: 
                                                   
                                                      a
                                                      p
                                                      0
                                                   
                                                   ∈
                                                   A
                                                   (
                                                   
                                                      c
                                                      k
                                                      0
                                                   
                                                   )
                                                   ;
                                                   
                                                      c
                                                      k
                                                      0
                                                   
                                                   ∈
                                                   C
                                                   (
                                                   
                                                      O
                                                      x
                                                      0
                                                   
                                                   )
                                                   ;
                                                   CT
                                                   (
                                                   
                                                      c
                                                      k
                                                      1
                                                   
                                                   )
                                                   ⊂
                                                   C
                                                   (
                                                   
                                                      O
                                                      x
                                                      1
                                                   
                                                   )
                                                   ;
                                                   
                                                      a
                                                      t
                                                      0
                                                   
                                                   ∈
                                                   A
                                                   (
                                                   
                                                      c
                                                      t
                                                      0
                                                   
                                                   )
                                                   ∈
                                                   
                                                      O
                                                      T
                                                      0
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                maxSim←0;
                                                LCP
                                                ←∅;
                                                nbEqWords
                                                ←0;
                                          
                                          
                                             
                                                
                                                
                                                   [
                                                   
                                                      a
                                                      q
                                                      1
                                                   
                                                   ;
                                                   maxSim
                                                   ]
                                                   ←
                                                 
                                                
                                                   getBestAttribute
                                                   (
                                                   
                                                      a
                                                      p
                                                      0
                                                   
                                                   ;
                                                   CT
                                                   (
                                                   
                                                      c
                                                      k
                                                      1
                                                   
                                                   )
                                                   ;
                                                   
                                                      a
                                                      t
                                                      0
                                                   
                                                   )
                                                 // cf. 
                                                Algorithm 1
                                             
                                          
                                          
                                             
                                                {if there exists the best similar attribute changed in context, then we verify conditions}
                                          
                                          
                                             
                                                
                                                if 
                                                
                                                   
                                                      a
                                                      q
                                                      1
                                                   
                                                   ≠
                                                   ∅
                                                 
                                                then
                                             
                                          
                                          
                                             
                                                  
                                                if 
                                                maxSim
                                                >
                                                τ 
                                                then
                                             
                                          
                                          
                                             
                                                    {calculate number of common words}
                                          
                                          
                                             
                                                    
                                                
                                                   nbEqWords
                                                   ←
                                                   ‖
                                                   W
                                                   (
                                                   
                                                      a
                                                      p
                                                      0
                                                   
                                                   )
                                                   ∩
                                                   W
                                                   (
                                                   
                                                      a
                                                      q
                                                      1
                                                   
                                                   )
                                                   ‖
                                                
                                             
                                          
                                          
                                             
                                                    
                                                if 
                                                
                                                   nbEqWords
                                                   /
                                                   ‖
                                                   W
                                                   (
                                                   
                                                      a
                                                      p
                                                      0
                                                   
                                                   )
                                                   ‖
                                                   
                                                   <
                                                   γ
                                                   
                                                   ∧
                                                   
                                                   nbEqWords
                                                   >
                                                   0
                                                 
                                                then
                                             
                                          
                                          
                                             
                                                      
                                                if 
                                                
                                                   
                                                      a
                                                      p
                                                      1
                                                   
                                                   ∈
                                                   A
                                                   (
                                                   
                                                      c
                                                      k
                                                      1
                                                   
                                                   )
                                                 
                                                then
                                             
                                          
                                          
                                             
                                                      
                                                LCP←
                                                PC
                                                ;
                                          
                                          
                                             
                                                    
                                                else
                                             
                                          
                                          
                                             
                                                      
                                                LCP←
                                                PT
                                                ;
                                          
                                          
                                             
                                                    
                                                end if
                                             
                                          
                                          
                                             
                                                  
                                                else
                                             
                                          
                                          
                                             
                                                    
                                                if 
                                                
                                                   nbEqWords
                                                   /
                                                   ‖
                                                   W
                                                   (
                                                   
                                                      a
                                                      p
                                                      0
                                                   
                                                   )
                                                   ‖
                                                   ≥
                                                   γ
                                                 
                                                then
                                             
                                          
                                          
                                             
                                                      
                                                if 
                                                
                                                   
                                                      a
                                                      p
                                                      1
                                                   
                                                   ∈
                                                   A
                                                   (
                                                   
                                                      c
                                                      k
                                                      1
                                                   
                                                   )
                                                 
                                                then
                                             
                                          
                                          
                                             
                                                        
                                                LCP←
                                                TC
                                                ;
                                          
                                          
                                             
                                                      
                                                else
                                             
                                          
                                          
                                             
                                                        
                                                LCP←
                                                TT
                                                ;
                                          
                                          
                                             
                                                      
                                                end if
                                             
                                          
                                          
                                             
                                                    
                                                end if
                                             
                                          
                                          
                                             
                                                  
                                                end if
                                             
                                          
                                          
                                             
                                                
                                                end if
                                             
                                          
                                          
                                             
                                                end if
                                             
                                          
                                          
                                             
                                                return (LCP);
                                          
                                       
                                    
                                 
                              
                           

We define semantic CP (SCP) classes as “Equivalent” (≡) (EQV), “More Specific” (<) (MSP), “Less Specific” (>) (LSP) and “Partial Match” (≈) (PTM). Table 3
                         shows examples of semantic change patterns. These change patterns aim to capture the evolution from the semantic point of view of an attribute value. This creates a much greater challenge for the recognition method, because situations not fully corresponding to the intersection of words or characters might exist. For example, “hypotension” is more specific than “vascular disease”. Our previous research with ontology evolution in the biomedical domain shows that these cases are rare in evolution scenarios [10]. Our proposed semantic change patterns still allow, for instance, the detection that “cerebral hypoxia” is a more general term than “cerebral anoxia”.

We formalize each type of SCP between attributes 
                           
                              a
                              p
                              0
                           
                           ∈
                           A
                           (
                           
                              c
                              k
                              0
                           
                           )
                         and 
                           
                              a
                              q
                              1
                           
                           ∈
                           A
                           (
                           
                              c
                              cand
                              1
                           
                           )
                         in the following. Aside from the EQV (cf. equations 10), we use the statement 
                           sim
                           (
                           
                              a
                              p
                              0
                           
                           ,
                           
                              a
                              q
                              1
                           
                           )
                           ≥
                           τ
                         to filter cases of very low similarity between the attributes.
                           
                              •
                              
                                 Equivalent. We consider an attribute 
                                    
                                       a
                                       p
                                       0
                                    
                                  as semantically equivalent to an attribute 
                                    
                                       a
                                       q
                                       1
                                    
                                  (cf. Eq. (10)) if, and only if, we observe all words from 
                                    
                                       a
                                       p
                                       0
                                    
                                  in 
                                    
                                       a
                                       q
                                       1
                                    
                                  and vice-versa or the overlap in terms of words between them must be equal to or greater than a threshold τ. In the latter case, to harmonize the rate of the words intersection between the attributes, we multiply the number of intersections by 2 over the total number of words of the two attributes. Based on the analysis conducted in our previous studies [10], we exclude from this SCP all concepts 
                                    
                                       c
                                       cand
                                       1
                                    
                                  with a hierarchical relationship with 
                                    
                                       c
                                       k
                                       1
                                    
                                 . We observed that there exists a conceptual error if at time j a mapping between two concepts exist with an equivalent relation (c
                                 
                                    s
                                 , c
                                 
                                    t
                                 , ≡) and at time j
                                 +1 a mapping between two concepts exists with an equivalent relation (c
                                 
                                    cand
                                 , c
                                 
                                    t
                                 , ≡) in which 
                                    
                                       c
                                       s
                                       1
                                    
                                    ∈
                                    sup
                                    (
                                    
                                       c
                                       cand
                                       1
                                    
                                    )
                                  or 
                                    
                                       c
                                       s
                                    
                                    ∈
                                    sub
                                    (
                                    
                                       c
                                       cand
                                       1
                                    
                                    )
                                 . We formally define the equivalence as follows:
                                    
                                       (10)
                                       
                                          
                                             a
                                             p
                                             0
                                          
                                          ≡
                                          
                                             a
                                             q
                                             1
                                          
                                          ⇔
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               c
                                                               k
                                                               1
                                                            
                                                            ∈
                                                            C
                                                            (
                                                            
                                                               O
                                                               x
                                                               1
                                                            
                                                            )
                                                         
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               c
                                                               k
                                                               1
                                                            
                                                            ∉
                                                            sub
                                                            (
                                                            
                                                               c
                                                               cand
                                                               1
                                                            
                                                            )
                                                            ∧
                                                            
                                                               c
                                                               k
                                                               1
                                                            
                                                            ∉
                                                            sup
                                                            (
                                                            
                                                               c
                                                               cand
                                                               1
                                                            
                                                            )
                                                         
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     
                                                                        
                                                                           
                                                                              
                                                                                 a
                                                                                 p
                                                                                 0
                                                                              
                                                                              =
                                                                              
                                                                                 a
                                                                                 q
                                                                                 1
                                                                              
                                                                           
                                                                        
                                                                        
                                                                           
                                                                              ∨
                                                                           
                                                                        
                                                                        
                                                                           
                                                                              (
                                                                              2
                                                                              *
                                                                              ‖
                                                                              W
                                                                              (
                                                                              
                                                                                 a
                                                                                 p
                                                                                 0
                                                                              
                                                                              )
                                                                              ∩
                                                                              W
                                                                              (
                                                                              
                                                                                 a
                                                                                 q
                                                                                 1
                                                                              
                                                                              )
                                                                              ‖
                                                                              )
                                                                              /
                                                                              (
                                                                              ‖
                                                                              W
                                                                              (
                                                                              
                                                                                 a
                                                                                 p
                                                                                 0
                                                                              
                                                                              )
                                                                              ‖
                                                                              +
                                                                              ‖
                                                                              W
                                                                              (
                                                                              
                                                                                 a
                                                                                 q
                                                                                 1
                                                                              
                                                                              )
                                                                              ‖
                                                                              )
                                                                              ≥
                                                                              γ
                                                                           
                                                                        
                                                                        
                                                                           
                                                                        
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                         
                                                      
                                                      
                                                         
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              


                                 More Specific. We define an attribute 
                                    
                                       a
                                       p
                                       0
                                    
                                  as more specific (less generic) than an attribute 
                                    
                                       a
                                       q
                                       1
                                    
                                  if, and only if, we observe all words from 
                                    
                                       a
                                       q
                                       1
                                    
                                  in 
                                    
                                       a
                                       p
                                       0
                                    
                                 , but not the opposite. Thus, 
                                    
                                       a
                                       q
                                       1
                                    
                                  is composed of a subset of words of 
                                    
                                       a
                                       p
                                       0
                                    
                                 . We also observe, by introducing the parameter γ whether 
                                    
                                       a
                                       q
                                       1
                                    
                                  has a declination of at least one word from 
                                    
                                       a
                                       p
                                       0
                                    
                                  (i.e., a prefix or a suffix of 
                                    
                                       a
                                       p
                                       0
                                    
                                  slightly differs from 
                                    
                                       a
                                       q
                                       1
                                    
                                 ). Moreover, concept c
                                 
                                    k
                                  cannot be located at a higher position in the hierarchical structure than concept c
                                 
                                    cand
                                 . Formally:
                                    
                                       (11)
                                       
                                          
                                             a
                                             p
                                             0
                                          
                                          <
                                          
                                             a
                                             q
                                             1
                                          
                                          ⇔
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               c
                                                               k
                                                               1
                                                            
                                                            ∉
                                                            sup
                                                            (
                                                            
                                                               c
                                                               cand
                                                               1
                                                            
                                                            )
                                                         
                                                         
                                                      
                                                      
                                                         
                                                            sim
                                                            (
                                                            
                                                               a
                                                               p
                                                               0
                                                            
                                                            ,
                                                            
                                                               a
                                                               q
                                                               1
                                                            
                                                            )
                                                            ≥
                                                            τ
                                                         
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     
                                                                        
                                                                           
                                                                              ‖
                                                                              W
                                                                              (
                                                                              
                                                                                 a
                                                                                 p
                                                                                 0
                                                                              
                                                                              )
                                                                              ‖
                                                                              >
                                                                              ‖
                                                                              W
                                                                              (
                                                                              
                                                                                 a
                                                                                 q
                                                                                 1
                                                                              
                                                                              )
                                                                              ‖
                                                                              ∧
                                                                              (
                                                                              ‖
                                                                              W
                                                                              (
                                                                              
                                                                                 a
                                                                                 p
                                                                                 0
                                                                              
                                                                              )
                                                                              ∩
                                                                              W
                                                                              (
                                                                              
                                                                                 a
                                                                                 q
                                                                                 1
                                                                              
                                                                              )
                                                                              ‖
                                                                              /
                                                                              ‖
                                                                              W
                                                                              (
                                                                              
                                                                                 a
                                                                                 q
                                                                                 1
                                                                              
                                                                              )
                                                                              ‖
                                                                              ≥
                                                                              γ
                                                                              )
                                                                           
                                                                        
                                                                        
                                                                           
                                                                              ∨
                                                                           
                                                                        
                                                                        
                                                                           
                                                                              ∃
                                                                              
                                                                                 w
                                                                                 p
                                                                                 0
                                                                              
                                                                              ∈
                                                                              W
                                                                              (
                                                                              
                                                                                 a
                                                                                 p
                                                                                 0
                                                                              
                                                                              )
                                                                              ,
                                                                              
                                                                                 w
                                                                                 q
                                                                                 1
                                                                              
                                                                              ∈
                                                                              W
                                                                              (
                                                                              
                                                                                 a
                                                                                 q
                                                                                 1
                                                                              
                                                                              )
                                                                              ∣
                                                                              Ch
                                                                              (
                                                                              
                                                                                 w
                                                                                 q
                                                                                 1
                                                                              
                                                                              )
                                                                              ⊂
                                                                              Ch
                                                                              (
                                                                              
                                                                                 w
                                                                                 p
                                                                                 0
                                                                              
                                                                              )
                                                                           
                                                                        
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              


                                 Less Specific. We consider attribute 
                                    
                                       a
                                       p
                                       0
                                    
                                  as less specific (more generic) than attribute 
                                    
                                       a
                                       q
                                       1
                                    
                                  applying the inverse proposition for the More Specific pattern. Formally:
                                    
                                       (12)
                                       
                                          
                                             a
                                             p
                                             0
                                          
                                          >
                                          
                                             a
                                             q
                                             1
                                          
                                          ⇔
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               c
                                                               k
                                                               1
                                                            
                                                            ∉
                                                            sub
                                                            (
                                                            
                                                               c
                                                               cand
                                                               1
                                                            
                                                            )
                                                         
                                                         
                                                      
                                                      
                                                         
                                                            sim
                                                            (
                                                            
                                                               a
                                                               p
                                                               0
                                                            
                                                            ,
                                                            
                                                               a
                                                               q
                                                               1
                                                            
                                                            )
                                                            ≥
                                                            τ
                                                         
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     
                                                                        
                                                                           
                                                                              ‖
                                                                              W
                                                                              (
                                                                              
                                                                                 a
                                                                                 p
                                                                                 0
                                                                              
                                                                              )
                                                                              ‖
                                                                              <
                                                                              ‖
                                                                              W
                                                                              (
                                                                              
                                                                                 a
                                                                                 q
                                                                                 1
                                                                              
                                                                              )
                                                                              ‖
                                                                              ∧
                                                                              (
                                                                              ‖
                                                                              W
                                                                              (
                                                                              
                                                                                 a
                                                                                 p
                                                                                 0
                                                                              
                                                                              )
                                                                              ∩
                                                                              W
                                                                              (
                                                                              
                                                                                 a
                                                                                 q
                                                                                 1
                                                                              
                                                                              )
                                                                              ‖
                                                                              /
                                                                              ‖
                                                                              W
                                                                              (
                                                                              
                                                                                 a
                                                                                 p
                                                                                 0
                                                                              
                                                                              )
                                                                              ‖
                                                                              ≥
                                                                              γ
                                                                              )
                                                                           
                                                                        
                                                                        
                                                                           
                                                                              ∨
                                                                           
                                                                        
                                                                        
                                                                           
                                                                              ∃
                                                                              
                                                                                 w
                                                                                 q
                                                                                 1
                                                                              
                                                                              ∈
                                                                              W
                                                                              (
                                                                              
                                                                                 a
                                                                                 q
                                                                                 1
                                                                              
                                                                              )
                                                                              ,
                                                                              
                                                                                 w
                                                                                 p
                                                                                 0
                                                                              
                                                                              ∈
                                                                              W
                                                                              (
                                                                              
                                                                                 a
                                                                                 p
                                                                                 0
                                                                              
                                                                              )
                                                                              ∣
                                                                              Ch
                                                                              (
                                                                              
                                                                                 w
                                                                                 p
                                                                                 0
                                                                              
                                                                              )
                                                                              ⊂
                                                                              Ch
                                                                              (
                                                                              
                                                                                 w
                                                                                 q
                                                                                 1
                                                                              
                                                                              )
                                                                           
                                                                        
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                         
                                                      
                                                      
                                                         
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              


                                 Partial Match. Attribute 
                                    
                                       a
                                       p
                                       0
                                    
                                  is partially matched to attribute 
                                    
                                       a
                                       q
                                       1
                                    
                                  if, and only if, we detect some common words between them and if the similarity value between them is higher than a threshold τ.
                                    
                                       (13)
                                       
                                          
                                             a
                                             p
                                             0
                                          
                                          ≈
                                          
                                             a
                                             q
                                             1
                                          
                                          ⇔
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            ∃
                                                            
                                                               w
                                                               ip
                                                               0
                                                            
                                                            ∈
                                                            W
                                                            (
                                                            
                                                               a
                                                               p
                                                               0
                                                            
                                                            )
                                                            ,
                                                            
                                                               w
                                                               ip
                                                               0
                                                            
                                                            ∈
                                                            W
                                                            (
                                                            
                                                               a
                                                               q
                                                               1
                                                            
                                                            )
                                                         
                                                         
                                                      
                                                      
                                                         
                                                            ∃
                                                            
                                                               w
                                                               kp
                                                               0
                                                            
                                                            ∈
                                                            W
                                                            (
                                                            
                                                               a
                                                               p
                                                               0
                                                            
                                                            )
                                                            ,
                                                            
                                                               w
                                                               kp
                                                               0
                                                            
                                                            ∉
                                                            W
                                                            (
                                                            
                                                               a
                                                               q
                                                               1
                                                            
                                                            )
                                                         
                                                         
                                                      
                                                      
                                                         
                                                            sim
                                                            (
                                                            
                                                               a
                                                               p
                                                               0
                                                            
                                                            ,
                                                            
                                                               a
                                                               q
                                                               1
                                                            
                                                            )
                                                            ≥
                                                            τ
                                                         
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              


                        Algorithm 3 describes the procedure designed to identify semantic change patterns (SCP). Considering that a candidate attribute exists in the context, the algorithm proceeds by verifying conditions to assign one of the four semantic CPs (Equivalence, More Specific, Less Specific or Partial Match, respectively). The process starts by verifying the conditions of the SCP Equivalence. If it is not satisfied then the algorithm verifies the conditions for More Specific, followed by Less Specific, and finally Partial Match. To this end, the algorithm calculates the number of common words between the attributes, and the number of subwords from one attribute to the other, by checking whether the set of characters of one word corresponds to a subset of characters of another word. The algorithm also checks a minimal threshold τ regarding the similarity value between the attributes for which a Less Specific or a More Specific SCP can be assigned. When the set of conditions is satisfied, the algorithm assigns SCP with the correspondent symbol and stops.


                        
                           Algorithm 3
                           Semantic change pattern identification


                              
                                 
                                    
                                       
                                       
                                          
                                             
                                                Require: 
                                                   
                                                      a
                                                      p
                                                      0
                                                   
                                                   ∈
                                                   A
                                                   (
                                                   
                                                      c
                                                      k
                                                      0
                                                   
                                                   )
                                                   ;
                                                   
                                                      c
                                                      k
                                                      0
                                                   
                                                   ∈
                                                   C
                                                   (
                                                   
                                                      O
                                                      x
                                                      0
                                                   
                                                   )
                                                   ;
                                                   CT
                                                   (
                                                   
                                                      c
                                                      k
                                                      1
                                                   
                                                   )
                                                   ⊂
                                                   C
                                                   (
                                                   
                                                      O
                                                      x
                                                      1
                                                   
                                                   )
                                                   ;
                                                   
                                                      a
                                                      t
                                                      0
                                                   
                                                   ∈
                                                   A
                                                   (
                                                   
                                                      c
                                                      t
                                                      0
                                                   
                                                   )
                                                   ;
                                                   
                                                      c
                                                      t
                                                      0
                                                   
                                                   ∈
                                                   
                                                      O
                                                      T
                                                      0
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                   [
                                                   
                                                      a
                                                      q
                                                      1
                                                   
                                                   ;
                                                   maxSim
                                                   ;
                                                   
                                                      c
                                                      cand
                                                      1
                                                   
                                                   ]
                                                   ←
                                                   getBestAttribute
                                                   (
                                                   
                                                      a
                                                      p
                                                      0
                                                   
                                                   ;
                                                   CT
                                                   (
                                                   
                                                      c
                                                      k
                                                      1
                                                   
                                                   )
                                                   ;
                                                   
                                                      a
                                                      t
                                                      0
                                                   
                                                   )
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                   EqWords
                                                   ←
                                                   
                                                      {
                                                      W
                                                      (
                                                      
                                                         a
                                                         p
                                                         0
                                                      
                                                      )
                                                      ∩
                                                      W
                                                      (
                                                      
                                                         a
                                                         q
                                                         1
                                                      
                                                      )
                                                      }
                                                   
                                                   ;
                                                   SCP
                                                   ←
                                                   ∅
                                                
                                             
                                          
                                          
                                             
                                                
                                                if (
                                                   
                                                      a
                                                      p
                                                      0
                                                   
                                                   =
                                                   
                                                      a
                                                      q
                                                      1
                                                   
                                                   )
                                                   ∨
                                                   (
                                                   (
                                                   2
                                                   *
                                                   ‖
                                                   EqWords
                                                   ‖
                                                   )
                                                   /
                                                   (
                                                   ‖
                                                   W
                                                   (
                                                   
                                                      a
                                                      p
                                                      0
                                                   
                                                   )
                                                   ‖
                                                   +
                                                   ‖
                                                   W
                                                   (
                                                   
                                                      a
                                                      q
                                                      1
                                                   
                                                   )
                                                   ‖
                                                   )
                                                   ≥
                                                   γ
                                                   )
                                                 
                                                then
                                             
                                          
                                          
                                             
                                                  
                                                if 
                                                
                                                   
                                                      c
                                                      k
                                                      1
                                                   
                                                   ∉
                                                   sup
                                                   (
                                                   
                                                      c
                                                      cand
                                                      1
                                                   
                                                   )
                                                   ∧
                                                   
                                                      c
                                                      k
                                                      1
                                                   
                                                   ∉
                                                   sub
                                                   (
                                                   
                                                      c
                                                      cand
                                                      1
                                                   
                                                   )
                                                 
                                                then
                                             
                                          
                                          
                                             
                                                    
                                                SCP←≡;
                                          
                                          
                                             
                                                  
                                                end if
                                             
                                          
                                          
                                             
                                                
                                                else if 
                                                maxSim
                                                ≥
                                                τ
                                             
                                          
                                          
                                             
                                                  
                                                if 
                                                
                                                   (
                                                   SubString
                                                   (
                                                   
                                                      a
                                                      q
                                                      1
                                                   
                                                   ,
                                                   
                                                      a
                                                      p
                                                      0
                                                   
                                                   )
                                                   )
                                                   ∨
                                                   (
                                                   (
                                                   ‖
                                                   W
                                                   (
                                                   
                                                      a
                                                      p
                                                      0
                                                   
                                                   )
                                                   ‖
                                                   >
                                                   ‖
                                                   W
                                                   (
                                                   
                                                      a
                                                      q
                                                      1
                                                   
                                                   )
                                                   ‖
                                                   )
                                                   ∧
                                                   (
                                                   ‖
                                                   EqWords
                                                   ‖
                                                   ≥
                                                   ‖
                                                   W
                                                   (
                                                   
                                                      a
                                                      q
                                                      1
                                                   
                                                   )
                                                   ‖
                                                   *
                                                   γ
                                                   )
                                                 
                                                then
                                             
                                          
                                          
                                             
                                                    
                                                if 
                                                
                                                   
                                                      c
                                                      k
                                                      1
                                                   
                                                   ∉
                                                   sup
                                                   (
                                                   
                                                      c
                                                      cand
                                                      1
                                                   
                                                   )
                                                 
                                                then
                                             
                                          
                                          
                                             
                                                      
                                                SCP←<;
                                          
                                          
                                             
                                                    
                                                end if
                                             
                                          
                                          
                                             
                                                  
                                                else if 
                                                
                                                   (
                                                   SubString
                                                   (
                                                   
                                                      a
                                                      p
                                                      0
                                                   
                                                   ,
                                                   
                                                      a
                                                      q
                                                      1
                                                   
                                                   )
                                                   )
                                                   ∨
                                                   (
                                                   (
                                                   ‖
                                                   W
                                                   (
                                                   
                                                      a
                                                      p
                                                      0
                                                   
                                                   )
                                                   ‖
                                                   <
                                                   ‖
                                                   W
                                                   (
                                                   
                                                      a
                                                      q
                                                      1
                                                   
                                                   )
                                                   ‖
                                                   )
                                                   ∧
                                                   (
                                                   ‖
                                                   EqWords
                                                   ‖
                                                   ≥
                                                   ‖
                                                   W
                                                   (
                                                   
                                                      a
                                                      p
                                                      0
                                                   
                                                   )
                                                   ‖
                                                   *
                                                   γ
                                                   )
                                                
                                             
                                          
                                          
                                             
                                                    
                                                if 
                                                
                                                   
                                                      c
                                                      k
                                                      1
                                                   
                                                   ∉
                                                   sub
                                                   (
                                                   
                                                      c
                                                      cand
                                                      1
                                                   
                                                   )
                                                 
                                                then
                                             
                                          
                                          
                                             
                                                      
                                                SCP←>;
                                          
                                          
                                             
                                                    
                                                end if
                                             
                                          
                                          
                                             
                                                  
                                                else if 
                                                
                                                   (
                                                   ‖
                                                   EqWords
                                                   ‖
                                                   >
                                                   0
                                                   )
                                                   ∧
                                                   (
                                                   EqWords
                                                   ≠
                                                   ‖
                                                   W
                                                   (
                                                   
                                                      a
                                                      q
                                                      1
                                                   
                                                   )
                                                   ‖
                                                   )
                                                   ∧
                                                   (
                                                   EqWords
                                                   ≠
                                                   ‖
                                                   W
                                                   (
                                                   
                                                      a
                                                      p
                                                      0
                                                   
                                                   )
                                                   ‖
                                                   )
                                                
                                             
                                          
                                          
                                             
                                                
                                                SCP
                                                =≈;
                                          
                                          
                                             
                                                end if
                                             
                                          
                                          
                                             
                                                end if
                                             
                                          
                                          
                                             
                                                return (SCP);
                                          
                                       
                                    
                                 
                              
                           

Note that for semantic CP identification, the concept 
                           
                              c
                              k
                              1
                           
                         may be considered as candidate in addition to concepts in 
                           CT
                           (
                           
                              c
                              k
                              1
                           
                           )
                        , because the whole set of concepts from 
                           CT
                           (
                           
                              c
                              k
                              1
                           
                           )
                         can remain unchanged, and the attribute 
                           
                              a
                              p
                              0
                           
                         can evolve becoming more or less specific in the same concept 
                           
                              c
                              k
                              1
                           
                        . However, for lexical CP identification, only concepts in 
                           CT
                           (
                           
                              c
                              k
                              1
                           
                           )
                         are considered as candidates, because we consider a copy or a transfer only between attributes of different concepts (i.e., concepts having different identifiers).

We present the used materials in the series of experiments to achieve the following objectives:
                        
                           1.
                           
                              Objective 1: Evaluate the effectiveness of the proposed methods to identify lexical and semantic change patterns as described in Algorithms 2 and 3.


                              Objective 2: Assess the utility of considering lexical and semantic change patterns for supporting mapping adaptation under evolving ontologies.


                              Objective 3: Investigate the influence of the similarity between attribute values in identified change patterns to explain the positive and negative impact of these patterns on the behaviours of mapping adaptation.

We devoted one particular experiment to investigating each objective. Section 6 reports on the experimental procedure and results for objective 1. Section 7 presents the results for objective 2 and section 8 for objective 3.

In the experiments, we chose life science ontologies and mappings from at least two official releases. Since no reference dataset exists for the defined patterns, this required the building of our own reference change patterns, called here gold standard, which allowed performing the validation. We used such dataset only in the experiment dedicated to evaluate objective 1 (Section 6). On the other hand, we used as input the whole set of mappings in the experiments to evaluate objectives 2 and 3.


                     Ontologies and mappings. Experiments in this article forced us to rely on several versions of validated mappings, which are freely available for research purposes.

We used four large biomedical ontologies: SNOMED-CT
                        3
                     
                     
                        3
                        
                           http://www.ihtsdo.org/snomed-ct (accessed 26.11.14).
                      (SCT for short), MeSH
                        4
                     
                     
                        4
                        
                           http://www.nlm.nih.gov/mesh/meshhome.html (accessed 26.11.14).
                     , ICD-9-CM
                        5
                     
                     
                        5
                        
                           http://www.cdc.gov/nchs/icd/icd9cm.htm (accessed 26.11.14).
                      (ICD9 for short) and ICD-10-CM
                        6
                     
                     
                        6
                        
                           http://www.cdc.gov/nchs/icd/icd10cm.htm (accessed 26.11.14).
                      (ICD10 for short). Table 4
                      presents statistics regarding the number of concepts, attributes denoting concepts, and the number of direct subsumption relationships between concepts, since this study focused on exploiting the hierarchical structure of ontologies. SCT contains a much higher number of concepts than MeSH, ICD9 and ICD10.

We used official mappings
                        7
                     
                     
                        7
                        
                           http://www.nlm.nih.gov/research/umls/mapping_projects/icd9cm_to_snomedct.html (accessed 26.11.14).
                      established between SCT and ICD9. Indeed, mappings between these two biomedical ontologies are provided for each release of SCT by the International Health Terminology Standards Development Organisation (IHTSDO)
                        8
                     
                     
                        8
                        
                           http://www.ihtsdo.org (accessed 26.11.14).
                      organization. Mappings between MeSH and ICD10 were established by the CISMeF team
                     
                        9
                     
                     
                        9
                        
                           http://www.cismef.org (accessed 26.11.14).
                      involving biomedical experts. Table 5
                      shows the quantity of mappings established between various releases of SCT and ICD9, MeSH and ICD10. The former has a higher number of correspondences between concepts compared to latter mappings.


                     Reference change patterns. To evaluate the effectiveness of the proposed methods, we defined a set of reference change patterns as our standards. To this end, we conducted the following steps:
                        
                           •
                           We combined the considered interrelated ontologies and we randomly selected 1000 couples of attributes. We found samples in regions of the ontologies (by examining the raw log of brut changes) that have changed the most, since unchanged concepts did not allow observing our proposed change patterns. We defined the size of our sample in accordance with the involved experts, taking into account their availability for our experiments. We explained to the experts the difference between lexical and semantic change patterns and for each category the definition of each instance of change patterns. One attribute of each couple comes from a source concept in a mapping at time j and the other attribute of the couple comes from a concept in the context of the source concept at time j
                              +1. We chose these couples based on the similarity between the attribute values, excluding attributes with very low similarity and unchanged attributes at time j
                              +1.

We invited three ontology engineering experts who are familiar with several biomedical subfields to evaluate all selected couples of attributes to assign their answer regarding LCP and SCP. They have been working in the biomedical field for 5–10 years and have thorough experience with terms in biomedical ontologies. The number of involved evaluators has been motivated by recent studies [34]. We supported the evaluators with a software tool suited to present additional information regarding each attribute. The tool presents the couples of attributes along with concepts in the context of the source concept of a mapping, the attributes denoting concepts, the changes affecting attributes, etc. We gave instructions on the purpose and idea of the different patterns, and recorded the answers for each evaluator separately.

They performed one round of evaluations and we merged the agreement answers. The biomedical domain experts collaborated and re-evaluated a second round with the disagreement part of couples only. We merged the final agreement couples for both LCP and SCP with the respective correct answers according to the evaluators. We achieved an average agreement rate of 86% for LCP and SCP. Finally, in our experiments, we retained 675 pairs of attributes which had the consent of all evaluators with either the same LCP or SCP.

To evaluate the effectiveness of our change pattern algorithms (cf. objective 1), we computed the standard metrics of Precision, Recall and F-measure based on the reference change patterns as input. As the objective 1 can be seen as a problem of retrieving instances of change patterns in a corpus of documents, we measured the benefits of the proposed methods with standard metrics commonly used in the areas of information retrieval and natural language processing.

Therefore, given a pair of attributes from the reference set, we used our recognition algorithms to identify lexical and semantic change patterns for the attribute at time j. We compared the outcome with the adequate answer in the gold standard (type of CPs and attribute in time j
                     +1), calculating the evaluation metrics. In this way, we involved human experts in the evaluation only once, when constructing the reference change patterns. Specifically, we computed the Precision as the number of correctly identified CPs by the algorithms, in contrast with the expected ones evaluated in the set of reference change patterns, over the total number of identified CPs:
                        
                           (14)
                           
                              Precision
                              =
                              
                                 
                                    #
                                    correctly
                                       
                                    identified
                                       
                                    CP
                                 
                                 
                                    #
                                    identified
                                       
                                    CP
                                 
                              
                           
                        
                     
                     Recall was computed as the number of correctly identified CPs over the total number of relevant/expected CPs in the set of reference:


                     
                        
                           (15)
                           
                              Recall
                              =
                              
                                 
                                    #
                                    correctly
                                       
                                    identified
                                       
                                    CP
                                 
                                 
                                    #
                                    relevant
                                       
                                    CP
                                 
                              
                           
                        
                     
                     F-measure was computed as the harmonic mean of precision and recall.


                     
                        
                           (16)
                           
                              F
                              -
                              measure
                              =
                              
                                 
                                    2
                                    ×
                                    precision
                                    ×
                                    recall
                                 
                                 
                                    precision
                                    +
                                    recall
                                 
                              
                           
                        
                     We measured these metrics separately for each type of lexical and semantic change patterns. We explored traditional string-based similarity metrics (the bi-gram measure) when calculating the similarity between attributes in Algorithm 1. We selected this metric as the default similarity because it performs well on ontology matching [35], but we kept it as a parameter in our prototype. We calculated the bi-gram similarity by using the Dice coefficient 
                     [36], which is twice the number of matching bi-grams between two words 
                        
                           w
                           x
                        
                      and 
                        
                           w
                           y
                        
                      divided by the sum of the number of bi-grams in word 
                        
                           w
                           x
                        
                      and the number of bi-grams in word 
                        
                           w
                           y
                        
                     .

We investigated the influence of the thresholds γ and τ (for word intersections and attribute value similarity, respectively) in the CP identification algorithms. We aimed to observe adequate values that can boost the performance of our algorithms for these variables.

The definition of LCPs included the threshold γ mostly to differentiate Total copy and Total Transfer from Partial Copy and Partial Transfer. The threshold γ contributes to make our defined CPs more flexible. Practical examples can illustrate the advantages of assigning the value γ different of 1. For instance, the attribute “diabetes type 1
                     ” can be considered as a Total Copy of the attribute “diabetes type I
                     ”, even though they are not totally exact, thus reducing possible cases of false-negative in the identification method.

Our research expects to determine the real impact that each threshold performs on the effectiveness of the change pattern recognition algorithms. For this purpose, we analyzed the CP identification performance by varying the thresholds from 0 to 1 with a step of 0.05 to observe the performance of our algorithms. We used a two-step procedure to evaluate the effects of the threshold values.

First, we evaluated the impact of the threshold γ in the identification of LCP by analyzing Total Copy and Total Transfer. Considering that a Total Copy or Transfer refers to the copy or the transfer of almostly the whole content of an attribute value from a concept 
                        
                           c
                           k
                           0
                        
                      to another concept 
                        
                           c
                           cand
                           1
                        
                     , we infer that the most adequate value for the threshold γ must remain high, but we intend to investigate the minimum γ value that assures a reliable performance of the algorithms. We also notice that to characterize a Total Copy or Total Transfer, it must require a high degree of similarity (τ). However, we assume that high values of γ can compensate low values of τ. In fact, as Total Copy and Total Transfer require a high degree of similarity, the value of γ will be much more important than τ. Therefore, in a first step, we conduct the experiment setting with τ
                     =0 (the minimal value of similarity) and vary the γ value to evaluate our algorithms. We use a similar approach to determine the γ value for Equivalence in SCP identification, since the γ might strongly influence this type of SCP. We can only determine the value of γ by examining the type of SCP where τ expresses no significant impact (i.e., for Equivalence type). Table 6
                      presents the analysis outcomes of the three relevant cases for determining γ.

Secondly, this experiment also performed the impact analysis of the threshold τ in the lexical change patterns identification by using Partial Copy and Partial Transfer as a reference (inverse procedure of step one). Since the first step can determine the most adequate value for γ, this experimental step fixed the γ value with the found threshold (from step one), and varies the τ value in order to determine its value and that does not decrease the performance of the algorithms. The definition of SCPs also uses the threshold τ; we thus investigate the impact of its value for the identification of the SCPs based on Less Specific, More Specific and Partial Match.

In the following, we report on the obtained results. We first present the findings concerning LCPs recognition (Section 6.1) and afterward SCPs recognition (Section 6.2).


                        Table 6 presents the effectiveness of the LCP identification algorithm in terms of Precision, Recall and F-measure for the first step of the experiment, by varying the threshold γ and setting τ to 0. According to the used metrics, we observe that the best value found for γ is 0.9. We also conducted other analyses with values of τ
                        >0, but they failed to reveal any significant difference from the values presented in Table 6. We can also determine the role of τ by analyzing the results depicted in Fig. 2
                        , where low τ values do not impact the performance of the algorithm for Total Copy and Total Transfer.

In the second step of the experiment, we investigated the most appropriate value for τ. Fig. 2 presents the results with γ
                        =0.9 (according to results of the first step) and varying the τ coefficient. We expected, with this analysis, to find a minimal value of τ that assures a good performance of Algorithm 2 with respect to the reference change patterns (i.e., by reducing or avoiding false-positive cases). In fact, Fig. 2 shows that the performance of the algorithm remains the same when the value of τ is inferior to 0.7 for Partial Copy and Partial Transfer and to 0.85 for Total Copy and Total Transfer. The τ presents a negative impact (increasing the number of false-negative) when its value is higher than the described thresholds. We also noticed that the analysis of Partial Transfer was compromised because the number of observed cases is too low. Thus our conclusion regarding the τ mostly relies on the other types of change patterns.

These results reflect the way the gold standard was generated. Discussions with domain experts who participated in the generation of reference change patterns highlight their decision process, which influences the observed results with respect to the τ. Indeed, the experts assigned at least one LCP (mostly in Partial Copy and Partial Transfer) if there is at least one word in common between the involved attribute values. This indicates that at least a minimal similarity between the attributes must exist, which is compatible with the obtained results.

Since we conducted this experiment based on the reference change patterns, understanding the impact of τ under the mapping adaptation viewpoint requires further studies. In this context, we need to evaluate whether the identification of an adequate mapping adaptation action requires a minimum τ value (Section 7). Considering only the obtained results from this section, we underline that only γ plays a relevant role in the identification of lexical change patterns.

The analysis for semantic change patterns follows the same procedure we used for the lexical change patterns. Similarly to LCP, Table 6 (right side) shows that the most adequate and minimum value of γ for the Equivalent SCP refers to 0.9, which expresses reasonable performance in terms of F-Measure. This assures a good performance of the Algorithm 3.


                        Fig. 3
                         presents the impact of τ when γ is set to 0.9 in the identification of semantic change patterns. We observe that the τ value does not impact the Equivalent. The analysis of τ shows that low values have no impact on the identification of SCPs and high values (τ
                        >0.7) have a negative impact (i.e., similar conclusions were obtained with the LCPs analysis). In this case, when we set the similarity threshold, between the attribute values too high, it is likely that the algorithm determines an Equivalent SCP type, which decreases the performance of the other types of SCP.

To evaluate the potential utility of change patterns for mapping adaptation (cf. objective 2), we computed the number of each type of lexical and semantic change pattern identified for different behaviours of mapping adaptation. We express these behaviours as Mapping Adaptation Actions (MoveM, DeriveM, RemoveM, ModifyR, and NoAction) [6]. Table 7
                      presents the mapping adaptation actions and their formalization, and in the conducted analysis the NoAction corresponds to the cases where mappings are unchanged. We use the whole set of mapped concepts from all studied ontologies combined as input in this experiment.

We expected to observe possible interdependencies between adaptation actions occurring between both two consecutive versions of mappings and the change patterns identified by our algorithms. Therefore, we measure the utility of change patterns by the fact that correlations are detected between the types of change patterns and the mapping adaptation actions according to the absolute number of change patterns recognized. We conducted the following procedure to investigate this objective:


                     
                        
                           •
                           
                              Calculation of diff. Firstly, we identify a set of concept changes in ontology (namely 
                                 
                                    diff
                                    C
                                 
                                 (
                                 
                                    O
                                    x
                                    1
                                 
                                 ,
                                 
                                    O
                                    x
                                    2
                                 
                                 )
                              ) using two different releases of the same ontology O
                              
                                 x
                              . We use the COnto-Diff tool [9] which calculates the different ontology change operations (OCOs) between two consecutive releases of an ontology (we used SCT, ICD9CM and MeSH in our experiments). The diff helps to identify the mappings impacted by ontology evolution (next step). Additionally, in the context of change pattern identification, we particularly paid attention to two change operations in diff, namely addA and chgAttValue, because they represent the basic conditions for any change pattern recognition. In particular, these change operations enable us to understand if an attribute in the context of a particular concept is newly added or was modified. For instance, before evolution the SCT had the concept code ‘422338006’ with the name equal to “senile macular retinal degeneration” which was removed after evolution.


                              Selection of mappings impacted by ontology changes. Given all correspondences between SCT and ICD9 (resp. between MeSH and ICD10), we selected only those affected by some ontology changes in diff. From our analysis, we removed unaffected mappings (i.e., the source concepts are unchanged) because we aimed to study the influence of change patterns on how mappings evolve. We studied the evolution of both source and target ontologies involved in mappings, but we considered that only one ontology evolved at time j to assure consistency in our experiments and to avoid misunderstandings on the results’ analysis. We must be sure that a modification applied to a mapping is only motivated by one of both concept evolutions. Therefore, we also removed mappings where the diff affects both source and target concepts of mappings at the same time.


                              Computation of mapping adaptation actions (MAAs). For each mapping impacted by ontology changes, we determined the corresponding MAAs. For instance, a mapping can be moved and have the relation modified (i.e., for the same mapping we can have more than one MAA). We constructed a method to calculate the MAAs given a mapping at time j and j
                              +1. It compares the elements of the mapping at j (identifier of source and target concept, and relation) with the elements of the mappings at time j
                              +1. When all elements of the mapping remain equal over time, then the MAAs is NoAction. If the target concept does not change, but the source concept changes to a concept in the context of the original source concept, the method identifies a MoveM (if the considered mapping was removed at j
                              +1) or a DeriveM (otherwise). The RemoveM is identified if, and only if, no new mapping exists at time j
                              +1 linking a concept from the context of the source concept with the target concept. For instance, in the first release of mappings between SCT and ICD9 we find the mapping between“primary malignant neoplasm of intrahepatic bile ducts (disorder)”, and with the semantic type ≡ linking to the ICD9 concept named “malignant neoplasm of Intrahepatic bile ducts”. In the second release this mapping is no longer found, which indicates a RemoveM action.


                              Identification of relevant attributes. For each source concept of an impacted mapping, we identified the relevant attributes. We have previously designed and evaluated an algorithm for identifying the most relevant concept attributes aiming to better interpret mappings [11]. Given a mapping m
                              
                                 st
                               between two concepts 
                                 
                                    c
                                    s
                                 
                                 ∈
                                 C
                                 (
                                 
                                    O
                                    S
                                    0
                                 
                                 )
                               and 
                                 
                                    c
                                    t
                                 
                                 ∈
                                 C
                                 (
                                 
                                    O
                                    T
                                    0
                                 
                                 )
                              , the proposed algorithm, namely getTopA(m
                              
                                 st
                              ), retrieves the minimum set of source concept attributes consisting of the most similar to the ones in the target concept. In this analysis, we set the number of relevant attributes to three representing the most meaningful attributes for a given mapping. Since a concept may be the source concept of more than one mapping, the relevant attributes are specific to one mapping and can therefore differ from one mapping to another. For example, among all attributes characterizing the concept identified by code ‘422338006’ in SCT, the attribute with value “senile macular retinal degeneration” stands for the attribute with the highest similarity with those attributes in the concept of ICD9.


                              Recognition of change patterns. For each retrieved relevant attribute from a source concept c
                              
                                 k
                               of the impacted mappings, we identified lexical and semantic change patterns if they exist, using Algorithms 2 and 3 and considering the candidate attribute 
                                 
                                    a
                                    q
                                    1
                                 
                               of the concept 
                                 
                                    c
                                    cand
                                    1
                                 
                               in the context 
                                 CT
                                 (
                                 
                                    c
                                    k
                                    1
                                 
                                 )
                              . We calculated the total number of identified LCPs and SCPs for each type of pattern for the different MAAs. When no (lexical or semantic) change pattern was found for the whole set of relevant attributes, we counted no−lcp and no−scp, respectively. In these cases, we also counted the frequency of no changes in diff affecting the concepts in the context. This allows us to observe when the algorithms fail to find change patterns because the context of the source concept of the mapping remains unchanged. This enables us to thoroughly understand the updating process of mappings and to identify potential correlations between MAAs and the change patterns. We defined the threshold of τ and γ based on the results of the first experiment. For the word comparison threshold (γ), we used the results of Section 6.1 (i.e., γ
                              =0.9). For the similarity value (τ), as indicated in the previous analyses, this threshold does not impact the change pattern identification whether τ
                              <0.8 (based on reference change patterns); we evaluated the correlation between CPs and MAAs for all values of τ in the range [0: 0.8] (with a step of 0.1). For clarity reasons in this article, we selected two τ values (0.2 and 0.7) to illustrate the obtained results and to support our conclusions.


                              Measurement of positive and negative impact. We intend to analyse in more detail two MAAs: MoveM and DeriveM. This step aims to investigate whether our change pattern recognition algorithms allow us to correctly identify the concepts involved in these actions. For MoveM and DeriveM actions, a concept 
                                 
                                    c
                                    obs
                                    1
                                 
                               in the context of the source concept in the original mapping plays a major role (cf. 
                              Table 7). The concept 
                                 
                                    c
                                    obs
                                    1
                                 
                               becomes the source concept of the adapted mapping when observing MoveM and DeriveM actions. Therefore, we calculated the frequency of cases where the algorithms identified LCPs and SCPs with attributes issued from 
                                 
                                    c
                                    obs
                                    1
                                 
                              , and we considered as positive impact of change pattern if the concept candidate 
                                 
                                    c
                                    cand
                                    1
                                 
                               is equal to 
                                 
                                    c
                                    obs
                                    1
                                 
                              . An example of negative impact is illustrated in Fig. 4
                              , where a MoveM happens from the concept 
                                 
                                    c
                                    s
                                    0
                                 
                               to 
                                 
                                    c
                                    obs
                                    1
                                 
                              , but an attribute from 
                                 
                                    c
                                    s
                                    0
                                 
                               has CPs with an attribute from 
                                 
                                    c
                                    cand
                                    1
                                 
                                 ≠
                                 
                                    c
                                    obs
                                    1
                                 
                               (i.e., the algorithm recognizes the right CP but with a wrong candidate concept according to the observed mapping evolution).


                              Analysis of the similarity threshold (τ) impact. We compute some measures to compare results with respect to the number of detected correlations when applying the recognition algorithm with different coefficients of τ. We computed: (1) analyzed attributes coverage and (2) positive impact increase. We calculated (1) as follows:


                              
                                 
                                    (17)
                                    
                                       Coverage
                                       =
                                       
                                          
                                             #
                                             identifiedCorrelations
                                          
                                          
                                             #
                                             analysedAttributes
                                          
                                       
                                    
                                 
                              
                           

We calculated the positive impact increase as follows:
                                 
                                    (18)
                                    
                                       PositiveIncrement
                                       =
                                       
                                          
                                             #
                                             positiveImpact
                                          
                                          
                                             #
                                             identifiedCorrelations
                                          
                                       
                                    
                                 
                              
                           

In the following, we present the achieved results related to the second evaluation objective. Table 7 presents the number of observed MAAs in this study by combining the three ontology datasets and their associated mappings. Section 7.1 reports on the results of impact of lexical change patterns on mapping adaptation, and Section 7.2 on the semantic change pattern.

This experiment investigates correlations between MAA and LCPs. We also evaluate the capacity of the LCP algorithm to correctly identify to which concept the mapping will be associated when the MoveM and DeriveM actions are applied. To specifically present these results, Tables 8 and 9
                        
                         include two indicators “positive impact” (represented by the symbol ▴), which indicate that our algorithm recognized the adequate concepts for MoveM and DeriveM and “negative impact” (represented by the symbol ▿), which indicates that the algorithm fails to find the adequate concept, i.e., 
                           
                              c
                              obs
                              1
                           
                        . Note that we conducted this analysis by considering the whole set of mapped concepts as initial input, and did not constrain the set by the number of cases in the gold standard (used to determine the value of γ). Also, we no longer contrasted the identified change patterns in this analysis with those of the gold standard.


                        Table 8 presents the obtained results when running Algorithm 2 with γ
                        =0.9 and τ
                        =0.7. This highlights that correlations exist between LCPs and MAAs. However, these correlations are complex to accurately describe, due to the fact that we observe each LCP type at least once for each MAA. Despite this fact, these results globally allow highlighting interesting aspects.

When analyzing MAAs, we observe the following aspects:
                           
                              •
                              
                                 MoveM is more frequently associated with Total Transfer and Total Copy.


                                 DeriveM is more frequently associated with Total Copy and Partial Copy.


                                 ModifyR is more frequently associated with Partial Copy.


                                 RemoveM and NoAction are more frequently associated with noLCP.

When analyzing the different types of LCPs, we point out the following findings:
                           
                              •
                              
                                 Total Transfer has a strong correlation with MoveM.


                                 Partial Transfer remains well distributed between MAAs, but the predominance is MoveM and NoAction.


                                 Total Copy is strongly associated with MoveM, DeriveM as well as NoAction.


                                 Partial Copy is the most frequent case and is well distributed between MAAs with predominance to DeriveM.

Overall, LCP identification algorithm yields positive impact more frequently than a negative one for MoveM and DeriveM. This suggests that identifying LCPs appears useful to determine a MoveM or a DeriveM in mapping adaptation.

The number of RemoveM and ModifyR actions decreases compared to the number of MoveM and DeriveM. When adapting mappings with RemoveM and ModifyR actions, Algorithm 2 identifies very few LCPs. This suggests that if any LCP is found, it can be more convenient to adapt mappings by removing them or by modifying the semantic relation instead of applying MoveM or DeriveM actions.

When we observe NoAction for the impacted mappings, a similar scenario occurs compared with RemoveM and ModifyR actions. However, MAAs other than NoAction are applied in a smaller part of the mappings impacted by ontology change operations, i.e. NoAction occurs much more frequently (cf. 
                        Table 7). The high number of NoAction occurrence ( 95%), when noLCP cases are observed, shows the relevance of our approach to reduce human effort to maintain mappings. The algorithm positively fails to identify LCPs in most of the cases where the corresponding mappings remain unchanged.

This study indicates that LCPs remain useful in supporting the decision process of MAA selection to maintain mappings up to date. However, it requires refinements to evaluate dependencies between attributes from the same concept containing LCP (instead of considering them independently of each other).

This study also analysed the impact of the similarity threshold (τ) on the correlation between MAAs and LCPs. We present and compare two result sets: one with τ
                        =0.7 (cf. 
                        Table 8), and another with τ
                        =0.2 (cf. 
                        Table 9). Comparing the obtained findings, we observe that the number of identified correlations for MoveM (i.e., the coverage expressed in Eq. (17)) increases from 720 (38%) to 1254 (66%), but the positive impact (cf. Eq. (18)) decreases (from 58% to 50%). This underscores that for MoveM, even though the number of correlations increases, it does not improve the performance in terms of positive and negative. For DeriveM, the number of identified LCP increases from 1030 (45%) to 1560 (68%) (cf. Eq. (17)) as well as the positive impact (from 60% to 67%) (cf. Eq. (18)).

The results show that low values of τ increase the total number of identified correlations, but not the general performance of the Algorithm 2 (according to an analysis between positive and negative impact of MoveM and DeriveM). In general, we conclude that the performance of the LCP recognition algorithm, when identifying correlations between MAAs and LCPs, can be negatively affected by very high values of τ.

The analysis of correlations between SCPs and MAAs with different similarity values (τ) leads to the same findings regarding LCPs (Section 7.1). To illustrate the obtained results, Table 10
                         presents the number of SCPs identified for the different types of MAAs when τ
                        =0.7. In general, the performance of Algorithm 3 to recognize accurate SCPs in the identified correlations is good. The number of SCPs with a positive impact is always higher than negative impact (for MoveM and DeriveM actions), except for the correlation between MoveM and Less Specific. In future work, we intend to combine the results of the correlations between lexical and semantic change patterns with respect to MAAs in order to increase the performance of our algorithms to detect more positive cases.

Similar to the LCP impact analysis, the number of SCPs found is smaller for the RemoveM and ModifyR actions. These results confirm a potential sign of applying these actions when we are not able to identify SCPs. We expected to observe a higher influence of SCP on the ModifyR action. We would like to observe whether every time the type of the mapping's semantic relation changes, at least one SCP is recognized. This reinforces the findings of our previous studies, which pointed out the non-correlation between modifying the semantic relation of mappings and ontology changes, mainly because this action is applied to correct erroneous mappings in the studied datasets [4].

This section investigates whether similarity between concept attributes in different scenarios can affect observed mapping adaptation actions. In the previous sections, we highlighted the complexity of calculating similarity values and we pointed out several factors that influence its computation: similarity measures, thresholds, etc. We observed that the similarity aspect stands for an element which may help deciding adequate actions to adapt mappings. Similarity between concept attributes’ values plays a major role in our approach to identifying change patterns.

This experiment investigates whether the similarity value calculated between attributes with detected change patterns can influence the positive and negative impact of change patterns on mapping adaptation (cf. Objective 3). We quantify this influence by means of the calculated frequency of the positive and neagative impact scenarios.

We particularly emphasize the MoveM and DeriveM actions in this analysis because for applying them, difficulties in deciding on an adequate candidate concept 
                        
                           c
                           cand
                           1
                        
                      (i.e., positive and negative impact) may occur, and aside of NoAction, these actions represent the majority of MAAs between two versions of mappings (cf. Table 7). We calculate the frequency of the maximum similarity value (ranging from 0 to 1) computed between attributes of involving concepts of impacted mappings, where a change pattern is identified in the following situations:
                        
                           •
                           
                              Positive impact (
                              
                                 
                                    c
                                    cand
                                    1
                                 
                                 =
                                 
                                    c
                                    obs
                                    1
                                 
                              
                              ). When our methods recognize change patterns in a concept c
                              
                                 cand
                               where MoveM or DeriveM action is effectively applied to c
                              
                                 obs
                               (i.e., 
                                 
                                    c
                                    cand
                                    1
                                 
                                 =
                                 
                                    c
                                    obs
                                    1
                                 
                              ), we count the maximum value of similarity found between 
                                 
                                    a
                                    p
                                    0
                                 
                               and 
                                 
                                    a
                                    q
                                    1
                                 
                              . This means that the change pattern is identified in a correct candidate concept c
                              
                                 cand
                               in a MoveM or DeriveM action, compared to the reference dataset (i.e., the new version of the published mappings)


                              Negative impact (
                              
                                 
                                    c
                                    cand
                                    1
                                 
                                 ≠
                                 
                                    c
                                    obs
                                    1
                                 
                              
                              ). We count the maximum value of similarity found between 
                                 
                                    a
                                    p
                                    0
                                 
                               and 
                                 
                                    a
                                    q
                                    1
                                 
                               when our algorithms recognize change patterns in a concept c
                              
                                 cand
                               which differs from the concept c
                              
                                 obs
                              , where a MoveM or a DeriveM of mapping is observed compared to the reference dataset. Thus, the possible concept selected to receive the mapping (moved or derived) is different from the one observed (c
                              
                                 obs
                              ) in the actions.


                              Attribute in the concept of MAA (c
                              
                                 obs
                              
                              ). This is a special case of negative impact. In fact, we want to examine whether the similarity value plays a role in minimizing the negative impact. To do so, we calculated the highest similarity value between 
                                 
                                    a
                                    p
                                    0
                                 
                               and a changed attribute of 
                                 
                                    c
                                    obs
                                    1
                                 
                               where the MoveM or DeriveM is observed. Based on this analysis, if the difference of the similarity values calculated is not significant (between the negative impact and this situation), we can determine that the similarity value refers to a relevant factor (i.e., the similarities found with c
                              
                                 cand
                               and c
                              
                                 obs
                               are not divergent). Consequently, we can conclude that negative impact is highly related to the way that the similarity value is calculated. Otherwise, we can conclude that only using the threshold τ remains insufficient for improving the performance of our algorithms (i.e., determine the adequate candidate concepts based on the similarity values).


                              No change pattern identified. When algorithms failed to identify LCPs or SCPs for all relevant attributes of influenced mappings, we calculated the frequency of the highest similarity value considering this set of attributes and the whole set of changed attributes in the context of the source concept.

We used the kernel density estimation (KDE) method [37] to plot and analyze the frequency of similarity values calculated for the MoveM and DeriveM mapping adaptation actions, respectively. We analysed the density of calculated similarity values ranging from 0 to 1. The density stands for a smoothing distribution of frequencies of the similarity values similar to a histogram. KDE refers to a particular non-parametric technique to estimate the underlying probability density function of a random variable as a weighted average of local functions centered at each sample point. KDE allows observing the general behaviour of the calculated similarity values to further explain the influence of the CPs on the ways mappings change.


                     Results on the similarity values distribution in lexical and semantic change patterns. Fig. 5
                      shows the KDE of similarity values measured with respect to positive and negative impact of LCPs in the MAAs MoveM and DeriveM. This figure also depicts the density of the highest similarity values calculated with the attributes in the concept 
                        
                           c
                           obs
                           1
                        
                      (for which MoveM and DeriveM actions are applied), and the density when no LCP is found for all relevant attributes of the mapping's source concept.

The role of similarity values in determining the correlation between MAAs and LCPs differs for DeriveM and MoveM actions. The former shows that similarity plays a relevant role. The density of positive cases are significantly superior to the negative ones. Moreover, when negative impact occurs, the similarity values of attributes from “correctly expected concepts” (c
                     
                        obs
                     ) are closer to the one from candidate concepts (c
                     
                        cand
                     ). Therefore, the performance of the algorithm highly depends on how the similarity value is calculated and on the set value for threshold τ.

Considering the MoveM action, the analysis of the similarity density remains less conclusive. Positive impact is much more frequent when τ
                     = 0.7 (highest density). However, by using this threshold, the algorithm will only be able to find 54% of the expected correct concepts for MoveM (in the best case) (i.e., positive_impact plus att_concept_MAA in Fig. 5). The negative impact does not remain strongly dependent on the similarity value, which requires improvement in the recognition algorithms (e.g., include other criteria to decide the candidate concept). To this end, we need to improve the approach to select candidate concepts (e.g., consider more than one candidate and other aspects for their selection in addition to the similarity).


                     Fig. 6
                      depicts the density of similarity values calculated for positive and negative scenarios of MAAs MoveM and DeriveM concerning the SCPs. In addition to these cases, we measured the highest similarity values with the concept 
                        
                           c
                           obs
                           1
                        
                      and with the whole context when the SCP identification algorithm does not find an SCP (no-scp).

Obtained results for the analysis of similarity density concerning SCPs and LCPs are quite similar. For DeriveM, τ plays an important role, but for MoveM the role of τ remains unclear. This suggests considering supplementary criteria (e.g., associating LCPs and SCPs to filter cases of negative impact) to improve the quality of the results. This issue refers to the subject of further studies.

@&#DISCUSSION@&#

The size of the life science ontologies as well as their dynamics make their alignment and maintenance hardly processable by human experts, which impacts the final quality of mappings over time. In this article, our investigation claimed that finely describing changes that affect attributes of concepts involved in mappings, in addition to existing ontology change operations, may provide the necessary statements to make the appropriate decisions on mapping adaptation. We considered light-weight ontologies such as taxonomies or terminologies. Additional research is requested to deal with the complexity of more elaborated semantic web ontologies described with logic-based languages like OWL.

From a more pragmatic point of view, the extensive use of ontologies and their associated mappings for semantic interoperability reasons remains cornerstone to annotate electronic health record (EHR) content to facilitate its sharing and retrieval. In this context, labels of ontology concepts usually compose queries emitted by health care professionals searching for relevant information about their patients. However, the evolution of ontologies leads to the version of the ontologies used to annotate EHR content being different from the one used to query it. This mismatch between query and data will unavoidably reduce the effectiveness of search results recovered. In consequence, being able to understand and recognize the evolution of ontologies to propagate this evolution to dependent artefacts, such as mappings, will positively impact underlying clinical information systems.

Through our experiments, we first found that changes in concept attribute values can be classified according to lexical and semantic change patterns. These change patterns refine the traditional ontology change operations 
                     [9] at a finer level of granularity to characterize ontology evolution. Results pointed out the effectiveness of the proposed methods relying on similarity values (τ) and the intersection of words between attribute values (γ) to recognize more refined change patterns between biomedical ontology versions.

Secondly, we demonstrated that the proposed change patterns provide useful statements to support the mapping adaptation processes, since the defined change patterns are correlated to the majority of mapping adaptation actions. Our analysis of positive and negative impact of change patterns (for MoveM and DeriveM) indicates that our approach exploring change patterns is useful for the application of these actions. Similarly, when our method failed to identify change patterns, our experiments demonstrated that mappings remain the same (NoAction) in more than 90% of the cases. For the other 10%, our algorithms reached a good precision to identify cases where the mappings are removed (RemoveM).

Thirdly, we investigated if the similarity between concept attribute values (before and after the ontology evolution) plays a role in change pattern identifications, to select adequate mapping adaptation actions. In fact, the positive impact on mapping adaptation exists when the similarity value ranges from 0.3 to 0.8 in the recognized instances of change patterns. On the other hand, our experiments on the density of similarity values between concepts revealed that negative impact exists even if similarity values are high. Therefore, although our findings explain several factors relevant to attaining automatic mapping adaptation based on ontology changes, deeply understanding the phenomenon on how change patterns influence mapping adaptations requires further studies. Literature on ontology change patterns reveals that existing approaches which exploit change patterns dealing with ontology evolution and their definition are frequently based on ontology meta-models and languages (e.g., OWL or RDF). Although popular initiatives have added more logical formalisms to life science ontologies (e.g., Gene ontology), most of these existing ontologies are rarely fully expressed in standard formats. Thus, existing patterns are hardly usable in the most disseminated life science ontologies (e.g., MeSH, ICD, LOINC, SNOMED-CT, etc.), which still rely on simple formalisms. This is one of the main motivations for our approach (i.e., to address change patterns at the level of attribute values using linguistic-based features for identifying the diffusion and semantic state of textual values between concepts over time). In contrast to the literature, we designed our approach with the mapping adaptation problem as target. This influenced some decisions on the applied techniques and implemented experiments.

In addition, to show evidence of the quality of the results yielded by the proposed methods relying on standard evaluation metrics, our obtained findings pointed out the potential influence and the utility of change patterns to support mapping adaptation. We conducted experiments using real life science ontologies and mappings which strengthen our results. We could improve the obtained results by investigating the combination of our techniques with other approaches based on background knowledge, especially to infer the semantic relationship between successive versions of concepts, improving thus the recognition of our semantic change patterns. In this context, the use of string-based similarity metrics may create issues, which can be minimized by using domain-specific background knowledge.

Although the used datasets were extremely useful for showing the effectiveness of our change pattern recognition approach, and for finding potential correlations between change patterns and mapping adaptation, the improvement of our gold standard could point out different ways to enhance the obtained results. For example, our gold standard contained only one case of Partial Transfer, but we need more cases to further analyze this change pattern. Moreover, mappings between life science ontologies mainly contain equivalent correspondences between concepts, which compromises the analysis of the ModifyR action as well as the analysis of the SCP recognition algorithm. The reference mappings failed to allow in particular observing how semantic change patterns influence the way mappings change their semantic relation.

Future work involves several studies to refine this proposal. First, we need to further study additional criteria that may potentially impact the performance of our algorithms. This involves investigating potential dependences between relevant attributes, for instance, if two or more attributes follow the same (or a specific subset of) change pattern(s), etc.. Future studies will also evaluate the impact of other approaches to similarity measures on the quality of change pattern recognition. This remains especially relevant when improving the identification of our semantic change patterns between successive versions of related concepts. Moreover, additional evaluations must require the support of human domain experts on mappings creation/maintenance to build an improved reference corpus (gold standard) which can allow applying other techniques like machine learning to extract even more refined change patterns and correlations.

Overall results achieved in this research indicate that the proposed set of change patterns refers to a relevant evidence to guide the adaptation of mappings into a more automatic process.

@&#CONCLUSION@&#

Ontology evolution impacts existing mappings demanding their adaptation over time. Addressing the mapping adaptation problem requires understanding ontology evolution in a fine-grained way at the level of attribute values. Existing approaches to calculate ontology changes patterns do not consider the mapping maintenance as a secondary use of their outcome. Thus, implementing automatic mapping adaptation solutions requires extending existing change patterns or creating new ones. In this article, we proposed change patterns allowing to characterize ontology evolution with the specific objective of facilitating adaptation of mappings associated with concepts affected by ontology changes. We particularly designed and implemented methods to recognize the proposed change patterns between ontology versions.

The experiments we conducted with real life science ontologies and mappings assessed the effectiveness and utility of the methods for supporting adaptation of mappings. The obtained results showed a reliable performance of the recognition methods against a set of reference change patterns. Further findings revealed that our change patterns correlated with mapping adaptation actions, which evidences the benefits of exploring the suggested change patterns to guide decisions on mapping adaptation. Our study answered relevant open research questions with respect to the evolution of life science ontologies. This will help in the definition of methods to better maintain mappings affected by ontology evolution valid over time. This also plays a key role in ensuring reliable interoperability between biomedical systems over time. Our experimental evaluation allowed to discover additional untouched research questions that may be crucial for an automatic adaptation of mappings. As future work, we aim to further study factors influencing the mapping adaptation actions, to design heuristics able to make adequate decisions on how to adapt mappings as automatic as possible. This will contribute to deeply observing and understanding the influence of lexical and semantic change patterns on how mappings evolve.

@&#ACKNOWLEDGMENTS@&#


                  The National Research Fund (FNR) of Luxembourg entirely supports this work under the DynaMO research project (grant #C10/IS/786147). We thank the CISMeF team for providing one of the datasets for the experiments in this work.

@&#REFERENCES@&#

