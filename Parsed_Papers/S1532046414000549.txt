@&#MAIN-TITLE@&#Monitoring Obstructive Sleep Apnea by means of a real-time mobile system based on the automatic extraction of sets of rules through Differential Evolution

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A cheap and portable approach to monitor in real time patients with OSA is proposed.


                        
                        
                           
                           ECG data is gathered by a wearable sensor and sent to a mobile device.


                        
                        
                           
                           A set of IF…THEN rules is extracted from ECG monitored data.


                        
                        
                           
                           This set of rules can be used in our real-time mobile monitoring system.


                        
                        
                           
                           If occurrence of OSA is detected by a rule, an alarm is automatically produced.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Obstructive Sleep Apnea

Differential Evolution

Knowledge extraction

IF…THEN rules

Real-time monitoring system

Wearable sensors

@&#ABSTRACT@&#


               
               
                  Real-time Obstructive Sleep Apnea (OSA) episode detection and monitoring are important for society in terms of an improvement in the health of the general population and of a reduction in mortality and healthcare costs. Currently, to diagnose OSA patients undergo PolySomnoGraphy (PSG), a complicated and invasive test to be performed in a specialized center involving many sensors and wires. Accordingly, each patient is required to stay in the same position throughout the duration of one night, thus restricting their movements.
                  This paper proposes an easy, cheap, and portable approach for the monitoring of patients with OSA, which collects single-channel ElectroCardioGram (ECG) data only. It is easy to perform from the patient’s point of view because only one wearable sensor is required, so the patient is not restricted to keeping the same position all night long, and the detection and monitoring can be carried out in any place through the use of a mobile device.
                  Our approach is based on the automatic extraction, from a database containing information about the monitored patient, of explicit knowledge in the form of a set of IF…THEN rules containing typical parameters derived from Heart Rate Variability (HRV) analysis. The extraction is carried out off-line by means of a Differential Evolution algorithm. This set of rules can then be exploited in the real-time mobile monitoring system developed at our Laboratory: the ECG data is gathered by a wearable sensor and sent to a mobile device, where it is processed in real time. Subsequently, HRV-related parameters are computed from this data, and, if their values activate some of the rules describing the occurrence of OSA, an alarm is automatically produced.
                  This approach has been tested on a well-known literature database of OSA patients. The numerical results show its effectiveness in terms of accuracy, sensitivity, and specificity, and the achieved sets of rules evidence the user-friendliness of the approach. Furthermore, the method is compared against other well known classifiers, and its discrimination ability is shown to be higher.
               
            

@&#INTRODUCTION@&#

Obstructive Sleep Apnea (OSA) [1], or apnea for short, is a breathing disorder which can be experienced during sleep, caused by the partial or complete constriction of the patient’s upper airway. Its clinical definition involves a cessation of airflow for at least 10s, and people with OSA experience repeated breathing stops, even hundreds per night, when sleeping, each stop typically lasting around 10–30s. About 4% of the general population suffers from OSA to some extent, and it is estimated that fewer than 25% of OSA sufferers know that they suffer from the condition [2]. These undiagnosed sufferers cause in the USA 70billion dollars loss, 11.1billion in damages, and 980 deaths each year [3].

In general, assessing sleep quality and investigating the presence of OSA is important in terms of an improvement in the health of the general population and of a reduction in mortality and healthcare costs: in fact, this disorder causes hypoxemia, asphyxia, and awakenings, and has immediate consequences such as an increased heart rate and high blood pressure as well as long-term symptoms affecting quality of life such as extreme fatigue, poor concentration, a compromised immune system, slower reaction times, and cardio/cerebrovascular problems [4].

Monitoring OSA becomes crucial for people already suffering from this condition and undergoing some given medical therapies or receiving some kinds of drugs: in these cases checking side effects, such as sleep or breathing disturbances, is of paramount importance. Additionally, this monitoring is crucial in perioperative conditions [5]: when a patient is undergoing surgery, and after this has taken place, the determination of whether, and to what extent, the patient is experiencing OSA is an important task for her/his health.

Feedback for instantaneous pressure adjustments in Continuous Positive Airway Pressure (CPAP) devices is another issue in which the real-time monitoring for OSA is highly welcome, as is also the case for other associated medical treatments.

Currently, to diagnose OSA patients undergo a sleep study, known as a PolySomnoGraphy (PSG). This examination has several drawbacks [6]: it is quite complicated, since it consists in the recording of electroencephalogram, electrooculogram, electromyogram, oronasal airflow, chest wall and abdominal wall movement, oxygen saturation, and ElectroCardioGram (ECG) measurements. A drawback linked to this is that during a PSG test a patient is required to stay in the same position throughout the duration of a night because of the large quantity of leads, wires, tubes, and so on. Another problem with the current OSA tests is that they restrict the patients to a hospital environment for at least one night, sometimes two, and may produce stresses that may influence the OSA pattern itself, and the results of this monitoring activity. Moreover, PSG is costly, the national average price in the USA for example being about 2600USD [7]. Finally, there are few places to undergo PSG, meaning long waiting times.

For these reasons, simpler, cheaper, and home-based methods are highly welcome, and are currently being developed to diagnose or monitor OSA. Unlike PSG, the use of single-channel ECG measurements would greatly ease OSA monitoring. This could be paired with currently available mobile technology so as to create an easy-to-use, cheap system to carry out at the same time ECG acquisition and monitoring, and the real-time screening and assessment of OSA.

In this regard, our research has the aim of developing a simple system that provides an easy, reliable, inexpensive, transportable, and fast approach to assist OSA patients. This approach is based on the automatic extraction of explicit knowledge in the form of a set of IF…THEN rules personalized for each patient. These rules detect the occurrence of OSA episodes and contain parameters related to Heart Related Variability (HRV). They are extracted off-line starting from single-lead ECG recordings by means of a binary classification task performed by a Differential Evolution (DE) algorithm [8]
                     [9].

The paper continues as follows. A description of the state of the art in literature about OSA monitoring is reported in Section 2, with specific reference to papers dealing with ECG-related parameters. Section 3 explains the way our approach works, and compares it against the other literature approaches presented in the previous section. A detailed description of our approach to classification is given in Section 4, after a general overview on DE, which is the core of this approach. Our classification tool, called the Differential Evolution-based Rule Extractor (DEREx), is then described. It has recently been developed and used to face a set of test medical problems [10]. The performance of the proposed method is assessed on a well-known sleep apnea database, the Physionet Apnea-ECG database [11] in Section 5, where a comparison is also carried out against the performance provided by a set of fifteen other widely-used classifiers. The architecture of the monitoring system is described in Section 6 and details on the sensors and devices used are given in the same section. Our conclusions and future plans are reported in Section 7.

@&#RELATED WORKS@&#

The detection and monitoring of OSA without making use of examination carried out through the use of polysomnography is a problem that can in general be approached from several possible viewpoints. For example this task can be considered as a time series forecasting problem, an approach taken in several issues related to medicine e.g. [12–14]. However, recent scientific literature has seen the introduction of several approaches to deal with OSA by different authors, each of which relies on the evaluation of different (sets of) vital parameters, and on the binary classification of time segments of the recordings of those parameters as to whether or not they contain apnea episodes. In this paper we follow this latter approach, so in this section we make reference to papers based on this view.

Several researchers have made reference to the use of parameters related to a saturation signal of oxygen in the arteries obtained through oximetry (SpO2) measurement, as for example Oliver and Flores-Mangas [15], Xie et al. [16], and Wakchaure and Ghuge [17].

Another attempt has been carried out by considering thoracic and abdominal signals, e. g. the respiration waveform, in Ishida et al. [18]. This system uses a mobile phone to send the recorded waveform to a server located at the hospital where it is analyzed.

Research has also been carried out into the use of ElectroEncephaloGram (EEG) signals for apnea detection, as for example in Lin et al. [19], where the signals are analyzed by means of the use of both wavelet transforms and an artificial neural network (ANN).

Furthermore, in several papers sets of parameters coming from different sensors are used. For example Ng et al. [20] made use of a polysomnography device to record signals of nasal and oral airflow, pulse oximetry level, and thoracic and abdominal efforts. In 2009 Alvarez et al. [21] considered the information provided by both electroencephalogram (EEG) and blood oxygen saturation (SaO2) recordings. Rofouei et al. [22] carried out research by considering the parameters gathered by microphone, oximeter, and accelerometer. Alqassim et al. [2], instead, took into account data recorded by means of a built-in microphone and an accelerometer. Finally, Patil et al. [23] presented an OSA monitoring system based on blood oxygen saturation signals gathered by pulsioximetry systems (SpO2 and HRV).

In the remainder of this section we pay particular attention to the papers that use an approach to monitor OSA similar to ours, i.e., that consider ECG-related parameters.

One of the pioneering papers is that of Raymond et al. [24]: they presented a method of screening for OSA which combines two different kinds of information. The first comes from the ECG-derived respiration (EDR) signal, whereas the second is the RR interval tachogram. Starting from the EDR signal, a computation of power spectral features was carried out by means of the discrete harmonic wavelet transform, and the power at the respiratory frequency and at frequencies below 0.1Hz was considered.

Another method was introduced in 2003 by de Chazal et al. [25]. It is based on night time single-lead ECG recordings, screening them to look for episodes of major sleep apnea and to provide a disordered breathing analysis effected on a minute-by-minute basis. The authors took into account both a wide set of features based on heartbeat intervals and a respiratory signal derived from ECG. Furthermore, a comparison between classifiers based on linear and quadratic discriminants was performed.

More recently, Quiceno-Manrique et al. [26] have extracted the dynamic features from time frequency distributions with the aim of detecting OSA starting from ECG signals recorded while the patient was sleeping. Moreover, the authors apply a methodology aimed at achieving a measurement of the importance of each dynamic feature taken into account, before a k-nearest neighbor is used to distinguish between normal and pathological signals.

Yilmaz et al. [27] propose a method for the automatic classification of sleep stages and obstructive apneic periods based on the use of only a set of features derived from a single-lead ECG signal. Their method is based on several issues. Firstly, the computation of the beat-to-beat interval (RR interval) through the use of an R-peak detection algorithm is considered. Secondly, starting from RR interval values, the features are extracted. Finally, as the classification methods they choose a k-nearest-neighbor, a quadratic discriminant analysis, and some support vector machines.

Recently, the Apnea MedAssist system [28] has been developed by Bsoul et al. (2011) with the aim of recognizing accurately OSA episodes. Both home and hospital scenarios have been considered. The system is fully automatic: it starts with the patient’s single channel ECG taken at night time, creates ECG-derived respiration signals, and extracts sets of features from both signals. The system is implemented on smart phones running an Android operating system, and the user can choose between two different models: one is general subject-independent, whereas the other is subject-dependent. It uses segments with a length of one minute extracted from ECG signals to extract features and classify. This latter task is carried out by means of support vector machines.

Very recently Almazaydeh et al. [3] have reported on the design and implementation of an automated classification algorithm which is based on support vector machines and is used to process short time intervals taken from ECG data.

Our research has the aim of developing a simple system that provides an easy, reliable, inexpensive, transportable, and fast approach to monitoring OSA in patients, for example before, during and after medical treatments. In fact, our system is better suited to the monitoring of some specific patients who are already known to suffer from OSA, rather than to the screening of a large group of individuals for the purpose of identifying those who suffer from it.

Specifically, to execute the apnea event detection task, we have designed a rule-based approach relying on single-lead ECG data analysis only. The reason why we have used ECG data only is that when we started to investigate real-time OSA monitoring, we searched for publicly available databases. The best one that we could find was Apnea-ECG, which contains ECG data only. Had it contained data related to other vital parameters we could have used them as well: our system has sensors for and so can detect such other parameters, and the physical meaning of the parameters contained in the database is transparent to the DEREx classifier, since it deals with numbers that could represent whatever is needed.

Our approach consists of two phases.

The first phase involves patient diagnosis and knowledge extraction, and is carried out off-line. A patient is given a wearable ECG sensor and a mobile device by her/his doctors, and is asked to wear the sensor during one night at home. The monitored data is locally sent via Bluetooth to the mobile device which records it. On the following day the sensor and the mobile are returned to the doctors. In the following days the doctors annotate the ECG recording with reference to the OSA episodes. Thanks to the annotations, binary supervised classification can be carried out of each minute as OSA or non-OSA. At the same time knowledge on that patient is automatically extracted off-line and represented in the form of an explicit set of IF…THEN rules containing typical parameters derived from Heart Rate Variability (HRV) analysis.

HRV is the physiological phenomenon of variation in the time interval between heartbeats, and is measured by the variation in the beat-to-beat interval. Rule extraction is carried out by means of a Differential Evolution [8,9] algorithm. Subsequently, this set of rules is loaded into a Decision Support System contained in the monitoring system [29] developed at iHealthLab (ICAR-CNR) [30] installed on the mobile device, and this latter is given again to the patient together with the wearable ECG sensor.

The second phase consists in patient monitoring and is carried out in real time. Every night, even for long time periods, or whenever necessary, and wherever she/he is, the patient sleeps while wearing the ECG sensor, and the recorded data is sent locally to the mobile device. However, this now acts as a real-time monitoring system: it receives the data, elaborates it, and computes the values of the set of parameters related to the HRV that are contained in the set of rules personalized for her/him. If the values of these parameters activate at least one of the rules describing the occurrence of an OSA episode, the monitoring system becomes aware that an apnea episode is taking place, and can consequently take immediate action, such as for instance waking up the patient, or sending an alert to medical personnel.

Each patient will have her/his own set of rules, and different patients could be represented by (even very) different sets of rules. This means personalized healthcare for each OSA patient.

With respect to existing literature, we feel our approach is well positioned and competitive. In fact, it has at least one innovative feature more than any of the above described approaches. To better understand this, we will firstly list the main features of our proposed system, and then contrast them with those of the other methods.

Firstly, our approach is easy to perform from the patient’s point of view because it does not require many sensors and wires, and the patient is not required to keep the same position all night long. Fig. 1
                      shows the comfortableness of our approach compared to classic examinations such as PSG.

Secondly, the whole process of ECG processing, feature computation, and 1-min segment classification is implemented on a mobile device, and therefore testing and monitoring can be performed everywhere.

Thirdly, our system aims at identifying in real time the occurrence of an OSA episode, so that consequent actions can be immediately taken to provide the patient with the appropriate care.

Fourthly, and most importantly, the decision about whether or not OSA is taking place is based on knowledge automatically extracted from the patient’s history and represented in the form of an explicit set of IF…THEN rules. This set of rules, extracted off-line, can be used in real time for that patient.

Fifthly, as a consequence of the previous point, each patient will have her/his personalized set of rules, and different patients could be represented by (even very) different sets of rules. In fact, we feel that the way OSA manifests itself in a patient is, in general, specific for that patient, and quite different from that of other patients, in terms of different values for the monitored parameters.

Our approach distinguishes itself from most others here described because it makes use of mobile devices. Although several other proposals also use mobile devices for OSA, each of them lacks some of the features of our system. For example, [2,18] use the mobile only to gather data and send it to a hospital server where the analysis is performed. The systems proposed in [15,17,22,23], instead, lack an Action Layer allowing the performance of immediate actions. Moreover, they all detect apnea episodes based on general knowledge rather than on rules specific for each patient.

In this way we feel we have designed a user-friendly system whose behavior can be easily understood and checked, unlike most other systems which do not provide any intelligible knowledge to the doctors.

This section describes the general idea underlying our approach to classification in a given database. It should be pointed out here that we rely on an approach based on rule learning. Several such approaches exist in scientific literature, too numerous to be listed here. The interested reader can make reference to [31], where a good review is reported.

For us each individual in the DE population represents a set of rules; each rule makes reference to a class, and in the set there should be at least one rule covering each class. For each class more than one rule can be present, if the algorithm finds it necessary to improve classification performance.

Each such set of rules competes with as many other sets of rules as there are individuals in the DE population.

In this paper all the rules contained in a set used for the classification are found all at once in one step. In other approaches instead, such as for example [32] the algorithm is executed once for each class in the database and one rule is achieved for that class.

In each rule the antecedent only has logical ANDs, so the whole rule is a disjunction, i.e. it is in the AND form. Actually all the rules making reference to a same class can be seen as logically connected in OR; this results for each database class in one logical rule containing both AND and OR connectors.

Our approach relies on supervised learning, so a database is divided into two sets: a training set and a testing set. The learning phase yields as-good-as-possible sets of rules through training on the former set, while the generalization ability of the best set of rules achieved in training is evaluated on the latter set. A well known drawback of this two-set approach is that classification accuracy results may depend on the specific division of samples making up the database in the two sets. Therefore, to be as independent as possible from this artificial division, a ten-fold cross-validation mechanism is used.

Since our approach to classification relies on a DE algorithm, in the next subsection we will describe this. Then, details are given in the next subsections about the Differential Evolution-based Rule Extractor (DEREx) tool [10] we have recently developed. In particular, the two subsections describe respectively the way in which a set of classification rules is encoded in a DEREx individual, and the way in which the quality of such a set of rules is evaluated by DEREx.

DE is a stochastic algorithm designed to face multivariable optimization problems [8,9]. Its original use consisted in finding the optimal combination of values for real-valued multiparameter functions. Its way of representing possible solutions to a given problem consists in vectors of real numbers. Given a problem, DE works with a set, called a population, of possible solutions, each of which is referred to as an individual. Each individual is actually a vector of real values, and the set of values contained in it is said to be the individual’s genotype. Each individual solves the problem with a higher or a lower degree of effectiveness: an objective function, often called the fitness function, expresses quantitatively how good a solution is.

To face a multivariable optimization problem with a number of NG
                         real parameters, DE starts by randomly generating an initial population. This is composed of a number of NPop
                         individuals, each of which consists of NG
                         real-valued genes. Each individual in the initial population is initialized randomly: each of its fields is given a random real value in the admissible range for that field.

Then, an iteration phase takes place which represents the generations in the natural evolution: when going from one generation to the next the population is modified through some transformations. Many possible transformation schemes exist. Price and Storn decided to name any DE strategy by means of a three-field string as ind/num/cro. In this, ind is an alphabetic string designating the specific vector in the current population to be modified (best
                        =the best individual, rand
                        =a randomly chosen one, rand-to-best
                        =a randomly chosen one, but also the current best takes part in the modification), num is the number of difference vectors (i.e. the vectors obtained by computing the difference between two individuals in the current population) used to perturb ind (either 1 or 2), and cro is the type of crossover (exp
                        =exponential, bin
                        =binomial) which is applied to create the new individual. Ten different DE variants have been designed by Price and Storn and are used in the literature. The interested reader can find detailed information about these in [33,34]. One of these ten strategies, i.e. that denoted with rand-to-best/1/bin, has been used for the experiments described within this paper. This choice has been made because in a preliminary activity aimed at facing a wide set of test-bed medical databases all the ten known DE variants were used [10], and the experimental results together with statistical analysis showed that this strategy was the best performing on average over that set of databases.

The specific way in which a new population is created in rand-to-best/1/bin is described in the following paragraphs. To create the generic i-th individual for the new population, the i-th individual in the current population xi
                        
                        =(xi
                        
                        ,1,
                        xi
                        
                        ,2,…,
                        xi
                        
                        ,
                        
                           NG
                        ) is considered, and two integer numbers r
                        1 and r
                        2 in [1,…,
                        NPop
                        ] differing from each other and different from i are randomly generated. Moreover, another integer number s in the range [1,
                        NG
                        ] is randomly chosen.

Then, a new trial individual 
                           
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                                 
                                    ′
                                 
                              
                           
                         is generated whose generic j-th component is computed as:
                           
                              
                                 
                                    
                                       x
                                    
                                    
                                       
                                          
                                             i
                                          
                                          
                                             ′
                                          
                                       
                                       ,
                                       j
                                    
                                 
                                 =
                                 
                                    
                                       x
                                    
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 +
                                 F
                                 ·
                                 (
                                 
                                    
                                       best
                                    
                                    
                                       j
                                    
                                 
                                 -
                                 
                                    
                                       x
                                    
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 )
                                 +
                                 F
                                 ·
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       
                                          
                                             r
                                          
                                          
                                             1
                                          
                                       
                                       ,
                                       j
                                    
                                 
                                 -
                                 
                                    
                                       x
                                    
                                    
                                       
                                          
                                             r
                                          
                                          
                                             2
                                          
                                       
                                       ,
                                       j
                                    
                                 
                                 )
                              
                           
                        subject to one of the two following conditions: either a real number ρ randomly generated in [0.0,1.0] is lower than a value CR (crossover ratio, parameter of the algorithm, ranging in [0.0, 1.0]), or the position j being modified is equal to s. If neither condition is true then a copy is carried out: 
                           
                              
                                 
                                    x
                                 
                                 
                                    
                                       
                                          i
                                       
                                       
                                          ′
                                       
                                    
                                    ,
                                    j
                                 
                              
                              =
                              
                                 
                                    x
                                 
                                 
                                    i
                                    ,
                                    j
                                 
                              
                           
                        . In the above equation xi
                        
                        ,,
                        
                           j
                         is the value contained in the j-th component of xi
                        , and so are 
                           
                              
                                 
                                    x
                                 
                                 
                                    i
                                    ,
                                    j
                                 
                                 
                                    ′
                                 
                              
                           
                         for 
                           
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                                 
                                    ′
                                 
                              
                           
                        , xr
                        
                        1,
                        
                           j
                         for xr1
                        , xr
                        
                        2,
                        
                           j
                         for xr2
                        , and bestj
                         for best, that is the best individual in the current population. The parameter F (mutation factor or scale factor) is a real-valued constant.

Next, a comparison takes place between this newly obtained trial individual 
                           
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                                 
                                    ′
                                 
                              
                           
                         and the i-th individual in the current population xi
                        . The best between them is copied into the i-th position of the new population. This scheme is iterated until a maximum number of generations Gen is performed.

Algorithm 1 shows this DE scheme with reference to a maximization problem. In it xi
                         represents the generic i-th individual in the current population and Φ(xi
                        ) is its fitness value representing the quality of this solution. Instead, xi
                        
                        ′ is the corresponding trial individual and Φ(xi
                        
                        ′) is its fitness value.
                           
                              
                                 
                                 
                                    
                                       Algorithm 1. The Differential Evolution algorithm used in this paper.
                                    
                                    
                                       
                                          begin
                                       
                                    
                                    
                                       
                                          
                                          randomly initialize population
                                    
                                    
                                       
                                          
                                          evaluate fitness Φ of all individuals
                                    
                                    
                                       
                                          
                                          while (maximal number of generations Gen is not reached) do
                                       
                                    
                                    
                                       
                                          
                                          
                                          begin
                                       
                                    
                                    
                                       
                                          
                                          
                                          
                                          for 
                                          i
                                          =1 to 
                                          NPop
                                           
                                          do
                                       
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          begin // create a new individual xi
                                          
                                          ′ by using rand-to-best/1/bin
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          
                                          n
                                          =random (1, NG
                                          )
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          
                                          for 
                                          j
                                          =1 to 
                                          NG
                                           
                                          do
                                       
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          
                                          
                                          begin
                                       
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          
                                          
                                          
                                          if
                                       
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          
                                          
                                          
                                          (random (0.0, 1.0)<
                                          CR) OR (j
                                          =
                                          NG
                                          )
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          
                                          
                                          
                                          
                                          
                                          
                                             
                                                
                                                   
                                                      x
                                                   
                                                   
                                                      
                                                         
                                                            i
                                                         
                                                         
                                                            ′
                                                         
                                                      
                                                      ,
                                                      j
                                                   
                                                
                                                =
                                                
                                                   
                                                      x
                                                   
                                                   
                                                      i
                                                      ,
                                                      j
                                                   
                                                
                                                +
                                                F
                                                ·
                                                (
                                                
                                                   
                                                      best
                                                   
                                                   
                                                      j
                                                   
                                                
                                                -
                                                
                                                   
                                                      x
                                                   
                                                   
                                                      i
                                                      ,
                                                      j
                                                   
                                                
                                                )
                                                +
                                                F
                                                ·
                                                (
                                                
                                                   
                                                      x
                                                   
                                                   
                                                      
                                                         
                                                            r
                                                         
                                                         
                                                            1
                                                         
                                                      
                                                      ,
                                                      j
                                                   
                                                
                                                -
                                                
                                                   
                                                      x
                                                   
                                                   
                                                      
                                                         
                                                            r
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                      ,
                                                      j
                                                   
                                                
                                                )
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          
                                          
                                          
                                          
                                          else
                                       
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          
                                          
                                          
                                          
                                          
                                          
                                             
                                                
                                                   
                                                      x
                                                   
                                                   
                                                      
                                                         
                                                            i
                                                         
                                                         
                                                            ′
                                                         
                                                      
                                                      ,
                                                      j
                                                   
                                                
                                                =
                                                
                                                   
                                                      x
                                                   
                                                   
                                                      i
                                                      ,
                                                      j
                                                   
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          
                                          
                                          n
                                          =
                                          n
                                          +1
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          
                                          
                                          if
                                       
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          
                                          
                                          
                                          n
                                          >
                                          NG
                                          
                                       
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          
                                          
                                          
                                          
                                          n
                                          =1
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          
                                          end
                                       
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          if
                                       
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          Φ (xi
                                          
                                          ′)⩾
                                          Φ (xi
                                          )
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          
                                          insert 
                                          xi
                                          
                                          ′ in the new population
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          else
                                       
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          
                                          insert 
                                          xi
                                           in the new population
                                    
                                    
                                       
                                          
                                          
                                          
                                          end
                                       
                                    
                                    
                                       
                                          
                                          
                                          end
                                       
                                    
                                    
                                       
                                          
                                          end
                                       
                                    
                                 
                              
                           
                        
                     

Let us suppose that we are given a database divided into NC
                         classes and that each instance has a number of features equal to NV
                        . Also, let us denote with NR
                         the maximum number of rules we would like in order to classify it. The description of the representation of a generic set of rules useful for classifying in that database can be easily understood if Fig. 2
                         is looked at.

The uppermost part of Fig. 2 says that each DE individual is in this case a vector, containing real values, representing a set of NR
                         classification rules written in sequence in the individual.

The middle part of the figure shows that each rule is represented by a set of fields. Namely, each rule consists in a Rule_Active field, followed by a number of NV Literal_Representation groups (one for each variable in the database), and finally by a Class field. In the rule database variables are listed sequentially, meaning that the generic i-th Literal_Representation deals with the i-th variable of the database. Rule_Active states whether or not the rule should be considered during classification. This is decided by comparing the real value contained in this field against a real value Rule Threshold (RT), which is a parameter for our tool: if the former value is higher, then this rule is seen as active in the current individual and should be used in the classification process. The parameter RT is important, in that it influences the number of the rules contained in the set proposed to the user: the higher its value, the lower the number of rules that, on average, will be active in any DE individual.

Each Literal_Representation field encodes a zero-th order literal, i.e. a literal in which only one variable is contained and is compared with one or two real values by means of relation operators. As shown in the bottom part of Fig. 2, this Literal_Representation field is in fact composed of four sub-fields, each containing a real value, as is detailed in the following paragraphs.

The first field is the Literal_Active field. Similarly to the Rule_Active field, it determines whether or not the literal is present in the rule. Also here, a real-valued parameter Literal Threshold (LT) is defined, and the generic literal under account is active if and only if the value in this field Literal_Active is higher than LT. Also the parameter LT is important, because it influences the size of the obtained rules: in fact, the higher the LT value, the lower the number of literals that, on average, will be active in any rule, which means that the rules will be more compact.

The second field is called Literal_Type. It encodes the relation operator that compares the variable and the constant value(s). We have decided to take the following seven different operators into account: <, ⩽, =, ⩾, >, IN, OUT. The first five operators need one constant value, i.e. C
                        1, whereas the latter two need two constant values C
                        1 and C
                        2. With reference to these two operators, it should be remarked here that a check is carried out throughout the algorithm so that C
                        1
                        ⩽
                        C
                        2. The operator IN checks if the value of the variable contained in the literal is within the numerical range expressed by C
                        1 and C
                        2 in their order of appearance in the individual. The operator OUT, instead, checks if the value taken on by the variable in the literal is outside the range [C
                        1–C
                        2], meaning that either it is lower than C
                        1 or it is greater than C
                        2.

The third and the fourth fields of the Literal_Representation field hold, respectively, the real values for the constants C
                        1 and C
                        2. It is now clear from the previous paragraph that C
                        1 will be used for each active literal, while C
                        2 will be taken into account only if an arity-two operator, i.e. an IN or an OUT, is present in the Literal_Type field.

Finally, the Class field contains the value representing the class to which all the database instances that satisfy the considered rule are assigned.

Therefore, counting all the above described fields, for each individual its total length NG
                         is equal to NG
                        
                        =
                        NR
                        
                        *(1+(4*
                        NV
                        )+1) fields.

Particular care should be taken during the initialization of the population, and during the creation of new individuals, with the aim of generating in each field of the individual some values that are sensible for that field. The lower and the upper bounds for the allowed values for each of the above fields are shown in Table 1
                        .

In the initialization process each individual in the initial population is filled with suitable random values: each of its fields is given a random real value in the admissible range for that field. For each field the admissible range is reported in Table 1. As an example, Rule_active field can be assigned any number within 0.0 and 1.0, e.g. 0.42, but it cannot contain 1.23 or −0.68, because these latter two are outside the admissible range [0.0,1.0].

For each literal, its actual type is achieved by starting from the real value contained in the Literal Type field and by rounding it up to its ceiling value. As an example, a real value equal to 4.56 in that field should be rounded up to ceiling(4.56)=5, so that the value of 4.56 actually codes for the fifth operator in the list of these latter. The order for the operators has been chosen as the following: IN, <, ⩽, =, ⩾, >, OUT, and therefore that value represents a “⩾” operator. The class to which the rule makes reference is achieved similarly, so a value equal to 1.42 in that field means that the rule refers to the class ceiling(1.42)=2.

An example of a DE individual for a database with two variables and two classes is shown in Fig. 3
                        . For each rule 1+(2*4)+1=10 fields are needed. In this example, each individual is supposed to contain a set of at most three rules. Consequently, each DE individual consists of 10*3=30 fields each containing a real value. As regards the other parameters, let us hypothesize that RT
                        =0.50 and LT
                        =0.50.

Let us examine the three rules and decode them by starting from the raw real values contained in the different fields.

The first rule is active, because its Rule_Active field contains a value of 0.68, greater than RT. Let’s see what happens for the literals for the two variables. The literal for the first variable is active because the value in the Literal_Active field is
                        =0.91, and the relation operator is “⩽” (encoded by the value 2.13). The literal for the second variable is active as well (Literal_Active
                        =0.63), the operator being “⩾” (encoded by 4.60). The Class field of the rule holds a value equal to 1.14, so it makes reference to class 2. The second rule, instead, is not active, because its Rule_Active field contains 0.24, which is lower than RT.

For the third rule, Rule_Active
                        =0.83, so this rule is active too. In it the literal for the first variable is not active, because Literal_Active is equal to 0.34, while that for the second variable is active (Literal_Active
                        =0.76) and its relation operator is ‘⩽’, represented by the real value 2.29. The rule makes reference to class 1 because its Class field contains the value 0.62.

Thus, the DE individual shown in the figure represents the following set of two rules:
                           
                              
                                 
                                    
                                       
                                          IF
                                          
                                          (
                                          
                                             
                                                var
                                             
                                             
                                                1
                                             
                                          
                                          ⩽
                                          6.14
                                          )
                                          
                                          AND
                                          
                                          (
                                          
                                             
                                                var
                                             
                                             
                                                2
                                             
                                          
                                          ⩾
                                          3.41
                                          )
                                          
                                          THEN class
                                          
                                          =
                                          
                                          2
                                       
                                    
                                    
                                       
                                          IF
                                          
                                          (
                                          
                                             
                                                var
                                             
                                             
                                                2
                                             
                                          
                                          ⩽
                                          3.12
                                          )
                                          
                                          THEN class
                                          
                                          =
                                          
                                          1
                                       
                                    
                                 
                              
                           
                        It is important to notice here that the rule representation chosen allows you to deal directly with all the real-valued variables contained in the databases. If, instead, integer-valued or binary variables should be handled, the algorithm works equally, because at the end of the execution an easy post-processing phase is carried out on the best set of rules found, with the aim of transforming the real constants contained in them into the most suitable corresponding integer or binary values. Moreover, this is true for nominal variables too, provided that a linear ordering exists for them, as for example in the case of a variable age
                        ={young, middle-aged, old}.

Given an optimization problem, a fitness function should be designed to evaluate the quality of each possible solution proposed by the DE in effectively solving that problem. For the classification problem, the fitness function Φ(i) typically used for each individual i is represented by the percentage of the samples of the training set Tr that are classified correctly, i.e.,
                           
                              
                                 Φ
                                 (
                                 i
                                 )
                                 =
                                 (
                                 
                                    
                                       N
                                    
                                    
                                       c
                                    
                                 
                                 /
                                 
                                    
                                       N
                                    
                                    
                                       tr
                                    
                                 
                                 )
                                 
                                 ∗
                                 
                                 100.0
                              
                           
                        where Nc
                         represents the number of samples in Tr that are classified correctly when the set of rules encoded by the individual i are used, while Ntr
                         is the total number of samples contained in Tr.

On the basis of the above definition, the range of variation for Φ(i) is [0.0–100.0], and the classification task can be seen as a maximization problem.

It should be remarked that, given a set of rules encoded in an individual, some of the instances in the database may be indeterminate with respect to the set of rules under account. By the word indeterminate we mean here two different things. Firstly, we mean a database item that satisfies at the same time the conditions of rules that assign it to two or more different classes: this is called ‘yes–yes’ indeterminate. Secondly, we mean an item which satisfies the conditions of no rule, so there is no class to which it can be assigned: this is called ‘no–no’ indeterminate. Instead, an instance which satisfies the conditions of more rules, all of which make reference to the same class is not an indeterminate case, rather it is assigned to that class.

During the training phase both types of indeterminate items are seen as classified incorrectly, whereas during the testing phase a recovery mechanism is applied. This is because obviously users want each sample in the testing set to be automatically assigned a class by the system.

The recovery mechanism used here has already been presented in [32]. If an item turns out to be a ‘yes–yes’ indeterminate, its distance from the frontier of each of the rules taking it is evaluated in the space of the database attributes. The highest such distance is found, and the item is considered as taken by the rule with the highest distance, so it is assigned to the class expressed in that rule.

If, instead, the item is a ‘no–no’ indeterminate, again its distance from the frontier of each of the rules is evaluated in the space of the database attributes, the rule with the lowest distance is found, and the item is assigned to the class expressed in that rule.

A graphical example is better suited to explain these rules of assignment. If a database with two classes and two variables is dealt with, and by hypothesizing that the range of each variable is [0.0,1.0], Fig. 4
                         shows some examples of the assignment of some items to classes. In the figure each rule is graphically represented by the corresponding area of the parameter space.

We suppose that the set found consists of the two following rules:
                           
                              rule 1: IF ((0.2⩽
                                 A
                                 1
                                 ⩽0.7) AND (A
                                 2
                                 ⩽0.4)) THEN class=1,

rule 2: IF ((0.4⩽
                                 A
                                 1
                                 ⩽0.9) AND (0.1⩽
                                 A
                                 2
                                 ⩽0.7)) THEN class=2.

Given these two rules, the database item S1 = (0.3, 0.2) is taken by rule 1 only, and therefore it is assigned to the class contained in it, i.e., 1. Similarly, the item S2=(0.8, 0.3) is taken by rule 2 only, and therefore it is assigned to class 2. If the item S3=(0.6, 0.3) is taken into account, both rules cover the point, meaning that, based on them, the item is a ‘yes–yes’ indeterminate case. Given that S3 is farther from the frontier of rule 2 than it is from the frontier of rule 1, it is more internal to the area represented by rule 2, and therefore it is considered as more properly taken by rule 2, and is consequently assigned to class 2.

Let us now take into account the item S4=(0.4, 0.9). There is no rule covering it, so it is a ‘no–no’ indeterminate. It is farther from the frontier of rule 1 than it is from the frontier of rule 2, and therefore rule 2 ‘misses’ it by a smaller quantity than rule 1 does. As a consequence, this item is assigned to class 2.

The motivation for performing recovery only during testing depends on the fact that if one allowed handling indeterminate items in this way also during training, this could favor during the evolution individuals presenting one of the two kinds of problems described in the following. The first problem is that such a choice would favor the survival of individuals containing rules making reference to (partially or totally) overlapping regions of the search space, yet accounting for different classes; such sets of rules should, instead, be avoided, since they would lead to (maybe many) yes–yes indeterminate cases, with a poor discrimination ability of the rules among the database classes, and this uncertainty would involve many testing set items.

The second problem is that this choice would favor the survival of individuals containing rules leading to the presence of many no–no indeterminate cases; through recovery, these individuals could apparently correctly classify many actually undetermined items, therefore apparently exhibiting high fitness values which would not correspond to the real classification ability of the set of rules.

When testing is carried out, instead, users want each database item to be assigned to a class. Moreover, all the other classification algorithms used in the experiments, with which our tool is compared, assign each item to one of the classes and leave none of them as indeterminate. Therefore, with the aim of performing a fair comparison, we have enabled the recovery mechanism described above during the testing set.

@&#EXPERIMENTS@&#

Starting from the apnea-ECG database 
                        [11], freely downloadable from www.physionet.org, we have to create one database for each patient.

The apnea-ECG database consists of 70 recordings, one for each patient. Thirty-five of them contain annotations about apnea episodes for each 1-min segment, and therefore we make reference to these 35 recordings only. Among these segments, 20 (labelled as a01–a20) are known to be related to people definitely suffering from OSA, five (b01–b05) are borderline, and ten (c01–c10) are people with no OSA at all or with very low level of the disease.

From each of these recordings, i.e. for each patient, we create a new database and let it undergo a classic classification task. Namely, we take the whole patient recording over the whole night, and for each 1-min segment we compute the values of a set of twelve typical parameters very popular in dealing with ECGs. Some of these are in the frequency domain, others in the time domain, whereas others make reference to non-linear methods.

The parameters considered in the frequency domain are:
                           
                              •
                              Power in the Ultra-low frequency band: ULF.

Power in the Very low frequency band: VLF.

Power in the Low frequency band: LF.

Power in the High frequency band: HF.

Total Power of the signal (i.e. the sum of the four above powers): P.

Low frequency/high frequency ratio: LF/HF.

The parameters in the time domain are:
                           
                              •
                              Average value of NN intervals: ANN.

The standard deviation of the average NN intervals: SDANN.

Proportion of NN50 divided by the total number of NNs, where NN50 is the number of pairs of successive NNs that differ by more than 50ms: pNN50.

The square root of the mean squared difference of successive NNs: rMSSD.

Those related to non-linear methods are:
                           
                              •
                              Approximate entropy: AE.

Fractal dimension: FD.

This has been performed by using GHRV software release 1.2 available at http://milegroup.github.io/ghrv/index.html.

The above HRV-related parameters are linked to ECG. In fact, what we do is to start from an ECG recording and then compute the QRS complexes in the ECG waveform. From them we can locate the R peak at each heartbeat, and can compute the RR (also known as NN) interval between successive peaks. Starting from the series of these RR peaks the above parameters can be computed.

Each instance in the database related to that patient will be constituted by those 12 values, together with the class of the instance as known from the annotations related to that recording. These latter will be represented by a 1 for a non-apnea minute and by a 2 for an apnea minute.

Since apnea-ECG database recordings have different lengths, due to the different duration of sleep for the different patients, so will the thereby extracted databases. Namely, their length varies from 428 to 576 items. It should be noted that apnea periods, as well as non-apnea ones, can last tens of minutes and even hours, therefore each database presents long sequences of consecutive items making reference to a same class. To avoid the possibility that this can negatively influence learning and generalization, the items in each of the 35 databases are shuffled.

As an example, Fig. 5
                         shows a part of the final database achieved for patient a04.

To automatically extract from each of the 35 obtained databases a set of explicit IF–THEN rules for the OSA episode detection related to that specific patient, the DEREx tool described in Section 4 is used. More specifically, DEREx uses a 10-fold cross-validation to select the set of rules that maximize the correct classification rate, i.e. the accuracy, over unseen examples. The population size NPop
                         has been set equal to 30 individuals, and the maximum number of generations Gen to 500. We set DEREx so that over each database it should search for groups of at most six rules, i.e. NR
                        
                        =6. Within each individual we set RT
                        =0.50 and LT
                        =0.50. It should be remarked here that no preliminary tuning has been carried out for the values of these parameters. Furthermore, DEREx is run 25 times because it is not deterministic, but its execution depends on an initial random seed.

Given a database related to a patient, we carry out ten-fold cross-validation, meaning that in each fold 90% of the data are used for training and the remaining 10% for testing, and each of these folds yields a rule set. For each patient we perform 25 such executions, which leads to 10*25=250 supervised classification phases, and to an equal number of rule sets for the patient. At the end, DEREx provides us with the “best set of rules” for that patient, i.e. the rule set with the highest accuracy over the testing set. By iterating this over the 35 patients, we get 35 sets of rules, one for each patient.


                        Table 2
                         shows the total discriminating ability of the system over the 35 databases in terms of accuracy, sensitivity, specificity, and ROC area. For the purpose of completeness, additionally both results over the training set and over the whole database are shown.

For the sake of clarity, we report the definitions for the above parameters.
                           
                              
                                 Accuracy
                                 =
                                 100.0
                                 ·
                                 
                                    
                                       (
                                       TP
                                       +
                                       TN
                                       )
                                    
                                    
                                       N
                                    
                                 
                              
                           
                        
                        
                           
                              
                                 Sensitivity
                                 =
                                 100.0
                                 ·
                                 
                                    
                                       TP
                                    
                                    
                                       (
                                       TP
                                       +
                                       FN
                                       )
                                    
                                 
                              
                           
                        
                        
                           
                              
                                 Specificity
                                 =
                                 100.0
                                 ·
                                 
                                    
                                       TN
                                    
                                    
                                       (
                                       FP
                                       +
                                       TN
                                       )
                                    
                                 
                              
                           
                        where N is the total number of samples, TP is the number of apnea events correctly classified, TN is the number of non-apnea events correctly classified, FP is the number of non-apnea events incorrectly taken as apnea, and FN is the number of apnea events incorrectly seen as non-apnea.

It is worth recalling here that sensitivity relates to the test’s ability to identify positive results, i.e. apnea episodes, and the higher the number of false negatives the lower the sensitivity value. Specificity, instead, measures the ability of the classifier to identify negative results, i.e. non-apnea episodes, and also for this the higher the number of false positives the lower the specificity value. In both cases, and in that of the ROC area too, it can range in our tests from a minimum of 0.0 (completely wrong predictive ability) to a maximum of 100.00 (perfect predictive ability with no errors in classification).

In the table each value is the average of the results achieved by each best set of rules over the corresponding part of database. For example, the reported accuracy over the testing set of 92.26% means that the 35 best sets of rules found allow the correct classifying of 92.26% of all the instances over the corresponding 35 testing sets on which they were found.

A first remark is that the results over testing are better than those over training, which could at first sight seem weird. Actually, those results are averaged over the 35 patients. For each patient, the best rule set is the one among the 250 that has the highest accuracy over testing set, so it is very likely to have extremely good performance on the testing set, in some cases even 100%. Therefore, this performance could be even better than that on the training set. Of course, this feature, i.e. performance over testing being better than that over training, is not the normal case, and in the vast majority of the 250 rule sets found for that patient just a few have this feature, yet very likely they are among those with the highest values of accuracy over the testing set for that patient.

At the end of this experimental phase the system provides doctors with 35 sets of rules, one for each patient. This means that a specific set is found for each patient. These sets are typically different one from another in terms of number of rules, number of parameters in each rule, parameters involved, relational operators, and threshold values. For each patient her/his set will be used in the real-time monitoring phase, which represents personalized healthcare.

As an example, the best set of rules for patient a04 is the following:
                           
                              
                                 
                                 
                                    
                                       IF ((HF<3321.48) OR (HF>5685.89) AND (mean_value_HR>71.44)
                                    
                                    
                                       
                                          THEN no_apnea
                                    
                                    
                                       
                                          
                                       
                                    
                                    
                                       IF (mean_value_HR<73.32)
                                    
                                    
                                       
                                          THEN apnea
                                    
                                 
                              
                           
                        
                     

We recall here that ten-fold cross-validation is performed over each database. This means that at the end of its execution over a database DEREx will achieve ten sets of rules, one for each fold. The one among them with the highest accuracy over the corresponding testing set is chosen as the “best set” for that execution. Moreover, since, as said above, we carry out 25 executions over each database, at the end of each of them we get one such best set, and at the end of the 25 executions we choose as the overall best set among those 25 the one with the highest accuracy over the testing set. This is the set shown above.

This set perfectly takes all cases over the testing set, as is shown in Table 3
                        . Furthermore, also its performance over the training set is really satisfactory, and so is that over the whole database.

Given the nature of the best set of rules explained above, it is not surprising that the performance over the testing set is better than that over the training set.

The above is just the performance of the rules found over the fold with the highest accuracy over testing set out of the 25 runs; of course tenfold cross-validation has been performed in that run, so ten different sets of rules have been found, one over each fold. There is no space here to report them all, so Table 4
                         summarizes the performance of DEREx, averaged over the ten folds (i.e. ten testing sets) and the ten sets of rules, in that run. It can be observed that average accuracy on training is higher than that on testing, which implies that for the high majority of the ten folds this is the normal case.

Instead, the best set of rules for patient a19 is:
                           
                              
                                 
                                 
                                    
                                       IF (LF⩾3052.02) AND ((mean_value_HR <= 77.27) OR (mean_value_HR⩾85.83))
                                    
                                    
                                       
                                          THEN no_apnea
                                    
                                    
                                       
                                          
                                       
                                    
                                    
                                       IF (standard_deviation_HR ⩾ 2.74)
                                    
                                    
                                       
                                          THEN apnea
                                    
                                    
                                       
                                          
                                       
                                    
                                    
                                       IF (HF < 8334.66) AND (standard_deviation_HR ⩽ 2.80)
                                    
                                    
                                       
                                          THEN no_apnea
                                    
                                 
                              
                           
                        
                     


                        Table 5
                         reports the discriminating ability for this set of rules.

and the average performance in the “best run” is reported in Table 6
                        .

As a further example, for patient a18 the best set of rules is:
                           
                              
                                 
                                 
                                    
                                       IF (VLF<500.07) AND (mean_value_HR⩾63.93)
                                    
                                    
                                       
                                          THEN no_apnea
                                    
                                    
                                       
                                          
                                       
                                    
                                    
                                       IF (mean_value_HR⩽64.93)
                                    
                                    
                                       
                                          THEN apnea
                                    
                                 
                              
                           
                        
                     

and the related statistics are in Table 7
                        .

whereas the average performance in the “best run” is reported in Table 8
                        .

A comparison between these three sets of rules confirms our hypothesis that the most relevant parameters for OSA discrimination depend on the specific patient being monitored: a set of rules which is very good for one could be unsuitable for other patients. On the one hand, some parameters such as the mean value of HR are often present in the 35 sets of rules, yet, on the other hand, each patient requires some very specific parameters to be taken into account. Moreover, even when the same parameter is taken into account for different patients, the values contained in the literals may be, even significantly, different. For example, the threshold for mean_value_HR is 73.32 for patient a04 whereas it is 64.93 for patient a18.

If, instead, we used the approach typically taken in the literature in other papers, and we gathered the 35 patient databases in one global database, the best set of rules found on it would be:
                           
                              
                                 
                                 
                                    
                                       IF ((power<114958.95) OR (power>2360972.72)) AND (pNN50<5.14)
                                    
                                    
                                       
                                          THEN no_apnea
                                    
                                    
                                       
                                          
                                       
                                    
                                    
                                       IF (pNN50⩾1.62)
                                    
                                    
                                       
                                          THEN apnea
                                    
                                    
                                       
                                          
                                       
                                    
                                    
                                       IF (ULF ⩾ 101363.00)
                                    
                                    
                                       
                                          THEN apnea
                                    
                                 
                              
                           
                        
                     

which achieves the performance reported in Table 9
                        .

The parameters involved now are not those best suited for the three patients shown above, and this is true in general for each patient. To put it simply, in this case the system would extract a kind of “average knowledge”. Also, the global performance is worse, especially in terms of specificity. This is a very important conclusion: a general database of people suffering from OSA, as typically sought in the other approaches described in Section 2, is not well suited to achieve effective care for a specific patient.

To carry out an evaluation of the quality of the results proposed by DEREx in terms of accuracy, sensitivity, and specificity, we have decided to take into account fifteen other well-known classifiers so as to compare the results of our classification tool against those provided by them. To achieve this aim, we have considered the Waikato Environment for Knowledge Analysis (WEKA) system release 3.4 [35]: it is a freely-downloadable tool that contains many classification techniques. These latter are categorized on the basis of their working principles, so the following groups exist: Bayesian, based on functions, lazy, meta-techniques, tree-based, rule-based, other. We have decided to choose some representatives from each of these groups. As a consequence, we have considered the Bayes Net [36] and the Naive Bayes [37] among the Bayesian, whereas the MultiLayer Perceptron Artificial Neural Network (MLP) [38] and the Radial Basis Function Artificial Neural Network (RBF) [39] have been chosen from among the function-based tools. As representatives of the lazy methods, we have selected the KStar [40] and the IB1 [41], while we have picked the AdaBoostM1 [42] and the Bagging [43] from among the meta-techniques. We have decided to pay particular attention to the rule-based classification methods, so we have taken into account the OneR [44], the Part [45], and the Ripple Down Rule (Ridor) [46]. We have chosen the J48 [47] and the Naive Bayes Tree (NBTree) [48] from among the tree-based classifiers, and, finally, we have decided to consider the Fuzzy Lattice Reasoning (FLR) [49] and the Voting Feature Interval (VFI) [50] from among the other methods.

Also for all of the above listed classification methods, as for DEREx, the decision has been made not to perform any preliminary parameter tuning. Therefore for each such classifier the parameter set used is the one set as default in WEKA. Of course, for a fair comparison of DEREx against these classifiers, also for all of them we must provide results averaged over 25 runs. Actually, MLP, RBF, AdaBoost, Bagging, Part, Ridor, and J48 make use of a random starting seed to obtain different executions, so the 25 runs for them have been performed quite easily by varying this initial value. Another group, instead, contains some classifiers that do not have any starting seed useful for obtaining different executions, and therefore for each of them the 25 runs have been performed by slightly varying the value of a parameter typical of the classifier: for Bayes Net we have chosen alpha, for KStar globalBlend, for FLR rhoa, for VFI bias, and for OneR minBucketSize. Finally, a last group of classifiers, composed by Naive Bayes, IB1, and NBTree, contains methods that do not have any dependence either on an initial random seed or on any typical tunable parameter, and therefore for each of them only one single run has been carried out on each database.

As we carried out for DEREx, 10-fold cross-validation has been performed in each run for each of these tools as well. Table 10
                         shows the results in terms of the average accuracy among the 35 databases faced, the related standard deviation, and the maximum and minimum values.

Some of the classifiers used here cannot handle continuous-valued parameters, and a discretization mechanism is needed because the attributes that we have considered take on real values. As an example, for Naïve Bayes Weka uses by default Gaussian distributions for the discretization of continuous numeric attributes. This holds true also for NBTree, which generates a decision tree with Naïve Bayes classifiers at the leaves. Actually, several other discretization mechanisms exist, including, among others, supervised discretization and kernel density estimation, and the choice of the most suitable one for each tool requiring it is not a trivial task, and could affect the performance of those algorithms. In this paper for each algorithm needing discretization we have used the default mechanism for it as provided by Weka.

For each parameter in Table 10, the best value obtained by all algorithms is reported in bold. The results in the table evidence that the average percentage of correct classification provided by DEREX over the 35 databases is the highest, exactly equal to that of Bagging. Moreover, the standard deviation is the second lowest, meaning that the algorithm is quite insensitive to the different initial random seeds. DEREx also achieves the highest maximum value. Bagging, instead, obtains the highest among the minimum values.


                        Table 11
                         contains the comparison of the algorithms in terms of average values of sensitivity over the 35 databases, and of the related standard deviation as well.

The highest average values are reported in bold. DEREx achieves the highest value of sensitivity, and is superior to the runner-up, i.e. IB1, by more than 6%. This means that, when compared to the other classifiers, DEREx has a lower number of false negatives, i.e. apnea episodes that are erroneously seen as non-apnea episodes. This is very important for a system of this kind, as it is better able to generate alarms only when necessary.


                        Table 12
                         shows the same information for specificity.

Here too DEREx provides the highest value, since the second best classifier is in this case Bagging but at a distance of more than 13%. This means that DEREx has a lower number of false positives, resulting in a lower number of unnecessary alarms.

This comparison makes us confident that our approach is capable of discriminating apnea episodes more accurately than these other artificial intelligence tools. In fact, the two above tables show that it yields at the same time a lower percentage of apnea episodes incorrectly taken as non-apnea episodes and a lower percentage of non-apnea episodes incorrectly taken as apnea episodes.

Furthermore, it is to be pointed out that most of these other classifiers do not perform rule extraction, so they would be useless for the creation of the knowledge base needed by our system. We believe this user-friendliness of our system could be very helpful to doctors.

This method, shown to be effective on the OSA apnea-ECG database used, should now be tested in a real life scenario. Therefore, it has been included in our mobile health monitoring system developed at iHealthLab, and experiments will be carried out in the near future with volunteers suffering from OSA. Each of them will be asked to wear sensors of the system for a few hours, and the resulting ECG traces will be annotated by a doctor. By so doing, a set of rules can be devised for that patient. Subsequently, these rules will be used to monitor the patient during the following nights.

The system developed at iHealthLab is a mobile multi-parametric monitoring system and allows you to have a complete description of the health condition of a patient by using several sensors recording many vital parameters. As described in Section 3, our proposed approach to OSA episode detection makes use of just one ECG sensor. The reason why we have used ECG data and one ECG sensor only is that when we started to investigate real-time OSA monitoring, we searched for publicly available databases. The best one we could find was Apnea-ECG, which contains ECG data only. Had it contained data related to other vital parameters we could have used them as well: our system has sensors for them also, so it can detect those parameters, and the physical meaning of any parameters contained in the database is transparent to the DEREx classifier, since it deals with numbers that could represent whatever is needed.

We feel it is worth providing readers with software and hardware details about our whole mobile health monitoring system, so as to let them have a complete vision of its capabilities. This is also because in the future our approach to OSA episode detection could involve the use of other sensors too, and, as a consequence, could make use of the evaluation of a higher number of patient parameters to further improve the accuracy in the detection of OSA events.

The software and hardware details about our mobile health monitoring system are given below.

The realized system relies on a multi-layer architecture [29] shown in Fig. 6
                        . This architecture is designed to provide the system with a flexibility capacity through which algorithms and sensors can be adapted to various applications and new sensors can be easily added. Each layer is independent of these above and below it.

From a logical point of view, the software architecture we have developed is divided into three different layers: the Data Layer, the Decisional Layer, and the Action Layer.

The Data Layer is responsible for gathering data coming from the wearable sensors such as ECG, accelerometer, body temperature, SpO2, and for performing data filtering and parameter estimation (e.g. peak of QRS, Heart Rate Variability).

The Decisional Layer is the “intelligent” core of the system: the data coming from the Data Layer is elaborated on the basis of the rules, so determining if any action has to be executed and, if that is the case, the type of such an action (e.g. alarm generation or a suggestion to the patient).

The Action Layer provides mechanisms to generate and to deliver alarm messages to doctors, or to generate sounding and/or visual alerts for the patient’s PDA or smart phone.

Each layer is constituted by software modules (or components), which execute their specific tasks and exchange information through their interfaces.

All the layers are implemented on the PDA (or smart phone). In the following we will describe in more detail the software modules constituting each layer.

The Data Layer consists of the following eight modules:


                           The User Module: this provides a user interface to input some patient data such as name, age, gender, and Resting Heart Rate (RHR). The gender and age are used to calculate the maximum Heart Rate (HRmax) using the Karvonen formula. Moreover, whenever the patient does not know her/his RHR, the user interface affords a functionality to calculate the RHR by giving the patient very simple instructions.


                           The Heart Rate Module: this contains the methods to detect the QRS complex of the ECG signal, and to calculate the peak QRS whereby the Heart Rate and the parameters related to HRV discussed in Section 5, like the Standard Deviation Normal beat to Normal beat (SDNN), are estimated.

In particular for real-time QRS detection the Pan and Tompkins algorithm is used [51]. In order to attenuate noise, the signal is passed through a bandpass filter composed of cascaded high-pass and low-pass integer filters. Subsequent processes are differentiation, squaring, and time averaging of the signal. In Fig. 7
                            the ECG output of each filter is shown.

A peak is determined when the signal changes direction within a certain time interval; this is needed to define thresholds to detect the peak of the QRS complex. These thresholds are dynamically calculated to adapt the algorithm to the ECG signal of a particular patient.

In principle, whatever parameter is necessary for the monitoring being carried out can be computed.

In the case of the OSA disease the parameters calculated are those listed in Section 5.1 and used throughout Section 5.

The modules that are described in the following paragraphs, and that are included in the Data Layer, currently are not used for OSA episode detection, but are nonetheless reported for the sake of completeness.


                           The Posture Module: this is required to recognize if the patient is staying up or is lying down. By means of an accelerometer, gravity-induced reaction forces are measured in terms of their g-force.

The collected data is preliminarily submitted to a filtering process to reduce unwanted high frequency elements like noise. Then the filtered data is analyzed to determine the patient’s posture. This decision is based on the evaluation of the tri-axial values in relation with some thresholds previously calculated in a test phase. In particular, only the y-axis and z-axis values play an important roles for the recognition of the patient posture.


                           The Activity Module: this performs a task in the detection of patient activity. Generally, there are three types of methods to recognize the movements of walking and running. They are: peak detection, zero crossing detection, and flat zone detection using differential acceleration.

We chose to adopt the peak detection method for its computational simplicity. The peak frequency of the acceleration signal reflects the intensity of the activity, and can be used to roughly classify different activities (see Fig. 8
                           ). In order to identify the peaks, the module first reduces the noise and then detects the peak using filters similar to those used in the QRS detection.


                           The Temperature Module: this is responsible for managing an estimated core body temperature (Tcore) that is a measure of the thermal state of the patient. The estimation of this parameter is based on a Kalman filter (KF) approach. The benefit of the KF approach is that it requires only one input – heart rate (HR) – while the current state-of-the-art models require a multitude of inputs including metabolic rate, environment conditions, clothing characteristics, and individual anthropometrics.


                           The Respiratory Module: The expansion and contraction of the thoracic cavity generates a size differential as measured by the temperature module thanks to a sensor on a strap under the wearer’s right arm. This differential is picked up by the strap sensor and the module manages the breathing waveform and breathing rate in Breaths per Minute. When viewing the waveform, inhalation is denoted by a downward trend in the breathing waveform. This is because the distance between the sensors in the strap is decreased (compressed) due to thoracic expansion. Commensurately, exhalation (sensor expansion) causes an upswing in the waveform. Respiration at rest should appear as a sine wave; respiration under activity should appear as a higher frequency sine wave.


                           The SpO2 Module: this is required to manage the information coming from the SpO2 sensor that emits a red and infra-red light which penetrates the tissue and responds to the fluctuations caused by the arterial blood pulses generating the respective signal. The ratio of the reflected light signals reflects the oxygen saturation of the blood. Factors such as steady venous blood flow, skin thickness, fingernail thickness, etc., do not affect the saturation reading because they are constant (do not fluctuate).


                           The EDF Module: this manages the saving of data in a specific data format, the European Data Format (EDF). The choice of the EDF format was made because it is the de facto standard for EEG and PSG recordings in commercial equipment and multi center research projects. It is a simple and flexible format for the exchange and storage of multichannel biological and physical signals. In addition, many freeware EDF viewers and EDF analyzers can be found.

The Decisional Layer contains the rule-based Decision Support System that is constituted by the following two modules:


                           The Knowledge-base Module: this is the module in which very basic clinical knowledge about simple abnormal heart rate variation is appropriately formalized and codified in terms of concepts, relationships and rules. In particular, it contains the best set of rules automatically extracted off-line from patient’s history represented in the form of an explicit set of IF…THEN rules by means of a Differential Evolution algorithm.

Such formalized knowledge enables the application of automated reasoning procedures to support the generation of alarms and warnings to signal possible anomalies. Examples of some implemented rules are in Fig. 9
                           .


                           The Rules-Engine Module: this processes the rules and data stored in the knowledge base. We used the rule engine described in [52], based on the lazy pattern matching algorithm to give an efficient handling of memory and computational resources and achieve good performance. This algorithm does not waste time in computing superfluous rule activations which could never be executed and enables to fire the first eligible rule as soon as it has been identified improving performance in terms of average response time. Therefore, by using this, it is possible to elaborate a rich volume of parameters in real time.

The main goal of this layer is to provide functionalities for generating and sending alarms or warnings. This layer consists of two modules:


                           The Alarm generator Module: on the basis of the output of the rules-engine modules, this generates alarm messages that are sent to the doctor. The alarm message contains patient’s name, the EDF file of the monitoring, and the rule fired.


                           The Warning generator Module: on the basis of the output of the rules-engine modules, this generates audio and/or textual warnings to the patient.

The ECG, Temperature and Breath Sensor: electrocardiography –ECG – is a non-invasive technique based on the interpretation of the electrical activity of the heart over time. These signals or activities are recorded by using skin electrodes. In our system, the ECG sensor is composed of three electrodes.

The ECG module receives small voltages of about 1mV that normally appear on the skin and may help to monitor the cardiac activity in the human body. The signals from the different leads provide cardiologists with help in making a diagnosing with a complete representation of the electrical activity of the heart, including the heart rate (HR), which is interpreted as the R-to-R Interval. Fig. 10
                         shows an example.

The device used in our system is the BioHarness™ BH3 (Fig. 11
                        ), an advanced physiological monitoring device that uses Bluetooth technology to transmit data. It is small and provides a medical-grade ECG, as well as heart rate, breathing rate and temperature monitoring, and 3-axis accelerometery.

The monitor can be used with the BioHarness™ strap, a lightweight elasticized component which incorporates Zephyr Smart Fabric ECG, Temperature, and Breathing Rate sensors.

The BioHarness BH3 also has a 3-axis accelerometer for the monitoring of subject posture and activity. The device allows you to recover axis mapping information for the accelerometer. Any accelerometer axis can be mapped to any other axis as well as being inverted to allow the device to be used in a number of different orientations (e.g. worn on the front, on the side, upside down, etc.).

Data are transmitted by Bluetooth and this allows physiological data to be monitored using any suitably-configured mobile device with Bluetooth technology, such as a laptop, phone, or PDA.

@&#IMPLEMENTATION DETAILS@&#

All the layers are implemented for resource-limited mobile devices, such as PDA and smart phones, using the java programming language, but the system could be used also to build desktop applications, except for the user interfaces. In particular, for this case study the system was developed by using Eclipse IDE and the Android SDK.

We conducted some preliminary tests using an Android-based tablet, an ASUS Eee Pad Transformer Prime TF201 model, as shown in Fig. 12
                        .

@&#CONCLUSIONS@&#

Real-time Obstructive Sleep Apnea (OSA) episode detection and monitoring are important for society in terms of an improvement in the health of the general population and of a reduction in mortality and healthcare costs. This paper has proposed an approach, embedded in a real-time mobile monitoring system, for monitoring patients with OSA. It is quite simple, since it gathers single-channel ECG data only, is easy to perform from the patient’s point of view because it can be carried out in any place and patient is not required to keep her/his position constant all night long. The approach is based on the automatic extraction of explicit knowledge from a database containing information about the monitored patient. The extraction is performed by Differential Evolution, and the knowledge takes the form of a set of IF…THEN rules containing typical HRV-related parameters for ECG.

It has been tested on a literature database of OSA patients. The numerical results have shown the effectiveness of the approach, and the achieved sets of rules evidence its user-friendliness, which is in our opinion a very helpful feature for doctors.

A very important conclusion is that a general database of people suffering from OSA, as typically pursued in other approaches and unlike ours, is not well suited for taking care of a specific patient.

Future works involve the use of more subtle strategies to further enhance the specificity and sensitivity of the system.

Furthermore, the experiments presented in this paper have been carried out using only a small number of patients, and so in fact they represent a preliminary evaluation. Therefore, we aim to test this system in a real life situation with a group of volunteers suffering from OSA. To achieve this, a closer cooperation with a hospital department will be of paramount importance, in order to annotate the files needed to train the system to better understand the OSA features for each patient.

Moreover, we plan that in the future our approach to OSA episode detection could involve the use of other sensors also, and, as a consequence, could make use of the evaluation of a higher number of patient parameters to further improve accuracy in the detection of OSA events.

An interesting point to consider in DEREx is that of multi-objective optimization. Currently, our classifier tries to find the set of rules that has an as-high-as-possible value of accuracy, and the possibility that also the related values for sensitivity and specificity are good is just a kind of side effect of the optimization over accuracy. We have just implemented a new version of DEREX that can optimize on either of these three parameters depending on the user’s choice. This could lead to find out that different sets of rules are better in terms of the different parameter to be optimized. Moreover, we plan to design and implement in the near future a new version of DEREx able to perform multi-objective optimization, i.e. a system in which for each set of rules the values of all the three parameters could be optimized at the same time. This could be achieved by making use of an approach based on a Pareto front.

Another very interesting issue worth investigating in the future is that related to the involvement of physicians in the process, with reference to the annotations. In fact, they are required to annotate the files needed in the off-line training phase for any given patient so that the system can be trained to better detect OSA episodes for that patient. Indeed this is currently a delicate issue in respect of all the systems presented in the literature aimed at detecting OSA episodes, since they all are based on supervised training, which implies the need for annotations. The annotation phase represents a more laborious step in the case of personalized monitoring systems, as ours, because the extraction of the knowledge has to be carried out for each new patient rather than just once. Nonetheless, the currently used OSA diagnosis methodology, i.e. polysomnography, requires that physicians inspect all the recordings gathered by the vast amount of sensors used during the night, so our system makes the process easier and faster, because they have to examine single-channel ECG data only. Finding a new way to automatically perform the annotation phase would really constitute a breakthrough.

Finally, we wish to investigate the ability of our system to dynamically manage CPAP pressure adjustments: currently, the airflow level is set statically and is kept constant during night time. By making use of the sets of rules, instead, the airflow could be set at a low level as long as an OSA event is not detected by the patient’s set of rules, whereas it could be automatically increased as soon as the occurrence of an OSA event is recognized, and gradually decreased again when the event has disappeared. Of course, since sets of rules are specific to individual patients, this would lead to a personalized management of pressure, i.e. personalized healthcare. Significantly, this would contribute to the design and building of a new class of intelligent devices for the more accurate treatment of the OSA disease.

@&#ACKNOWLEDGMENTS@&#

The authors would like to thank Dr. Massimo Esposito and Dr. Aniello Minutolo for their useful contribution in permitting us to use their developed DSS in our system [52].

@&#REFERENCES@&#

