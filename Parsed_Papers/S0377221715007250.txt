@&#MAIN-TITLE@&#Models and algorithms for network reduction

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We model and develop algorithms to reduce network size over large-scale networks.


                        
                        
                           
                           We study two variants, Min-Size and Min-Length, of the network reduction problem.


                        
                        
                           
                           We propose optimization-based heuristic algorithms to solve the problem.


                        
                        
                           
                           The methods include shortest path-based procedure and dual ascent algorithm.


                        
                        
                           
                           We report successful applications for two practical planning problems.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Networks

Large scale optimization

Heuristics

Shortest path

Dual ascent

@&#ABSTRACT@&#


               
               
                  We study models and algorithms for a Network Reduction (NR) problem that entails constructing a reduced network in place of an existing large network so that the shortest path lengths between specified node pairs in this network are equal to or only slightly longer than the corresponding shortest path lengths in the original network. Solving this problem can be very useful both to accelerate shortest path calculations in many practical contexts and to reduce the size of optimization models that contain embedded shortest path problems. This work was motivated by a real problem of scheduling and routing resources to perform spatially dispersed jobs, but also has other applications. We consider two variants of the NR problem—a Min-Size NR problem that minimizes the number of arcs in the reduced network while ensuring that the shortest path lengths in this network are close to the original lengths, and a Min-Length NR problem that minimizes a weighted sum of shortest path lengths over all the specified node pairs while limiting the number of arcs in the reduced network. We model both problems as integer programs with multi-commodity flows, and propose optimization-based heuristic algorithms to solve them. These methods include preprocessing, a shortest path-based procedure with local improvement, and a dual ascent algorithm. We report on the successful applications to reduce the network for practical infrastructure project planning and to condense a transportation network for distribution planning. We also compare these solutions with those obtained using algorithms for minimum length trees.
               
            

@&#INTRODUCTION@&#

Given a large network over which resources or flows are to be routed, we address the problem of constructing a smaller or reduced network so that the shortest path lengths between specified node pairs in the smaller network are equal to or only slightly longer than the corresponding shortest path lengths in the original network. We refer to this problem as the Network Reduction (NR) problem. As we explain later, our work on this problem arose in the context of developing a practical model for a large-scale optimization problem to assign and schedule resources and plan their movements on a large infrastructure network. The models and algorithms developed in the paper also have broader applications in other scientific and engineering contexts where performing shortest path calculations very quickly is critical, and in domains such as service network design to balance customer responsiveness and cost. We consider two variants of the NR problem—a Min-Size version that seeks to minimize the number of arcs in the reduced network while ensuring that the shortest path lengths are not much longer than the original lengths, and a Min-Length problem that limits the number of arcs in the reduced network while minimizing the sum of shortest path lengths in this network. We model these problems as integer programs with multi-commodity flows. Since both problems are NP-hard, we develop optimization-based heuristic algorithms, including a dual ascent method and shortest path-based procedures, supplemented with preprocessing techniques. We report on successful results from applying these methods to real problem instances from an infrastructure project planning application and for distribution planning.

Our work on the NR problem was initially motivated by the need to develop a practical model for a large-scale project planning model on an infrastructure network (Li, 2011). This planning model contains embedded subproblems to route resources (e.g., workers and equipment) of different types over multiple periods on the shortest paths between various pairs of work locations. In the largest among these resource routing subproblems, the underlying physical network (on which resources travel) contains over 8000 nodes and 17,000 arcs, but only a small fraction of the nodes (around 1.5 percent) are work locations. To model the movements for each of many available resource types over this physical network during each of 50 periods, we would require millions of routing variables. (The model also contains many other integer variables to capture assignment and scheduling decisions, and numerous logical constraints linking the variables.) Solving such a large-scale mixed integer programming model is very challenging. As part of our exploration of practical modeling alternatives, since only a small proportion of the nodes in the physical network are work locations, we began examining ways to “condense” the network by eliminating or replacing arcs and nodes so as to reduce the number of variables and constraints in the model while capturing well the cost of resource movements. For each arc (or node) that is eliminated, the model size reduces by hundreds of routing variables (or constraints) across periods and resources.

Condensing the given network requires addressing the tradeoff between reducing the size of the network (and hence making the planning model easier to solve) versus increasing the lengths of the shortest paths in this network between the work locations (thereby introducing some approximation in the cost of movements). Specifically, requiring these lengths to be the same as the shortest path lengths in the original network ensures that the reduced network accurately captures the associated route lengths and costs, but limits the amount of possible reduction in network size. On the other hand, if we are willing to permit slightly longer path lengths in the reduced network, the resulting network can have fewer nodes and arcs (and hence fewer variables and constraints in the planning model) but is an approximation of the original problem. The two models we propose in this paper address these trade-offs between network size and shortest path length. Our Min-Size model can be used to determine the smallest possible network size without compromising on shortest path lengths, while our Min-Length model minimizes the approximation error for a reduced network of a specified size.

The NR models also apply to many other scientific and engineering computations that require intensive and quick calculation of shortest path lengths (e.g., Ahuja, Magnanti, & Orlin, 1993; Allan & Bragg, 2012; Li & Klette, 2011). For example, in many routing applications, such as Vehicle Route Guidance Systems (VRGS) and Automated Vehicle Dispatching Systems (AVDS), shortest paths need to be quickly identified due to real-time response requirements or repeated calculations. Several recent research surveys for various transportation problems, e.g., SteadieSeifi, Dellaert, Nuijten, Van Woensel, and Raoufi (2014) for multimodal freight transportation planning, Vidal, Crainic, Gendreau, and Prins (2013) for multi-attribute vehicle routing planning, and Demir, Bektaş, and Laporte (2014) for green road freight transportation planning, all note that time-efficient shortest path calculations are central to solving these problems effectively. Although shortest path algorithms are polynomial in terms of computational complexity, their actual solution times over very large networks can be high, precluding real-time use. So, researchers have developed heuristic shortest path methods for these applications (see survey by Fu, Sun, & Rilett, 2006). By replacing the original large network with a smaller network generated by the NR model, our work provides an alternate approach that can complement existing shortest path methods to further reduce computational time while obtaining good solutions. Network reduction also applies in many practical transportation problems in which the potential origins and destinations for a particular customer constitute only a small portion of nodes of a large network. Goczyła and Cielatkowski (1995) incorporated network reduction in the context of train routing in Polish national railways. Due to the vast size of the network, optimal route planning based on the physical network was time-consuming and not practical for operational decision support. So, the authors applied a network reduction step that can be viewed as a simplified version (for nodes in series) of our preprocessing procedure.

The terminology of network or graph reduction has also been used in other contexts. For example, in project management, network reduction at the modeling stage refers to transforming the original activity network into simpler and more synthetic networks (Bein, Kamburowski, & Stallmann, 1992; Tavares, 2002). Problem reduction, to reduce the number of variables and constraints of a formulation, has been discussed in the context of several integer programming problems. When the problem is defined over a graph, these reduction methods attempt to make the underlying network smaller. Balakrishnan and Patel (1987) proposed problem reduction procedures, based on minimum spanning tree solutions, to eliminate (or fix) arcs and nodes that cannot (or must necessarily) belong to the optimal Steiner tree solution. Researchers have since applied analogous methods to various other network design problems. For instance, Chardy, Costa, Faye, and Trampont (2012) recently proposed problem reduction methods to eliminate nodes and arcs so as to reduce the size of the mixed integer formulation for the splitter and fiber location problem in telecommunications. For the weighted dense k subgraph problem, which seeks a maximum weight subgraph induced by k vertices of a given graph, Borgwardt and Schmiedl (2014) proposed a preprocessing heuristic to delete less promising vertices from the original graph based on their estimated contributions relative to a threshold value. Note that the above methods are designed to ensure that the reduction steps do not eliminate the optimal solutions to various design problems, but do not focus on path lengths between node pairs. Further, none of the previous papers permit loss of accuracy or address its tradeoff with model size, as we do.

We next review two models from the literature—the Optimal Communication Spanning Tree (OCST) problem and the t-spanner problem—that do consider the effect of network reduction on shortest path lengths. In service network design, providing effective service requires keeping the delivery or communication times low between potential sender–receiver pairs (Magnanti & Wong, 1984). However, directly connecting every pair to minimize delivery times is very expensive. So, researchers have studied the following Optimal Communication Spanning Tree (OCST) problem (Hu, 1974) to design a sparse (tree) network spanning all the sender–receiver pairs. The problem seeks a spanning tree with minimum weighted total shortest path length, where the weight for each sender–receiver pair depends on this pair's relative importance. The special case of the OCST problem in which all sender–receiver pairs are equally important is called the Optimal Distance Spanning Tree (ODST) or minimum routing cost spanning tree problem. Because the ODST problem is NP-complete (Garey & Johnson, 1979; Johnson, Lenstra, & Rinnooy Kan, 1978), researchers have proposed various evolutionary algorithms to heuristically solve the OCST and ODST problems (e.g., Chou, Premkumar, & Chu, 2001; Fischer & Merz, 2007; Li & Bouchebaba, 1999). Researchers have also analyzed the worst-case gap for efficient approximation algorithms to solve the OCST problem (e.g., Peleg & Reshef, 1998; Sharma, 2006), the ODST problem (e.g., Campos & Ricardo, 2008; Wong, 1980; Wu, Chao, & Tang, 2000b; Wu et al., 2000), and variants such as the minimum average stretch spanning tree (Alon, Karp, Peleg, & West, 1995), optimal sum-requirement or product-requirement communication spanning tree (Wu, Chao, & Tang, 2000a), and optimal p-source communication spanning tree (Wu, 2004) problems. Compared to the abundant literature on heuristic algorithms, only a few exact algorithms have been proposed to solve the OCST or ODST problem (Ahuja & Murty, 1987; Fischetti, Lancia, & Serafini, 2002). The OCST problem can be viewed as a version of our Min-Length NR problem (on an undirected network) in which the restricted network is required to be a tree. By allowing a more general network structure than trees, the NR problem avoids long paths between sender–receiver pairs, achieving a better balance between customer service and cost.

The NR problem is also related to the t-spanner problem. A t-spanner is a subgraph of a given graph that spans all nodes while ensuring that the distance (shortest path length) between any two nodes in the subgraph is no more than t times the corresponding distance in the original graph. Among the many variants (Elkin & Peleg, 2007) of this problem, one version, called the sparsest t-spanner problem, seeks a t-spanner with the fewest number of edges. Peleg and Schaffer (1989) showed that the sparsest t-spanner problem is NP-complete even when t = 2. Researchers have mainly focused on establishing global bounds on the number of links required and devising approximation algorithms for t-spanners (e.g., Berman, Bhattacharyya, Makarychev, Raskhodnikova, & Yaroslavtsev, 2011; Cowen, 2001; Elkin & Zhang, 2006; Kortsarz & Peleg, 1994; Narasimhan & Smid, 2007). The Min-Size NR problem is similar to the sparsest t-spanner problem but is more general because it permits specifying a subset of nodes (rather than all the nodes) of the given graph that need to be connected, incorporates having different maximum length multipliers t for different node pairs, and allows including arcs that are not in the original network.

We model both the Min-Length and Min-Size NR problems as integer programs with multi-commodity flows, and show that they are NP-hard. To effectively solve these problems, we develop preprocessing strategies, applied before optimization, to eliminate nodes and arcs without increasing arc lengths, and then propose two optimization-based heuristic algorithms—a shortest path-based method for the Min-Size problem, and an algorithm that iteratively applies dual ascent for the Min-Length problem. We report successful results from applying these methods to two actual large-scale networks, and compare performance with two ODST algorithms.

The rest of the paper is organized as follows: Section 2 presents the model formulations for the Min-Size and Min-Length problems, and discusses their computational complexity. Section 3 develops solution approaches for the two NR problems. Section 4 reports on computational results that demonstrate the effectiveness of our solution procedures for actual large scale network applications, and Section 5 concludes the paper.

In this section, we formally define the two versions of the NR model, formulate the problems as integer programs with multi-commodity flows, and discuss their computational complexity.

We are given a directed graph G:(N, A) with node set N and arc set A. Each arc (i, j) ∈ A has a non-negative length cij
                         representing, for instance, the unit transportation cost, travel time, or some other performance metric associated with using the arc (i, j) to transport flows. Let K ⊆ N × N denote the set of node pairs that we wish to connect with short paths. We associate a “commodity” with each such node pair, and refer to K as the set of commodities. Each commodity k has an origin node ok
                         ∈ N and destination node dk
                         ∈ N. Let O denote the set of all origins, and D the set of all destinations for commodities in K. Some nodes may serve as both origins and destinations. We refer to nodes that are origins or destinations as “required” nodes, and define S = O ∪ D as the set of required nodes. The remaining nodes N\S are “optional” nodes. For each commodity k, let Hk
                         denote the length of the shortest path from node ok
                         to node dk
                         in the given graph G. The Network Reduction (NR) problem requires finding a reduced graph G′:(N′, A′), with S⊆N′⊆N and A′⊂{(i, j): i ∈ N, j ∈ N, i ≠ j}, such that G′ has fewer arcs (and possibly fewer nodes) than G but the shortest path length in G′ for each commodity k ∈ K is equal or close to Hk
                        . Note that the arc set A′ of the reduced graph may contain arcs that do not belong to the original arc set A. The reduced graph G′ must span all the required nodes S, but may also include some optional nodes from N\S. Including such nodes can be advantageous for reducing the number of arcs in G′. For any candidate arc (i, j) of the reduced network, we set its length hij
                         equal to the length of the shortest path from node i to node j in the original network G.

We consider two versions of the NR problem, the Min-Size network reduction problem and the Min-Length network reduction problem. The Min-Size version minimizes the number of arcs in the reduced network G′ while ensuring that the shortest path length from ok
                         to dk
                         in G′ does not exceed a given upper bound Lk
                         on this length for every commodity k. The Min-Length version, on the other hand, minimizes a weighted sum of the shortest path lengths, over all commodities, in the reduced graph G′, but requires this graph to contain no more than a prespecified number of arcs M. We first discuss the variables and constraints that are common to the multi-commodity integer programming formulations for both these problems, and then specify the objective function and additional constraints for each version.

Our NR problem formulations use two sets of binary variables that respectively represent arc selection and commodity routing decisions. Specifically, for each candidate arc (i, j), let: (i) yij
                         denote the binary arc selection variable that takes the value 1 if we include this arc (i, j) in the reduced network, and is 0 otherwise; and (ii) 
                           
                              x
                              
                                 i
                                 j
                              
                              k
                           
                         denote the commodity routing variable that is 1 if we route commodity k on arc (i, j), and 0 otherwise. Using these variables, both the Min-Size and Min-Length problems contain the following sets of constraints:

                           
                              (1)
                              
                                 
                                    
                                       
                                       
                                       
                                          
                                             Flow
                                             
                                             conservation
                                             :
                                             
                                                ∑
                                                
                                                   j
                                                   ∈
                                                   N
                                                
                                             
                                             
                                                x
                                                
                                                   j
                                                   i
                                                
                                                k
                                             
                                             −
                                             
                                                ∑
                                                
                                                   j
                                                   ∈
                                                   N
                                                
                                             
                                             
                                                x
                                                
                                                   i
                                                   j
                                                
                                                k
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             
                                             
                                             
                                             
                                             =
                                             
                                                {
                                                
                                                
                                                
                                                
                                                
                                                   
                                                      
                                                         
                                                            1
                                                            
                                                            
                                                               if
                                                               
                                                            
                                                            i
                                                            =
                                                            
                                                               o
                                                               k
                                                            
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            −
                                                            1
                                                            
                                                            
                                                               if
                                                               
                                                            
                                                            i
                                                            =
                                                            
                                                               d
                                                               k
                                                            
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            0
                                                            
                                                            otherwise
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                             for
                                             
                                             all
                                             
                                             k
                                             ∈
                                             K
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (2)
                              
                                 
                                    
                                       
                                          
                                             Forcing
                                             
                                             constraints
                                             :
                                             
                                                x
                                                
                                                   i
                                                   j
                                                
                                                k
                                             
                                             ≤
                                             
                                                y
                                                
                                                   i
                                                   j
                                                
                                             
                                             
                                             for
                                             
                                             all
                                             
                                             k
                                             ∈
                                             K
                                             ,
                                             
                                             i
                                             ,
                                             j
                                             ∈
                                             N
                                             ,
                                             i
                                             ≠
                                             j
                                             ,
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (3)
                              
                                 
                                    
                                       
                                          
                                             Integrality
                                             :
                                             
                                                y
                                                
                                                   i
                                                   j
                                                
                                             
                                             ,
                                             
                                                x
                                                
                                                   i
                                                   j
                                                
                                                k
                                             
                                             
                                                =
                                                0
                                             
                                             
                                             or
                                             
                                             1
                                             
                                             for
                                             
                                             all
                                             
                                             i
                                             ,
                                             j
                                             ∈
                                             N
                                             ,
                                             i
                                             ≠
                                             j
                                             ,
                                             k
                                             ∈
                                             K
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The flow conservation equations (1) ensure that, for each commodity, the routing variables that are set to one define a path from the commodity's origin to destination. The forcing constraints (2) specify that we can route any commodity on an arc (i, j) only if we include this arc in the reduced network. Observe that these constraints are “disaggregated,” i.e., we have one such constraint for every commodity k and each arc. Alternatively, we can formulate the forcing requirement using the following “aggregate” constraint for every commodity:

                           
                              (2′)
                              
                                 
                                    
                                       
                                          
                                             
                                                ∑
                                                
                                                   k
                                                   ∈
                                                   K
                                                
                                             
                                             
                                                x
                                                
                                                   i
                                                   j
                                                
                                                k
                                             
                                             ≤
                                             
                                                |
                                                K
                                                |
                                             
                                             
                                                y
                                                
                                                   i
                                                   j
                                                
                                             
                                             
                                             for
                                             
                                             all
                                             
                                             i
                                             ,
                                             j
                                             ∈
                                             N
                                             ,
                                             i
                                             ≠
                                             j
                                             ,
                                          
                                       
                                    
                                 
                              
                           
                        where |K| is the number of commodities. Although this version has fewer constraints, it has a weaker LP relaxation than that of the disaggregate formulation (Balakrishnan, Magnanti, & Wong, 1989; Nemhauser & Wolsey, 1988), and so is less suited for LP-based solution procedures.

We next specify the objective function and additional constraints needed for each of the two NR problem variants.

For the Min-Size problem, we are given multiplicative factors tk
                            ≥ 1 for each commodity k ∈ K, and must ensure that the length of the shortest path from ok
                            to dk
                            in the reduced graph G′ does not exceed tkHk
                           . Let 
                              
                                 
                                    L
                                    k
                                 
                                 =
                                 
                                    t
                                    k
                                 
                                 
                                    H
                                    k
                                 
                              
                            denote this upper limit. The objective of the Min-Size model is to minimize the number of arcs in the reduced graph. Using the arc selection and routing variables, we can express the objective function and path length constraints as follows:

                              
                                 (4)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   Min
                                                   −
                                                   Size
                                                
                                                
                                                problem
                                                
                                                
                                                   formulation
                                                   :
                                                
                                                
                                                Minimize
                                                
                                                   ∑
                                                   
                                                      i
                                                      ,
                                                      j
                                                      ∈
                                                      N
                                                   
                                                
                                                
                                                   y
                                                   
                                                      i
                                                      j
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           subject to: Flow conservation (1), forcing (2), integrality (3) constraints, and

                              
                                 (5)
                                 
                                    
                                       
                                          
                                             
                                                Path
                                                
                                                length
                                                
                                                constraints
                                                :
                                                
                                                   ∑
                                                   
                                                      i
                                                      ,
                                                      j
                                                      ∈
                                                      N
                                                   
                                                
                                                
                                                   
                                                      h
                                                      
                                                         i
                                                         j
                                                      
                                                   
                                                   
                                                      x
                                                      
                                                         i
                                                         j
                                                      
                                                      k
                                                   
                                                
                                                ≤
                                                
                                                   L
                                                   k
                                                
                                                
                                                for
                                                
                                                all
                                                
                                                k
                                                ∈
                                                K
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

Constraint (5) specifies that the solution must be able to route each commodity k on some path in G′ whose length does not exceed the maximum permissible length Lk
                           . Hence, the shortest origin-to-destination (OD) path in G′ must also satisfy this path length limit. Note that when tk
                            = 1, i.e., Lk
                            = Hk
                           , for all k ∈ K, the Min-Size problem just requires constructing a reduced network having the fewest arcs without increasing the shortest path lengths over the original values. We refer to any OD path in the reduced network with length at most Lk
                            as a feasible path for commodity k.

Given a set of non-negative weights wk
                            for all commodities k ∈ K and the maximum number of arcs M permitted for the reduced network, the Min-Length NR problem seeks a reduced network G′ with M or fewer arcs that minimize the total weighted shortest OD path lengths over all the commodities in K. The commodity weights reflect the relative importance of different commodities, with more “important” commodities (for which it is more important to maintain short path lengths) having higher weights. This problem has the following formulation:

                              
                                 (6)
                                 
                                    
                                       
                                          
                                          
                                          
                                             
                                                
                                                   Min
                                                   −
                                                   Length
                                                
                                                
                                                problem
                                                
                                                formulation
                                                :
                                                
                                                Minimize
                                                
                                                   ∑
                                                   
                                                      k
                                                      ∈
                                                      K
                                                   
                                                
                                                
                                                   
                                                      w
                                                      k
                                                   
                                                   
                                                      ∑
                                                      
                                                         i
                                                         ,
                                                         j
                                                         ∈
                                                         N
                                                      
                                                   
                                                   
                                                      
                                                         h
                                                         
                                                            i
                                                            j
                                                         
                                                      
                                                      
                                                         x
                                                         
                                                            i
                                                            j
                                                         
                                                         k
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           subject to: Flow conservation (1), forcing (2), integrality (3) constraints, and

                              
                                 (7)
                                 
                                    
                                       
                                          
                                             
                                                Network
                                                
                                                size
                                                
                                                constraints
                                                :
                                                
                                                   ∑
                                                   
                                                      i
                                                      ,
                                                      j
                                                      ∈
                                                      N
                                                   
                                                
                                                
                                                   y
                                                   
                                                      i
                                                      j
                                                   
                                                
                                                ≤
                                                M
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

Since the arc lengths are non-negative, this problem has an optimal solution that routes each commodity k on the shortest OD path in the chosen reduced network G′. Also, we can relax the integrality requirement for the 
                              
                                 x
                                 
                                    i
                                    j
                                 
                                 k
                              
                            variables since we can show that, for any feasible integer values of the yij
                            variables, the relaxed model has an optimal solution in which all x-values are integral.

The Min-Size problem controls the path length for each commodity while minimizing the size of the reduced network, while the Min-Length problem controls the size of the network but minimizes the total (weighted) shortest path length over all commodities. The choice between these two models depends on the application context. If it is important to ensure “fairness” across commodities (i.e., avoid having very long paths for certain commodities) or necessary to preserve original shortest path lengths, the Min-Size model is suitable. On the other hand, if the reduced network's maximum permissible size is an important requirement and we are willing to tolerate some approximation in the shortest paths, then the Min-Length model is appropriate. For instance, in our infrastructure project planning application (discussed in Sections 1 and 4), since the resource movement cost is one among several costs (including costs for resource selection and assignment, and job timing), the Min-Length NR model is appropriate; solving this model led to significant reduction in computational time for the planning model with only minimal loss of accuracy in the objective function.

We conclude this discussion of modeling NR problems by noting that both our formulations readily extend to other variants. For instance, we have focused on the “directed” case in which the given and reduced networks have directed arcs. Depending on the context, we can develop an “undirected” version in which selecting an undirected edge {i, j} permits using that edge in either direction, i.e., to flow or travel from i to j or from j to i. Only the following two changes are needed for this undirected model:

                              
                                 (i)
                                 instead of defining arc selection variables yij
                                     for every arc, we define an edge selection variable, say zij
                                    , for each candidate undirected edge, i, j ∈ N, i < j. We continue to use directed routing variables 
                                       
                                          x
                                          
                                             i
                                             j
                                          
                                          k
                                       
                                    , two for each edge and commodity; and,

we replace the forcing constraints (2) with 
                                       
                                          
                                             x
                                             
                                                i
                                                j
                                             
                                             k
                                          
                                          +
                                          
                                             x
                                             
                                                j
                                                i
                                             
                                             k
                                          
                                          ≤
                                          
                                             z
                                             
                                                i
                                                j
                                             
                                          
                                       
                                     for each candidate edge {i, j} and commodity k. This constraint exploits the fact that both NR models have optimal solutions that do not simultaneously route any commodity k in both directions on any edge.

Similarly, we can readily modify the model to incorporate other extensions such as having commodity-dependent arc lengths.

Next, we establish the computational complexity of the Min-Size and Min-Length problems:


                        
                           Proposition 1
                           
                              The Min-Size and Min-Length NR problems are NP-hard for both directed and undirected networks.


                        
                           Proof
                           We establish this result (see Appendix A) by relating both NR problems to known NP-hard problems such as sparsest t-spanner, ODST, and p-median problems.

The NR problems, besides being theoretically difficult to solve as shown by Proposition 1, are also very challenging to solve in practice because the formulation size is very large. For instance, in the infrastructure project planning problem, the underlying network contains about 8500 nodes, out of which 100 nodes are required, and we must consider the path lengths between every pair of required nodes. Hence, the number of candidate arcs for the reduced network exceeds 70 million, and the number of commodities is 9900. Even advanced solvers and computers cannot solve such very large instances of the NR problems to optimality. We, therefore, focus next on developing and applying optimization-based heuristic procedures.

To effectively solve the NR problem (Min-Size or Min-Length versions), this section first discusses preprocessing techniques, applied before solving the problem, to condense the network without increasing the shortest path length for any commodity in K. We then describe two broad optimization-based heuristic strategies for the Min-Size and Min-Length problems that use shortest path methods and dual ascent to identify good heuristic solutions quickly.

We first apply two methods to drop some nodes from the original network G and replace arcs. These preprocessing procedures are effective when the original network G has “local sparsity,” i.e., when G contains some nodes that have few incident arcs, as is common for actual networks including those we tested (see Section 4). The methods consist of “bypassing” certain nodes by adding direct arcs from their predecessors to successors (if G does not already contain these arcs), and then deleting the bypassed nodes and incident arcs. These nodes are chosen so that the network transformation does not increase, and may decrease, the total number of arcs; the operations may also reduce the number of commodities.

To facilitate the discussions in this section, we introduce some additional notation. We refer to the network obtained after intermediate and final steps of the preprocessing procedures as the condensed network, and denote it as G
                        c: (N
                        c, A
                        c). Initially, G
                        c = G, and the length of each arc (i, j) ∈ A
                        c is hij
                        , the length of the shortest path in G from node i to node j. For any node i ∈ N
                        c, let 
                           
                              
                                 A
                                 +
                              
                              
                                 (
                                 i
                                 )
                              
                           
                         and 
                           
                              
                                 A
                                 −
                              
                              
                                 (
                                 i
                                 )
                              
                           
                         respectively denote the set of all arcs in G
                        c that are incident from and to node i. Correspondingly, let 
                           
                              
                                 N
                                 +
                              
                              
                                 (
                                 i
                                 )
                              
                              =
                              
                                 {
                                 j
                                 :
                                 
                                    (
                                    i
                                    ,
                                    j
                                    )
                                 
                                 ∈
                                 
                                    A
                                    +
                                 
                                 
                                    (
                                    i
                                    )
                                 
                                 }
                              
                           
                         and 
                           
                              
                                 N
                                 −
                              
                              
                                 (
                                 i
                                 )
                              
                              =
                              
                                 {
                                 l
                                 :
                                 
                                    (
                                    l
                                    ,
                                    i
                                    )
                                 
                                 ∈
                                 
                                    A
                                    −
                                 
                                 
                                    (
                                    i
                                    )
                                 
                                 }
                              
                           
                         denote the sets of successors and predecessors of node i in G
                        c.

Suppose an origin node i ∈ O\D has only one outgoing arc in G
                           c, i.e., 
                              
                                 
                                    |
                                 
                                 
                                    A
                                    +
                                 
                                 
                                    
                                       (
                                       i
                                       )
                                    
                                    |
                                    =
                                    1
                                 
                              
                           , and let (i, j) be this incident arc. Then, we can delete node i and its incident arcs, and for each node 
                              
                                 l
                                 ∈
                                 
                                    N
                                    −
                                 
                                 
                                    
                                       (
                                       i
                                       )
                                    
                                    ∖
                                    
                                       {
                                       j
                                       }
                                    
                                 
                              
                           , if arc (l, j) ∉ A
                           c, we add the arc (l, j), with length hlj
                           , to G
                           c. These steps do not increase, and may decrease, the number of arcs in the network. After eliminating an origin node i, we also need to adjust the commodity structure. Let K
                           0(i) be the set of commodities for which node i is the origin. For each commodity k ∈ K
                           0(i), we redefine its origin as node j, i.e., set ok
                            = j. For the Min-Size model, we must also subtract the length of the original arc (i, j) from the maximum path length for commodity k, i.e., we set 
                              
                                 
                                    L
                                    k
                                 
                                 ←
                                 
                                    L
                                    k
                                 
                                 −
                                 
                                    h
                                    
                                       i
                                       j
                                    
                                 
                              
                           , and for the Min-Length model we add the constant wkhij
                            to the objective function. These operations of adding arcs and changing commodity origins and parameters ensure that the shortest OD path lengths for all the commodities over the modified graph G
                           c are the same as those in the original problem.

We can apply a similar technique when a destination node i ∈ D\O has only one incoming arc (l, i). In this case, for each node 
                              
                                 j
                                 ∈
                                 
                                    N
                                    +
                                 
                                 
                                    
                                       (
                                       i
                                       )
                                    
                                    ∖
                                    
                                       {
                                       l
                                       }
                                    
                                 
                              
                           , if arc (l, j) ∉ A
                           c, we add the arc (l, j), with length hlj
                           , to G
                           c. Then, we delete node i and all its incident arcs. For any commodity k that previously terminated at node i, we treat node l as the new destination for this commodity, and update 
                              
                                 
                                    L
                                    k
                                 
                                 ←
                                 
                                    L
                                    k
                                 
                                 −
                                 
                                    h
                                    
                                       l
                                       i
                                    
                                 
                              
                            for the Min-Size model or add wkhli
                            to the objective of the Min-Length model.

Finally, suppose node i is both an origin and destination, and it has two incident arcs (i, j) and (j, i) that are both incident to and from node j. In this case, we eliminate node i and both of these arcs, and change the origin (or destination) of any commodity that previously originated (or terminated) at node i to node j. We then make appropriate changes (as above) to the Min-Size model's parameters Lk
                           , for commodities k that originate or terminate at node i, or to the Min-Length model's objective function. There are also some generalizations of this reduction.

As a final step of this required node elimination procedure, we can further simplify the problem when the previous steps change the origin or destination of a commodity. Recall that when we delete an origin node i with a single outgoing arc (i, j), we change the origin for every commodity k that originated at i to node j. Suppose the commodity set K already contains another commodity k′ with node j as its origin and the same destination as commodity k. In this case, when we change commodity k’s origin to node j, we now have two commodities k and k′ that have the same origin and same destination. We can combine these two commodities into a single commodity, denoted as k″, and define its parameters as follows: set 
                              
                                 
                                    L
                                    
                                       k
                                       
                                          ′
                                          ′
                                       
                                    
                                 
                                 =
                                 min
                                 
                                 
                                    {
                                    
                                       
                                          L
                                          
                                             k
                                             ′
                                          
                                       
                                       ,
                                       
                                          L
                                          k
                                       
                                    
                                    }
                                 
                              
                            for the Min-Size model, or 
                              
                                 
                                    w
                                    
                                       k
                                       
                                          ′
                                          ′
                                       
                                    
                                 
                                 =
                                 
                                    w
                                    
                                       k
                                       ′
                                    
                                 
                                 +
                                 
                                    w
                                    k
                                 
                              
                            for the Min-Length model.

We now consider optional nodes i ∈ N\S that have one or more incoming and outgoing arcs. We wish to determine if we can eliminate this node and its incident arcs by bypassing the node, without increasing the number of arcs in the current network G
                           c. The bypassing steps consist of: (i) deleting node i and all its incident arcs, and (ii) adding new arcs (l, j) ∉ A
                           c for 
                              
                                 l
                                 ∈
                                 
                                    N
                                    −
                                 
                                 
                                    (
                                    i
                                    )
                                 
                              
                           , 
                              
                                 j
                                 ∈
                                 
                                    N
                                    +
                                 
                                 
                                    
                                       (
                                       i
                                       )
                                    
                                    ∖
                                    
                                       {
                                       l
                                       }
                                    
                                 
                              
                           , with arc length hlj
                           . These steps generalize the analogous operations for eliminating required nodes to the case when node i has multiple predecessors and successors. Since node i is optional, bypassing it does not change the commodity structure. We next develop a condition under which this bypassing procedure does not increase the number of arcs. Let 
                              
                                 
                                    N
                                    0
                                 
                                 
                                    (
                                    i
                                    )
                                 
                                 =
                                 
                                    N
                                    +
                                 
                                 
                                    (
                                    i
                                    )
                                 
                                 ∩
                                 
                                    N
                                    −
                                 
                                 
                                    (
                                    i
                                    )
                                 
                              
                            denote the set of nodes that are both predecessors and successors of node i, i.e., G
                           c contains both arcs (i, j) and (j, i) for nodes j ∈ N
                           0(i). Let ADc
                           (i) denote the set of arcs (l, j) from predecessors l to successors j of i that G
                           c already contains. Then, the following proposition provides the desired condition when deleting (bypassing) an optional node i yields a network with one less node without increasing the number of arcs.


                           
                              Proposition 2
                              
                                 For any optional node i, if in the current network G
                                 c
                                 
                                    
                                       (8)
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         |
                                                      
                                                      
                                                         N
                                                         +
                                                      
                                                      
                                                         
                                                            
                                                               (
                                                               i
                                                               )
                                                            
                                                            |
                                                         
                                                         *
                                                      
                                                      
                                                         |
                                                      
                                                      
                                                         N
                                                         −
                                                      
                                                      
                                                         
                                                            (
                                                            i
                                                            )
                                                         
                                                         |
                                                         −
                                                         |
                                                      
                                                      
                                                         N
                                                         0
                                                      
                                                      
                                                         
                                                            (
                                                            i
                                                            )
                                                         
                                                         |
                                                         −
                                                         |
                                                         A
                                                      
                                                      
                                                         D
                                                         c
                                                      
                                                      
                                                         
                                                            (
                                                            i
                                                            )
                                                         
                                                         |
                                                         ≤
                                                         |
                                                      
                                                      
                                                         N
                                                         +
                                                      
                                                      
                                                         
                                                            (
                                                            i
                                                            )
                                                         
                                                         |
                                                         +
                                                         |
                                                      
                                                      
                                                         N
                                                         −
                                                      
                                                      
                                                         
                                                            (
                                                            i
                                                            )
                                                         
                                                         |
                                                         ,
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                                 then bypassing node i does not increase the number of arcs in the network.
                              


                           
                              Proof
                              See Appendix B.

Observe that, for any node i with 
                              
                                 
                                    |
                                 
                                 
                                    N
                                    +
                                 
                                 
                                    
                                       (
                                       i
                                       )
                                    
                                    |
                                    =
                                    1
                                 
                              
                            or 
                              
                                 
                                    |
                                 
                                 
                                    N
                                    −
                                 
                                 
                                    
                                       (
                                       i
                                       )
                                    
                                    |
                                    =
                                    1
                                 
                              
                           , condition (8) is always satisfied (even if N
                           0(i) and ADc
                           (i) are empty), and so Proposition 2 implies that we can eliminate optional nodes that have only one incoming or one outgoing arc. Thus, the proposition formally extends the validity of our previous required node elimination method to optional nodes. Among the several other interesting implications of Proposition 2, we consider its application to “bi-directed” networks in which, for every arc (i, j) ∈ A, the network also contains the reverse arc (j, i). So, for every node i, 
                              
                                 
                                    N
                                    0
                                 
                                 
                                    (
                                    i
                                    )
                                 
                                 =
                                 
                                    N
                                    +
                                 
                                 
                                    (
                                    i
                                    )
                                 
                                 =
                                 
                                    N
                                    −
                                 
                                 
                                    (
                                    i
                                    )
                                 
                              
                           , i.e., each of node i’s predecessors is also a successor. The real problems that we used for computational testing have this property. Applying Proposition 2 to such networks yields the following corollary.


                           
                              Corollary 3
                              For bi-directed networks, we can eliminate (bypass) all optional nodes with three or fewer neighbors without increasing the network size.

The result in Corollary 3 only requires bi-directed arcs between neighbors of optional nodes, not origin or destination nodes, and so applies even to networks that are not fully bi-directed. Proposition 2 and Corollary 3 generalize some network reduction ideas discussed in the literature (e.g., Bein et al., 1992; Goczyła & Cielatkowski, 1995; Tavares, 2002). These papers focus on reducing networks that contain several nodes in series (each with degree two), whereas our methods also apply to more complex topologies.

To apply the two node elimination methods, we sequentially examine nodes i in the current network, and determine if either method can bypass this node. Since this operation also deletes some arcs, the in-degree or out-degree of the remaining nodes can decrease (e.g., if the network already contains all the arcs connecting an eliminated node's predecessors to its successors). In this case, these neighbors may now satisfy the needed condition, e.g., condition (8), to eliminate them. So, after completing one pass or iteration through the list of nodes, applying the sequential procedure again may yield additional reduction in the number of nodes, arcs, and commodities. These iterations stop when no further elimination is possible. In the subsequent discussions, we will assume that the given network is already condensed using the preprocessing methods (i.e., update G ← G
                           c at the end of the node elimination iterations).

This section proposes a three-phase heuristic procedure, based on shortest path computations, for the Min-Size problem. The first phase finds arcs that must be excluded or necessarily included in the reduced network due to the Min-Size model's path length restrictions. The second phase builds a feasible network, starting with the essential arcs, so as to include a feasible path for all commodities. The third phase uses a myopic drop procedure to improve this solution.

The first phase of the heuristic identifies two special types of arcs: (i) infeasible arcs that cannot belong to any feasible path satisfying the maximum length restrictions for a commodity, and (ii) essential arcs that must necessarily be included in the network to create feasible paths.

Recall that the Min-Size problem imposes an upper bound of Lk
                               on the length of the OD path on which commodity k is routed in the reduced network. So, if we can identify, a priori, arcs (i, j) that cannot lie on any feasible path, we can eliminate the corresponding routing variables 
                                 
                                    x
                                    
                                       i
                                       j
                                    
                                    k
                                 
                               and omit the arcs from the graph for commodity k. To verify if an arc (i, j) can belong to a feasible ok
                              -to-dk
                               path, we determine the shortest path from ok
                               to node i, and from node j to dk
                              . The length of the shortest path for commodity k via arc (i, j) is the sum of lengths of these two shortest paths plus the length of arc (i, j); then, commodity k can flow on arc (i, j) only if this total length is less than or equal to Lk
                              . This test reduces to the following arc infeasibility condition:

For any arc (i, j), with i, j ∈ N and i ≠ j, if 
                                 
                                    
                                       h
                                       
                                          
                                             o
                                             k
                                          
                                          i
                                       
                                    
                                    +
                                    
                                       h
                                       
                                          i
                                          j
                                       
                                    
                                    +
                                    
                                       h
                                       
                                          j
                                          
                                             d
                                             k
                                          
                                       
                                    
                                    >
                                    
                                       L
                                       k
                                    
                                 
                              , then commodity k cannot flow on arc (i, j).

If this condition holds, we can delete the variable 
                                 
                                    x
                                    
                                       i
                                       j
                                    
                                    k
                                 
                               from the Min-Size formulation, and also ignore this arc when routing the commodity in any heuristic procedure. We can show that eliminating the variable not only reduces the model size but can also strengthen the LP relaxation of the integer program, thereby improving the performance of LP-based solution procedures.

Let GSk
                              : (NSk, ASk
                              ) denote the graph consisting of all nodes and arcs on which commodity k can flow (after eliminating infeasible arcs). We refer arcs in ASk
                               as eligible arcs for commodity k. An arc (i, j) ∈ ASk
                               is an essential arc for commodity k if every feasible OD path for commodity k contains this arc. To determine if an arc (i, j) ∈ ASk
                               is essential, we just need to check if, after removing arc (i, j) from GSk
                              , the destination dk
                               is still reachable from the origin ok
                               on a feasible path. Arc (i, j) is essential only if this graph does not contain a feasible path for commodity k. So, we can identify all the essential arcs for a commodity by solving |ASk
                              | shortest path problems, one for each arc (i, j) ∈ ASk
                              , by omitting this arc from GSk
                              . To reduce the computational effort, we first use the following properties to easily identify some essential arcs before solving the above shortest path problems. For this discussion, we refer to nodes spanned by essential arcs, together with the origin node ok
                               and destination dk
                              , as essential nodes for commodity k, and denote this set as NSEk
                               (we initialize this set as {ok, dk
                              }, and update it as we discover more essential nodes).


                              
                                 Property 1
                                 If an essential node i ∈ NSEk\{dk
                                    } has only one outgoing arc (i, j) in GSk
                                    , then this arc is essential for commodity k, and node j is an essential node. Similarly, if an essential node i ∈ NSEk\{ok
                                    } has only one incoming arc (l, i) in GSk
                                    , then arc (l, i) is essential for commodity k, and node l is an essential node.


                              
                                 Property 2
                                 If |ASk
                                    | = |NSk
                                    | − 1, then all the arcs in ASk
                                     are essential arcs for commodity k.

Since the origin (destination) is an essential node, if it has only one outgoing (incoming) arc in GSk
                              , then by Property 1 this arc is essential and we can label the other node at which the arc is incident as an essential node. We can then reapply the tests in Property 1 to possibly identify other essential arcs and nodes. The validity of Property 2 stems from noting that, for any node i ∈ NSk
                              \{ok, dk
                              }, GSk
                               must contain a feasible OD path passing through node i (otherwise, the arcs to and from this node are infeasible and should have been previously eliminated). Therefore, if a commodity k has more than one feasible OD path, ASk
                               must contain at least |NSk
                              | arcs. Conversely, if |ASk
                              | = |NSk
                              | − 1, commodity k must have a unique OD path in GSk
                              , and all of the arcs on this path are essential.

Let N
                              0 and A
                              0 denote the sets of essential nodes and essential arcs identified in this first phase. The graph G
                              0: (N
                              0, A
                              0) serves as the initial network for the following network construction phase.

We propose two methods—sequential arc addition and sequential commodity routing—to construct an initial feasible (reduced) network. Both methods start with the initial network G
                           0 and progressively grow the network by adding eligible arcs that are not already selected.

The sequential arc addition method iteratively adds arcs until the network contains a feasible path for all commodities. We can develop many possible rules to decide the order for examining the arcs. For instance, let μij
                            denote the number of commodities for which arc (i, j) lies on a feasible OD path. Since any arc (i, j) with a high value of μij
                            is eligible for more commodities, and is an attractive candidate for inclusion in the reduced network, we can consider arcs for addition in decreasing order of μij
                           . We can also iteratively update μij
                            by only considering commodities that do not yet have a feasible path in the current (partial) network.

The sequential commodity routing method iteratively considers commodities, finds a feasible path for that commodity using current and new arcs (i.e., those not yet in the network), and adds these new arcs to the network. Again, there are many ways to sequence the commodities and find a feasible path that satisfies the maximum path length constraint (5). Note that, at each iteration, adding new arcs to create a feasible path for one commodity may also create feasible paths for other commodities we have not yet been considered. So, at each iteration, we only need to consider commodities that do not already have a feasible OD path in the current network.

We apply both network construction methods, and select the solution with fewer arcs as the starting solution, denoted as G′: (N′, A′), for the following local improvement phase.

Network G′ may contain some arcs that can be removed without affecting feasibility because certain commodities may have alternative feasible paths in G′. To identify such network reduction opportunities, we consider the arcs of the current network G′ in some order. For instance, given a feasible routing of commodities in G′, arcs that carry more commodities are better candidates for retention. So, we can consider arcs in increasing order of vij
                           , the number of commodities that are currently routed on an arc (i, j). (Any arc (i, j) with vij
                            = 0 can be first dropped from A′.) For each arc (i, j) in sequence, we determine whether the remaining network after we delete (i, j) from A′ contains feasible paths for all commodities by verifying if the shortest OD path length in A′\(i, j) for each commodity k is less than or equal to Lk
                           . If so, we can drop the arc by updating A′ ← A′\(i, j); further, if node i (or node j) is an optional node and only one arc of the updated arc set A′ is incident to or from this node, then we can remove this node from N′ and also delete the single incident arc from A′. For commodities that previously used the dropped arc(s), we identify feasible paths in the reduced arc set A′ and update the values vij
                           . We then consider the next arc in the reduced network, and repeat the process until we have examined all arcs of A′. After dropping arcs, we can apply the previous node elimination method again to possibly bypass some remaining optional nodes.

To solve the Min-Length problem, we develop a dual-based method that approximately solves the dual of a relaxed NR problem to identify good heuristic solutions. The method parametrically varies a cost multiplier associated with the network size constraint and, for each value of the parameter, applies a dual ascent method to the resulting subproblem to generate a reduced network. The procedure terminates when the network satisfies the size requirement or no further network reduction is possible.

This method is based on the following main observation. Suppose, instead of explicitly imposing the network size constraint (7), we assign a “fixed” cost of, say, F per arc for each arc included in the reduced network, and modify the objective function to include both the weighted path lengths (6) and the additional arc inclusion costs. That is, we consider the following “modified” problem which we call Min-Cost (F):

                           
                              (9)
                              
                                 
                                    
                                       
                                          
                                             Z
                                             
                                                (
                                                F
                                                )
                                             
                                             =
                                             min
                                             
                                                ∑
                                                
                                                   
                                                      (
                                                      i
                                                      ,
                                                      j
                                                      )
                                                   
                                                   ∈
                                                   
                                                      A
                                                      ¯
                                                   
                                                
                                             
                                             
                                                F
                                                
                                                   y
                                                   
                                                      i
                                                      j
                                                   
                                                
                                             
                                             +
                                             
                                                ∑
                                                
                                                   k
                                                   ∈
                                                   K
                                                
                                             
                                             
                                                
                                                   w
                                                   k
                                                
                                                
                                                   ∑
                                                   
                                                      
                                                         (
                                                         i
                                                         ,
                                                         j
                                                         )
                                                      
                                                      ∈
                                                      
                                                         A
                                                         ¯
                                                      
                                                   
                                                
                                                
                                                   
                                                      h
                                                      
                                                         i
                                                         j
                                                      
                                                   
                                                   
                                                      x
                                                      
                                                         i
                                                         j
                                                      
                                                      k
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        subject to: constraints (1)–(3).

Intuitively, as the cost per arc F increases, we expect that the optimal solution to Min-Cost (F) will contain fewer arcs. The following proposition formally establishes this property.


                        
                           Proposition 4
                           
                              The Min-Cost(F) problem has an optimal solution in which the number of arcs does not increase as F increases.
                           


                        
                           Proof
                           See Appendix C.


                        Proposition 4 suggests that we can parametrically solve the modified problem with increasing values of F until the solution to Min-Cost(F) gives a network that is as small as desired or possible (in terms of number of arcs). We can interpret Min-Cost(F) as the Lagrangian subproblem when we dualize constraint (7) using the multiplier F.

To solve the Min-Cost(F) problem, for any given value of F, we apply a dual-ascent algorithm that approximately solves the problem's LP relaxation to generate tight lower bounds on the optimal value Z(F) and to also construct good heuristic solutions. Dual-ascent algorithms have been successfully used to solve many challenging network design problems such as the uncapacitated plant location (e.g., Bilde & Krarup, 1977; Erlenkotter, 1978) and Steiner tree (Wong, 1984) problems. Balakrishnan et al. (1989) generalized these previous methods to effectively solve large-scale, fixed-charge uncapacitated network design problems. Dual ascent has also been applied to a broader range of network optimization problems including capacitated network design (Gendron, 2002; Herrmann, Ioannou, Minis, & Proth, 1996), connected facility design (Bardossy & Raghavan, 2010), hub network design (Yoon & Current, 2008), and transportation network design (Barnhart, Jin, & Vance, 2000; Crainic, 2000). Barnhart et al. (2000) combined Lagrangian relaxation with dual-ascent, analogous to our approach.

The Min-Cost(F) problem is a fixed-charge uncapacitated network design problem, but with all arcs having the same fixed cost F. We therefore use the effective dual ascent algorithm for network design developed by Balakrishnan et al. (1989) to find a good solution to the following dual of the LP relaxation of the Min-Cost(F) problem, which we call Dual-Min-Cost(F):

                           
                              (10)
                              
                                 
                                    
                                       
                                          
                                             Z
                                             D
                                             
                                                (
                                                F
                                                )
                                             
                                             =
                                             max
                                             
                                                ∑
                                                
                                                   k
                                                   ∈
                                                   K
                                                
                                             
                                             
                                                γ
                                                
                                                   
                                                      d
                                                      k
                                                   
                                                
                                                k
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (11)
                              
                                 
                                    
                                       
                                          
                                             
                                                γ
                                                j
                                                k
                                             
                                             −
                                             
                                                γ
                                                i
                                                k
                                             
                                             ≤
                                             
                                                w
                                                k
                                             
                                             
                                                h
                                                
                                                   i
                                                   j
                                                
                                             
                                             +
                                             
                                                λ
                                                
                                                   i
                                                   j
                                                
                                                k
                                             
                                             
                                             for
                                             
                                             all
                                             
                                             
                                                (
                                                
                                                   i
                                                   ,
                                                   j
                                                
                                                )
                                             
                                             ,
                                             k
                                             ,
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (12)
                              
                                 
                                    
                                       
                                          
                                             
                                                ∑
                                                
                                                   k
                                                   ∈
                                                   K
                                                
                                             
                                             
                                                λ
                                                
                                                   i
                                                   j
                                                
                                                k
                                             
                                             ≤
                                             F
                                             
                                             for
                                             
                                             all
                                             
                                             
                                                (
                                                
                                                   i
                                                   ,
                                                   j
                                                
                                                )
                                             
                                             ,
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (13)
                              
                                 
                                    
                                       
                                          
                                             
                                                λ
                                                
                                                   i
                                                   j
                                                
                                                k
                                             
                                             ≥
                                             0
                                             
                                             for
                                             
                                             all
                                             
                                             
                                                (
                                                
                                                   i
                                                   ,
                                                   j
                                                
                                                )
                                             
                                             ,
                                             k
                                             ,
                                          
                                       
                                    
                                 
                              
                           
                        where 
                           
                              γ
                              i
                              k
                           
                         and 
                           
                              λ
                              
                                 i
                                 j
                              
                              k
                           
                         are respectively the dual variables corresponding to constraints (1) and (2). Since ZD(F) ≤ Z(F), the objective value of any feasible dual solution is a lower bound on the optimal value of Min-Cost(F). Besides generating a tight lower bound, the dual-based method also constructs a heuristic solution based on the final dual values.

The method is based on the following two key observations: (i) constraint (12) requires “allocating” the fixed cost F of each arc (i, j) to various commodities via the variables 
                           
                              λ
                              
                                 i
                                 j
                              
                              k
                           
                        ; and, (ii) for given values of 
                           
                              λ
                              
                                 i
                                 j
                              
                              k
                           
                         satisfying (12), constraints (11) and the objective function (10) of Dual-Min-Cost(F) correspond to the dual of a shortest path problem using 
                           
                              (
                              
                                 w
                                 k
                              
                              
                                 h
                                 
                                    i
                                    j
                                 
                              
                              +
                              
                                 λ
                                 
                                    i
                                    j
                                 
                                 k
                              
                              )
                           
                         as arc lengths. So, the dual ascent method judiciously and iteratively allocates portions of each arc's fixed cost to various commodities so as to maximize the sum of shortest OD path lengths over all commodities. For this purpose, the method uses a Labeling procedure to increase the λ-values for one commodity k at a time in order to increase the length of the shortest path from ok
                         to dk
                        ; the procedure terminates when every commodity's destination is labeled (see Balakrishnan et al., 1989 for details). Computational results have shown that the value of the final dual solution is close to ZD(F) and is a very good lower bound on the optimal value of Min-Cost(F).

This procedure offers another key advantage that is important for our purpose. We are interested in generating a good heuristic (primal) solution to Min-Cost(F) containing few arcs; the final dual solution at the end of dual ascent yields such a network. Specifically, it can be shown that, when the dual ascent method terminates, the network consisting of arcs with zero slack (in constraints (12)) contains an OD path for every commodity. Let G1(F) denote this reduced network. We can apply the following two procedures to further reduce the size of this network:

                           
                              (i)
                              Apply the Min-Size heuristic of Section 3.2 to G1(F) to obtain a smaller network G2(F), with the requirement that, for every commodity k, the length of the shortest OD path in G2(F) must be the same as the shortest path length in G1(F). This requirement ensures that the objective value (9), which includes the weighted shortest path lengths, does not increase when we reduce the network from G1(F) to G2(F); and,

Apply the previous node elimination method to G2(F) to possibly bypass some of its optional nodes and further reduce the number of arcs. Let G3(F) denote this reduced network.

If the number of arcs in G3(F) does not exceed the maximum desired number of arcs M, then the Min-Length algorithm terminates. Otherwise, we increase the value of F, and re-apply the dual ascent method to network G3 (from the last iteration), followed by the improvement steps.

We next remark on selecting the values of F. Recall that problem Min-Cost(F) is related to the Lagrangian subproblem obtained by dualizing constraint (7). In Lagrangian relaxation, since one of the main goals is to obtain as high a lower bound as possible on the optimal value of the original problem, the emphasis is on trying to find the “best” value of multiplier F (i.e., solve the Lagrangian dual problem) using methods such as subgradient optimization. Our goal, however, is different since we primarily seek a feasible solution to the Min-Length problem satisfying the limit on network size. So, instead of applying conventional Lagrangian relaxation multiplier adjustment methods (e.g., Fisher, 1981) to update the value of F, we iteratively increase this value in proportion to the excess number of arcs (over M) in the reduced network G3(F) at the current iteration (this excess number is a subgradient). Specifically, let Ft
                         denote the value of the fixed cost parameter for the tth time (or iteration) that we apply the network design dual ascent method. If the number of arcs Mt
                         in the reduced network at the end of this method exceeds the limit M, we update the value of F for the next iteration as follows:


                        
                           
                              
                                 F
                                 
                                    t
                                    +
                                    1
                                 
                              
                              =
                              Min
                              
                                 {
                                 
                                    θ
                                    1
                                 
                                 
                                    F
                                    t
                                 
                                 ,
                                 Max
                                 
                                    {
                                    
                                       F
                                       t
                                    
                                    +
                                    
                                       v
                                       t
                                    
                                    
                                       (
                                       
                                          M
                                          t
                                       
                                       −
                                       M
                                       )
                                    
                                    ,
                                    
                                       θ
                                       2
                                    
                                    
                                       F
                                       t
                                    
                                    }
                                 
                                 }
                              
                           
                        , where vt
                         is a step-size parameter, and θ
                        1 and θ
                        2 are two parameters greater than one that respectively limit the minimum and maximum increase in F-value from one iteration to next. In our implementation, we initialize F to F
                        0 = 1, and set v
                        0 = 1, θ
                        1 = 1.05, and θ
                        2 = 1.5. If the size of the network reduces by less than 1 percent for two consecutive iterations, we double vt
                        ; otherwise we reset vt
                         to 1.

We note that parametrically solving Min-Cost(F) for increasing values of F has the added advantage of assessing the tradeoff between network size and the total (weighted) shortest path length. In practice, planners may not be sure initially about what value to use for the upper limit M on network size, and so may prefer to see this tradeoff curve to select a desired size that achieves a satisfactory approximation of the total shortest path length. Thus, although our heuristic does not guarantee finding a solution that satisfies the upper bound on network size, it can be very useful in practice.

To quantify the approximation in shortest path lengths, we define the following metric. Let ZC denote the weighted sum of shortest path lengths in the reduced network G′, and let 
                           
                              
                                 Z
                                 ̲
                              
                              =
                              
                                 ∑
                                 k
                              
                              
                                 
                                    w
                                    k
                                 
                                 
                                    H
                                    k
                                 
                              
                           
                         denote the smallest possible weighted sum, obtained by using the shortest OD path length Hk
                         for each commodity k in the original network G. Then, the ratio 
                           
                              ρ
                              =
                              
                                 
                                    (
                                    Z
                                    C
                                    −
                                    
                                       Z
                                       ̲
                                    
                                    )
                                 
                                 /
                                 
                                    Z
                                    ̲
                                 
                              
                           
                         represents the deviation (approximation) of the total shortest path length in G′ relative to its smallest possible value. We refer to this metric as the Approximation Error ratio. For our test problems, the Min-Length heuristic was able to achieve very good approximation while significantly reducing the size of the network (see Section 4). With small F, the dual ascent method can provide a solution with zero or near-zero approximation error. Hence, the method can also be potentially used for the Min-Size problem.

To conclude this discussion of network reduction algorithms, we remark on the relationship between arcs and paths in the reduced network and the original network G. The arcs in G represent flow or transport along the physical links of the network; for the network reduction problem, we can interpret arcs (i, j) of the reduced network G′ that are not originally in G as “logical” (or virtual) links that represent movement along multiple physical arcs in sequence. During our algorithm, whenever such logical links are added (when bypassing nodes), we record the embedding relationship between these links and the original arcs. Thus, after our solution method finds a reduced network, the decision maker can easily translate this solution back to the original network by expanding the logical links using the stored embedding information.

We successfully applied the proposed algorithms to the infrastructure project network that motivated this work and to a distribution planning problem over an actual road network.

For the infrastructure project planning problem described in Section 1, the resources (e.g., equipment) needed for the projects are moved from one job location to the next over a physical (rail) network G, spanning over half the U.S. states and containing 8490 nodes and 17,372 arcs. Service is required at 127 nodes (origins and destinations); the remaining nodes are optional. The planning model entails routing different types of resources, some of which can work at all the required nodes, while others are restricted in their work locations (and hence have fewer required nodes). Since each resource type has separate routing variables and constraints in the planning model, we can reduce the network size for each resource type separately. For this computational study, we consider five resource types, labeled as R1–R5.

Column 2 of Table 1
                        
                         shows the number of required nodes for the problem instance corresponding to each resource type. Resource types R1 and R2 are the most ‘versatile’ resources that can work at all or most of the work locations and hence have more required nodes. Resource types R3 and R4 have intermediate levels of flexibility, while resource type R5 is most restricted or specialized. For each problem instance, the commodity structure is “complete,” i.e., we are interested in low shortest path lengths from each required node to every other required node; Column 3 of Table 1 shows the number of commodities for each instance. For the infrastructure project planning application, the Min-Length version of network reduction was considered appropriate since the problem does not impose explicit limits on individual path lengths and routing cost is one of the components of the objective function. Column 4 shows the desired maximum number of arcs (three times the number of required nodes) for each problem instance, with more arcs permitted for instances corresponding to more versatile resources. Since the number of arcs needed in the reduced network increases with the number of required nodes, which varies with problem instance, in our summary of computational results we include values of arc density which we define as the number of arcs in the reduced network divided by the number of required nodes. This metric permits better performance comparison across problem instances rather than just comparing the number of arcs.

Before applying the Min-Length dual-based procedure, we first applied the preprocessing (node bypassing) methods, and then applied the shortest path-based method, developed for the Min-Size problem, to further condense the network while preserving the original shortest path lengths (i.e., Lk
                         = Hk
                        ). Table 2 shows the dimensions of the condensed network after preprocessing, including both the actual number of nodes, arcs, and commodities and percentages (in parentheses) of the corresponding values for the original network.

The preprocessing procedure takes only around one second for each problem. As the statistics in Table 2 show, the preprocessing techniques significantly reduce the size of the network. For instance, for problem R1, the procedure reduces the number of arcs from the original 17,372 arcs to 836 arcs, a 95.19 percent reduction. These results demonstrate that our procedure is able to effectively exploit the local sparsity of the original network and the low proportion of required nodes (around 1.5 percent or less of the original nodes) to bypass nodes and eliminate arcs. Such characteristics are often found in physical networks such as road, rail, or electricity distribution systems (e.g., Chardy et al., 2012; Goczyła & Cielatkowski, 1995). Of course, preprocessing may be less effective for networks that are denser or have a higher proportion of required nodes.

After preprocessing, the shortest path-based method constructs a smaller network while ensuring that the shortest path length for every commodity is the same as in the original network. Table 3 shows, for each problem instance, the size of the reduced network after applying this heuristic, and its computational times. We next applied the dual-based Min-Length method to obtain networks within the required size (shown in Table 1).


                        Table 4 shows the results after applying the dual-based algorithm. For problem R1, the reduced network contains 380 arcs (satisfying the maximum arcs requirement). Remarkably, the approximation error ρ (column 4) of this reduced network is only 0.86 percent, i.e., the total shortest path length over all commodities in this network is only 0.86 percent more than the total length in the original network. The procedure required around 14 minutes of computational time, and solved the network design problem Min-Cost (F) 38 times (column 6), for increasing values of F, to obtain a reduced network within the required size. For problem R2, the dual ascent method required 39 trial F-values, used around 10 minutes of computational time, and achieved a relative approximation of just 1.08 percent. The smaller problem instances, corresponding to the less versatile resources R3, R4, and R5, required solving fewer network design problems, each in much shorter time, while achieving lower approximation errors.
                        
                     

As noted earlier, one advantage of the dual-based method is that, by iteratively increasing the value of F, the method generates a sequence of reduced networks that have fewer arcs but more approximation error. Thus, given a target value of permissible error in total shortest path lengths, the method can find a reduced network (heuristic) solution that achieves this target with as few arcs as possible. Table 4 shows that, for the maximum network sizes chosen in Table 1, the approximation errors for the reduced networks are small, ranging from 0.04 percent to 1.08 percent. What if we are willing to accommodate slightly higher errors of up to, say, 2 percent? How many fewer arcs are needed in the reduced network to meet this target? Table 5 reports results, using the dual-based method, when an approximation error of up to 2 percent is acceptable.

Comparing the number of arcs for the reduced networks in Tables 4 and 5, we see that permitting just a small increase in the approximation error (to 2 percent) yields a significant reduction of 16.5 percent, on average, in the number of arcs (reduction measured as percent of the number of arcs in Table 4).

Next, using problem instance R4 as an example, we illustrate the tradeoff between network size and approximation error. Fig. 1 pictorially depicts how the arc density decreases and approximation error increases as we solve network design problems with increasing values of F. In this figure, the upper and lower curves respectively represent the approximation error percent and arc density as the fixed cost value F increases. For low F values, we obtain a reduced network with arc density of less than three and having little or no approximation error (i.e., same total shortest path length as original network). As F increases, arc density decreases to around 2.5 but the algorithm can still generate networks that have very low errors (less than 0.72 percent). Increasing F further results in networks with lower densities, but noticeably higher errors.
                     

To test the performance of our solution methods for other problem instances, we consider the task of condensing a road network that interconnects various supply or pickup points (e.g., distribution centers) and demand or delivery points (e.g., retail stores or customer locations) for purposes of distribution planning. Balakrishnan, Geunes, and Pangburn (2002) describe the planning problems that arise in the context of supplying retail stores, dispersed over a geographical region, using less-than-truckload deliveries. In this setting, having a reduced version of the road network facilitates routing and delivery scheduling decisions. Such reduction is also useful for service network design by logistics service providers to select a parsimonious set of services to move goods between various locations while ensuring that the travel distance between these locations is close to the shortest path distances. Modeling such applications of network reduction requires starting with the road network that serves the locations (nodes) of interest, and condensing this network. For this purpose, we use the actual road network in California (Li, Cheng, Hadjieleftheriou, Kollios, & Teng, 2005) as the given graph G. This network has 21,048 nodes and 43,386 arcs, nearly two-and-a-half times the size of the infrastructure project planning network of Section 4.1. Based on this network, we consider three problem instances, labeled D1, D2, and D3, with 50, 75, and 100 required nodes, respectively, each with commodities between every pair of required nodes. In these problem instances, all the required nodes have high degree (large number of incident arcs) in the given graph, implying that they are well-connected.
                        
                     

As before, we first applied preprocessing and the shortest path-based method to each problem. Tables 6 and 7, similar to Tables 2 and 3 for infrastructure project planning, show the results. From Table 6, we see that the percent reduction in the number of nodes and arcs due to preprocessing is about the same for distribution planning as for infrastructure project planning (see Table 2) although the former problems are much larger. The percent reduction in commodities is somewhat smaller since the required nodes in problems D1, D2, D3 have high degree.

The arc densities of the reduced networks after preprocessing are notably higher for the distribution problems (average of 29.30) than those shown in Table 2. However, the shortest path-based method is able to significantly reduce arc densities (to an average of 5.72) to values that are comparable to those in Table 3. Next, we applied the dual-based Min-Size method to further reduce the network while permitting an approximation error of up to 2 percent.

The results, in Table 8, after applying the dual-based method again show that providing just a small allowance for approximation error (≤2 percent) enables us to construct a very small network, with number of arcs less than three times the number of required nodes, reinforcing the similar property we observed for the smaller infrastructure project planning problems (Table 5).

The literature has not proposed general network reduction models or methods, as we do, to systematically assess the tradeoffs between network size and approximation of shortest path lengths. The most similar problem to our Min-Length model is the Optimal Distance Spanning Tree (ODST) problem which requires identifying a tree of an undirected network that spans the required nodes and has minimum total path length between these nodes. When the given network is complete, this problem is an extreme case of our Min-Length model since it requires selecting a tree which is the smallest possible (undirected) network connecting the required nodes. For this NP-hard problem, Wong (1980) proposed a polynomial-time approximation, and proved that this solution has an approximation error of no more than 100 percent when arc lengths satisfy the triangle inequality. Campos and Ricardo (2008) proposed a more efficient algorithm, but its actual computational performance is similar to Wong's method for practical problems. Wong's algorithm essentially constructs a Min-Length one-star tree, in which all other nodes are connected to a single center node. Wu et al. (2000) extended this idea to construct a Min-Length k-star tree, in which at most k nodes, i.e., the “stars”, have degree greater than one. Although this algorithm is fastest among approximation algorithms (Campos & Ricardo, 2008), its actual computation time becomes high when k is large.

For our computational experiments, we implemented Wong's algorithm and Wu et al.’s algorithm with k = 2 (two-star) to compare the quality of the solutions. To apply these algorithms to our directed networks, for each problem instance, we first construct a complete (undirected) network over the required nodes, setting the edges lengths equal to the shortest path lengths in the original network. We then construct the trees using these two methods, and replace each edge in the tree with two arcs directed in opposite directions. Hence, the arc density of these solutions is 
                           
                              2
                              (
                              |
                              S
                              |
                              −
                              1
                              )
                              /
                              |
                              S
                              |
                              ≈
                              2
                           
                        . To obtain comparable dual-based solutions, having few arcs and low arc density, we set F to a very large value. Table 9 compares the results using our network reduction algorithm with those obtained using Wong's (one-star) and Wu et al.’s (two-star) methods.

The statistics in this table show that, although the dual-based solutions to our NR model have somewhat higher arc densities than the ODST solutions (average of 2.35 across problem instances versus around 2 for the ODST solutions), their approximation errors are significantly lower. The NR solutions’ error, averaged over the eight problem instances, is 5.93 percent, whereas the average errors for the ODST solutions obtained using Wong's and Wu et al.’s (two-star) algorithms are 40.49 percent and 32.68 percent respectively. As might be expected, the one-star solutions obtained using Wong's method have consistently higher approximation errors than the Wu et al.'s two-star solutions. Comparing the errors for infrastructure project planning problems having 50 or more required nodes (R1–R3) with those for the distribution planning problems (D1–D3), we see that the NR solutions have around the same average approximation errors (6.21 percent and 6.47 percent for infrastructure and distribution problems respectively). In contrast, the ODST solutions (using either method) have noticeably higher errors for the infrastructure planning problems compared to the distribution problems. (This difference stems in part because the required nodes for distribution planning are well-connected and so are natural centers for the tree solution.) These results demonstrate that permitting a few more arcs in the reduced network and applying our NR model and solution methods yield solutions whose approximation errors are five times smaller than those for the sparse ODST solutions. Moreover, our approach permits exploring a spectrum of networks that vary in size and approximation error that the users can choose from.
                        
                        
                     

@&#CONCLUSION@&#

This paper has modeled and developed effective algorithms to reduce the network size without adversely affecting shortest path lengths between origin and destination nodes. This model and approach can greatly facilitate solving large-scale integer programs that have embedded routing subproblems (as in the real infrastructure project planning application that motivated this work) and also has broader applications in service network design (e.g., deciding package delivery services, distribution planning), and other scientific and engineering computations. We modeled two versions of the network reduction problem—Min-Size and Min-Length—as integer programs with multi-commodity flows, and proposed effective solution methods including node elimination techniques and optimization-based heuristics that iteratively apply shortest path and dual ascent algorithms. Using real networks, we have demonstrated that we can significantly reduce the size of the underlying physical (transportation) networks with only minimal loss of accuracy in shortest path lengths, particularly when the original networks have local sparsity (as is common in real networks) and the proportion of required nodes is small. For instance, for the infrastructure project planning problem, starting with a physical network containing 8490 nodes and 17,372 arcs, we were able to generate reduced networks containing less than 400 arcs while increasing the total shortest path length by no more than 1 percent. The reduction was even greater for the much larger distribution planning network. Potential directions for future research include: (i) testing the solution methods for denser networks with higher percentage of required nodes; (ii) specializing and adapting Balakrishnan et al.'s (1989) dual ascent method to the situation when all arcs have the same fixed cost F, and when we iteratively solve the network design problem for increasing values of F (e.g., we can exploit or re-use the dual solution for one value of F when solving the problem for the next higher value); and (iii) developing more sophisticated methods for the Min-Size problem and other Min-Length solution approaches that assure finding a network with a given maximum size.

The sparsest t-spanner problem is a special case of the Min-Size NR problem obtained by treating all original nodes as required nodes, defining K as a complete demand set with one commodity for every node pair, and setting 
                        
                           
                              t
                              k
                           
                           =
                           t
                        
                      for all commodities. Peleg and Schaffer (1989) showed the sparsest t-spanner problem is NP-hard on both directed and undirected networks. Therefore, the Min-Size NR problem is also NP-hard. The ODST problem is a special case of the Min-Length NR problem on an undirected network, in which the new network is restricted to be a tree and 
                        
                           
                              w
                              k
                           
                           =
                           1
                        
                      for all commodities. Johnson et al. (1978) showed that the ODST problem is NP-hard on the undirected network. Therefore, the Min-Length NR problem is also NP-complete in the hard sense on the undirected network.

Now we establish the NP-completeness of the Min-Length NR problem on the directed network. The proof is to show that a p-median Uncapacitated Facility Location (UFL) problem is reducible to the Min-Length NR problem. Given a customer set I, a candidate facility set J, and cost cij
                      of assigning a customer i to facility j, a p-median UFL problem is to find a minimum cost assignment in which each customer is assigned to one facility and the total number of facilities selected is no larger than p. The p-median UFL problem is known as NP-complete in the hard sense (Garey & Johnson, 1979). Given any p-median instance (I, J, p), we construct a corresponding Min-Length NR instance as the follows:

Node set 
                        
                           N
                           =
                           {
                           I
                           }
                           ∪
                           {
                           
                           J
                           }
                           ∪
                           {
                           s
                           }
                        
                      where s is a sink node

Arc set 
                        
                           A
                           =
                           {
                           (
                           i
                           ,
                           j
                           )
                           :
                           i
                           ∈
                           I
                           ,
                           j
                           ∈
                           J
                           }
                           ∪
                           {
                           (
                           j
                           ,
                           s
                           }
                           :
                           j
                           ∈
                           J
                           }
                        
                     
                  

Commodity set 
                        
                           C
                           =
                           {
                           (
                           i
                           −
                           >
                           s
                           )
                           :
                           i
                           ∈
                           I
                           }
                        
                     
                  

Length of arcs: 
                        
                           
                              h
                              
                                 i
                                 j
                              
                           
                           =
                           
                              c
                              
                                 i
                                 j
                              
                           
                           
                           
                              (
                              i
                              ∈
                              I
                              ,
                              j
                              ∈
                              J
                              )
                           
                        
                      and 
                        
                           
                              h
                              
                                 j
                                 s
                              
                           
                           =
                           0
                           
                           
                              (
                              j
                              ∈
                              J
                              )
                           
                        
                     
                  

Maximum number of arcs: M = p + |I|

Given a new network G′, the total path length increases can be expressed as TP = Z(G′) − Z(G) where Z(G′) (Z(G)) denotes the sum of the shortest path lengths in G′ (G) for all commodities. Note that Z(G) is a constant and any new network must have |I| arcs to connect node i with node j and p zero-length arcs to connect node j with node s. Thus, the minimum cost in the p-median UFL problem is equal to P
                     * + Z(G) where P
                     * is the optimal value of the Min-Length NR problem. Since the p-median UFL problem is a known NP-hard problem, the Min-Length NR problem is also NP-hard on the directed network.

We prove the proposition by the following construction: For any node in i ∈ V/S
                  


                     Step 1: For any incoming arc (u, i) and any outgoing arc (i, j) of node i, consider the following cases:

                        
                           1
                           If u and j are the same node, then arcs (u, i) and (i, j) are reversed arcs. Do nothing.

If u and j are two different nodes and arc (u, j) exists, do nothing.

If u and j are two different nodes and arc (u, j) does not exist, then we generate a new arc (u, j) with the length huj
                              .


                     Step 2: Remove all incoming arcs and outgoing arcs of node i and remove node i.

Recall the notations defined in paper body, 
                        
                           
                              |
                           
                           
                              N
                              +
                           
                           
                              
                                 (
                                 i
                                 )
                              
                              |
                           
                        
                      and 
                        
                           
                              |
                           
                           
                              N
                              −
                           
                           
                              
                                 (
                                 i
                                 )
                              
                              |
                           
                        
                      represent the number of successors and predecessors of node i, respectively; |N
                     0(i)| is the number of nodes that are both predecessors and successors of node i; and |AD
                     c(i)| is the number of direct arcs from predecessors to successors of i that are already present in the current network. Note Step 1 will execute a total of 
                        
                           
                              |
                           
                           
                              N
                              +
                           
                           
                              
                                 
                                    (
                                    i
                                    )
                                 
                                 |
                              
                              *
                           
                           
                              |
                              
                                 N
                                 −
                              
                              
                                 (
                                 i
                                 )
                              
                              |
                           
                        
                      times. Among this step, case 1 appears |N
                     0(i)| times and case 2 appears |AD
                     c(i)| times. Thus, case 3 will execute 
                        
                           
                              |
                           
                           
                              N
                              +
                           
                           
                              
                                 
                                    (
                                    i
                                    )
                                 
                                 |
                              
                              *
                           
                           
                              |
                           
                           
                              N
                              −
                           
                           
                              
                                 (
                                 i
                                 )
                              
                              |
                              −
                              |
                           
                           
                              N
                              0
                           
                           
                              
                                 (
                                 i
                                 )
                              
                              |
                              −
                              |
                              A
                           
                           
                              D
                              c
                           
                           
                              
                                 (
                                 i
                                 )
                              
                              |
                           
                        
                      times, and each execution of case 3 increases the arc size of the network by one. Meanwhile, Step 2 will decrease the arc size of the network by 
                        
                           
                              |
                           
                           
                              N
                              +
                           
                           
                              
                                 (
                                 i
                                 )
                              
                              |
                              +
                              |
                           
                           
                              N
                              −
                           
                           
                              
                                 (
                                 i
                                 )
                              
                              |
                           
                        
                      and the node size by one. Therefore, as long as condition (8) is satisfied, executing the above two-step operations on node i will always reduce the network size. We further show that the shortest path length of any commodity in K will not change in the new network: Assume one arc (u, i) is part of the shortest path for a commodity in K. Because node i is not in S, then another outgoing arc—assuming (i, j)—must belong to the same shortest path and u ≠ j. Therefore, using arc (u, j), whose length satisfies 
                        
                           
                              h
                              
                                 u
                                 j
                              
                           
                           ≤
                           
                              h
                              
                                 u
                                 i
                              
                           
                           +
                           
                              h
                              
                                 i
                                 j
                              
                           
                        
                      on the new network, will not increase the shortest path length for the commodity in K.

Given two values of F, F1 and F2, where F1 < F2, let G1 (G2) be the network in the optimal solution to Min-Cost(F1) (Min-Cost(F2)). Also, let A1 (A2) be the set of arcs on G1 (G2), and H(A1) (H(A2)) be the weighted path lengths of all commodities on G1 (G2). Therefore,

                        
                           
                              
                                 
                                    
                                       
                                          Z
                                          
                                             (
                                             
                                                F
                                                1
                                             
                                             )
                                          
                                          =
                                          F
                                          
                                             1
                                             *
                                          
                                          
                                             |
                                             
                                                A
                                                1
                                             
                                             |
                                          
                                          +
                                          H
                                          
                                             (
                                             
                                                A
                                                1
                                             
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           
                              
                                 
                                    
                                       
                                          Z
                                          
                                             (
                                             
                                                F
                                                2
                                             
                                             )
                                          
                                          =
                                          F
                                          
                                             2
                                             *
                                          
                                          
                                             |
                                             
                                                A
                                                2
                                             
                                             |
                                          
                                          +
                                          H
                                          
                                             (
                                             A
                                             2
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                  

Note that G1 is also a feasible network to Min-Cost(F2) and the total cost is F2 * |A1| + H(A1) in this case. By the optimality assumption, we have:

                        
                           (AC1)
                           
                              
                                 
                                    
                                       
                                          F
                                          
                                             2
                                             *
                                          
                                          
                                             |
                                             
                                                A
                                                1
                                             
                                             |
                                          
                                          +
                                          H
                                          
                                             (
                                             A
                                             1
                                             )
                                          
                                          ≥
                                          F
                                          
                                             2
                                             *
                                          
                                          
                                             |
                                             A
                                             2
                                             |
                                          
                                          +
                                          H
                                          
                                             (
                                             A
                                             2
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                  

Similarly, we have:

                        
                           
                              
                                 
                                    
                                       
                                          F
                                          
                                             1
                                             *
                                          
                                          
                                             |
                                             
                                                A
                                                2
                                             
                                             |
                                          
                                          +
                                          H
                                          
                                             (
                                             
                                                A
                                                2
                                             
                                             )
                                          
                                          ≥
                                          F
                                          
                                             1
                                             *
                                          
                                          
                                             |
                                             
                                                A
                                                1
                                             
                                             |
                                          
                                          +
                                          H
                                          
                                             (
                                             
                                                A
                                                1
                                             
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                  

Note F1 < F2. Denote s = F2 − F1 where s is positive value. Replace (AC1) by:

                        
                           
                              
                                 
                                    
                                       
                                          
                                             s
                                             *
                                          
                                          
                                             (
                                             
                                                |
                                                
                                                   A
                                                   2
                                                
                                                |
                                                −
                                                |
                                                A
                                                1
                                                |
                                             
                                             )
                                          
                                          +
                                          
                                             (
                                             
                                                F
                                                
                                                   1
                                                   *
                                                
                                                
                                                   |
                                                   
                                                      A
                                                      2
                                                   
                                                   |
                                                
                                                +
                                                H
                                                
                                                   (
                                                   
                                                      A
                                                      2
                                                   
                                                   )
                                                
                                                −
                                                F
                                                
                                                   1
                                                   *
                                                
                                                
                                                   |
                                                   
                                                      A
                                                      1
                                                   
                                                   |
                                                
                                                −
                                                H
                                                
                                                   (
                                                   
                                                      A
                                                      1
                                                   
                                                   )
                                                
                                             
                                             )
                                          
                                          ≤
                                          0
                                       
                                    
                                 
                              
                           
                        
                     
                  

Therefore, |A2| ≤ |A1|.

@&#REFERENCES@&#

