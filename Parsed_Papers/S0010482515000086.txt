@&#MAIN-TITLE@&#Monitoring eating habits using a piezoelectric sensor-based necklace

@&#HIGHLIGHTS@&#


               
                  
                  
                     
                        
                           
                           Piezoelectric sensors in the lower trachea are viable for detection of food intake.


                        
                        
                           
                           Accelerometers for activity recognition can reduce the false positive rate of detected swallows.


                        
                        
                           
                           Classification can be performed between several food types using Bayes classifiers.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Piezoelectric sensor

Wireless Health

Nutrition

Necklace

@&#ABSTRACT@&#


               
               
                  Maintaining appropriate levels of food intake and developing regularity in eating habits is crucial to weight loss and the preservation of a healthy lifestyle. Moreover, awareness of eating habits is an important step towards portion control and weight loss. In this paper, we introduce a novel food-intake monitoring system based around a wearable wireless-enabled necklace.
                  The proposed necklace includes an embedded piezoelectric sensor, small Arduino-compatible microcontroller, Bluetooth LE transceiver, and Lithium-Polymer battery. Motion in the throat is captured and transmitted to a mobile application for processing and user guidance. Results from data collected from 30 subjects indicate that it is possible to detect solid and liquid foods, with an F-measure of 0.837 and 0.864, respectively, using a naive Bayes classifier. Furthermore, identification of extraneous motions such as head turns and walking are shown to significantly reduce the false positive rate of swallow detection.
               
            

@&#MOTIVATION@&#

In 2008, medical costs associated with obesity were estimated to be over $147 billion [1], and over one-third of adults in the United States are considered obese. The average BMI (body mass index) has consistently increased over the last two decades, which has been shown to be a contributor to risk of stroke, diabetes, certain cancers, heart disease, and other conditions [1]. Though many activity-monitoring systems have been proposed [2–4], little research has been conducted on quantifying the volume of food consumption, which has been shown to correlate with weight gain [5]. Though countless manual data collections have been proposed such as food records and 24-h recall, these approaches suffer from poor accuracy, high user burden, and low compliance. Wireless health-monitoring technologies have the potential to promote healthy lifestyle behavior and address the ultimate goal of enabling better lifestyle choices. In this paper, we describe a wearable nutrition-monitoring system in the form of a necklace, which is capable of identifying swallows, performing basic classification, and providing user guidance through a mobile application.

@&#BACKGROUND@&#

Our work on nutrition monitoring pertains to the development and test of an nutrition-monitoring necklace with an embedded piezoelectric (vibration) sensor. Piezoelectric sensors are capable of producing a voltage at their terminals in response to mechanical stress. Thus, the system is capable of detecting swallows based on skin movement in the lower trachea during ingestion. Vibration-sensor data was transmitted to a mobile application using a low-powered Bluetooth LE transceiver built into the processing board mounted upon the necklace. The application included algorithms for identifying swallows, performing basic classification between solid and liquid foods, and providing recommendations to the user with respect to the timing, volume, and composition of their meals. An overview of the hardware architecture is provided in Fig. 6. The system includes a piezoelectric strip, Bluetooth-compatible microcontroller board, and a small lithium-polymer or cell battery for powering the system.

Though the system provides high accuracy in laboratory-based testing environments, accuracy is compromised in certain use-cases such as walking, running, and head motions in both horizontal and vertical directions. Often, these motions are detected as swallows, which significantly reduced the accuracy and practicality of the system. Therefore, we propose different classification techniques to distinguish these motions from those associated with eating using both the piezoelectric sensor, and a small accelerometer.


                     Fig. 7 shows how the addition of a new sensor could be used to assist in activity classification to improve system accuracy. Prior to swallow detection, which in the previous system was based on vibration sensor data alone, activity recognition is computed from a necklace-mounted tri-axial accelerometer. This accelerometer data is intended to detect motion of the necklace itself caused by head motions or movement, rather than the skin in the lower throat as in the case of the piezoelectric sensor.

This paper is organized as follows. Section 3 presents an overview of prior art in the field of food intake monitoring. Section 4 describes the algorithms used to detect swallows, followed by the experimental procedure in 5. The evaluation is presented in Section 6, followed by the conclusion in Section 7.

@&#RELATED WORKS@&#

Food records generally are not impacted by the accuracy of a subject׳s memory; they typically require individual to make note of their eating habits during or immediately after a meal [6]. However, there are several problems with this approach. In cases where assessment of a typical diet is the goal, this technique is not feasible because it has been found that the necessity of completing a food record affects dietary choices. Other concerns include patient compliance, and the difficulty that untrained individuals face when accurately assessing portion size.

One of the most simple and yet pervasive methods of monitoring dietary intake is the multi-pass 24-h dietary recall method, based on the data patients provide at the end of a randomly selected day. This approach measures food intake in a reasonably quantitative manner but with significant error because people do not recall the exact amount of food they have eaten [7]. Experimental data shows that food intake is usually reported with error and measurement variance also depends on the patient׳s experience with this system [8].

A third method for manually assessing dietary intake is to use a food frequency questionnaire (FFQ), in which individuals specify their rate of consumption for various food items. Nutritional intake can subsequently be assessed by summing various food types provided within the list [6]. Though this technique is inexpensive to administer and insensitive to recent changes in diet, FFQs are typically inaccurate in comparison with other techniques. This is often a result of several factors including incomplete lists of food, poor user compliance, errors in recording frequency, and errors in recording serving size [9].

Recent research has been developed that use a watch-like configuration of sensors to track wrist motion throughout the day to automatically detect periods of eating [10]. While this work shows promise, it does not capture people that eat and drink with two hands (92% of food bites with the dominant hand but only 57% of liquid bites), and also has a high false positive rate (one per five bites).

Swallows could also be detected as a sign of food intake. However, current systems detecting swallowing maintain a dependency on bulky and potentially unsafe equipment (video fluoroscopy) and invasiveness (subcutaneous EMG) [11]. Some recent works suggest the use of throat microphones as a means of acquiring audio signals from throat and extracting swallowing sounds afterwards [12,13]. In a promising work by Amft et al. [14], authors analyze bite weight and classify food acoustically from an earpad-mounted sensor. However, as other acoustic methods, this system may not be practical in environments with high ambient noise. Analyzing wave shape in time domain [12] or feature extraction and machine learning [15] has resulted in an 86% swallow detection accuracy in an in-lab controlled environment. Some studies have reached accuracy rates of 91.7% in an in-lab controlled environment using neural networks with false positives of 9.5%. A more recent study using support vector machines have been able to reach swallow detections of up to 96.7% in an in-lab setting [11]. However, these devices are mounted very high up in the top part of the trachea, near the larynx. Such positioning of a device is quite uncomfortable to wear throughout the day.

Many prior works have attempted to detect swallow disorders using inertial sensors. The work by Toyosato et al. in [16] used a piezoelectric pulse transducer to detect food bolus passage through the esophagus. In [17], Ertekin et al. used piezoelectric sensors to evaluate dysphagia symptoms in a study with thirty normal subjects and 66 dysphagia patients. The authors concluded that piezoelectric sensors can be applied successfully towards objective evaluation of oropharyngeal dysphagia. Another example is our prior work in nutrition monitoring in [18], in which we propose monitoring eating habits by placing a piezoelectricc sensor in the lower trachea. In [19], Miyaoka et al. used piezolectric sensor signals were able to detect the volume of tea swallowed based on the waveforms acquired from the sensor, after GLM-ANOVA analysis. Though the application did not relate to nutrition monitoring, this work is significant because it shows that food volume can be inferred from a piezoelectric sensor.

In this section, we describe the hardware and software components of our system.

A piezoelectric sensor, sometimes known as a vibration sensor, produces a voltage when subjected to physical strain. By placing a piezoelectric sensor against the throat, the motion of the skin during a swallow is represented in the output of the sensor, when sampled at frequencies as low as 5Hz. During a swallow event, muscular contractions result in motion of the skin, which pushes the vibration sensor away from the body and towards the inside of the necklace, generating a unique output voltage pattern, as shown in Fig. 1
                        . The piezoelectric sensor was integrated into our system by connecting the positive terminal to the microcontroller board׳s GPIO pin, which is internally connected to a 12-bit analog/digital converter. The other terminal of the sensor is connected directly to ground on the microcontroller board. Amplification of the piezoelectric signal was not required due to the relatively high voltages produced by the sensor.

The piezoelectric sensor used is the LDT0-028K, which consists of a 28μm PDVDF polymer film laminated to a 0.125mm substrate, which produces voltages within standard CMOS input voltage ranges when deflected directly. The necklace can operate under conditions ranging from 0 to 85°C. The LDT0 is available with added masses at the tip, which reduce the resonant frequency but can greatly increase the sensitivity of the device. In the configuration without an added mass at the tip, the baseline sensitivity is approximately 50mV/g, with sensitivity at resonance of 1.4V/g [20].

Our necklace features a thin, lightweight piezoelectric vibration sensor attached to the inside of the necklace, along with a small microcontroller board capable of sampling the sensor and transmitting the data to a mobile phone via Bluetooth. The hardware is powered by a lightweight lithium-polymer battery or a simple 3V coin battery.

The necklace is available in several varieties, the first of which is a sportsband style. The advantage of this design is the increased sensor stability, as the neckband prevents excessive lateral motion that can introduce errors (false positives) in swallow detection. However, due to the cumbersome design, the sportsband is best suited for algorithm evaluation, data collection, and clinical environments where appearance is of secondary importance. Otherwise, the pendant-based design shown in Fig. 2
                         may be more appropriate for daily use.

Because the piezoelectric sensor generates a voltage in response to physical strain, tightening the necklace excessively such that motion is restricted has a negative on sensor accuracy; the necklace is designed to be worn loosely and comfortably, only sufficiently tight such that the sensor barely remains in contact with the skin. However, the primary challenge associated with the pendant-based design is that it may not stay attached to the skin as a result of various motions. For example, walking, running, or vigorous turns of the head may make the necklace change position and no longer be in contact with the lower neck. To avoid false positives, we propose using an accelerometer mounted to the left of the piezoelectric sensor, which is used to detect extraneous motions and prevent recordings of false nutritive swallows. The details of this algorithm are described in subsequent sections. Another more pertinent concern is how to ensure that users who wear the pendant design are placing them correctly on the neck, both initially after any possible change of location induced by motion. One possibility will be to require the user to perform a simple calibration before each meal, which could be to take several sips of water. Once the magnitude of the peak described in the algorithms section has reached a particular threshold, the user could be notified that the necklace is correctly placed. Such schemes will be evaluated in our future work.

Waveforms collected from necklace configurations of various tightness are shown in Fig. 3
                        . Nevertheless, Fig. 4
                         shows a more low-profile design based around a pendant, that may be more acceptable for daily use. The intention of the pendant design is to allow relatively inconspicuous monitoring of an individuals eating habits. Though it is unlikely that every individual is comfortable wearing such a necklace in public, this is a step towards the miniaturization of a necklace-based nutrition monitor, and more quantitative evaluation of user acceptance is left to a future work.

The recently released RFDuino board samples the voltage of the vibration sensor at a rate of 20Hz, converting the voltage to a digital signal using the on-chip A/D converter. The data is then buffered and transmitted to a mobile phone. This Arduino-compatible board is easily programmed, very compact, and features a Bluetooth 4.0 LE transceiver on-board, based on the RFD22301 SMT module. The embedded processor is an ARM Cortex M0 with 256kB of flash memory and 16kB of RAM. This board was specifically selected because of its ease of use and integrated CPU/BTLE transceiver in the same package. This made a pendant-based necklace design much more practical due to its relatively compact dimensions.

The specific accelerometer used in our evaluation is the Xtrinsic MMA8452Q 3-Axis 12-bit digital accelerometer from FreeScale semiconductor, which supports output data rates from 1.56Hz to 800Hz and has a sensing range of 3g. The board is mounted onto the necklace fabric itself, approximately 2in to the left of the vibration sensor, and draws approximately 320μA of current. In our application, the output sample rate was limited to 20Hz, which was a decision motivated by a system requirement of high battery life. The device was directly connected to the GPIO interface of the microcontroller board, and because the sampling rate was identical to the piezoelectric sensor, synchronization of the two signals not a major concern – accelerometer sampling immediately preceded the vibration sensor sample, both of which were transmitted immediately to the mobile application for processing.

A swallow event creates physical stress on the piezoelectric sensor, which is manifested in a voltage measured by the microcontroller board. The swallow detection algorithm processes the original piezoelectric sensor waveforms in order to decouple the peaks of the waveform from the effects of drift and noise. This signal transform is first achieved by generating a new waveform using a sliding-window average of the original data. After a moving-average representation of the data is generated, each data point is assigned a numerical value with respect to the difference between its original value and average in the previous window. This essentially removes the offset from the data and combats the effect of drift, while preserving the critical features of the original waveform.

This procedure can be used to simplify the analysis of many relatively stable waveforms with occasional perturbations or spikes, as shown in Fig. 5
                        . The raw values shown on the left of this figure are caused by moving the accelerometer several times, which causes spikes in each axis. By using the moving average representation, the Y-axis offset can be removed, which facilitates an objective comparison between waveforms.

The top figure is the raw waveform acquired from the vibration sensor over time, at a rate of 20Hz. The noticeable dips in the waveform generally correspond with swallows. The data is then smoothed using a moving-average low-pass filter with a span of 5, to reduce the impact of oscillations and noise that are unrelated to swallowing. Subsequently, a sliding window of length 9, corresponding with 0.45s of data, is applied with a maximum overlap (shifted one point at a time). This was experimentally determined to be optimal for preserving the critical features of the waveform. Within each window, the average voltage from the vibration sensor is calculated. Subsequently, the standard deviation of each point within the window is calculated. Algorithm 1 shows a simplified version of this procedure, which was implemented on the mobile phone, and is used to detect swallows based on data from the vibration sensor.
                           Algorithm 1
                           Swallow detection algorithm. 
                                 
                                    
                                       
                                       
                                          
                                             Smooth(Data);
                                          
                                          
                                             
                                                for i=1:Window:Size(Data) do
                                             
                                          
                                          
                                             
                                                
                                                   ⌊
                                                   
                                                      
                                                         
                                                            
                                                               avg
                                                               =
                                                               CalculateAverage
                                                               (
                                                               Data
                                                               [
                                                               i
                                                               ]
                                                               :
                                                               Data
                                                               [
                                                               i
                                                               +
                                                               Window
                                                               ]
                                                               )
                                                               ;
                                                            
                                                         
                                                         
                                                            
                                                               for
                                                               j
                                                               =
                                                               i
                                                               :
                                                               i
                                                               +
                                                               Window
                                                               do
                                                            
                                                         
                                                         
                                                            
                                                               ⌊
                                                               
                                                                  
                                                                     
                                                                        
                                                                           diff
                                                                           =
                                                                           abs
                                                                           (
                                                                           avg
                                                                           −
                                                                           Data
                                                                           [
                                                                           i
                                                                           ]
                                                                           )
                                                                        
                                                                     
                                                                     
                                                                        
                                                                           if
                                                                           
                                                                           diff
                                                                           <
                                                                           threshold
                                                                           
                                                                           then
                                                                        
                                                                     
                                                                     
                                                                        
                                                                           |
                                                                           diff
                                                                           =
                                                                           0
                                                                           ;
                                                                        
                                                                     
                                                                     
                                                                        
                                                                           else
                                                                        
                                                                     
                                                                     
                                                                        
                                                                           ⌊
                                                                           data
                                                                           [
                                                                           i
                                                                           ]
                                                                           =
                                                                           diff
                                                                           ;
                                                                        
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                         
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                for i=1:Size(Data) do
                                             
                                          
                                          
                                             
                                                
                                                   ⌊
                                                   
                                                      
                                                         
                                                            
                                                               if
                                                               
                                                               Data
                                                               [
                                                               i
                                                               ]
                                                               >
                                                               0
                                                               
                                                               then
                                                            
                                                         
                                                         
                                                            
                                                               ⌊
                                                               
                                                                  
                                                                     
                                                                        
                                                                           SwCount
                                                                           ++;
                                                                        
                                                                     
                                                                     
                                                                        
                                                                           i
                                                                           =
                                                                           i
                                                                           +
                                                                           Jump
                                                                           ;
                                                                        
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                         
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           

The last step in swallow detection is to count the number of peaks in the waveform, followed by a period of disabled detection after each swallow to “debounce” the sensor from false-positives caused by noise resulting from a single swallow that may be mistaken for multiple. The parameters used in algorithm design were derived using MATLAB simulations for optimality. Half of the data was used for training and the other half of the data set was used for evaluation. The algorithm can perform well at a variety of window sizes ranging from 3 to 23, but is much more sensitive to the threshold of 180mV, which is inherently a property of the piezoelectric sensor in the experimental configuration.  
                        
                     

Because the piezoelectric sensor is capable of detecting motions beyond swallows, the detection of consistent chewing between swallows is a reliable indicator that a solid food is being consumed, while several swallows (especially if they are in rapid succession) with no chewing detected between may indicate that a liquid is being consumed. Fig. 8
                         illustrates three primary features which can be used to differentiate solid and liquid foods, by comparing waveforms corresponding to a glass of water (top) and chips (bottom).

The most critical indicator that the food being consumed is a liquid is the absence of vibrations corresponding with chewing, between swallows. Furthermore, swallows corresponding with liquid foods are typically sharper and higher in magnitude. The impact of chewing on sensor data is shown in Fig. 9
                        , which shows that data acquired from solid foods has much more intra-swallow variation compared to liquids, which are much more consistent.

For each swallow event, the standard deviation of data between the current and subsequent swallows was extracted in cases when the time ΔT was between 1 and 15s. This time period was selected in order to filter out errors caused by noise. For example, there could be two swallows reported for one actual swallow. Furthermore, there is no guarantee that the user is chewing between swallows – the probability decreases as the time interval between swallows increases past a certain threshold. Similarly, the magnitude of each peak (after normalization) was extracted for classification.

In order to develop the classifier for various motions, a training set is used in which the subject annotates the data by pressing a button on a mobile phone while performing the activity. For example, by pressing a button on each step, the time at which a step is taken is noted in the log file. This allows some uniformity between the centering of each extracted window, which is then classified based on the motion detected. A window size of 1s was selected, which corresponds to 20 samples from the piezoelectric sensor and vibration sensor respectively. This was chosen because the window is large enough to capture distinguishing features from all classified motions when centered appropriately.

Several movements not associated with eating or drinking can produce distinct waveforms, as shown in Fig. 10
                        . Motions such as head turns, walking, and running can affect the quality of the data inadvertently, as the data is acquired from the vibration sensor and transmitted to mobile phone. To reduce the impact of these motions on accurate profiling of an individual׳s eating habits, it is necessary to extract features from these motions and apply classifiers. In this section, we present a framework from identifying non-eating movements using several techniques, in order to reduce the rate of false positives during swallow detection. Fig. 11
                         presents several possible approaches.

One approach is to create new classes for data acquired from the vibration sensor, for motions such as walking, speaking, and turning the head. However, this would decrease the true positive rate of detection since there would be more categories to mistakenly classify a swallow. Furthermore, the design of the necklace is to detect motion from the neck rather than the rest of the body, which suggests that the vibration sensor is not suitable to identify these motions. Therefore, a second approach is to use a small accelerometer placed on the fabric of the necklace, which unlike the piezoelectric sensor, is positioned to detect motion of the upper body rather than motion in the skin of the lower throat. A third approach is to use both sensors in various configurations to detect motions. Our selected approach is to use the accelerometer exclusively for detecting non-eating related motions, to use the vibration sensor for detecting food intake.

Both the tri-axial accelerometer and piezoelectric sensor act as inertial sensors; the piezoelectric sensor could be modeled as a 1-D accelerometer. However, these two devices but work differently due to their placement. The skin motion during a swallow is quite small and requires very high sensitivity. Therefore, the long and thin design of a piezoelectric strip very well suited for this application, in which the necklace clamps the sensor to the skin and causes it to bend slightly during a swallow. However, these swallow-related motions do not register noticeably on the waveform acquired by the accelerometer. This can be seen in Fig. 12
                        , which shows 300 samples from the piezoelectric sensor and accelerometer (corresponding with 15s of data), as one individual drank a small glass of water with five swallows in total. As this figure shows, the peaks produced by the ingestion of water are relatively pronounced in the piezoelectric sensor data, while the accelerometer data shows no clear pattern.

Because the piezoelectric sensor is not designed for detection of movements in three dimensions, it is more sensitive to swallows than head motions in our application. By contrast, lateral head movements not associated with swallowing are much more pronounced, and can be detected by placing an accelerometer almost anywhere along the necklace. The triaxial accelerometer is specifically designed to detect motion along three dimensions, but is not suitable for placement directly against the skin to detect swallows. A model in which the accelerometer and piezoelectric sensor data are both used is defined in (1), in which C
                        acl is the output of the accelerometer classifier while C
                        vib is the output of the piezoelectric-sensor classifier. Both sensors classify between different types of motions, with no overlap
                           
                              (1)
                              
                                 
                                    
                                       C
                                    
                                    
                                       acl
                                    
                                 
                                 ∈
                                 {
                                 LookUp
                                 ,
                                 Walk
                                 ,
                                 Turn
                                 ,
                                 None
                                 }
                                 
                                    
                                       C
                                    
                                    
                                       vib
                                    
                                 
                                 ∈
                                 {
                                 Chew
                                 ,
                                 Swallow
                                 ,
                                 None
                                 }
                                 
                                    
                                       C
                                    
                                    
                                       acl
                                    
                                 
                                 ≠
                                 
                                    
                                       C
                                    
                                    
                                       vib
                                    
                                 
                              
                           
                        
                     

The system makes the simplifying assumption that a user will not be performing a movement based activity, i.e. walking or running, while eating. Therefore, the final activity class for a particular window of time, C
                        final, is assigned based on the following piecewise function shown in Eq. (2). In summary, the proposed algorithm ensures that a swallow is detected from data acquired from the vibration sensor, only if the data from the accelerometer shows that the user is not performing an activity commonly mistaken for a swallow: rapid head turn in the horizontal or vertical direction, or walking
                           
                              (2)
                              
                                 
                                    
                                       C
                                    
                                    
                                       final
                                    
                                 
                                 =
                                 {
                                 
                                    
                                       
                                          
                                             
                                                
                                                   C
                                                
                                                
                                                   vib
                                                
                                             
                                             :
                                             
                                                
                                                   C
                                                
                                                
                                                   acl
                                                
                                             
                                             ∈
                                             {
                                             None
                                             }
                                          
                                       
                                       
                                          
                                             None
                                             :
                                             
                                                
                                                   C
                                                
                                                
                                                   acl
                                                
                                             
                                             ∈
                                             {
                                             Turn
                                             ,
                                             Walk
                                             ,
                                             LookUp
                                             }
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The classification of these motions is conducted based on several key features: harmonic mean, geometric mean, standard deviation, kurtosis, skewness, and mean-absolute deviation. These features were extracted from the windows corresponding with these activities, using the same window size as the swallowing samples for objective comparison. These features were imported into the WEKA data mining software, which can report classification accuracy using various classifiers. A Naive Bayesian classifier was used to label the data using leave-one-out cross validation. As in the case of the swallows, the user annotated his actions manually during the data collection, using a button on the application which labeled the data when pressed.

Data was collected from a total of 30 subjects ranging from 22 to 34 with a median age of 23. The participants consisted of 25 men and 5 women. The consumed foods included: one quarter of a standard triangle-shaped chicken-salad sandwich on white bread (available at most convenience stores), a small handful of potato chips, and an 8 oz. glass of water. These foods were specifically chosen to represent a wide variety of textures, ranging from crunchy, chewy, and liquid. The subjects were seated at an office desk while eating, and were asked to refrain from unnecessary body motion, beyond what would be typical in the average meal. Each subject annotated the times at which he or she swallowed by pressing a button on the Android application which logged the data.

For each subject and food type, the piezoelectric sensor was placed in six different locations on the throat. This was necessary to identify the regions of the neck which produced the clearest signal. To ensure consistency in how the necklace was oriented and tightened, subjects were guided through the setup process every time. Furthermore, the sports band on which the sensor was mounted ranged from loose to firm, in order to find the right balance between comfort and detection accuracy. The necklace used in data collection was of the sports-band variety rather than a pendant style due to its durability. However, preliminary results suggested the efficacy of either design in a controlled environment.

A total of five subjects were asked to perform three activities while wearing a necklace similar to the one before, but with a triaxial accelerometer mounted 2in to the left of the piezoelectric sensor. The subject׳s necklaces were paired with an Android device which collected the data. Unlike the real-time implementation of the piezoelectric-based detection described earlier, accelerometer data was collected live, but processed offline. Once the data was collected, accelerometer data was written to a log file on the Android phone, annotated by the user by pressing a button while performing the motion. At times, the annotation in the log file was corrected in order to ensure objective comparison between different activities. This was necessary because actions such as walking and speaking do not have a clear center, as in the case of a swallow.

Each subject was asked to perform three activities. These activities were walking for approximately 1min at a normal pace, moving their head horizontally to the left, and looking up at approximately a 45° angle. These activities were selected because of their frequency in day-to-day life, as well as our observation during earlier experimentation that these motions were often misclassified as swallows. The activities were performed in the following order: walking, horizontal movement, and vertical movement. The activities were repeated five times each, which yielded 50 windows per activity and 150 windows in total. After each data collection, the accelerometer and piezoelectric sensor log files were labeled according to the time of the data collection.

@&#EVALUATION@&#


                        Fig. 13
                         shows the accuracy of swallow detection for three different food types. The percentage accuracy for chips, water, and sandwiches were 85.3%, 81.4%, and 84.5%, respectively. In this case, we define accuracy as the percentage of swallows correctly identified, because the algorithm was not evaluated on other activities that may be mislabeled as swallows.


                        Table 1
                         shows the accuracy of vibration sensor classification between solid and liquid foods. Best results were achieved using a naive Bayes classifier, which enabled us to identify liquids with an F-measure of 0.837% and solids with an F-measure of 0.864%. The presented results are based on leave-one-subject-out cross validation. Precision, recall, and other relevant terms used in this paper are defined in Eq. (3). As this table shows, the recall corresponding with the liquid class is rather low, at 79.4%. In other words, in cases when the classifier reported that a liquid had been swallowed, the food was often a solid. One possible explanation for this is the relatively high variety in the eating patterns of different individuals. For example, some subjects preferred to chew the food excessively before swallowing, while others ate at a much quicker pace. Significant variations were also noted in the same subject during different days, while eating the same food. This suggests that eating patterns are dependent on a multitude of factors such as satiety, mood, time of day, and environment. To improve the recall of the liquid class, it may be necessary to extract more features with respect to the characteristics of the associated pulse, rather than stressing the frequency of swallows and the amplitude of the signal which appears to vary significantly based on the tightness of the necklace.
                           
                              (3)
                              
                                 Precision
                                 =
                                 
                                    
                                       tp
                                    
                                    
                                       tp
                                       +
                                       fp
                                    
                                 
                                 Recall
                                 =
                                 
                                    
                                       tp
                                    
                                    
                                       tp
                                       +
                                       fn
                                    
                                 
                                 F
                                 −
                                 measure
                                 =
                                 2
                                 ·
                                 
                                    
                                       Precision
                                       ·
                                       Recall
                                    
                                    
                                       Precision
                                       +
                                       Recall
                                    
                                 
                                 Accuracy
                                 =
                                 
                                    
                                       tp
                                       +
                                       tn
                                    
                                    
                                       tp
                                       +
                                       tn
                                       +
                                       fp
                                       +
                                       fn
                                    
                                 
                              
                           
                        
                     


                        Fig. 14
                         shows waveforms acquired from the accelerometer (20Hz) corresponding with horizontal and vertical head turns, as well as walking, in all three dimensions. As shown on these graphs, walking produces peaks in the X, Y, and Z axes on each step. Furthermore, horizontal and vertical head turns cause peaks in the Z and Y dimensions respectively, with relatively little activity on the other two axes. Of note is the similarity between these waveforms and those acquired from the vibration sensor. Therefore, peak detection in the X, Y, and Z domains can be used to identify these extraneous motions and disable swallow detection during these intervals.


                        Table 2
                         shows the results for activity recognition using the accelerometer. About 84% of head turns (horizontal), 80% of head turns (vertical), and 88% of steps were detected correctly based on a total of 150 collected samples. Without the accelerometer, these motions were frequently mistaken for swallows: 18% of left turns, 46% of vertical head motions, and 8% of steps were misclassified as swallows. Using accelerometer data to temporarily disable detection during these activities allowed us to substantially reduce our rate of false positives. This was able to reduce our false positive rate to 6%, 14%, and 2% for left turns, vertical motions, and steps, respectively.

It may not be practical to infer eating habits when an individual is walking briskly and simultaneously eating, because swallow detection is disabled during these periods. However, the majority of large meals are not eaten during periods of motion. Reducing the false positive rate of swallow detection is much more critical to accurate assessment of eating habits than further increasing the true positive rate. This is because most individuals spend a relatively small part of their day eating, compared to the variety of other motions and activities. Nevertheless, further investigation is warranted into decoupling physical activity-induced artifacts from the swallowing-related signals acquired from the piezoelectric sensor.

It was determined through extensive experimentation that the accuracy of swallow detection increases substantially as the vibration sensor is moved toward the lower region of the throat, compared to the mid-throat and the upper region, as shown in Fig. 15
                        . Fig. 15 shows the relative accuracy of swallow detection with respect to the location of the neck on which the vibration sensor was placed, based on data collected from 10 subjects.

The necklace was placed in three different configurations: comfortable, tight, and loose. Typically the loose configuration allowed only intermittent contact between the vibration sensor and neck. The tight configuration was typically described as too uncomfortable to be worn for more than a few minutes at a time. In the loose configuration, the back of the fabric necklace could be stretched back approximately 3cm from the back of the neck. The ”comfortable” configuration could be stretched approximately 1.8cm from the back of the neck, which is approximately one index finger width for the average adult. The corresponding tight necklace configuration value was 1cm.

Results revealed that tightening the necklace restricts the movement of the piezoelectric sensor, and decreases the sensitivity of detection such that swallows are barely visible on the waveform. Furthermore, the loose configuration׳s lack of movement restriction causes significant fluctuation in the data which was rendered unusable. Experiments reveal that the necklace must be fastened for the piezoelectric sensor to typically remain in contact with the skin, but sufficiently loose such that its movement is not completely restricted by the tension of the sports band.

@&#CONCLUSION@&#

In this paper, we describe a low-cost, wearable sensor system in the form of a necklace with an embedded piezoelectric sensor. The necklaces is capable of detecting food consumption and transmitting the data to a mobile phone for analysis. Results show that food can be classified between solid and liquid categories with high accuracy, and the proposed algorithm correctly identifies most swallows. The system and software described in this paper were designed with the primary goal of making individuals more aware of their eating habits, which we believe is critical for weight loss.

None.

@&#REFERENCES@&#

