@&#MAIN-TITLE@&#A framework for live and cross platform fingerspelling recognition using modified shape matrix variants on depth silhouettes

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Live fingerspelling recognition using modified interpretation of shape matrix.


                        
                        
                           
                           Cross platform solution for ISL, ASL, NTU datasets.


                        
                        
                           
                           Region, contour, and depth based shape matrix variants.


                        
                        
                           
                           Recognizes both one and two handed postures.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Depth sensing

Shape matrix

Line of reference

Principal axis

Fingerspelling recognition

@&#ABSTRACT@&#


               
               
                  Automatic recognition of fingerspelling postures in a live environment is a challenging task primarily due to the complex computation of popular moment-based and spectral descriptors. Shape matrix offers a time-efficient alternative that samples the shape region through the intersection points of adjacent log-polar sections. However, sparse sampling of the region by discrete log-polar intersection points cannot capture salience of the shape. This manuscript proposes modified forms of the shape matrix which can capture salience of the fingerspelling postures by the precise sampling of contours and regions. For effective segmentation and subsequent description, hand postures are acquired through the depth sensor. Proposed shape matrix variants are evaluated for fingerspelling recognition with one-handed and two-handed postures. Experiments are rigorously performed on three datasets including one-handed signs of American Sign Language (ASL), NTU hand digits, and both one-handed and two-handed signs of Indian Sign Language (ISL). Proposed shape matrix variants supersede the benchmark shape context and Gabor features by obtaining 94.15% accuracy on ISL dataset with minimum mean running time of 0.029 s. On ASL and NTU datasets, 91.86% and 95.11% accuracies are obtained with 0.0172 and 0.0483 s mean running times, respectively.
               
            

@&#INTRODUCTION@&#

Fingerspelling signs are the basic communication tool for hearing and speech disabled persons, which include hand postures for alphabets and digits of the pertaining sign language. The task of vision-based fingersign recognition is daunting in itself. Even with one-handed postures, self-occlusions and out-of-plane rotations always pose challenges. When one of the hands touches or overlaps the other to articulate a combined posture, the task becomes complex by many folds. It is very tough to implement a general hand posture recognizer due to multiplied degrees of the freedom of each hand that results into a galore of new shapes. Nevertheless, it is possible to realize context specific systems with appropriate acquisition mechanisms, features, and tolerable assumptions. The context might be universal, e.g., fingersign recognition or it can be defined to suit a specific need like identification of the postures for virtual 3D interfaces, robotic control, and hand grasp analysis. A solution to the automatic fingerspelling recognition is important as it not only targets a social cause but also motivates to resolve small context specific posture subsets. Systems working offline [1–6], on prerecorded videos [7–9], and in constrained acquisition setups [10–14] are readily available. Live and deployable hand posture recognition systems, capable of recognizing both one and two-handed postures, and performing across the contexts in a generalized perspective are required.

Features such as shape matrix [15] can prove to be efficient for the live recognition environments. The shape matrix aligns the shape with a circular grid and samples it through the intersection points of adjacent log-polar sections. Each cell corresponding to a sampled point is set in the binary shape matrix. The matrices of the two shapes are matched using XOR operation to determine the extent of their similarity. Although the feature is quite compact and fast, its posture recognition performance suffers due to the discrete sampling of the region which misses fine shape details and reliance on the maximum radius line as an axis of reference. The proposed work aims to develop a framework for the live fingerspelling recognition targeting both one-handed and two-handed postures of Indian Sign Language (ISL) with modified interpretations of the shape matrix. ISL dataset, customized to accomplish the task, comprises of 19 two-handed and 7 one-handed postures as shown in Fig. 1
                     . The contributions of the presented work are:

                        
                           1.
                           Modifications to the shape matrix are introduced to capture contour and region salience by; selecting the principal axis as a more stable axis of reference, selective radial subdivisions, and inclusion of the distance and the depth in log-polar sections.

Versatility of proposed features is verified on cross context fingersigns through experiments on the benchmark one-handed fingerspelling ASL dataset [16] and hand digits NTU [17] datasets.

Experiments are carried out with varying levels of depth patch exposure to evaluate the fitness of proposed features on the varying forearm portion of the hands.

The system is evaluated through k-Nearest Neighbor (kNN) classifier. It is experimentally shown that the proposed versions of the shape matrix are capable of achieving adequate accuracy within the real-time constraints.

Further, Section 2 discusses the relevant work in hand postures and fingerspelling recognition with an aim to explore live systems. Section 3 explains the arrangement of the depth-based posture acquisition and real-time execution. Shape matrix based description of the fingersign postures is explained in Section 4. An analysis of the selection of a reference line is given here to make the description invariant to arbitrary transformations. Section 5 explains experimental details with an introduction to the datasets employed in this work. A discussion on the obtained results is conducted under the same section. Finally, the manuscript is concluded in Section 6 highlighting the further research aspects and shortcomings of the proposed framework.

@&#RELATED WORK@&#

Detection of the hands and other body parts in variable background conditions using a 2D camera forms a research topic in itself [18–22]. Hand blobs obtained as a result of ill segmentation, adversely affect subsequent recognition process. The major problems in automated hand posture recognition owe to inadequacy of the acquisition environments supplemented by high dimensionality of hand movement, self-occlusions, processing speed, and rapid hand motion. After the inception of low cost depth sensors like KinectTM and similar depth sensing devices, live hand posture recognizers deployable in indoor environments have begun to develop. Some of these systems consider the complete depth frame to derive features [23,24], while others target hand regions as region-of-interest (ROI) to extract features [25–29].

Many systems follow kinematic hand model to recognize postures where geometrical means are used to capture hand structure. General examples are postures like ‘OK’, ‘Right’, ‘Left’, ‘Up’, ‘Down’, etc., which are used in different contexts. Finger detection and indexing are performed through curvature, peakedness, and convexity features [25]; number of geodesic distance maxima, their intensities, amplitudes, phases, major axis angle of inscribing ellipse, and associated major and minor axis lengths [26]; and using neural network based shape fitting[1]. A few postures can be tagged with this geometrical analysis, but capturing the essence of the shape is difficult. Moreover, the computation of a maximum inscribing circle [27] or ellipse [26,28] to extract the palm portion adds to computational complexity.

Being a sub-problem of generic shape recognition, techniques including higher order moments, spectral transforms, and geometrical methods are equally applicable to hand posture recognition. Priyal and Bora [5] demonstrated the robustness of Krawtchouk moment features against Zernike and geometric moments by recognizing a general set of hand postures. Tchebichef moments, Hu moments, and geometric features derived from the convex hull of hand postures are used by Dahmani and Larabi [6] to recognize fingerspellings in Arabian Sign Language (ArSL). As with Zernike moments, kernels of both Krawtchouk and Tchebichef moments are complex to compute and need prior normalization for scale invariance. Capability of multi-resolution analysis in the direction of radius is also not justified [30]. Wavelet transform description of Persian sign language alphabet postures with subsequent Multilayer Perceptron (MLP) based classification is given by Karami et al. [3]. Again, the prior normalization is performed before Wavelet application. The system is offline and portability in a live prototype is not discussed. Hrúz et al. [13] used Local Binary Patterns (LBP), Elliptical Fourier descriptor, Radial distance function, and Hu moments to describe shapes. Subsequently, Hidden Markov Model (HMM) was used for word level recognition. Resulting versatile system gave common platform for fingerspelling recognition in Turkish, Russian, and Czech sign languages. However, the impact on time complexity due to the use of multiple descriptors is not discussed. A comparative analysis of Zernike moments, Hu moments, and Fourier descriptors by Bourennane and Fossati [31] shows that Fourier descriptor magnitudes derived from hand shape signatures outperform others. A graph based description by Flasiński and Myśliński [32] also recognizes one-handed Polish sign language hand postures. In order to recognize British Sign language (BSL) fingerspells, Liwicki and Everingham [7] modified the histogram of gradients (HOG) by dividing the image area into small bins and computing the histogram of orientations for each bin. Instead of emphasizing on individual postures, a word level recognition using HMM is employed. Generalized Hough transform, intensity regions, and local features are used by Atlun and Albayrak [33] to tag Turkish alphabets. Description took 0.7 s to recognize an image using hypothesis-similarity-amount.

Shape matrix, introduced by Goshtasby [15], is hardly used in shape recognition in its original form due to sparse sampling of the shape. Nevertheless, the basic log-polar division concept appears in varied forms in both shape [34] and posture recognition [35,36] in conjunction with some other descriptors like generic Fourier descriptor. One of the pioneer applications of log-polar raster in contour matching given by Belongie et al. [37] appears in the form of shape context. It is defined as a histogram hi
                     (k) for a point pi
                      on the shape contour such that 
                        
                           
                              h
                              i
                           
                           
                              (
                              k
                              )
                           
                           =
                           #
                           
                              {
                              q
                              ≠
                              
                                 p
                                 i
                              
                              
                                 )
                                 ∈
                                 b
                                 i
                                 n
                                 
                                    (
                                    k
                                    )
                                 
                              
                              }
                           
                           ,
                        
                      where k is the number of bins and 1 ≤ i ≤ N. Use of relative coordinates (
                        
                           q
                           −
                           
                              p
                              i
                           
                        
                     ) gives invariance to shape transformations. The scheme achieved fair results on benchmark shape databases. However, the computational overhead of O(n
                     3) in matching two shapes makes it unsuitable for live implementation. Moreover, when posture contour changes due to small noise or exposed forearm portion, recognition accuracy badly suffers [17]. Successors of shape context [38,39] are bound to suffer from the same problem. However, being a benchmark contour matching technique, it is evaluated on ISL dataset and compared with the proposed descriptors.

While the temporal issue is almost ignored towards gaining accuracy, some techniques find a good trade-off between computation speed and accuracy, and can be deployed in live environments. Pugeault and Bowden [16] applied 2D Gabor filter bank with 4 scales and 4 orientations on the color and depth frames of ASL dataset for fingerspelling recognition at 30 operations/sec. Feature vector of length 1024 was evaluated with multiclass random forest. However, due to lack of background separation on depth frames, accuracy suffered. Pedersoli et al. [29] applied similar Gabor filter banks evaluated by Support Vector Machine (SVM) using radial basis function kernel to obtain 90% accuracy on ASL dataset [16]. Huang et al. [40] also applied Gabor filter in hand posture recognition with SVM classification on intensity image based small customized dataset. As the worth of Gabor features has been demonstrated in a number of posture recognition systems, it is also evaluated on the customized ISL dataset for comparison. Another contour oriented technique by Ren et al. [17] applies Finger Earth Mover Distance (FEMD) on self-collected NTU hand digit dataset to obtain 93.2% accuracy in a mean running time of 0.0750 s. FEMD scheme establishes threshold rules to make a recognition decision and forms a training independent system. However, the base of FEMD is in detection of fingers and its response cannot be estimated on hand postures not characterized by fingers.

For live recognition of fingerspelling postures, some measures are desirable to assess temporal efficiency of techniques employed for the purpose. It is important due to extensive segmentation efforts at preliminary stages, complex region based intensity image processing, and computation of multiple features on a single thread of execution done by typical systems. Moreover, there should always be a scope for generalization in the sense that description scheme can recognize additional postures, if needed. The proposed work gives modified and novel interpretation to the shape matrix in three representations, i.e., region, contour, and depth so that hand postures can be recognized effectively in the rigid live environment constraints. Versatility of the descriptors is demonstrated on generic fingerspelling postures using three different datasets. Efficacy of the features is verified by obtaining 94.15, 91.86 and 95.11% accuracies on ISL, ASL, and NTU datasets. Results are obtained in mean running times of 0.029, 0.0172, and 0.0483 s, respectively.

ROI extraction is a preliminary step in hand posture recognition. It separates hands from the remaining body and the background. Due to inherent limitations of conventional 2D cameras, depth sensor is employed to capture postures in a live video stream. Depth sensor and associated hardware used in the new generation cameras measure relative distances of the physical objects placed in their field of view (FoV). Use of KinectTM, a camera with the depth sensing capability, has become widespread nowadays, especially in gesture based games. It offers a 640 × 480 30 frames/sec depth image stream apart from a 640 × 480 (VGA) 30 frames/sec RGB color stream [41,42]. A structured infrared light projection and sensing system is used to sense the depth. Once an angle between the projector and sensor is acquired, depth is computed by triangulation based on the principle of structured light sensing. Depth stream is used in this work to capture hand postures and subsequent descriptor extraction. Hand region is considered closest to the camera. This assumption can be avoided if a skin color based hand detection technique is incorporated to separate hands from rest of the competing objects within the same depth range. However, it would require RGB color stream to be synchronized with the depth stream at the cost of computation overhead. FoV is adjusted to 320 × 240 within the basic depth stream to avoid redundant background. Let 
                        
                           D
                           (
                           x
                           ,
                           y
                           )
                           =
                           d
                        
                      denote the depth corresponding to a point (x, y) in a 320 × 240 depth frame D acquired by the depth sensor. In order to detect the hand portion, it is necessary to find the depth (dmin
                     ) in D from where the hand region begins.

                        
                           (1)
                           
                              
                                 
                                    d
                                    
                                       m
                                       i
                                       n
                                    
                                 
                                 =
                                 m
                                 i
                                 n
                                 
                                    {
                                    
                                       D
                                       
                                          (
                                          x
                                          ,
                                          y
                                          )
                                       
                                       |
                                       1
                                       ≤
                                       x
                                       ≤
                                    
                                    
                                       x
                                       
                                          m
                                          a
                                          x
                                       
                                    
                                    ,
                                    1
                                    ≤
                                    y
                                    ≤
                                    
                                       y
                                       
                                          m
                                          a
                                          x
                                       
                                    
                                    }
                                 
                              
                           
                        
                     
                  

Further, beginning with dmin
                     , a depth threshold T should be established such that the depth range dmin
                      to 
                        
                           
                              d
                              
                                 m
                                 i
                                 n
                              
                           
                           +
                           T
                        
                      covers palm and fingers portion. This makes an arrangement such that depth 
                        
                           D
                           
                              (
                              x
                              ,
                              y
                              )
                           
                           >
                           
                              d
                              
                                 m
                                 i
                                 n
                              
                           
                           +
                           T
                        
                      belongs to the objects of no interest including the background. Let R be the portion of hand that pertains to ROI defined as

                        
                           (2)
                           
                              
                                 R
                                 =
                                 
                                    {
                                    
                                       
                                          (
                                          x
                                          ,
                                          y
                                          )
                                       
                                       |
                                    
                                    
                                       d
                                       
                                          m
                                          i
                                          n
                                       
                                    
                                    ≤
                                    D
                                    
                                       (
                                       x
                                       ,
                                       y
                                       )
                                    
                                    ≤
                                    
                                       d
                                       
                                          m
                                          i
                                          n
                                       
                                    
                                    +
                                    T
                                    ,
                                    1
                                    ≤
                                    x
                                    ≤
                                    
                                       x
                                       
                                          m
                                          a
                                          x
                                       
                                    
                                    ,
                                    1
                                    ≤
                                    y
                                    ≤
                                    
                                       y
                                       
                                          m
                                          a
                                          x
                                       
                                    
                                    }
                                 
                                 .
                              
                           
                        
                     
                  


                     D can now be thresholded to generate a binary frame B containing R.

                        
                           (3)
                           
                              
                                 B
                                 
                                    (
                                    x
                                    ,
                                    y
                                    )
                                 
                                 =
                                 
                                    {
                                    
                                       
                                          
                                             1
                                          
                                          
                                             
                                                
                                                   if
                                                
                                                
                                                
                                                   d
                                                   
                                                      m
                                                      i
                                                      n
                                                   
                                                
                                                ≤
                                                D
                                                
                                                   (
                                                   x
                                                   ,
                                                   y
                                                   )
                                                
                                                ≤
                                                
                                                   d
                                                   
                                                      m
                                                      i
                                                      n
                                                   
                                                
                                                +
                                                T
                                                ;
                                             
                                          
                                       
                                       
                                          
                                             0
                                          
                                          
                                             
                                                otherwise
                                                ,
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     where 1 ≤ x ≤ xmax
                      and 1 ≤ y ≤ ymax
                     .

Measurement errors might cause isolated noise chunks (false positives) to appear prior to actual dmin
                      or within the threshold range dmin
                      to 
                        
                           
                              d
                              
                                 m
                                 i
                                 n
                              
                           
                           +
                           T
                        
                     . To eliminate these noise artifacts, opening and closing morphological operations are conducted in sequence over the binary plane B with disk structuring element of size 6 × 6. The depth thresholding step mentioned in Eq. 3 is repeated if no blob is detected. Both morphological operations are performed once again over the qualified blob(s) in B, B ≠ ϕ to smooth out the posture outline as well as to fill up the holes which might get introduced due to the measurement errors.

In an alternative arrangement, postures can be captured within a specific distance range dmin
                      to 
                        
                           
                              d
                              
                                 m
                                 i
                                 n
                              
                           
                           +
                           T
                        
                     . Here, a predetermined value of dmin
                      marks beginning point of the articulation region. Though, the user is constrained to articulate within dmin
                      to 
                        
                           
                              d
                              
                                 m
                                 i
                                 n
                              
                           
                           +
                           T
                           ,
                        
                      arrangement eliminates the computation of dmin
                      resulting in a comparatively faster hand pose acquisition. ROI can be obtained using Eq. 3. The minimum articulation distance dmin
                      is determined as 800 mm for experiments considering the near-mode constraints in KinectTM. Determination of depth threshold T is empirical and established by the inspection of hand samples included in the dataset. It is found that a threshold value of 120 mm is sufficient to cover the most lateral gesture of an average hand.
                  

Whenever a single blob is detected in the view, testing module turns active. Adjacent frames contain redundant information, therefore a few interleaved epenthesis frames can be dropped without further processing. Each Nth frame in the sequence is processed provided it fulfills the criteria of stable centroid and equal area. If a posture is stable for N consecutive frames, the difference in posture centroids of first and Nth frames in terms of Euclidean distance would be insignificant. Areas of the two postures would also have negligible difference. Let 
                        
                           O
                           =
                           (
                           
                              x
                              c
                           
                           ,
                           
                              y
                              c
                           
                           )
                        
                      and Ar be the centroid and area (in number of pixels) of the obtained blob in the first frame, while O′ and Ar′ represent centroid and area, respectively, for the hand blob obtained in the Nth frame. The Nth depth frame qualifies for processing if centroid shift 
                        
                           
                              |
                              O
                              −
                              O
                              |
                              <
                           
                           
                              ϵ
                              1
                           
                        
                      and change of area 
                        
                           
                              |
                              A
                              r
                              −
                              A
                           
                           
                              r
                              ′
                           
                           
                              |
                              <
                           
                           
                              ϵ
                              2
                           
                        
                     . Quantities 
                        
                           ϵ
                           1
                        
                      and 
                        
                           ϵ
                           2
                        
                      are thresholds for centroid shift and area deviation, respectively. Window size N can be adjusted as per speed of signing and it is varied from 2 to 5 in the experiments.

In another testing scenario, also suggested by Pugeault and Bowden [16], every frame i in the sequence is considered as legitimate, which is further investigated against velocity and area variance thresholds to qualify for a ‘key frame’. Velocity v can be computed as 
                        
                           v
                           =
                           
                              1
                              N
                           
                           
                              ∑
                              
                                 i
                                 =
                                 1
                              
                              N
                           
                           
                              |
                              
                                 O
                                 
                                    i
                                    +
                                    1
                                 
                              
                              −
                              
                                 O
                                 i
                              
                              |
                           
                        
                      and can be verified against a threshold 
                        
                           v
                           <
                           
                              ϵ
                              3
                           
                           ,
                        
                     
                     
                        
                           
                              ϵ
                              3
                           
                           =
                           0.05
                        
                     . Similarly, variance of areas 
                        
                           
                              σ
                              2
                           
                           =
                           
                              1
                              N
                           
                           
                              ∑
                              
                                 i
                                 =
                                 1
                              
                              N
                           
                           
                              |
                              A
                              
                                 r
                                 i
                              
                              −
                              A
                              
                                 r
                                 m
                              
                              |
                           
                        
                      can be verified as 
                        
                           
                              σ
                              2
                           
                           <
                           
                              ϵ
                              4
                           
                           ,
                        
                     
                     
                        
                           
                              ϵ
                              4
                           
                           <
                           0.02
                        
                     . Here, Arm
                      is the mean area. Fig. 2 illustrates the acquisition of postures through depth sensor and real-time recognition.

Shape matrix lays the foundation of the subsequent description process. Concept of shape matrix, its applicability to posture recognition, and suggested modifications are discussed here.

Most of the shape description methods use rectangular grid sampling to extract shape saliency. However, rectangular rasters may be inefficient to counter transformation variances, especially arbitrary rotations. Circular grid sampling is an efficient alternative for normalization against transformation variations. The centroid of the shape coincides with the center of a polar grid with radial divisions. The resulting log-polar sections can be associated with a 2D matrix having one dimension corresponding to angular divisions and the other to radial divisions. Goshtasby [15] terms this matrix as shape matrix and employs maximum radius line as the axis of reference to begin polar partitions. Maximum radius line joins the centroid to the farthest point on the shape. Selection of this line as the axis of reference is fundamental to rotation and scale invariance, and its emergence from the centroid makes it translation invariant as well. The algorithm iterates over m polar and n radial divisions to generate mn polar points. Depending on, whether the polar point 
                           
                              (
                              i
                              R
                              /
                              (
                              n
                              −
                              1
                              )
                              ,
                              360
                              j
                              /
                              m
                              )
                           
                         corresponding to jth radial section of ith polar division lies within the shape region, entry in jth column of the ith row of the shape matrix is set. Two shapes can then be compared by their logical shape matrices using simple XOR operations. If M
                        1 and M
                        2 are shape matrices, then the similarity of corresponding shapes ρ is computed as

                           
                              (4)
                              
                                 
                                    S
                                    =
                                    
                                       ∑
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          m
                                          −
                                          1
                                       
                                    
                                    
                                       
                                          ∑
                                          
                                             j
                                             =
                                             1
                                          
                                          
                                             n
                                             −
                                             1
                                          
                                       
                                       
                                          
                                             M
                                             1
                                          
                                          
                                             (
                                             i
                                             ,
                                             j
                                             )
                                          
                                          ⊕
                                          
                                             M
                                             2
                                          
                                          
                                             (
                                             i
                                             ,
                                             j
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (5)
                              
                                 
                                    ρ
                                    =
                                    1
                                    −
                                    
                                       S
                                       
                                          n
                                          (
                                          m
                                          −
                                          2
                                          )
                                       
                                    
                                    ,
                                 
                              
                           
                        where ⊕ is binary XOR operator. All the shapes produce similarities between 0 and 1. For exactly similar shapes, ρ is 1. Applications of the shape matrix are demonstrated for detection of defective objects, template matching and character recognition [15,43].

The shape described through basic shape matrix is a rough sampling of the region by polar coordinates. Polar coordinates are mere intersections of radial lines by concentric circles. The description is nothing but a probe for existence of intersection points within the shape region. Hence, capturing the saliency of underlying shape is difficult as a polar point approximation might not capture subtle details. Secondly, the maximum radius line selected as the axis of reference may itself lead to errors for noisy and symmetric shapes samples. For better description of the shape, its contour can be sampled on the basis of gradient of the line joining the centroid and a contour point. The distance of the contour point from the centroid can discriminate it from other contour points with different gradients. Angular sampling is done with reference to a standard line (a vector, in fact) which is unique for all shapes of a specific kind (the maximum radius line in shape matrix). Selection of the most stable line of reference is important for correct shape recognition.

The line of reference is selected to mitigate the effects of arbitrary rotations and is essential for other normalizations too. This line ought to be similar for various instances of a posture (shape) class. Depending on the articulation and the amount of distortion in shapes, reference lines for instances of the same class might shuffle leading to disagreements in shape definitions. Line connecting two farthest points, axis of the least inertia, Eigen axes (principal axes), and maximum radius line are some of the possible candidates for reference line. The suitability of an alternative is decided empirically with visual perception only.

Also referred as major axis, this line connects two farthest points of the shape. The line joining two points Pq
                                  and Pr
                                  within N points of shape S is major axis, if

                                    
                                       (6)
                                       
                                          
                                             d
                                             i
                                             s
                                             t
                                             
                                                (
                                                
                                                   P
                                                   q
                                                
                                                ,
                                                
                                                   P
                                                   r
                                                
                                                )
                                             
                                             =
                                             m
                                             a
                                             x
                                             
                                                {
                                                d
                                                i
                                                s
                                                t
                                                (
                                                
                                                   P
                                                   i
                                                
                                                ,
                                                
                                                   P
                                                   j
                                                
                                                )
                                                |
                                                1
                                                ≤
                                                i
                                                ≤
                                                N
                                                ,
                                                1
                                                ≤
                                                j
                                                ≤
                                                N
                                                ,
                                                
                                                
                                                   and
                                                
                                                
                                                i
                                                ≠
                                                j
                                                }
                                             
                                          
                                       
                                    
                                 where function dist() gives Euclidean distance between two points. Let the line PqPr
                                  be inclined by an angle θ with x-axis, then θ is determined in the following steps:

                                    
                                       
                                          
                                             
                                                
                                                   
                                                      α
                                                      =
                                                      
                                                         tan
                                                         
                                                            −
                                                            1
                                                         
                                                      
                                                      
                                                         (
                                                         
                                                            
                                                               
                                                                  y
                                                                  q
                                                               
                                                               −
                                                               
                                                                  y
                                                                  r
                                                               
                                                            
                                                            
                                                               
                                                                  x
                                                                  q
                                                               
                                                               −
                                                               
                                                                  x
                                                                  r
                                                               
                                                            
                                                         
                                                         )
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      β
                                                      =
                                                      s
                                                      i
                                                      
                                                         n
                                                         
                                                            −
                                                            1
                                                         
                                                      
                                                      
                                                         (
                                                         
                                                            
                                                               
                                                                  y
                                                                  q
                                                               
                                                               −
                                                               
                                                                  y
                                                                  r
                                                               
                                                            
                                                            
                                                               
                                                                  
                                                                     
                                                                        (
                                                                        
                                                                           x
                                                                           q
                                                                        
                                                                        −
                                                                        
                                                                           x
                                                                           r
                                                                        
                                                                        )
                                                                     
                                                                     2
                                                                  
                                                                  +
                                                                  
                                                                     
                                                                        (
                                                                        
                                                                           y
                                                                           q
                                                                        
                                                                        −
                                                                        
                                                                           y
                                                                           r
                                                                        
                                                                        )
                                                                     
                                                                     2
                                                                  
                                                               
                                                            
                                                         
                                                         )
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       (7)
                                       
                                          
                                             θ
                                             =
                                             
                                                {
                                                
                                                   
                                                      
                                                         
                                                            α
                                                            +
                                                            180
                                                            ,
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               if
                                                            
                                                            
                                                            α
                                                            <
                                                            0
                                                            
                                                            
                                                               and
                                                            
                                                            
                                                            β
                                                            >
                                                            0
                                                            ;
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            α
                                                            −
                                                            180
                                                            ,
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               if
                                                            
                                                            
                                                            α
                                                            >
                                                            0
                                                            
                                                            
                                                               and
                                                            
                                                            
                                                            β
                                                            <
                                                            0
                                                            ;
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         α
                                                      
                                                      
                                                         
                                                            otherwise
                                                            .
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 where (xq, yq
                                 ) and (xr, yr
                                 ) are coordinates of points Pq
                                  and Pr
                                 , respectively.

This line connects centroid O to the farthest point P in shape S. It is expressed in the similar way as major axis except one of the two points, Pq
                                  or Pr
                                  is replaced by centroid O. Angle θ can be determined by Eq. 7.

Axis of least inertia is the line for which sum of the squares of distances of all points on the shape is minimum. The sum is given as ([44])

                                    
                                       (8)
                                       
                                          
                                             E
                                             =
                                             
                                                1
                                                2
                                             
                                             
                                                (
                                                a
                                                +
                                                c
                                                )
                                             
                                             −
                                             
                                                1
                                                2
                                             
                                             
                                                (
                                                a
                                                −
                                                c
                                                )
                                             
                                             cos
                                             
                                                2
                                                α
                                             
                                             −
                                             
                                                1
                                                2
                                             
                                             b
                                             sin
                                             
                                                2
                                                α
                                             
                                             .
                                          
                                       
                                    
                                 where 
                                    
                                       a
                                       =
                                       
                                          ∑
                                          
                                             i
                                             =
                                             1
                                          
                                          n
                                       
                                       
                                          
                                             (
                                             
                                                x
                                                i
                                             
                                             −
                                             
                                                x
                                                c
                                             
                                             )
                                          
                                          2
                                       
                                       ,
                                    
                                 
                                 
                                    
                                       b
                                       =
                                       2
                                       
                                          ∑
                                          
                                             i
                                             =
                                             1
                                          
                                          n
                                       
                                       
                                          
                                             (
                                             
                                                x
                                                i
                                             
                                             −
                                             
                                                x
                                                c
                                             
                                             )
                                          
                                          
                                             (
                                             
                                                y
                                                i
                                             
                                             −
                                             
                                                y
                                                c
                                             
                                             )
                                          
                                       
                                       ,
                                    
                                 
                                 
                                    
                                       c
                                       =
                                       
                                          ∑
                                          
                                             i
                                             =
                                             1
                                          
                                          n
                                       
                                       
                                          
                                             (
                                             
                                                y
                                                i
                                             
                                             −
                                             
                                                y
                                                c
                                             
                                             )
                                          
                                          2
                                       
                                    
                                  and (xc, yc
                                 ) is centroid of a set of n shape points with each point having coordinates in the form (xi, yi
                                 ), and α is the angle between the axis of least inertia and the x-axis. Differentiating E and equating 
                                    
                                       
                                          d
                                          E
                                       
                                       
                                          d
                                          α
                                       
                                    
                                  to 0 gives

                                    
                                       (9)
                                       
                                          
                                             
                                                
                                                   d
                                                   E
                                                
                                                
                                                   d
                                                   α
                                                
                                             
                                             =
                                             
                                                (
                                                a
                                                −
                                                c
                                                )
                                             
                                             sin
                                             
                                                2
                                                α
                                             
                                             −
                                             b
                                             cos
                                             
                                                2
                                                α
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       (10)
                                       
                                          
                                             
                                                
                                                   
                                                      d
                                                      2
                                                   
                                                   E
                                                
                                                
                                                   d
                                                   
                                                      α
                                                      2
                                                   
                                                
                                             
                                             =
                                             2
                                             
                                                [
                                                (
                                                a
                                                −
                                                c
                                                )
                                                cos
                                                
                                                   2
                                                   α
                                                
                                                −
                                                b
                                                sin
                                                
                                                   2
                                                   α
                                                
                                                ]
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       (11)
                                       
                                          
                                             
                                                
                                                   
                                                      α
                                                      =
                                                      
                                                         1
                                                         2
                                                      
                                                      
                                                         tan
                                                         
                                                            −
                                                            1
                                                         
                                                      
                                                      
                                                         (
                                                         
                                                            b
                                                            
                                                               a
                                                               −
                                                               c
                                                            
                                                         
                                                         )
                                                      
                                                      ,
                                                   
                                                
                                                
                                                   
                                                      −
                                                      
                                                         π
                                                         2
                                                      
                                                      <
                                                      α
                                                      <
                                                      
                                                         π
                                                         2
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              

Slope angle θ is given by

                                    
                                       (12)
                                       
                                          
                                             θ
                                             =
                                             
                                                {
                                                
                                                   
                                                      
                                                         
                                                            α
                                                            +
                                                            
                                                               π
                                                               2
                                                            
                                                            ,
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               if
                                                            
                                                            
                                                            
                                                               
                                                                  
                                                                     d
                                                                     2
                                                                  
                                                                  E
                                                               
                                                               
                                                                  d
                                                                  
                                                                     α
                                                                     2
                                                                  
                                                               
                                                            
                                                            <
                                                            0
                                                            ;
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         α
                                                      
                                                      
                                                         
                                                            otherwise
                                                            .
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              

Principal axes are two orthonormal vectors on the shape centroid which represent the directions with no cross-correlation [45]. Let X be the set of all N shape points in the vector form defined as 
                                    
                                       X
                                       =
                                       
                                          {
                                          
                                             x
                                             i
                                          
                                          
                                             |
                                          
                                          
                                             x
                                             i
                                          
                                          =
                                          
                                             
                                                (
                                                
                                                   x
                                                   i
                                                
                                                ,
                                                
                                                   y
                                                   i
                                                
                                                )
                                             
                                             T
                                          
                                          ,
                                          1
                                          ≤
                                          i
                                          ≤
                                          N
                                          }
                                       
                                    
                                  and 
                                    
                                       
                                          m
                                          x
                                       
                                       =
                                       
                                          
                                             (
                                             
                                                x
                                                c
                                             
                                             ,
                                             
                                                y
                                                c
                                             
                                             )
                                          
                                          T
                                       
                                    
                                  be their mean, then covariance matrix Cx
                                  of the vector population is computed as

                                    
                                       (13)
                                       
                                          
                                             
                                                C
                                                x
                                             
                                             =
                                             
                                                ∑
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                N
                                             
                                             
                                                
                                                   (
                                                   
                                                      x
                                                      i
                                                   
                                                   −
                                                   
                                                      m
                                                      x
                                                   
                                                   )
                                                
                                                
                                                   
                                                      (
                                                      
                                                         x
                                                         i
                                                      
                                                      −
                                                      
                                                         m
                                                         x
                                                      
                                                      )
                                                   
                                                   T
                                                
                                             
                                             .
                                          
                                       
                                    
                                 
                              

Let e
                                 1 and e
                                 2 be two orthonormal vectors corresponding to eigenvalues λ
                                 1 and λ
                                 2 determined from Cx
                                  (λ
                                 1 > λ
                                 2). Either e
                                 1 or e
                                 2 can be used as the line of reference. If A is the matrix containing e
                                 1 and e
                                 2 arranged in rows, then the transformation 
                                    
                                       y
                                       =
                                       A
                                       x
                                    
                                  gives the set of points aligned to eigenvectors e
                                 1 and e
                                 2. If 
                                    
                                       
                                          e
                                          1
                                       
                                       =
                                       
                                          
                                             (
                                             
                                                x
                                                e
                                             
                                             ,
                                             
                                                y
                                                e
                                             
                                             )
                                          
                                          T
                                       
                                       ,
                                    
                                  then 
                                    
                                       α
                                       =
                                       
                                          tan
                                          
                                             −
                                             1
                                          
                                       
                                       
                                          (
                                          
                                             y
                                             e
                                          
                                          /
                                          
                                             x
                                             e
                                          
                                          )
                                       
                                    
                                  and θ can be computed using Eq. 7.

In Fig. 3
                                 , each row shows four contour instances for different alphabet postures in ISL. Odd rows display the reference lines for the axis of least inertia, maximum radius line and major axis, respectively. For all contour instances at each odd row, subsequent even row shows principal axis as the reference line. Consistency of the principal axis for all contour instances is evident as compared to other alternatives. In the proposed work, the first principal vector e
                                 1 corresponding to the larger eigenvalue λ
                                 1 is employed as the line of reference. The process of e
                                 1 and e
                                 2 generation is depicted in Fig. 4
                                  for two instances of ISL alphabet ‘P’. Their uniqueness is justified by the transformation 
                                    
                                       y
                                       =
                                       A
                                       x
                                    
                                  that aligns binary blobs with e
                                 1 and e
                                 2 to get uniform orientation.

A logical two dimensional array is employed with predetermined gradient intervals, e.g., 1–30, 31–60, 
                              
                                 …
                                 ,
                              
                            331–360, in one dimension and calibrated distance ranges in the other. Each row i in this array belongs to a polar range 
                              
                                 θ
                                 l
                                 i
                              
                            - 
                              
                                 
                                    θ
                                    u
                                    i
                                 
                                 ,
                              
                            and each column j pertains to a radial division 
                              
                                 r
                                 l
                                 j
                              
                            - 
                              
                                 r
                                 u
                                 j
                              
                           . Each cell indicates whether the posture contour passes through the corresponding log-polar section. Slope of a line joining a contour point to the centroid O and its length generate indices for the modified shape matrix M. As the first step of the algorithm, the maximum distance is obtained by taking the distances of all the points on each contour from O towards further normalization. Subsequently, an axis of reference is established as mentioned in Section 4.2.1 to generate the reference angle θ. During the second step, slope for each point on every contour is determined to get the row index i in the same way that of maximum radius line. If this slope is δ, then the slope with respect to the axis of reference would be 
                              
                                 φ
                                 =
                                 δ
                                 +
                                 θ
                              
                           . The limits of i
                           th polar section 
                              
                                 θ
                                 l
                                 i
                              
                            - 
                              
                                 θ
                                 u
                                 i
                              
                            can be described as 
                              
                                 
                                    θ
                                    l
                                    i
                                 
                                 =
                                 
                                    (
                                    360
                                    i
                                    /
                                    m
                                    +
                                    θ
                                    )
                                 
                              
                            and 
                              
                                 
                                    θ
                                    u
                                    i
                                 
                                 =
                                 
                                    θ
                                    l
                                    i
                                 
                                 +
                                 
                                    
                                       360
                                       (
                                       i
                                       +
                                       1
                                       )
                                    
                                    
                                       m
                                       −
                                       1
                                    
                                 
                              
                           . Instead of checking the entire range 
                              
                                 θ
                                 l
                                 i
                              
                            - 
                              
                                 θ
                                 u
                                 i
                              
                           ; 
                              
                                 0
                                 ≤
                                 i
                                 ≤
                                 m
                                 −
                                 1
                              
                            for φ , the row index i can be determined using Eq. 14.

                              
                                 (14)
                                 
                                    
                                       i
                                       =
                                       
                                          ⌈
                                          
                                             
                                                φ
                                                m
                                             
                                             360
                                          
                                          ⌉
                                       
                                    
                                 
                              
                           Note that φ is within 0° – 360°.

Once i is determined, distance r of each contour point P from O is obtained and thresholded to a specific radial range 
                              
                                 r
                                 l
                                 j
                              
                            – 
                              
                                 r
                                 u
                                 j
                              
                           . Again, conditional checks are avoided by computing radial division (column) index j as

                              
                                 (15)
                                 
                                    
                                       j
                                       =
                                       ⌈
                                       
                                          r
                                          n
                                       
                                       ⌉
                                       ,
                                    
                                 
                              
                           where r is the normalized distance obtained by min-max normalization and n is the number of radial divisions. Cell M(i, j) corresponding to P can be set now. The procedure continues with the next point available, if any. Fig. 5
                            distinguishes between the original shape matrix and its proposed interpretation.

For convex shapes, the number of pixels in outer circles is larger than the inner ones. This means peripheral sections contain richer information. For a number of one-handed postures, like the ones in ASL and NTU datasets, information lies in the outer circles. However, in concave or symmetrically shaped postures, information may lie in the inner circles also. Shapes resulting from two-handed postures like alphabets ‘A’,‘B’, ‘K’, and ‘X’ in ISL contain discriminatory information in the inner circles. Fortunately, angular spreads get smaller with decreasing radius making the sampled points dense towards the center. Shape matrix strategy can be modified to emphasize the subtle details appearing at distances farther to the shape centroid. A weight based strategy by Taza and Suen [43] focuses on this issue by assigning weights to the shape matrix columns in proportion of the radius. Weighting strategy emphasizes outer circle details but does not help to capture them. A radial subdivision strategy used in this work helps to capture information effectively on the circles of increasing radius. Note that the linear increment in m and/or n increases the size of the shape matrix missing the shape details. Radial sections, beginning from peripheral section to the innermost, are divided into a decreasing number of subsections. In general, n original radial sections generate a total of 
                              
                                 n
                                 (
                                 n
                                 +
                                 1
                                 )
                                 /
                                 2
                              
                            divisions after subdivision. It is empirically found that 
                              
                                 n
                                 =
                                 3
                              
                            to 5 is sufficient to capture the salience of one-handed/two-handed postures within 6 to 15 total divisions. With this modification, row and column indices i and j representing a log-polar subdivision M(i, j) in the shape matrix M need to be redefined. Let r be the normalized distance of a contour point in a log-polar subdivision. Number of complete divisions a in j subdivisions are

                              
                                 (16)
                                 
                                    
                                       a
                                       =
                                       
                                          ⌊
                                          
                                             
                                                r
                                                n
                                             
                                             360
                                          
                                          ⌋
                                       
                                       .
                                    
                                 
                              
                           
                        

The number of subdivisions as
                            in a complete divisions, is given as

                              
                                 (17)
                                 
                                    
                                       
                                          a
                                          s
                                       
                                       =
                                       a
                                       
                                          
                                             (
                                             a
                                             +
                                             1
                                             )
                                          
                                          2
                                       
                                       .
                                    
                                 
                              
                           
                        

The following observations can be drawn from the above formulation:

                              
                                 •
                                 Length of each radial division is 1/n and that up to a
                                    th division is given as a/n.

Length of the remaining subdivisions before j in 
                                       
                                          
                                             (
                                             a
                                             +
                                             1
                                             )
                                          
                                          
                                             th
                                          
                                       
                                     division is 
                                       
                                          r
                                          −
                                          a
                                          /
                                          n
                                       
                                    .

Length of any subdivision in 
                                       
                                          
                                             (
                                             a
                                             +
                                             1
                                             )
                                          
                                          
                                             th
                                          
                                       
                                     division is 
                                       
                                          1
                                          
                                             n
                                             (
                                             a
                                             +
                                             1
                                             )
                                          
                                       
                                    .

Now, let the subdivision j with radial distance r lies within k
                           th subdivision of 
                              
                                 
                                    (
                                    a
                                    +
                                    1
                                    )
                                 
                                 
                                    th
                                 
                              
                            division. Then, k can be expressed as 
                              
                                 k
                                 =
                                 ⌈
                                 
                                    (
                                    r
                                    −
                                    
                                       a
                                       n
                                    
                                    )
                                 
                                 /
                                 
                                    {
                                    
                                       1
                                       
                                          n
                                          (
                                          a
                                          +
                                          1
                                          )
                                       
                                    
                                    }
                                 
                                 ⌉
                              
                            which upon simplification gives

                              
                                 (18)
                                 
                                    
                                       k
                                       =
                                       ⌈
                                       (
                                       r
                                       n
                                       −
                                       a
                                       )
                                       (
                                       a
                                       +
                                       1
                                       )
                                       ⌉
                                       .
                                    
                                 
                              
                           
                        

Radial subdivision index j can be determined from Eqs. 17 and18 as

                              
                                 (19)
                                 
                                    
                                       j
                                       =
                                       
                                          a
                                          s
                                       
                                       +
                                       k
                                       .
                                    
                                 
                              
                           
                        

It does not make sense to manipulate m as identification of specific polar divisions having shape saliency is rather complex. Formulation for j given above fits to n subdivisions in nth radial division policy. It will change, if subdivision strategy changes.

The binary shape matrices in Sections 4.2.2 and 4.2.3 mark the presence of contour points in log-polar sections. They do not convey how far a representative point is located from the centroid. To capture more salience, distances of representative points in log-polar sections are accommodated in shape matrix. Doing so estimates the location of a representative point within its local log-polar section. The radial distance r of a sampled point P on the contour should be associated with a cell M(i, j). The scheme proposed in Section 4.2.2 is slightly modified to accommodate r. Let Ppq
                            and 
                              
                                 P
                                 
                                    
                                       p
                                       ′
                                    
                                    
                                       q
                                       ′
                                    
                                 
                              
                            be two consecutively traversed points on any contour of shape S with (p, p′) ∈ i and (q, q′) ∈ j. If 
                              
                                 P
                                 
                                    
                                       p
                                       ′
                                    
                                    
                                       q
                                       ′
                                    
                                 
                              
                            remains in the same log-polar section, i.e., 
                              
                                 
                                    p
                                    ′
                                 
                                 =
                                 p
                              
                            and 
                              
                                 
                                    q
                                    ′
                                 
                                 =
                                 q
                                 ,
                              
                            then each P is added to the sum. This can be expressed as 
                              
                                 s
                                 u
                                 m
                                 =
                                 
                                    ∑
                                    
                                       p
                                       ∈
                                       i
                                       
                                       
                                          and
                                       
                                       
                                       q
                                       ∈
                                       j
                                    
                                 
                                 
                                    P
                                    
                                       p
                                       q
                                    
                                 
                              
                           . If 
                              
                                 P
                                 
                                    
                                       p
                                       ′
                                    
                                    
                                       q
                                       ′
                                    
                                 
                              
                            falls into a different log-polar section, i.e., p′ ≠ p or q′ ≠ q, then (i) all X, 
                              
                                 X
                                 =
                                 
                                    {
                                    
                                       P
                                       
                                          p
                                          q
                                       
                                    
                                    
                                       |
                                       p
                                       ∈
                                       i
                                       
                                       
                                          and
                                       
                                       
                                       q
                                       ∈
                                       j
                                    
                                    }
                                 
                                 ,
                              
                            are averaged to generate Pm
                            (ii) normalized Euclidean distance r between O and Pm
                            is computed (iii) M(i, j) is set as (
                              
                                 r
                                 −
                              
                            length of 
                              
                                 [
                                 
                                    a
                                    s
                                 
                                 +
                                 
                                    (
                                    k
                                    −
                                    1
                                    )
                                 
                                 ]
                              
                            subdivisions). Length of 
                              
                                 (
                                 k
                                 −
                                 1
                                 )
                              
                            subdivisions in 
                              
                                 
                                    (
                                    a
                                    +
                                    1
                                    )
                                 
                                 
                                    th
                                 
                              
                            division is 
                              
                                 (
                                 k
                                 −
                                 1
                                 )
                                 /
                                 [
                                 n
                                 (
                                 a
                                 +
                                 1
                                 )
                                 ]
                              
                           . Sectional distance or local displacement rs
                            is given in Eq. 20 and assigned to the cell M(i, j).

                              
                                 (20)
                                 
                                    
                                       
                                          r
                                          s
                                       
                                       =
                                       r
                                       −
                                       
                                          [
                                          
                                             1
                                             n
                                          
                                          
                                             (
                                             a
                                             +
                                             
                                                
                                                   k
                                                   −
                                                   1
                                                
                                                
                                                   a
                                                   +
                                                   1
                                                
                                             
                                             )
                                          
                                          ]
                                       
                                    
                                 
                              
                           
                        

The procedure to generate a decimal shape matrix is illustrated in Fig. 6
                            for ISL alphabet ‘D’ where local displacement computation is highlighted. Its pseudo-code is given as Algorithm 1
                            and evaluation is discussed in Section 5.

In algorithm Generate_Shape_Matrix, iprev
                            and jprev
                            denote row and column indices in M computed during the previous iteration. Symbol ϕ represents a NULL value or invalid index. For basic non-radial subdivision version of shape matrix, M is initialized as M[mn] ← 0. It is mandatory to check condition 
                              
                                 
                                    i
                                    
                                       p
                                       r
                                       e
                                       v
                                    
                                 
                                 =
                                 ϕ
                              
                            or 
                              
                                 
                                    j
                                    
                                       p
                                       r
                                       e
                                       v
                                    
                                 
                                 =
                                 ϕ
                              
                            to deal with the first log-polar section. As more than one contour fragment might appear in a log-polar section, the statement 
                              
                                 M
                                 
                                    (
                                    
                                       i
                                       
                                          p
                                          r
                                          e
                                          v
                                       
                                    
                                    ,
                                    
                                       j
                                       
                                          p
                                          r
                                          e
                                          v
                                       
                                    
                                    )
                                 
                                 =
                                 
                                    r
                                    s
                                 
                                 ,
                              
                            assigns largest of the rs
                            of average points corresponding to traversed contour fragments.

Assignment of radial distance r to a cell M(i, j), without computing rs
                           , gives another version of the shape matrix termed as Log-Polar Signature (LPS). LPS can be expressed as 
                              
                                 L
                                 P
                                 S
                                 =
                                 
                                    ∥
                                    
                                       i
                                       =
                                       1
                                    
                                    m
                                 
                                 
                                    ∥
                                    
                                       j
                                       =
                                       1
                                    
                                    n
                                 
                                 
                                    r
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 ,
                              
                            where ∥ denotes concatenation and r
                           
                              i, j
                            represents radial distance to a contour point stored in the cell M(i, j). Indices i and j obtained respectively from Eqs. 14 and19 avoid 
                              
                                 m
                                 n
                                 (
                                 n
                                 +
                                 1
                                 )
                                 /
                                 2
                              
                            conditional checks which are required to obtain i and j in a usual way. M(iprev, jprev
                           ) would be assigned 1 on the detection of a changed i or j for binary radial subdivision. Fig. 7
                           (a) shows three instances of hand digit ‘4’ articulations from NTU dataset at different levels of forearm exposure while Fig. 7(b) shows the same number of articulated instances for ISL alphabet ‘P’. Second column shows the contours for corresponding articulations along with principal axis. The third and fourth columns display LPS and local displacement matrices (Shape matrices with rs
                           ) for the corresponding instances, respectively. Despite the arbitrary extension of forearm regions, uniformity of the signature and within cell displacement matrix for each posture type is evident in the figure. This is the case where contour based techniques which apply histogram computation based features [37–39] suffer because proportion of the pixels in log-polar cells is not consistent due to unpredictable exposures of the forearm.

The shape matrix variants discussed so far are limited in description of the contours. For a number of postures, discriminative information lies in the posture region which cannot be captured effectively through contours. ISL alphabets ‘M’, ‘N’, ‘R’, ‘S’ and ASL alphabets ‘a’, ‘e’, ‘m’, ‘n’, ‘s’, ‘t’ are some examples. Implicit region details available in depth(3D) information can be extracted if depth silhouettes are not binarized using Eq. 3. Considering the intersection points shown in Fig. 8
                            as landmarks, depth information within the silhouette can be captured. Depth Matrix can be formed by associating the depth D(x, y) in the cell M(i, j). It describes hand postures through the depth associated with landmark points. To capture the details in convex area, subdivision strategy is applied on depth silhouettes too. The key idea is to compute the incremental radial distances during each pass of the shape matrix algorithm [15]. The incremental radial distance with subdivision strategy is redefined as

                              
                                 (21)
                                 
                                    
                                       
                                          r
                                          
                                             i
                                             n
                                             c
                                          
                                       
                                       =
                                       
                                          
                                             R
                                             (
                                             i
                                             −
                                             1
                                             )
                                          
                                          n
                                       
                                       +
                                       
                                          
                                             R
                                             k
                                          
                                          
                                             n
                                             i
                                          
                                       
                                       ,
                                    
                                 
                              
                           where 1 ≤ i ≤ n and 1 ≤ k ≤ i.

Cartesian coordinates corresponding to log-polar coordinates of the intersection points, generated during execution of the algorithm, can be obtained as 
                              
                                 x
                                 =
                                 
                                    r
                                    
                                       i
                                       n
                                       c
                                    
                                 
                                 cos
                                 θ
                              
                            and 
                              
                                 y
                                 =
                                 
                                    r
                                    
                                       i
                                       n
                                       c
                                    
                                 
                                 sin
                                 θ
                                 ,
                              
                            where θ is the normalized angle. Depth matrix needs to be normalized with the maximum depth before using it as a feature. If a subdivision variant of original binary shape matrix is to be obtained, only the presence of point (x, y) in the posture region needs to be detected and corresponding cell M(i, j) is set accordingly. As, only intersection points of concentric circles are traced during the execution, the depth of the centroid is appended separately to the feature string.

Two shapes can be matched for similarity by the means of cell centric XOR operations using Eqs. 4 and 5. If both shapes have 
                        
                           M
                           (
                           i
                           ,
                           j
                           )
                           =
                           1
                        
                      or 
                        
                           M
                           
                              (
                              i
                              ,
                              j
                              )
                           
                           =
                           0
                           ,
                           ∀
                           
                              (
                              i
                              ,
                              j
                              )
                           
                           ,
                        
                      the result of cumulative XOR would be 0 for M. Thus, more the number of matches, similar will be the shapes. To conduct matching, a model shape matrix for each class must be available for comparison with the query shape. S can now be redefined as

                        
                           (22)
                           
                              
                                 S
                                 =
                                 
                                    ∑
                                    
                                       i
                                       =
                                       1
                                    
                                    
                                       n
                                       −
                                       1
                                    
                                 
                                 
                                    ∑
                                    
                                       j
                                       =
                                       1
                                    
                                    
                                       n
                                       −
                                       1
                                    
                                 
                                 
                                    |
                                    
                                       M
                                       1
                                    
                                    
                                       (
                                       i
                                       ,
                                       j
                                       )
                                    
                                    −
                                    
                                       M
                                       2
                                    
                                    
                                       (
                                       i
                                       ,
                                       j
                                       )
                                    
                                    |
                                 
                                 .
                              
                           
                        
                     and matching can be performed using Eq. 5.

Linear matching is appropriate when an ideal prototype is available for each shape class and the number of candidate classes is small. However, articulations generate a number of possible prototypes and selection of a single class representative is difficult. If several prototypes are employed and the number of shape classes is large, matching would be complex in time. This scenario is prevalent in hand posture recognition problems where the system needs to be trained on multiple prototypes of the same kind of posture. Clearly, M needs to be interpreted as a feature vector for classification with maximum possible separation among individual dimensions while keeping the size of descriptor sufficiently small. Different approaches are possible to interpret shape matrix as a descriptor. If each cell M(i, j) is used to describe a posture, dimension of the descriptor would be m × n. The feature vector would then be a concatenated sequence of M(i, j) either in a row or column.

In another description, the number of radial sections that shape contours pass through in a polar section i; 
                        
                           i
                           ∈
                           0
                           ,
                           1
                           ,
                           …
                           ,
                           m
                           −
                           1
                        
                      can be investigated. This descriptor of length m can be expressed as 
                        
                           
                              F
                              θ
                           
                           =
                           
                              [
                              
                                 F
                                 1
                                 θ
                              
                              ,
                              
                                 F
                                 2
                                 θ
                              
                              ,
                              …
                              ,
                              
                                 F
                                 m
                                 θ
                              
                              ]
                           
                        
                      where 
                        
                           
                              F
                              i
                              θ
                           
                           =
                           
                              ∑
                              
                                 j
                                 =
                                 1
                              
                              n
                           
                           M
                           
                              (
                              i
                              ,
                              j
                              )
                           
                           
                              where
                           
                           1
                           ≤
                           i
                           ≤
                           m
                        
                     . Alternatively, the number of polar sections through which shape contours pass in radial section j; 
                        
                           j
                           ∈
                           0
                           ,
                           1
                           ,
                           …
                           ,
                           n
                           −
                           1
                        
                      can be examined (
                        
                           
                              F
                              r
                           
                           =
                           
                              [
                              
                                 F
                                 1
                                 r
                              
                              ,
                              
                                 F
                                 2
                                 r
                              
                              ,
                              …
                              ,
                              
                                 F
                                 m
                                 r
                              
                              ]
                           
                        
                     ). Fθ
                      and Fr
                      can be combined to form a 
                        
                           m
                           +
                           n
                        
                      sized descriptor. Still, the size of m × n descriptor is sufficiently smaller than other peer features [7,26,29,33,37] and hence employed for the experiments in this work.

To verify the strength of the proposed features, three different datasets are evaluated. ASL dataset contains over 500 pairs of color and depth frames for each alphabet collected from 5 subjects. The extent of in-plane and out-of-plane rotation variation in articulations is moderate. Forearm exposure is also variable with no apparent clues given for the palm separation. Pre-segmented depth frames deliver ROIs. NTU dataset comprises of 1000 fingercount postures for digits 0 to 9 collected from 10 subjects in color and depth frames. A clue to separate the palm from forearm section is given in a black strip on the wrist. Sample depth silhouettes for ASL and NTU dataset postures are shown in Fig. 9
                        .
                     

The ISL dataset customized in this work for fingersign postures comprises of 13000 pairs of color and depth frames. Postures are collected from 10 subjects of both genders giving 500 articulations for each alphabet. Posture instances involve moderate in-plane and out-of-plane rotations and no clues are given for palm separation (Fig. 10
                        ). For each subject, a 150 frames long depth sequence is recorded with a lag of 2 frames out of which 50 distinct depth silhouettes are extracted per sign. In the 50 articulations collected for each sign, different levels of forearm exposure are incorporated by interactively adjusting the depth levels in the depth maps through a GUI. While the forearm exposure level is already variable in ASL articulations, NTU instances are manipulated to generate a secondary dataset with multiple forearm exposure levels for each posture. Doing so checks the viability of the proposed descriptors against abruptly appearing hand regions in the articulation region. Two additional articulatory forms of alphabets ‘E’ and ‘F’ are included in the dataset while postures for ‘J’ and ‘I’ are alternates for their dynamic counterparts (Fig. 1). As alphabets ‘C’ and ‘U’ have similar articulations with orthogonal orientations, posture for ‘U’ is omitted from training and evaluation. However, when required, an orientation feature can distinguish between the two samples. MATLAB R2013a is used on Windows-7 platform for implementation.

To begin with, experiments are conducted on ISL dataset to determine better performers among region, contour and depth descriptor categories. Region based (2D) descriptors are original shape matrix SMo
                         and shape matrix with subdivisions SMos
                        . Contour based descriptors are binary shape matrix with SMcs
                         and without subdivisions SMc
                        , shape matrix with contour point distance (log-polar signature) SM
                        
                           cd1, and shape matrix with local displacement SM
                        
                           cd2. The only depth-based descriptor is depth matrix SMoz
                        . All four reference vector candidates; axis of least inertia (ALI), major axis (MA), maximum radius (MR), and principal axis (PA) are employed in the experiments. ASL and NTU datasets are then evaluated with the best option in each descriptor category. Experiments are conducted on each dataset for m × n sized descriptors. The information in shape matrix variants is highly correlated. A de-correlation on feature vectors is avoided to discard an additional computation overhead. A distance based classifier like kNN is a good option as the approach is inherently simple, and effective if decision boundaries are non-linear. kNN classifies a test pattern to the most voted group amongst its k nearest neighbor patterns, where k is a small positive integer. In the training phase, the descriptors are associated with their class labels and stored in the training set with no computation overheads. At the time of classification, k nearest patterns are selected from the training set on the basis of closest distance to the test posture. Optimal k is estimated by iterating the voting procedure for various values of k. Number of training samples in each class are kept similar to avoid the skew.
                     

Dataset is divided equally by including alternate instances in the training and testing sets. Circular grid size is varied in steps for each of SMo, SMos, SMc, SMcs, SM
                        
                           cd1, SM
                        
                           cd2, and SMoz
                        . Experiments are repeated for each reference vector ALI, MJA, MR, and PA. Classification response for all shape matrix variants on varying circular grid sizes of the form m × n is shown in Table 1. With ALI and MA reference vectors, recognition performance consistently suffers for all SM variants. While both MR and PA improve the performance, PA performs still better. Performance degradation due to loss of information in region variants SMo, SMos
                         is also evident from the table. Still, SMos
                         does better than SMo
                         due to calibrated subdivisions. Broadly, contour variants perform better than region variants with SM
                        
                           cd1 doing the best. As no region (2D) or contour variant could capture the assimilated 3D information, depth matrix SMoz
                         performs the best amongst all. Yet, the performance of SMoz
                         is not distinctly better as it tries to capture the depth at discrete intersection points and misses nearby salient depth values, occasionally. Having performed better in their categories, SMos, SM
                        
                           cd1, and SMoz
                         are employed in experiments on ASL and NTU datasets with MR and PA as reference vectors.

Shape context [37] is used as a benchmark for contour representations, and Gabor filter [16,29,40] is employed for processing depth silhouettes. Performance of SM
                        
                           cd1 and SMoz
                         is compared with these two. Evaluation on shape context feature is carried out with and without bending costs. As per Pedersoli et al. [29], cropped depth silhouettes are resized to a constant rectangular grid and convolved with a Gabor filter bank of four scales 
                           
                              s
                              =
                              
                                 1
                                 2
                              
                              ,
                              
                                 1
                                 4
                              
                              ,
                              
                                 1
                                 8
                              
                              ,
                              
                                 1
                                 16
                              
                           
                         and four orientations 
                           
                              θ
                              =
                              0
                              ,
                              
                                 π
                                 4
                              
                              ,
                              
                                 π
                                 2
                              
                              ,
                              
                                 
                                    3
                                    π
                                 
                                 4
                              
                           
                        . Feature vectors are then classified using SVM with the radial basis function kernel. Table 2 shows comparative performance of benchmark methods, SM
                        
                           cd1, and SMoz
                         along with mean running time for each scheme. A comparison on individual ISL alphabet recognition using the evaluated schemes is shown in Fig. 11
                        . Performance of both, Shape context and Gabor filter features suffered due to the extended levels of forearm exposure in the ISL dataset. Slight noise or distortion present on the contour is another probable reason for under-performance of contour based methods. On the basis of mean running time, shape context is discarded for live implementations while Gabor feature comes close to required constraints. Performance of SMoz
                        , 94.15% and 0.029 s, makes it more suitable for live implementation.

To understand the efficacy of each feature in interpretation of the most confusing ISL dataset signs, partial confusion matrices in Table 3
                         can be referred. Posture sets ‘D’, ‘K’, ‘P’, ‘Q’ and ‘M’, ‘N’, ‘R’, ‘S’ assimilate outline and regional confusions, respectively. Shape Context feature could not distinguish contour confusions among ‘D’, ‘K’, and ‘P’ efficiently. Accuracy of ‘Q’ and ‘P’, however, reaches close to 85%. SM
                        
                           cd1 is better in contour discrimination, especially in ‘K’, ‘P’, and ‘Q’ where accuracy reaches above 90%. Both, shape context and SM
                        
                           cd1, naturally struggle to distinguish among ‘M’, ‘N’, ‘R’, and ‘S’. Gabor features are 90% accurate to interpret 3D information contained in the depth silhouettes of ‘M’, ‘N’, ‘R’, and ‘S’. SMoz
                         captures depth information slightly better than Gabor filter in addition to efficient capturing of outlines in ‘D’, ‘K’, ‘P’, and ‘Q’.

Recognition behavior of shape matrix variants is also characterized by the number of sections in the log-polar grid. Fig. 12
                         illustrates the effect of m × n grid size variation on recognition accuracy of SMos, SM
                        
                           cd1, and SMoz
                         descriptors with PA reference vector. Stagnation or decline of the accuracy after a specific grid size is evident from the figure. The optimal grid size varies from one dataset to another and from one variant to the other. On ISL dataset, SM
                        
                           cd1 and SMoz
                         acquire maximum accuracy on 16 × 10 sized grid, while 16 × 15 is a suitable grid size for SMos
                        . Similarly, on ASL dataset the highest accuracy is obtained at the grid size of 20 × 15. For wrist cropped samples of NTU dataset, 16 × 10 grid gives better results while samples with exposed forearms of the same dataset are recognized best at 20 × 15 sized grid. Slightly better responses are observed with deliberate increase in the grid size, yet the proposed work restricts itself to a maximum grid size of 20 × 15.

Depth silhouettes extracted from ASL and NTU datasets are equally divided into the training and testing sets. Experiments are iterated for varying grid sizes on SMos, SM
                        
                           cd1, and SMoz
                         features with MR and PA reference vectors. Black band on the wrist and depth threshold are used to detect palm portion in depth frames of NTU dataset. Additionally, NTU dataset is further customized to include varying exposure levels of the forearm. Thus, experiments for NTU hand digits are conducted on two different hand digit datasets. The results obtained by shape matrix variants for both, ASL and NTU datasets, are given in Table 4
                        . Contour based SM
                        
                           cd1 could capture 89.22% depth information interleaved in ASL postures.SMoz
                         performs better to retrieve and interpret depth information with 91.86% accuracy. Table 5
                         shows comparative performances of SM
                        
                           cd1 and SMoz
                         against other techniques evaluated on ASL and NTU datasets. To compare the results on ASL dataset, work by Pedersoli et al. [29] is referred which computes accuracies using Gabor filter with random forest [16,46] and SVM classifiers. SMoz
                         slightly surpasses the performance of Gabor filter + SVM combination by 1.2%. In Fig. 13
                         recognition accuracy achieved by Gabor features and shape matrix variants is shown for individual postures of the ASL dataset. SMoz
                         which supersedes other schemes, obtains more consistent performances for alphabets ‘f’, ‘i’, ‘w’, and ‘y’, while its performance suffers in the recognition of ‘m’, ‘p’, and ‘s’. Nevertheless, the mean running times offered by SM
                        
                           cd1 and SMoz
                         make them deployable in live ASL fingerspelling recognition.

Referring again to Table 4 for NTU dataset reflects that SMoz
                         achieves 94.2 and 92.5% success on wrist cropped and extended forearm datasets, respectively. On the same versions of NTU dataset, SM
                        
                           cd1 performs fairly with 95.11 and 92.88% accuracies, respectively. It is important to notice 92.88% performance of SM
                        
                           cd1 descriptor on extended forearm samples which suggests the possible recognition of NTU hand digits through stretched contours. Comparative analysis on NTU dataset in Table 5 reveals that SM
                        
                           cd1, which offers 95.11% accuracy, surpasses the recognition performance of shape context and Near-convex Decomposition + FEMD [17] features. Comparison on individual hand digits of NTU dataset is given in Fig. 14
                        . SM
                        
                           cd1 also offers lesser average computation time of 0.0483 s.


                        Table 6
                         shows confusion matrices for evaluation of wrist cropped and forearm extended NTU datasets with SM
                        
                           cd1 descriptor. No serious confusions are observed on wrist cropped NTU dataset except slight inferior performance on digit postures ‘4’, ‘6’, and ‘9’ each of which is recognized 92, 90, and 92% times, respectively. Recognition of digits ‘1’ and ‘2’ is quite consistent. On extended forearm dataset, recognition of ‘6’ highly suffers while performance goes a little inferior for digits ‘0’, ‘4’, ‘5’, ‘8’, and ‘9’. Here also, ‘1’ and ‘2’ are recognized consistently.

To verify the subject independent performance of the proposed schemes, two strategies; leave-one-subject-out and random half-split are experimented. In the latter, posture instances of ⌊N/2⌋ subjects are used in the training and instances of the remaining 
                           
                              N
                              −
                              ⌊
                              (
                              N
                              /
                              2
                              )
                              ⌋
                           
                         subjects are used for testing. Though, subject combinations would be numerous with increased number of users, four combinations (sequential and alternate half-splits with flipped roles) are selected for training and testing sets, and performance is averaged. The later test is more prohibitive, but still conducted for observational purpose.

With leave-one-subject-out, SM
                        
                           cd1 obtains 69.14, 90.75, and 87.5% accuracy on ASL, NTU, and ISL datasets, respectively. On the same datasets, SMoz
                         acquires 71.58, 89.6, and 89.12% accuracies. The performance of SM
                        
                           cd1 and SMoz
                         on ASL dataset surpasses the performance of Gabor filter combinations with random forest (49%) [16] and SVM (56%) [29]. In the second test, accuracies obtained by SM
                        
                           cd1 and SMoz
                         on ASL, NTU, and ISL datasets are 59, 85.1, 84.5%, and 63.72, 85.5, 86.28%, respectively.

Automated posture recognition, being a real-time application, requires a descriptor with immediate response. Though, original shape matrix underperforms as compared to other modified variants, produces faster results due to its running time of mn, where m and n are polar and radial divisions, respectively. Its subdivision versions in region and depth, SMos
                         and SMoz
                        , are also O(mn) complex. Thus, region based shape matrices are faster than their contour based counterparts which are O(N) complex. Here, N is the number of points on the contour and mn < N. In practice, O(N) descriptors are hardly seen. Space complexity remains almost the same for region (or depth) and contour based variants.

With depth sensing arrangement, the size of a distinguishable hand blob (in pixels) is at most 1/5 of the entire image area (signer beyond 50 cm, facing the depth sensor). Further, the contour length is on an average 1/3 of the ROI. For a lag-free recognition experience, the mean running time (descriptor generation + classification) must make the recognition process indiscernible to the observer. If 15–20 frames/s rate is considered indiscernible to the observer, mean running time must not exceed 0.067 s. Mean running time for all cascaded operations, beginning from depth frame acquisition up to the classification, is measured over 500 articulations in depth images of size 320 × 240 on two different configuration machines. The average time taken for each interleaved operation in the recognition process is given in Table 7
                         along with the overall time taken. Measured time is displayed for SMos
                         and SM
                        
                           cd1 variants on 16 × 10 circular grid.

Eventually, SM
                        
                           cd1 takes the maximum time within all variants. On a 2.2 GHz, 3 GB memory machine (Configuration 1), the processing rate achieved varies between 17 operations/sec (SM
                        
                           cd1) to 34 operations/sec (SMos
                        ). On the other hand, a 3 GHz dual core processor, 8 GB memory machine (Configuration 2) obtains a processing rate between 37 operations/sec (SM
                        
                           cd1) to 80 operations/sec(SMos
                        ). Processing rates are compatible enough to meet the requirements of live systems.

The worth of region, contour, and depth based variants of the shape matrix is verified as recognition accuracy above 90% is achieved on all datasets for each variant. The results on ISL dataset show that application of subdivision strategy on all variants with the principal axis as reference vector improves the recognition accuracy. Among the four reference vector candidates, recognition performance suffers the most with the axis of least inertia while the results with the major axis are also not encouraging. However, the performance with maximum radius reference vector comes close to that of principal axis on all datasets. It is observed through visual inspection that symmetric fingersigns, like ISL alphabets ‘A’, ‘B’, and ‘X’, generate two maximum radius candidates (as shown in Fig. 3(b)). If the instances with different maximum radius lines for the same sign are treated as samples belonging to two different classes, recognition accuracy can be improved. When it comes to extract the implicit depth information, the most efficient variant is SMoz
                        , which outperforms other variants on ISL and ASL datasets. In case of NTU dataset, the contour based variant SM
                        
                           cd1 performs the best. When compared to the shape context and Gabor features on ISL dataset, shape matrix (both SM
                        
                           cd1 and SMoz
                        ) performs better. In comparison to Gabor feature results evaluated using SVM by Pedersoli [29] on ASL dataset, SMoz
                         does slightly better. However, accuracy of contour based SM
                        
                           cd1 suffers on ASL dataset due to the lack of depth information.

The only depth based descriptor, SMoz
                        , employs a 2D reference vector to normalize rotations. If articulations are tilted out of the plane, recognition accuracy is bound to suffer. This is the reason why its accuracy suffers in comparison to 3D features proposed by Keskin et al. [46], and Zhang et al. [47]. Nevertheless, all shape matrix variants outperform above mentioned features in temporal efficiency. To summarize, the proposed shape matrix variants find better trade-off between accuracy of recognition and running time, and hence can be deployed in live environments.

@&#CONCLUSIONS@&#

A framework to recognize one-handed and two-handed fingerspelling postures is developed in this manuscript. As the motive is to complete the task within deadlines of live systems, modified variants of the shape matrix are introduced with demonstrated short running times while giving adequate recognition performance. The experiments reveal that shape matrix variants are sufficiently robust to in-plane rotations, scales, and translations. Apart from region and contour SM variants (SMos, SMc, SMcs, SM
                     
                        cd1, SM
                     
                        cd2), a depth shape matrix variant (SMoz
                     ) is also introduced to capture implicit 3D information in silhouettes like ridges and pits. Application of principal axis as reference vector and radial subdivision strategy enables SMos, SM
                     
                        cd1, SM
                     
                        cd2, and SMoz
                      to extract subtle posture details. Depth based acquisition of hand gestures mitigates the effects of ill segmentation usually faced with 2D cameras. In the correct classification of the highly correlated shape matrix features, simple yet effective kNN strategy plays an important role. To consolidate the claims on the accuracy and running time, apart from two-handed ISL fingerspelling dataset, experiments are also conducted on the one-handed ASL fingerspelling and NTU hand digits dataset. Recognition accuracy delivered by the proposed individual descriptors without association of any other feature is noticeable.

In order to abide by the strict deadlines, several assumptions are made in which appearance of the ROI closest to the depth sensor is primary. To convert the presented framework into a full-fledged hand posture recognition system, a number of issues including the detection of ROI in generalized depths (with clues in skin color and depth textures), tracking and recognition of postures on disconnected hand blobs, invariance to out-of-plane rotations need to be addressed. Further, in order to recognize dynamic gestures, a multi-state probabilistic model like HMM or DTW (Dynamic Time Warping) needs to be employed.

Supplementary material associated with this article can be found, in the online version, at 10.1016/j.cviu.2015.08.001
                  


                     
                        
                           
                        
                     
                  


                     
                        
                           
                        
                     
                  

@&#REFERENCES@&#

