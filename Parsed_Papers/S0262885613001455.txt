@&#MAIN-TITLE@&#Extended Topological Active Nets

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           ETANs overcome the limitations of TANs while keeping their promising features.


                        
                        
                           
                           ETANs combine the best capabilities of two DMs, TANs and EVFC snakes.


                        
                        
                           
                           ETANs employ novel mechanisms to tackle topological changes, as link cuts and holes.


                        
                        
                           
                           ETANs employ node movement constraints to avoid crossing links.


                        
                        
                           
                           ETANs employ a new local search procedure and a new automatic pre-processing phase.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Deformable models

Active contours

Snakes

Level sets

Chan and Vese

Geodesic Active Contours

Active nets

Topological Active Nets

Extended Topological Active Nets

Local search optimization

External force

Gradient Vector Flow

Vector Field Convolution

@&#ABSTRACT@&#


               
               
                  Topological Active Nets are promising parametric deformable models that integrate features of region-based and boundary-based segmentation techniques. Problems associated with the complexity of the model, however, have limited their utility. This paper introduces an extension of the model, defining a new behavior for changing its topology, as well as a novel external force definition and a new local search optimization procedure. In particular, we propose a new automatic pre-processing phase, a new external energy term based on the Extended Vector Field Convolution, node movement constraints to avoid crossing links, and different procedures to perform link cuts and hole detection. Moreover, the new local search procedure also incorporates heuristics to correct the position of eventually misplaced nodes. The proposal has been tested on 18 synthetic images which present different segmentation difficulties along with 3 real medical images. Its performance has been compared with that of the original Topological Active Net optimization approach along with both state-of-the-art parametric and geometric active contours: two snakes (based on Gradient Vector Flow and Vector Field Convolution), and two level sets (Chan and Vese, and Geodesic Active Contour). Our new method outperforms all the others for the given image sets, in terms of segmentation accuracy measured by using four standard segmentation metrics.
               
            

@&#INTRODUCTION@&#

Deformable models [1] (DMs) are a promising and vigorously researched computer-assisted image segmentation technique. They have proven to be effective in segmenting digital images by exploiting features of the image data together with a priori knowledge about the structures of these images. Since the pioneering work of Kass et al. [2], a number of different kinds of deformable models have been proposed. They can be described by two different paradigms: parametric deformable models, which represent curves and surfaces explicitly in their parametric forms during deformation, and geometric deformable models, which represent curves and surfaces implicitly as level sets of a higher-dimensional scalar function [3]. There has been some discussion in the area to determine which of the two DM families provides better performance. However, experimental studies like [4] have shown that, as there are significant differences in the model principles, complexity and capabilities, this decision depends on the specific application tackled. In fact, it is said that existing DM methods are not mutually exclusive and that the proposal of new approaches combining features from different kinds of methods is a promising research line.

Among parametric DMs, the active net model is a discrete implementation of an elastic mesh with interrelated nodes [5]. It integrates features of region-based and boundary-based [6] segmentation techniques that could potentially lead to better segmentation results than those DMs based only on boundary information [4]. To this end, active nets distinguish two kinds of nodes: internal nodes, related to the region-based information, and external nodes, related to the boundary-based information. Since the model deformation is controlled by an energy functional in such a way that the mesh reaches a minimum when the model is over the objects, the segmentation process is tackled as a numerical optimization problem.

The Topological Active Net (TAN) model was developed as an extension of the original active net model [7,8]. It solves some intrinsic problems of deformable models such as the initialization problem. In addition, a TAN has a dynamic behavior that allows topological local changes to be performed in order to achieve accurate adjustments and to find all the objects of interest in the scene.

The advantage of this model is the capability of fitting the edges of the objects while at the same time detecting their inner topology. Given the dual nature of the nodes, the generic active net model can be easily customized to the specific segmentation problem by incorporating prior knowledge (such as texture, shape, or color information) [9]. Potential applications of TAN's special properties have not been explored yet. However, they have already been applied to different problems such as iris location [9], road sign detection [10], stereo matching [11], and segmentation of different structures in medical images [5,8,12] with successful results.

Despite the promising features of TANs, the complexity of the model and the difficult optimization task inherent to the segmentation process have limited their utility. In fact, only a few works [10,12–15] dealing with TANs have been developed during the last ten years. In addition, those works have mainly focused on the proposal of global optimization techniques without providing solutions to the main TAN drawbacks and limitations: topological changes, external energy definition, and local deformations.

In this paper, an Extended Topological Active Net (ETAN) model is presented. It aims at overcoming the limitations of TANs while keeping their promising features. Here, rather than introducing a model ready to be applied to a broad range of real world problems, we intend to provide a proof of concept to revive interest in a type of deformable model that did not receive much focus from the scientific community in the last few years. To do so, we combined the best capabilities of two different kinds of DMs, TANs and Extended Vector Field Convolution snakes [16,17], as well as we have designed some specific components. In particular, we have developed novel mechanisms tackling topological changes including external and internal link cuts, we propose a new external energy term to properly guide the model in the case of complex concavities and highly non-convex shapes, we introduce node movement constraints to avoid crossing links, and we design a new local search procedure including heuristics to correct the position of eventually misplaced nodes. Moreover, a new automatic pre-processing phase is employed.

The proposed model will be tested over eighteen synthetic images categorized in six groups and three different levels of difficulty. The new model will be compared with the one designed by Ansia et al. [8] (also based on a local optimization of the TAN), including minor changes in the external energy term by Ibáñez et al. [13]. Besides, in order to increase the soundness of the experimental test and to show the advantages and disadvantages of ETANs for image segmentation, we also include widely employed parametric and geometric deformable models in the comparison. On the one hand, we compare against the Gradient Vector Flow (GVF) [18] and Vector Field Convolution (VFC) snake models [16], on the other hand, against the Chan and Vese (CaV) [19] and Geodesic Active Contour (GAC) [20] level set models.

The two snake models could be considered the state-of-the-art parametric deformable models. While the former is the most extended parametric model the latter has been recently proven to outperform it in several scenarios [16]. The CaV level set model can detect objects whose boundaries are not necessarily defined by the gradient as the level sets minimize an energy which can be seen as a particular case of the minimal partition problem. Finally, the GAC is based on the relation between active contours and the computation of geodesics or minimal distance curves.

The structure of this paper is the following: Section 2 introduces the TAN model and summarizes both the GVF- and VFC-snakes, as some of their components will be used in the ETAN design. Section 3 describes the proposed ETAN model, Section 4 explains the ETAN optimization process while Section 5 deals with some complementary tasks. Section 6 is devoted to the evaluation of the performance of our proposal and comparison with other methods. Finally, Section 7 summarizes some conclusions and future developments.

@&#BACKGROUND@&#

A TAN is a discrete implementation of an elastic two/dimensional mesh with interrelated nodes [5]. The structure of a small TAN is depicted in Fig. 1
                        . As this figure shows, the model has two kinds of nodes: internal and external. Each kind of node represents different features of the objects: the external nodes fit the edges of the objects whereas the internal nodes model the internal topology of the object. Therefore, this model allows information based on discontinuities and information based on regions to be integrated in the segmentation process. The former is associated to external nodes and the latter to internal nodes.

A TAN is defined parametrically as v(r,s)=(x(r,s), y(r,s)) where (r,s)∈([0,1]×[0,1]). The mesh deformations are controlled by an energy functional defined as follows:
                           
                              
                                 
                                    E
                                    
                                       
                                          v
                                          
                                             r
                                             s
                                          
                                       
                                    
                                    =
                                    
                                       
                                          ∫
                                          0
                                          1
                                       
                                       
                                          
                                             
                                                ∫
                                                0
                                                1
                                             
                                             
                                                
                                                   
                                                      
                                                         E
                                                         int
                                                      
                                                      
                                                         
                                                            v
                                                            
                                                               r
                                                               s
                                                            
                                                         
                                                      
                                                      +
                                                      
                                                         E
                                                         ext
                                                      
                                                      
                                                         
                                                            v
                                                            
                                                               r
                                                               s
                                                            
                                                         
                                                      
                                                   
                                                
                                                drds
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where E
                        int and E
                        ext are the internal and the external energies of the TAN, respectively. The internal energy controls the shape and the structure of the mesh whereas the external energy represents the external forces which govern the adjustment process.

The internal energy depends on the first and second order derivatives which control contraction and bending, respectively. The internal energy term is defined by the following equation:
                           
                              
                                 
                                    
                                       E
                                       int
                                    
                                    
                                       
                                          v
                                          
                                             r
                                             s
                                          
                                       
                                    
                                    =
                                    α
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      v
                                                      r
                                                   
                                                   
                                                      r
                                                      s
                                                   
                                                
                                             
                                             2
                                          
                                          +
                                          
                                             
                                                
                                                   
                                                      v
                                                      s
                                                   
                                                   
                                                      r
                                                      s
                                                   
                                                
                                             
                                             2
                                          
                                       
                                    
                                    +
                                    β
                                    
                                       
                                          
                                             
                                                
                                                   v
                                                   rr
                                                
                                                
                                                   r
                                                   s
                                                
                                             
                                          
                                          2
                                       
                                    
                                    +
                                    
                                       
                                          
                                             
                                                v
                                                rs
                                             
                                             
                                                r
                                                s
                                             
                                          
                                       
                                       2
                                    
                                    +
                                    
                                       
                                          
                                             
                                                
                                                   v
                                                   ss
                                                
                                                
                                                   r
                                                   s
                                                
                                             
                                          
                                          2
                                       
                                    
                                 
                              
                           
                        where subscripts represent partial derivatives, and α and β are coefficients that control the first and second order smoothness of the net. In order to calculate the energy, the parameter domain [0,1]×[0,1] is discretized as a regular grid defined by the internode spacing (k,l) and the first and second derivatives are estimated using the finite difference technique. More details about the calculation of the terms of the previous equation are shown in [8].

The external energy represents the features of the scene that guide the adjustment process. It is defined by the following equation:
                           
                              
                                 
                                    
                                       E
                                       ext
                                    
                                    
                                       
                                          v
                                          
                                             r
                                             s
                                          
                                       
                                    
                                    =
                                    ωf
                                    
                                       
                                          I
                                          
                                             
                                                v
                                                
                                                   r
                                                   s
                                                
                                             
                                          
                                       
                                    
                                    +
                                    
                                       ρ
                                       
                                          
                                             ℵ
                                             
                                                r
                                                s
                                             
                                          
                                       
                                    
                                    
                                       
                                          ∑
                                          
                                             p
                                             ∈
                                             ℵ
                                             
                                                r
                                                s
                                             
                                          
                                       
                                       
                                          
                                             1
                                             
                                                
                                                   v
                                                   
                                                      r
                                                      s
                                                   
                                                   −
                                                   v
                                                   
                                                      p
                                                   
                                                
                                             
                                          
                                       
                                    
                                    f
                                    
                                       
                                          I
                                          
                                             
                                                v
                                                
                                                   p
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where ω and ρ are weights, I(v(r,s)) is the intensity value of the original image in position v(r,s), ℵ(r,s) is the neighborhood of node (r,s) and f is a functional, which is different for both types of nodes since the external nodes fit the edges whereas the internal nodes model the inner features of the objects. If the objects to detect are dark and the background is bright, the energy of an internal node will be minimum when it is on a point with a low gray level. On the other hand, the energy of an external node will be minimum when it is on a discontinuity and on a light point outside the object. In this situation, functional f is defined as:
                           
                              
                                 
                                    f
                                    
                                       
                                          I
                                          
                                             
                                                v
                                                
                                                   r
                                                   s
                                                
                                             
                                          
                                       
                                    
                                    =
                                    
                                       
                                          
                                             
                                                h
                                                
                                                   
                                                      
                                                         I
                                                         
                                                            
                                                               
                                                                  v
                                                                  
                                                                     r
                                                                     s
                                                                  
                                                               
                                                            
                                                            n
                                                         
                                                      
                                                      ¯
                                                   
                                                
                                                ,
                                             
                                             
                                                for
                                                
                                                internal
                                                
                                                nodes
                                             
                                          
                                          
                                             
                                                h
                                                
                                                   
                                                      
                                                         I
                                                         max
                                                      
                                                      −
                                                      
                                                         
                                                            I
                                                            
                                                               
                                                                  
                                                                     v
                                                                     
                                                                        r
                                                                        s
                                                                     
                                                                  
                                                               
                                                               n
                                                            
                                                         
                                                         ¯
                                                      
                                                      +
                                                      ξ
                                                      
                                                         
                                                            
                                                               G
                                                               max
                                                            
                                                            −
                                                            G
                                                            
                                                               
                                                                  v
                                                                  
                                                                     r
                                                                     s
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                                +
                                                δGD
                                                
                                                   
                                                      v
                                                      
                                                         r
                                                         s
                                                      
                                                   
                                                
                                                ,
                                             
                                             
                                                for
                                                
                                                external
                                                
                                                nodes
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where ξ and δ are weighting terms, I
                        max and G
                        max are the maximum intensity values of image I and the gradient image G, respectively, I(v(r,s)) and G(v(r,s)) are the intensity values of the original image and the gradient image in node position v(r,s), I(v(r,s))
                           n
                         is the mean intensity in a n
                        ×
                        n square mask and h is an appropriate scaling function. Since the work of Ibáñez et al. [13] the external energy also includes the gradient distance term, GD(v(r,s)), which is, the distance from the position v(r,s) to the nearest edge. This term introduces a continuous range in the external energy since its value diminishes as the node gets closer to an edge.

The adjustment process consists of minimizing these energy functions. In the TAN proposal [8], the mesh is placed over the whole image and, then, the energy of each node is minimized using a best improvement local search (BILS) algorithm (called greedy search in those previous papers). In each step of the algorithm, the energy of each node is computed in its current position and in its nearest neighborhood. The position with the lowest energy value is selected as the new position of the node. The algorithm stops when there is no node in the mesh that can move to a position with lower energy.

The traditional external force is derived from the edge map f(x,y) calculated on the image I(x,y) and having the property that it shows larger values near the image edges. This edge map has three important properties. First, its gradient ∇f has vectors pointing toward the edges, which are normal to the edges at the edges. Second, these vectors generally have large magnitudes only in the immediate vicinity of the edges. Third, in homogeneous regions, where I(x,y) is nearly constant, ∇f is nearly zero. While the first property is desirable, the last two are not because the capture range will be very small and homogeneous regions will have no external forces whatsoever.

In [18], Xu and Prince developed a new external force for active contours to solve the problems associated with initialization and poor convergence to concave boundaries.

They defined the GVF as the vector field
                           
                              
                                 
                                    v
                                    
                                       x
                                       y
                                    
                                    =
                                    
                                       
                                          u
                                          
                                             x
                                             y
                                          
                                          ,
                                          v
                                          
                                             x
                                             y
                                          
                                       
                                    
                                 
                              
                           
                        that minimizes the energy functional
                           
                              
                                 
                                    E
                                    =
                                    
                                       ∬
                                       
                                          
                                             
                                                μ
                                                
                                                   
                                                      
                                                         u
                                                         x
                                                         2
                                                      
                                                      +
                                                      
                                                         u
                                                         y
                                                         2
                                                      
                                                      +
                                                      
                                                         v
                                                         x
                                                         2
                                                      
                                                      +
                                                      
                                                         v
                                                         y
                                                         2
                                                      
                                                   
                                                
                                                +
                                                
                                                   
                                                      
                                                         ∇
                                                         f
                                                      
                                                   
                                                   2
                                                
                                                
                                                   
                                                      
                                                         v
                                                         −
                                                         ∇
                                                         f
                                                      
                                                   
                                                   2
                                                
                                             
                                          
                                          dxdy
                                       
                                    
                                    .
                                 
                              
                           
                        
                     

This variational formulation makes the result smooth when there is no data and keeps v nearly equal to the gradient of the edge map when it is large, but forcing the field to be slowly-varying in homogeneous regions. The parameter μ is a regularization parameter governing the trade-off between the first and second terms in the integrand and should be set according to the amount of noise present in the image.

Using the calculus of variations 
                        [21] it can be shown that the GVF field can be found by solving the following Euler equations
                           
                              
                                 
                                    
                                       
                                          μ
                                          
                                             ∇
                                             2
                                          
                                          u
                                          −
                                          
                                             
                                                u
                                                −
                                                
                                                   f
                                                   x
                                                
                                             
                                          
                                          
                                             
                                                
                                                   f
                                                   x
                                                   2
                                                
                                                +
                                                
                                                   f
                                                   y
                                                   2
                                                
                                             
                                          
                                          =
                                          0
                                          ,
                                       
                                       
                                          μ
                                          
                                             ∇
                                             2
                                          
                                          v
                                          −
                                          
                                             
                                                v
                                                −
                                                
                                                   f
                                                   y
                                                
                                             
                                          
                                          
                                             
                                                
                                                   f
                                                   x
                                                   2
                                                
                                                +
                                                
                                                   f
                                                   y
                                                   2
                                                
                                             
                                          
                                          =
                                          0
                                       
                                    
                                 
                              
                           
                        where ∇2 is the Laplacian operator.

The snake using the GVF field provides a large capture range and the ability to capture concavities by diffusing the gradient vectors of an edge map generated from the image. Although the GVF field has been widely used and improved in various models, it still shows some disadvantages, such as high computational cost, noise sensitivity, parameter sensitivity, and the ambiguous relationship between the capture range and parameters [16].

Trying to overcome the previous limitations, the VFC [16] is calculated convolving a vector field kernel with an edge map derived from the image. Given a gray-scale image I(x,y), its edge map is f(x,y)=|∇(G
                        
                           σ
                        
                        ∗
                        I)|, where Gσ
                         is a 2-D Gaussian function with standard deviation σ and the operator * denotes the linear convolution. The VFC is defined as
                           
                              
                                 
                                    
                                       f
                                       vfc
                                    
                                    
                                       x
                                       y
                                    
                                    =
                                    
                                       
                                          
                                             u
                                             vfc
                                          
                                          
                                             x
                                             y
                                          
                                          ,
                                          
                                             v
                                             vfc
                                          
                                          
                                             x
                                             y
                                          
                                       
                                    
                                 
                              
                           
                        and is calculated by convolving the edge map with a vector field kernel
                           
                              (1)
                              
                                 
                                    k
                                    
                                       x
                                       y
                                    
                                    =
                                    m
                                    
                                       x
                                       y
                                    
                                    n
                                    
                                       x
                                       y
                                    
                                 
                              
                           
                        where m(x,y) is the magnitude of the vector at (x,y) and n(x,y) is the unit vector pointing to the kernel origin (0,0):
                           
                              
                                 
                                    n
                                    
                                       x
                                       y
                                    
                                    =
                                    
                                       
                                          
                                             −
                                             x
                                          
                                          r
                                       
                                       
                                          
                                             −
                                             y
                                          
                                          r
                                       
                                    
                                    ,
                                 
                              
                           
                        (except that n(0,0)=[0,0]) and where 
                           
                              r
                              =
                              
                                 
                                    
                                       x
                                       2
                                    
                                    +
                                    
                                       y
                                       2
                                    
                                 
                              
                           
                         is the Euclidean distance from the kernel origin. The kernel field has the property that a free particle placed in the field will move to the kernel origin. If the kernel origin is considered as an edge point, the particle will move toward the edge.

The VFC external force is then given by:
                           
                              
                                 
                                    
                                       f
                                       vfc
                                    
                                    
                                       x
                                       y
                                    
                                    =
                                    f
                                    
                                       x
                                       y
                                    
                                    ∗
                                    k
                                    
                                       x
                                       y
                                    
                                    =
                                    
                                       
                                          f
                                          
                                             x
                                             y
                                          
                                          ∗
                                          
                                             u
                                             k
                                          
                                          
                                             x
                                             y
                                          
                                          ,
                                          f
                                          
                                             x
                                             y
                                          
                                          ∗
                                          
                                             v
                                             k
                                          
                                          
                                             x
                                             y
                                          
                                       
                                    
                                    .
                                 
                              
                           
                        
                     

Because the edge map is non-negative and larger near the edges, these will contribute to the VFC external force more than homogeneous regions and the free particles will be attracted by the edges.
                           1
                        
                        
                           1
                           Working with gray-scale images, the vectors of the field will be attracted by and will point towards the brighter areas of the image.
                        
                     

A sample image along with the gradient of its edge image and the result of the VFC are depicted, respectively, in Fig. 2(a, b, c).

The performance obtained by the GVF and VFC-snakes is encouraging. However, they are one-dimensional DMs. For this reason, while they show good capabilities of segmenting the contours of the objects, they lack information about the inner part of the objects. Conversely, the bi-dimensional structure of TANs allows them to segment the internal features of the objects, for instance holes. Therefore, in this paper we propose an ETAN model with the aim of endowing this DM with an advanced distance to the gradient external energy term derived from the VFC field, with a new method to handle topological changes (including holes), with an enhanced local search, and with an improved image filtering mechanism.

The VFC field has some advantages over the GVF field: a better convergence to boundary concavities, a reduced computational cost, robustness to noise, and the flexibility to be easily tailored upon a particular application. However, when dealing with highly convex shapes, the VFC field forms an area where the forces point in opposite directions and the snake stops before getting into the concavity [17].

Nevertheless, as introduced in [16], the VFC field can be tailored by adding an anisotropic term that incorporates a displacement of the vector field upon a certain direction.

The modified VFC magnitude function is:
                           
                              
                                 
                                    
                                       m
                                       0
                                    
                                    
                                       x
                                       y
                                    
                                    =
                                    
                                       c
                                       0
                                    
                                    
                                       x
                                       y
                                    
                                    m
                                    
                                       x
                                       y
                                    
                                 
                              
                           
                        where c
                        0(x,y) is the anisotropic term
                           
                              
                                 
                                    
                                       c
                                       0
                                    
                                    
                                       x
                                       y
                                    
                                    =
                                    
                                       1
                                       
                                          2
                                          −
                                          d
                                          ⋅
                                          n
                                          
                                             x
                                             y
                                          
                                       
                                    
                                    ,
                                 
                              
                           
                        with d being a unit vector representing the displacement direction and·denoting the vector dot product.

In [17] the authors extended the initial tailoring deriving the anisotropic term from the image itself, with the aim of drawing a vector field suitable for the segmentation of highly non-convex shapes. The idea is convolving the blurred gray-level image instead of the edge map with the kernel to generate the anisotropic term shown in Fig. 2(e) for the displacement vector map shown in Fig. 2(d). The final vector field is shown in Fig. 2(f).

According to [16], in some situations the leakage of the DM over weaker edges could appear. To handle this, two techniques were introduced in [17] to mix the VFC and the standard gradient of the edge map: the fixed threshold, where a threshold, for example derived using the Otsu method [22], determines the transition between the two fields, and the convex combination, which consists of taking a convex combination between the normalized VFC and the standard gradient of the edge map. A result of the mix of the vector fields shown in Fig. 2(g) and (c) using the former method in given in Fig. 2(h). Conversely, Fig. 2(i) is the result of mixing the vector fields shown in Fig. 2(g) and (f) using the latter method.

We observed that it is possible to derive a better expression of the gradient distance term used in the TAN model from the VFC and, in particular, from the Extended VFC (EVFC). With this aim, we adapted the field in the following way.

First of all, in [16] and [17], the authors generated normalized fields, which are fields whose vectors have a unitary length. In other words, they only use the information related to the direction and do not take into account the length, or strength, of the vectors in the field. This information, however, can be profitably exploited in DM optimization algorithms, so we developed a different approach. Instead of imposing the length of every vector in the field to 1, we impose the mean of the length of the vectors in the field to 1, that is
                           
                              (2)
                              
                                 
                                    
                                       1
                                       wh
                                    
                                    
                                       
                                          ∑
                                          
                                             v
                                             ∈
                                             F
                                          
                                       
                                       
                                          
                                             v
                                          
                                       
                                    
                                    =
                                    1
                                    ,
                                 
                              
                           
                        where v is a vector in the vector field F and w and h are, respectively, the width and the height of the image I (there are wh vectors in a vector field generated from I).

However, when mixing the gradient of the edge image and an EVFC, a problem arises. While the EVFC (F
                        evfc) is a dense field, that is, a non-zero length vector is associated to every point in the field, the vector field FG
                         of the edge image, ∇f(x,y), is sparse, that is, there are many points in the fields to which an almost zero length vector is associated. Therefore, applying Eq. (2) to the gradient of the edge image vector field would lead to abrupt changes in the resulting field when mixing it with an EVFC field.

We propose to solve this by multiplying every vector in FG
                         by a scaling factor 
                           
                              s
                              =
                              
                                 μ
                                 
                                    EVFC
                                    Otsu
                                 
                              
                              /
                              
                                 μ
                                 
                                    G
                                    Otsu
                                 
                              
                           
                        , where
                           
                              
                                 
                                    
                                       
                                          
                                             μ
                                             
                                                EVFC
                                                Otsu
                                             
                                          
                                          =
                                          
                                             
                                                
                                                   
                                                      1
                                                      n
                                                   
                                                   
                                                      ∑
                                                      
                                                         
                                                            v
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                      
                                                         v
                                                         ∈
                                                         
                                                            F
                                                            evfc
                                                         
                                                         ,
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            
                                                               ∇
                                                               f
                                                               
                                                                  v
                                                               
                                                            
                                                         
                                                         >
                                                         t
                                                         
                                                            h
                                                            Otsu
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          ,
                                       
                                       
                                          
                                             μ
                                             
                                                G
                                                Otsu
                                             
                                          
                                          =
                                          
                                             
                                                
                                                   
                                                      1
                                                      n
                                                   
                                                   
                                                      ∑
                                                      
                                                         
                                                            v
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                      
                                                         v
                                                         ∈
                                                         ∇
                                                         
                                                            F
                                                            G
                                                         
                                                         ,
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            
                                                               ∇
                                                               f
                                                               
                                                                  v
                                                               
                                                               |
                                                            
                                                         
                                                         >
                                                         t
                                                         
                                                            h
                                                            Otsu
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          ,
                                       
                                    
                                 
                              
                           
                        
                        v is a vector belonging to a vector field, th
                        Otsu is the Otsu's threshold calculated considering |∇f| as a gray-level image, and n is the number of points of f(x,y) for which the condition |∇f(v)|>
                        th
                        Otsu applies. In this way, the mean length of the vectors of the gradient vector field is imposed to be the same of the one in EVFC, for the vectors whose corresponding points have a value higher than the Otsu's threshold in the gradient image. Mixing the two vector fields this way, a smooth transition between the two of them is achieved.

As shown earlier, several authors have employed vector fields as external forces to adjust the snake contour to the borders of the object. However, the adjustment of a TAN is guided by energies rather than forces; therefore we need to derive an energy map from the vector field. Since such external energy will drive the adjustment of the external nodes, it should have low values close to the object contour and high values inside the object or far from it.

Therefore we propose to calculate a distance to gradient image DG
                        evfc such that, for every pixel p:
                           
                              (3)
                              
                                 
                                    D
                                    
                                       G
                                       evfc
                                    
                                    
                                       p
                                    
                                    =
                                    
                                       1
                                       
                                          
                                             ∑
                                             
                                                v
                                                ∈
                                                
                                                   ℵ
                                                   w
                                                
                                                
                                                   p
                                                
                                             
                                          
                                          
                                             
                                                v
                                             
                                          
                                       
                                    
                                    ,
                                 
                              
                           
                        where v is a vector of the EVFC field belonging to the neighborhood of size w of the pixel p. To fully take advantage of the smoothness of this term, we perform an equalization [23] of the gray tones of the energy image. Fig. 3
                         shows an example of the construction of this image. Therefore, the final energy functional will be the same shown in Section 2.1 changing the term GD(v(r,s)) with the one shown in Eq. (3).

If the shape of the object(s) rises the need for cutting links and, eventually, changing the topology of the TAN, it is necessary to properly adapt the structure of the net.

The previously existing solution [13] was to perform cuts of links between adjacent external nodes after the minimization process. The procedure identified the most distant external nodes from the object edges using the Tchebycheff's theorem. This way, an external node n was badly placed if its gradient distance, 
                           
                              G
                              
                                 D
                                 
                                    v
                                    ext
                                 
                              
                              
                                 n
                              
                           
                        , fulfilled that
                           
                              
                                 
                                    G
                                    
                                       D
                                       
                                          v
                                          ext
                                       
                                    
                                    
                                       n
                                    
                                    >
                                    μG
                                    
                                       D
                                       
                                          v
                                          ext
                                       
                                    
                                    
                                       n
                                    
                                    +
                                    3
                                    σG
                                    
                                       D
                                       
                                          v
                                          ext
                                       
                                    
                                    
                                       n
                                    
                                 
                              
                           
                        where 
                           
                              μG
                              
                                 D
                                 
                                    v
                                    ext
                                 
                              
                              
                                 n
                              
                           
                         and 
                           
                              σG
                              
                                 D
                                 
                                    v
                                    ext
                                 
                              
                              
                                 n
                              
                           
                         were the average and the standard deviation of the gradient distance of all the external nodes. After the outlier set was identified, the link to be removed was chosen. This link was defined by the node with the highest gradient distance and its worst neighbor in the outlier set.

Although this solution has given acceptable results, it does not take into account the underlying image, only the shape of the net. Moreover, it cannot open holes into the mesh to perform the segmentation of object holes. In order to solve these issues, we have developed a novel approach to tackle topological changes in ETANs. The following sections show our new approach.

The link to be cut is chosen depending on the energy the link is withstanding: the higher the energy, the higher the possibility to cut the link. The underlying idea is to cut the links which bear an energy
                              2
                           
                           
                              2
                              The energy a link is withstanding can be thought as the tension that link is bearing.
                            higher than a threshold. This threshold is not fixed, in fact it depends on the mean energy the links of a mesh are experiencing.

The energy of a link is calculated as
                              
                                 (4)
                                 
                                    
                                       
                                          E
                                          link
                                       
                                       =
                                       
                                          
                                             
                                                
                                                   ∑
                                                   
                                                      p
                                                      ∈
                                                      A
                                                   
                                                
                                                
                                                   D
                                                   
                                                      G
                                                      evfc
                                                   
                                                   
                                                      p
                                                   
                                                   ⋅
                                                   
                                                      
                                                         
                                                            I
                                                            
                                                               p
                                                            
                                                         
                                                         
                                                            I
                                                            max
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             A
                                          
                                       
                                       ,
                                    
                                 
                              
                           where p is a pixel belonging to the area A over which the energy is computed, DG
                           evfc is the EVFC distance to gradient image, I is the original image, I
                           max is the maximum intensity value in the original image, and |A| is the size of the area A. This area is defined by the w and h parameters; while h can be set to zero, w has to be non-zero. Fig. 4
                            illustrates the cut of a mesh link.

The link cutting procedure calculates the energy of all the links that can be cut in the mesh, derives the mean energy E
                           mean a link in the mesh is withstanding, and cuts the most stressed one (with energy E
                           max) if E
                           max/E
                           mean
                           >
                           th
                           
                              cut
                           .

Robust values (experimentally found) for thcut
                            are around 3.

Not all links in a mesh can be cut, even if they bear a high energy. The reason for this is that the topology of the net can be damaged [13]. Therefore the only links whose energy is measured and contributes to E
                           mean are those which can actually be cut. In order to be a candidate for being cut, a node has to pass some cuttability tests:
                              
                                 •
                                 The side links test. First of all, the two links at the sides (in the same line) of the link to be cut must exist, otherwise a wire would appear. One of the conditions to consider a link as a wire is to connect a node which has only one neighbor. Fig. 5(a) depicts this test.

The external nodes test. A link to be cut has to connect two external nodes: the cut of external–internal and internal–internal links are not allowed because it would open holes in the mesh. Fig. 5(a) shows internal and external nodes of a small mesh (respectively in blue and white). Opening of holes in the mesh is performed to segment holes in the objects but it is managed in a different way and explained in Section 3.2.2. This test is fast and simple, however, it is not sufficient to prevent the opening of non desired holes in a mesh.

The existing faces test. It is possible that although a link connects two external nodes, its removal would lead to a hole in the mesh, as the yellow link in Fig. 5(a). To prevent this and other undesirable statuses, we introduced the idea of face. A face is a zone of the mesh delimited by four nodes (and the corresponding four links between pairs of them). It can be full, if all the four links connecting the nodes exist, or empty, if at least one is missing. Therefore, removing a link whose lateral faces are both full is not allowed.

The allowed faces test. When removing a link, if the previous test is passed, it is necessary to test for not allowed configurations in a search window of 3×4 faces (see Fig. 5(b)). Inside the search window, we test that all the six configurations of 2×2 face subwindows are different from the incorrect ones, in case the link had been removed. The 2×2 faces incorrect configurations are shown in Fig. 5(c). All the remaining possible configurations are allowed. It is possible to cut the link only if the configurations of all of the six subwindows are allowed (see Fig. 5(d)).

Once a link has been cut, it is necessary to perform a further test, the topology test. In some cases, only two links and the face between them connect two subnets, like the ones in Fig. 5(e). If one of the two links is removed, the face would be set empty and the other link would become a wire. To avoid this, four faces in the same column (two one each direction) of the removed link are considered, and every link lying between two empty faces is removed, successfully cutting the possible wires. This test is recursively applied to subsequent cuts and can lead to the separation of two subnets, changing the topology of the net, as the example shown in Fig. 5(e).

TANs have the ability of segmenting holes in the object(s). The holes are recognized starting from misplaced internal nodes. For every internal node n, r(n) is calculated as
                              
                                 (5)
                                 
                                    
                                       r
                                       
                                          n
                                       
                                       =
                                       
                                          
                                             
                                                E
                                                ext
                                             
                                             
                                                n
                                             
                                          
                                          
                                             
                                                E
                                                ext
                                             
                                             
                                                n
                                             
                                             +
                                             
                                                E
                                                int
                                             
                                             
                                                n
                                             
                                          
                                       
                                       ,
                                    
                                 
                              
                           where E
                           ext(n) is the external energy of the node n and E
                           int(n) is the internal energy of the node n. The idea of Eq. (5) is that a misplaced internal node (in a hole) has a high external energy in comparison with its internal energy. The node nh
                            with the highest ratio is selected and if r(n
                           
                              h
                           )>
                           th
                           holes, a hole is opened in the net starting from this node. If this is the case, the values of the energy of the links connecting nh
                            and its neighbors are calculated and the highest one is chosen. This internal link is removed and the topology test is applied, eventually removing wires.

The adjustment of the mesh to the object is a procedure that comprises several steps. After the mesh is initialized to the starting position, the adjustment process begins.

The first step is a BILS algorithm that optimizes the position of every node in the mesh. To do so, a square window centered on each node, and a location (i.e. a pixel on the image) with a lower energy is searched for it, according to the energy functional discussed in Section 2.1. If a better position is found, the node is immediately moved to this location. The search is performed sequentially from the first to the last node of the net and the whole search is repeated until no node can be further moved. When it is not possible to stretch or compress the mesh anymore, the link cutting procedure is activated. This procedure, affected by several constraints, cuts the links located in high energy areas and allows the mesh to adapt itself to the shape or topology of the object. A specific heuristic procedure is called after this phase to correct the position of misplaced nodes. At this point the mesh should be adjusted to the contour of the object and it is now possible to segment the holes which eventually exist inside the object. The last step of the process is the activation of a less constrained version of the cutting procedure to finalize the segmentation. Algorithm 1 shows the full mesh adjustment procedure while Fig. 6
                      depicts the overall scheme. The next subsections explain the different phases of the segmentation process in more detail.

As said, the BILS algorithm looks for the best position of each node inside a specific window. However, one of its drawbacks described in [8] is the absence of constraints to limit the position of the moving nodes with respect to the other nodes in the mesh. This can eventually lead to crossings of the links connecting nodes. In order to avoid that, the first step of our extended BILS search (EBILS) is testing if the node is located outside the safe area, which is the polygonal area delimited by the node neighbors. While for an internal node this reduces to testing if a point is inside or outside the polygonal area, for an external node the safe area is not limited in one or more sides. Thus, we test if the target node lies on the left side of the vectors connecting the neighbors of the target node, in anticlockwise direction. If a node (internal or external) lies outside of its safe area, it is moved to a position that is calculated as the mean position of its neighbors. Fig. 7
                         shows two misplaced nodes and their repositioning.

Once the position of a node has been tested and eventually corrected, the EBILS search calculates the local energy the target node would have if located on the pixels belonging to a square neighborhood of size S
                           neighs
                         of pixels centered on the current location. This EBILS search only considers positions in the safe area and if it finds a location with a lower energy than the current one, it moves the node to its new position.

Finally, it iterates on all the nodes of the mesh (a pass) until no node was moved in the last pass. Algorithm 2 shows this procedure.

Once it is not possible to improve the energy of the net just relocating its nodes, the cutting links procedure begins. This procedure chooses a link to be cut (if it exists) to improve the net adjustment to the object. If it is the case, the EBILS previous node movement procedure is run after the cut. The cutting links procedure ends when it is not possible to cut more links. Algorithm 3 shows this procedure.
                           Algorithm 1
                           Mesh full adjustment procedure


                           
                              
                                 
                                    
                                 
                              
                           


                              
                                 
                                    
                                 
                              
                           


                              
                                 
                                    
                                 
                              
                           

After the EBILS application, it can happen that some nodes are gradient-misplaced. Those nodes are topologically part of a subnet but are located far from it, in a position closer to another subnet. This can happen if, after some cuts, the misplaced nodes followed the energy gradient and were attracted far away from their neighbors. Moreover, these nodes cannot be cut because they did not pass the cuttability tests. The gradient-misplaced nodes are recognized measuring the energy and the length of every link in the mesh connecting pairs of external nodes. The links are ordered by length and the mean of the energies and the median of the lengths are calculated. If the length of a link is more than 
                           
                              t
                              
                                 h
                                 
                                    lin
                                    
                                       k
                                       length
                                    
                                 
                              
                           
                         times the median length and 
                           
                              t
                              
                                 h
                                 
                                    lin
                                    
                                       k
                                       energy
                                    
                                 
                              
                           
                         times the mean energy, then one of the two nodes connected by the link is considered as gradient-misplaced.

Our solution is to move the misplaced nodes towards their good placed neighbors. Since it is not easy to detect which of the two nodes of the link is gradient-misplaced, we move the node that has the lowest number of neighbors. If both nodes have the same number of neighbors, the neighbors of neighbors are calculated and the node with the lower value is moved. If that number is still the same, the node with the higher energy is moved. This heuristic is applied to every link that complies with the conditions illustrated above. The whole procedure is applied if at least one node moved in the previous iteration up to a max of 
                           
                              t
                              
                                 h
                                 
                                    link
                                    iters
                                 
                              
                           
                         iterations. After this procedure, a pass of the EBILS is applied to finely adjust the position of the moved nodes. Robust values (experimentally achieved) for 
                           
                              t
                              
                                 h
                                 
                                    link
                                    length
                                 
                              
                           
                        , 
                           
                              t
                              
                                 h
                                 
                                    link
                                    energy
                                 
                              
                           
                         and 
                           
                              t
                              
                                 h
                                 
                                    link
                                    iters
                                 
                              
                           
                         are 5, 3 and 5, respectively. Fig. 8
                         illustrates an example of this procedure.

After the procedure shown in Section 3.2.2, a complete EBILS with cuts enabled is applied to the mesh. Moreover, up to 
                           
                              t
                              
                                 h
                                 
                                    link
                                    iters
                                 
                              
                           
                         iterations of the Fixnet heuristic are applied to the net. This whole procedure is repeated for as many internal nodes have a r(·) ratio (Eq. (5)) above the th
                        holes threshold. Since an EBILS and the heuristic have been applied, it is necessary to recalculate the nodes energies again at every pass of this procedure.

After the holes have been segmented, the net is ready for the last step of the segmentation algorithm. Occasionally, a good segmentation is spoiled by some links that cannot be cut because of the link cut topology restrictions. An example of this is shown in Fig. 9(a). Here the net is well adjusted to the object apart from three links that cannot be cut, as shown by the topology net in Fig. 9(d).

In order to solve this, the last step of our segmentation process is to run the EBILS with cuts enabled and without the topological restrictions described in Section 3.2.1. Since this way it is possible that the net ends up with wires, we developed a correction procedure. This procedure removes every link between two empty faces and links connecting nodes with only one neighbor. Fig. 9(b, e) shows, respectively, the segmentation and the topology nets after applying the EBILS without restrictions while Fig. 9(c, f) shows the two nets after applying the correction procedure. Note the presence of a free node (i.e. with no neighbors) in the net, as shown in Fig. 9(f). Since a free node has no neighbors, it is removed from the net and it does not contribute to the energy of the net in any way.

The following subsections are not strictly related to the ETAN model. In contrast, they deal with the image filtering process and the net initialization, tasks that depend on the kind of images to segment.

The gradient image, which is also the starting point of the distance to gradient image, is usually constructed applying an edge detector over the original image. As an alternative, we propose to use a K-means clustering [24] generated pre-segmentation. Both methods have pros and cons. While the K-means based distance to gradient image can provide cleaner images, in particular in the case of synthetic image with fuzzy borders or real images affected by noise, it is heavily based on the quality of the K-means pre-segmentation result.

In our case, every pixel of the image is assigned by K-means to a cluster, on the basis of its gray tone [25]. In order to reduce the noise of the obtained segmentation, the original image undergoes a mean filtering by means of a 10×10 kernel.

The results of the K-means clustering are highly dependent on the initial number of clusters, which is the value of the K parameter. Experimental tests have proven that the best results are obtained with K
                        =2 for synthetic images (which are fundamentally composed of only two areas, the object and the background), and with K
                        =3 for the medical images in our dataset.

K-means assigns every pixel in the image to a specified cluster. A result of this clustering procedure for the example medical image in Fig. 10(a) is shown in Fig. 10(b), where each one of the three gray tones identifies a cluster. The smallest and brightest one corresponds to the target object. However, it is not possible to know a priori which cluster corresponds to the target segmentation object. Therefore, we take as object the cluster with the most compact spatial location, that is the one given by
                           
                              
                                 
                                    
                                       
                                          arg
                                          
                                          min
                                       
                                       
                                          c
                                          ∈
                                          C
                                       
                                    
                                    
                                       
                                          
                                             1
                                             
                                                c
                                             
                                          
                                          
                                             
                                                ∑
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                
                                                   c
                                                
                                             
                                             
                                                
                                                   d
                                                   E
                                                
                                                
                                                   
                                                      
                                                         
                                                            p
                                                            
                                                               c
                                                               ,
                                                               i
                                                            
                                                         
                                                         −
                                                         
                                                            μ
                                                            c
                                                         
                                                      
                                                   
                                                   2
                                                
                                             
                                          
                                       
                                    
                                    ,
                                    
                                    with
                                    
                                    
                                       μ
                                       c
                                    
                                    =
                                    
                                       1
                                       
                                          c
                                       
                                    
                                    
                                       
                                          ∑
                                          
                                             i
                                             =
                                             1
                                          
                                          
                                             c
                                          
                                       
                                       
                                          
                                             p
                                             
                                                c
                                                ,
                                                i
                                             
                                          
                                       
                                    
                                    ,
                                 
                              
                           
                        where C is the set of clusters, pc,i
                         is the i-th point of cluster c, μc
                         is the centroid in image space (and not in the gray level space) of the cluster c and the function dE
                        () is the Euclidean distance.

Once the cluster t corresponding to the target object is known, the K-means segmentation image is created. A pixel ps
                         of this image has a value of 0, if p
                        
                           k
                        
                        ∈
                        t and 225 if p
                        
                           k
                        
                        ∉
                        t, where pk
                         is a pixel of the K-means cluster image. The resulting K-means segmented image obtained applying the algorithm to the image in Fig. 10(a) is shown in Fig. 10(c).

Then, applying an edge detector and the EVFC procedure to this image, it is possible to obtain the gradient and the distance gradient images shown in Fig. 10(e) and (g). These images are affected by a lower amount of noise than the corresponding ones shown in Fig. 10(d) and (f) but the object contours are less precise.

The net is initialized uniformly sampling all the nodes of the mesh between two endpoints, the upper left node and the lower right node. The two endpoints can be chosen manually, automatically, or to cover the whole image. With the manual initialization, the user has to choose two points on the image in such a way that the mesh will surely cover the object to segment. With the automatic initialization the software chooses the endpoints using the K-means segmentation image. For this purpose, morphological opening and closing are applied to the image in order to remove small artifacts. Then, a bounding box is calculated around the object. Finally, the two endpoints are inferred from the bounding box.

@&#RESULTS AND ANALYSIS@&#

@&#EXPERIMENTAL DESIGN@&#

We tested six different segmentation algorithms: two state-of-the-art snake models, GVF and VFC; two state-of-the-art level set models, CaV and GAC; the original TAN and our ETAN proposal. The final aim of selecting such a different set of DM-based image segmentation models is to show that ETAN can actually become competitive when dealing with this image processing task.

In this paper we consider the use of a K-means pre-segmentation to generate the EVFC employed by the external energy term of our algorithm (see Section 5.1). Although this is just a pre-processing, it succeeds in filtering the image and simplifies the segmentation process. In order to perform a fair comparison, we also evaluated the other algorithms providing them with the same pre-processing step.

We tested our method on two different image datasets, one of them composed of synthetic images and the other of real-world medical images. The synthetic images show various difficulties and have a ground truth allowing us to properly evaluate the segmentation performance.

In order to quantitatively assess our results on the dataset, we compute the spatial accuracy index S, which is a similarity index based on the overlapping rate between the segmentation result and the ground truth [26]:
                           
                              (6)
                              
                                 
                                    S
                                    =
                                    2
                                    ⋅
                                    
                                       
                                          Card
                                          
                                             
                                                R
                                                ∩
                                                T
                                             
                                          
                                       
                                       
                                          Card
                                          
                                             R
                                          
                                          +
                                          Card
                                          
                                             T
                                          
                                       
                                    
                                    ,
                                 
                              
                           
                        where R is the segmentation result and T is the ground truth.

We also compute the mean distance 
                           
                              M
                              
                                 d
                                 RT
                              
                           
                         between the contours of the segmentation results and the ground truth as well as the mean distance 
                           
                              M
                              
                                 d
                                 TR
                              
                           
                         between the ground truth and the segmentation results:
                           
                              
                                 
                                    
                                       
                                          
                                             M
                                             
                                                d
                                                RT
                                             
                                          
                                          =
                                          
                                             
                                                
                                                   
                                                      ∑
                                                      
                                                         r
                                                         ∈
                                                         R
                                                      
                                                   
                                                   
                                                      
                                                         min
                                                         
                                                            t
                                                            ∈
                                                            T
                                                         
                                                      
                                                      
                                                      d
                                                      
                                                         r
                                                         t
                                                      
                                                   
                                                
                                             
                                             
                                                Card
                                                
                                                   R
                                                
                                             
                                          
                                          ,
                                       
                                       
                                          
                                             M
                                             
                                                d
                                                TR
                                             
                                          
                                          =
                                          
                                             
                                                
                                                   
                                                      ∑
                                                      
                                                         t
                                                         ∈
                                                         T
                                                      
                                                   
                                                   
                                                      
                                                         min
                                                         
                                                            r
                                                            ∈
                                                            R
                                                         
                                                      
                                                      
                                                      d
                                                      
                                                         r
                                                         t
                                                      
                                                   
                                                
                                             
                                             
                                                Card
                                                
                                                   T
                                                
                                             
                                          
                                          ,
                                       
                                    
                                 
                              
                           
                        where d(x,y) is the Euclidean distance.

Moreover, we compute the Hausdorff distance [27], which is the maximum distance between the two contours:
                           
                              (7)
                              
                                 
                                    
                                       d
                                       H
                                    
                                    
                                       R
                                       T
                                    
                                    =
                                    max
                                    
                                       
                                          
                                             sup
                                             
                                                r
                                                ∈
                                                R
                                             
                                          
                                          
                                             inf
                                             
                                                t
                                                ∈
                                                T
                                             
                                          
                                          d
                                          
                                             r
                                             t
                                          
                                          ,
                                          
                                          
                                             sup
                                             
                                                t
                                                ∈
                                                T
                                             
                                          
                                          
                                             inf
                                             
                                                r
                                                ∈
                                                R
                                             
                                          
                                          d
                                          
                                             r
                                             t
                                          
                                       
                                    
                                    .
                                 
                              
                           
                        
                     

The two snake codes are the original MATLAB® implementations released by the authors. The two level sets (obtained from the Free Software ofeli 
                        [28]) are C++ implementations of the Shi and Karl Fast-Two-Cycle (FTC) algorithm [29]. The original TAN is implemented in C while the code relative to our proposal has been implemented in C++. All the tests were run on an Intel® Core™2 Quad CPU Q8400 at 2.66GHz with 4GB DDR3 RAM.

The TAN and ETAN parameters used for all the 18 images in the synthetic images dataset are shown in Table 1
                        . As shown, the ETAN has all the parameters of the TAN and some new ones. Although this could suggest that tuning an ETAN is harder than a TAN, we experimentally arrived at the opposite conclusion. Indeed, in order to achieve an appropriate performance for the TAN, there is a need to perform a specific experimental study testing different values for each parameter in a wide range, for each image. For instance, for the TAN case, using a net size of 30×30 nodes provided poor results and it was necessary to manually set this parameter to lower values, different for each image. Conversely, in the ETAN case we simply fixed the values for almost every parameter. Only the last two ETAN parameters were changed, and only for a few cases. No changes were done to parameters of the two snakes [16,18], which are shown in Table 2
                        . Finally, Table 3
                         lists the parameters values relative to the level sets. While the GAC did not require any adjustment (since no performance difference was detected on the used image datasets (see Section 6.2) changing the morphological gradient structuring element size parameter), the CaV algorithm benefitted from the extensive adjustment of the two shown parameters we developed.

The synthetic images of our dataset are divided into six categories:
                           
                              1.
                              images with concavities or complex shapes;

images with fuzzy borders;

images with noise;

images with holes;

images with multiple objects; and

images with a combination of several difficulties.

The three images in every category are listed in increasing difficulty order. All the images of this dataset have a size of 375×375 pixels and are shown in Fig. 11
                         (to save space, they are shown with the resulting ETAN superposed).

Finally, we also evaluated the six algorithms on three real-world medical images, which are shown in Fig. 12
                        . These images are extracted from a dataset without ground truth. Therefore we only assess the segmentation accuracy in a qualitative way.


                        Fig. 11 shows the resulting ETAN adjusted over the original image, while the results achieved by the six methods with and without the K-means pre-segmentation are resumed using boxplots in Fig. 13
                        . Table 4
                         shows the numeric results of the five metrics for the six methods on every synthetic image. The table also shows the mean (μ) and the standard deviation (σ) for all the algorithms and for every metric on the whole synthetic images dataset. For every image, the best result for every metric is highlighted in boldface.

As it can be seen in Table 4, our proposal achieves the highest mean index S, the lowest mean Hausdorff distance, and the lowest mean 
                           
                              M
                              
                                 d
                                 TR
                              
                           
                         distance, that is, the ground truth image is closer to the ETAN segmentation result than any other one. Conversely, the mean 
                           
                              m
                              
                                 d
                                 RT
                              
                           
                         distances provided by the two snakes using the K-means pre-segmentation and the CaV level set without using it are smaller than the ETAN result. This means that those solutions, when able to find the right contour, can adjust to it in a slightly better way (0.3, 0.49 and 0.86 vs 1.27) than ETAN. Regarding the time, the fastest algorithm is the TAN, followed by the level sets and our ETAN proposal. It is worth to note that the Shi level set implementation used in ofeli is significantly faster than typical level sets, with speedups up to ×100 compared to other implementations [29]. Moreover, we must note that the times shown for the TAN and the level sets do not include the K-means pre-segmentation phase, when applicable. Moreover, the TAN (regardless how it was initialized) never achieved the best segmentation. The two snake algorithms are from 10 to 70 times slower than ETAN. Below, we provide a detailed analysis of the obtained results divided by categories.

Images cc1, cc2, and cc3 belong to this category. The TAN provides unsatisfactory results for all the images. The GVF snake fails to properly segment image cc1 while the VFC snake does not provide a completely satisfactory segmentation of image cc2. Both algorithms do not provide completely satisfactory segmentations of image cc3, as shown in Table 4. On the contrary, the two level sets provide perfect segmentations on this subset, and our proposal provides good results for the three images, as shown in Fig. 11(a–c). The behavior of the algorithms does not change using the K-means pre-segmentation.

Images fb1, fb2, and fb3 belong to this category. The TAN obtains good results on the first two images when using the K-means pre-segmentation while it stops too far from the real borders without it. Conversely, the segmentation of fb3 is unsatisfactory in both cases. The GVF snake is able to segment the first two images using the K-means while without it the result for fb1 is suboptimal. It fails to properly segment fb3. The VFC snake (regardless the chosen pre-segmentation), the level sets and our proposal perform well on the three images (see Fig. 11(d–f)).

These images, n1, n2, and n3, are affected by an increasing amount of noise. The snake and the TAN algorithms are very influenced by the presence or not of the K-means segmentation. In fact, it effectively filters the image providing a simpler input for the segmentation process. In particular, the TAN provides unsatisfactory results in any case. The GVF snake without K-means is unable to segment the images while, when using it, it is able to provide suboptimal segmentations because of its incapacity of segmenting this particular shape (see Table 4). The VFC snake provides better results, being capable of segmenting correctly n1 even without K-means. Moreover, with the pre-segmentation, it is able to segment correctly all the images. Differently from the other algorithms, the level set and our proposal achieve good results in the three cases (see Fig. 11(g–i) for ETAN).

Images h1, h2, and h3 belong to this category. All the models are able to perform a near perfect segmentation of the external borders of the objects. However, only our proposal is able to segment the holes of the objects (see in Table 4 how no algorithm, apart from ETAN, achieved a Hausdorff distance lower than 45pixels). In these cases, the level sets are not able to segment the holes in the objects, when initialized outside the object, like the other algorithms. This is due to the monodimensional nature of the contour. Therefore, our approach obtains much better overall results (see Fig. 11(j–l)) than all the others. This behavior does not change when the competitors are endowed with the K-means pre-segmentation.

For images belonging to this category (mo1, mo2, and mo3), the TAN provides the worst results. The meshes did not divide so that they cover the objects and the area among them. Conversely, the snakes, the level sets and our proposal provide better results. While the GVF snake is able to segment mo1, it fails to segment the other two. The VFC snake, in turn, only fails to segment mo3 (see Table 4) while the level sets and our proposal are both able to properly segment all the three images (see Fig. 11(m–o)). It is important to note that the snakes are not able to change their topology, hence small wires connect the segmented object, even when the segmentation is of good quality. The results do not change when the K-means pre-segmentation is employed.

Images c1, c2, and c3 belong to this category. The TAN performs badly on the three images. The GVF snake performs better but it is unable to separate the objects, to segment some complex shapes, and to segment the holes. The VFC snake succeeds in separating the objects but it is unable to segment some complex concavities and the holes (hence the high values of the Hausdorff distance of Table 4). The level sets show the same behavior as the VFC snake, as they fail in segmenting the holes in the objects. Our proposal is the only method being able to provide good segmentations of the three images (see Fig. 11(p–r)). Our competitors are scarcely influenced by the pre-segmentation.

The images in this second dataset, m1, m2, and m3 are real-world CT images.
                              3
                           
                           
                              3
                              The gray value of all pixels has been inverted so the bone becomes the darker object in the image.
                            They are depicted in Fig. 12. The segmentation has been performed over the K-means pre-segmentation and over the original image. In the latter case, a Canny filtering [30] has been applied to the image (this does not apply to the two level sets as the CaV does not employ edges and the GAC relies on its own detector). Moreover, the initialization is different for the six algorithms, because of the different implementations. In the case of the TAN, the mesh is initialized on the whole image. This implies that the net gets stuck in the first local minimum, that is, the tissue part around the bone, as shown in Fig. 12(d–f). Conversely, with the K-means pre-segmentation, the mesh can reach a zone closer to the object because the pre-segmentation removes the tissue region, providing better results (see Fig. 12(a–c)).

The two snakes and the two level sets are initialized manually as circles around the objects: this means that there is no overlap between the DMs and the external tissue contour. Even in this case, the GVF snake falls in local minima for the case of m2 and m3 images (see Fig. 12(k, l)) while it provides a very good result for the case of image m1 (see Fig. 12(j)). Contrarily, the VFC snake is able to obtain good results for the three images (see Fig. 12(p–r)). On these images the level sets show some limitations. On the one hand, the CaV level set provides acceptable results on images m2 and m3 while it leaks inside the object for the case of image m1. Changing the values of the two parameters of the algorithm in a wide range gave only two outcomes: either the one shown in Fig. 12(v) or another, similar to the one obtained by the GAC in Fig. 12(ab), segmenting the tissue around the bone. On the other hand, the GAC level set failed in segmenting the bones, providing a result similar to the TAN one. This is due to the attraction of the edges dividing the air and the tissue which have a much stronger response compared to the edges dividing the tissue and the bone.

Differently, our proposal is initialized automatically, using the K-means pre-segmentation, with a rectangular mesh. This means that, in the case of images m2 and m3, there is an overlap between the tissue external border and the mesh. Although this really increases the difficulty level of the segmentation, our model is able to provide acceptable segmentations. In the area occupied by the upper part of the bone in image m2 the mesh falls in a local minimum (see Fig. 12(ai)). Moreover, our proposal obtains an excellent result for images m1 (see Fig. 12(ah)) and m3 (see Fig. 12(aj)).

In the case of using the K-means pre-segmentation, the two snakes, the two level sets, and our proposal obtain very similar results. Although the segmentation is acceptable, it is highly dependent on the K-means pre-segmentation result; the borders, indeed, are not exactly the ones of the objects (see Fig. 12(g–i, m–o, s–u, y–aa, ae–ag)).

The execution times of the six algorithms span four orders of magnitudes, as shown in Table 4. While the TAN never needs more than 1s to segment the image, the two snake implementations require several minutes. In particular, the GVF snake required more than 10min to segment one of the noisy images. This is partly because of the MATLAB implementation of both snakes and partly because of the slowness of the optimization algorithm used. The level set showed to be a fast algorithm, when the Shi model is used, as it required from 1.5 to 7.5s to segment the images. These times, however, do not include the creation of the K-means pre-segmentation, when applicable. Our proposal never required more than 9s to segment an image, with most of the images segmented in less than 3s (see Table 4). Moreover, the K-means pre-segmentation and the creation of the EVFC require approximately 2–3s to be calculated.

@&#CONCLUSIONS AND FUTURE WORK@&#

In this work we introduced the ETAN model, extending the existing TAN one through the design of several new components to improve the accuracy of the segmentation results.

In particular, we introduced a new external energy term, derived from the EVFC, which substitutes the previous distance gradient image. We designed new ways to tackle topological changes, such as link cuttings, net division and hole segmentation while ensuring the net correctness during the local search. We also designed a heuristic to fix the position of misplaced nodes. Finally, we endowed the ETANs with a pre-segmentation phase based on K-means clustering with the aim of performing automatic initialization.

The obtained results are encouraging. Our proposal improves the accuracy of the segmentation of synthetic images in comparison with snake models of the state-of-the-art, while needing lower computational resources. Besides, it is also competitive with level sets on synthetic images while it even outperforms them on the tested real world medical images. Moreover, the robustness achieved is significantly better than the previous TAN method and it is less sensitive to parameter values changes.

Nevertheless, regardless its good performance, our method still has room for improvement. In some cases the obtained segmentations are not fully correct. The EBILS algorithm gets good results in those cases with low presence of noise since it takes the best local adjustment. Nevertheless, this local adjustment may not be the best global one in many images because of the presence of noise and/or artifacts, or simply the high complexity found in medical images. Moreover, the EBILS algorithm does not consider any possible alternatives. This way, if the model reaches a wrong segmentation, a local minimum from the optimization point of view, it gets stuck in it. Embedding the ETANs into a global search framework (like in [13]) could overcome these limitations providing a very robust segmentation technique.

The ETAN model has boundary-based and region-based segmentation capabilities. To better take advantage of the latter feature, another future work could be to endow the ETAN with a texture analysis system. Indeed, texture is one of the important characteristics used in identifying objects or regions of interest in an image. Haralick [31,32] described some easily computable textural features based on gray-tone spatial dependencies that can be helpful in image segmentation. These features could be taken into account by the pre-segmentation phase and/or by the ETAN itself (analyzing the face areas, which are the areas delimited by four nodes) to further improve the segmentation process.

Moreover, Barreira et al. introduced Topological Active Volumes in [33] to perform segmentation of 3D structures. A further development of the current proposal could be its extension to 3D as done in that work with the original TAN.

@&#ACKNOWLEDGMENT@&#

This work has been supported by the European Commission with the contract no. 238819 (MIBISOC Marie Curie ITN), the Spanish Ministerio de Economía y Competitividad under the SOCOVIFI2 project (references TIN2012-38525-C01/C02 http://www.softcomputing.es/socovifi/), the Andalusian Department of Innovación, Ciencia y Empresa (reference TIC-7745), including EDRF funding.

Part of the experiments related to this work was supported by the computing resources at the Supercomputing Center of Galicia (CESGA), Spain.

@&#REFERENCES@&#

