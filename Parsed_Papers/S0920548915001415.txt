@&#MAIN-TITLE@&#A cloud service for COTS component-based architectures

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Cloud services for deploying component-based architectures


                        
                        
                           
                           Component-based architectures for building user interfaces at run-time


                        
                        
                           
                           Components and interfaces, models, and COTSget-as-a-service


                        
                        
                           
                           An infrastructure model based on a three-tier architecture to deploy user interfaces


                        
                        
                           
                           Integration of CBSE, MDE and cloud computing technologies


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Cloud service

Software architectures

Component-based systems

COTS

@&#ABSTRACT@&#


               
               
                  Software architecture management, especially in component-based web user interfaces is important to enhance their run-time accessibility, dynamics and management. The cloud offers some excellent mechanisms for this kind of systems, since software can be managed remotely, easy availability of the resources is ensured and mass storage is possible. This article presents an infrastructure solution, based on the use of web services and cloud computing, for managing COTS-based architectures.
               
            

@&#INTRODUCTION@&#

In general, software available on the web must increasingly be changed, updated and adapted to user demands. Such software is sometimes built up from components, or component-based architectures are used to describe its structure. In both approaches, they must be accessible at any time, dynamic, managed at run-time and adaptable to changes [5]. Web services and cloud computing offer an excellent infrastructure for this, and since the software can be managed remotely, high resource availability is ensured and mass storage is possible. An example of such architectures is component-based web interfaces, which have the same requirements, and must be dynamic and adapt thier structure to the user preferences. With this aim, new projects and proposals have come up in the last few years to build customized web User Interfaces (UI) by configuring the widgets the user wants to visualize [25]. For these applications, the user has a Graphical User Interface (GUI) available that can be configured to create a dashboard. This type of GUI is built from graphical components of high or medium granularity (that is, they are not simple buttons or text fields) that group together some functionalities related to each other and make up widget-based mashup applications [46,15], such as MyYahoo, Ducksboard or Netvibes [42].

This led to our interest in developing an infrastructure for managing component-based software architectures. In particular, our research work is focused on dynamic management of component-based UIs. The three pillars on which our proposal is based are therefore: CBSE (Component-based Software Engineering), MDE (Model-Driven Engineering) and Cloud Computing. Component-based Software Engineering 
                     [11] is a software engineering discipline that improves software development by reusing it, contributing reliability, and reducing the time required for creating such software. Contrary to traditional software development, CBSE is focused on integrating previously developed software components into the system following a bottom-up development instead of a traditional top-down perspective. The concept of component reuse and management is also present in standards [2]. Our proposal requires that the user interface be defined as a set of components, in which each application component represents an individual user interface component. This proposal follows a bottom-up perspective for developing (at run-time) the UI structure from components available in one or more third-party repositories.

The UI components used in our proposal are called COTSgets, from COTS (Commercial Off-The-Shelf) [28] and gadgets (understood as any software that can work alone or as a piece of the architecture). A COTS component is any coarse-grained component developed by third parties available for building more complex systems. An example of a GUI application developed by us under a Project of Excellence funded by the Junta de Andalucía [Andalusian Government] [18] may be seen at http://acg.ual.es/enia/COTSbasedArchitectureExample. This real application will show the reader what a COTSget-based architecture looks like. It can be tried out, and hopefully, the role of this kind of component will be easier to understand.

The second pillar is Model-Driven Engineering. This engineering discipline is focused on constructing models on different levels of abstraction, facilitating software specification, and providing several mechanisms for automating the development of the final product using of model transformation techniques. Some systems developed with these techniques attempt to provide software with adaptive capabilities for dynamic reconfiguration of the models at run-time, so they may act differently as the adapt to the circumstances of their execution, such as changes in the user interaction, available resources, or execution platforms [37,16]. In the particular domain of component-based software systems, MDE techniques can facilitate architecture design and development, for example, in defining their structure, component behavior and relationships, interaction, or their functional and non-functional properties [12]. Furthermore, adaptation of architectural models at run-time makes it possible to generate different software systems based on the same abstract definition, for example, to cope with different user preferences, component status or target platforms [3]. Fig. 1
                      shows how our component-based architectures can be represented on three levels of abstraction (in the infrastructure proposed):
                        
                           •
                           Abstract architectural model, corresponding to the Platform Independent Model (PIM) level in Model Driven Architecture (MDA) [31], and representing the architecture in terms of the type of components it contains and their relationships.

Concrete architectural model, corresponding to the Platform Specific Model (PSM) level, and describing the concrete components that comply with the definition of the abstract architecture.

Final software architecture, which represents the source code (our components) to be executed or interpreted.

Run-time adaptation of the architectures is based on processes executed on the abstract and concrete architecture levels [10,27]. On the abstract level, model-to-model transformation processes [14] are executed to adapt the abstract architectural models to changes in context [9]. On the concrete level, the concrete architectural models are realized by a trading process [28,8], which calculates the configurations of concrete components that best meet the abstract definitions. This provides the possibility of generating different software architectures based on the same abstract definition, for example so it can be executed on different platforms. The content of this paper focuses only on showing the technological infrastructure used on the concrete level and the final architecture. Adaptation on the abstract level (PIM perspective), the trading process for the concrete architectures (PSM), synchronization of abstract models and final architectures, or how the changes in the models affect the executing architecture are outside the scope of this paper.

The third pillar is Cloud Computing. The strengths of cloud computing for users and organizations have been widely described in the literature, e.g., [33] or [44]. The benefits identified include the use of Software-as-a-Service (SaaS) and specifically Models-as-a-Service (MaaS) as on-demand high-level abstract software. The combined use of MaaS and MDE in turn has many benefits [6] to highlight such aspects as their availability, run-time sharing, improved scalability and distribution, etc. In our proposal, instead of proposing general use of this concept, our work focuses on the management of software architectures based on our COTSget components. Therefore, inspired by the use of these components in models as services and as a mechanism for access to these models through web services deployed in the cloud, we have created a cloud service called COTSgets-as-a-Service. To provide this service, a cloud infrastructure organized in three layers has been created (Fig. 1): the client layer (C), the platform-dependent server layer (B) and the platform-independent server layer (A).

The client layer is made up of user applications, and therefore, it comprises the set of components defining the final software architecture. Currently, all the developed applications are deployed on the web platform and have been implemented using widgets, following the recommendation of W3C. The platform-dependent layer is intended to (1) provide the client with the required services and (2) interact with the independent layer, thus obtaining some services from it and providing it with others. The platform-independent layer offers those services which are valid for all platforms. These services are based only on the description of components and their relationships, regardless of the platform where components will be deployed.

This article is based on previous research work [43] in the field of distributed development of information systems [34]. In that work, the system infrastructure focusing on the three-level data model used in the different layers of our architecture is described. The work presented in this manuscript focuses on the technological infrastructure based on web services and cloud computing used for the deployment of COTS component-based architectures.

The rest of the paper is organized as follows: Section 2 shows an example of an scenario where the most important concepts used in the rest of the article are explained. Section 3 describes the languages proposed (using an MDE perspective) for describing COTSget-based architectures. Section 4 explains how the COTSgets-as-a-Service is provided using a cloud service. Section 5 illustrates the process used to validate and evaluate the cloud service and its performance. Section 6 presents the related work and, finally, Section 7 summarizes the conclusions and discusses the future work.

This section describes a web-based application as a sample scenario to explain many of the concepts used in the rest of the article. This application (Fig. 2
                     ) was dynamically constructed from COTSgets components for the abovementioned ENIA research project. The application deals with a geographic information query system, with which visual layers with this type of information can be loaded. These layers provide data acquired from a set of Open Geospatial Consortium (OGC) services provided by the REDIAM (Environmental Information Network of Andalusia).

The components in this application are not assembled alone (independently of each other), but rather coupled, as described below, to help designers build complex interactive applications. In the upper right-hand corner of the figure, there are two components: UserInfo and Logout. The first one is responsible for identifying the user who has connected and showing user-specific information, such as the profile they are currently using in the system, and the Logout component closes that user's session. These two components are not isolated from each other. In fact, there is a component called Header, which in addition to controlling the display in the top bar of the user interface, joins the two components. Thus, the Header manages the access to the system. Below the menu bar are components specific to the user profile and their role in the system. One is the Map component, which is responsible for displaying the geographical information found in layers from OGC services. Nevertheless, this component does not let the user indicate which layers are to be displayed. For this, this component is related to the LayerList (top left) which provides it with the required information.

In addition, the web application displays certain information about the layers being viewed on the map at any given moment. This is done by the Legend component (left center), and as with the Map component, it acquires the necessary information from the LayerInfo component. Continuing examination of the figure, at the bottom there is a report (in table format) in the middle and two graphs (a pie chart and a bar chart) on the left. Both the report (ReportResults component) and the graphs (Piechart and Barchart components) only display information. Another component (TableParser) is responsible for generating the information and providing it where it is needed. Finally, on the right, there is an external RSS service for REDIAM notices. This service, which has been encapsulated in a component (called RSS), is an example of how services or external components can be seamlessly integrated in our architecture, although with some limitations.

As seen in the example, it is possible to build web applications where the components can be used for several purposes, e.g., to interact with the user, display information, for background activities (with no user interaction), to group others and form more complex components, or to integrate third-party resources. This diversity is analyzed in detail in Subsection 3.1. All the components that can be used in an application can be described by a set of abstract components [41]. The right-hand side of Fig. 2 shows an abstract representation of the sample web application scenario. This figure shows only the components which include a user interface. Therefore, the TableParser component does not appear in it. The proposed component-based architecture model with which the visual component mode can be disabled so only their features can be worked with, is more easily understood in this figure. Having described the example scenario, the structure of our component architecture and the relationships that exist between the various elements involved in this architecture are examined below.

This section describes how our COTSget-based architectures are defined. We use a design inspired by MDE to build a Domain-Specific Language (DSL) of the architecture, as can be seen in the metamodel of Fig. 3
                     . This metamodel defines the abstract syntax of our DSL and is described using object-oriented constructs [13] because we use MOF [29] as our metamodeling language. This representation helps us to understand the different parts that make up the architectures.

Looking at the figure, our architectures are composed of two types of models, the Abstract Architectural Model and the Concrete Architectural Model. As described in the Introduction, the former identify abstract components, that is, the types of components an architecture must include to be considered correct. On the other hand, the concrete architectural models identify the concrete components that have been selected as a solution for the types defined in the abstract architectural models. Furthermore, both types of architectural models identify the relationships and links which can be established among components, as described below. This article focuses on the concrete architecture models as discussed in the introduction. Therefore, hereafter, our discussion about component architectures refers to architectures of concrete components.

In the proposed language, a concrete architectural model consists of a set of individual components (ConcreteComponent) and a set of relationships (Relationship) among them. Each component has a type, defined by ComponentType. The container component type identifies a component that contains other components. This makes it possible to build more complex components from more basic ones. The functional component type is used to construct functional components, which do not include user interaction, and therefore, can be built to execute background code (internal code of the component). The userInteraction component type is used to build components that include user interaction or simply display information. Finally, the normal component type is the union of functional and userInteraction component types, components that include interaction with the user and the internal functionality of the component. These types define all the components present in a user interface.

Furthermore, concrete components contain a list of the properties (RuntimeProperty) that have been modified or that should be taken into account at run-time. Each component has a list of ports (Port) which are responsible for communication between components, and each component has a reference to its corresponding specification (ConcreteComponentSpecification). In the following section, this specification, the types of components and ports associated with them are discussed in detail. The DSL also considers the relationships (Relationship) among components. Each relationship connects two or more components simultaneously and may be formed by Connector-type elements. A Connector represents the link that allows us to send information from the output ports to the input ports. Relationships can be Binary or Nary. Binary relationships are established between two different components (e.g. association, composition, etc.). N-ary relationships are composed of at least two binary relationships and are therefore related to at least three components of the architecture (e.g. hierarchy, sequence, etc.). These relationships are described more in detail in Subsection 3.2.

Not all the constraints of our architectural model can be expressed in a metamodel. To do this, a set of OCL (Object Constraint Language) constraints has been defined, which help these restrictions to be formally described and improve our models, making them coherent and reliable. Below, we describe some examples of these restrictions on the relationships between components. Our language allows only a single relationship between two components, i.e., a single binary relationship with source in component A and target in component B. Therefore, the first constraint is as expressed in OCL1 of Fig. 4
                     . This constraint is basic to our architectures and helps restrict possible relationships among components, making them more manageable and useful.

The second constraint indicates that if the relationship between two components A and B is two-way, then there are at least two connectors, one with origin A and destination B, and another connector with origin B and destination A (OCL2 of Fig. 4). Therefore, at least one output port of the first component must be connected to an input port of the second, and vice versa. Furthermore, a component must have at least one port, however, the restriction is stronger, since it must have at least one input port (OCL3 of Fig. 4). We therefore check that among a component's ports, there is at least one that is an InputPort.

The DSL shown in Fig. 3 allows us to formally describe the structure of our component-based architectures. Therefore, our proposal must start from some initial applications (UI in the proposed example domain). Then, these initial application are manually represented (by developers) though their corresponding architectures, performing an abstraction process. Then, the applications (which are being executed on the client side) and the architectural models (which are being managed on the server side) must always be synchronized. On one hand, the changes performed on the client side are communicated to the server side. On the other hand, if the cloud service changes (proactively) the architecture (adding new components, removing unnecessary elements, etc.), the changes in the new model are propagated to the client side. In the case of web user interfaces, the HTML code of the user interface is modified and reinterpreted at run-time.

As stated above, our concrete architecture model consists of a set of individual components. Each component has to be specified using a DSL. Fig. 5
                         shows the part of the metamodel which describes the internal structure of those components. Each component is composed of four parts: Functional, ExtraFunctional, Packaging and Marketing. Only the Functional and ExtraFunctional parts have been expanded in the figure, because they are essential for understanding the internal structure of a component. When a component is built, all parts must be specified except for the ExtraFunctional part, which is optional. The Marketing part of a component identifies the information related to the entity that developed the component, such as the name of the organization, contact name, etc. The Packaging part provides information on the component's packaging, such as identifying the repository where the component is located, the programming language used for it, etc.

The ExtraFunctional part identifies the set of extra-functional properties that a component can have. These properties may provide information on NFPs (Non-Functional Properties), quality of service (QoS), component appearance, such as width, height, etc., and any dependencies on other components. The Functional part is described in more detail, since it is fundamental to be able to understand a COTSget component's structure. Each component implements its own functionality, both related to the interaction with the user (InteractionContent) and the internal component itself (Core-Content). Both features are optional, and therefore, developers can build a component to suit their needs.

There are different types of components (identified by the componentType attribute of Fig. 3), depending on which functional parts are implemented:
                           
                              •
                              
                                 Functional Component: this type of component implements only the internal functionality (CoreContent), and not functionality related to user interaction. It can be used to perform background tasks, such as accessing a database. In our example scenario, the TableParser component is a functional component responsible for generating information related to reporting results and table formatting. This component does not interact with the user or display information on the screen. Once the component has generated the data, it sends this data to the ReportResults component for displaying the information on the screen.


                                 User Interaction Component: this type of component only includes functionality associated with user interaction (InteractionContent). It can also be used to display reports or graphical information. There are several components of this type in our example scenario. For instance, the Map component is used to display a map and interact with it, and the layers that have been selected are shown in the LayerList component.


                                 Container Component: this type of component has neither internal functionality nor functionality related to user interaction. A container is composed of several components for carrying out a common task or purpose. An example of this type is the Header component in our example scenario. This component contains the UserInfo and Logout components, and is used to control system access. The Header component is a good example of how a set of components can be used to create a more complex common task.

In addition to the functionality that can be implemented in a component, the Functional part includes the specification of two interfaces, the (InteractionInterface) and the (ControllerInterface). The user interacts with the component to enter data or receive information by means of the interaction interface. User events supported by the component are managed in this interface depending on the device used for handling the component. The component developer should provide the setting in which that component is executed (e.g., mobile environment, desktop, etc.), so its functionality can be developed according to the specific events of that setting. This means that the components depend on their setting. The controller interface is used for communication between components. It is comprised of a set of provided (ProvidedInterfaces) and required (RequiredInterfaces) interfaces, with the constraint that each component must have at least one provided interface. The provided interfaces define all the component functionality visible to the outside world, i.e., it describes methods that can be invoked to make the component perform some operation. The required interfaces describe the operations belonging to other components invoked by a component for its full and proper operation.

Both types of functional interfaces (provided and required) are defined using the structure specified by WSDL (Web Services Description Language), as seen in the WSDLSpecification concept. This language was chosen because the component interfaces can be described in terms of operations, including definition of the types of input and output. This specification uses the portType concept, defined in WSDL 1.1 (http://www.w3.org/TR/wsdl), as a root element for describing each of the interfaces. Fig. 6
                         shows the specification of an interface (PortType). Each interface has an identifier, so each interface in the same component can be referred to univocally, and a set of operations (Operation) with which information can be sent (Output) or received (Input). An interface must always have an input operation and, optionally an output operation. The input operation may or may not be formed by a set of input elements (InputElement) while the output operation consists of one or more output elements (OutputElement). Each Element defines its name, type and, optionally, the minimum (minOccurs) and maximum (maxOccurs) number of times it must be present.


                        Fig. 7
                         shows a fragment of the specification of the provided interface manageLegend from the Legend component, taken from our sample scenario. This interface describes two operations, loadLegend and removeLegend (lines 44 and 48). The first is a “request–response” type, since it defines an input message and an output, while the second is a “one-way” type, since it only defines an input message (lines 45–46 and 49–50).

Moreover, the data definitions describing the structure of these messages can be seen in lines 9–32. For example, the loadLegend operation receives the URL as input of an OGC service followed by a list of the layers belonging to the service to be loaded in the component caption (lines 17–18). As output, the operation returns the result of its execution in a text string (line 23), that is, whether it has been properly executed or if an error has occurred.

In order to meet the component specification, the functionality implemented in a component must be defined in the InteractionContent and CoreContent, and these must invoke the corresponding ControllerInterface operations if is intended for the component to send/receive information to/from other component(s) via ports. Since each component may be viewed as a black box, the only information that can be obtained from a component is the information it provides through its ports. To summarize, this subsection describes the component structure and conditions that must be fulfilled to be considered a COTSget which can be part of our approach.

The section above described the internal component structure by examining its parts and identifying the different types that exist. In this section, we describe the next aspect included in an architecture, the relationships between components. As discussed above, each component is related to other(s) by relationships, leading to different forms of communication between them. Before listing the set of relationships between components, the concept of a relationship must be defined. Every relationship connects a component with other(s) through the entry and exit ports of these components, i.e. if there is a relationship between two components, at least one set of output ports of a component must be connected to a set of input ports of another component.

The connection between two ports of two different components is called a connector (Connector concept in Fig. 3). Fig. 8a shows an example of a concrete component, while Fig. 8b shows an example of two components connected by their ports. As can be seen in Fig. 8b, there may be ports in the components which have no connectors and therefore do not participate in the architecture. These ports may be linked by other relationships or may not be used in a specific system. Therefore, depending on the application being implemented and the relationships defined in the architectural model, some ports or others are used. Fig. 8b also shows the connections in the relationship between the Legend and LayerList components from the example. It should be noted that the functional interfaces defined in the specification (Fig. 5) are translated to the corresponding communication ports of each component defined in the architecture (Fig. 3).

Once the connectors have been defined, the relationship concept can be defined. A Relationship (see Fig. 3) is used to connect two or more components at once, allowing them to communicate. The relationships between components can be Binary or N-ary. Binary relationships are between two different components. These relationships have a boolean property called isBidirectional, to indicate whether the components involved are connected and the what one does affects the other and vice versa. A connector goes between two ports, one input and one output, from each of the components in a relationship. Binary relationships also include the BinaryType concept, which identifies the types of binary relations, and therefore, different possible behaviors in such links.

To understand the meaning of these connections more easily, the relationships among the components of the example scenario are identified in the model of Fig. 9
                         (ports are hidden in the diagram to highlight the relationships). The source elements of the binary relationships are represented by a line with no arrow, and the target elements are depicted with a line ending in an arrow. The association relationship is the least restrictive link and it exists when a default relationship is established between two components A and B. This relationship is used to represent the regular exchange of information between two components, where such exchange cannot be represented by any of the other relationships. An example of this relationship appears for instance between the Header and LayerList components. This relationship represents request of user information to the Header component by the LayerList component. When this component builds the list of layers available for display, it attempts to acquire information from the other using one of its methods. However, if the component is not available or is not in the architecture, LayerList will display a list of default layers. This behavior of weak dependence forms an association-type relationship.

The composition relationship is used when all of the interfaces of B are in A. Any component wishing to access B must do so through A. This relationship is used to create components from other components. Thus a component can contain one or more components which together perform a specific task or purpose. An example of a composition relationship may be seen in the Header, UserInfo and Logout components. The Header component is a container type component containing the other two components. Thus all outward operations by the UserInfo or Logout components, and all requests for the methods of these two components coming from the outside, must be made through the ports of the Header component. Therefore, if the Map component wants to communicate with the UserInfo component, invocation of the corresponding operations must be go through the Header component. The Header and Map components must be linked by a relationship, and they can communicate with each other by exchanging messages because they share the same parent.

The dependence relationship appears when a component A cannot exist without a component B. In our example scenario, this relationship appears between the Logout component and the UserInfo component. The first depends on the second given that, without the necessary information about the users and their session, it is impossible to execute the closing operations, and therefore, cannot function correctly. This strong dependence forms a dependence-type relationship.

There is an inheritance relationship when a component A includes all the ports that have been defined in a component B. This relationship does not appear in our example scenario. Nevertheless, should we assume a component called MapDB connected to the Map component by this relationship. This component would include all the ports (and therefore the entire functionality) defined in the map. Furthermore, it would be able to implement new functionalities such as, saving the search history in a database. These new functionalities could optionally be offered using additional ports of the MapDB component.

The last binary relationship is called producer–consumer. This relationship exists when, in a relationship between A and B, A produces information which B consumes. This relationship is very useful in cases of access to databases by the producer component, which supplies information (modified or not) to the consumer component. In our example scenario there are various producer–consumer relationships. One case of this type may be found in the LayerList and the Map components. The former acts as the producer supplying the OGC services needed to be visualized on the map by the latter.

All these relationships between two components cover a wide range of possible scenarios in the construction of component-based systems. Furthermore, when building such architectures, there may be more complex patterns involving two or more binary relationships (and consequently, three or more components). These combinations of binary relationships and components identify specific situations with a particular behavior. In such cases, we propose use of the N-ary relationship concept, which is defined as a set of binary relationships.

The first N-ary relationship identified is called sequence. This relationship gives the order of a set of components for carrying out a shared task. A graphical representation of this relationship can be seen in Fig. 10a. An example of this N-ary relationship is the one between the LayerList, Map and Legend components, formed by the two binary producer–consumer type relationships that link the LayerList and Map, and LayerList and Legend components, respectively. The N-ary relationship sequence describes the execution order by the source and target elements of each binary relationship. The first source element identifies the first element to execute its operations, and the last target element is the last component to be executed.

Another N-ary relationship is the hierarchy existing when all the components in the set have an inheritance relationship with their parent component (see Fig. 10b). This relationship defines an inheritance tree made up of all the components in the relationship. A trading relationship exists when one of the components carries out a mediation task (see Fig. 10c). As may be seen, an association relationship exists between component X and component Y. When component T trades, it defines how components X and Y must communicate with each other.

The observer, controller and sink relationships have similar structures, defined graphically in the shape of a star in which the relationships arriving or leaving the center component, change. The observer relationship implies that the central component (component O in Fig. 10d) carries out observation tasks on all the other components and acts accordingly. The controller relationship implies that the central component (component C in Fig. 10e) does not only observe, but also sends control orders to the other components. Therefore, although the binary relationships linked are the association type, this N-ary relationship is stronger than the observer relationship. Finally, the sink relationship is one in which the central component (component S in Fig. 10f) is the receiver of the information generated by the other components involved in the relationship. Therefore, all its binary relationships are the producer–consumer type, in which the consumer is the central component.

The use of these relationships allows us to establish additional information among the components which form part of the architectures. In this sense, this extra information is used for managing the different states and uses of the architectures during their execution. Having defined the internal structure of the COTSgets components and the major relationships, the next section describes the cloud service implemented for managing the proposed component-based architectures.

Based on the definitions of the architectures, components and their relationships, this section describes the cloud service developed for supporting the management of architectures at run-time. These architectures represent software applications of coarse-grained components which have a structure that can be changed dynamically and components that communicate with each other by exchanging messages through input and output ports. Moreover, the models containing the architectural definitions must always be synchronized with the application that is running on the client, as mentioned above.

The main purpose of this cloud service is to offer the operations required to ensure these capabilities of the COTSget component-based architectures. It therefore includes: (a) management of the COTSgets specifications, (b) management of the COTSgets-based architectures, (c) instantiation of COTSgets components, (d) initialization of user applications based on the architectures, and (e) communication of components belonging to an architecture. All these capabilities are offered at run-time to dynamically provide architecture and component models, thus using the Models-as-a-Service term for establishing the concept of COTSgets-as-a-Service. Furthermore, this service makes the main parts (such as the databases of components and architectures, the platform independent server or the platform-independent server) highly scalable and distributable as additional benefits derived from the cloud computing [44]. Moreover, the purpose of this service is to support interactive systems running on different platforms. Nevertheless, the current version of this cloud service only supports the management of component-based applications on the web platform.

The proposed service is based on a three layer infrastructure: the client layer, the platform-dependent server layer and the platform-independent server layer. The client layer consists of user applications. The components of these applications use the web platform (such as web-based technology) and have been implemented by widgets as recommended by W3C. These applications are deployed on a web browser. The platform-dependent layer constitutes the middle layer of the system infrastructure. This layer provides the client with the required services and interacts with the independent layer, thus obtaining a number of services from it and providing it with others. The platform-independent layer provides the services that are valid for all the platforms. Its functionalities are based on the component descriptions and their relationships, regardless of the platform on which they are deployed.

The following subsection describes the two layers of servers. Then, in Subsection 4.2, some implementation details related to the deployment of the three layers are examined.

The infrastructure proposed consists of a set of servers located in the dependent and independent platform layers. To describe the operation of these servers, we refer to the diagram shown in Fig. 11
                        , which shows (1) the representation of the run-time behavior and (2) the different parts of the infrastructure which are involved in its implementation. The platform-dependent layer is the middle layer of the infrastructure, and is responsible for providing the applications that are running on the client layer with the necessary services and communicating with the platform independent layer. The following services are offered to the client application layer:
                           
                              •
                              
                                 Initial loading of the application: when an application is started (Fig. 11 task (a)), the components that make up the application must be loaded. The platform-dependent layer supports this initial loading by means of a web application server (task (b)), because, as already stated above, it is only currently possible to construct web-platform applications. During loading, the layer interacts with the browser where it is deployed to acquire and embed the widgets used to build the user interface on the website (task (c)). This service is managed by a Node.js server (http://nodejs.org).


                                 Component repository support: As the applications are made of components, there must be a server to manage the repositories of these components. This essentially consists of creating and obtaining instances of widgets (task (d)). Different repositories will exist depending on the platform on which they are run. For components implemented with widgets, an Apache Wookie server is used (http://wookie.apache.org).


                                 Communication between components: the dependent layer indirectly manages the communication established among components (widgets), i.e. it is not responsible for calculating the communication paths, but for receiving and sending messages to and from the components. To manage this service a Node.js server is used. This communication may be necessary for various reasons, for instance, for user interaction with the application (task (e)). When messages are sent, the client is responsible for receiving and executing the corresponding operations resulting from the communication (task (f)).

By interacting with the independent layer, the dependent layer requires a series of services (task (g)) and provides the independent layer with others (task (h)). With the services required, the dependent layer obtains the code necessary to create the initial web application and also consults which route the information should follow for components to be able to communicate with each other. This is achieved using a web service implemented in the independent layer. The dependent layer also offers information to the independent layer about the components it manages, such as the address of the widget instances that it uses to generate the application code.

The platform-independent layer supports different platforms and offers a number of features related solely to the description of the components and their relationships, regardless of the specific platform on which they are deployed. In terms of deployment, each platform has certain particularities which must be taken into account, for example initializing a web user interface may be different from initialization a component architecture in a Java implemented application, or invocation of methods between components as part of a communication task. However, there is a part in common, the abstract view of the behaviors that can be extracted and implemented independently of the platform.

Therefore, the services offered in this layer are the same for all platforms, although depending on the case, invocation of internal services is related to the specific behavior for each platform. This mechanism hides the specifics of each platform from the outside and enables our approach to be modular and scalable, allowing the progressive addition of new features to any new platforms that may support the system in the future. The independent layer has been implemented with a single server. This server (called COScore, Cotsgets-based architecture Operating Support core) forms the core of the management of component-based architectures. Its basic functions are:
                           
                              •
                              
                                 Initialize the architecture of concrete components: when a new client initiates the connection to the system, the component architecture that is to be provided must be acquired (task (i)). Therefore, the corresponding component instances are created (task (j)) and it returns the data structure to be represented by the architecture. In the particular case of web user interfaces, this service is responsible for initializing the widget-based UI and returning the associated code (task (k)).


                                 Obtain the communication relationships between components: as mentioned above, this layer handles component communication indirectly. This COScore service is responsible for providing routing information for messages between components (task (l)) i.e., it calculates which components should receive a message using a message send request that comes from the dependent layer. For this purpose, the information held on the component architecture and the relationships between these components is used (task (m)).

These services are the only ones published externally, although there is a number of internal services which complement the behavior of the above. To summarize, these internal services include:
                           
                              •
                              
                                 Initialize COScore services: all the data structures necessary are constructed when the system is booted, so all the services offered can be managed (task (n)).


                                 Read the concrete component model: the architectural model (corresponding to the application) is acquired with the client information provided by the application (task (o)).


                                 Generate a data structure for routing: A data structure representing its component relationships is generated from the architecture model (task (p)). Recall that these relationships are used for communication between components. This data structure must be updated each time the architecture model is modified.


                                 Create instances of the architecture components (task (q)): the component instances are also constructed from the architecture model and information about them is associated with the corresponding client.


                                 Generate the code of the architecture (task (r)): this service builds the code compiled or interpreted for the platform on which the architecture is deployed.

To make the structure of the infrastructure proposed more easily understood, this section shows some implementation details. For a complete view, we present some code fragments related to the client, the platform-dependent and the platform-independent layers in three different tables. These tables share a common example scenario in which a mashup user interface is initialized and then, a communication process is performed between two components. The first column in the tables gives the execution order and includes some information about the component containing the piece of code and the main purpose of the implementation fragment.

Starting from the client layer, the user interfaces are developed sharing common web technologies such as HTML, CSS and JavaScript. To register the user interface in the system, the web user interface must be connected to the platform-dependent layer. So the client needs to establish a socket connection with the Node.js server and to request its GUI initialization (Fig. 12
                        -step#1).

Moreover, the application is waiting for a message with the HTML code of the widgets it needs for them to be added to the user interface (Fig. 12-step#7). The result is that the HTML code of the widget-based user interface is deployed in the client layer (Fig. 12-step#8). For each widget to communicate with the Node.js server, there must be a connection to it and a statement of the input and output ports (this code is contained in each widget). Fig. 12-step#9 shows the code executed when the interaction with the LayerList component requires information to be sent to the platform dependent layer about the layers which have to be loaded. Fig. 12-step#12 shows the Map component connection and the statement of an input port called loadLayer. This input port receives the information generated by the interaction mentioned in Fig. 12-step#9 from the platform dependent layer. This implementation of ports is specific for web platforms and corresponds to the interface definitions managed by the COScore server (see Subsection 3.1).

On the platform-dependent layer, we have deployed two servers: an Apache Wookie server and a Node.js server. The first server allows us to deploy widgets based on the W3C specification (http://www.w3.org/TR/widgets/). The components resident in the server are used for the web platform case, where graphical user interfaces are built from widgets. This server provides an API (http://wookie.apache.org/docs/api.html) based on REST services [38] for managing of widgets (insertion, elimination, modification, creation of instances, etc.). In our approach, the server is deployed at http://acg.ual.es/wookie and an example address of the Map component for user1 would be:

http://acg.ual.es/wookie/deploy/acg.ual.es/wookie/widgets/Map/index.html?idkey=tuV6YYw9ztkjVRHkTC6NDz25D.sl.Y.eq.&proxy=http://acg.ual.es:80/wookie/proxy&st=.

In this link, the address http://acg.ual.es/wookie/widgets/Map is the component identifier, and tuV6YYw9ztkjVRHkTC6NDz25D.sl.Y.eq. is the user's instance identifier.

The second server is a JavaScript server, called Node.js, which can be used as a link between the client and the platform-independent server. We use sockets to manage communications with Node.js. This requires installation of the socket.io module (http://socket.io). An example of its use may be seen in the code of Fig. 13
                        -step#2. In this code, the Node.js server establishes an input port initGUI at initialization (connection). This input port is invoked from the client web application to initialize the user interface and, consequently, the COScore web service in charge of getting the components is called up. The result is sent through the output port addComponent to the web client. Another example is shown in Fig. 13-step#10. This code sets up an input port (send) which is invoked from the client layer to solve the communication process of the components. Again, a COScore web is invoked (in this case, calculatedConnectedPorts) and then, the information is routed to the corresponding components through the calculated ports.

To invoke the SOAP-based web services, the node-soap module (https://github.com/vpulim/node-soap) needs to be installed. In the code fragment shown in Fig. 13-step#3, this module is used to create a SOAP client which invokes the corresponding web service method and returns the result. Implementation of GUI initialization is used as an example to describe client-layer deployment. The code shown in Fig. 12-step#1, which is in charge of starting the connection between the web application and the Node.js server, must be included on the client side. Next, it sends a message with its user identifier through the initGUI port to initiate the interface. It also establishes an input port called addComponent which is called from the code described in Fig. 12-step#7. This port adds the widgets to the web interface. A code fragment from the widget-based web application resulting from initialization may be seen in Fig. 12-step#8.

A JBoss application server has been deployed (http://www.jboss.org/jbossas) for the platform-independent layer. This application server offers a set of web services developed with JAX-WS [7] which are called up by SOAP messages from the platform-dependent layer [22] and offer the functionalities of the independent layer. All COScore modules (capacities) are implemented by EJB [30] and internally managed by this server's lookup mechanisms and different types of session beans (stateful, stateless and singleton). Following the code fragments above, there is a service in charge of resolving the initial widget list to be inserted in the web user interface (called initGUI).

This service is responsible for reading the data structure that represents the user interface architecture. It is also in charge of creating the corresponding HTML code that will be deployed by the client (Fig. 14
                        -step#4). Widget instances are created for this purpose with REST services by using the Wookie API (Fig. 14-step#5), and then, the HTML code is constructed using the information from the instances previously created (Fig. 14-step#6). Another example of these services is shown in Fig. 14-step#11. This service implements calculation of which components (and through which ports) are going to receive the information obtained from client interaction.

This section shows the process used to validate and evaluate the cloud service and its performance in managing COTSgets-based architectures. The previous section described the infrastructure supporting our proposal, explained how it has been deployed, and provided implementation details. Nevertheless, a performance evaluation is also required to validate our approach. Performance is measured in terms of the execution and response times observed in the two main processes of the service developed. These two processes are: (1) initialization of the GUI, and (2) communication between the components present in the GUI.

To this end, we performed several different tests to analyze our setup's behavior by taking three parameters that could affect performance into account. These parameters are: (a) the size of the initial GUI loaded and shown to the user, (b) the coupling degree of the architecture, i.e., the number of connections between components, and (c) the number of concurrent users accessing at the same time. We know that there are other input parameters affecting response times, such as network latency or the browser used by the client, among others. However, to ensure correct system performance, only experiments with manageable or limitable features were done. To execute these experiments and measure the performance times, we used a computer with an Intel(R) Core(TM) i5 CPU 660 @ 3.33GHz, with 4GB of physical memory and running under Windows 8.1 Professional 64 bits operating system. This machine included the platform-dependent and independent servers. For testing purposes, a web application was developed as a client. Each response time is calculated as the average of 100 repetitions of the same test unit.

As the proposed infrastructure has three layers (see Fig. 11), firstly, we evaluated the times measured in (A), (B), and (C), as shows Fig. 15
                     . The time obtained in (A) is the execution time of the functions implemented in the independent layer server (COScore). Then, the time in (B) is derived from (A) but it includes the time it takes for the behavior implemented in the platform-dependent layer. Finally, (C) represents the total time elapsed between the time the client calls and the moment a response is received and shown to the user. Fig. 16a shows the response times for the GUI initialization when the number of components is varied. The differences between times measured in (A), (B) and (C) are very small. Therefore, the following performance times are focused on the time (C), because it is the longest time (in fact, it is equal to the total process time) and corresponds to the real time the user has to wait for a response from the service.

The first group of tests was intended to evaluate the performance of the GUI initialization. We evaluated the times obtained for different initial GUI models with 1, 2, 3, 5, 10, and 20 components as shown to the user. These sizes were chosen since GUIs (developed within our COTS-based architectures) are usually made up of less than 20 components. For example, a typical user interface with only one component in the aforementioned domain is a GUI composed by a map with geospatial information. In addition to the map, the user interface may contain a legend component and/or a component with a list of the layers shown, thus forming typical examples of GUIs with two and three components. Due to visual limitations and typical user preferences, the normal scenario is to manage GUIs with a maximum of four, five or six components. For completeness, we included experiments with 10 and 20 components so performance could be tested under less favorable conditions. At the very least, the results allow us to infer the response times for scenarios with additional components. We also evaluated performance with “low”, “medium” and “high” coupling. If “n” is the number of GUI components, low coupling means that there are fewer than “n−1” communications between components. High coupling means that the number of communications is over “n∗n (n−1)/2”, and medium coupling is an intermediate number. Fig. 16b shows the results of this test. It is worth mentioning that the times shown in Fig. 16a correspond to the times shown in Fig. 16b for medium coupling.

We can arrive at three conclusions from Fig. 16a and b: (1) the response times rise in proportion to the number of components, (2) the coupling degree does not affect (or has an insignificant influence on) performance, and (3) performance is suitable for GUI initialization, since the worst response time is below 600ms, resulting in a good user experience. Nevertheless, we performed another group of tests to evaluate the initialization by concurrent users, to test performance in a real exploitation/production environment. An excerpt of the results of this experiment is shown in Fig. 17
                     , where rows (U
                     
                        i
                     ) are the response times when different numbers of concurrent users i accessed the user interface, and columns (C
                     
                        i
                     ) are the size of the model loaded. Low, medium and high coupling are represented by “l”, “m” and “h”, respectively. Performance is measured in milliseconds.

When multiple concurrent users simultaneously make a request for GUI initialization, the server side is not able to respond to all users at the same time. Therefore, the “min” column in Fig. 17 gives the time taken for the first user to receive the response and complete the initialization process. The “max” column depicts the time taken for the last user to receive the response and complete the process. Fig. 8 shows a representation of the results (one for model).

From the results depicted in Fig. 17 and the different graphs in Fig. 18
                     , we are able to draw the following conclusions: (1) “min” response time remains almost constant and is not affected by the number of concurrent accesses, (2) “max” response time increases in proportion to the number of concurrent users, (3) the larger the GUI model is, the higher the increase in “max” value, and (4) GUI architecture coupling does not influence performance even if the number of concurrent users is increased (as we mentioned above for one user, see Fig. 16b). The results in Fig. 18 are summarized in the graphics shown in Fig. 19a and b, which represent the lowest and highest times achieved, respectively.

Performance in these experiments is relatively good in terms of response times for GUI initialization with different numbers of concurrent users. Nevertheless, for models with 10 components the response time experienced by the last user (“max” value) begins to exceed acceptable levels (3.5s) once there are over 40 concurrent requests for access. For models with 20 components, the highest response time (over 3.6s), with over 25 concurrent initializations, is excessive. The reason the number of concurrent users influences the response time is because the application server (i.e., the platform-independent server) which has some points in common (shared EJBs) is accessed by all the users and a bottleneck may be created. An example of this is the EJB in charge of managing the user sessions. We therefore performed another experiment, in which we tried to lower the response time and improve performance. In this test, we deployed two and three platform-independent servers and balanced the workload by distributing the requests among the servers. The results are shown in Fig. 19c.

Due to the results of the experiment we decided to deploy our cloud service infrastructure with two platform-independent servers instead of one or three. This decision was based on two factors: (a) the use of more than one server is useful to avoid a bottleneck in the system, and (b) using more than two servers takes longer to choose the target server and affects performance. Fig. 19c shows that the improvement in results using three servers is the same for “max” times, but worse for “min” times.

We measured the communication response times with different numbers of components and with different coupling. For practical reasons, we did not perform the test with low architecture coupling, because there are very few connections enabling communication. In addition, we only performed the test for GUIs with 3 to 20 components, as these scenarios provided sufficient connections to evaluate the process. Fig. 19d shows the results of the experiment. The response times for the communication remain under 100ms for “medium” coupling and less than 140ms for “high” coupling. These times grow in proportion to the number of components, but on a very low gradient. We can therefore assert that communication is executed within a suitable length of time.

@&#RELATED WORK@&#

The use of cloud-based computing, as previously described in [33], offers a number of advantages for both users and organizations who want to make better use of the resources they manage. Among the benefits identified, that study refers to the use of SaaS, and specifically of MaaS as a software element with a high level of abstraction which systems can use at any time, for example, to build software “top-down” from an approximation. The MaaS concept as an on-demand decision element that could be used by a software system was introduced in [4] and has had numerous applications since then. For example, in [32], the authors make use of this concept to provide data and decision analysis in model form from expert knowledge and an automatic modeling system. In [6] benefits that can be obtained from the MaaS concept and the use of models with cloud computing are also identified. In this work, the authors highlight aspects such as the availability of these models, run-time sharing, improved scalability and distribution, possible implementation, adaptation and evolution of these models or even building mashups, such as a combination of MDE services offered by different “vendors”.

Inspired by this concept and the use of the mechanism for accessing models through web services, we have also made use of cloud computing and models as services in our proposal. Nevertheless, instead of proposing general use of this concept, our work focuses on software architecture management based on specific named components such as COTSgets. We also show the use of the system developed to manage and communicate graphical user interfaces constructed from these components.

The MaaS concept was also used in [20] to identify ecological models represented and stored by a web system, for customers who would like to share this information for management and decision-making. Other authors [40], have demonstrated its potential uses, the challenges to be addressed and provided a case study of its use for a task which analyzed risk of oil spills. Other works [21] propose a definition of web service interface and a specification for data exchange to describe and offer “water resources” as web services.

Other projects for enhancing interoperability of models which represent geospatial information and its access have used web services, and attempted to make these services increasingly reusable [36]. Our proposal also uses this mechanism for accessing models with services. However, although we also use geospatial information as a domain, because our research is linked to a regional project called ENvironmental Information Agent [18], the models which we access through the cloud represent the structure of widget-based GUIs and it is precisely these medium or high-granularity graphical components which are reused in our system.

Therefore, the domain could be any other application using a graphical interface in which components may be developed as widgets. Looking to the future, we believe that our proposal could be extended to other domains in which our COTSgets do not represent GUI widgets, but rather are used to describe software architectures based on components from other areas, such as home automation [7], robotics [17], communication network infrastructures [19], etc.

Some studies have integrated the use of cloud computing with user interfaces in the domain of our proposal (i.e. UI). In [24] the authors work with Android devices to achieve more flexibility in the user interfaces by making use of information about the environment (for example, with an ambient light sensor, battery status, user interaction, etc.). The service we have developed is also designed to store information about the environment, including the ability to capture the user's interaction with the components because of Node.js server communication management. In the literature, there are other notable works that are not directly related to cloud computing, but with GUIs built from components or services. In [45] the authors analyzed the features of building mashup GUIs using W3C widgets, and proposed an extension of the widget model. The reason for extending this model is to support a variety of component communication patterns. In contrast, our proposal developed a mechanism that hides the communication process in the W3C component implementation, by using communication ports. In [26], the authors proposed use of MDA modeling to develop Web 2.0 applications such as mashup. For UML constraints they make use of a profile developed specifically for this domain. In our case, instead of a UML profile, we restricted the modeling language by using a domain-specific language [23] to describe our architectures and COTSgets component types.

@&#CONCLUSIONS AND FUTURE WORK@&#

This paper presents an infrastructure developed for managing component-based architectures by using web services. The proposal takes a general approach so it can be applied to any type of software architecture. Nevertheless, the architectures in our proposal must be defined using a DSL developed for the purpose. This language allows us to define which components are present in the architecture and how they relate to each other. For a description of these relationships, our language can define different types of binary and N-ary relationships between components, providing information about communication and interaction between them. In addition, this language describes how the architectural components are connected at the port level.

Our approach proposes the use of another DSL to specify components. Thus, the possible application domains are restricted to those software architectures built from components that meet our component definition. We call our type of component COTSget, from the combination of COTS and “gadget” where gadget may be any software appliance that can work alone or as a piece of architecture. Such components are medium or high-granularity that encapsulate some functionality and can interact with other elements of the architecture through their interfaces. Therefore, inspired by the description of third-party COTS components, our DSL defines interfaces, properties and dependencies. This language can also provide some information about the implementation, packaging and marketing of each component.

As has been noted in the metamodels, which represent the syntax, both languages have been defined using MDE technologies. As a result, our proposal benefits from all the development and implementation mechanisms and tools that exist within this paradigm. In this sense, the article provides some examples of OCL constraints that are applied in the construction of our models, enabling syntactic and semantic checks that cannot be expressed through the sole use of metamodels.

Building on established foundations, this paper demonstrates a three-layer implementation infrastructure based on web services and cloud management for component-based software architectures. The three layers consist of a client-side layer and two layers on the server side, one being dependent on the platform and the other platform-independent. The platform-independent layer includes all the management services of the architectures common to all possible platforms, such as management of communication between components. Platform-dependent layer management provides the services that are particular to a specific platform, such as creating instances of widget-like components for the web platform. The client layer is where the final software architecture opens and interacts with the platform-dependent server layer to resolve all the required services.

A component-based prototype developed in the domain of user web interfaces is given as a specific application platform. Within this domain, a web interface that serves as a “running example” throughout the article is shown to explain the definitions of architectures and components and the three-layer infrastructure. To make it easier to understand how the platform works, the technology deployed to solve the infrastructure proposed is shown, and specific examples of functionalities and their implementation are provided.

In summary, the main contributions of the approach presented in this paper are the following:
                        
                           (a)
                           A three-layer infrastructure for managing component-based software.

This infrastructure is based on a cloud service, increasing access, scalability and availability of resources and services.

Different layers allows us to separate the operations concerning platform-independent and platform-independent architectures.

A DSL is proposed for defining architectures of COTSget components.

Another DSL is used for specifying each COTSget component.

Architectures and components are managed using MDE technologies, favoring formal descriptions and the persistence of these formal definitions.

Apart from its contributions, our approach has some limitations that must be taken into account. One of the most important shortcomings is the mandatory adaptation of components and architectures to fit the proposed languages. Furthermore, only those components which (a) can be implemented following the specifications and (b) are intended to communicate with other components of the architecture can be part of this approach.

Other limitations are more related to its practicality. Therefore, as future work, we intend to apply the infrastructure to different real systems, and provide it with new capabilities. One of our main goals is to apply elements from the field of “Business Intelligence” [35] and its uses from cloud computing through “Big Data” [1]. Big Data involves a massive amount of data collected from different sources over time and aims to facilitate the task of analyzing this data using cloud services. Thus, in our approach, user interaction with the components could be recorded for future decision making, for example, to tailor the user interface to their specific needs.

Furthermore, the languages developed for specifying components and architectures can be applied to different fields and platforms. Although this paper shows an example for application in web technologies, we intend to extend the use of our infrastructure to other scenarios such as home automation or robotics. These scenarios widen the validity of our research and open new lines to improve our proposal.

Regarding the use of MDE technologies, there are different possibilities that can greatly complement this work. Processing operations or refactoring of models can be used to adapt or modify software architectures (at run-time), for example, from changes in context or due to user interaction [39]. Both the use of mediators and solutions based on “trading” can also provide an interesting mechanism for the resolution of different platform-dependent configurations from the same platform-independent architecture [8].

In addition, we want to improve the evaluation of this approach with incorporation of the analysis of the suitability of the generated mashup applications. Other aspects such as user experience and comparison with other component models, can be also incorporated.

@&#ACKNOWLEDGMENTS@&#

This work was funded by the EU ERDF and the Spanish Ministry of Economy and Competitiveness (MINECO) under Project TIN2013-41576-R, and the Spanish Ministry of Education, Culture and Sport (MECD) under a FPU grant (AP2010-3259), and the Andalusian Regional Government (Spain) under Project P10-TIC-6114. This work was also supported by the CEiA3 and CEIMAR consortiums.

@&#REFERENCES@&#

