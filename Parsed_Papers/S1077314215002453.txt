@&#MAIN-TITLE@&#Texture modelling with nested high-order Markov–Gibbs random fields

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Texture models with heterogeneous sets of features are learnt sequentially.


                        
                        
                           
                           Parameter learning can be omitted.


                        
                        
                           
                           Local binary patterns with learnt offsets are introduced as MGRF features.


                        
                        
                           
                           Methods of gradually or immediately selecting the offsets are compared.


                        
                        
                           
                           The models are promising for texture synthesis and inpainting.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Texture synthesis and analysis

High-order MRFs

Local binary patterns

Structure learning

@&#ABSTRACT@&#


               
               
                  Currently, Markov–Gibbs random field (MGRF) image models which include high-order interactions are almost always built by modelling responses of a stack of local linear filters. Actual interaction structure is specified implicitly by the filter coefficients. In contrast, we learn an explicit high-order MGRF structure by considering the learning process in terms of general exponential family distributions nested over base models, so that potentials added later can build on previous ones. We relatively rapidly add new features by skipping over the costly optimisation of parameters.
                  We introduce the use of local binary patterns as features in MGRF texture models, and generalise them by learning offsets to the surrounding pixels. These prove effective as high-order features, and are fast to compute. Several schemes for selecting high-order features by composition or search of a small subclass are compared. Additionally we present a simple modification of the maximum likelihood as a texture modelling-specific objective function which aims to improve generalisation by local windowing of statistics.
                  The proposed method was experimentally evaluated by learning high-order MGRF models for a broad selection of complex textures and then performing texture synthesis, and succeeded on much of the continuum from stochastic through irregularly structured to near-regular textures. Learning interaction structure is very beneficial for textures with large-scale structure, although those with complex irregular structure still provide difficulties. The texture models were also quantitatively evaluated on two tasks and found to be competitive with other works: grading of synthesised textures by a panel of observers; and comparison against several recent MGRF models by evaluation on a constrained inpainting task.
               
            

@&#INTRODUCTION@&#

Texture modelling is central or important to many computer vision and image processing tasks such as image segmentation, inpainting, texture classification or synthesis, anomaly (defect) detection, and image recognition. Although successful specialised algorithms for texture classification, synthesis and segmentation have been developed, generative probabilistic models which offer relatively complete models of statistics of individual textures are appealing. They may be applied not only to all of the above tasks, but to anywhere appearance priors or feature extraction are needed, and they are also of interest to understanding human vision. Generative models must capture most of the features of a texture that are significant to human perception in order to be successful, whereas texture features used for discrimination need not.

The most prevalent tool for image and texture modelling are Markovian undirected graphical models, a.k.a. Markov random fields (MRFs). An MRF together with an explicit Gibbs probability distribution (GPD) is called herein a Markov–Gibbs random field (MGRF). MGRFs are particularly popular for image analysis involving the determination of boundaries (as in segmentation) or enforcing smoothness (e.g. in stereoscopic matching and image denoising). In these cases the Markov networks are usually sparse, with the directly interacting neighbours of each variable being close by. Some high-order MGRF models have been proposed for such tasks (e.g. [1,2,11]), and for binary variables efficient maximum a posteriori (MAP) algorithms exist, such as graph cuts [3]. However things are different in the domain of image and texture modelling, where inference needs to be performed on real-valued or highly multivalued image variables in dense Markov networks. The networks used in this paper typically have Markov blankets containing 50–100 nearby and distant pixels, and even sampling from the models proves to be difficult.

MGRFs and other probabilistic texture models reduce images g to a vector of statistics of image features f(g), which are assumed sufficient to describe the texture. The model is completed by assigning an energy ϕ to each feature vector, giving a Gibbs probability distribution over images:

                        
                           (1)
                           
                              
                                 
                                    
                                       
                                          p
                                          (
                                          g
                                          )
                                          ∝
                                          exp
                                          (
                                          −
                                          ϕ
                                          (
                                          f
                                          (
                                          g
                                          )
                                          )
                                          )
                                          .
                                       
                                    
                                 
                              
                           
                        
                     Historically statistics of pairs of pixels [4–6] were used. However higher-order MGRFs (which cannot be expressed in terms of lower order ones), have become more common as they are recognised to be necessary for more expressive models of natural images and textures (e.g. [2,7–11]). Higher order interactions in image models allow for abstracting beyond pixels, building upon larger scale image attributes like edges, and for context and complex structures to be captured. In addition, since regularly tiled textures have strong long range correlations between nearby tiles it is natural to learn an interaction structure (i.e. the pattern of statistic dependences between pixels) specific to the texture. Yet it is still almost unheard of in computer vision and image modelling for higher-order MRF structure to be learned rather than hand selected.

However, selection of high-order features poses significant problems. The cardinality of a space of possible feature functions grows combinatorially in the order, due to both freedom in the shape of the support (variables/pixels to select as input), and the need to reduce or manage its high dimensional input domain. In other words the features should be parameterised with a reasonable number of parameters. The higher-order MGRFs in use nearly exclusively apply linear filters as feature functions, with statistics of the filter responses, such as means and variances [12], correlations [13], or histograms [14] forming a description vector. For texture classification many other methods of extracting useful information out of a high dimensional pixel co-occurrence matrix have been investigated (e.g. [15,16]). Dimensionality can be reduced by making assumptions such as that images are invariant to contrast and offset changes. However this approach has seemingly been little-applied to generative texture models.

In order to tackle these problems, we build texture models by a model nesting procedure which greedily selects features and can build higher order features by composing lower order ones. Unlike some other works (e.g. [13,14]) we do not attempt to provide a fixed set of statistics/texture features to distinguish between all textures (a goal with the Julesz conjecture [17] as its origin), but rather learn texture-specific features. This potentially provides compact representations while still allowing a large and varied space of descriptors. Each nesting iteration corrects statistical differences between the training image and the textures class given by the previous model, as sketched in Fig. 1
                     .

Contributions of this paper are as follows: (i) We efficiently select high-order features by “nesting” models with heterogeneous features/potentials, while coping with the difficulties of inference in dense MGRF texture models. Unlike the model nesting used previously in [14,18] we do not learn maximum likelihood estimate (MLE) of parameters at each nesting iteration, which is very expensive, but instead generate images which match the current statistical constraints (Section 4.3). These are equivalent to samples from the ideal maximum likelihood (ML) model. Correct parameter learning can be delayed until afterwards. We use no hidden variables as is currently popular which eases learning and inference, with parameter learning remaining convex in theory. (ii) We extend the very popular local binary pattern (LBP) descriptors of images by learning the offsets of the surrounding pixels (Section 4.6) for use as high-order ‘binary pattern’ (BP) MGRF texture features. These are quite different from the common high-order linear filtering or Potts potentials, and faster to compute than responses of large linear filters. LBPs have apparently never been used in this way despite enormous popularity as image descriptors. Experiments into texture synthesis using MGRFs with LBP histograms as sufficient statistics can provide insight into the visual features actually captured by the LBPs. (iii) We compare several families of nested texture models utilising different high-order features, including different methods of selecting BP offsets. The resulting texture models have heterogeneous feature sets composed of second-order grey level difference (GLD) features, and of up to 13th-order BP features or Laplacian of Gaussian and Gabor filters. The use of learned long range GLD interactions allows almost-regular (tiled) textures in particular to usually be synthesised well. (iv) The ability of the proposed procedure to learn characteristic features across different types of textures is demonstrated with texture synthesis across a varied set of greyscale textures, also evaluated by a panel of observers, along with several other comparisons. (v) In order to improve generalisation and to attempt to allow partially inhomogeneous training images a variant of the MLE was used, such that the training image is split into pieces and the minimum of the likelihoods of the pieces rather than their product is maximised.

@&#RELATED WORK@&#

Much research in texture analysis has focused on describing textures using the distributions of responses of square linear filters. MGRF texture models utilising non-trivial filters were introduced with FRAME [9,14], where the filters were selected from a manually-specified bank. More recently learning the filters themselves (with predetermined fixed supports) has been popularised by the Field-of-Experts (FoE) model [10]. These model the marginal distribution of responses for each filter with hand-picked potentials with few parameters; in the original FoE model they are Student t-distributions. Therefore the interaction structure is learned as filter coefficients. FoE was extended to bimodal FoE (BiFoE) which uses more informative bimodal potentials, and successfully applied to texture modelling by Heess et al. [8]; several state of the art generative texture models have been built on BiFoE, some using various configurations of hidden variables. Kivinen and Williams [19] improved on BiFoE by using gated MRFs [20], and Luo et al. [21] investigated convolutional deep belief networks (DBN) and spike-and-slab potential functions. However because of learning difficulties and to reduce required computation all these learned-filter models have been restricted to relatively small filter sizes. These do not directly capture distant interactions; the largest filter size used in the mentioned works was 11 × 11. As a result, while these filter-based MGRFs model certain classes of textures excellently, they have inherent weaknesses. A more general survey of MRFs which covers high order models can be found in [11].

The recently popular hierarchical filter-based MRFs are a merger of MRF models, especially Boltzmann machines, and models of single image patches using independent components analysis [22] and overcomplete Product-of-Experts [23]. These are applied to larger images by tiling and overlapping the filters. Today MRFs including latent variables are popular, often inspired by simple and complex cells in the visual cortex, with strong links to convolutional artificial neural networks. Using multiple layers allows application to high level computer vision tasks where the Markov property does not hold, such as object recognition and face modelling. In many cases integrating out the latent variables leads to a completely connected, non-Markovian interaction graph. We diverge from this direction to consider the direct inclusion of higher-order features in models, which is more common for other machine learning tasks where there often is no analogue to linear filtering.

Various high-order local texture descriptors have been applied to texture classification (e.g. [15,16,24]) going back at least 20 years. For such applications, invariances to contrast, offset, scale, rotation, and deformation are given particular weight. Non-linear texture features have also been used in MGRF texture models; Sivakumar and Goutsias [25] introduced MGRF texture models which used sophisticated multi-scale features defined through mathematical morphology. Many sought to directly reduce the dimensionality of high-order co-occurrence histograms through traditional techniques such as spectral clustering of histogram bins [26], vector quantisation [16], Gaussian mixture models [24], and self-organising maps [15]. However such dimensionality reduction techniques usually require a nearest-neighbour search to map new data points, which likely makes them unsuitably slow as feature functions in MGRFs.

Probably the most popular texture descriptors for discrimination are LBPs [27], which compare the intensities of a ring of pixels 
                           
                              
                                 p
                                 1
                              
                              ,
                              …
                              ,
                              
                                 p
                                 k
                              
                           
                         around a central one p
                        0, and form the bit-vector (pi
                         > p
                        0)1 ≤ i ≤ k
                        . These are nearly contrast- and offset-invariant and can be straight-forwardly extended to rotation invariance [28] by merging bins, and extended to partial scale invariance by using multiple concentric rings. In addition to their proven ability to distinguish textures LBPs are also very cheap to compute, hence we investigate their use in texture modelling. Nosaka et al. [29] introduced co-occurrence statistics of neighbouring LBPs in a way that is rotationally invariant, This is particularly interesting for future extension of the BP-based MGRFs in this paper to rotational invariance. LBPs have inspired a number of other variants such as local ternary patterns (LTPs) [30], and local radial index [31]. Liu et al. [32,33] have also used LBPs, LTPs, and related non-linear “ordinal” texture descriptors with learnt offsets, and applied them to texture classification and retrieval. Although explained within the framework of MGRFs, these approaches do not involve learning a complete MGRF model. They built up the higher-order cliques (up to 20th order) out of the lower-order ones by searching for cliques in an interaction graph computed using a thresholding rule. We find this too restrictive and pursue alternative strategies for selecting the offsets.

A method for selecting the features of the model which is both intuitive and theoretically sound is to use greedy sequential structure selection, as has been used by various authors [14,18,34–36] with a number of details varying. This alternates between adding one or more features/factors to the current model from a candidate set according to an estimate of the best feature to add, and then finding the new MLE of the parameters (initialised at those from the previous iteration). The most common metric for selecting the best feature to introduce is to select that with the largest ‘error’ between training image and model synthesis result [14,34,35]. This paper follows the same general approach, which we call ‘nesting’, although we describe our particular flavour. The main difference in our approach is to attempt to directly generate images matching the statistics at each iteration, learning approximate parameters as a side effect.

Della Pietra et al. [18] treated structure learning in MGRFs (for natural language processing problems) as a feature selection problem, and built up higher order features out of lower order ones. Several other authors have since considered selecting MGRFs features by gradually composing together low order atomic features ‘general-to-specific’ (e.g. [37,38]), or by starting from template-like features (sometimes called ‘patterns’) which are conjunctions of simple 
                           
                              
                                 x
                                 i
                              
                              =
                              
                                 c
                                 j
                              
                           
                         predicates, derived directly from the training data and gradually generalising them ‘specific-to-general’ (e.g. [39]).

A closely related popular method for MGRF structure learning is the use of sparsity-inducing L
                        1 regularisation [35,40], which forces some feature weights to exactly zero so that they can be removed. Otherwise proceeding like nesting, this approach has the advantages that the regularisation combats overfitting, that it allows removing a feature after it has been added, and is a convex problem. Recently Chen and Welling [41] suggested the use of spike-and-slab priors (similar to L
                        0 regularisation) instead of L
                        1 regularisation. This has some advantages, but does not also lead to an efficient greedy algorithm with an optimality guarantee.

Practical texture synthesis is currently dominated by algorithms which combine pieces of a source image so that the pieces fit together well. This is defined in terms of the match between neighbourhoods of the pieces. Region-growing techniques add one pixel (e.g. [42,43]) or patch (e.g. [44,45]) to the image at a time. Algorithms are often multiscale [43,46,47]. However all these synthesis algorithms have the property that they copy large parts of the source image directly into the result, either an explicit part of the algorithm, or an emergent property of the algorithms’ search for best matching neighbourhoods, due to ‘forced moves’.

Another rather successful but not realtime class of texture synthesis algorithm is based on global optimisation of the image such as by projection onto the set of images with certain statistics equal to those of the training image, in particular statistics of wavelet-decompositions [12,13]. A codebook of texture patches or primitives can also be used instead  [48]. These are implicitly MRF texture models as they provide no explicit probability distributions (hence our discrimination between MGRFs and MRFs) and so are less broadly applicable than probabilistic models. Hence, although these give good synthesis results these algorithms in fact attack a different problem than the more statistical one that this paper does; we use texture synthesis only for evaluation.

This section provides first some definitions, and then defines general exponential distributions as the conceptual and theoretical basis for MGRF model nesting. A description of the nesting algorithm follows.

Any probability distribution which is nowhere-zero can be represented as a GPD factorised into Gibbs factors: functions of complete subgraphs (cliques) of the Markov network. In this paper we consider the class of MGRFs with factors (synonymously, potentials) that can be described as the product of a fixed feature function—identifying a certain signal configuration (pattern)—and a corresponding weight/parameter.

We restrict our scope to modelling of homogeneous textures by repeating the Gibbs factors and cliques across the image to achieve translation invariance. Let 
                           
                              R
                              ⊂
                              
                                 Z
                                 2
                              
                              ,
                           
                         where 
                           Z
                         are the integers, be a finite lattice of image coordinates and 
                           
                              
                                 α
                              
                              =
                              
                                 {
                                 
                                    α
                                    i
                                 
                                 :
                                 
                                    α
                                    i
                                 
                                 ∈
                                 
                                    Z
                                    2
                                 
                                 ;
                                 1
                                 ≤
                                 i
                                 ≤
                                 d
                                 }
                              
                           
                         be a list of d coordinate offsets with 
                           
                              
                                 α
                                 1
                              
                              =
                              
                                 (
                                 0
                                 ,
                                 0
                                 )
                              
                           
                         fixed. An order d clique family C
                        
                           
                              α
                           
                         in 
                           R
                         is the set of all spatially repeated cliques with the offset pattern given by 
                           α
                        :

                           
                              
                                 
                                    
                                       
                                          
                                             
                                                C
                                                
                                                   α
                                                
                                             
                                             :
                                             =
                                             
                                                {
                                                
                                                   (
                                                   
                                                      r
                                                      1
                                                   
                                                   ,
                                                   …
                                                   ,
                                                   
                                                      r
                                                      d
                                                   
                                                   )
                                                
                                                :
                                                
                                                   r
                                                   1
                                                
                                                ,
                                                …
                                                ,
                                                
                                                   r
                                                   d
                                                
                                                ∈
                                                R
                                                ;
                                                
                                                
                                                   r
                                                   i
                                                
                                                −
                                                
                                                   r
                                                   1
                                                
                                                =
                                                
                                                   α
                                                   i
                                                
                                                ;
                                                
                                                i
                                                =
                                                1
                                                ,
                                                …
                                                ,
                                                d
                                                }
                                             
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        Let 
                           
                              g
                              :
                              R
                              →
                              {
                              0
                              ,
                              …
                              ,
                              Q
                              −
                              1
                              }
                           
                         be an image on 
                           R
                         with Q possible grey levels. An order d feature is a function 
                           
                              f
                              :
                              
                                 
                                    {
                                    0
                                    ,
                                    …
                                    ,
                                    Q
                                    −
                                    1
                                    }
                                 
                                 d
                              
                              →
                              
                                 N
                                 s
                              
                           
                         with finite range 
                           
                              
                                 N
                                 s
                              
                              :
                              =
                              
                                 {
                                 1
                                 ,
                                 …
                                 ,
                                 s
                                 }
                              
                           
                         and an associated clique family Cf
                         given by offset list 
                           α
                        
                        
                           f
                        . The histogram of values of f collected over an image g is the vector

                           
                              (2)
                              
                                 
                                    
                                       
                                          
                                             
                                                h
                                                f
                                             
                                             
                                                (
                                                g
                                                )
                                             
                                          
                                       
                                       
                                          
                                             =
                                             
                                                [
                                                
                                                   ∑
                                                   
                                                      c
                                                      ∈
                                                      
                                                         C
                                                         f
                                                      
                                                   
                                                
                                                
                                                   [
                                                   
                                                      [
                                                      l
                                                      =
                                                      f
                                                      
                                                         (
                                                         
                                                            g
                                                            c
                                                         
                                                         )
                                                      
                                                      ]
                                                   
                                                   ]
                                                
                                                
                                                :
                                                
                                                l
                                                ∈
                                                
                                                   N
                                                   s
                                                
                                                ]
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where [[ · ]] is the Iverson bracket mapping true ↦1, false ↦0, and g
                        
                           c
                         is notation for sequence of pixels 
                           
                              g
                              
                                 (
                                 
                                    r
                                    1
                                 
                                 )
                              
                              ,
                              …
                              ,
                              g
                              
                                 (
                                 
                                    r
                                    d
                                 
                                 )
                              
                              ,
                           
                         
                        ri
                         ∈ c, c a clique. The order of a model is defined as the maximum order of any of its features.

In the nesting procedure, new features to be added to the current model are selected based on the disagreement between their statistics in the training image and the model’s expected statistics, approximated from model samples. In this way the model is modified to correct these errors. When the statistics in question are expectations (equivalently, histograms), these corrections take a particularly simple form.

Let 
                           
                              F
                              
                                 i
                                 +
                                 1
                              
                           
                         be a set of feature functions and let the histogram vector 
                           
                              
                                 f
                                 
                                    i
                                    +
                                    1
                                 
                              
                              
                                 (
                                 g
                                 )
                              
                           
                         be the concatenation of histograms for the set 
                           
                              F
                              
                                 i
                                 +
                                 1
                              
                           
                        : 
                           
                              
                                 f
                                 
                                    i
                                    +
                                    1
                                 
                              
                              
                                 (
                                 g
                                 )
                              
                              :
                              =
                              
                                 [
                                 
                                    h
                                    f
                                 
                                 
                                    (
                                    g
                                    )
                                 
                                 :
                                 f
                                 ∈
                                 
                                    F
                                    
                                       i
                                       +
                                       1
                                    
                                 
                                 ]
                              
                           
                        . A general exponential family model [49] is a probability distribution which can be written in the following form specified by a base model pi
                        (g), a vector-valued feature function 
                           
                              
                                 f
                                 
                                    i
                                    +
                                    1
                                 
                              
                              
                                 (
                                 g
                                 )
                              
                              ,
                           
                         and a parameter vector 
                           
                              
                                 
                                    θ
                                 
                                 
                                    i
                                    +
                                    1
                                 
                              
                              ,
                           
                        
                        
                           
                              (3)
                              
                                 
                                    
                                       
                                          
                                             
                                                p
                                                
                                                   i
                                                   +
                                                   1
                                                
                                             
                                             
                                                (
                                                g
                                                |
                                                
                                                   
                                                      θ
                                                   
                                                   
                                                      i
                                                      +
                                                      1
                                                   
                                                
                                                )
                                             
                                             =
                                             
                                                1
                                                
                                                   Z
                                                   (
                                                   
                                                      
                                                         θ
                                                      
                                                      
                                                         i
                                                         +
                                                         1
                                                      
                                                   
                                                   )
                                                
                                             
                                             
                                                p
                                                i
                                             
                                             
                                                (
                                                g
                                                )
                                             
                                             exp
                                             
                                                (
                                                −
                                                
                                                   f
                                                   
                                                      i
                                                      +
                                                      1
                                                   
                                                
                                                
                                                   (
                                                   g
                                                   )
                                                
                                                ·
                                                
                                                   
                                                      θ
                                                   
                                                   
                                                      i
                                                      +
                                                      1
                                                   
                                                
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where Z(
                           
                              
                                 θ
                              
                           
                        ) is a normalisation factor, and · denotes dot-product. In our case, the parameters are a concatenation of per-feature parameter vectors 
                           
                              
                                 
                                    θ
                                 
                                 
                                    i
                                    +
                                    1
                                 
                              
                              =
                              
                                 [
                                 
                                    
                                       θ
                                    
                                    f
                                 
                                 :
                                 f
                                 ∈
                                 
                                    F
                                    
                                       i
                                       +
                                       1
                                    
                                 
                                 ]
                              
                           
                        .

If one wishes to find a model 
                           
                              p
                              
                                 i
                                 +
                                 1
                              
                           
                         meeting constraints to be satisfied in the form of expectations 
                           
                              
                                 E
                                 
                                    p
                                    
                                       i
                                       +
                                       1
                                    
                                 
                              
                              
                                 [
                                 
                                    f
                                    
                                       i
                                       +
                                       1
                                    
                                 
                                 
                                    (
                                    g
                                    )
                                 
                                 ]
                              
                              =
                              
                                 f
                                 
                                    i
                                    +
                                    1
                                 
                              
                              
                                 (
                                 
                                    g
                                    ∘
                                 
                                 )
                              
                           
                         (where g° is given training data), but already has prior information expressed as a base model (in this case the model at the previous iteration, pi
                        ), then it is widely known [18] that the probability distribution 
                           
                              p
                              
                                 i
                                 +
                                 1
                              
                           
                         which matches the new constraints but deviates from the base model the minimum possible amount (as measured by the Kullback–Leibler divergence, i.e. has maximum entropy relative to pi
                        ) has a simple form. It is the general exponential family model given in (3) with the MLE of the parameters 
                           
                              
                                 
                                    
                                       θ
                                    
                                 
                                 
                                    i
                                    +
                                    1
                                 
                                 *
                              
                              :
                              =
                              arg
                              
                                 max
                                 
                                    θ
                                 
                              
                              
                                 p
                                 
                                    i
                                    +
                                    1
                                 
                              
                              
                                 (
                                 
                                    g
                                    ∘
                                 
                                 |
                                 
                                    θ
                                 
                                 )
                              
                           
                        . It can be seen from Eq. (9) that the ML parameters achieve the desired statistical constraints. Technically, the MLE 
                           
                              
                                 
                                    θ
                                 
                              
                              
                                 i
                                 +
                                 1
                              
                              *
                           
                         may lie at an infinitely distant point in parameter space, which is not permitted by the usual definition of a GPD. This possibility is easily avoided by slightly smoothing 
                           
                              
                                 f
                                 
                                    i
                                    +
                                    1
                                 
                              
                              
                                 (
                                 
                                    g
                                    ∘
                                 
                                 )
                              
                           
                        .

The challenges of both selecting high-order features and structure can be met by gradually building up features from pieces, reducing the set of candidate features to a size that can be exhaustively searched at each iteration. One could reasonably expect that when some configuration of pixels (as recognised by a feature function) is characteristically common for a texture, that the configuration restricted to a subset of pixels would usually also be common. Hence we conjecture that in practice high-order feature functions picking out characteristic interactions can be found by building up from lower order features.

From the theory of general exponential distributions we can see that there is no need to modify whatever parameters the base model may have, although in most previous works involving sequential structure learning this is normally done as it allows increasing the likelihood. However to attempt to reduce overfitting we suggest that it is reasonable to only adjust parameters associated with the new features 
                           
                              f
                              
                                 i
                                 +
                                 1
                              
                           
                        . Dudík et al. [50] described such a coordinate-wise descent algorithm for a wide class of generalised maximum-entropy problems which selects a best single parameter to update on each iteration. They state the standard approach of updating all parameters each iteration “is impractical when the number of features is very large”. However in our experiments we found that this was too aggressive a solution to overfitting, and obtained better results by keeping all parameters free.

Given a set of feature functions Fi
                        , having already been selected, a selector function C(Fi
                        ) is defined to provide a candidate set of new features, possibly built upon previous features. The algorithm proceeds stage-wise through a sequence of selectors 
                           
                              
                                 C
                                 1
                              
                              ,
                              …
                              ,
                              
                                 C
                                 k
                              
                           
                         each providing features of a certain order and type, to avoid the problem of comparing across feature types. Sequential selection simply selects one or more feature functions among Cj
                        (Fi
                        ) on which the current model pi
                         has the largest disagreement (error) against the training data e(f) ≔ d(h
                        
                           f
                        (g°), h
                        
                           f
                        (g
                        (i))), where d is a distance function on histograms. The next selector in the sequence is proceeded to after 
                           
                              
                                 max
                                 
                                    f
                                    ∈
                                    
                                       C
                                       j
                                    
                                    
                                       (
                                       
                                          F
                                          i
                                       
                                       )
                                    
                                 
                              
                              d
                              
                                 (
                                 
                                    h
                                    f
                                 
                                 
                                    (
                                    
                                       g
                                       ∘
                                    
                                    )
                                 
                                 ,
                                 
                                    h
                                    f
                                 
                                 
                                    (
                                    
                                       g
                                       
                                          (
                                          i
                                          )
                                       
                                    
                                    )
                                 
                                 )
                              
                           
                         becomes too small, and the algorithm terminates when the selectors are exhausted.

One possible variant is to use separate training and validation datasets, and to stop when performance (measured either by d or an application-specific external evaluation function such as texture discrimination accuracy) on the validation begins to decrease. Such a validation test was used in the earlier work [51], in order to detect slightly non-homogeneous textures. This paper takes the idea further that statistical variations across the training data are important: Section 4.1 discusses the selection of features from a set of pieces of the training images rather than less powerfully only looking for variation between a single training and validation pair.

Previous sequential feature selection implementations have used ℓ1 
                        [14,40] or ℓ2 distance or ‘gain’ for d. Gain is the increase in information contained in a model (equivalently, decrease in entropy) due to adding a feature to it, and can be either be estimated analytically [9] or, at great expense, by actually comparing every possible extended model [18]. Zhu et al. [9] also gave a correction to the gain for theoretical uncertainty in the estimated statistics, which is a form of the Akaike information criterion (AIC), penalising model complexity.

However, real uncertainty in estimates found through Markov chain Monte Carlo (MCMC) sampling from a MGRF is typically vastly larger than theoretical estimates of uncertainty because the sampling may not converge (see Section 4.3). This is especially true because the quality, and also statistics, of the approximate samples that we attempt to rapidly draw from the current texture model are highly variable.

We used the Jensen–Shannon divergence (JSD) [52] for distance function d as a proxy to the additional information content of h
                        
                           f
                        (g°). The JSD is defined as

                           
                              
                                 
                                    
                                       
                                          
                                             
                                                D
                                                
                                                   JS
                                                
                                             
                                             
                                                (
                                                p
                                                ∥
                                                q
                                                )
                                             
                                          
                                       
                                       
                                          
                                             :
                                             =
                                             
                                                1
                                                2
                                             
                                             
                                                (
                                                
                                                   D
                                                   
                                                      KL
                                                   
                                                
                                                
                                                   (
                                                   p
                                                   ∥
                                                   m
                                                   )
                                                
                                                +
                                                
                                                   D
                                                   
                                                      KL
                                                   
                                                
                                                
                                                   (
                                                   q
                                                   ∥
                                                   m
                                                   )
                                                
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where D
                        KL is the Kullback–Leibler divergence (KLD), p and q are probability distributions, and m is the averaged distribution 
                           
                              
                                 1
                                 2
                              
                              
                                 (
                                 p
                                 +
                                 q
                                 )
                              
                           
                        . The JSD measures the discriminability of two distributions, namely the average certainty (as measured in bits) with which a sample can be ascribed to one or the other. The JSD is symmetric, bounded in the range [0, 1] bits (when computed using base 2 logarithms) and is popular because it is suitable for comparing two empirically estimated distributions, unlike the KLD, which is often undefined. In practice, the JSD usually provides very similar rankings to the ℓ1 distance.


                        Algorithm 1
                         summarises this approach. Fig. 2
                         gives examples of its operation, starting from the initial model (from which the first sample is drawn) which included only marginal and nearest-neighbour pairwise potentials and proceeding through two selectors. The first selector returns three pairwise potentials at a time. Frequently, there is no visible improvement from one step to another, however even the samples getting worse do not indicate that the model is getting worse, due to the unstable sampling process. There is also usually a big jump as each new class of features is added, and decreasing returns thereafter. Determining a suitable stopping point for model learning is difficult, as the histogram distances e(f) do not reflect visual proximity to the training image very well, and a texture similarity metric such as improved structural texture similarity (STSIM2) [55] might be a better option. For experiments in this paper we instead used a fixed 8 iterations for each selector, as this removes the variability due to an imperfect stopping rule, which can have a large effect. Fig. 3
                         shows the cliques selected in two of the examples in detail.

The procedure described above is generic and could equally well be applied to learning MGRF models for machine learning tasks outside of computer vision. Its refinement specific to texture-modelling, including some of our implementation details is given below.

Broadly, there are two ways to achieve desired invariances: by designing the models to enforce those invariances (e.g. by using feature functions with some invariance property), or by learning them from suitable training data which demonstrates them. We use both approaches, although the latter is only preliminarily developed here.

Up to now, we have described model learning in terms of maximising the total probability of the training image, but the sufficient statistics of the image are the mean values of the feature functions over the image. This is completely oblivious to variations across the image, and for this reason some small parts of the training image may actually have low probability. This is particularly true of textures composed of large randomly distributed textons (coherent texture elements like pebbles or grass blades), which greatly reduces the effective amount of training data, and thus is the most difficult to learn for all kinds of MGRF models. At one place in the image or over the whole image a particular angle or offset between textons may be more common than the average just by chance. Just like humans, sequential feature selection easily sees patterns in noise. We have already made the assumptions that the texture is homogeneous with the Markovian property and that the entire training image is a sample from the texture class, without foreign inclusions. We can thus expect that every piece of the training image of sufficient size (which we term the “scale” of the texture) is itself also a visually recognisable sample of the texture class, while those much smaller aren’t, and thus the model should also recognise them. The scale will be approximately equal to once to twice the tessellation offset if the texture is regular, related to the size of any textons that the texture is composed of, and in general similar to the spatial extent of the Markov blanket. Indeed, this property holds for all of the training images used in our experiments. Hence, it is unsatisfactory that only averages over the training image are considered, and we propose to switch away from the ML as our objective.

Let 
                           
                              {
                              
                                 g
                                 i
                                 ∘
                              
                              }
                           
                         be a set of training images. In practice we simply split a single training image g° into pieces of size 80 × 80 with overlap of 22 pixels. This is related to the maximum offset length between interacting pixels that we search for, 40 pixels. We change our optimisation problem to

                           
                              (4)
                              
                                 
                                    
                                       
                                          
                                             
                                                max
                                                
                                                   p
                                                   ,
                                                   
                                                      θ
                                                   
                                                
                                             
                                             
                                                min
                                                i
                                             
                                             ℓ
                                             
                                                (
                                                
                                                   θ
                                                
                                                |
                                                
                                                   g
                                                   i
                                                   ∘
                                                
                                                )
                                             
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        It is perhaps desirable to use a smoothed differentiable version of the objective using a ‘soft-min’ instead of min,

                           
                              (5)
                              
                                 
                                    
                                       
                                          
                                             
                                                max
                                                
                                                   p
                                                   ,
                                                   
                                                      θ
                                                   
                                                
                                             
                                             
                                                ∑
                                                i
                                             
                                             ℓ
                                             
                                                (
                                                
                                                   θ
                                                
                                                |
                                                
                                                   g
                                                   i
                                                   ∘
                                                
                                                )
                                             
                                             w
                                             
                                                (
                                                
                                                   g
                                                   i
                                                   ∘
                                                
                                                
                                                |
                                                
                                                p
                                                
                                                   (
                                                   ·
                                                   |
                                                   
                                                      θ
                                                   
                                                   )
                                                
                                                )
                                             
                                             ,
                                          
                                       
                                    
                                 
                              
                           
                        where w weights the pieces exponentially according to their proximity to the minimum (which is easy to compute):

                           
                              (6)
                              
                                 
                                    
                                       
                                          
                                             w
                                             (
                                             
                                                g
                                                i
                                                ∘
                                             
                                             |
                                             p
                                             )
                                             :
                                          
                                       
                                       
                                          =
                                       
                                       
                                          
                                             
                                                exp
                                                (
                                                −
                                                α
                                                ℓ
                                                
                                                   (
                                                   
                                                      θ
                                                   
                                                   |
                                                   
                                                      g
                                                      i
                                                      ∘
                                                   
                                                   )
                                                
                                                )
                                             
                                             
                                                
                                                   ∑
                                                   j
                                                
                                                exp
                                                
                                                   (
                                                   −
                                                   α
                                                   ℓ
                                                   
                                                      (
                                                      
                                                         θ
                                                      
                                                      |
                                                      
                                                         g
                                                         j
                                                         ∘
                                                      
                                                      )
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                          =
                                       
                                       
                                          
                                             
                                                exp
                                                (
                                                −
                                                α
                                                
                                                   θ
                                                
                                                ·
                                                h
                                                
                                                   (
                                                   
                                                      g
                                                      i
                                                      ∘
                                                   
                                                   )
                                                
                                                )
                                             
                                             
                                                
                                                   ∑
                                                   j
                                                
                                                exp
                                                
                                                   (
                                                   −
                                                   α
                                                   
                                                      θ
                                                   
                                                   ·
                                                   h
                                                   
                                                   
                                                      (
                                                      
                                                         g
                                                         j
                                                         ∘
                                                      
                                                      )
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where α is a softness parameter.

This objective implies that when selecting features we replace the criterion

                           
                              
                                 
                                    arg
                                    
                                       max
                                       f
                                    
                                    d
                                    
                                       (
                                       
                                          
                                             h
                                             f
                                          
                                          ¯
                                       
                                       
                                          (
                                          
                                             g
                                             
                                                samp
                                             
                                          
                                          )
                                       
                                       ,
                                       
                                          h
                                          f
                                       
                                       
                                          (
                                          
                                             g
                                             ∘
                                          
                                          )
                                       
                                       )
                                    
                                 
                              
                           
                        with one of

                           
                              (7)
                              
                                 
                                    
                                       
                                          
                                             arg
                                             
                                                max
                                                f
                                             
                                             
                                                min
                                                i
                                             
                                             d
                                             
                                                (
                                                
                                                   
                                                      h
                                                      f
                                                   
                                                   ¯
                                                
                                                
                                                   (
                                                   
                                                      g
                                                      
                                                         samp
                                                      
                                                   
                                                   )
                                                
                                                ,
                                                
                                                   h
                                                   f
                                                
                                                
                                                   (
                                                   
                                                      g
                                                      i
                                                      ∘
                                                   
                                                   )
                                                
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           
                        or

                           
                              (8)
                              
                                 
                                    
                                       
                                          
                                             arg
                                             
                                                max
                                                f
                                             
                                             
                                                ∑
                                                i
                                             
                                             w
                                             
                                                (
                                                
                                                   g
                                                   
                                                      samp
                                                   
                                                
                                                |
                                                p
                                                )
                                             
                                             d
                                             
                                                (
                                                
                                                   
                                                      h
                                                      f
                                                   
                                                   ¯
                                                
                                                
                                                   (
                                                   
                                                      g
                                                      
                                                         samp
                                                      
                                                   
                                                   )
                                                
                                                ,
                                                
                                                   h
                                                   f
                                                
                                                
                                                   (
                                                   
                                                      g
                                                      i
                                                      ∘
                                                   
                                                   )
                                                
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           
                        to find features that are characteristic for all parts of the image.

As the data likelihood in the base model pi
                        (g°) is fixed w.r.t. 
                           
                              
                                 θ
                              
                           
                         and can be dropped, parameters of general exponential family distributions are learned in the same was as without a base model. The gradient vector 
                           ∇
                        ℓ(
                           
                              
                                 θ
                              
                           
                        |g°) and the Hessian matrix H(ℓ)(
                           
                              
                                 θ
                              
                           
                        |g°) of the log-likelihood are easily derived as:

                           
                              (9)
                              
                                 
                                    
                                       
                                          
                                             
                                                ∇
                                             
                                             ℓ
                                             (
                                             
                                                θ
                                             
                                             |
                                             
                                                g
                                                ∘
                                             
                                             )
                                          
                                       
                                       
                                          
                                             =
                                             −
                                             h
                                             
                                             
                                                (
                                                
                                                   g
                                                   ∘
                                                
                                                )
                                             
                                             +
                                             
                                                E
                                                
                                                   θ
                                                
                                             
                                             
                                                {
                                                h
                                                
                                                (
                                                g
                                                )
                                                }
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (10)
                              
                                 
                                    
                                       
                                          
                                             H
                                             
                                                (
                                                ℓ
                                                )
                                             
                                             
                                                (
                                                
                                                   θ
                                                
                                                |
                                                
                                                   g
                                                   ∘
                                                
                                                )
                                             
                                          
                                       
                                       
                                          
                                             =
                                             −
                                             
                                                
                                                   Cov
                                                
                                                
                                                   θ
                                                
                                             
                                             
                                                {
                                                h
                                                
                                                
                                                   (
                                                   g
                                                   )
                                                
                                                }
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where E
                        
                           
                              
                                 
                                    θ
                                 
                              
                           
                        {h(g)} and Cov
                           
                              
                                 
                                    θ
                                 
                              
                           
                        {h(g)} denote respectively the expected value and covariance matrix of the image features h(g) w.r.t. the distribution p(g|
                           
                              
                                 θ
                              
                           
                        ). As the covariance matrix is always non-positive definite, the log-likelihood is concave down in the space of parameter vectors, which is a common property of all exponential family distributions [56].

Computing the expectation in Eq. (9) exactly is in general intractable. Its approximation using a Markov chain Monte Carlo (MCMC) sampler such as the single-site Gibbs sampler can be highly unreliable, because the energy landscape often has deep local minima which are inescapable in reasonable time-scales.

The Hessian may be reasonably and easily approximated as a diagonal matrix, so given samples from the model p(g|
                           
                              
                                 θ
                              
                           
                        
                        
                           j
                        ) we can find the second order Taylor expansion about 
                           
                              
                                 θ
                              
                           
                        
                        
                           j
                         as an approximation to the log-likelihood using Eqs (9) and (10). A Newton step can be performed by inverting the Hessian, while a more numerically stable alternative is to find the maximum of the second order likelihood approximation along the direction of the gradient. See [57] for details.

We use this second-order method to find an initial approximation to the parameters at each nesting iteration, to save a little time. As both gradient and Hessian are highly approximate and Newton’s method takes dangerously large steps we take a single second order step, and then switch to a stochastic first order method which follows only the approximate gradient, as detailed in the next section.

Assuming that the time to sample from a MGRF is linear in the number of features, the nesting procedure runs in time quadratic in the number of nesting iterations. In order to keep running times reasonable, the number of nesting steps should be limited, and computation per nesting iteration minimised.

The most obvious method to learn the parameters of a MGRF is to perform stochastic gradient descent (SGD), following a noisy approximation to the gradient given by sampling from the model to approximate the expectation in the gradient (Eq. (9)). Sampling could be performed by starting from an initial image (e.g. of noise) and performing Gibbs sampler sweeps over the whole image until its total energy converges. However, this method is very slow. The MGRFs we learn are very dense, which makes sampling problematic; Gibbs sampling may mix very slowly, and easily gets stuck in local minima. Alternatively, a fixed number of sweeps can be performed to produce a sample, which is still useful for synthesising images but optimises the wrong objective.

Rather than repeatedly sampling from the models to approximate the gradient we used controllable simulated annealing (CSA) [58], simultaneously invented in [14], to produce approximate images matching the training statistics much faster than possible learning ML parameters. An essentially identical procedure was also reinvented in [59] under the name ‘persistent contrastive divergence’ (PCD). The goal in PCD is parameter learning, and it is presently the most popular method for that for MGRFs. The difference is that PCD uses small step sizes, and is started from the training data rather than a random image.

CSA alternates Gibbs sampling sweeps (visiting each pixel in the image g
                        samp once) and changes to parameters according to

                           
                              
                                 
                                    Δ
                                    
                                       θ
                                    
                                    =
                                    
                                       
                                          λ
                                       
                                       t
                                    
                                    ∘
                                    
                                       (
                                       h
                                       
                                       
                                          (
                                          
                                             g
                                             
                                                samp
                                             
                                          
                                          )
                                       
                                       −
                                       h
                                       
                                       
                                          (
                                          
                                             g
                                             ∘
                                          
                                          )
                                       
                                       )
                                    
                                 
                              
                           
                        where ○ denotes element-wise Hadamard product, g° is the training image, 
                           λ
                        
                        
                           t
                         is a vector of the current per-parameter step sizes and t is the iteration number. A Robbins–Monro (RM) sequence 
                           
                              
                                 
                                    λ
                                 
                                 t
                              
                              =
                              
                                 15
                                 
                                    15
                                    +
                                    t
                                 
                              
                              1
                           
                         was used, where 1 is the all-ones vector of the same dimension as 
                           
                              
                                 θ
                              
                           
                        . CSA can more rapidly produce an image with statistics which usually match the training statistics fairly well, but also has a strong tendency to oscillate. For this reason we introduce a variant of CSA called accelerated controllable simulated annealing (ACSA), which uses an gain vector adaptive step size instead of RM steps, as described by Almeida et al. [60], with default parameters and initial step size vector 
                           
                              
                                 
                                    λ
                                 
                                 0
                              
                              =
                              1
                           
                        . This uses different learning rates for different parameters, dampening oscillations by reducing the learning rate for parameters which do so, while increasing the learning rate for those that seem to require it. Adaptive step sizes proved to give far faster convergence to the desired statistics than RM steps, and are more robust to initial step size.

Finding optimal parameters which produce good unguided synthesis results requires far more fine tuning to eliminate unwanted energy minima which are approached very slowly during MCMC. In theory, if optimal parameters are learned then MCMC sampling and CSA should both produce samples which have statistics equal to the constraints on average, and are indistinguishable by the model features. Hence CSA ‘samples’ can be substituted for real samples from the ML model. Ideally if available a more efficient sampling algorithm than single-site Gibbs sampling should be used, but most popular samplers are not applicable here. More efficient algorithms have been developed for creating images matching desired statistics by making modifications attempting to directly move towards them [12,13,61].

Naturally, CSA will converge to the desired statistics faster if starting from parameters close to the MLE. At each nesting iteration we first found an approximation to the parameters as described in Section 4.2, and then ran CSA four times for 50 Gibbs sweeps each, starting from uniform noise images, to produce four samples of size 100 × 100. CSA results can be noisy and unreliable, not reaching the desired statistics, so it helps greatly to average over multiple runs. The parameters produced as a side effect of CSA are very approximate and may actually diverge from the MLE, but nonetheless are useful and carried forward to future iterations.

An important consideration when drawing samples from a MGRF texture model using an MCMC sampler is the choice of initial image. While the Markov chain converges asymptotically to the model distribution, this can take a number of steps exponential in the number of pixels due to ubiquitous deep local minima. However it is well known that MCMC converges slowly when highly correlated variables are updated independently, and in image models all nearby pixels are typically highly correlated to one another, making Gibbs sampling inefficient and prone to being trapped in local minima. The most common example of these are ‘crystallisation’ of regular patterns growing from two or more areas and meeting without aligning. Gibbs sampling of regular textures starting from noise often leads to crystallisation if the image size is several multiples of the maximum clique size.

There are a number of ways to avoid crystallisation. One is to add longer range interactions in order to more strongly enforce global structure. Otherwise, the process can be pushed towards the correct regularity by starting from an initial image with a template, in the form of dots, stripes, or any other unevenness of the desired tessellation. Such tessellation of near-regular textures can automatically be extracted by computing co-occurrence statistics for different offsets, in the form of a model-based interaction map (MBIM) [57]. Other alternatives slowly grow the image by extending the boundaries, starting from a single small ‘seed’ which is first allowed to converge [51], or starting from a random piece of the training image as a seed. The latter was used for these experiments due to simplicity. If a texture model is to be used for other tasks such as segmentation or classification better performance could be expected if appropriate learning, sampling and validation methods are used. For example for texture synthesis we care only about the local minimum that is reached on sampling from the starting sample (a white noise image in this work), and disregard the energy landscape outside of this basin, while for texture classification we want to ensure correct behaviour for distant images too.

For unguided texture synthesis after learning a model we used 300 sweeps of ACSA, growing from a seed, to produce images of size 180 × 180 plus trimmed margins of up to 65 pixels depending on feature sizes. Hence when inpainting this shortcut is not available: in practice CSA and ACSA are harmful for inpainting as generalisation (e.g. differing lighting) may be required. Instead we tuned the model parameters in the normal way, and then used Gibbs sampling to inpaint.

In order to reduce the space of candidate potentials, we define families of potentials that are parameterised only by the shape of their supports, with unparameterised feature functions. The simplest such order k feature on an image of Q pixel grey-levels is the trivial grey level co-occurrence (GLC) feature

                           
                              
                                 
                                    
                                       f
                                       
                                          GLC
                                       
                                    
                                    
                                       (
                                       
                                          x
                                          1
                                       
                                       ,
                                       …
                                       ,
                                       
                                          x
                                          k
                                       
                                       )
                                    
                                    :
                                    =
                                    
                                       x
                                       1
                                    
                                    
                                       Q
                                       0
                                    
                                    +
                                    ⋯
                                    +
                                    
                                       x
                                       k
                                    
                                    
                                       Q
                                       
                                          k
                                          −
                                          1
                                       
                                    
                                 
                              
                           
                        with Qk
                         bins. GLC features proved to have poor generalisation ability; while they performed well for texture synthesis, when used for inpainting tasks they remembered the original contrast and offset of the training image rather than matching the contrast of the surrounding inpainting frame. Previous researchers have found that histograms of the pairwise grey level difference (GLD) — defined for 
                           
                              k
                              =
                              2
                           
                         as 
                           
                              
                                 f
                                 
                                    GLD
                                 
                              
                              
                                 (
                                 
                                    x
                                    1
                                 
                                 ,
                                 
                                    x
                                    2
                                 
                                 )
                              
                              :
                              =
                              
                                 x
                                 2
                              
                              −
                              
                                 x
                                 1
                              
                              ,
                           
                         with 
                           
                              2
                              Q
                              −
                              1
                           
                         bins — encodes the large majority of the information in a pairwise GLC histogram [16,62], confirmed by our own comparisons GLC and GLD features for texture synthesis (see Section 5.1). Hence, we used GLD instead of GLC features to capture pairwise interactions.

The high-order features investigated were binary patterns (BPs), generalising LBPs by using learned offsets from the central pixel. The BP feature function thresholds the grey levels of the pixels in each clique against a certain distinguished pixel (no longer necessarily in the centre): 
                           
                              
                                 f
                                 
                                    BP
                                 
                              
                              
                                 (
                                 
                                    x
                                    0
                                 
                                 ,
                                 …
                                 ,
                                 
                                    x
                                    d
                                 
                                 )
                              
                              :
                              =
                              
                                 ∑
                                 
                                    1
                                    ≤
                                    i
                                    ≤
                                    d
                                 
                              
                              
                                 2
                                 
                                    i
                                    −
                                    1
                                 
                              
                              
                                 [
                                 
                                    [
                                    
                                       x
                                       0
                                    
                                    <
                                    
                                       x
                                       i
                                    
                                    ]
                                 
                                 ]
                              
                           
                        . No interpolation between pixels was performed, nor were histogram bins combined as in uniform LBPs [28].

We write GLC
                           k
                        , GLD
                           k
                         and BP
                           k
                         to indicate order k grey level co-occurrence, grey level difference and binary pattern features, respectively.


                        Binary equality features. Complementary to BPs, we considered ‘binary equality’ (BE) feature functions which test whether pixels are within an equality threshold c of each other (dependent on the grey level range) defined as

                           
                              
                                 
                                    
                                       f
                                       
                                          BE
                                       
                                    
                                    
                                       (
                                       
                                          x
                                          0
                                       
                                       ,
                                       …
                                       ,
                                       
                                          x
                                          d
                                       
                                       )
                                    
                                    :
                                    =
                                    
                                       ∑
                                       
                                          1
                                          ≤
                                          i
                                          ≤
                                          d
                                       
                                    
                                    
                                       2
                                       
                                          i
                                          −
                                          1
                                       
                                    
                                    
                                       [
                                       [
                                       |
                                    
                                    
                                       x
                                       0
                                    
                                    −
                                    
                                       x
                                       i
                                    
                                    
                                       |
                                       ≤
                                       c
                                       ]
                                       ]
                                       .
                                    
                                 
                              
                           
                        We supposed these might be more suitable for describing flat regions of an image, where any amount of noise causes f
                        BP to produce evenly distributed random values. For synthesis purposes, these features must be used in heterogeneous models paired with other features that break the symmetry between an image and its inverse (GLD features fail to do this for images with both 180 rotational symmetry and symmetric histograms). In our experiments we found that if a texture contains flat regions then a number of BE features would be selected by the nesting procedure, otherwise they were hardly selected. We found them to have similar descriptive power to BP statistics, but had additional failure conditions due to the necessary symmetry breaking, so they were not used further.

As a base model, we used a MGRF with a first order factor to model marginal statistics and the two nearest neighbour GLD features with offsets ((0, 0), (1, 0)) and ((0, 0), (0, 1)). As an exception, marginal potentials were not used for the inpainting experiment in Section 5.2, which improved the models’ ability to match the contrast of the surrounding frame. However for unguided synthesis matching the original histogram is desirable.

All features were constrained to clique families with at most 40 pixels distance between two points. The initial candidate set (selector) C
                        1 was always comprised of all GLD2 features within this circular window. Three GLD2 features are added at a time to speed learning. Thereafter different possibilities for C
                        2 were considered as listed below.

                           
                              •
                              ‘Combined’ BP5 features built out of the set of characteristic offsets {ri
                                 } occurring by the previously selected GLD2 and BP5 features. Each possible selection of two offsets r
                                 1, r
                                 2 and for each 
                                    
                                       i
                                       =
                                       1
                                       ,
                                       2
                                    
                                  each choice of either using mirrored offsets 
                                    
                                       
                                          r
                                          i
                                       
                                       ,
                                       −
                                       
                                          r
                                          i
                                       
                                    
                                  or halved offsets 
                                    
                                       
                                          r
                                          i
                                       
                                       /
                                       2
                                       ,
                                       −
                                       
                                          r
                                          i
                                       
                                       /
                                       2
                                    
                                  provided the set of four-offset candidates. BP5 features were also added two at a time.

‘Conjoined’ BP9 features built by selecting (by exhaustive search) four BP3 features with symmetric pairs of offsets 
                                    
                                       (
                                       
                                          r
                                          i
                                       
                                       ,
                                       −
                                       
                                          r
                                          i
                                       
                                       )
                                    
                                  of maximal JSD between training and sample histograms and then combining them into a single clique family with shape 
                                    
                                       (
                                       
                                          r
                                          1
                                       
                                       ,
                                       −
                                       
                                          r
                                          1
                                       
                                       ,
                                       …
                                       ,
                                       
                                          r
                                          4
                                       
                                       ,
                                       −
                                       
                                          r
                                          4
                                       
                                       )
                                    
                                 . Examples can be seen in Fig. 3.

‘Jagged star’ (jag-star) BP
                                    k
                                  features (for k = 9,13) with 
                                    
                                       k
                                       −
                                       1
                                    
                                  surrounding pixels alternately and evenly spaced on two circles of radii d
                                 0, d
                                 1 centred on the central pixel, with offsets at

                                    
                                       
                                          
                                             
                                                [
                                                
                                                   
                                                      
                                                         
                                                            x
                                                            i
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            y
                                                            i
                                                         
                                                      
                                                   
                                                
                                                ]
                                             
                                             =
                                             
                                                d
                                                
                                                   i
                                                   
                                                   
                                                      mod
                                                   
                                                   
                                                   2
                                                
                                             
                                             
                                                [
                                                
                                                   
                                                      
                                                         
                                                            cos
                                                            (
                                                            
                                                               
                                                                  2
                                                                  π
                                                                  i
                                                               
                                                               
                                                                  k
                                                                  −
                                                                  1
                                                               
                                                            
                                                            +
                                                            ϕ
                                                            )
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            sin
                                                            (
                                                            
                                                               
                                                                  2
                                                                  π
                                                                  i
                                                               
                                                               
                                                                  k
                                                                  −
                                                                  1
                                                               
                                                            
                                                            +
                                                            ϕ
                                                            )
                                                         
                                                      
                                                   
                                                
                                                ]
                                             
                                             ,
                                          
                                       
                                    
                                 where d
                                 
                                    i mod 2 is d
                                 1 if i is odd and d
                                 0 if i is even. These configurations include square as well as circular patterns. Considering a dense subset of rotations and radii from 1 to 20 pixels provided a fixed set of 2638 candidates. Examples can be seen in Fig. 3.

Linear filters. This is a fixed bank of Gabor wavelets and Laplacian of Gaussians identical to those used in FRAME [14] except that we increased the number of Gabor wavelet orientations from 6 to 10, and restricted sizes of the filters to prevent excessively long running times. We employed Gabor wavelets with wavelengths only up to 6 pixels (filters of size 17 × 17) rather than 12. In total there were 64 filters.

@&#EXPERIMENTS@&#

Generative image models have often been evaluated by measuring performance of image denoising and inpainting when the model is used as the prior. But this is an indirect and incomplete method of evaluation. Instead we mainly compare different classes of models by inspection of synthesis results. Experiments were conducted with a set of grey-scale digitised photographs of natural and approximately spatially homogeneous textures sourced from several popular databases. Textures were selected which were diverse, difficult to model, homogeneous and without periodicity or other features on a scale longer than 40 pixels (all images were kept at original scales, with the exception of the inpainting experiment in Section 5.2). The databases used were the popular Brodatz photo album [53]; the “NewTex” dataset of natural textures included with MeasTex [63], a framework for standardised texture discriminator evaluation; and the MIT VisTex database [54], and images collected by the NYU Laboratory for Computational Vision [64].

Textures were subjectively categorised into three classes according to structure: stochastic (those apparently described by only simple local interactions, e.g. sand, water), near-regular (regularly tiled but with random defects, e.g. weaves), and irregular (containing large scale elements with unpredictable placement or shapes, e.g. marbles).

Each image was quantised to 
                        
                           Q
                           =
                           8
                        
                      grey levels. With some exceptions (e.g. when comparing to other results) the images were quantised using contrast-limited adaptive histogram equalisation [65] with 16 × 16 tiles and a contrast clipping limit of 0.03. Adaptive histogram equalisation mostly avoids the situation where most of the image is mapped to only one or two grey levels, and also lessens shadows and gradients, which hinder the recovery of long range interactions. The low Q value used speeds up Gibbs sampling.

Source code for all experiments is freely available from the website accompanying the paper, together with supplementary material including results for a large number of additional textures.
                        1
                     
                     
                        1
                        
                           http://www.ivs.auckland.ac.nz/texture_modelling.
                     
                  

As a baseline we compare synthesis results to the texture analysis and synthesis algorithm by Portilla and Simoncelli [13] (downloadable from [64]), which in addition to being freely available, is today still one of the most successful attempts to model texture statistically, and has recently been extended to colour textures. Their approach uses iterated projections to attempt to produce images matching certain first- and second-order statistics of wavelet responses. On the other hand, all of the recent filter-based MRF texture models [8,19–21,66] have only been demonstrated on a few simple highly regular textures with short repetition lengths and texton scales. Unfortunately the lack of difficult synthesis examples or source code for these previously published approaches hinders comparison, although [21] achieved visually better results than us on the difficult D103/D104 textures (see Fig. 9) and D76 by using three layers of hundreds of filters in a deep belief network. In theory the purpose of these layers was to stabilise learning by using tiled-convolutional rather than fully-convolutional filters, which for simpler models is not necessary [66].


                        Figs. 4
                         and 5
                         show 180 × 180 synthesis results for 30 of the most diverse and interesting examples modelled using each of the alternative classes of BP features described in Section 4.6. Training images were 256 × 256 in size.

Synthesis results for the different models under comparison were evaluated by a panel of observers. For each of 20 textures (a subset of the 30 shown) six synthesised images from different classes of models were presented to each person along with the original training image, and they were tasked with placing the synthesis results in order from best to worst.
                           2
                        
                        
                           2
                           This questionnaire is available online at http://www.ivs.auckland.ac.nz/texture_modelling/.
                         The observers were instructed to make rapid decisions rather than perform careful inspection.


                        Table 1
                         presents the average rankings of each of the model types against the other five options, summarised by texture category. Additionally Table 2
                         reports how frequently each class of model gave the best-ranked synthesis result. The BP5 features outperforming the 9th order ones on stochastic textures may be an artifact of the earlier stopping rule, which usually excluded the higher order ones altogether on these textures.

From the figures and tables, it can be seen that the MGRFs perform well on near-regular textures, as tessellation is easily handled, and on stochastic textures, for which the apparent dependency of the actual texture is on a short scale and thus a natural fit for a MGRF. However, it is not easy to separate the performance of the different classes of models. On stochastic textures the method of Portilla and Simoncelli [13] usually but not always dominates, apparently most significantly because it captures high frequency aspects and details (such as thin branches and speckles) that ours do not. It is often able to produce nice results for irregular textures too, however, it often violates fixed tessellation offsets and fails to represent complex textons. On those cases the simple and cheap GLD potentials can be very effective. In addition, Gibbs (or CSA) sampling from a MGRF adds unwanted high frequency noise. Complex irregular textures such as tiles in column 3 of Fig. 4 are the most difficult for all methods, and in these cases hidden variables to distinguish different local contexts, as in gated MRFs, are probably necessary to visually replicate the texture.

In the tables the ‘combined’ 5th order BPs are seen to do very well on irregular textures, despite being low order and only having 16 parameters per feature. This provides promising evidence that piecing together high order features out of low order ones is a workable technique. However a number of other schemes for building up to higher orders that we attempted, not documented here, provided bad results. This motivated the investigation of the jag-star features as simpler and less brittle alternatives. Previous independent experiments [51] also favoured the ‘combined’ features, providing more evidence for a real effect. No significant difference between the 9th and 13th order jag-star features is visible, which is provides some evidence that the large number of parameter in the latter models — 4096 parameters per BP feature — is not unworkable. Results for star BP’s (not shown) were close to those for jag-star, but generally inferior.

We also compared the effect of replacing pairwise GLD features with GLC features or removing them entirely, as shown in Fig. 6
                           . Generally the result of excluding pairwise potentials is not very great (although it is very large when linear filters are used instead, Section 5.1.2), or even undetectable, as the higher order features can seemingly usually capture the same statistics, which is against expectations. Naturally long range GLD features are very helpful for regular textures. The difference between GLD and GLC features is even less, though over the whole texture set use of GLC models as a base seem to be slightly more powerful.

Using BPs for texture modelling was compared with more traditional linear filters, too. We consider both models which are close to those used in [14] (with both nesting procedure and filter bank being similar), and models also including GLD2 features. In either case the initial base model was the same as used in all our other models.

We can see from Fig. 7
                            that small linear filters alone of course cannot reconstruct textures whenever textural elements are larger than the filter wavelength, although larger objects can still be partially captured, such as the tiles in row 2, column 3. Augmenting the filters with long range GLD potentials prevents this failure case, while the linear filters perform much better than pairwise features alone. Unexpectedly with the addition of these long range potentials the synthesised images do not normally appear distinct from those composed of BP features, with very similar results across all texture types. For example the speckles in the first row texture are disappointingly not captured, indicating a deficiency in the fixed filterbank. However in row 5 (pine trees) we do see some ripples in the images clearly captured by wavelets, including Portilla & Simoncelli’s analysis, but not by BP features. Additionally from Table 1 it appears that the FRAME linear filters outperform BPs on stochastic textures, as might be expected, although far weaker than the comprehensive set of wavelet statistics used in [13]; but on the other hand are outperformed by BPs on textures with more structure.

Despite restricting the filter sizes to 17 × 17, model learning times with the filters were still 30 min on average (our implementation in C++ is single-threaded), several times that of the BP models.

Additionally, we compared against results from three recent leading hierarchical MGRF texture models [19,21,66] which attempted to quantitatively evaluate MGRF texture models through a texture inpainting task. (Heess et al. [8] used a slightly different variant, so most of their results are incomparable.) By focusing on four highly regular textures with small textural feature sizes, it is reasonable to compare the synthesized pixels in the inpainted region to the original ones since they should be nearly aligned. This is not applicable to other texture types, so is a very narrow test.

In the task a 76 × 76 pixel piece of Brodatz textures D6, D21, D53, or D77 is provided as an inpainting frame with a 54 × 54 pixel hole cut out of the centre. An algorithm fills the hole in a way consistent with the frame, and the difference against the ground truth is measured using the mean structural similarity index (MSSIM) [67]. MSSIM has been found experimentally to be a good measure of perceptual distance between images. D6 and D53 were bilinearly scaled to 50% and D21 and D77 to 75%; this allowed the use of small filters by the earlier papers. The top half of each image was used for training, and the bottom half for testing. Since the learning procedure is stochastic, the inpainting is repeated (200 times in our case) with random inpainting frames from test region and the average MSSIM score reported.

Examples of the inpainted frames are shown in Fig. 8
                        
                        , and examples of texture synthesis using the models used for inpainting is shown in Fig. 9, comparing to previously published synthesis results. Initially, the MSSIM scores across all models we learnt were very poor, but Fig. 9 reveals the reason for the bad quantitative results. All the best previously published models produce very smooth synthesis and also inpainting (not shown) results, as if maximising the per-pixel posterior marginals rather than providing a sample from the texture distribution. This is especially true for the published works which achieve the highest MSSIM scores [66]. On the other hand our models produce typically more realistic-appearing inpainting and synthesis results, with random deviations.

By averaging over 50 consecutive Gibbs MCMC samples we now achieve similar scores to previously published algorithms, although visual quality is greatly decreased by doing so. This is demonstrated in Fig. 8. The MSSIM scores are presented in Table 3
                        , alongside best previously published results and the Efros and Leung texture synthesis algorithm [42] as a baseline. For this experiment we used 
                           
                              Q
                              =
                              16
                           
                         rather than 
                           
                              Q
                              =
                              8
                           
                         grey levels. The comparison of ground truth with 256 grey levels against models using only 16 levels gives a slight penalty against the previous works. For some unknown reason all models attempted frequently failed to properly inpaint D6, resulting in low scores for this texture. The full resolution version of D6 is also unusually difficult to synthesise for all models.

@&#CONCLUSION@&#

While Markov random fields have long been applied to image modelling, there has been little prior investigation in this context into practical learning of interaction structure, with until recently [33] apparently only 2nd to 4th order MGRFs previously learned. The particular model nesting approach applied in this paper has the same theoretical foundation on maximum entropy distributions as previous sequential structure learning approaches, but emphasises approximation and speed by using CSA. Aside from this, the strength of model nesting is in creating heterogeneous models, and allowing composition of feature functions. Mixing dissimilar potentials in a MGRF typically shows immediate improvements.

Furthermore, for nearly two decades MGRF texture and image models based on square linear filters have been almost exclusively studied due to their superior performance over the primitive pairwise models that preceded them. However, we have shown that other types of high-order features, such as the generic binary pattern features introduced in this paper, are viable alternatives to linear filters. These BP features have several advantages over filters. They are offset and nearly contrast invariant, and are still powerful even when of low order. The presented synthesis and inpainting experiments showed that even BP feature of only 5th order are sufficient to capture many important visual aspects of textures and are capable of outperforming the previously best approaches, thanks to building features up out of characteristic low-order cliques. These relatively low orders reduce computation costs, while no filter coefficients need to be selected or learned.

The purpose of our synthesis experiments is not to challenge the mainstream highly effective and efficient texture synthesis algorithms but to validate our probabilistic models. There are however still many textures which our models have failed to capture, especially complex irregular ones, as well as losing fine details in general. In order to tackle these in future we plan to extend our models by including additional layers of feature selectors for diverse types of statistics, particularly co-occurrences between the outputs of feature functions at previous levels, as has been used in several texture models which used filters as features. A stopping rule for the nesting procedure which is robust to the highly variable quality of CSA samples would also be important if more feature sets are used, to keep the number of nesting iterations low. In future work we also hope to improve the generalisation ability of the models, such as with invariance to small deformations of the image. This is closely related to the selection of complex composite features which can describe more powerful abstractions.

@&#REFERENCES@&#

