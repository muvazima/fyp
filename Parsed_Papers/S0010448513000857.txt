@&#MAIN-TITLE@&#Partial retrieval of CAD models based on local surface region decomposition

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A B-rep model is decomposed into surface regions with different convexity.


                        
                        
                           
                           An optimal procedure is utilized to guide the surface partition.


                        
                        
                           
                           A kind of region codes is adopted to describe the surface regions.


                        
                        
                           
                           Partial model retrievals are realized by matching the region codes between models.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Surface region decomposition

Partial retrieval

Attributed relational graph

@&#ABSTRACT@&#


               
               
                  Most existing methods for 3D model retrieval focus on the global shape description and matching. However, partial shape description and retrieval may be used more frequently in the fields of product design and manufacture. In order to resolve the problem that the retrieval efficiency for complex model descriptors is low, a CAD model retrieval method based on local surface region decomposition is presented in this paper. First, according to the salient geometric features of the mechanical part, the surface boundary of a solid model is divided into local convex, concave and planar regions. Then, we give a kind of region codes that describe the surface regions and their links in the CAD model. Finally, the model retrievals are realized based on the similarity measurement between two models’ region codes. Experimental results have shown that this approach is able to support partial retrieval of CAD models.
               
            

@&#INTRODUCTION@&#

Ullmann  [1] estimated that more than 75% of product designs were case-based designs or adaptable designs. Designers usually modify existing products to meet the new requirements instead of starting from scratch. In order to seek out the reference schemes, more than 60% of design time is spent on collecting and reading the related documents. In industries, enterprises have suffered from tremendous waste due to the repeated design phenomenon. Obviously, effective information retrieval tools are helpful for solving this problem.

The popularity of three-dimensional (3D) CAD systems in industries has brought about the emergence of a large number of 3D CAD models. Methods for model retrieval can help users locate the desired models for design reuse. However, most existing methods for 3D model retrieval focus on the global retrieval instead of partial retrieval. In fact, many local design structures of different 3D CAD models are more likely to be reused in engineering applications. Consequently, model retrieval based on partial shape matching may be used more frequently in product design. Funkhouser et al.  [2] showed how the partial shapes retrieved from libraries can be utilized by compositing the interesting retrieved results together in different ways to form new objects. Its benefit is that the retrieved results usually offer highly detailed geometric feature for a user design concept. Fisher and Hanrahan  [3] proposed another kind of application of partial shape retrieval, in which the strength of relationships between partial shapes of models in databases provides a clue for discovering a proper candidate partial model in a given location.

Partial model retrieval needs much more computation than whole model retrieval because the former has to determine which part of a model to be matched with query model. One way to improve the efficiency is to reduce the size of the problem by making the granularity of model elements larger. Triangles in mesh models are too small, and even the faces like polygonal planes and cylindrical surfaces in B-rep models are not large enough when models are complex. So, we need the model segmentation, which divides models into new model elements with some basic characteristics, replacing triangles in meshes or faces in B-reps. In this paper, we just handle the problem for B-rep models and the model elements are boundary regions with consistent convexity.

However, the boundary partitions for B-rep models also face the efficiency problem and the resulting uncertainty problem. Existent approaches in literature include region growing and clustering algorithm. The former has good efficiency but may produce different results when the program starts with different seed faces. The latter as an optimization process can give a determinate result, provided that the process has traversed all the possible combinations, but obviously its time cost is high. To address the issue of surface segmentation mentioned above, we adopt a multi-step approach, where the regions that can be identified easier are processed first and the combinatorial optimization process is only applied to the remaining areas with reduced sizes. The justification of this approach is based on the fact that some adjacent faces can be said to belong to the same region without any doubts while others may not. The previous steps form a determinate process without any seed-face inputs and do not perform any questionable face-merging, while the last step is just provided for handling questionable face-merging.

After partitioning B-rep models into regions, region-matching is another task for partial model retrieval. Actually many existent methods for 3D shape comparison can be used for this purpose. Here, we adopt a relatively simple method, which is based on a kind of face-context codes. Generally, the code comparison method is faster than the methods of graph isomorphism checking, and it is also more convenient for B-rep model than the methods based on shape statistics and shape analysis. The basic assumption for using this approach is that the B-rep models are mainly composed of faces with regular geometry like plane, cylinder, cone, sphere and so on. It is worth mentioning that the code method like other face-topology matching approaches is not suitable for mesh models. This is because the same 3D shape may be tessellated in different ways with different mesh topologies. But topologies of B-rep models in mechanical engineering are determined by their face geometries (plane, cylinder, cone, sphere and so on); if two adjacent faces have the same geometry, they should belong to the same face. Therefore, it is reasonable to use the proposed region-matching method for partial CAD model retrieval.

Based on the motivations described above, a partial retrieval method for CAD models is proposed in this paper. In this method, FAG representations for each library model and retrieval model are created from their B-rep models first, and then they are decomposed into convex, concave and planar regions. After the surface decomposition, a kind of region codes is adopted to describe the surface regions and their links in the CAD models, and finally the partial model retrieval is realized with the comparison of their region codes. The experimental results have shown that the proposed approach is feasible.

The rest of this paper is organized as follows. First, a brief review of the related literature is presented in Section  2. Then, local surface region decomposition is introduced in Section  3. In Section  4, a kind of region codes that describes the surface region and their links in the CAD model are presented in detail. Following this, partial retrieval approach for CAD models is developed in Section  5. Section  6 presents some results of experiments that apply the proposed approach to the partial retrieval of CAD models. Finally, the paper ends up with some conclusions in Section  7.

@&#RELATED WORK@&#

Since recently, 3D model retrieval and classification has become an active research topic and a lot of work has been done in disciplines such as computer vision, mechanical engineering, artifact searching, molecular biology and chemistry. Although most of the works are relevant to CAD models used in engineering design, 3D model retrieval area has so far been dominated by research in computer vision and computer graphics. Instead of giving a complete overview to 3D model retrieval, which can be found in  [4–8], here we focus on literature in model segmentation and partial model retrieval.

For the processing of multimedia data, 3D mesh segmentation is a key task which produces a vital organization of the data points by partitioning them into connected regions or parts with certain semantic. Agathos et al.  [9] gave an exhaustive overview for 3D mesh segmentation. Methods for 3D mesh segmentation were classified into surface-based and part-based decomposition. The former divides model surface into local regions while the latter partitions model volume into sub-volumes. Chen et al.  [10] proposed a benchmark for quantitative evaluation of mesh segmentation algorithms, which contains a dataset with 4300 manually generated segments from 380 surface meshes of 19 different object categories. Tang and Huang  [11] adopted the properties of the line segments connecting certain facial points to perform person and gender facial expression recognition. The normalized distances and slopes of these line segments comprise a set of 96 distinguishing features for recognizing six universal facial expressions, namely anger, disgust, fear, happiness, sadness, and surprise.

For 3D solid model segmentation, most methods are developed in the area of machining feature recognition. Shah et al.  [12] developed a method to decompose a solid model into maximum convex volumes by half-space partitioning. In their works, they tried to decompose a solid model by intersecting it with the half-spaces of the surfaces. However, it is not always possible for the operations of the half-spaces to decompose a solid model with curved faces. Sakurai and Dave  [13] proposed an approach to divide a solid model with curved faces into maximal volumes. But this method may become very slow when the number of cells is large. Woo and Sakurai  [14] made an effort to improve the scalability of the maximal volume decomposition by recursively bisecting solid models and composing the maximal volumes of the bisected volumes. Ma et al.  [15] developed an approach to decompose solid models along Cutting Loops. They used volume relational graphs to represent B-rep models, in which each volume is generated from a face shell in the surface partition determined by the specially selected cutting loops.

Schreck et al.  [16] decomposed 3D models into a number of simpler shapes with octant-based partitioning scheme for global and partial 3D object retrieval. Philipp-Foliguet et al.  [17] used watershed cut algorithm to decompose artwork 3D models. Ferreira et al.  [18] considered segments generated in the segmentations of other models with collection-aware segmentation. Gal and Cohen-Or  [19] extracted salient geometric features by analyzing the variations of surface curvatures. The salient geometric features are some local surface regions whose curvatures are distinctive compared with their surrounding areas. Different from model segmentation, the union of salient geometric features may not form the whole model surface. Zheng and Saupe  [20] developed a hierarchical 3D shape approximation as well as a segmentation method for dividing the scanned low-resolution global shape model into several meaningful parts for registering high-resolution local-surface patches in complex 3D shape recovery.

Compared with global retrieval, there is still little literature for partial 3D model retrieval. In the following, we give a brief overview for partial retrieval of 3D models.

Funkhouser et al.  [2] used voxel grids to describe voxelized models and evaluated two model’s similarity by comparing the sum of squared distance between their voxel grids. This approach can realize global and partial retrieval within the same framework by varying weights of different subparts of the models. But it needs to deal with model alignment in advance. Bai et al.  [21] adopted the extended feature tree to represent design-feature based CAD models. In order to improve retrieval efficiency, they built bitmap indices for the local matching regions of every reusable subpart in the library as well as a query model. However, reusable design features extraction may be an intractable problem.

For partial retrieval of CAD models, graph-based methods are usually preferred because they consider both geometry and topology information of 3D models and are more suitable for the representations of shapes in various scopes. Saber et al.  [22] introduced feature-point graphs to describe 2D shapes with feature points on the boundary and their distances. Points with local maximum curvature along each contour were chosen as feature points. They used the distance matrix to represent the feature-point graph and evaluated partial similarity by sub-matrix matching. Since the feature points on a 2D boundary can be arranged sequentially, the sub-matrix matching is relatively easier than that for other subgraph matchings.

Bespalov et al.  [23] adopted feature-adjacency graphs to represent 3D models with extracted local features and their adjacency relationships. The graph vertex number may be small, but their scale-space description extraction technique is intractable. Biasotti et al.  [24] constructed extended Reeb graphs with geometric attributes to describe 3D models. For shape descriptors based on feature-adjacency graphs and extended Reeb graphs mentioned above, they achieved partial retrieval by implementing the largest common subgraph with some heuristics. Li et al.  [25] used feature dependency directed acyclic graphs (FDAGs) to represent CAD models and extracted reusable local structures by removing FDAG’s articulation points. The similarity between query and reusable subparts in library was evaluated by comparing their shape distribution histograms. FDAG is semantic-based and suitable for CAD models which can capture some related engineering knowledge besides their shapes.

EI-Mehalawi and Allen  [26] and Tao et al.  [27] used face adjacency graphs (FAGs) to describe CAD models for model retrieval. FAGs have an advantage that it is convenient to be created directly from CAD model’s boundary representation (B-rep). Nevertheless, the graph node number may be huge and they need more complicated subgraph matching algorithm.

In this section, we first give several concepts which are closely related to surface region decomposition, and then we discuss surface region decomposition for CAD models.

In commercial CAD systems, CAD models have two popular representations, constructive solid geometry (CSG) and boundary representation (B-rep). Since the CSG representation of a solid model is not unique and various B-rep models can be conveniently exported into a model file with the STEP standard format, B-rep is usually preferred for the description and analysis of solid models  [26,28]. From the same reason, local surface region decomposition for CAD models is also developed based on the B-rep model in this paper.

Before CAD models are decomposed, we transform them to FAGs. El-Mehalawi and Allen  [26] presented a method for generating and expressing a FAG from a STEP file. In this paper, the FAG is an ordered pair 
                           G
                           =
                           
                              (
                              V
                              ,
                              E
                              )
                           
                         where 
                           V
                         is its node set and 
                           E
                         is its link set, respectively corresponding to model faces and model edges.

Similar to the approaches developed by Sonthi et al.  [29] and Fu et al.  [30], the points on a solid boundary are classified into convex, concave and planar ones in this paper. Let 
                           
                              
                                 κ
                              
                              
                                 
                                    min
                                 
                              
                           
                         and 
                           
                              
                                 κ
                              
                              
                                 
                                    max
                                 
                              
                           
                         be the two principal curvatures for a point. The point is convex if 
                           
                              
                                 κ
                              
                              
                                 
                                    min
                                 
                              
                           
                           ≤
                           0
                           ,
                           
                              
                                 κ
                              
                              
                                 
                                    max
                                 
                              
                           
                           ≤
                           0
                         and 
                           
                              |
                              
                                 
                                    κ
                                 
                                 
                                    
                                       min
                                    
                                 
                              
                              |
                           
                           +
                           
                              |
                              
                                 
                                    κ
                                 
                                 
                                    
                                       max
                                    
                                 
                              
                              |
                           
                           >
                           0
                        , it is concave if 
                           
                              
                                 κ
                              
                              
                                 
                                    min
                                 
                              
                           
                           ≥
                           0
                           ,
                           
                              
                                 κ
                              
                              
                                 
                                    max
                                 
                              
                           
                           ≥
                           0
                         and 
                           
                              |
                              
                                 
                                    κ
                                 
                                 
                                    
                                       min
                                    
                                 
                              
                              |
                           
                           +
                           
                              |
                              
                                 
                                    κ
                                 
                                 
                                    
                                       max
                                    
                                 
                              
                              |
                           
                           >
                           0
                        , and it is planar if 
                           
                              |
                              
                                 
                                    κ
                                 
                                 
                                    
                                       min
                                    
                                 
                              
                              |
                           
                           +
                           
                              |
                              
                                 
                                    κ
                                 
                                 
                                    
                                       max
                                    
                                 
                              
                              |
                           
                           =
                           0
                        . Here, for simplicity, we neglect saddle points, which have 
                           
                              
                                 κ
                              
                              
                                 
                                    min
                                 
                              
                           
                           
                              
                                 κ
                              
                              
                                 
                                    max
                                 
                              
                           
                           <
                           0
                        .

However, surface decomposition based on the above point classification usually produces more regions than expected for engineering applications. For this reason, it is better to use semi-convex and semi-concave region types in surface decomposition instead of strictly convex and concave ones. Here, a semi-convex surface region not only includes convex points but may also have planar points. It is similar for semi-concave region. In this way, planar faces connected with convex edges form a semi-convex region.

While they are vigorous, the above definitions are still not convenient for identifying types of regions because of the point-wise convexity checking. Therefore, we adopt a region classification based on the convexity of individual faces and edges in a region. Here, a face could be semi-convex, semi-concave or planar, while an edge could be convex, concave, tangent, convex-tangent or concave-tangent according to the external or internal edge angle  [30]. For simplicity, edge convexity is determined only by the curvature in the direction across the edge here.

Thus, in this paper, the boundary of a solid CAD model is decomposed into a set of semi-convex regions, semi-concave regions and planar regions. The segmentation can greatly reduce the complexity of the model descriptors. Before introducing the approach for local surface region decomposition, some basic concepts are first given below. 
                           Definition 1
                           If all faces in a surface region are planar while their interior edges have a tangent type, this surface region is called Planar Region (PR).


                        
                           Definition 2
                           A surface region is called Semi-convex Region 
                              
                                 
                                    (
                                    
                                       
                                          C
                                       
                                       
                                          v
                                       
                                    
                                    R
                                    )
                                 
                               (Semi-concave Regions 
                                 
                                    (
                                    
                                       
                                          C
                                       
                                       
                                          c
                                       
                                    
                                    R
                                    )
                                 
                              ) if it satisfies the following three conditions: 
                                 
                                    (1)
                                    Each of faces in the region is semi-convex (semi-concave) or planar;

Each of interior edges in the region is convex (concave), convex-tangent (concave-tangent), or tangent;

There is at least one semi-convex (semi-concave) face or one interior edge with the type of convex (concave) or convex-tangent (concave-tangent).

For simplicity, semi-convex regions and semi-concave regions are briefly called Convex Regions and Concave Regions respectively in the rest of the paper. 
                           Definition 3
                           For FAG 
                                 g
                                 =
                                 
                                    (
                                    
                                       
                                          V
                                       
                                       
                                          g
                                       
                                    
                                    ,
                                    
                                       
                                          E
                                       
                                       
                                          g
                                       
                                    
                                    )
                                 
                               and 
                                 G
                                 =
                                 
                                    (
                                    V
                                    ,
                                    E
                                    )
                                 
                                 ,
                                 g
                               is called as 
                                 G
                              ’s Induced Graph (IG), if they satisfy the following two conditions: 
                                 
                                    (1)
                                    
                                       
                                          g
                                          ⋅
                                          
                                             
                                                V
                                             
                                             
                                                g
                                             
                                          
                                          ⊆
                                          G
                                          ⋅
                                          V
                                       ;


                                       
                                          g
                                          ⋅
                                          
                                             
                                                E
                                             
                                             
                                                g
                                             
                                          
                                          =
                                          
                                             {
                                             e
                                             ∣
                                          
                                        for all 
                                          
                                             e
                                             ∈
                                             G
                                             ⋅
                                             E
                                             ,
                                             e
                                             ⋅
                                             
                                                
                                                   v
                                                
                                                
                                                   i
                                                
                                             
                                             ∈
                                             g
                                             ⋅
                                             
                                                
                                                   V
                                                
                                                
                                                   g
                                                
                                             
                                             ,
                                             
                                             i
                                             =
                                             1
                                             ,
                                             2
                                             }
                                          
                                       .

Corresponding to PR, 
                           
                              
                                 C
                              
                              
                                 v
                              
                           
                           R
                         and 
                           
                              
                                 C
                              
                              
                                 c
                              
                           
                           R
                        , IG can be classified into Planar Region Graph (PRG), Convex Region Graph (
                           
                              
                                 C
                              
                              
                                 v
                              
                           
                           
                              RG
                           
                        ) and Concave Region Graph (
                           
                              
                                 C
                              
                              
                                 c
                              
                           
                           
                              RG
                           
                        ). 
                           Definition 4
                           If a FAG 
                                 G
                                 =
                                 
                                    (
                                    V
                                    ,
                                    E
                                    )
                                 
                               is decomposed into a set of 
                                 G
                              ’s IGs 
                                 S
                                 =
                                 
                                    {
                                    
                                       
                                          g
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          g
                                       
                                       
                                          2
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       
                                          g
                                       
                                       
                                          n
                                       
                                    
                                    ∣
                                    
                                       
                                          g
                                       
                                       
                                          i
                                       
                                    
                                    =
                                    
                                       (
                                       
                                          
                                             V
                                          
                                          
                                             i
                                          
                                       
                                       ,
                                       
                                          
                                             E
                                          
                                          
                                             i
                                          
                                       
                                       )
                                    
                                    }
                                 
                               and they satisfy the following two conditions: 
                                 
                                    (1)
                                    
                                       
                                          G
                                          ⋅
                                          V
                                          =
                                          
                                             
                                                g
                                             
                                             
                                                1
                                             
                                          
                                          ⋅
                                          
                                             
                                                V
                                             
                                             
                                                1
                                             
                                          
                                          ∪
                                          
                                             
                                                g
                                             
                                             
                                                2
                                             
                                          
                                          ⋅
                                          
                                             
                                                V
                                             
                                             
                                                2
                                             
                                          
                                          ⋯
                                          
                                             
                                                g
                                             
                                             
                                                n
                                             
                                          
                                          ⋅
                                          
                                             
                                                V
                                             
                                             
                                                n
                                             
                                          
                                       ;


                                       
                                          
                                             
                                                g
                                             
                                             
                                                i
                                             
                                          
                                          ⋅
                                          
                                             
                                                V
                                             
                                             
                                                i
                                             
                                          
                                          ∩
                                          
                                             
                                                g
                                             
                                             
                                                j
                                             
                                          
                                          ⋅
                                          
                                             
                                                V
                                             
                                             
                                                j
                                             
                                          
                                          =
                                          0̸
                                        if 
                                          i
                                          ≠
                                          j
                                       
                                    

Surface region decomposition is to divide a solid boundary or a mesh surface into regions with specific geometric properties. Region growing  [31–33] and clustering algorithm  [34–36] are two common approaches for this purpose. In the former, segmentation areas are generated with the expansion of distinct seed faces while growing criteria are applied to permit or stop the growing. For a dense mesh or a complicated solid model, the expansion of distinct seed faces may be a time-consuming task and unreasonable seed faces may lead to improper segmentation. In clustering algorithm, segmentation is achieved either by using 
                           k
                        -means clustering algorithm iteratively or by a hierarchy of cluster faces approximated by a primitive like plane and sphere. Usually, the algorithm is also time-consuming when the number of faces is large.

Since FAG provides complete face adjacency information, region growing seems to be a natural approach. However, it may produce different results as the seed faces are expanded in different orders. Fig. 1
                         gives such an example. If the pocket bottom face as a seed face is expanded first, the pocket side face 
                           f
                         will be assigned to the pocket region. But, when the front face serves as a seed face first, the same face 
                           f
                         could be one of the faces of the block region that is composed of planar faces and convex edges; this is an unexpected result. The result uncertainty is caused by the situation that the face 
                           f
                         has convex and concave edges at the same time, which makes it can be reached by both convex and concave region expansion procedures.

Another difficulty in the surface segmentation is that there exist exclusive constraints on the faces in one region. For example, suppose that faces 
                           
                              
                                 f
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 f
                              
                              
                                 2
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 f
                              
                              
                                 5
                              
                           
                         in Fig. 2
                         already form a 
                           
                              
                                 C
                              
                              
                                 v
                              
                           
                           R
                           
                           g
                        , and then either 
                           
                              
                                 f
                              
                              
                                 6
                              
                           
                         or 
                           
                              
                                 f
                              
                              
                                 7
                              
                           
                         could be added to the 
                           
                              
                                 C
                              
                              
                                 v
                              
                           
                           R
                           
                           g
                        , but not both of them because their connecting edge has different convexity from the region.

The above two cases indicate that there exist alternative surface partitions that meet the requirements of the surface region decomposition described in Definition 4, even though regions are expanded to be as large as possible. But, for the purpose of model description in CAD model retrieval, we want the partition result to be determinate as much as possible. To address this issue, an optimization-based approach similar to the 
                           k
                        -means clustering algorithm is adopted to perform the surface region decomposition in this paper.

Here, we choose an optimization objective function that measures the average relevance of faces to their regions. The relevance of a face 
                              v
                            to the region 
                              
                                 
                                    g
                                 
                                 
                                    i
                                 
                              
                            that it belongs to is defined as the number of the edges connecting 
                              v
                            to its neighbor vertices in the region; that is 
                              
                                 
                                    φ
                                 
                                 
                                    
                                       
                                          g
                                       
                                       
                                          i
                                       
                                    
                                 
                              
                              
                                 (
                                 v
                                 )
                              
                              =
                              
                                 |
                                 N
                                 
                                    (
                                    
                                       
                                          g
                                       
                                       
                                          i
                                       
                                    
                                    ,
                                    v
                                    )
                                 
                                 |
                              
                           , here 
                              N
                              
                                 (
                                 
                                    
                                       g
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 v
                                 )
                              
                              =
                              
                                 {
                                 
                                    
                                       v
                                    
                                    
                                       ′
                                    
                                 
                                 |
                                 ∃
                                 e
                                 
                                    (
                                    v
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          ′
                                       
                                    
                                    )
                                 
                                 ∈
                                 
                                    
                                       g
                                    
                                    
                                       i
                                    
                                 
                                 ⋅
                                 
                                    
                                       E
                                    
                                    
                                       i
                                    
                                 
                                 }
                              
                           . Therefore, the average relevance of all the faces of a region 
                              
                                 
                                    g
                                 
                                 
                                    i
                                 
                              
                            is 
                              
                                 
                                    ∑
                                 
                                 
                                    j
                                    =
                                    1
                                 
                                 
                                    
                                       |
                                       
                                          
                                             V
                                          
                                          
                                             i
                                          
                                       
                                       |
                                    
                                 
                              
                              
                                 
                                    φ
                                 
                                 
                                    
                                       
                                          g
                                       
                                       
                                          i
                                       
                                    
                                 
                              
                              
                                 (
                                 
                                    
                                       V
                                    
                                    
                                       i
                                    
                                 
                                 .
                                 
                                    
                                       v
                                    
                                    
                                       j
                                    
                                 
                                 )
                              
                              /
                              
                                 |
                                 
                                    
                                       V
                                    
                                    
                                       i
                                    
                                 
                                 |
                              
                           ; here 
                              
                                 |
                                 
                                    
                                       V
                                    
                                    
                                       i
                                    
                                 
                                 |
                              
                            is the number of vertices in 
                              
                                 
                                    V
                                 
                                 
                                    i
                                 
                              
                           . If the region partition is 
                              S
                              =
                              
                                 {
                                 
                                    
                                       g
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 
                                    
                                       g
                                    
                                    
                                       2
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    
                                       g
                                    
                                    
                                       
                                          |
                                          S
                                          |
                                       
                                    
                                 
                                 }
                              
                           , then the average relevance among all the regions is defined as follows: 
                              
                                 (1)
                                 
                                    f
                                    
                                       (
                                       S
                                       )
                                    
                                    =
                                    
                                       
                                          
                                             
                                                ∑
                                             
                                             
                                                i
                                                =
                                                1
                                             
                                             
                                                
                                                   |
                                                   S
                                                   |
                                                
                                             
                                          
                                          
                                             {
                                             
                                                [
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      j
                                                      =
                                                      1
                                                   
                                                   
                                                      
                                                         |
                                                         
                                                            
                                                               V
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                         |
                                                      
                                                   
                                                
                                                
                                                   
                                                      φ
                                                   
                                                   
                                                      
                                                         
                                                            g
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                   
                                                
                                                
                                                   (
                                                   
                                                      
                                                         V
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   .
                                                   
                                                      
                                                         v
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                   )
                                                
                                                ]
                                             
                                             /
                                             
                                                |
                                                
                                                   
                                                      V
                                                   
                                                   
                                                      i
                                                   
                                                
                                                |
                                             
                                             }
                                          
                                       
                                       
                                          
                                             |
                                             S
                                             |
                                          
                                       
                                    
                                    .
                                 
                              
                            Here 
                              
                                 |
                                 S
                                 |
                              
                            is the number of regions in 
                              S
                           . With this measurement, we choose the region partition that makes 
                              f
                              
                                 (
                                 S
                                 )
                              
                            be maximal. Fig. 3
                            gives 
                              f
                              
                                 (
                                 S
                                 )
                              
                           ’s values for the different surface partitions of the models in Figs. 1–2.

Although the objective function can clearly define what surface region partitions we need, solving the optimization problem is not easy because this is a combinatorial optimization with exponential complexity. Here we adopt a three-step approach for finding the problem’s solution, where the regions that can be identified easier are processed first and the combinatorial optimization process is applied to the remaining areas with reduced sizes. The three steps are: 
                              
                                 •
                                 Clustering the faces that definitely belong to a 
                                       
                                          
                                             C
                                          
                                          
                                             v
                                          
                                       
                                       R
                                     or 
                                       
                                          
                                             C
                                          
                                          
                                             c
                                          
                                       
                                       R
                                    ;

Clustering the faces that have hybrid convexity;

Merging the clusters into regions with optimization.

The procedures in the previous two steps can efficiently decompose the surfaces, but they usually produce more regions than expected. For example, they may generate two adjacent 
                              
                                 
                                    C
                                 
                                 
                                    v
                                 
                              
                              
                                 RG
                              
                           s but actually the two regions should be looked as one 
                              
                                 
                                    C
                                 
                                 
                                    v
                                 
                              
                              
                                 RG
                              
                            region. The optimization procedure in the third step is just for handling this issue.

For the example in Fig. 4
                           , the first step recognizes a 
                              
                                 
                                    C
                                 
                                 
                                    v
                                 
                              
                              
                                 RG
                              
                              
                              
                                 
                                    g
                                 
                                 
                                    1
                                 
                              
                            that consists of the block faces and a 
                              
                                 
                                    C
                                 
                                 
                                    c
                                 
                              
                              
                                 RG
                              
                              
                              
                                 
                                    g
                                 
                                 
                                    2
                                 
                              
                            that only includes the pocket bottom face, from the initial graph 
                              G
                           . Here, although the pocket bottom face is planar, it looks as a semi-concave face for possible expansion. The second step handles the hybrid regions from the rest of 
                              
                                 
                                    g
                                 
                                 
                                    1
                                 
                              
                            and 
                              
                                 
                                    g
                                 
                                 
                                    2
                                 
                              
                            in 
                              G
                            and identifies one 
                              
                                 
                                    C
                                 
                                 
                                    c
                                 
                              
                              
                                 RG
                              
                              
                              
                                 
                                    g
                                 
                                 
                                    3
                                 
                              
                            that has four side faces of the pocket. It is worthwhile to note that the edges not belonging to 
                              G
                              -
                              
                                 
                                    g
                                 
                                 
                                    1
                                 
                              
                              -
                              
                                 
                                    g
                                 
                                 
                                    2
                                 
                              
                            are not considered in the region recognition of the second step. Thus, the previous two steps generate the surface segmentation 
                              
                                 
                                    S
                                 
                                 
                                    ′
                                 
                              
                              =
                              
                                 {
                                 
                                    
                                       g
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 
                                    
                                       g
                                    
                                    
                                       2
                                    
                                 
                                 ,
                                 
                                    
                                       g
                                    
                                    
                                       3
                                    
                                 
                                 }
                              
                           . At the third step, the optimization procedure merges 
                              
                                 
                                    g
                                 
                                 
                                    2
                                 
                              
                            and 
                              
                                 
                                    g
                                 
                                 
                                    3
                                 
                              
                            into one 
                              
                                 
                                    C
                                 
                                 
                                    c
                                 
                              
                              
                                 RG
                              
                              
                              
                                 
                                    g
                                 
                                 
                                    4
                                 
                              
                           . So, the final decomposition is 
                              S
                              =
                              
                                 {
                                 
                                    
                                       g
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 
                                    
                                       g
                                    
                                    
                                       4
                                    
                                 
                                 }
                              
                           , which respectively are the block and the pocket.

From the examples in Figs. 1–2, it can be seen that some faces should belong to the same region without any doubts. The reason behind the phenomenon is that the convexity of the regions they belong to is definite. In contrast, some faces like 
                              f
                            in Fig. 1(a) could be assigned to a 
                              
                                 
                                    C
                                 
                                 
                                    v
                                 
                              
                              R
                            or a 
                              
                                 
                                    C
                                 
                                 
                                    c
                                 
                              
                              R
                           ; this means that the convexity of the regions they belong to is indefinite. To exactly describe these concepts, we give the following definition.


                           
                              Definition 5
                              Vertices in a FAG 
                                    G
                                  are classified into three types as follows: 
                                    
                                       •
                                       
                                          Convex vertex: It represents a semi-convex face, or it represents a planar face whose edges in 
                                             G
                                           are all convex or convex-tangent. The vertex is denoted using symbol ‘+’.


                                          Concave vertex: It represents a semi-concave face, or it represents a planar face whose edges in 
                                             G
                                           are all concave or concave-tangent. The vertex is denoted using symbol ‘−’.


                                          Hybrid vertex: Otherwise, it is a hybrid vertex of 
                                             G
                                          , and it is denoted using symbol ‘/’.

Please note that there is a little bit difference between face convexity and the vertex types defined above; here, a planar may be called a convex (concave) vertex if its edges have consistent convex (concave) convexity. Another implication of the vertex classification is that the vertex types are also relevant to what is the graph 
                              G
                           ; actually, 
                              G
                            could any subgraphs of the whole FAG, including the current vertex. Taking into account this factor, a hybrid vertex may have different types in the different subgraphs because some adjacency edges may not exist in the subgraph.

Based on Definition 5, each vertex in a FAG 
                              G
                            has a type of ‘+’, ‘−’, or ‘/’, and the types can be easily identified (see Fig. 5
                           (a), (b)). Therefore, clustering the faces with definite convexity has the following steps (see Fig. 5(b), (c)): 
                              
                                 1.
                                 Remove all the hybrid vertices, denoted with ‘/’, as well as their connecting edges;

Remove the ‘−’ edges of ‘+’ vertices and the ‘+’ edges of ‘−’ vertices, if any;

Identify the subgraphs 
                                       
                                          
                                             S
                                          
                                          
                                             +
                                          
                                       
                                       =
                                       
                                          {
                                          
                                             
                                                g
                                             
                                             
                                                1
                                             
                                             
                                                +
                                             
                                          
                                          ,
                                          
                                             
                                                g
                                             
                                             
                                                2
                                             
                                             
                                                +
                                             
                                          
                                          ,
                                          …
                                          ,
                                          
                                             
                                                g
                                             
                                             
                                                p
                                             
                                             
                                                +
                                             
                                          
                                          }
                                       
                                     where 
                                       
                                          
                                             g
                                          
                                          
                                             i
                                          
                                          
                                             +
                                          
                                       
                                     are maximally connected subgraphs with ‘+’ vertices, and the subgraphs 
                                       
                                          
                                             S
                                          
                                          
                                             −
                                          
                                       
                                       =
                                       
                                          {
                                          
                                             
                                                g
                                             
                                             
                                                1
                                             
                                             
                                                −
                                             
                                          
                                          ,
                                          
                                             
                                                g
                                             
                                             
                                                2
                                             
                                             
                                                −
                                             
                                          
                                          ,
                                          …
                                          ,
                                          
                                             
                                                g
                                             
                                             
                                                n
                                             
                                             
                                                −
                                             
                                          
                                          }
                                       
                                     where 
                                       
                                          
                                             g
                                          
                                          
                                             i
                                          
                                          
                                             −
                                          
                                       
                                     are maximally connected subgraphs with ‘−’ vertices;

Check whether the induced graph of each 
                                       
                                          
                                             g
                                          
                                          
                                             i
                                          
                                          
                                             +
                                          
                                       
                                     and 
                                       
                                          
                                             g
                                          
                                          
                                             i
                                          
                                          
                                             −
                                          
                                       
                                     in 
                                       G
                                     is itself. If not, remove it from 
                                       
                                          
                                             S
                                          
                                          
                                             +
                                          
                                       
                                     or 
                                       
                                          
                                             S
                                          
                                          
                                             −
                                          
                                       
                                    ;

Remove subgraphs 
                                       
                                          
                                             g
                                          
                                          
                                             i
                                          
                                          
                                             +
                                          
                                       
                                     and 
                                       
                                          
                                             g
                                          
                                          
                                             i
                                          
                                          
                                             −
                                          
                                       
                                     respectively from 
                                       
                                          
                                             S
                                          
                                          
                                             +
                                          
                                       
                                     and 
                                       
                                          
                                             S
                                          
                                          
                                             −
                                          
                                       
                                     if they are single-vertex subgraphs;

Return 
                                       
                                          
                                             S
                                          
                                          
                                             +
                                          
                                       
                                     and 
                                       
                                          
                                             S
                                          
                                          
                                             −
                                          
                                       
                                     as the clusters of the faces that belong to a 
                                       
                                          
                                             C
                                          
                                          
                                             v
                                          
                                       
                                       R
                                     or 
                                       
                                          
                                             C
                                          
                                          
                                             c
                                          
                                       
                                       R
                                     respectively.

Using the above procedure, all the maximal connected subgraphs with ‘+’ vertices as well as those with ‘−’ vertices can be found. At the second step, two adjacent curved faces like cylinders that have a connecting edge with inconsistent convexity can be separated. For the purpose of surface decomposition, all the interior edges in a region should have consistent convexity with its faces; if some do not present in the subgraphs, the consistent convexity cannot be guaranteed. Therefore, we need the fourth step. Since single face should not be looked as a cluster, the fifth step makes them removed from 
                              
                                 
                                    S
                                 
                                 
                                    +
                                 
                              
                            and 
                              
                                 
                                    S
                                 
                                 
                                    −
                                 
                              
                           .

After extracting 
                              
                                 
                                    S
                                 
                                 
                                    +
                                 
                              
                            and 
                              
                                 
                                    S
                                 
                                 
                                    −
                                 
                              
                            from 
                              G
                           , the remaining subgraph is 
                              
                                 
                                    G
                                 
                                 
                                    /
                                 
                              
                              =
                              G
                              −
                              
                                 
                                    G
                                 
                                 
                                    +
                                 
                              
                              −
                              
                                 
                                    G
                                 
                                 
                                    −
                                 
                              
                           , where 
                              
                                 
                                    G
                                 
                                 
                                    +
                                 
                              
                              =
                              
                                 
                                    ⋃
                                 
                                 
                                    
                                       
                                          g
                                       
                                       
                                          i
                                       
                                       
                                          +
                                       
                                    
                                    ∈
                                    
                                       
                                          S
                                       
                                       
                                          +
                                       
                                    
                                 
                              
                              
                                 
                                    g
                                 
                                 
                                    i
                                 
                                 
                                    +
                                 
                              
                            and 
                              
                                 
                                    G
                                 
                                 
                                    −
                                 
                              
                              =
                              
                                 
                                    ⋃
                                 
                                 
                                    
                                       
                                          g
                                       
                                       
                                          i
                                       
                                       
                                          −
                                       
                                    
                                    ∈
                                    
                                       
                                          S
                                       
                                       
                                          −
                                       
                                    
                                 
                              
                              
                                 
                                    g
                                 
                                 
                                    i
                                 
                                 
                                    −
                                 
                              
                           . Although some vertices of 
                              
                                 
                                    G
                                 
                                 
                                    /
                                 
                              
                            may have a type of ‘+’ or ‘−’, which fail to become a vertex of some 
                              
                                 
                                    g
                                 
                                 
                                    i
                                 
                                 
                                    +
                                 
                              
                            or 
                              
                                 
                                    g
                                 
                                 
                                    i
                                 
                                 
                                    −
                                 
                              
                           , we still call 
                              
                                 
                                    G
                                 
                                 
                                    /
                                 
                              
                            a hybrid subgraph. In order to identify maximal connected 
                              
                                 
                                    C
                                 
                                 
                                    v
                                 
                              
                              R
                           s and 
                              
                                 
                                    C
                                 
                                 
                                    c
                                 
                              
                              R
                           s in 
                              
                                 
                                    G
                                 
                                 
                                    /
                                 
                              
                           , we convert its ‘/’ vertices into ‘+’ or ‘−’ vertices first by deleting its ‘−’ or ‘+’ edges respectively (see Fig. 5(e), (g)). Then, in the remaining subgraph of 
                              
                                 
                                    G
                                 
                                 
                                    /
                                 
                              
                           , ‘+’ vertices connected with ‘+’ edges or ‘−’ vertices connected with ‘−’ edges could form subgraphs we need. If the subgraphs are finally checked to be induced subgraphs of 
                              G
                           , they represent the face clusters we are looking for. The detail of the procedure at this step is presented as follows: 
                              
                                 1.
                                 Set 
                                       
                                          
                                             G
                                          
                                          
                                             ′
                                          
                                       
                                       =
                                       
                                          
                                             G
                                          
                                          
                                             /
                                          
                                       
                                    ;

Remove all the ‘+’ edges in 
                                       
                                          
                                             G
                                          
                                          
                                             ′
                                          
                                       
                                     and regenerate the vertex types with respect to 
                                       
                                          
                                             G
                                          
                                          
                                             ′
                                          
                                       
                                    ;

Identify maximally connected subgraphs 
                                       
                                          
                                             S
                                          
                                          
                                             1
                                          
                                          
                                             +
                                          
                                       
                                       =
                                       
                                          {
                                          
                                             
                                                g
                                             
                                             
                                                1
                                                ,
                                                1
                                             
                                             
                                                +
                                             
                                          
                                          ,
                                          
                                             
                                                g
                                             
                                             
                                                1
                                                ,
                                                2
                                             
                                             
                                                +
                                             
                                          
                                          ,
                                          …
                                          ,
                                          
                                             
                                                g
                                             
                                             
                                                1
                                                ,
                                                p
                                                1
                                             
                                             
                                                +
                                             
                                          
                                          }
                                       
                                     of 
                                       
                                          
                                             G
                                          
                                          
                                             ′
                                          
                                       
                                    , which only have ‘+’ vertices and ‘+’ edges;

For each 
                                       
                                          
                                             g
                                          
                                          
                                             1
                                             ,
                                             i
                                          
                                          
                                             +
                                          
                                       
                                         in  
                                       
                                          
                                             S
                                          
                                          
                                             1
                                          
                                          
                                             +
                                          
                                       
                                    , check whether its induced graph in 
                                       G
                                     is itself, and if not, remove it from 
                                       
                                          
                                             S
                                          
                                          
                                             1
                                          
                                          
                                             +
                                          
                                       
                                    ;

Restore the 
                                       
                                          
                                             G
                                          
                                          
                                             ′
                                          
                                       
                                    ’s edges removed in Step 2, repeat Step 2 to Step 4 for ‘−’ edges and ‘−’ vertices to obtain 
                                       
                                          
                                             S
                                          
                                          
                                             1
                                          
                                          
                                             −
                                          
                                       
                                       =
                                       
                                          {
                                          
                                             
                                                g
                                             
                                             
                                                1
                                                ,
                                                1
                                             
                                             
                                                −
                                             
                                          
                                          ,
                                          
                                             
                                                g
                                             
                                             
                                                1
                                                ,
                                                2
                                             
                                             
                                                −
                                             
                                          
                                          ,
                                          …
                                          ,
                                          
                                             
                                                g
                                             
                                             
                                                1
                                                ,
                                                n
                                                1
                                             
                                             
                                                −
                                             
                                          
                                          }
                                       
                                    , and restore the 
                                       
                                          
                                             G
                                          
                                          
                                             ′
                                          
                                       
                                    ’s edges, too, before going to the next step;

If both 
                                       
                                          
                                             S
                                          
                                          
                                             1
                                          
                                          
                                             +
                                          
                                       
                                     and 
                                       
                                          
                                             S
                                          
                                          
                                             1
                                          
                                          
                                             −
                                          
                                       
                                     are empty, 
                                       
                                          (6.1)
                                          Generate a single-vertex subgraph for each vertex of 
                                                
                                                   
                                                      G
                                                   
                                                   
                                                      ′
                                                   
                                                
                                             , and put it to 
                                                
                                                   
                                                      S
                                                   
                                                   
                                                      /
                                                   
                                                
                                             ;

Exit the procedure;

Compute 
                                       f
                                       
                                          (
                                          
                                             
                                                S
                                             
                                             
                                                1
                                                ,
                                                
                                                   ex
                                                
                                             
                                             
                                                +
                                             
                                          
                                          )
                                       
                                     and 
                                       f
                                       
                                          (
                                          
                                             
                                                S
                                             
                                             
                                                1
                                                ,
                                                
                                                   ex
                                                
                                             
                                             
                                                −
                                             
                                          
                                          )
                                       
                                     with Eq. (1), where 
                                       
                                          
                                             S
                                          
                                          
                                             1
                                             ,
                                             
                                                ex
                                             
                                          
                                          
                                             +
                                          
                                       
                                     and 
                                       
                                          
                                             S
                                          
                                          
                                             1
                                             ,
                                             
                                                ex
                                             
                                          
                                          
                                             −
                                          
                                       
                                     are 
                                       
                                          
                                             G
                                          
                                          
                                             ′
                                          
                                       
                                    ’s partitions respectively expanded from 
                                       
                                          
                                             S
                                          
                                          
                                             1
                                          
                                          
                                             +
                                          
                                       
                                     and 
                                       
                                          
                                             S
                                          
                                          
                                             1
                                          
                                          
                                             −
                                          
                                       
                                     by adding other vertices to the partitions as single-vertex subgraphs. If 
                                       f
                                       
                                          (
                                          
                                             
                                                S
                                             
                                             
                                                1
                                                ,
                                                
                                                   ex
                                                
                                             
                                             
                                                +
                                             
                                          
                                          )
                                       
                                       >
                                       f
                                       
                                          (
                                          
                                             
                                                S
                                             
                                             
                                                1
                                                ,
                                                
                                                   ex
                                                
                                             
                                             
                                                −
                                             
                                          
                                          )
                                       
                                    , denote 
                                       
                                          
                                             S
                                          
                                          
                                             1
                                          
                                       
                                       =
                                       
                                          
                                             S
                                          
                                          
                                             1
                                          
                                          
                                             +
                                          
                                       
                                     and put 
                                       
                                          
                                             S
                                          
                                          
                                             1
                                          
                                          
                                             +
                                          
                                       
                                     to 
                                       
                                          
                                             S
                                          
                                          
                                             +
                                          
                                       
                                    ; otherwise, denote 
                                       
                                          
                                             S
                                          
                                          
                                             1
                                          
                                       
                                       =
                                       
                                          
                                             S
                                          
                                          
                                             1
                                          
                                          
                                             −
                                          
                                       
                                     and put 
                                       
                                          
                                             S
                                          
                                          
                                             1
                                          
                                          
                                             −
                                          
                                       
                                     to 
                                       
                                          
                                             S
                                          
                                          
                                             −
                                          
                                       
                                    ;

Remove the vertices of 
                                       
                                          
                                             S
                                          
                                          
                                             1
                                          
                                       
                                     and their edges from 
                                       
                                          
                                             G
                                          
                                          
                                             ′
                                          
                                       
                                    , and go to Step 2.

The above procedure is an iterative process and each iteration finds a set of maximal connected 
                              
                                 
                                    C
                                 
                                 
                                    v
                                 
                              
                              R
                           s or 
                              
                                 
                                    C
                                 
                                 
                                    c
                                 
                              
                              R
                           s, depending on which one can be expanded to a better partition for the current remaining subgraph 
                              
                                 
                                    G
                                 
                                 
                                    ′
                                 
                              
                            in the measure of Eq. (1). The subgraphs identified in this procedure, together with those generated in the previous clustering procedure, are saved in 
                              
                                 
                                    S
                                 
                                 
                                    +
                                 
                              
                                and  
                              
                                 
                                    S
                                 
                                 
                                    −
                                 
                              
                           , and the rest faces are kept in 
                              
                                 
                                    S
                                 
                                 
                                    /
                                 
                              
                            as single-vertex subgraphs, which cannot be merged into others. Fig. 5 gives an example for the above two procedures.

Let 
                              
                                 
                                    S
                                 
                                 
                                    c
                                 
                              
                              =
                              
                                 {
                                 
                                    
                                       g
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 
                                    
                                       g
                                    
                                    
                                       2
                                    
                                 
                                 ,
                                 …
                                 }
                              
                              =
                              
                                 
                                    S
                                 
                                 
                                    +
                                 
                              
                              ∪
                              
                              
                                 
                                    S
                                 
                                 
                                    −
                                 
                              
                              ∪
                              
                                 
                                    S
                                 
                                 
                                    /
                                 
                              
                           , which includes all the face clusters generated in the previous two clustering steps. Here, the single-vertex subgraphs from 
                              
                                 
                                    S
                                 
                                 
                                    /
                                 
                              
                            could be a 
                              
                                 
                                    C
                                 
                                 
                                    v
                                 
                              
                              
                                 RG
                              
                              ,
                              
                                 
                                    C
                                 
                                 
                                    c
                                 
                              
                              
                                 RG
                              
                            or PRG, depending on whether they represent a semi-convex, semi-concave or planar face. Since some subgraphs in 
                              
                                 
                                    S
                                 
                                 
                                    c
                                 
                              
                            can be merged to form a better partition, a merging process is necessary. In this process, there are two issues that need to be addressed. The first is what is the mergeable condition and the second is whether a merging can improve the current partition.

The mergeability of two subgraphs means that the induced graph from all the vertices of them is a 
                              
                                 
                                    C
                                 
                                 
                                    v
                                 
                              
                              
                                 RG
                              
                              ,
                              
                                 
                                    C
                                 
                                 
                                    c
                                 
                              
                              
                                 RG
                              
                            or PRG. Concretely, we say two subgraphs 
                              
                                 
                                    g
                                 
                                 
                                    1
                                 
                              
                            and 
                              
                                 
                                    g
                                 
                                 
                                    2
                                 
                              
                            are mergeable if they satisfy conditions: 
                              
                                 •
                                 They have the consistent convexity;

All the edges existing between vertices of the two subgraphs have the consistent convexity with the two subgraphs, too.

For the partition improvement, the following property deduced from Eq. (1) is useful. 
                              Property 1
                              
                                 Suppose 
                                 
                                    S
                                    =
                                    
                                       {
                                       
                                          
                                             g
                                          
                                          
                                             1
                                          
                                       
                                       ,
                                       
                                          
                                             g
                                          
                                          
                                             2
                                          
                                       
                                       ,
                                       
                                          
                                             g
                                          
                                          
                                             3
                                          
                                       
                                       ,
                                       …
                                       ,
                                       
                                          
                                             g
                                          
                                          
                                             m
                                          
                                       
                                       }
                                    
                                  
                                 . If the following two conditions are satisfied:
                              


                                 • 
                                 
                                    
                                       
                                          g
                                       
                                       
                                          1
                                       
                                    
                                  
                                 and 
                                 
                                    
                                       
                                          g
                                       
                                       
                                          2
                                       
                                    
                                  
                                 are mergeable;
                                 
                                    
                                       (2)
                                       
                                          •
                                          
                                          
                                             
                                                
                                                   
                                                      n
                                                   
                                                   
                                                      1
                                                   
                                                
                                                
                                                   
                                                      ϕ
                                                   
                                                   
                                                      2
                                                   
                                                
                                                +
                                                
                                                   
                                                      n
                                                   
                                                   
                                                      2
                                                   
                                                
                                                
                                                   
                                                      ϕ
                                                   
                                                   
                                                      1
                                                   
                                                
                                                −
                                                2
                                                e
                                             
                                             
                                                
                                                   
                                                      n
                                                   
                                                   
                                                      1
                                                   
                                                
                                                +
                                                
                                                   
                                                      n
                                                   
                                                   
                                                      2
                                                   
                                                
                                             
                                          
                                          <
                                          f
                                          
                                             (
                                             S
                                             )
                                          
                                          ,
                                       
                                    
                                 
                                 then merging 
                                 
                                    
                                       
                                          g
                                       
                                       
                                          1
                                       
                                    
                                  
                                 and 
                                 
                                    
                                       
                                          g
                                       
                                       
                                          2
                                       
                                    
                                  
                                 can increase the optimization objective function. Here, 
                                 
                                    
                                       
                                          n
                                       
                                       
                                          1
                                       
                                    
                                  
                                 and 
                                 
                                    
                                       
                                          n
                                       
                                       
                                          2
                                       
                                    
                                  
                                 are respectively the vertex numbers of 
                                 
                                    
                                       
                                          g
                                       
                                       
                                          1
                                       
                                    
                                  
                                 and 
                                 
                                    
                                       
                                          g
                                       
                                       
                                          2
                                       
                                    
                                    ,
                                    
                                       
                                          ϕ
                                       
                                       
                                          k
                                       
                                    
                                    =
                                    
                                       [
                                       
                                          
                                             ∑
                                          
                                          
                                             i
                                             =
                                             1
                                          
                                          
                                             
                                                
                                                   n
                                                
                                                
                                                   1
                                                
                                             
                                          
                                       
                                       
                                          
                                             φ
                                          
                                          
                                             
                                                
                                                   g
                                                
                                                
                                                   k
                                                
                                             
                                          
                                       
                                       
                                          (
                                          
                                             
                                                V
                                             
                                             
                                                k
                                             
                                          
                                          ⋅
                                          
                                             
                                                v
                                             
                                             
                                                i
                                             
                                          
                                          )
                                       
                                       ]
                                    
                                    /
                                    
                                       
                                          n
                                       
                                       
                                          k
                                       
                                    
                                    ,
                                    
                                    k
                                    =
                                    1
                                    ,
                                    2
                                 
                                 , and 
                                 
                                    e
                                  
                                 is the number of connecting edges between the two subgraphs.
                              

Based on the above discussion, a simple merging process has the following steps: 
                              
                                 1.
                                 Set 
                                       S
                                       =
                                       
                                          
                                             S
                                          
                                          
                                             c
                                          
                                       
                                       =
                                       
                                          {
                                          
                                             
                                                g
                                             
                                             
                                                1
                                             
                                          
                                          ,
                                          
                                             
                                                g
                                             
                                             
                                                2
                                             
                                          
                                          ,
                                          …
                                          }
                                       
                                     and the merging flag 
                                       b
                                       =
                                       
                                          FALSE
                                       
                                    ;

Scan all subgraph pair 
                                       
                                          
                                             g
                                          
                                          
                                             i
                                          
                                       
                                     and 
                                       
                                          
                                             g
                                          
                                          
                                             j
                                          
                                       
                                     in 
                                       S
                                    : 
                                       
                                          (2.1)
                                          If they satisfy the mergeability conditions and the improvement condition (2), merge them and set 
                                                b
                                                =
                                                
                                                   TRUE
                                                
                                             ;

Go to the next subgraph pair.

If 
                                       b
                                       =
                                       
                                          FALSE
                                       
                                    , return 
                                       S
                                     as the final surface region decomposition and exit; otherwise, update 
                                       S
                                       =
                                       
                                          {
                                          
                                             
                                                g
                                             
                                             
                                                1
                                             
                                          
                                          ,
                                          
                                             
                                                g
                                             
                                             
                                                2
                                             
                                          
                                          ,
                                          …
                                          }
                                       
                                     with the previous merged subgraphs and go to Step 2.

Usually, since the number of subgraphs generated by the previous clustering steps is much smaller than the model face number, and many adjacent subgraphs have inconsistent convexity, the above merging process can quickly identify which subgraphs to merge. Fig. 6
                            gives an example of the comparison between the initial decomposition and the final optimized result. In the figure, different surface regions are painted with different colors. The initial decomposition has 6 
                              
                                 
                                    C
                                 
                                 
                                    v
                                 
                              
                              R
                           s, 5 
                              
                                 
                                    C
                                 
                                 
                                    c
                                 
                              
                              R
                           s and 3 PRs while the final optimized result consists of 5 
                              
                                 
                                    C
                                 
                                 
                                    v
                                 
                              
                              R
                           s and 5 
                              
                                 
                                    C
                                 
                                 
                                    c
                                 
                              
                              R
                           s. This example shows that the optimized result is more reasonable and its engineering semantics is more obvious.

Effect and efficiency are two primary concerns for the CAD models’ surface decomposition. To test its effect, some typical CAD models are processed with the proposed approach and the results are listed in Fig. 7
                        , where each surface region is assigned a separate color but two separate regions without adjacent relation may have the same color. These decomposition results show that the proposed approach is feasible and most local surface regions obtained with the method have obvious engineering semantics. Meanwhile, an efficiency curve is given in Fig. 8
                         for the CAD model surface decomposition approach, where the two coordinate axes respectively represent the models’ face numbers and the decomposition time. From this curve, it can be seen that the method takes no more than 1.4 s for a CAD model with 500 faces. Besides, most parts shown there have tens even hundreds of faces. These results indicate that its efficiency could meet the requirement of practical applications.

In this paper, the partial retrieval of CAD models is realized by matching the surface regions generated with the above approach. A simple method for matching these regions is to compare their characteristics represented with a vector of feature values. Here, they are called surface region properties represented in a form of codes, which are convenient for comparison.

The properties of a surface region, which are taken into consideration in this research, include region convexity, surface types and information of adjacency with other regions. Here, the former two properties are represented with the region header code header while the third property is described with the region adjacency code adj. The code adj captures information of convexity of edges on the region boundary and convexity of its adjacent regions. While they are necessary, the codes header and adj are insufficient for region shape description. Hence, a more complicated code, called face context code context, is introduced to describe the faces and their relations in a region, which can greatly improve the precision of shape matching between different regions.

Region adjacency code adj has a form as follows: 
                           
                              (3)
                              
                                 
                                    adj
                                 
                                 =
                                 9
                                 ×
                                 
                                    
                                       r
                                    
                                    
                                       
                                          ec
                                       
                                    
                                 
                                 +
                                 3
                                 ×
                                 
                                    
                                       r
                                    
                                    
                                       c
                                       ,
                                       
                                          min
                                       
                                    
                                 
                                 +
                                 
                                    
                                       r
                                    
                                    
                                       c
                                       ,
                                       
                                          max
                                       
                                    
                                 
                                 ,
                              
                           
                         where 
                           
                              
                                 r
                              
                              
                                 
                                    ec
                                 
                              
                           
                         is an integer capturing the information of edge convexity on region boundary, and 
                           
                              
                                 r
                              
                              
                                 c
                                 ,
                                 
                                    min
                                 
                              
                           
                         and 
                           
                              
                                 r
                              
                              
                                 c
                                 ,
                                 
                                    max
                                 
                              
                           
                         respectively are the minimum and maximum value of 
                           
                              
                                 r
                              
                              
                                 c
                              
                           
                         in the codes of the adjacent regions. Here, 
                           
                              
                                 r
                              
                              
                                 
                                    ec
                                 
                              
                           
                         has the following expression: 
                           
                              (4)
                              
                                 
                                    
                                       r
                                    
                                    
                                       
                                          ec
                                       
                                    
                                 
                                 =
                                 
                                    
                                       b
                                    
                                    
                                       0
                                    
                                 
                                 +
                                 2
                                 ×
                                 
                                    
                                       b
                                    
                                    
                                       1
                                    
                                 
                                 +
                                 4
                                 ×
                                 
                                    
                                       b
                                    
                                    
                                       2
                                    
                                 
                                 ,
                              
                           
                         where 
                           
                              
                                 b
                              
                              
                                 i
                              
                           
                           
                           
                              (
                              i
                              =
                              0
                              –
                              2
                              )
                           
                         is an integer 1 or 0. The cases of subscript 
                           i
                           =
                           0
                           ,
                           1
                           ,
                           2
                         respectively correspond to three edge types; they are tangent edge, convex edge and concave edge. If there exist edges with the 
                           i
                        -th edge type on the region boundary, then 
                           
                              
                                 b
                              
                              
                                 i
                              
                           
                           =
                           1
                        ; otherwise, 
                           
                              
                                 b
                              
                              
                                 i
                              
                           
                           =
                           0
                        .

Before giving the definition of face context code, the codes for faces and edges are introduced first.

For a face, its properties that are taken into account include surface type and face convexity, and these properties are expressed with a face code 
                              f
                           . Here, it is formulated as follows: 
                              
                                 (5)
                                 
                                    f
                                    =
                                    10
                                    ×
                                    
                                       
                                          f
                                       
                                       
                                          t
                                       
                                    
                                    +
                                    
                                       
                                          f
                                       
                                       
                                          c
                                       
                                    
                                    ,
                                 
                              
                            where 
                              
                                 
                                    f
                                 
                                 
                                    t
                                 
                              
                            and 
                              
                                 
                                    f
                                 
                                 
                                    c
                                 
                              
                            are integers, representing the face’s properties mentioned above. Specifically, 
                              
                                 
                                    f
                                 
                                 
                                    t
                                 
                              
                              =
                              0
                           , 1, 2, 3 or 4, respectively, if the surface is a plane, cylinder, cone, sphere, or one with any other type, and 
                              
                                 
                                    f
                                 
                                 
                                    c
                                 
                              
                              =
                              0
                           , 1, 2 or 3, respectively for the cases that the face is planar, convex, concave, or with hybrid convexity.

Here, the description for an edge focuses on two edge properties, edge convexity and the types of its adjacent faces. So, the code for an edge has a form as follows: 
                              
                                 (6)
                                 
                                    e
                                    =
                                    25
                                    ×
                                    
                                       
                                          e
                                       
                                       
                                          c
                                       
                                    
                                    +
                                    5
                                    ×
                                    
                                       
                                          f
                                       
                                       
                                          t
                                          ,
                                          
                                             min
                                          
                                       
                                    
                                    +
                                    
                                       
                                          f
                                       
                                       
                                          t
                                          ,
                                          
                                             max
                                          
                                       
                                    
                                    ,
                                 
                              
                            where 
                              
                                 
                                    f
                                 
                                 
                                    t
                                    ,
                                    
                                       min
                                    
                                 
                              
                            and 
                              
                                 
                                    f
                                 
                                 
                                    t
                                    ,
                                    
                                       max
                                    
                                 
                              
                            are respectively the minimum and maximum value of 
                              
                                 
                                    f
                                 
                                 
                                    t
                                 
                              
                            in the codes of its adjacent faces, and 
                              
                                 
                                    e
                                 
                                 
                                    c
                                 
                              
                            is an integer describing the edge’s convexity. The value of 
                              
                                 
                                    e
                                 
                                 
                                    c
                                 
                              
                            is determined by the dihedral angle between the two adjacent faces; 
                              
                                 
                                    e
                                 
                                 
                                    c
                                 
                              
                              =
                              0
                           , 1 or 2, respectively, if the angle is equal to 180°, less than 180° or the others.

First, graph 
                              
                                 
                                    G
                                 
                                 
                                    r
                                 
                              
                              =
                              
                                 (
                                 
                                    
                                       V
                                    
                                    
                                       r
                                    
                                 
                                 ,
                                 
                                    
                                       E
                                    
                                    
                                       r
                                    
                                 
                                 )
                              
                            is used to express all the faces and their relations in the region. Then, a face context code context for each face 
                              v
                            in 
                              
                                 
                                    V
                                 
                                 
                                    r
                                 
                              
                            is calculated from the information of 
                              v
                           ’s neighbors with different distances from 
                              v
                           . For this purpose, the vertices in 
                              
                                 
                                    V
                                 
                                 
                                    r
                                 
                              
                            is divided into layers 
                              
                                 
                                    L
                                 
                                 
                                    k
                                 
                              
                              
                              
                                 (
                                 k
                                 =
                                 1
                                 ,
                                 2
                                 ,
                                 …
                                 ,
                                 m
                                 )
                              
                            around vertex 
                              v
                            and let 
                              v
                            itself forms the layer 
                              
                                 
                                    L
                                 
                                 
                                    0
                                 
                              
                           . Each layer 
                              
                                 
                                    L
                                 
                                 
                                    k
                                 
                              
                            includes vertices that have the shortest distance 
                              k
                            from 
                              v
                            (see Fig. 9
                           ). Based on the partition of the neighboring layers for vertex 
                              v
                           , its context code context is formulated as follows: 
                              
                                 
                                    (7)
                                    
                                       
                                          context
                                       
                                       
                                          (
                                          v
                                          )
                                       
                                       =
                                       f
                                       
                                          (
                                          v
                                          )
                                       
                                       −
                                       
                                          
                                             C
                                          
                                          
                                             1
                                          
                                       
                                       −
                                       
                                          
                                             C
                                          
                                          
                                             2
                                          
                                       
                                       −
                                       ⋯
                                       −
                                       
                                          
                                             C
                                          
                                          
                                             m
                                          
                                       
                                       ;
                                    
                                 
                                 
                                    
                                       
                                          
                                             C
                                          
                                          
                                             k
                                          
                                       
                                       =
                                       1
                                       
                                          
                                             0
                                          
                                          
                                             4
                                          
                                       
                                       ×
                                       
                                          
                                             l
                                          
                                          
                                             k
                                          
                                       
                                       +
                                       
                                          
                                             10
                                          
                                          
                                             2
                                          
                                       
                                       ×
                                       
                                          
                                             i
                                          
                                          
                                             k
                                          
                                       
                                       +
                                       
                                          
                                             o
                                          
                                          
                                             k
                                          
                                       
                                       ;
                                    
                                 
                                 
                                    
                                       
                                          
                                             l
                                          
                                          
                                             k
                                          
                                       
                                       =
                                       
                                          (
                                          
                                             
                                                ∑
                                             
                                             
                                                
                                                   
                                                      v
                                                   
                                                   
                                                      i
                                                   
                                                
                                                ∈
                                                
                                                   
                                                      L
                                                   
                                                   
                                                      k
                                                   
                                                
                                             
                                          
                                          f
                                          
                                             (
                                             
                                                
                                                   v
                                                
                                                
                                                   i
                                                
                                             
                                             )
                                          
                                          )
                                       
                                       /
                                       
                                          |
                                          
                                             
                                                L
                                             
                                             
                                                k
                                             
                                          
                                          |
                                       
                                       ;
                                    
                                 
                                 
                                    
                                       
                                          
                                             i
                                          
                                          
                                             k
                                          
                                       
                                       =
                                       
                                          (
                                          
                                             
                                                ∑
                                             
                                             
                                                
                                                   
                                                      e
                                                   
                                                   
                                                      i
                                                   
                                                
                                                ∈
                                                
                                                   
                                                      L
                                                   
                                                   
                                                      k
                                                      −
                                                      1
                                                   
                                                
                                                ×
                                                
                                                   
                                                      L
                                                   
                                                   
                                                      k
                                                   
                                                
                                             
                                          
                                          e
                                          
                                             (
                                             
                                                
                                                   e
                                                
                                                
                                                   i
                                                
                                             
                                             )
                                          
                                          )
                                       
                                       /
                                       
                                          |
                                          
                                             
                                                L
                                             
                                             
                                                k
                                                −
                                                1
                                             
                                          
                                          ×
                                          
                                             
                                                L
                                             
                                             
                                                k
                                             
                                          
                                          |
                                       
                                       ;
                                    
                                 
                                 
                                    
                                       
                                          
                                             o
                                          
                                          
                                             k
                                          
                                       
                                       =
                                       
                                          (
                                          
                                             
                                                ∑
                                             
                                             
                                                
                                                   
                                                      e
                                                   
                                                   
                                                      i
                                                   
                                                
                                                ∈
                                                
                                                   
                                                      L
                                                   
                                                   
                                                      k
                                                   
                                                
                                                ×
                                                
                                                   
                                                      L
                                                   
                                                   
                                                      k
                                                   
                                                
                                             
                                          
                                          e
                                          
                                             (
                                             
                                                
                                                   e
                                                
                                                
                                                   i
                                                
                                             
                                             )
                                          
                                          )
                                       
                                       /
                                       
                                          |
                                          
                                             
                                                L
                                             
                                             
                                                k
                                             
                                          
                                          ×
                                          
                                             
                                                L
                                             
                                             
                                                k
                                             
                                          
                                          |
                                       
                                       .
                                    
                                 
                              
                            In the above formula, 
                              
                                 
                                    L
                                 
                                 
                                    k
                                    −
                                    1
                                 
                              
                              ×
                              
                                 
                                    L
                                 
                                 
                                    k
                                 
                              
                            is the set of edges between 
                              
                                 
                                    L
                                 
                                 
                                    k
                                    −
                                    1
                                 
                              
                            and 
                              
                                 
                                    L
                                 
                                 
                                    k
                                 
                              
                            while 
                              
                                 
                                    L
                                 
                                 
                                    k
                                 
                              
                              ×
                              
                                 
                                    L
                                 
                                 
                                    k
                                 
                              
                            is the set for edges inside 
                              
                                 
                                    L
                                 
                                 
                                    k
                                 
                              
                              ,
                              f
                              
                                 (
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                 
                                 )
                              
                            and 
                              e
                              
                                 (
                                 
                                    
                                       e
                                    
                                    
                                       i
                                    
                                 
                                 )
                              
                            are calculated respectively with Eq. (5) and Eq. (6). The symbol ‘−’ in 
                              f
                              
                                 (
                                 v
                                 )
                              
                              −
                              
                                 
                                    C
                                 
                                 
                                    1
                                 
                              
                              −
                              
                                 
                                    C
                                 
                                 
                                    2
                                 
                              
                              −
                              ⋯
                              −
                              
                                 
                                    C
                                 
                                 
                                    m
                                 
                              
                            is looked as a code connector, not a subtraction operator, here.

In Fig. 9, surface region 
                              g
                            has four faces 
                              
                                 
                                    f
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    f
                                 
                                 
                                    2
                                 
                              
                              ,
                              
                                 
                                    f
                                 
                                 
                                    3
                                 
                              
                            and 
                              
                                 
                                    f
                                 
                                 
                                    4
                                 
                              
                           . For the context code of face 
                              v
                              =
                              
                                 
                                    f
                                 
                                 
                                    4
                                 
                              
                              ,
                              
                                 
                                    f
                                 
                                 
                                    4
                                 
                              
                            lies in layer 
                              
                                 
                                    L
                                 
                                 
                                    0
                                 
                              
                            and 
                              f
                              
                                 (
                                 v
                                 )
                              
                              =
                              00
                           . 
                              
                                 
                                    L
                                 
                                 
                                    1
                                 
                              
                            has 
                              
                                 
                                    f
                                 
                                 
                                    1
                                 
                              
                            and 
                              
                                 
                                    f
                                 
                                 
                                    3
                                 
                              
                              ,
                              f
                              
                                 (
                                 
                                    
                                       f
                                    
                                    
                                       1
                                    
                                 
                                 )
                              
                              =
                              f
                              
                                 (
                                 
                                    
                                       f
                                    
                                    
                                       3
                                    
                                 
                                 )
                              
                              =
                              00
                              ,
                              
                                 |
                                 
                                    
                                       L
                                    
                                    
                                       1
                                    
                                 
                                 |
                              
                              =
                              2
                           , and then 
                              
                                 
                                    l
                                 
                                 
                                    1
                                 
                              
                              =
                              00
                           . There are two edges between layer 
                              
                                 
                                    L
                                 
                                 
                                    0
                                 
                              
                            and 
                              
                                 
                                    L
                                 
                                 
                                    1
                                 
                              
                            whose codes are 
                              e
                              
                                 (
                                 e
                                 
                                    (
                                    
                                       
                                          f
                                       
                                       
                                          4
                                       
                                    
                                    ,
                                    
                                       
                                          f
                                       
                                       
                                          1
                                       
                                    
                                    )
                                 
                                 )
                              
                              =
                              e
                              
                                 (
                                 e
                                 
                                    (
                                    
                                       
                                          f
                                       
                                       
                                          4
                                       
                                    
                                    ,
                                    
                                       
                                          f
                                       
                                       
                                          3
                                       
                                    
                                    )
                                 
                                 )
                              
                              =
                              25
                              ,
                              
                                 |
                                 
                                    
                                       L
                                    
                                    
                                       0
                                    
                                 
                                 ×
                                 
                                    
                                       L
                                    
                                    
                                       1
                                    
                                 
                                 |
                              
                              =
                              2
                           , and hence 
                              
                                 
                                    i
                                 
                                 
                                    1
                                 
                              
                              =
                              25
                           . At the same time, there is only one edge in layer 
                              
                                 
                                    L
                                 
                                 
                                    1
                                 
                              
                            with code 
                              e
                              
                                 (
                                 e
                                 
                                    (
                                    
                                       
                                          f
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          f
                                       
                                       
                                          3
                                       
                                    
                                    )
                                 
                                 )
                              
                              =
                              25
                              ,
                              
                                 |
                                 
                                    
                                       L
                                    
                                    
                                       1
                                    
                                 
                                 ×
                                 
                                    
                                       L
                                    
                                    
                                       1
                                    
                                 
                                 |
                              
                              =
                              1
                           , and therefore 
                              
                                 
                                    o
                                 
                                 
                                    1
                                 
                              
                              =
                              1
                           . Thus, 
                              
                                 
                                    C
                                 
                                 
                                    1
                                 
                              
                              =
                              002525
                           . Furthermore, layer 
                              
                                 
                                    L
                                 
                                 
                                    2
                                 
                              
                            has one face 
                              
                                 
                                    f
                                 
                                 
                                    2
                                 
                              
                           , its code 
                              f
                              
                                 (
                                 
                                    
                                       f
                                    
                                    
                                       2
                                    
                                 
                                 )
                              
                              =
                              00
                           , and the code for the layer is calculated as 
                              
                                 
                                    l
                                 
                                 
                                    2
                                 
                              
                              =
                              00
                           . The partial code 
                              
                                 
                                    i
                                 
                                 
                                    2
                                 
                              
                            describing the edges between 
                              
                                 
                                    L
                                 
                                 
                                    1
                                 
                              
                            and 
                              
                                 
                                    L
                                 
                                 
                                    2
                                 
                              
                            can be obtained from the numbers 
                              e
                              
                                 (
                                 e
                                 
                                    (
                                    
                                       
                                          f
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          f
                                       
                                       
                                          2
                                       
                                    
                                    )
                                 
                                 )
                              
                              =
                              e
                              
                                 (
                                 e
                                 
                                    (
                                    
                                       
                                          f
                                       
                                       
                                          3
                                       
                                    
                                    ,
                                    
                                       
                                          f
                                       
                                       
                                          2
                                       
                                    
                                    )
                                 
                                 )
                              
                              =
                              25
                            and 
                              
                                 |
                                 
                                    
                                       L
                                    
                                    
                                       1
                                    
                                 
                                 ×
                                 
                                    
                                       L
                                    
                                    
                                       2
                                    
                                 
                                 |
                              
                              =
                              2
                           ; it is 
                              
                                 
                                    i
                                 
                                 
                                    2
                                 
                              
                              =
                              25
                           . Since no edge is in layer 
                              
                                 
                                    L
                                 
                                 
                                    2
                                 
                              
                           , there is 
                              
                                 
                                    o
                                 
                                 
                                    2
                                 
                              
                              =
                              00
                           . Therefore, there is 
                              
                                 
                                    C
                                 
                                 
                                    2
                                 
                              
                              =
                              002500
                           . The calculation is ended because there does not exist 
                              
                                 
                                    L
                                 
                                 
                                    3
                                 
                              
                            for 
                              
                                 
                                    f
                                 
                                 
                                    4
                                 
                              
                           . Finally, 
                              
                                 
                                    f
                                 
                                 
                                    4
                                 
                              
                           ’s context code is composed from 
                              f
                              
                                 (
                                 v
                                 )
                              
                              =
                              00
                              ,
                              
                                 
                                    C
                                 
                                 
                                    1
                                 
                              
                              =
                              002525
                           , and 
                              
                                 
                                    C
                                 
                                 
                                    2
                                 
                              
                              =
                              002500
                           ; it is 00002525002500. In the same way, the context codes for other faces in the region can be calculated; they are 
                              
                                 context
                              
                              
                                 (
                                 
                                    
                                       f
                                    
                                    
                                       1
                                    
                                 
                                 )
                              
                              =
                              00002525
                              ,
                              
                                 context
                              
                              
                                 (
                                 
                                    
                                       f
                                    
                                    
                                       2
                                    
                                 
                                 )
                              
                              =
                              00002525002500
                           , and 
                              
                                 context
                              
                              
                                 (
                                 
                                    
                                       f
                                    
                                    
                                       3
                                    
                                 
                                 )
                              
                              =
                              00002525
                           .

The context codes of faces in a region are utilized to describe the shape of the region through its faces’ shapes and their adjacency relations. One of shortage for this kind of shape description approaches is that they are sensitive to the structure of region’s FAG; small features like fillets and chamfers may have equal effects on the code formation as other major shape features. To overcome this problem, these small features are filtered out in the calculations of face context codes. Here, a face is shrunk to be an edge or a vertex if the ratio between its length and width is greater than a threshold (such as 15) or the ratio between its area and the total area of the region is smaller than a threshold (such as 0.05).

In the proposed approach, partial retrieval of CAD models is based on matching surface region codes. Here, two surface regions are matched if they have the same or similar region description codes, which are composed of three parts: header, adj and context, presented in the last section. Actually, the three parts in the code provide different levels of details for the model description. The matching with rough description codes, header and adj, can efficiently excludes some irrelevant surface regions of data models in partial model retrieval. The more detailed matching with context codes is just applied to the models that have passed through the rough matching; this can save the model comparison time again.

Here, partial-model retrievals are realized in two ways, rough retrieval and exact retrieval, which are provided for meeting various partial-model retrieval requirements. Rough retrieval can find submodels that have a certain similarity to the query. When users are not sure what are their desired reusable submodels and only aim at getting inspiration from retrieved submodels, they may prefer to use the rough retrieval. Exact retrieval is based on all the three-code matching, which usually returns less submodels. It supports users to discover those submodels similar to the query in all aspects.

For a surface region, there is only one header code but it usually has multiple region adjacency codes and multiple face context codes; this is because each edge on the region boundary has a code adj and each face within the region has a code context. In order to compare the multiple codes among different regions conveniently, the codes for a region are compared with each other first, and then the numbers of the boundary edges or faces with the same codes are counted. The statistic results are expressed as follows: 
                           
                              
                                 
                                    
                                       adjs =
                                    
                                    
                                       {
                                       
                                          
                                             n
                                          
                                          
                                             a
                                             ,
                                             1
                                          
                                       
                                       -
                                       
                                          
                                             
                                                adj
                                             
                                          
                                          
                                             1
                                          
                                       
                                       ,
                                       
                                          
                                             n
                                          
                                          
                                             a
                                             ,
                                             2
                                          
                                       
                                       -
                                       
                                          
                                             
                                                adj
                                             
                                          
                                          
                                             2
                                          
                                       
                                       ,
                                       …
                                       ,
                                       
                                          
                                             n
                                          
                                          
                                             a
                                             ,
                                             m
                                          
                                       
                                       -
                                       
                                          
                                             
                                                adj
                                             
                                          
                                          
                                             m
                                          
                                       
                                       }
                                    
                                    ;
                                 
                              
                              
                                 
                                    
                                       contexts
                                    
                                    =
                                    
                                       {
                                       
                                          
                                             n
                                          
                                          
                                             c
                                             ,
                                             1
                                          
                                       
                                       -
                                       
                                          
                                             
                                                context
                                             
                                          
                                          
                                             1
                                          
                                       
                                       ,
                                       
                                          
                                             n
                                          
                                          
                                             c
                                             ,
                                             2
                                          
                                       
                                       -
                                       
                                          
                                             
                                                context
                                             
                                          
                                          
                                             2
                                          
                                       
                                       ,
                                       …
                                       ,
                                       
                                          
                                             n
                                          
                                          
                                             c
                                             ,
                                             n
                                          
                                       
                                       -
                                       
                                          
                                             
                                                context
                                             
                                          
                                          
                                             n
                                          
                                       
                                       }
                                    
                                    .
                                 
                              
                           
                         In the above expressing, 
                           
                              
                                 
                                    adj
                                 
                              
                              
                                 i
                              
                           
                           
                           
                              (
                              1
                              ≤
                              i
                              ≤
                              m
                              )
                           
                         are the 
                           m
                         distinct adj codes and 
                           
                              
                                 n
                              
                              
                                 a
                                 ,
                                 i
                              
                           
                         are the numbers of region boundary edges with code 
                           
                              
                                 
                                    adj
                                 
                              
                              
                                 i
                              
                           
                        . Similarly, 
                           
                              
                                 
                                    context
                                 
                              
                              
                                 j
                              
                           
                           
                           
                              (
                              1
                              ≤
                              j
                              ≤
                              n
                              )
                           
                         are the 
                           n
                         distinct context codes and 
                           
                              
                                 n
                              
                              
                                 c
                                 ,
                                 j
                              
                           
                         are the numbers of faces with code 
                           
                              
                                 
                                    context
                                 
                              
                              
                                 j
                              
                           
                         in the region.

Given the query model’s region 
                           
                              
                                 r
                              
                              
                                 q
                              
                           
                         and a data model’s region 
                           
                              
                                 r
                              
                              
                                 d
                              
                           
                        , let 
                           
                              
                                 
                                    header
                                 
                              
                              
                                 q
                              
                           
                         and 
                           
                              
                                 
                                    header
                                 
                              
                              
                                 d
                              
                           
                         respectively be their header codes, and 
                           
                              
                                 
                                    contexts
                                 
                              
                              
                                 q
                              
                           
                         and 
                           
                              
                                 
                                    contexts
                                 
                              
                              
                                 d
                              
                           
                         respectively be their face context codes, which have the following forms: 
                           
                              
                                 
                                    
                                       
                                          
                                             contexts
                                          
                                       
                                       
                                          q
                                       
                                    
                                    =
                                    
                                       {
                                       
                                          
                                             n
                                          
                                          
                                             q
                                             ,
                                             1
                                          
                                       
                                       -
                                       
                                          
                                             
                                                context
                                             
                                          
                                          
                                             q
                                             ,
                                             1
                                          
                                       
                                       ,
                                       
                                          
                                             n
                                          
                                          
                                             q
                                             ,
                                             2
                                          
                                       
                                       -
                                       
                                          
                                             
                                                context
                                             
                                          
                                          
                                             q
                                             ,
                                             2
                                          
                                       
                                       ,
                                       …
                                       ,
                                       
                                          
                                             n
                                          
                                          
                                             q
                                             ,
                                             m
                                          
                                       
                                       -
                                       
                                          
                                             
                                                context
                                             
                                          
                                          
                                             q
                                             ,
                                             m
                                          
                                       
                                       }
                                    
                                 
                              
                              
                                 
                                    
                                       
                                          
                                             contexts
                                          
                                       
                                       
                                          d
                                       
                                    
                                    =
                                    
                                       {
                                       
                                          
                                             n
                                          
                                          
                                             d
                                             ,
                                             1
                                          
                                       
                                       -
                                       
                                          
                                             
                                                context
                                             
                                          
                                          
                                             d
                                             ,
                                             1
                                          
                                       
                                       ,
                                       
                                          
                                             n
                                          
                                          
                                             d
                                             ,
                                             2
                                          
                                       
                                       -
                                       
                                          
                                             
                                                context
                                             
                                          
                                          
                                             d
                                             ,
                                             2
                                          
                                       
                                       ,
                                       …
                                       ,
                                       
                                          
                                             n
                                          
                                          
                                             d
                                             ,
                                             n
                                          
                                       
                                       -
                                       
                                          
                                             
                                                context
                                             
                                          
                                          
                                             d
                                             ,
                                             n
                                          
                                       
                                       }
                                    
                                    .
                                 
                              
                           
                        
                     

When 
                           
                              
                                 
                                    header
                                 
                              
                              
                                 q
                              
                           
                           =
                           
                              
                                 
                                    header
                                 
                              
                              
                                 d
                              
                           
                         and for each 
                           
                              
                                 
                                    context
                                 
                              
                              
                                 q
                                 ,
                                 i
                              
                           
                         in region 
                           
                              
                                 r
                              
                              
                                 q
                              
                           
                         there exists an equal 
                           
                              
                                 
                                    context
                                 
                              
                              
                                 d
                                 ,
                                 j
                              
                           
                         in region 
                           
                              
                                 r
                              
                              
                                 d
                              
                           
                        , the properties of regions 
                           
                              
                                 r
                              
                              
                                 q
                              
                           
                         and 
                           
                              
                                 r
                              
                              
                                 d
                              
                           
                         are thought to be matched in the rough mode. In addition to the above conditions, if 
                           
                              
                                 n
                              
                              
                                 q
                                 ,
                                 i
                              
                           
                           =
                           
                              
                                 n
                              
                              
                                 d
                                 ,
                                 j
                              
                           
                        , their properties are thought to be matched in the exact mode.

Like the matching conditions for region properties, those for region adjacency relations are defined as follows. Suppose 
                           
                              
                                 r
                              
                              
                                 q
                              
                           
                         is the query model’s region that needs to be matched and 
                           
                              
                                 r
                              
                              
                                 d
                              
                           
                         is a region of data model. Meanwhile, let 
                           
                              
                                 
                                    adjs
                                 
                              
                              
                                 q
                              
                           
                         and 
                           
                              
                                 
                                    adjs
                                 
                              
                              
                                 d
                              
                           
                         be their respective adjacency relation properties codes, which have the following forms: 
                           
                              
                                 
                                    
                                       
                                          
                                             adjs
                                          
                                       
                                       
                                          q
                                       
                                    
                                    =
                                    
                                       {
                                       
                                          
                                             n
                                          
                                          
                                             q
                                             ,
                                             1
                                          
                                       
                                       -
                                       
                                          
                                             
                                                adj
                                             
                                          
                                          
                                             q
                                             ,
                                             1
                                          
                                       
                                       ,
                                       
                                          
                                             n
                                          
                                          
                                             q
                                             ,
                                             2
                                          
                                       
                                       -
                                       
                                          
                                             
                                                adj
                                             
                                          
                                          
                                             q
                                             ,
                                             2
                                          
                                       
                                       ,
                                       …
                                       ,
                                       
                                          
                                             n
                                          
                                          
                                             q
                                             ,
                                             m
                                          
                                       
                                       -
                                       
                                          
                                             
                                                adj
                                             
                                          
                                          
                                             q
                                             ,
                                             m
                                          
                                       
                                       }
                                    
                                 
                              
                              
                                 
                                    
                                       
                                          
                                             adjs
                                          
                                       
                                       
                                          d
                                       
                                    
                                    =
                                    
                                       {
                                       
                                          
                                             n
                                          
                                          
                                             d
                                             ,
                                             1
                                          
                                       
                                       -
                                       
                                          
                                             
                                                adj
                                             
                                          
                                          
                                             d
                                             ,
                                             1
                                          
                                       
                                       ,
                                       
                                          
                                             n
                                          
                                          
                                             d
                                             ,
                                             2
                                          
                                       
                                       -
                                       
                                          
                                             
                                                adj
                                             
                                          
                                          
                                             d
                                             ,
                                             2
                                          
                                       
                                       ,
                                       …
                                       ,
                                       
                                          
                                             n
                                          
                                          
                                             d
                                             ,
                                             n
                                          
                                       
                                       -
                                       
                                          
                                             
                                                adj
                                             
                                          
                                          
                                             d
                                             ,
                                             n
                                          
                                       
                                       }
                                    
                                    .
                                 
                              
                           
                        
                     

If each 
                           
                              
                                 
                                    adj
                                 
                              
                              
                                 q
                                 ,
                                 i
                              
                           
                         of region 
                           
                              
                                 r
                              
                              
                                 q
                              
                           
                         can be matched by certain code 
                           
                              
                                 
                                    adj
                                 
                              
                              
                                 d
                                 ,
                                 j
                              
                           
                         of region 
                           
                              
                                 r
                              
                              
                                 d
                              
                           
                        , the adjacency relations of regions 
                           
                              
                                 r
                              
                              
                                 q
                              
                           
                         and 
                           
                              
                                 r
                              
                              
                                 d
                              
                           
                         are thought to be matched in the rough mode. In addition to the above conditions, if 
                           
                              
                                 n
                              
                              
                                 q
                                 ,
                                 i
                              
                           
                           =
                           
                              
                                 n
                              
                              
                                 d
                                 ,
                                 j
                              
                           
                        , their adjacency relations are said to be matched in the exact mode.

For a query model region 
                           
                              
                                 r
                              
                              
                                 q
                              
                           
                         and a data model region 
                           
                              
                                 r
                              
                              
                                 d
                              
                           
                        , if their region properties and adjacency relations are both matched in the rough mode, we define that regions 
                           
                              
                                 r
                              
                              
                                 q
                              
                           
                         and 
                           
                              
                                 r
                              
                              
                                 d
                              
                           
                         are matched in the rough mode. Meanwhile, when their region properties and adjacency relations are both matched in the exact mode, we call that regions 
                           
                              
                                 r
                              
                              
                                 q
                              
                           
                         and 
                           
                              
                                 r
                              
                              
                                 d
                              
                           
                         are matched in the exact mode.


                        Table 1
                         together with Fig. 10
                         presents an example of surface region matching. In this example, query model 
                           
                              
                                 M
                              
                              
                                 q
                              
                           
                         and data model 
                           
                              
                                 M
                              
                              
                                 d
                              
                           
                         respectively have 11 and 10 surfaces but both have 7 surface regions. For each of their regions, its header, adjs and contexts are listed in the table. According to the matching conditions defined in the previous subsections, we can find the matched regions from 
                           
                              
                                 M
                              
                              
                                 q
                              
                           
                         and 
                           
                              
                                 M
                              
                              
                                 d
                              
                           
                        . These matched region pairs are presented with connection lines in Fig. 10.

The proposed approach has been implemented and it has also been applied to the partial model retrievals for two model databases. Here, some experiment results are first presented, and then its real effect and efficiency are discussed.

Here, four CAD models (Cimplex, Simple Boeing, Part 9 and Part 10) in Fig. 4 of  [23] are used to examine the quality of the surface region decomposition. For a comparison, the clustering result 
                              
                                 
                                    S
                                 
                                 
                                    c
                                 
                              
                            and optimized result 
                              S
                            are listed together with those presented in Fig. 4 of  [23] and they are all shown in Table 2
                           . In Table 2, each region is assigned a separate color. Obviously, local surface regions in clustering result 
                              
                                 
                                    S
                                 
                                 
                                    c
                                 
                              
                            and optimized result 
                              S
                            are more reasonable and salient geometric features are more outstanding.

In order to validate the proposed approach in this paper, experiments have been conducted for the subpart matching between query and library models. These tests were performed on a computer with an Intel 3.0 GHz CPU and 1.0 GB RAM, and the model libraries are the National Design Repository and Purdue Engineering Shape Benchmark. The former includes 554 classified CAD models with ACIS format while the latter possesses 446.

First, three typical subparts with rich features in the first library (http://www.designrepository.org/datasets) are selected to evaluate the retrieval effect and efficiency of the program developed based on the proposed partial CAD model retrieval approach. In Table 3
                           , the three subparts, respectively having 4, 6 and 9 faces, selected from query models are presented in orange color, while their similar subparts found in the library are shown in red color. Meanwhile, their search time is also listed in the table. Since surface region decompositions and region code generations are carried out in the offline phase, the search time listed in the table does not include the time for the two types of offline computation. In addition, they are the average time of 50 runs of the program for a partial retrieval. If surface region header code header is used to filter the irrelevant surface regions in library models, the retrieval efficiency can be noticeably improved. Experimental results show that the proposed approach well supports the partial retrieval of CAD models and it is promising to meet the requirement of engineering applications.

Then, we adopt the conventional precision–recall plot to assess the retrieval performance of the proposed partial retrieval approach by using the Functional Classification Dataset in Table 1 of  [23]. This dataset is downloaded from http://www.designrepository.org/datasets/functional, which includes 70 mechanical classification models. For a comparison, a precision–recall graph for the proposed approach is drawn in Fig. 11
                           (a) while the precision–recall curves presented in Fig. 10 of  [23] are redrawn in Fig. 11(b). In our approach, average 65% surface region of a model is selected to perform partial retrieval and returned models is regarded as retrieval results. The curves in Fig. 11(a) show that rough retrieval has its advantage in the recall aspect while exact retrieval has its merit in the precision aspect. In Fig. 11(b), curve 1 is for Reeb graph technique, curve 2 is for Scale-Space technique with the max-angle distance function and simple subgraph isomorphism for matching, curve 3 is for the original Scale-Space technique with a geodesic distance function, and curve 4 is for random retrieval technique. From Fig. 11(a) and (b), we can find that our method has advantages in the precision aspect. In addition, the more surface regions and the more complicated models are selected for partial retrieval, the higher precision the proposed approach appears to have.

Finally, we plot another precision–recall graph to evaluate the retrieval performance of the proposed approach by using Flat-Thin Walled Components dataset in Table 1 of  [37]. This dataset is downloaded from https://engineering.purdue.edu/cdesign/wp/?page_id=1386, which possesses 95 mechanical classification models. For a comparison, two precision–recall curves for the proposed approach are provided in Fig. 12
                           (a) while the precision–recall curves presented in Fig. 11 of  [37] are shown in Fig. 12(b). In our approach, average 65% surface region of a model is selected to perform partial retrieval and returned models is regarded as retrieval results. In Fig. 12(b), the methods based on 2D drawings outperformed other methods while 3D shape distributions and Surface Area and Volume performed better than the rest of the three methods based on more complex feature vectors, viz., SH, CHH, and SAH. In general, our method has advantages in the precision aspect.

@&#DISCUSSIONS@&#

For partial model retrieval, the FAG description has an advantage that the description is convenient to be created directly from CAD model’s boundary representation and the existing subgraph matching algorithms can be used for the model comparison. However, the sizes of FAGs for CAD models may be large and subgraph matching may not be efficient enough because the matching is an NP problem. The significant contributions of our work are that the computational complexity for model comparison is greatly reduced through surface region decomposition and the method efficiency for the surface region decomposition is also achieved with a multi-step process strategy.

The results of experiments have shown some advantages of the proposed approach. First, the region decomposition is efficient even for complex models and it can produce reasonable model surface partitions, in which most regions are salient geometric features with certain engineering semantics. Second, the face context codes used for region shape matching, which capture the information of face adjacency relations, possess excellent capability of differentiating region shapes.

Meanwhile, the experiments also reveal some limitations of the method. First, the segmentation approach does not consider saddle surfaces and hence the surface shape comparison cannot be applied to the comparison of these surfaces. Second, although the proposed B-rep model segmentation approach could be adapted to mesh models, the face context code method cannot be used for shape description of these models; this means the proposed partial model retrieval method is only for B-rep format CAD models. Third, since the face context code is a topology-based shape description method, it is sensitive to small variations of face constitution and relations. Although some measures like elimination of small and narrow faces are adopted, more efforts are still required for achieving a better noise-tolerancing capability.

@&#CONCLUSIONS@&#

In this research, a partial CAD model retrieval approach is developed by handling model’s face adjacency graphs, which mainly consists of three aspects: local surface region decomposition, surface region description based on shape codes, and local shape comparison through matching the region shape codes. To reflect salient geometric features in a model, which are the basic shape elements in most partial model retrievals, the region decomposition is performed by separating regions with different convexity. For user’s queries with hybrid convexity, multiple regions with different convexity can be considered simultaneously. To address the issue that there exist alternative decompositions based on region convexity for a given model, which may cause the indeterminate problem in the retrieval, the decompositions for both query models and data models are carried out with a determinate process controlled by an appropriate optimization criterion. Although local regions are often with relatively less faces compared with whole models, their matching efficiency still needs to be guaranteed with certain measures for practical applications. Here, face context codes combined with the codes reflecting region’s convexity and relations are further generated from region’s FAG to serve as the substitutes of the original FAG shape description, and consequently the matching efficiency is achieved by replacing the subgraph-isomorphism checking process with the comparison of the codes. Experiments show that the face context codes have good shape differentiating capability. In summary, the proposed approach is an efficient and effective approach for partial CAD model retrieval.

@&#ACKNOWLEDGMENTS@&#

This work was supported by the National Natural Science Foundation of China (Nos. 61173115, 51275182 and 50935004), the Innovation Foundation of Shanghai Aerospace Science and Technology (SAST201208) and the Scientific Research Project of Hubei Educational Department (B2013229).

@&#REFERENCES@&#

