@&#MAIN-TITLE@&#Capacity level modeling of mobile device bandwidth requirements employing high utilization mobile applications

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We find the 7% of applications responsible for 75% of data in a mobile device dataset.


                        
                        
                           
                           Active and background applications are aggregated for limited parameters.


                        
                        
                           
                           We simulate a mobile device based on these applications using a 4 state Markov Model.


                        
                        
                           
                           Using exponential distributions, simulated results are within 10% of submitted data.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Mobile communication

User modeling

Data communication

Simulation

@&#ABSTRACT@&#


               
               
                  Mobile network providers face an ever-increasing number of mobile devices requesting similarly increasing amounts of data. In this article, we present a two-step approach to modeling and simulating the amounts of data produced by mobile devices based on applications that are highly utilized on the network. In the first step, we separate the applications on a mobile device into highly utilized and background ones for the overall population to be modeled. With the identified overall application groups, we employ a four-state Hidden Markov Model to capture the characteristics of the high utilization applications as aggregates per device; the characteristics of the background applications are matched to four states, dependent on the high utilization aggregates’ states. Utilizing the Exponential distribution for both, we closely match their original user-based characteristics. The suitability of our model is lastly corroborated through simulation-based comparisons of estimations for the bandwidth requirements of the individual users; or our model’s estimates are typically within ten percent of the original values.
               
            

@&#INTRODUCTION@&#

With the continuous broad proliferation of smart mobile devices, a sustained growth of mobile data is predicted for years to come [1]. Cellular network service providers face the challenges associated with satisfying this demand for data communications from mobile end devices. Oftentimes, these providers resolve to traffic reduction means for their networks, such as data offloading to co-located wireless local area networks. Planning of current and future network capacities requires modeling the data transmission requirements that are resulting from the activities of mobile users. In recent research works, in turn, several studies investigated the characteristics and potential for modeling and simulation of individual mobile user data consumption characteristics.

While providers can investigate their subscriber’s network activity, these cellular network-level measurements typically provide only one viewpoint (which is commonly aggregated or by application-centric endpoints). Evaluations of mobile network utilization have indicated that mobile smart devices have to be considered differently when compared to laptops, see, e.g., [2,3]. Additionally, common mobile device usages have been found to exhibit significant patterns with respect to applications used and the networked data that is produced/consumed by them, e.g., in the context of energy savings as outlined in [4]. Similarly, from a research point of view, these activities require cooperations with network providers, see, e.g., [5]. An actual user device-level evaluation is more difficult to achieve; this confinement is a special concern in light of heightened user considerations of privacy when relying on voluntarily provided data.

Several past studies have gathered datasets of users across different domains and presented initial (partially complex) models, such as in [6], where the authors examine a study of users and their mobile device utilization behavior patterns and resulting characteristics. They report a broad variation amongst users and conclude that, in turn, for optimizations, a learning approach seems most suitable. Similarly, in [7] the authors describe a broad disparity across user types, whereby they identify normal and heavy users; the latter 3% of all users was found to account for almost half of the network traffic. These findings correlate with other observations, e.g., such as those in [8], indicating a general trend. In [9], the authors propose to use a combination of Zipf-distribution and Markov models to represent the network traffic behavior between different devices and applications thereon. The authors continue their model by grouping devices into low, medium, and high different network activity classes, similar to the two user classes in [7], but slightly more focused on device diversity. Their model for a network provider based level of finer grained data shows good estimations of general behaviors. Further studies, such as [10], compare additional factors, e.g., wireline and wireless traffic comparison across applications. In [10], the authors find that wireless HTTP based application traffic can exceed wireline application specific counterparts, indicating broad traffic variability.

In [11], the authors present a measurement-study with a similar approach to ours; they report their findings for a crowd-sourced data collection employing a mobile Android application and results from controlled experiments. They also group the applications and users based on their utilization and network traffic characteristics into high and low categories.

We are motivated by these prior works and target the modeling of the device level activity with respect to the amount of data exchanged over connected networks. In particular, based on the prior results, we provide a simplified modeling approach that is based only on two classes of applications, namely (i) high utilization applications and (ii) remaining ones, which we aggregate into a background activity. We assume that the high utilization applications can be utilized to model the overall device behavior in an efficient manner. The proposed model is in turn suitable for broad application scenario ranges, even if only basic or aggregate parameters of main applications on mobile devices are known by, e.g., a cellular network provider wishing to evaluate capacities. A description of the characteristics of the device-level activities for volunteer-submitted data that captured network activities in 2-hour intervals over varying time horizons was presented in [12]. Due to space limitations, we refer to [12] for greater details about the dataset, which we utilize as basis.
                        2
                        The dataset is available for download from http://www.disclab.org and http://patrick.seeling.org.
                     
                     
                        2
                     
                  

The remainder of this article is structured as follows. In the following section, we initially present the identification of application classes and the categorization of mobile applications into the high utilization category. We subsequently describe our modeling and simulation concept in Section 3, whereby we initially describe a static approach, followed by a process flow description. We subsequently evaluate the performance of our approach through simulation in Section 4, before we conclude in Section 5.

In this section, we initially discuss the overall approach we employ in clustering the determined application characteristics from the submitted volunteer data into different categories before we describe the outcomes for different characteristics.

We denote an individual application package 
                           
                              
                                 
                                    a
                                 
                                 
                                    i
                                 
                              
                              ,
                              i
                              =
                              1
                              ,
                              2
                              ,
                              …
                              ,
                              I
                           
                         for which we obtained data from the participating users 
                           
                              
                                 
                                    u
                                 
                                 
                                    j
                                 
                              
                              ,
                              j
                              =
                              1
                              ,
                              2
                              ,
                              …
                              ,
                              J
                           
                        . (E.g., we consider 
                           
                              
                                 
                                    a
                                 
                                 
                                    3
                                 
                              
                           
                        
                        =‘com.android.browser’ for the default system web browser application present at the user indexed as “5,” namely 
                           
                              
                                 
                                    u
                                 
                                 
                                    5
                                 
                              
                           
                        .) We note that not every individual applications 
                           
                              
                                 
                                    a
                                 
                                 
                                    i
                                 
                              
                           
                         might be present within each individual user’s 
                           
                              
                                 
                                    u
                                 
                                 
                                    j
                                 
                              
                           
                         submitted dataset. We additionally designate 
                           
                              t
                              =
                              0
                              ,
                              …
                              ,
                              T
                              (
                              
                                 
                                    u
                                 
                                 
                                    j
                                 
                              
                              )
                           
                         to denote the time, as each user submission features an individual length of time in the submitted dataset, measured in activity within 2-h bins. Let 
                           
                              x
                              (
                              
                                 
                                    a
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    u
                                 
                                 
                                    j
                                 
                              
                              ,
                              t
                              )
                           
                         refer to the amount of data produced by a mobile application within such a bin.

For an individual user 
                           
                              
                                 
                                    u
                                 
                                 
                                    j
                                 
                              
                           
                        , we thus calculate the total amount of data for a present application package 
                           
                              
                                 
                                    a
                                 
                                 
                                    i
                                 
                              
                           
                         as
                           
                              (1)
                              
                                 X
                                 (
                                 
                                    
                                       a
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       u
                                    
                                    
                                       j
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          t
                                       
                                    
                                 
                                 x
                                 (
                                 
                                    
                                       a
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       u
                                    
                                    
                                       j
                                    
                                 
                                 ,
                                 t
                                 )
                              
                           
                        and the average as
                           
                              (2)
                              
                                 
                                    
                                       x
                                    
                                    
                                       ‾
                                    
                                 
                                 (
                                 
                                    
                                       a
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       u
                                    
                                    
                                       j
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       X
                                       (
                                       
                                          
                                             a
                                          
                                          
                                             i
                                          
                                       
                                       ,
                                       
                                          
                                             u
                                          
                                          
                                             j
                                          
                                       
                                       )
                                    
                                    
                                       T
                                       (
                                       
                                          
                                             u
                                          
                                          
                                             j
                                          
                                       
                                       )
                                    
                                 
                                 .
                              
                           
                        
                     

We calculate the overall average amount of data for each application package 
                           
                              
                                 
                                    a
                                 
                                 
                                    i
                                 
                              
                           
                         (with respect to user, time, and data) as
                           
                              (3)
                              
                                 
                                    
                                       X
                                    
                                    
                                       ‾
                                    
                                 
                                 (
                                 
                                    
                                       a
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             j
                                          
                                       
                                       
                                          
                                             x
                                          
                                          
                                             ‾
                                          
                                       
                                       (
                                       
                                          
                                             a
                                          
                                          
                                             i
                                          
                                       
                                       ,
                                       
                                          
                                             u
                                          
                                          
                                             j
                                          
                                       
                                       )
                                    
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             j
                                          
                                       
                                       
                                          
                                             
                                                X
                                                (
                                                
                                                   
                                                      a
                                                   
                                                   
                                                      i
                                                   
                                                
                                                ,
                                                
                                                   
                                                      u
                                                   
                                                   
                                                      j
                                                   
                                                
                                                )
                                                >
                                                0
                                             
                                          
                                       
                                    
                                 
                                 ,
                              
                           
                        whereby 
                           
                              [
                              ·
                              ]
                           
                         represents the Iverson Bracket. We determine other individual and aggregate sample statistics, such as the standard deviation of an application’s produced data 
                           
                              
                                 
                                    σ
                                 
                                 
                                    x
                                    (
                                    
                                       
                                          a
                                       
                                       
                                          i
                                       
                                    
                                    ,
                                    
                                       
                                          u
                                       
                                       
                                          j
                                       
                                    
                                    )
                                 
                              
                           
                        , in a similar manner. Furthermore, the activity for an individual application 
                           
                              
                                 
                                    a
                                 
                                 
                                    i
                                 
                              
                           
                        , i.e., the amount of time the application was utilizing the network interface(s), is captured as 
                           
                              τ
                              (
                              
                                 
                                    a
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    u
                                 
                                 
                                    j
                                 
                              
                              )
                           
                         and the aggregate statistics in a similar fashion as 
                           
                              T
                              (
                              
                                 
                                    a
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    u
                                 
                                 
                                    j
                                 
                              
                              )
                              ,
                              
                                 
                                    τ
                                 
                                 
                                    ‾
                                 
                              
                              (
                              
                                 
                                    a
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    u
                                 
                                 
                                    j
                                 
                              
                              )
                              ,
                              
                                 
                                    T
                                 
                                 
                                    ‾
                                 
                              
                              (
                              
                                 
                                    a
                                 
                                 
                                    i
                                 
                              
                              )
                           
                        , and 
                           
                              
                                 
                                    σ
                                 
                                 
                                    τ
                                    (
                                    
                                       
                                          a
                                       
                                       
                                          i
                                       
                                    
                                    ,
                                    
                                       
                                          u
                                       
                                       
                                          j
                                       
                                    
                                    )
                                 
                              
                           
                        .

To normalize for the differences amongst users, not applications, we calculate the Z-score for each application 
                           
                              
                                 
                                    a
                                 
                                 
                                    i
                                 
                              
                           
                         based on different characteristics. The Z-score is commonly used for normalization, especially in mixed data, see, e.g., [13]. We determine the Z-score as basis for our clustering in different domains of characteristics, namely (i) the activity level of the application under consideration, (ii) the application data transferred in bytes, (iii) the count of application measurement points, and (iv) the number of users employing the application as follows.

Let 
                           
                              N
                              (
                              
                                 
                                    a
                                 
                                 
                                    i
                                 
                              
                              )
                           
                         denote the number of users for application 
                           
                              
                                 
                                    a
                                 
                                 
                                    i
                                 
                              
                           
                        , i.e.,
                           
                              
                                 N
                                 (
                                 
                                    
                                       a
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                       
                                    
                                 
                                 
                                    
                                       
                                          X
                                          (
                                          
                                             
                                                a
                                             
                                             
                                                i
                                             
                                          
                                          ,
                                          
                                             
                                                u
                                             
                                             
                                                j
                                             
                                          
                                          )
                                          >
                                          0
                                       
                                    
                                 
                                 ,
                              
                           
                        and 
                           
                              
                                 
                                    μ
                                 
                                 
                                    N
                                 
                              
                           
                         denote the average number of all applications and users, i.e.,
                           
                              
                                 
                                    
                                       μ
                                    
                                    
                                       N
                                    
                                 
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                       
                                    
                                 
                                 N
                                 (
                                 
                                    
                                       a
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 /
                                 J
                                 .
                              
                           
                        Similarly, let 
                           
                              
                                 
                                    σ
                                 
                                 
                                    N
                                 
                              
                           
                         denote the standard deviation of all 
                           
                              N
                              (
                              
                                 
                                    a
                                 
                                 
                                    i
                                 
                              
                              )
                           
                        . The Z-score for the number of users of application 
                           
                              
                                 
                                    a
                                 
                                 
                                    i
                                 
                              
                           
                         is in turn calculated as
                           
                              (4)
                              
                                 
                                    
                                       Z
                                    
                                    
                                       N
                                    
                                 
                                 (
                                 
                                    
                                       a
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       N
                                       (
                                       
                                          
                                             a
                                          
                                          
                                             i
                                          
                                       
                                       )
                                       -
                                       
                                          
                                             μ
                                          
                                          
                                             N
                                          
                                       
                                    
                                    
                                       
                                          
                                             σ
                                          
                                          
                                             N
                                          
                                       
                                    
                                 
                                 .
                              
                           
                        
                     

We derive the count of application measurement points as
                           
                              
                                 C
                                 (
                                 
                                    
                                       a
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                       
                                    
                                 
                                 [
                                 X
                                 (
                                 
                                    
                                       a
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       u
                                    
                                    
                                       j
                                    
                                 
                                 )
                                 >
                                 0
                                 ]
                                 ·
                                 [
                                 T
                                 (
                                 
                                    
                                       a
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       u
                                    
                                    
                                       j
                                    
                                 
                                 )
                                 >
                                 0
                                 ]
                                 .
                              
                           
                        and the resulting average as
                           
                              
                                 
                                    
                                       μ
                                    
                                    
                                       C
                                    
                                 
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                       
                                    
                                 
                                 C
                                 (
                                 
                                    
                                       a
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 /
                                 I
                                 .
                              
                           
                        With the standard deviation as 
                           
                              
                                 
                                    σ
                                 
                                 
                                    C
                                 
                              
                           
                        , we denote the Z-score for the count of bins as
                           
                              (5)
                              
                                 
                                    
                                       Z
                                    
                                    
                                       C
                                    
                                 
                                 (
                                 
                                    
                                       a
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       C
                                       (
                                       
                                          
                                             a
                                          
                                          
                                             i
                                          
                                       
                                       )
                                       -
                                       
                                          
                                             μ
                                          
                                          
                                             C
                                          
                                       
                                    
                                    
                                       
                                          
                                             σ
                                          
                                          
                                             C
                                          
                                       
                                    
                                 
                                 .
                              
                           
                        
                     

Calculations for the bytes transferred are performed synonymously utilizing
                           
                              
                                 B
                                 (
                                 
                                    
                                       a
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                       
                                    
                                 
                                 X
                                 (
                                 
                                    
                                       a
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       u
                                    
                                    
                                       j
                                    
                                 
                                 )
                                 ,
                              
                           
                        
                        
                           
                              
                                 
                                    μ
                                 
                                 
                                    B
                                 
                              
                              =
                              
                                 
                                    X
                                 
                                 
                                    ‾
                                 
                              
                              (
                              
                                 
                                    a
                                 
                                 
                                    i
                                 
                              
                              )
                           
                        , and 
                           
                              
                                 
                                    σ
                                 
                                 
                                    B
                                 
                              
                           
                         to derive
                           
                              (6)
                              
                                 
                                    
                                       Z
                                    
                                    
                                       B
                                    
                                 
                                 (
                                 
                                    
                                       a
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       X
                                       (
                                       
                                          
                                             a
                                          
                                          
                                             i
                                          
                                       
                                       )
                                       -
                                       
                                          
                                             μ
                                          
                                          
                                             B
                                          
                                       
                                    
                                    
                                       
                                          
                                             σ
                                          
                                          
                                             B
                                          
                                       
                                    
                                 
                                 .
                              
                           
                        
                     

We denote the time an application utilizes the network as
                           
                              
                                 A
                                 (
                                 
                                    
                                       a
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                       
                                    
                                 
                                 T
                                 (
                                 
                                    
                                       a
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       u
                                    
                                    
                                       j
                                    
                                 
                                 )
                                 .
                              
                           
                        The global average is this calculated as
                           
                              
                                 
                                    
                                       μ
                                    
                                    
                                       A
                                    
                                 
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                       
                                    
                                 
                                 A
                                 (
                                 
                                    
                                       a
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 /
                                 I
                              
                           
                        and the standard deviation denoted as 
                           
                              
                                 
                                    σ
                                 
                                 
                                    A
                                 
                              
                           
                        . We determine the Z-score for the application’s network activity subsequently as
                           
                              (7)
                              
                                 
                                    
                                       Z
                                    
                                    
                                       A
                                    
                                 
                                 (
                                 
                                    
                                       a
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       A
                                       (
                                       
                                          
                                             a
                                          
                                          
                                             i
                                          
                                       
                                       )
                                       -
                                       
                                          
                                             μ
                                          
                                          
                                             A
                                          
                                       
                                    
                                    
                                       
                                          
                                             σ
                                          
                                          
                                             A
                                          
                                       
                                    
                                 
                                 .
                              
                           
                        
                     

The unsupervised k-means clustering approach, see, e.g., [14], is used to group the applications based on their Z-score values obtained. In the following, we now discuss the results for clustering based on these different approaches in greater detail.

Initially, we utilize 
                           
                              
                                 
                                    Z
                                 
                                 
                                    A
                                 
                              
                              ,
                              
                                 
                                    Z
                                 
                                 
                                    B
                                 
                              
                           
                        , and 
                           
                              
                                 
                                    Z
                                 
                                 
                                    N
                                 
                              
                           
                         to cluster the applications into the high, medium, and low categories. Let 
                           
                              
                                 
                                    A
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    A
                                 
                                 
                                    2
                                 
                              
                           
                        , and 
                           
                              
                                 
                                    A
                                 
                                 
                                    3
                                 
                              
                           
                         denote the application sets for high, medium, and low activities (and similar notations for the ones we categorize based on other characteristics, such as B for amounts of data), which we determine relative to other Z-scores, e.g., the determination for the A classes is performed in reference to the application popularity 
                           
                              
                                 
                                    Z
                                 
                                 
                                    N
                                 
                              
                              (
                              
                                 
                                    a
                                 
                                 
                                    i
                                 
                              
                              )
                              :
                              
                                 
                                    Z
                                 
                                 
                                    A
                                 
                              
                              (
                              
                                 
                                    a
                                 
                                 
                                    i
                                 
                              
                              )
                           
                         and B classes similarly. We illustrate the outcome of this initial clustering in Figs. 1 and 2
                        
                         for activity and data classes, respectively. We immediately observe that the majority of evaluated applications is fairly close to the Z-score center around the origin. These applications were categorized into the low activity class 
                           
                              
                                 
                                    A
                                 
                                 
                                    3
                                 
                              
                           
                        . The density decreases linearly as a function of the Z-score for the average active time (activity) of the applications with only a small number falling into the 
                           
                              
                                 
                                    A
                                 
                                 
                                    1
                                 
                              
                           
                         category, e.g., applications such as the Korean chat application ‘com.kakao.talk’. Similarly, when regarding the average application amount of data measured in Z-scores, we observe a mostly vertical dispersion from the majority of applications around the origin. Typical applications in the highest data utilization class include, e.g., the Dropbox client ‘com.dropbox.android‘. We originally reported on this clustering outcome in [15].

The applications we characterize as “High Utilization Applications” belong to both uppermost classes identified through the clustering. In other words, we select applications exhibiting high relative frequency of network time combined with high amounts of transferred data as the set of applications of main interest based on this clustering approach. In the following, we denote these applications as 
                           
                              
                                 
                                    a
                                 
                                 
                                    h
                                 
                              
                           
                        , with 
                           
                              
                                 
                                    a
                                 
                                 
                                    h
                                 
                              
                              ∈
                              {
                              
                                 
                                    H
                                 
                                 
                                    1
                                 
                              
                              }
                              =
                              
                                 
                                    
                                       
                                          
                                             A
                                          
                                          
                                             1
                                          
                                       
                                       ∩
                                       
                                          
                                             B
                                          
                                          
                                             1
                                          
                                       
                                    
                                 
                              
                           
                        . We provide an overview of the characteristics of these applications as identified by the clustering in Table 1
                        .

We initially note that a fairly large variety exists between the applications in the evaluated different dimensions of data, users, and measurement points (bins). We observe that only 12% of the total network traffic originates from these high utilization applications and that their overall number of active bins varies significantly. As reported in [15], utilizing this clustering outcome we were able to achieve a close fit overall for average amounts of data, but lacked a sufficient estimation of the network traffic variability on these longer time scales. In turn, we are motivated to modify the clustering basis to derive a more evenly distributed representation.

We derive from additional data evaluations that most high utilization applications keep running for 24h if the smart devices are turned on for 24h – utilizing the active time from the dataset is hence an unsuitable approach to determine the device-level impact for modeling and simulation. Based on observations, we initially remove the ‘hu.tagsoft.ttorrent.pro’ application, which is an outlier and negatively impacts the overall clustering performance due to the underlying distance metric of the clustering algorithm. We then perform three-dimensional unsupervised k-means clustering, whereby we utilize the combination of 
                           
                              
                                 
                                    Z
                                 
                                 
                                    B
                                 
                              
                              (
                              
                                 
                                    a
                                 
                                 
                                    i
                                 
                              
                              )
                              :
                              
                                 
                                    Z
                                 
                                 
                                    C
                                 
                              
                              (
                              
                                 
                                    a
                                 
                                 
                                    i
                                 
                              
                              )
                              :
                              
                                 
                                    Z
                                 
                                 
                                    N
                                 
                              
                              (
                              
                                 
                                    a
                                 
                                 
                                    i
                                 
                              
                              )
                           
                         to derive the overall high, medium, and low application categories, denoted as 
                           
                              
                                 
                                    H
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    H
                                 
                                 
                                    2
                                 
                              
                           
                        , and 
                           
                              
                                 
                                    H
                                 
                                 
                                    3
                                 
                              
                           
                        , respectively.

Initially, we illustrate the resulting three-dimensional properties of the high utilization applications in category 
                           
                              
                                 
                                    H
                                 
                                 
                                    1
                                 
                              
                           
                         in Fig. 3
                        . We observe that there is no directly visible trend that uniquely describes the characteristics of this application class by itself.

In turn, we illustrate the different projections of the Z-scores for all three categories into the 2-dimensional space in Figs. 4–6
                        
                        
                        .

For the relation of measurement points or bins to application usage in Fig. 4, we observe that the highest category 
                           
                              
                                 
                                    H
                                 
                                 
                                    1
                                 
                              
                           
                         exhibits a very wide diffusion, ranging from slightly less than average users to all users. Similarly, we note that the bins per application are also widely diffused. Overall, higher classes are more diffused and present on more devices with the 
                           
                              
                                 
                                    H
                                 
                                 
                                    1
                                 
                              
                           
                         category seemingly “fanning out” with the number of users and bins. In other words, we note that high utilization applications tend to have more installations and are more frequently used overall.

Next, we illustrate the amount of data in relationship to the installation distribution in Fig. 5. We note that the data points for high utilization application exhibit a similarly widespread distribution amongst users. Outliers with larger amounts of data, however, can be observed for a smaller number of user applications and are more evenly spread across the number of installations.

Thirdly, we project the relationship of the number of bins and the amounts of data onto the 2d plane illustrated in Fig. 6. The comparison of data and bins together exhibits that most applications deviate little from the average of number of bins (measurement points) and average amounts of data observed per application. High utilization applications in category 
                           
                              
                                 
                                    H
                                 
                                 
                                    1
                                 
                              
                           
                        , on the other hand, are deviating significantly from the averages in both data and bin domains.

From the Z-score based clustering, we thus derive that the typical applications that we consider as the main dominators of the mobile device behavior are (i) not necessarily found on every user’s device (i.e., are distributed amongst users), (ii) not necessarily those producing the (individually) largest amounts of data, and (iii) as a general trend have higher levels of activity (bins).

The high utilization applications are in this case determined as 
                           
                              
                                 
                                    a
                                 
                                 
                                    h
                                 
                              
                              ∈
                              
                                 
                                    
                                       
                                          
                                             H
                                          
                                          
                                             1
                                          
                                       
                                    
                                 
                              
                           
                         and we provide an overview of their characteristics in Table 2
                        . The total number of applications that are present in the overall dataset (i.e., across all users) and, in turn, used to access the network at least one time is 512. Based on the three-dimensional clustering, we now reduced the number to 36 applications, which we term high utilization applications 
                           
                              
                                 
                                    a
                                 
                                 
                                    h
                                 
                              
                           
                        . We note that while the total number of high utilization applications increased compared to the previous clustering approach, they now account for an approximate total of 75% of data. In other words, we determined the approximate 7% of applications that are responsible for 75% of networked data in the overall dataset.

We model a mobile user’s device behavior (with respect to data transmissions) based on two different application categories, namely (i) high utilization applications and (ii) background applications. We postulate that the high utilization category’s values determine the device’s overall network behavior and any remaining data is contributed through a background process. In this section, we describe the model and derived values in greater detail.

With the identified high utilization applications 
                           
                              
                                 
                                    a
                                 
                                 
                                    h
                                 
                              
                           
                         determined across all users, we perform a second round of user-specific categorization into high, medium, and low categories for each of these application groups at a user, based on the amounts of data. For this second round, we initially determine
                           
                              (8)
                              
                                 
                                    
                                       X
                                    
                                    
                                       h
                                    
                                 
                                 (
                                 
                                    
                                       u
                                    
                                    
                                       j
                                    
                                 
                                 ,
                                 t
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                       
                                    
                                 
                                 x
                                 (
                                 
                                    
                                       a
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       u
                                    
                                    
                                       j
                                    
                                 
                                 ,
                                 t
                                 )
                                 
                                    
                                       
                                          
                                             
                                                a
                                             
                                             
                                                i
                                             
                                          
                                          ∈
                                          
                                             
                                                H
                                             
                                             
                                                1
                                             
                                          
                                       
                                    
                                 
                                 ,
                                 
                                 ∀
                                 t
                              
                           
                        i.e., we determine the aggregated high utilization amounts for each user 
                           
                              
                                 
                                    u
                                 
                                 
                                    j
                                 
                              
                           
                         at all times t. Similarly, we calculate the background applications’ aggregates as
                           
                              (9)
                              
                                 
                                    
                                       X
                                    
                                    
                                       l
                                    
                                 
                                 (
                                 
                                    
                                       u
                                    
                                    
                                       j
                                    
                                 
                                 ,
                                 t
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                       
                                    
                                 
                                 x
                                 (
                                 
                                    
                                       a
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       u
                                    
                                    
                                       j
                                    
                                 
                                 ,
                                 t
                                 )
                                 
                                    
                                       
                                          
                                             
                                                a
                                             
                                             
                                                i
                                             
                                          
                                          
                                          ∉
                                          
                                          
                                             
                                                H
                                             
                                             
                                                1
                                             
                                          
                                       
                                    
                                 
                                 .
                              
                           
                        With these identified values, we now perform one-dimensional unsupervised k-means clustering to determine three different intensity level groups. This approach is similar to the one outlined in Section 2, but regards the individual users and individual aggregates over time, rather than aggregates across users. The result is a determination of three different states that the combined high utilization applications’ data for user 
                           
                              
                                 
                                    u
                                 
                                 
                                    i
                                 
                              
                           
                         can fall into.

We additionally define a ‘zero application activity’ state to accommodate the cases where no data is generated. As the joint application data amounts can fall into each of the four states over time t, this results in the 4-state Hidden Markov Model (HMM) illustrated in Fig. 7
                        . We denote the four different state types as (Z)ero, (L)ow, (M)edium, and (H)igh. In turn, we now re-evaluate the 
                           
                              
                                 
                                    X
                                 
                                 
                                    h
                                 
                              
                              (
                              
                                 
                                    u
                                 
                                 
                                    j
                                 
                              
                              ,
                              t
                              )
                           
                         over time and map them to one of the four states based on their value as 
                           
                              
                                 
                                    X
                                 
                                 
                                    h
                                 
                              
                              (
                              
                                 
                                    u
                                 
                                 
                                    j
                                 
                              
                              ,
                              t
                              )
                              
                              ↦
                              
                              
                                 
                                    
                                       
                                          
                                             S
                                          
                                          
                                             h
                                          
                                          
                                             Z
                                          
                                       
                                       ,
                                       
                                          
                                             S
                                          
                                          
                                             h
                                          
                                          
                                             L
                                          
                                       
                                       ,
                                       
                                          
                                             S
                                          
                                          
                                             h
                                          
                                          
                                             M
                                          
                                       
                                       ,
                                       
                                          
                                             S
                                          
                                          
                                             h
                                          
                                          
                                             H
                                          
                                       
                                    
                                 
                              
                           
                        . We denote 
                           
                              
                                 
                                    S
                                 
                                 
                                    h
                                 
                                 
                                    Z
                                 
                              
                              ,
                              
                                 
                                    S
                                 
                                 
                                    h
                                 
                                 
                                    L
                                 
                              
                              ,
                              
                                 
                                    S
                                 
                                 
                                    h
                                 
                                 
                                    M
                                 
                              
                           
                        , and 
                           
                              
                                 
                                    S
                                 
                                 
                                    h
                                 
                                 
                                    H
                                 
                              
                           
                         as the high activity application aggregate states (and note that index l denotes the background application aggregate counterparts).

Next, we determine the user-specific state transition probability matrix 
                           
                              
                                 
                                    P
                                 
                                 
                                    h
                                 
                              
                              (
                              
                                 
                                    u
                                 
                                 
                                    j
                                 
                              
                              )
                           
                         for the high utilization applications’ aggregates from the submitted data. In other words, we determine 
                           
                              P
                              (
                              
                                 
                                    S
                                 
                                 
                                    h
                                 
                                 
                                    {
                                    Z
                                    ,
                                    L
                                    ,
                                    M
                                    ,
                                    H
                                    }
                                 
                              
                              (
                              t
                              +
                              1
                              )
                              |
                              
                                 
                                    S
                                 
                                 
                                    h
                                 
                                 
                                    {
                                    Z
                                    ,
                                    L
                                    ,
                                    M
                                    ,
                                    H
                                    }
                                 
                              
                              (
                              t
                              )
                              )
                           
                         from the submitted user data. We note that while we identify the four states for the background applications as well, we do not need to derive the associated state transition probability matrix. Our model assumes that the background application aggregate state results from the highly active application aggregate state, which is an extension of the model we described in [15]. The determination of the states in both categories allows to compare their occurrences in the submitted user data and determine the state-dependent average and standard deviations as 
                           
                              
                                 
                                    μ
                                 
                                 
                                    {
                                    h
                                    ,
                                    l
                                    }
                                 
                                 
                                    {
                                    Z
                                    ,
                                    L
                                    ,
                                    M
                                    ,
                                    H
                                    }
                                 
                              
                           
                         and 
                           
                              
                                 
                                    σ
                                 
                                 
                                    {
                                    h
                                    ,
                                    l
                                    }
                                 
                                 
                                    {
                                    Z
                                    ,
                                    L
                                    ,
                                    M
                                    ,
                                    H
                                    }
                                 
                              
                           
                        , respectively. This allows to subsequently determine the correlation matrix between them, denoted as 
                           
                              
                                 
                                    ρ
                                 
                                 
                                    h
                                    ,
                                    l
                                 
                              
                           
                        . As a result of this approach, we have introduced an additional assumed probability in the derivation of 
                           
                              
                                 
                                    S
                                 
                                 
                                    l
                                 
                              
                           
                         from 
                           
                              
                                 
                                    S
                                 
                                 
                                    h
                                 
                              
                           
                        , which is used in the following dynamic simulation of user activities.

Having described the details of parameter estimation from a static point of view, we now shift our focus to the dynamic utilization in simulations. In the dynamic process view, illustrated in Fig. 8
                        , we initially determine the state of the high utilization application aggregate. We denote the state as 
                           
                              
                                 
                                    S
                                 
                                 
                                    h
                                 
                                 
                                    {
                                    Z
                                    ,
                                    L
                                    ,
                                    M
                                    ,
                                    H
                                    }
                                 
                              
                              (
                              t
                              )
                           
                         as one of the four states at simulation time t in the HMM approach. We assume that state determination is achieved through drawing numbers from a uniform distribution as starting point. With the determined state for the high utilization application aggregate, we now determine the number of bytes using separate probability distributions for each state; the parameters for each of the distributions were fitted to the previously determined 
                           
                              
                                 
                                    μ
                                 
                                 
                                    h
                                 
                                 
                                    {
                                    Z
                                    ,
                                    L
                                    ,
                                    M
                                    ,
                                    H
                                    }
                                 
                              
                           
                         and 
                           
                              
                                 
                                    σ
                                 
                                 
                                    h
                                 
                                 
                                    {
                                    Z
                                    ,
                                    L
                                    ,
                                    M
                                    ,
                                    H
                                    }
                                 
                              
                           
                        . In the following, we omit the indexes for state and time for clarity, noting that the procedure is generally similar. The randomly drawn presumed number of bytes for the high utilization application aggregate is, thus, denoted as 
                           
                              
                                 
                                    Y
                                 
                                 
                                    h
                                 
                              
                              (
                              
                                 
                                    S
                                 
                                 
                                    h
                                 
                              
                              )
                           
                        . We consider different probability distributions to determine 
                           
                              
                                 
                                    Y
                                 
                                 
                                    h
                                 
                              
                           
                        , namely (i) the Folded Normal distribution, (ii) the Gamma distribution, (iii) the Inverse Gaussian distribution, and (iv) the Exponential distribution. In a next step, we now utilize the correlation matrix 
                           
                              
                                 
                                    ρ
                                 
                                 
                                    h
                                    ,
                                    l
                                 
                              
                           
                         to determine by an additional draw from a uniform distribution the state of the background application aggregate 
                           
                              
                                 
                                    S
                                 
                                 
                                    l
                                 
                              
                           
                        . Using the same probability distribution as for the high utilization application aggregate, but now with parameters fitted to 
                           
                              
                                 
                                    μ
                                 
                                 
                                    l
                                 
                              
                           
                         and 
                           
                              
                                 
                                    σ
                                 
                                 
                                    l
                                 
                              
                           
                        , we draw the aggregate bytes generated from the background applications as 
                           
                              
                                 
                                    Y
                                 
                                 
                                    l
                                 
                              
                              (
                              
                                 
                                    S
                                 
                                 
                                    l
                                 
                              
                              )
                           
                        . We then combine the randomly obtained values for the simulated high utilization and background application activities for each bin as 
                           
                              
                                 
                                    x
                                 
                                 
                                    ′
                                 
                              
                              (
                              
                                 
                                    u
                                 
                                 
                                    j
                                 
                              
                              )
                              =
                              
                                 
                                    Y
                                 
                                 
                                    h
                                 
                              
                              (
                              
                                 
                                    S
                                 
                                 
                                    h
                                 
                              
                              )
                              +
                              
                                 
                                    Y
                                 
                                 
                                    l
                                 
                              
                              (
                              
                                 
                                    S
                                 
                                 
                                    l
                                 
                              
                              )
                           
                         and continue with the determination of the next 
                           
                              
                                 
                                    S
                                 
                                 
                                    h
                                 
                              
                           
                        .

@&#PERFORMANCE EVALUATION@&#

In this section, we evaluate the applicability of our modeling approach in the context of different distributions and how well their employment reflects the original data characteristics we observed.

We perform 10,000 simulations for each user, consisting of the number of two hour bins of the original dataset to replicate the original data in comparison. We present the results from the different distributions we evaluate in Table 3
                        .

We initially observe that some parameters could not be estimated for reasonable outcomes, which are denoted as blank entries in the table. We observe that the Folded Normal distribution, which was able to capture the average data amounts in [15] fairly well, now results in significantly higher simulated data amounts while the variability remains similar. We conclude that the different identification approach of high utilization applications has rendered this prior distribution no longer suitable. For the Gamma distribution, we observe an overall better trend, but still a significant amount of outliers resulting in the simulated data and variability being too high on average. The Exponential distribution exhibits a fairly narrow range (within 5–10% of the original data) across most users for both data and variability. We additionally evaluated the Inverse Gaussian distribution as well, which for some users slightly outperforms the Exponential distribution in terms of average amounts of data; however, significant outliers in both average amount and variability of data make this distribution not well suited, despite the ability to derive the parameters for all users. We conclude that the memoryless Exponential distribution captures the average and standard deviation of the dataset we model best. In particular, we note that the exponential distribution fits overall very well, whereas other distributions only fit partial groups of users well with significant numbers of outliers (i.e., either significantly over- or under-estimating). Lastly, we note that the 95% Confidence Interval (CI) for the simulated average utilizing the Exponential distribution for the individual users are fairly narrow; we determined an average of 2.5% of the mean on average (ranging from 0.7% to 5.8%).

We now evaluate the detailed estimation of high utilization application aggregate and background application aggregates in Table 4
                        . We note that the average of the high utilization application values is very close to the originally submitted data for the users for which matching distribution parameters were found (i.e., within 5%). Only a handful of users exhibit larger differences, with user 16 being the only significant outlier below 50%. We observe a similar trend for the standard deviation. Overall, the high utilization value simulation results in averages of about 96% for the simulated values. In addition, we observe that for the background application, the majority of successful user simulations except one is within 5% of the original value; this is almost identically observed for the background data value’s standard deviation, which results in an almost 100% average value match between simulation and real data.

We evaluate the suitability of our model additionally by employing unbuffered statistical multiplexing smoothed over the aggregated traffic in the 2h time intervals of each bin. More details about this approach can be found in, e.g., [16,17]. We illustrate the model in Fig. 9
                        , where the individual data streams generated are added over time, with the potential for losses.

Each user submitted data is aggregated as 
                           
                              X
                              (
                              
                                 
                                    u
                                 
                                 
                                    j
                                 
                              
                              ,
                              t
                              )
                           
                         over time, following our notation used throughout. we subsequently determine a number of times that the user’s data should be randomly replicated over the network, denoted as R. For each replications r, we draw a random starting phase 
                           
                              
                                 
                                    θ
                                 
                                 
                                    r
                                 
                              
                              (
                              
                                 
                                    u
                                 
                                 
                                    j
                                 
                              
                              )
                           
                        . We then estimate the loss probability of the aggregated stream, performing wrap-around if the end of the individual stream is reached. Thus, at time t, the number of bytes in the aggregated stream is derived as 
                           
                              
                                 
                                    ∑
                                 
                                 
                                    r
                                 
                              
                              X
                              (
                              
                                 
                                    u
                                 
                                 
                                    j
                                 
                              
                              ,
                              (
                              
                                 
                                    θ
                                 
                                 
                                    r
                                 
                              
                              +
                              t
                              )
                              
                              mod
                              
                              T
                              (
                              
                                 
                                    u
                                 
                                 
                                    j
                                 
                              
                              )
                              )
                           
                        . We utilize this approach to determine 
                           
                              
                                 
                                    C
                                 
                                 
                                    min
                                 
                              
                           
                        , the bandwidth required to support R replications of user 
                           
                              
                                 
                                    u
                                 
                                 
                                    j
                                 
                              
                           
                         with a maximum upper loss probability of 
                           
                              ∊
                              =
                              
                                 
                                    10
                                 
                                 
                                    -
                                    5
                                 
                              
                           
                         when smoothing over the bin duration. We compare these results from the submitted volunteer data samples with those generated through our high utilization application approach, whereby we create 100,000 bins of aggregated synthetic user data and subsequently perform the same bufferless multiplexing approach to determine the bandwidth required to support a low data loss rate.

We present the relative results in Table 5
                        , whereby we compare the simulated values for the sample mean for bandwidth 
                           
                              
                                 
                                    C
                                 
                                 
                                    min
                                 
                                 
                                    ′
                                 
                              
                           
                        , as well as 90% and 95% Confidence Intervals (
                           
                              
                                 
                                    CI
                                 
                                 
                                    90
                                 
                                 
                                    ′
                                 
                              
                           
                         and 
                           
                              
                                 
                                    CI
                                 
                                 
                                    95
                                 
                                 
                                    ′
                                 
                              
                           
                        ) with their respective counterparts obtained from the original user data.

We observe that overall, the simulation results in comparable levels of estimated bandwidth requirements; the estimates are typically within 5%, with only few outliers estimating smaller or higher required 
                           
                              
                                 
                                    C
                                 
                                 
                                    min
                                 
                              
                           
                         values. A comparison of the confidence intervals shows that the ones obtained through simulation are typically an order of magnitude smaller, due to the large number of simulated bins. Overall, we conclude that model produces coarse-grained traffic estimates for individual users that are suitable for capacity estimations.

@&#CONCLUSION@&#

We described how modeling of the network traffic characteristics of mobile users can be achieved in a tractable and efficient manner by capturing the characteristics of high utilization applications as the main contributors of the overall mobile device behavior for a group of users. Based on a publicly available dataset of volunteer submissions, we described two approaches that were employed to initially determine the high utilization applications on mobile devices. While both utilize multi-dimensional k-means clustering based on Z-scores to determine the sought applications, we found that two-dimensional clustering did not provide an overall sufficient result for detailed modeling. A three-dimensional approach successfully determined the 7% of applications that are responsible for 75% of the overall amount of data in our underlying dataset.

We defined a straightforward approach by which one can utilize these applications within a second step that determines the user-specific characteristics as an aggregate. When combined with the remaining background applications, we determined that the Exponential distribution was most suitable to model both individual amounts of data produced for the majority of users. Additionally performed simulations for bandwidth requirement estimations based on the model and original data corroborated the suitability of our model, whereby we observed typically less than 10% of difference. In turn, our approach is suitable to determine the long-range average user activity with only little input parameters (high utilization application characteristics from group observations, aggregated background application characteristics, and their distribution) and provides a reasonable trade-off between complexity and ease of use.

Future research directions are geared towards finer-grained time scales based on new datasets, such as the ones we currently generate using our NTraX Android application.
                        3
                        A demonstration was presented at the 2013 IEEE Online Conference on Green Communications (OnlineGreenComm).
                     
                     
                        3
                      Furthermore, evaluations of groups of user characteristics in conjunction with the presented model on fine-grained data could yield interesting insights as well.

@&#REFERENCES@&#

