@&#MAIN-TITLE@&#Randomized fault-tolerant virtual backbone tree to improve the lifetime of wireless sensor networks

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Need of energy efficient backbone routing for WSNs.


                        
                        
                           
                           FTVBT (virtual backbone tree construction algorithm) proposed to minimize energy consumption.


                        
                        
                           
                           Identifies hotspots, distributes dependents across tree nodes and the distribution is also bounded.


                        
                        
                           
                           Randomized FTVBT elects tree nodes based on a weight function and increases network lifetime.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Backbone construction

Energy consumption

Network lifetime

Routing

Virtual backbone

Wireless sensor network

@&#ABSTRACT@&#


               
               
                  Backbone nodes are effective for routing in wireless networks because they reduce the energy consumption in sensor nodes. Packet delivery only occurs through the backbone nodes, which depletes the energy in the backbone drastically. Several backbone construction algorithms, including energy-aware virtual backbone tree, virtual backbone tree algorithm for minimal energy consumption and multihop cluster-based stable backbone tree, fail to form a complete backbone when converting important nodes, such as a cut vertex tree node to a non-backbone node. Thus we propose a fault-tolerant virtual backbone tree (FTVBT) algorithm that addresses all of these conflicts and we give theoretical derivations of the bounds for the probability that a sensor node can connect with the backbone. Furthermore, randomized FTVBT improves FTVBT by redistributing non-tree nodes randomly among all the eligible tree nodes based on their fitness values, thereby decreasing the rapid depletion of energy in a particular node and increasing the network lifetime. We performed simulations in NS2 and analyzed the experimental results.
               
            

@&#INTRODUCTION@&#

At present, wireless sensor networks (WSN) are major research topics in the areas of computer science and telecommunications. Wireless sensors are deployed in a region that needs to be monitored. Large numbers of sensors are deployed randomly, which are low power, low cost, memory/computationally-constrained devices that form a network. These devices transmit the sensing data back to a sink. Some emerging applications of WSNs include environmental monitoring, industrial control, healthcare, military uses, area surveillance and natural habitat monitoring. The sensor nodes consume energy during events such as sensing, computation and communication. From a traditional perspective, the energy consumption by WSNs is dominated by communication rather than by sensing and computation. In most cases, the computational energy cost is insignificant compared with the communication cost [1,2]. The sensing cost can also be assumed to be negligible in some networks.

Numerous solutions have been proposed for network life management based on deployment optimization (coverage, connectivity), topology control, energy efficient routing, clustering, data aggregation, mobile sinks/relay nodes and backbone approaches [3–7]. In this study, we propose a multihop routing protocol that performs better than single hop routing. In single hop routing, the energy consumption can be reduced in only a few nodes. Thus, single hop transmission is not suitable in situations where the sink node is not reachable. In these situations, multihop routing protocols are preferred but they require adequate resources to transmit data to the sink, which increases the communication overheads and costs. Addressing these issues by routing through a backbone can reduce the communication overheads and the overall energy consumption of WSNs.

In this study, we attempt to increase the lifetime of sensor networks by constructing a virtual backbone tree. Several virtual backbone algorithms have been proposed previously such as energy-aware virtual backbone tree (EVBT), multihop cluster-based stable backbone tree and a virtual backbone tree algorithm for minimal energy consumption (ViTAMin). Constructing the backbone involves selecting tree nodes and each sensor node (non-tree node) is associated with at least one tree node. The tree nodes are selected based on their energy, upstream distance from the parent tree node and the angle between the node and its parent. Mobile sink nodes are considered in the present study. We propose a novel backbone construction and reconstruction algorithm and we explain how the N-of-N lifetime is maintained. Even if only one sensor node exists in a region, the backbone will be maintained by virtual backbones and the mobile sink.

Section 2 provides a brief overview of related research and the challenges involved in the formation of a backbone. An overview of the proposed fault-tolerant virtual backbone tree (FTVBT) is provided in Section 3, which also includes the algorithms for backbone construction, reconstruction, the randomized fault-tolerant backbone formation approach, and a discussion of the network lifetime. The simulation results and an evaluation of FTVBT are presented in Section 4. Finally, Section 5 gives our conclusion and some directions for future research.

@&#RELATED WORK@&#

The network lifetime is an important issue when evaluating sensor networks [8,9]. In previous studies, the network lifetime has been defined in various ways, such as the mean expiration time, the time when a specific fraction of nodes remains alive in the network and the time when the first loss of reporting occurs. Thus, the definition of the network lifetime is context-dependent and it can be specified in different ways for various scenarios [10]. In our scenario, we define the network lifetime as the time when backbone trees cannot be formed that cover the entire network such that every node can communicate with the sink node.

Many energy-efficient routing algorithms have been proposed to improve the lifetime of WSNs. Recently, two attractive categories of routing methods have been investigated: cluster and virtual backbone-based routing methods. Cluster-based protocols [11–13] use a hop limit-based model where the sink is within the hop limit of a cluster member that transfers the data directly to the sink node. The current solution used for clustering requires maintenance to reorganize the clusters due to mobility and node failures. To better organize the sensor nodes, different algorithms [14,15] have been used to set up a virtual backbone among the active nodes. A set of active nodes forms a backbone to perform certain tasks and they provide services to the nodes that are not involved in the backbone. Backbones reduce the operational costs involved in the communication between the sink and other sensor nodes, thereby decreasing the overall energy consumption of each packet and increasing the WSN lifetime.

Virtual backbones provide an infrastructure for efficient communication with the sink node. Nodes are selected as tree nodes (black) and non-tree nodes (blue). All of the communication between a particular sensor node and the sink node occurs via the tree nodes. Various strategies can be used to select the tree nodes. In EVBT [16], the sink node transmits a broadcast request (BCR) packet to all of the nodes in its sensing range. The nodes that receive this packet compute its fitness factor and time delay (t
                     
                        d
                     ). The nodes then wait until t
                     
                        d
                      has expired. If a node receives another BCR request during this interval, the node becomes a non-tree node and it selects the nearest tree node as its parent; otherwise, the node becomes a backbone tree node and a branch of the virtual backbone. Selecting the nearest tree node as part of the backbone for the upstream link does not involve many computations, but it is not the shortest route to the sink. The main aim is to reduce the energy usage and to enhance the persistence of the network. ViTAMin [17] finds the shortest path to the sink for each tree node by adding a distance parameter to track the existing BCR packet, which is referred to as an extended BCR (EBCR) packet. The modified EVBT (m-EVBT) [18] reduces the total energy consumption by utilizing the distance between nodes and energy consumption information to identify upstream connections. Like ViTAMin, the energy consumption information is passed via an EVBT construction request (ECR) packet. EVBT can be built without using a time delay [19]. Only nodes with energy greater than the threshold are considered for selection as tree nodes. A node with a degree of one is always a non-tree node. Distributed Breadth First Search are run and if a vertex is not reached, it is joined to the virtual backbone. The virtual backbone is constructed and maintained with the minimal number of tree nodes. The network lifetime can be increased by controlling the mobility in the sink using a centralized and dynamic scheme [20–22].

In EVBT, ViTAMin and m-EVBT, the time delay is computed based on the node’s fitness factor when an ECR or EBCR packet is received. If an EBCR or ECR packet is received before t
                        
                           d
                         expires, the node becomes a sensor node. Fig. 1
                         shows how this mechanism can lead to failure during the formation of a backbone. Node N3 has the ability to become a backbone node but it becomes a non-backbone node because it also receives an ECR packet from N2 before t
                        
                           d
                         expires. Thus, because N3 becomes a non-tree node, the virtual backbone cannot be constructed further.

The time delay is calculated using the formula: ((M-k)+random ())*s. The fitness factor is divided into M groups, such as 0=
                        f
                        
                           i
                        (0)<
                        f
                        
                           i
                        (1)<
                        f
                        
                           i
                        (2)⋯<
                        f
                        
                           i
                        (M)=1, where f
                        
                           i
                         belongs to [f
                        
                           i
                        (k), f
                        
                           i
                        (k
                        +1)]. For example, we may have M
                        =5 and f
                        
                           i
                        (1)=0.2, f
                        
                           i
                        (2)=0.4, f
                        
                           i
                        (3)=0.6, and f
                        
                           i
                        (4)=0.8. When a node (A) receives an ECR packet, it calculates the fitness factor (e.g., f
                        
                           i
                        
                        =0.59). Time delay=(3+random ())*s. Next, another node (B) calculates its fitness factor (e.g. f
                        
                           i
                        
                        =0.61). Time delay=(2+random())*s, where random() gives a value between 0 and 1. These two node fitness factors do not differ greatly, but t
                        
                           d
                         is decreased considerably for the second node. It can become even worse if the random() gives a higher value for node (A) compared with node (B). This difference plays a major role in determining whether nodes receive another ECR packet before t
                        
                           d
                         expires.

In this study, we propose FTVBT which reduces the energy consumption for a packet, increases the network lifetime, does not drain any particular node quickly and it also maintains the N-of-N lifetime. Fig. 2
                      shows a model of the proposed system. The system comprises a sink node and sensor nodes, which are classified as tree and non-tree nodes.

A tree node has comparatively high energy and it performs data sensing, sending and receiving. All of the data from the non-tree node to the sink need to be transferred with the minimum energy expenditure and distance to prolong the network’s lifetime. Initially, the sink node broadcasts request packets. After the nodes receive request packets, they calculate their energy, the distance between the node and the node that sent the request packet and they identify the upstream link. The nodes that satisfy the threshold criteria become tree nodes and the others are obviously non-tree nodes. The non-tree nodes have to select appropriate tree nodes. They should also sense data and send data packets to their tree nodes.

Each node present in the sensor network has a variable energy level. Initially, all of the nodes with an energy level greater than the threshold (Th) are temporarily designated as tree nodes. From the sink, a tree is constructed that connects all of these nodes. If a tree node approaches its threshold value or it has too many dependents, it will become a hotspot and lose energy quickly because too many packets are transferred through it.
                           Algorithm 1
                           Initialization of virtual backbone tree construction 
                                 
                                    
                                 
                              
                           

The dependent child tree nodes and associated non-tree nodes are directed to find a new parent tree node. A node only remains the parent of nodes that do not find a new parent. A tree node with energy that approaches the threshold should reduce its number of dependents appreciably or try to become a non-tree node. Thus, the network may experience a few issues because a child tree node of this tree node must find another parent and the associated non-tree nodes need to find a suitable parent node. Algorithm 1 illustrates how the reachable tree nodes are found for each tree node. The notations used in the virtual backbone tree algorithm are described in Table 1
                        .

When a tree node wants to redistribute its dependents, it directs its child nodes to find a new parent. The actions initiated by the child tree node are described in Algorithm 2. A child tree node scans and finds the list of reachable tree nodes that lie within its sensing range. If there is only one node in its range, then it is selected as its parent. If more than one tree node is present in its sensing range, then the node with the highest fitness factor is selected as its parent. If a new parent cannot be found, then it remains a child of its old parent node to maintain the network.
                              Algorithm 2
                              Selecting a new parent of a child tree node 
                                    
                                       
                                    
                                 
                              

New parent node selection for non-tree nodes 
                                    
                                       
                                    
                                 
                              

Backbone Reconstruction 
                                    
                                       
                                    
                                 
                              

For each non-tree child node, the reachable tree nodes are found that lie within its sensing range. Among the reachable tree nodes, the parent node with the shortest upstream distance is selected. Node N
                           
                              i
                            becomes a non-tree node when it has no remaining dependents. Thus, the parents of child tree nodes are selected based on the maximum fitness value and the parents of child non-tree nodes are selected based on the minimum upstream distance as described by Algorithm 3.

A node may fail due to hardware error or it could be completely drained of energy. The reconstruction mechanism is described by Algorithm 4. The tree nodes check periodically whether the energy falls below Th. If this is the case, the node becomes a non-tree node. If T is a tree node that fails, then all of its child tree nodes are assigned to a new parent. A child tree node finds all the tree nodes within its sensing range. It selects the tree node with the highest fitness factor as its parent. If there is no other tree node within its sensing range, it checks all of the non-tree nodes that are within its sensing range, before selecting the node with the highest fitness factor and the minimum upstream stream distance, which it converts from a non-tree node to a tree node. A precondition is that the energy of the selected non-tree node must be greater than the threshold. If a non-tree node fails, then there is no breakage in the tree structure and it is considered to be dead.
                           Algorithm 4
                           Backbone Reconstruction (continued) 
                                 
                                    
                                 
                              
                           

FTVBT selects tree nodes deterministically based on a fitness factor. Instead of always selecting the tree with the highest fitness factor, it is possible to select all of the tree nodes as parents based on their fitness factor. A random parent can be selected for every packet sent to the sink [23]. In the present study, a random parent tree node is selected based on a weight function. Initially, the sum of the fitness factors for all the tree nodes reachable from the sink is computed using Eq. (1).
                           
                              (1)
                              
                                 sum
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          t
                                       
                                    
                                 
                                 
                                 fitnessfactor
                                 (
                                 i
                                 ,
                                 t
                                 )
                              
                           
                        Initially, the potential tree nodes are ordered. A random value is generated between [0,sum]. If it lies in [0,fitnessfactor(i,0)], then tree node t
                        0 is selected as the parent. If the generated number lies between [fitnessfactor(i,0),fitnessfactor(i,0)+fitnessfactor(i,1)], then tree node t
                        1 is selected as the parent. The probability of node t being selected as a parent of a tree node is given by Eq. (2)
                        
                           
                              (2)
                              
                                 P
                                 (
                                 t
                                 =
                                 =
                                 parent
                                 )
                                 =
                                 
                                    
                                       fitnessfactor
                                       (
                                       i
                                       ,
                                       t
                                       )
                                    
                                    
                                       sum
                                    
                                 
                              
                           
                        This scheme reduces the redistribution. Similarly, when an associated non-tree node selects its parent, this can be achieved based on distance using Eq. (3). For a particular non-tree node j:
                           
                              (3)
                              
                                 sum
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          t
                                       
                                    
                                 
                                 
                                    
                                       1
                                    
                                    
                                       upstream
                                       +
                                       distance
                                       (
                                       j
                                       ,
                                       t
                                       )
                                    
                                 
                              
                           
                        The probability of a node t being selected as a parent of a non-tree node is calculated by equation: (4)
                        
                           
                              (4)
                              
                                 P
                                 (
                                 t
                                 =
                                 =
                                 parent
                                 )
                                 =
                                 
                                    
                                       1
                                    
                                    
                                       upstream
                                       +
                                       distance
                                       (
                                       j
                                       ,
                                       t
                                       )
                                       ×
                                       sum
                                    
                                 
                              
                           
                        
                     

When they are deployed initially, most of the nodes have more energy than the threshold. Let path(n) be the path from the sink to a node n. For all nodes ‘n’ the path is identified through the tree nodes. When the nodes are far apart, it might not be possible to cover it using a single virtual backbone. Thus, after initially constructing the virtual backbone, some of the nodes that are very far apart will have a path(n) of infinity. Thus, a node ’n’ is made from the root and a virtual backbone is built again. Thus, several discrete virtual backbones can be formed and all the nodes are part of the FTVBT initially. When a tree node has too many children, its energy level will be affected, which will affect the network’s lifetime. Thus, when the number of dependents is greater than the average number of reachable local tree nodes, the number of dependents is reduced. If this value is too low, many nodes will belong to this category, whereas if it is too high, very few will belong to this category. Ideally, this value should be twice the average number of dependents in nearby tree nodes.

During reconstruction, some of the non-tree nodes are converted into tree nodes when it is necessary to cover all the nodes. If the setup cost (N) of a node N is too high, then the sink makes another root and the backbone through it is updated so it periodically visits the node N. After the failure of nodes, new discrete structures are formed where more new roots are selected and the sink (the mobilizer) visits them periodically. If there are many breakages in the link coverage, an ‘n’ non-overlapping group is formed. Thus, there will be at least ‘n’ root nodes for the sink to collect data, with at least one in each group. According to the N-of-N lifetime concept, if there are few nodes left in the deployed area, backbones must be formed that comprise part of the network. Until the number of alive nodes becomes zero, the sink collects data and maintains the N-N lifetime.

We performed simulations using the NS2 simulator. The release of IEEE 802.15.4 with NS2 represents a milestone in wireless personal area networks and WSNs. It targets a low data rate, low power consumption and low cost wireless networking, as well as offering device level wireless connectivity. We simulated our proposed FTVBT algorithm in NS2 with Mac/802.15.4. The nodes were deployed with random x, y co-ordinates. If a single backbone could not be formed or a single backbone became broken, the sink node stored the positions of the different root nodes that it had to monitor. In the simulations, we deployed 100 and 200 nodes separately in a rectangular region of 200
                     
                        
                           ×
                        
                     
                     150 square units. If a tree node has too many dependents, it will have a serious impact because the energy of the tree node will drain rapidly so it becomes a non-tree node. To avoid this problem, the variance in the number of dependents of tree nodes must be kept to a minimum. In FTVBT, there is an implicit check on the number of dependents for every tree node. The number of tree nodes used to build a virtual backbone tree in EVBT [19] and FTVBT with various transmission ranges are shown in Table 2
                     . The lower and upper bounds for the average number of tree nodes are also given with the 90%, 95% and 99% confidence intervals. In this case, FTVBT has more tree nodes compared with EVBT, which helps to reduce the number of dependents. The average number of dependents for a tree node with EVBT [19] and FTVBT are shown in Table 3
                     . Each node calculates the distance and angle from all the other reachable nodes.

All of the FTVBT modules were run in every node and each node changed its state from a tree node to a non-tree node according to the proposed algorithms. The energy dissipation by each node was captured in NS2 by modifying the cc file and the energy was obtained while executing the tcl file. The graphical representation was generated by network animator and the sequence of simulated events was represented in the trace file. When the energy of a node dropped below the threshold, it could only remain forever as a non-tree node. We also simulated the energy consumption when delivering the data for 100 and 200 nodes using EVBT CDS(Connected Dominationg Set), EVBT, ViTAMin and FTVBT, as described above, and the results are shown in Table 4
                     , Figs. 3 and 4
                     
                     . The optimum transmission range was around 39m for the first order energy model, so the energy consumption by the sensor nodes increased after 40m. However, increasing the transmission range will consume more battery power.


                     Table 5
                      was computed using the following configuration: number of nodes=100, transmission range=30m, energy =random distribution, and rectangular deployment over 200m
                     
                        
                           ×
                        
                     
                     150m with a sink node placed at the center. In this simulation, the number of tree nodes was fixed for all the routing protocols to allow them to be compared with each other. In this case, the CDS-based virtual backbone obtained the shortest mean routing path length, which was measured in terms of the number of hops. However, the number of dependents had a very high variance, which leads to the failure of tree nodes and affects the network lifetime. The load-balanced virtual backbone obtained the minimum variance in the dependents across all the tree nodes but the average routing path length was too high. Minimizing the average routing path length and reducing the variance in the number of dependents are orthogonal challenges. Our proposed algorithm achieves a balance by using a shorter routing path length than the load-balanced virtual backbone and it also minimizes the variance to some extent. The parents are selected randomly when a message is sent based on the fitness factor and previous loads, which results in a better distribution of dependents. The table shows that the on-demand randomized selection of parent nodes based on their energy, load and distance will help to increase the network’s lifetime.

Randomized FTVBT overcomes the disadvantages of FTVBT by giving an equal likelihood to all of the tree nodes based on a weight function by randomization, which minimizes redistribution while maintaining the same level of energy consumption. This avoids the problem of frequent redistribution between the tree nodes with high fitness factors and energy, without actually transferring any packets. Each node sends a packet of 22bytes to the sink node along the tree through its parent tree node. The total energy consumption is defined according to the first order energy model [26], i.e., the sum of E
                     
                        tx
                     (D) and E
                     
                        rx
                     . E
                     
                        tx
                     (D) and E
                     
                        rx
                      are the energy consumed when transmitting and receiving a bit over a distance D, respectively. Direct transmission where a node sends a packet directly to a sink node in one hop consumes the most energy. We found that FTVBT outperforms variants of EVBT and ViTAMin. The number of packets used for reconstruction comprises: (i) nodes sending packets to find new reachable tree nodes; (ii) new parent tree nodes sending acknowledgments; or (iii) an unreachable tree node connecting to the sink within its range and the nodes near a previous parent node asking the sink to monitor the region to predict where a disjoint set might occur. The recovery time in terms of the number of packets is O(RTN).

@&#CONCLUSION@&#

Our energy-efficient FTVBT method identifies hotspots and distributes the dependents across tree nodes, thereby increasing the durability of the virtual backbone. FTVBT selects an energy-efficient path for routing via the backbone after considering the remaining energy of the tree nodes and the upstream distance, which increases the overall network lifetime of WSNs. The redistribution of dependents is also bounded to control the cost of the computations involved in load distribution. Randomized FTVBT selects tree nodes on demand, thereby allowing each node with sufficient energy to become part of the virtual backbone based on their fitness factor. In the worst case, even the sensor nodes with energy greater than the threshold can be converted into tree nodes to improve the duration of the network for a longer period of time. The probability of a node not finding a parent is negligible. Multiple virtual backbones are constructed when a single virtual backbone becomes infeasible. The N-of-N lifetime is achieved based on discrete structures, which are virtually connected to the sink.


                        Algorithm 1 invokes redistribution when the number of dependents of a tree node is greater than twice the average number of dependents in its reachable tree nodes. This ensures that any particular tree node is not overloaded. We consider the probability of the number of tree nodes that satisfy this condition and that have contacts with child nodes changing their parent node. Let X be a random variable that denotes the number of dependents in the reachable tree nodes. By Markov inequality, if X is any non-negative random variable and 
                           
                              a
                              >
                              0
                           
                        , then
                           
                              (A.1)
                              
                                 P
                                 (
                                 X
                                 ⩾
                                 a
                                 )
                                 ⩽
                                 
                                    
                                       E
                                       (
                                       X
                                       )
                                    
                                    
                                       a
                                    
                                 
                              
                           
                        where X is non-negative because the number of dependents cannot be negative. Let a 
                           
                              =
                              2
                              ×
                              E
                              (
                              X
                              )
                           
                         and by applying the Markov inequality, the probability of tree node T having greater than or equal to twice the average number of dependents is:
                           
                              (A.2)
                              
                                 P
                                 
                                    
                                       
                                          X
                                          ⩾
                                          2
                                          ×
                                          E
                                          
                                             
                                                
                                                   X
                                                
                                             
                                          
                                       
                                    
                                 
                                 ⩽
                                 
                                    
                                       E
                                       
                                          
                                             
                                                X
                                             
                                          
                                       
                                    
                                    
                                       2
                                       ×
                                       E
                                       
                                          
                                             
                                                X
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (A.3)
                              
                                 P
                                 
                                    
                                       
                                          X
                                          ⩾
                                          2
                                          ×
                                          E
                                          
                                             
                                                
                                                   X
                                                
                                             
                                          
                                       
                                    
                                 
                                 ⩽
                                 
                                    
                                       1
                                    
                                    
                                       2
                                    
                                 
                              
                           
                        However, this gives a weak upper bound and thus the chance of re-distribution is high, which may lead to something similar to thrashing if the value is excessively high. Our scheme is verified by Chebyshev’s bound. By the Chebyshev inequality, if X is a non-negative random variable, and E(x) and Var(X) are the mean and variance, respectively, then
                           
                              (A.4)
                              
                                 P
                                 
                                    
                                       
                                          
                                             
                                                
                                                   X
                                                   -
                                                   E
                                                   (
                                                   X
                                                   )
                                                
                                             
                                          
                                          >
                                          a
                                       
                                    
                                 
                                 ⩽
                                 
                                    
                                       Var
                                       (
                                       X
                                       )
                                    
                                    
                                       
                                          
                                             a
                                          
                                          
                                             2
                                          
                                       
                                    
                                 
                              
                           
                        If we let a
                        =
                        E(X), then the probability of tree node T having greater than or equal to twice the average of number of dependents is:
                           
                              (A.5)
                              
                                 P
                                 
                                    
                                       
                                          
                                             
                                                
                                                   X
                                                   -
                                                   E
                                                   (
                                                   X
                                                   )
                                                
                                             
                                          
                                          >
                                          E
                                          (
                                          X
                                          )
                                       
                                    
                                 
                                 ⩽
                                 
                                    
                                       Var
                                       (
                                       X
                                       )
                                    
                                    
                                       
                                          
                                             
                                                
                                                   E
                                                   (
                                                   X
                                                   )
                                                
                                             
                                          
                                          
                                             2
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (A.6)
                              
                                 P
                                 
                                    
                                       
                                          
                                             
                                                
                                                   X
                                                   -
                                                   E
                                                   (
                                                   X
                                                   )
                                                
                                             
                                          
                                          >
                                          E
                                          (
                                          X
                                          )
                                       
                                    
                                 
                                 ⩽
                                 
                                    
                                       E
                                       (
                                       
                                          
                                             X
                                          
                                          
                                             2
                                          
                                       
                                    
                                    
                                       E
                                       (
                                       X
                                       )
                                    
                                 
                                 -
                                 1
                              
                           
                        
                     

Chebyshev’s inequality gives a better upper bound for the proposed scheme compared with the Markov inequality (see Table A.6
                        ).

If a child node (C
                        
                           n
                        ) does not find a parent tree node, it will become disconnected from the virtual backbone. Let k be the number of tree nodes that cannot be reached. Let t
                        1,
                        t
                        2,…,
                        t
                        
                           k
                         be the tree nodes arranged in descending order of fitness between the node and t
                        
                           i
                        . Initially, the child node selects t
                        1 as its parent, which has the highest fitness factor. t
                        1 can reject the node’s request if it has twice the average number of dependents or its energy is less than T
                        +
                        ∊. Now, C
                        
                           n
                         contacts the remaining tree node with the highest fitness factor. Thus, the probability of a child node being disconnected is 
                           
                              
                                 
                                    ∏
                                 
                                 
                                    k
                                 
                                 
                                    i
                                    -
                                    1
                                 
                              
                           
                         Pr(node ti rejects the request). If all the reachable tree nodes become non-tree nodes, node C
                        
                           n
                         will be disconnected. Now, the probability of being disconnected from the network is equal to: 
                           
                              
                                 
                                    ∏
                                 
                                 
                                    k
                                 
                                 
                                    i
                                    =
                                    1
                                 
                              
                              Pr
                              (
                              node
                              
                              
                                 
                                    t
                                 
                                 
                                    i
                                 
                              
                              
                              rejects request
                              )
                              ×
                              
                                 
                                    ∏
                                 
                                 
                                    k
                                 
                                 
                                    i
                                    =
                                    1
                                 
                              
                              
                                 
                                    ∏
                                 
                                 
                                    number
                                    
                                    of
                                    
                                    dependents
                                 
                                 
                                    j
                                    =
                                    1
                                 
                              
                              Pr
                              (
                              node
                              
                              j
                              
                              cannot find a new parent
                              )
                           
                        , which is very small. Therefore, the probability of a child node finding a parent tends to 1.

@&#REFERENCES@&#

