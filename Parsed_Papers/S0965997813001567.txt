@&#MAIN-TITLE@&#Automated finite element model updating of full-scale structures with PARameter Identification System (PARIS)

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Automated FE model updating for structural health monitoring.


                        
                        
                           
                           Development of FE model updating framework called PARIS.


                        
                        
                           
                           Customizable research software utilizing API of existing commercial software.


                        
                        
                           
                           Solution of parameter estimation problems distributed between different software platforms.


                        
                        
                           
                           Demonstration of FE model updating for full-scale structures with damage scenarios.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Finite element model updating

Parameter estimation

Inverse problems

Full-scale structures

Application Programming Interface (API)

PARameter Identification System (PARIS)

@&#ABSTRACT@&#


               
               
                  This paper presents a software framework, PARIS (PARameter Identification System), developed for automated finite element model updating for structural health monitoring. With advances in Application Programming Interfaces (API) for modern computing, the traditional boundaries between different standalone software packages hardly exist. Now complex problems can be distributed between different software platforms with advanced and specialized capabilities. PARIS takes advantage of the advancements in the computing environment and interfacing capabilities provided by commercial software to systematically distribute the structural parameter estimation problem into an iterative optimization and finite element analysis problem across different computing platforms. Three validation examples using simulated nondestructive test data for updating full-scale structural models under typically encountered damage scenarios are included. The results of model updating process for realistic structural models and their systematic treatment provide enhanced understanding of the aforementioned parameter estimation process and an encouraging path towards its feasible field application for structural health monitoring and structural condition assessment.
               
            

@&#INTRODUCTION@&#

The American Society of Civil Engineers’ 2013 Infrastructure Report Card [1] rated America’s infrastructure at D+ and its existing bridges at C+ with an estimated total investment of 3.6trillion dollars needed for infrastructure maintenance by 2020. The design life of these structures is determined based on the applicable design codes. Through their service life, these structures may experience impacts of climate variation, seismic events, corrosive environment, and other unexpected transient and long term loading, leading to structural deterioration. Structural health monitoring (SHM) is increasingly gaining emphasis in response to the continually deteriorating state of our transport infrastructure. SHM has the potential to be used in conjunction with the current methods of inspection to add a layer of confidence in objective decision making with regards to structural management and maintenance. Unlike limited visual inspections, it can provide a continuous stream of measured data to help benchmark structural condition and evaluate long term trends and performance.

There is considerable volume of published research in the field of SHM based on a wide array of approaches to achieve the same end goal. Researchers at the Los Alamos National Laboratory have published state-of-the-art reports of on damage identification [2], damage prognosis [3], and health monitoring [4] of structures. ASCE recently published a book with comprehensive set of case studies of structural health monitoring (Editor: Catbas et al. [5]), This book reviewed contemporary Structural-Identification (St-Id) methods under research and organized them into distinct steps like modeling, data processing, and parameter identification.

Techniques used for damage assessment are broadly classified as global and local. A review of global SHM and local non-destructive evaluation methods and their shortcomings is provided by Chang et al. [6] and Chang and Liu [7] respectively. Local SHM methods like acoustics and electromechanical impedance based SHM methods, often sophisticated and precise, require pre-identification of damage and are most effective in localized regions of damage. Global methods, however, use global characteristics of a structure’s response to determine either the extent or location of damage or both in a structure. Mengelkamp and Fritzen [8] combined the local ultrasonic wave propagation method with the global stochastic subspace fault detection method (SSFDM) to investigate and detect artificially introduced cracks and delaminations in a stiffened aluminum plate and a GFRP plate.

SHM techniques are further categorized as model based and non-model based. There are various methods for the non-model based approach. As an example, Farrar and Worden [9] discussed recent research that identifies SHM problem primarily as a Statistical Pattern Recognition problem. Deraemaeker et al. [10] used output-only vibration measurements under variable environmental conditions for damage detection using a numerical example of a bridge. The feasibility of using self organization and learning capabilities of neural networks for structural damage assessment has also been explored by researchers like Wu et al. [11].

A set of model based methods for SHM relies on observing changes in the structure’s stiffness, mass, and damping parameters to correlate predicted and measured response. Parameter estimation is the process of updating the parameters of an a priori mathematical model to correlate its predicted response with the measured data at selected observation points for a given set of excitations. This is called the inverse problem and is unlike the forward analysis problem, which is to determine response of a structure to a known excitation as a function of known physical parameters of the model. An acceptable method for solving input–output inverse problems is by minimizing the residual between the predicted response from a mathematical model and the measured response of the actual system constituting the observed data set. The process thus involves starting with an a priori mathematical model based on certain assumptions of the initial values of the parameters. Key structural parameters of the model are first considered to be unknown and then iteratively updated for minimizing the residual and updating the unknown parameters until their best fit values are achieved. The updated parameter estimates are reflective of actual state of the structure and can thus be used to assess the level of damage in the structure.

Catbas and Aktan [12] discussed several promising indices and experimental constraints for condition and damage assessment. Focusing on bridges, they stated that a successful condition and damage assessment can be achieved with the appropriate set of experiments and judicial use of indices in structural identification framework. Kaouk and Zimmerman [13] adopted the Minimum Rank Perturbation Theory (MRTP) index for locating damage and determining its extent from measured eigenvalues and eigenvectors. Using vibrational test data, Doebling et al. [14] presented the problem of determining local stiffness parameters as a well-determined linear least square problem based on the decomposition of the flexibility matrix. Wang et al. [15] presented a structural damage identification algorithm for Damage Signature Matching (DMS) using change in static displacement response as a function of perturbation in stiffness matrix and changes in natural frequency. In order to consolidate research efforts in SHM further, the IASC-ASCE Task Group created a series of benchmark problems. The first phase of this study was based on using only simulated acceleration response data from the scaled physical model of a four story building frame. Caicedo et al. [16] used the Natural Excitation Technique (NExT) and Eigensystem Realization Algorithm (ERA) for identification of modal parameters for damage assessment on the IASC-ASCE benchmark problem.

The reliance of comprehensive infrastructural inspection and monitoring methods for objective condition evaluation on advanced technologies demands modern computational tools capable of analyzing larger structural systems more efficiently and accurately. Some examples of SHM and parameter estimation software are DIAMOND and FEMtools. DIAMOND [17] from Los Alamos National Laboratory is a software toolbox with several vibration based damage identification algorithms for vibration tests simulation, modal data analysis, finite element correlation, and comparison of both linear and nonlinear damage identification techniques. Its successor, DIAMOND II [18] is a collection of algorithms for treatment of SHM as a statistical pattern recognition problem. FEMtools [19], a commercial FE model updating software that interfaces with FEA packages like ABAQUS and NASTRAN is developed by Dynamic Design Solutions. The development of a software platform for full-scale finite element (FE) model based parameter estimation using non-destructive test (NDT) data is the subject matter of this paper, addressing important aspects of FE model calibration for structural health monitoring and structural conditions assessment.

PARameter Identification System (PARIS) is a MATLAB® based program that integrates seamlessly with the commercially available Finite Element Analysis (FEA) program, SAP2000®, to evaluate structural health at elemental level by observing a structure’s global response in a NDT. A unique feature of this program is utilization of interactive functionality of existing commercial software packages, SAP2000 and MATLAB. SAP2000 serves as the Finite Element Analysis (FEA) solver and with an integrated Graphical User Interface (GUI) for 3D model creation and validation. MATLAB is a fourth generation programming environment with exhaustive function optimization options. The APIs from SAP2000 developers enables MATLAB to use SAP2000 as a slave program for FEA. Additionally, visualization capabilities of the Graphical User Interface (GUI) of SAP2000 are used for FE model creation, verification, analysis, and post processing. This combination facilitated development of a platform for automated FE model updating of full-scale structures in the form of PARIS computer program. PARIS calibrates the FE model iteratively and automatically by minimizing the residual between the predicted response of the FE model and the measured response from NDT data. PARIS, as a research freeware, is posted at the SHM research website of Civil and Environmental Engineering Department at Tufts University at http://engineering.tufts.edu/cee/shm/software.asp.

This research is based on the parameter estimation formulations developed by researchers at Tufts University for PARIS (PARameter Identification System). This work is also divided into two distinct phases. Phase-I is the computer program development with capabilities for full-scale bridge FE model updating. The program itself uses Application Programming Interface (API) of SAP2000 for two-way automatic data exchange between MATLAB and SAP2000. Phase-II includes testing the program with simulated NDT data to validate its functionality. Model updating using simulated NDT data for FE models of full-scale structures falls under Phase-II.

PARIS (PARameter Identification System) is the acronym for the custom MATLAB based computer program for parameter estimation and FE model updating. Fig. 1
                      illustrates the FE model updating process in PARIS version 13.0. The flowchart connectors labeled as API describe two-way automatic data exchange between MATLAB and SAP2000. This distinctive feature allows SAP2000 to be used as a slave program to MATLAB based PARIS during iterative stages of FEA and updating model parameters in the parameter estimation process.

Parameter estimation process, as shown in Fig. 1, begins with an initial FE model creation in SAP2000 which is based on the preliminary guess of unknown structural parameters. In an a priori model, these parameters are rigidities and mass properties of elements. Typical stiffness parameters of a FE model are EA (axial rigidity), EI (bending rigidity) and GJ (torsional rigidity) for frame elements, E (modulus of elasticity) for shell and solid elements, and kX (translational stiffness) and kθ (rotational stiffness) for joint springs. For dynamic systems, mass parameter in a FE model is m (mass) of the finite elements. A change in any of the structural parameters used for defining the a priori model is defined as “structural damage”.

The discrepancy between the predicted response from the FE model and measured simulated NDT data is quantified as the residual. This residual is called error function. Various error functions are stacked for multi-response FE model updating. A scalar objective function is formed using the error functions and is optimized in MATLAB. Unknown parameter values are updated iteratively such that the updated model in one cycle becomes the initial model for the next. In each iteration of the optimization process for parameter estimation, the SAP2000 model is invoked by MATLAB for calculating the FE responses. The iterations continue until all pre-defined convergence criteria are met. Successful convergence indicates that the physical model closely assimilates the real structure’s behavior. The following paragraphs describe various mathematical concepts and formulations used in PARIS in the sequence in which they are encountered in the FE model updating process.

The model updating capabilities of PARIS include models comprised of frame, quadrilateral shell, and cuboid solid elements using static and/or modal data. Its usefulness lies in availability of advanced FE types for modeling. While solid elements may be better suited for modeling problems without geometrical oversimplification, shell elements, on other hand, provide greater convenience in modeling in addition to reduced analysis time. The model updating options have also been extended to update joint spring and 2-node link element stiffness in the FE model. Any combination of active DOFs for analysis can also be selected by the user.

Error functions are a measure of residual between the predicted response from the FE model and experimental data. They are formulated in terms of unknown parameters of the a priori FE model and they serve to estimate its unknown parameters. Generally, an error function is expressed as the difference between analytical and measured physical quantities as (1),
                           
                              (1)
                              
                                 e
                                 (
                                 p
                                 )
                                 =
                                 
                                    
                                       q
                                    
                                    
                                       predicted
                                    
                                 
                                 -
                                 
                                    
                                       q
                                    
                                    
                                       measured
                                    
                                 
                              
                           
                        where ‘q’ denotes a response quantity which can either be strain or translation and rotation under a set of known static loads or modal excitation. Static and modal error functions are further subdivided as stiffness and flexibility based error functions. In essence, the stiffness based error functions measure the residual between applied forces and the flexibility based error functions quantify residual between measured displacements. Static strain error function can also be categorized under flexibility based error function as strains are related directly to displacements.

Sanayei and Onipede [20] developed the static stiffness error function. They showed that the predicted displacement response from applied static test loads at one subset of degrees of freedom (DOF) and measured displacement response at another subset of DOF could be used to detect damage in the structures at the element level. Based on the partitioning of the force–displacement relationship as per measured and unmeasured displacements given by Eq. (2), the static stiffness error function is written as Eq. (3),
                           
                              (2)
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         f
                                                      
                                                      
                                                         a
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         f
                                                      
                                                      
                                                         b
                                                      
                                                   
                                                
                                             
                                             
                                                
                                             
                                          
                                       
                                    
                                 
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         K
                                                      
                                                      
                                                         aa
                                                      
                                                   
                                                
                                                
                                                   
                                                      
                                                         K
                                                      
                                                      
                                                         ab
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         K
                                                      
                                                      
                                                         ba
                                                      
                                                   
                                                
                                                
                                                   
                                                      
                                                         K
                                                      
                                                      
                                                         bb
                                                      
                                                   
                                                
                                             
                                             
                                                
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         u
                                                      
                                                      
                                                         a
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         u
                                                      
                                                      
                                                         b
                                                      
                                                   
                                                
                                             
                                             
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (3)
                              
                                 
                                    
                                       e
                                    
                                    
                                       SS
                                    
                                 
                                 (
                                 p
                                 )
                                 =
                                 (
                                 
                                    
                                       K
                                    
                                    
                                       aa
                                    
                                 
                                 -
                                 
                                    
                                       K
                                    
                                    
                                       ab
                                    
                                 
                                 
                                    
                                       K
                                    
                                    
                                       bb
                                    
                                    
                                       -
                                       1
                                    
                                 
                                 
                                    
                                       K
                                    
                                    
                                       ba
                                    
                                 
                                 )
                                 
                                    
                                       u
                                    
                                    
                                       a
                                    
                                 
                                 +
                                 
                                    
                                       K
                                    
                                    
                                       ab
                                    
                                 
                                 
                                    
                                       K
                                    
                                    
                                       bb
                                    
                                    
                                       -
                                       1
                                    
                                 
                                 
                                    
                                       f
                                    
                                    
                                       b
                                    
                                 
                                 -
                                 
                                    
                                       f
                                    
                                    
                                       a
                                    
                                 
                              
                           
                        where vectors ua
                         and ub
                         are vectors of measured and unmeasured displacements. Submatrices Kaa
                        , Kab
                        , Kba
                        , and Kbb
                         represent the partitioned terms of the stiffness matrix and fa
                         and fb
                         represent the partitioned applied load force vector depending on measured and unmeasured displacements at ‘a’ and ‘b’ subsets of degrees of freedom.

Sanayei et al. [21] developed the static flexibility error function.
                           
                              (4)
                              
                                 
                                    
                                       e
                                    
                                    
                                       SF
                                    
                                 
                                 (
                                 p
                                 )
                                 =
                                 
                                    
                                       (
                                       
                                          
                                             K
                                          
                                          
                                             aa
                                          
                                       
                                       -
                                       
                                          
                                             K
                                          
                                          
                                             ab
                                          
                                       
                                       
                                          
                                             K
                                          
                                          
                                             bb
                                          
                                          
                                             -
                                             1
                                          
                                       
                                       
                                          
                                             K
                                          
                                          
                                             ba
                                          
                                       
                                       )
                                    
                                    
                                       -
                                       1
                                    
                                 
                                 (
                                 
                                    
                                       f
                                    
                                    
                                       a
                                    
                                 
                                 -
                                 
                                    
                                       K
                                    
                                    
                                       ab
                                    
                                 
                                 
                                    
                                       K
                                    
                                    
                                       bb
                                    
                                    
                                       -
                                       1
                                    
                                 
                                 
                                    
                                       f
                                    
                                    
                                       b
                                    
                                 
                                 )
                                 -
                                 
                                    
                                       u
                                    
                                    
                                       a
                                    
                                 
                              
                           
                        It is based on the inverse force–displacement relationship and it compares predicted and measured displacements at a subset of DOFs using Eq. (4).

Sanayei and Saletnik [22] developed the static strain error function. It is defined as the difference between predicted and measured strains at selected observation points as,
                           
                              (5)
                              
                                 
                                    
                                       e
                                    
                                    
                                       SSTR
                                    
                                 
                                 (
                                 p
                                 )
                                 =
                                 
                                    
                                       B
                                    
                                    
                                       a
                                    
                                 
                                 
                                    
                                       K
                                    
                                    
                                       -
                                       1
                                    
                                 
                                 
                                    
                                       f
                                    
                                    
                                       a
                                    
                                 
                                 -
                                 
                                    
                                       ε
                                    
                                    
                                       a
                                    
                                 
                              
                           
                        where Ba
                         is the mapping matrix from the relation ε=Ba q and is used to calculate strains from displacements for frame elements. However, for shell elements in PARIS, a more direct approach has been adopted to calculate strains from FE model stresses using Hooke’s Law. SAP2000 calculates stresses at the four integration points for shell elements and extrapolates them to the corner nodes for output. Internally in PARIS, strain calculated at a particular node is averaged based on shell elements surrounding that node.

Sanayei et al. [23] developed the modal stiffness error function. The eigenvalue problem shown in Eq. (6) forms the basis of modal stiffness error function.
                           
                              (6)
                              
                                 K
                                 
                                    
                                       ϕ
                                    
                                    
                                       i
                                    
                                 
                                 =
                                 λ
                                 M
                                 
                                    
                                       ϕ
                                    
                                    
                                       i
                                    
                                 
                              
                           
                        
                     

In Eq. (6), K and M are the stiffness and the mass matrices, respectively. Vector 
                           
                              
                                 
                                    ϕ
                                 
                                 
                                    i
                                 
                              
                           
                         represents the ith natural mode shape and λi
                         is the square of the ith natural frequency.
                           
                              (7)
                              
                                 
                                    
                                       e
                                    
                                    
                                       MS
                                    
                                 
                                 
                                    
                                       (
                                       p
                                       )
                                    
                                    
                                       i
                                    
                                 
                                 =
                                 [
                                 (
                                 
                                    
                                       K
                                    
                                    
                                       aa
                                    
                                 
                                 -
                                 
                                    
                                       λ
                                    
                                    
                                       i
                                    
                                 
                                 
                                    
                                       M
                                    
                                    
                                       aa
                                    
                                 
                                 )
                                 -
                                 (
                                 
                                    
                                       K
                                    
                                    
                                       ab
                                    
                                 
                                 -
                                 
                                    
                                       λ
                                    
                                    
                                       i
                                    
                                 
                                 
                                    
                                       M
                                    
                                    
                                       ab
                                    
                                 
                                 )
                                 
                                    
                                       (
                                       
                                          
                                             K
                                          
                                          
                                             bb
                                          
                                       
                                       -
                                       
                                          
                                             λ
                                          
                                          
                                             i
                                          
                                       
                                       
                                          
                                             M
                                          
                                          
                                             bb
                                          
                                       
                                       )
                                    
                                    
                                       -
                                       1
                                    
                                 
                                 (
                                 
                                    
                                       K
                                    
                                    
                                       ba
                                    
                                 
                                 -
                                 
                                    
                                       λ
                                    
                                    
                                       i
                                    
                                 
                                 
                                    
                                       M
                                    
                                    
                                       ba
                                    
                                 
                                 )
                                 ]
                                 
                                    
                                       ϕ
                                    
                                    
                                       ai
                                    
                                 
                              
                           
                        
                     

After partitioning Eq. (6) similar to Eq. (2) and condensing out unmeasured mode shapes, the modal stiffness error function is given by Eq. (7) as a residual of modal forces. Vector 
                           
                              
                                 
                                    ϕ
                                 
                                 
                                    ai
                                 
                              
                           
                         is defined as the measured modal displacements at subset ‘a’ of DOFs at ith iteration.

Sanayei et al. [24] developed modal flexibility based error function by condensing the characteristic equation written in terms of the flexibility matrix. Hjelmstad [25] also arrived at a similar modal flexibility based error function formulation by only partitioning the mass matrix at measured and unmeasured DOF without using condensation. Similar to static flexibility, the modal flexibility error function includes the inverse of stiffness matrix, K, in its formulation. Modal flexibility error function, as formulated by Sanayei et al. [24], is shown in Eq. (8).
                           
                              (8)
                              
                                 
                                    
                                       e
                                    
                                    
                                       MF
                                    
                                 
                                 
                                    
                                       (
                                       p
                                       )
                                    
                                    
                                       i
                                    
                                 
                                 =
                                 [
                                 
                                    
                                       λ
                                    
                                    
                                       i
                                    
                                    
                                       2
                                    
                                 
                                 
                                    
                                       D
                                    
                                    
                                       ab
                                    
                                 
                                 
                                    
                                       (
                                       I
                                       -
                                       
                                          
                                             λ
                                          
                                          
                                             i
                                          
                                       
                                       
                                          
                                             D
                                          
                                          
                                             bb
                                          
                                       
                                       )
                                    
                                    
                                       -
                                       1
                                    
                                 
                                 
                                    
                                       D
                                    
                                    
                                       ba
                                    
                                 
                                 +
                                 
                                    
                                       λ
                                    
                                    
                                       i
                                    
                                 
                                 
                                    
                                       D
                                    
                                    
                                       aa
                                    
                                 
                                 -
                                 I
                                 ]
                                 
                                    
                                       ϕ
                                    
                                    
                                       ai
                                    
                                 
                              
                           
                        
                     

The matrix D in Eq. (8) is the dynamic matrix given by the relationship D
                        =
                        K
                        −1
                        M.

The quadratic scalar objective function J(p) defined in Eq. (9) is used to judge convergence or divergence of the iterative model updating process. 
                           
                              (9)
                              
                                 J
                                 (
                                 p
                                 )
                                 =
                                 e
                                 
                                    
                                       (
                                       p
                                       )
                                    
                                    
                                       T
                                    
                                 
                                 e
                                 (
                                 p
                                 )
                              
                           
                        
                     

A declining value of J(p) over successive iterations denotes convergence.

The difference in the order of magnitudes of various types of parameters, measured quantities, and error functions used, can potentially give rise to numerical difficulties by making the inverse problem ill-conditioned. Two types of normalization methods are available in PARIS: parameter normalization and error function normalization.

Parameters that define structural element properties are normalized with respect to their initial values to give them the same weight in parameter estimation. Normalizing parameter values to 1.0 by dividing them by initial estimated values is called parameter normalization. An estimated value of 0 indicates complete damage. Additionally, a statistical method for adjusting to measurement errors is to normalize an error function based on the observability of each measurement. Sanayei and DiCarlo [26] implemented this normalization scheme for all three static error functions in PARIS and demonstrated a higher confidence level in estimated parameters especially in presence of measurement errors.
                           
                              (10)
                              
                                 J
                                 (
                                 p
                                 )
                                 =
                                 e
                                 
                                    
                                       (
                                       p
                                       )
                                    
                                    
                                       T
                                    
                                 
                                 
                                    
                                       Σ
                                    
                                    
                                       e
                                    
                                    
                                       -
                                       1
                                    
                                 
                                 e
                                 (
                                 p
                                 )
                              
                           
                        
                     

Using Eq. (10), in which ∑
                           e
                         is the covariance matrix of measured response data, the static error functions in PARIS are both weighted and normalized depending on the level of measurement error. The results of this process approximate that of a maximum likelihood estimator.

Minimizing J(p) using hill climbing method is based on the analytical derivatives of the error functions defined in Eqs. (3), (4), (5), (7), and (8). The analytical sensitivities are presented in Refs. [20–24]. The general from of the sensitivities is defined based on the first derivatives of the error function as shown in Eq. (11),
                           
                              (11)
                              
                                 S
                                 (
                                 p
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             
                                                ∂
                                                {
                                                e
                                                (
                                                p
                                                )
                                                }
                                             
                                             
                                                ∂
                                                p
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The minimization process results in newer estimate of unknown parameters (p+Δp) which take the place of initial estimates (p) for the next iteration. PARIS provides the option of minimizing J(p) by using analytical sensitivities formulated in Refs. [20–24]. The change in parameter values, Δp is obtained from the iterative solution of algebraically nonlinear system of Eq. (12) using the Gauss–Newton method.
                           
                              (12)
                              
                                 S
                                 (
                                 p
                                 )
                                 Δ
                                 p
                                 =
                                 -
                                 e
                                 (
                                 p
                                 )
                              
                           
                        where S(p) is the analytical sensitivity matrix obtained by taking the derivative of the error function vector e(p) with respect to the unknown parameters. The sensitivity matrix S(p) is of size NM×NUP, where NM is defined as the total number of measurements and NUP is the number of unknown parameters in the problem. The change in parameter values, Δp, in the ith iteration, is obtained from solving the over determined system of equations in (12) leading to (13),
                           
                              (13)
                              
                                 
                                    
                                       p
                                    
                                    
                                       i
                                       +
                                       1
                                    
                                 
                                 =
                                 
                                    
                                       p
                                    
                                    
                                       i
                                    
                                 
                                 +
                                 Δ
                                 
                                    
                                       p
                                    
                                    
                                       i
                                    
                                 
                              
                           
                        
                     

An alternative to using analytical sensitivity matrices is using numerical sensitivity matrices by utilizing the MATLAB Optimization Toolbox. It is successfully implemented by using the algorithm for constrained minimization of the algebraically non-linear multivariable error function, fmincon, available in MATLAB. It uses interior point algorithm which is suited for large and sparse problems as well as for small and dense problems (MATLAB Documentation). It satisfies upper and lower bound on parameters at all stages and can recover from undefined and infinite values if encountered in the optimization process. This algorithm requires the target function to be defined in terms of unknown parameters that returns a scalar value, which in PARIS is the scalar objective function J(p).

Convergence criteria are required for terminating the optimization routine. The dissimilarity between the updated unknown parameter values and true values is reconciled within reasonable limits at this level. Convergence criteria used in PARIS are given by Eqs. (14) and (15).
                           
                              (14)
                              
                                 
                                    
                                       
                                          
                                             p
                                          
                                          
                                             i
                                             +
                                             1
                                          
                                       
                                       -
                                       
                                          
                                             p
                                          
                                          
                                             i
                                          
                                       
                                    
                                    
                                       
                                          
                                             p
                                          
                                          
                                             1
                                          
                                       
                                    
                                 
                                 ⩽
                                 relative
                                 
                                 Δ
                                 p
                                 
                                 tolerance
                              
                           
                        
                        
                           
                              (15)
                              
                                 
                                    
                                       J
                                       
                                          
                                             (
                                             p
                                             )
                                          
                                          
                                             i
                                             +
                                             1
                                          
                                       
                                       -
                                       J
                                       
                                          
                                             (
                                             p
                                             )
                                          
                                          
                                             i
                                          
                                       
                                    
                                    
                                       J
                                       
                                          
                                             (
                                             p
                                             )
                                          
                                          
                                             1
                                          
                                       
                                    
                                 
                                 ⩽
                                 relative
                                 Δ
                                 J
                                 (
                                 p
                                 )
                                 tolerance
                              
                           
                        
                     

Relative Δp tolerance for convergence is the change in the value of unknown parameter value with respect to its initial value between two successive iterations. Similarly, relative ΔJ(p) tolerance is the change in the objective function value with respect to its initial value.

In analytical sensitivity matrix based objective function minimization, the sensitivity matrix S(p) is post-multiplied by a boolean group transformation matrix, GT, to map the elements of the sensitivity matrix according to the unknown parameter groups defined by the user. This step reduces the size of S(p) from NM×NUP to NM×NPG, where NPG is the number of parameter groups. In the case of constrained function minimization using MATLAB Optimization Toolbox, fmincon, the objective function J(p) takes the input argument as a smaller vector of grouped unknown parameters pG
                         of size NPG×1 rather than the original vector of unknown parameters p of size NUP×1. The number of unknown independent variables in the resulting multivariable optimization problem in both cases is thus significantly reduced in comparison to the original problem without grouping.

Multi-response parameter estimation refers to the use of different sets of measurements for different load cases and subset of measurements as well as using different types of static and modal data with their corresponding error functions [27]. In PARIS, stacking is implemented by default using Eqs. (16) and (17) whenever a combination of different load cases and/or different error functions is used.
                           
                              (16)
                              
                                 e
                                 (
                                 p
                                 )
                                 =
                                 
                                    
                                       {
                                       
                                          
                                             
                                                e
                                                
                                                   
                                                      (
                                                      p
                                                      )
                                                   
                                                   
                                                      1
                                                   
                                                   
                                                      T
                                                   
                                                
                                             
                                             
                                                e
                                                
                                                   
                                                      (
                                                      p
                                                      )
                                                   
                                                   
                                                      2
                                                   
                                                   
                                                      T
                                                   
                                                
                                             
                                             
                                                .
                                                .
                                                .
                                             
                                             
                                                e
                                                
                                                   
                                                      (
                                                      p
                                                      )
                                                   
                                                   
                                                      n
                                                   
                                                   
                                                      T
                                                   
                                                
                                             
                                          
                                          
                                             
                                          
                                       
                                       }
                                    
                                    
                                       T
                                    
                                 
                              
                           
                        
                        
                           
                              (17)
                              
                                 [
                                 S
                                 (
                                 p
                                 )
                                 ]
                                 =
                                 
                                    
                                       [
                                       
                                          
                                             
                                                
                                                S
                                                
                                                   
                                                      (
                                                      p
                                                      )
                                                   
                                                   
                                                      1
                                                   
                                                   
                                                      T
                                                   
                                                
                                             
                                             
                                                S
                                                
                                                   
                                                      (
                                                      p
                                                      )
                                                   
                                                   
                                                      2
                                                   
                                                   
                                                      T
                                                   
                                                
                                             
                                             
                                                .
                                                .
                                                .
                                             
                                             
                                                S
                                                
                                                   
                                                      (
                                                      p
                                                      )
                                                   
                                                   
                                                      n
                                                   
                                                   
                                                      T
                                                   
                                                
                                             
                                          
                                          
                                             
                                          
                                       
                                       ]
                                    
                                    
                                       T
                                    
                                 
                              
                           
                        
                     

Observing different types of responses simultaneously to estimate a set of unknown parameters is an effective approach as it increases the amount of information used in the parameter estimation process by simultaneously using esf
                        , esstr
                        , emf
                         or ess
                        , e
                           ms
                         error functions in groups.

The parameter estimation process is sensitive to the accuracy of measurements collected during a NDT. The sensors and instruments can either be erroneous due to defects in the manufacturing process or become faulty in their handling and installation. Normally, a bound on accuracy of a measuring device is stated by the manufacturer. This bound on the level of errors, however, can be exceeded due to difficulties in sensor installation and connection losses [28]. Although there is no way to accurately model actual measurement errors, the options to introduce uniformly or normally distributed errors in simulated data are available in PARIS to study the influence of measurement errors on estimated parameters. While uniform error distribution resembles a banded type of error with equal probabilities of occurrence throughout, the normal error distribution is a non-banded type of error with its probabilities of occurrence being higher closer to true values [29]. Eqs. (18) and (19) are used for contaminating simulated NDT data with proportional and absolute errors, respectively.
                           
                              (18)
                              
                                 
                                    
                                       q
                                    
                                    
                                       m
                                    
                                 
                                 =
                                 q
                                 
                                    
                                       
                                          1
                                          +
                                          
                                             
                                                1
                                             
                                             
                                                2
                                             
                                          
                                          
                                             
                                                e
                                             
                                             
                                                q
                                             
                                          
                                          ⊗
                                          
                                             
                                                R
                                             
                                             
                                                q
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (19)
                              
                                 
                                    
                                       q
                                    
                                    
                                       m
                                    
                                 
                                 =
                                 q
                                 +
                                 
                                    
                                       1
                                    
                                    
                                       2
                                    
                                 
                                 
                                    
                                       e
                                    
                                    
                                       q
                                    
                                 
                                 ⊗
                                 
                                    
                                       R
                                    
                                    
                                       q
                                    
                                 
                              
                           
                        
                     

In the equations above, q is the vector of measured forces or simulated response. eq
                         represents the percentage level of measurement error in Eq. (18) whereas in Eq. (19) it represents absolute error with units as defined by the user. The vector Rq
                         is fully populated either with uniformly distributed random numbers between 0 and 1 or normally distributed random numbers with 0 mean and standard deviation of 0.5. The symbol 
                           
                              ⊗
                           
                         denotes element-wise vector multiplication.

The IASC-ASCE SHM Benchmark Structure is the leading contemporary example of a framed building structure. Currently in its second phase (Dyke et al. [30]), it provides a platform for researchers to test their hypotheses on damage identification and assessment for structural health monitoring. The FHWA’s bridge inspection program has inspired the SHM community to develop and test novel tools and techniques for bridge monitoring and maintenance. Cardini and DeWolf [31] present, in one example, the use of strain data from a multi-girder composite steel bridge for long-term SHM. Farrar and Jauregui [32] performed comparative analysis of various damage based assessment method using modal data from a damaged and an undamaged bridge.

Three full-scale FE model updating examples using simulated NDT data are presented to illustrate the range of capabilities of the PARIS program using Application Programing Interfaces (API) for automated and systematic parameter estimation. These examples are the IASC-ASCE scale model benchmark building comprised of frame and shell elements, girder-3 of the Powder Mill Bridge made with solid (concrete deck) and shell (steel girder) elements, and the complete model of Powder Mill Bridge using shell elements (concrete deck) and frame (steel girder) elements. The combination of program features covered in each example is shown in Table 1
                     . This section contains the description of the structures, model updating problem formulation, and parameter estimates for all three examples.

The first column in Table 1 presents various features of PARIS which are further expanded in column two. Verification examples using these features of the program are shown in columns three to five for the FE model of the IASC-ASCE SHM Benchmark Structure, the Powder Mill Bridge (PMB) Girder-3 model, and the full-scale PMB model, respectively.

An analytical model based on the Phase-I study of the IASC-ASCE SHM Benchmark Problem was updated using PARIS as the first verification example. The global geometry and member properties as well as damage scenarios 1 and 2 to simulate damage are taken from Black and Ventura [33] and Johnson et al. [34]. The FE model used in this research is slightly different than the actual analytical model. Originally, two finite element models were developed by IASC-ASCE SHM Task Group. The first model was a 12 DOFs shear-building model in which only two horizontal translations and one rotation was permitted for each floor. The second model had 120 DOFs which constrained all nodes at each floor only for the same horizontal translations and in-plane rotations [34]. The structural model used here has 1944 DOFs because of greater discretization of shell elements at the floor levels and also from the fact that all rotational and translational DOFs are made active in analysis.


                        Fig. 2
                         shows the FE model of the experimental steel frame housed in the Earthquake Engineering Research Laboratory at the University of British Columbia. It is a 4-story, 3.6m high structure with two bays in orthogonal lateral directions with each bay measuring 1.25m. The sections are made out of hot rolled grade 300W steel with 300MPa nominal yield stress. Steel sections that constitute the structure are B100×9 (columns), S75×11 (beams), and L25×25×3 (braces). The floor slab at each story is comprised of 4 square slab panels. Mass of each panel is 800kg at the first floor and 600kg at the second and the third floor. The fourth floor has 3 panels of 400kg mass and 1 panel that has a mass of 550kg. Each of the 4 slab panels measuring 1.25m×1.25m is modeled using 16 thin-shell elements. The columns are oriented with their weak axis (y) along the global X axis in the SAP2000 model. All beams connect rigidly to the columns while the braces are pin connected and thus behave as axial members. All columns are fixed at the base.

PARIS was used to estimate the unknown stiffness and/or mass parameters for four simulated damage scenarios as summarized in Table 2
                        . In first damage case, the first floor braces with 8 unknown EA parameters were grouped into 4 different unknown parameter groups. Error functions SS, SF, and SSTR were run individually. In the second damage case, 3 EIzz and 3 EIyy parameters of the base columns at Grid-A were paired as two groups. Error functions SS, SF, and SSTR were run again individually. In the third damage case in which mass of one slab panel is the unknown parameter, modal error functions were used one at a time to estimate the reduced mass of 16 shell elements making up that panel as one group. In the fourth damage case, both stiffness and mass parameters were estimated using SS and MS error functions simultaneously. The eight braces on one side of the frame (at Grid A) of the model were paired into 4 unknown stiffness parameter groups based on their story level. The four mass parameter groups comprised of four floor slab panels at each of the 4 story levels.

Diagnostic static test loads were applied under four load cases. Table 3
                         shows the location and magnitude of loads for all four load cases. The prefix ‘S’ refers to a story. Reference is made to grid lines from Fig. 2.

Displacement and strain measurement locations for static load cases used with damage cases 1, 2, and 4 are listed in Table 4
                         and Table 5
                        .

For estimating the unknown mass parameters for damage cases 3 and 4, mode shapes 1 to 3 were utilized. Mode 1 and 2 are bending modes in the global Y and the X directions, respectively. Mode 3 is the torsional mode about Z axis. Mode shapes 1 through 3 and their associated natural frequencies for un-damped vibrations are shown in Fig. 3
                        .

Displacements were measured for modes 1, 2, and 3 at locations listed in Table 6
                        .

The parameter estimation results for the four damage cases described above are presented here. For damage case 1, the parameter estimates are presented in Fig. 4
                        . The first bar represents the normalized value of initial guess of parameters. Bar number 2 is the true value of the parameter used to simulate NDT data. The last three bars are parameter estimates using simulated measurements for error functions SS, SF, and SSTR, respectively. This case shows that the first floor braces are identifiable using either the nodal displacements or member strains using simulated NDT data. The SS, SF, and SSTR error functions were all used independently and successfully estimating the EA parameters for damage case 1.

For damage case 2, the parameter estimates are presented in Fig. 5
                         for updating EIzz and EIyy parameter groups for three base columns. All three static error functions estimated the grouped bending rigidities along the major and minor axes of the columns. The convergence criterion for relative ΔJ(p) tolerance was maintained at 10E−10 while that for relative Δp tolerance was 10E−06 for all damage cases. This case shows that column moments of inertia are identifiable using any of SS, SF, and SSTR error functions when the NDT loads were applied to the structure to cause bending of the columns with unknown EI parameters and measurements were taken to observe these parameters. The accuracy of the parameter estimates relates to good observability of the unknown parameters by the the measurements at the selected nodes or members.

For damage case 3, the mass parameter of one roof slab panel was updated from an initial guess of 550kg to a final value of 400kg using modal stiffness and modal flexibility error function. Modal stiffness error function converged faster in 7 iterations than the modal flexibility error function that took 13 iterations. This damage case shows that mass parameter is also identifiable using modal error function MS and MF independently. Changes in mass alter the modal frequencies of the structure. PARIS detected the change and updated the mass parameter appropriately to minimize the residual.

For damage case 4, the combined stiffness and mass parameter updating capability of PARIS and the resulting parameter estimates are shown in Fig. 6
                        . The parameter groups G1 through G4 are the unknown EA parameters for braces. Groups G5 through G8 represent unknown floor mass parameters with an estimated value equal to true value of 0.6. In this case, advantage of using a smaller number of unknown parameters was achieved by grouping the similar parameters together. the mass matrix and the stiffness matrix were updated iteratively in PARIS until the objective function value was reduced to a level below the convergence limit. At this stage, the predicted response measured well with the measured response from the simulated NDT data.


                        Table 7
                         compares the EA parameter estimates and number of iterations required for FE model updating for damage case 1 shown in Fig. 4 in presence of 2% normally distributed proportional measurement errors in forces and displacements. Damage case 1 simulated a 100% axial rigidity loss in all 8 braces at the first story as shown in Table 2. The parameter estimates using SF and SSTR are shown, first separately and then stacked together.

The merit of multi-response parameter estimation is seen in reduction of the number of iterations required when SF and SSTR error functions are stacked.


                        Fig. 7a and 7b
                        
                         represent the parameter estimates for damage case 2 using static error functions in presence of 2% normally distributed proportional measurement error in forces and displacements. In this damage case, bending rigidity loss of 30% in columns at Grid A at the first story level was present. Fig. 7a shows high scatter in the parameter estimates in presence of measurement errors. However, the EIzz and EIyy parameter estimates using statistical error function normalization were closer to the true parameter values in presence of measurement errors. The results in Fig. 7b demonstrate the robustness of the statistical normalization method proposed by Sanayei and DiCarlo [26]. The authors recommend the use of the statistical normalization method for parameter estimation.

After successful completion of the IASC-ASCE SHM Benchmark Structure using four damage cases with and without measurement errors, a full scale bridge is studied first using shell and solid elements for modeling one composite girder and then the full bridge is modeled using shell and frame elements. Several damage cases using various error functions is used for parameters estimation and FE model updating.

The Powder Mill Bridge (PMB) in Fig. 8
                         is a three span continuous steel girder bridge with a reinforced concrete deck in composite action. The bridge crosses the Ware River in the town of Barre, Massachusetts. This bridge was used for examining capabilities of PARIS for full-scale FE model updating. Two finite element models of the PMB were updated for assumed damage scenarios. The first model discussed below is of one of the continuous interior girders of the bridge. This model is made of solid and shell finite elements and is referred to as Solid-Shell model further in the text. The second model is the full bridge model which is made of shell and frame elements and is referred to as Shell-Frame model. Truck loads are applied as static loads in different load cases to simulate a truck crossing the bridge. The damage scenarios consider alteration in the stiffness of finite elements to simulate damage incurred in the deck and girders.

The first finite element model used with this example is of a single interior girder (Girder-3) of the bridge as shown in Fig. 9
                           . This model is comprised of cuboid solid elements for bridge deck and haunch and quadrilateral plan thin-shell elements for web and flanges of the W920×238 steel girder. The support conditions at the pier cap and abutment are modeled with joint springs based on stiffness values from Sanayei et al. [35]. Solid elements used to model deck and haunch have reduced modulus of elasticity for concrete (Ec
                           ) in the negative moment region, which is considered to be 20% of the length of each span.

A test truck load of 353.6kN (79.5kips) is applied along a straight path centrally aligned over Girder-3 of the bridge.

In order to simulate a crawl speed NDT, the truck location on the bridge was discretized into 13 static load cases as shown in Fig. 10
                           . The truck load was applied as a 3-axle (3×2 point loads) in each load case. The displacement and strain measurement locations were chosen to be the central node at the bottom flange at the center of the end spans of the bridge and at quarter points at the longer central span. Since PARIS is designed to accommodate different number of measurements in each load case, only observations from the span on which the truck was located were used with that load case, respectively.

The PMB Girder-3 Solid-Shell model has 9,168 nodes which represent a total of 35,256 DOFs. The model was however analyzed in XZ-plane with two translational and one rotational DOF thus reducing the active DOFs to 27,504. Since the size of the stiffness matrix is dependent on the number of active DOFs, a reduction in the number of active DOFs in a model reduces computational time, thus speeding up the FE model updating process.

This verification example included model updating in two simulated damage scenarios with no measurement errors. The damage scenarios and parameter estimation results are presented next.


                           Damage case 1: In the first damage case, a loss of 20% horizontal translational stiffness (kXX
                           ) and rotational stiffness (kθY
                           ) was considered to simulate joint deterioration. The damage was assumed to occur similarly at both the pier and abutment locations. The bottom flange of the girder has four shell elements across its width thus requiring joint springs at 5 points. All five spring stiffnesses were grouped together as a single parameter at each of the four support locations (two piers and two abutments). PARIS was used to accurately estimate the unknown stiffness values using all three static error functions. The stiffnesses of the joint springs contribute to the stiffness matrix of the structure and thus determine the structure’s response to loading conditions. It was possible to update the spring stiffnesses in PARIS through the use of SAP2000 APIs to access and modify stiffness values. In this case the static stiffness and static strain error functions estimated the unknown bending rigidities more accurately than the static flexibility error function.

Mean of translational and rotational stiffness values at four support locations is shown in Fig. 11
                           . SS and SSTR functions performed better in terms of accuracy of the parameter estimates. The number of iterations required for model updating for damage case 1 were 27 for the SS error function, 96 for SF error function, and 37 for the SSTR error function.


                           Damage case 2: A loss of 20% of the girder’s stiffness was assumed to occur at the entire south span of 11.75m length as a global deterioration case. Since girder is comprised of shell elements, the damage in finite element model would then be reflected in reduction of modulus of elasticity (Es) of steel. The 624 shell elements making up the south span of the girder in the FE model were grouped into 8 groups with 78 elements in each group. The elements were grouped along the length of the girder with equal number of elements in each group. Static strain error function was used to estimate 20% reduction in Es
                           . The PMB Girder-3 Model was updated using only SSTR error function for damage case 2. The mean of estimated parameters values of Es
                            for shell elements was 0.8035 from the expected value of 0.8 and had a 0.0148 standard deviation. Unlike translational displacement measurements, strain measurements are reference-independent making them a preferred measurable response quantity. Strain gauges are also a low cost option when compared to both contact and non-contact devices required for measuring displacements.

One particular aspect that deserves attention is the ability to discretize the FE model to a satisfactory level that leads to a large number of elements in the model. Normally it is not feasible to identify all elements in a finite element with a fine mesh using a coarse set of measurements points. Grouping of similar unknown parameters allow solving of the inverse problem. At the same time when a localized damaged region is observed, it is possible to ungroup the parameters of those areas to zoom in damage severity at smaller locations.

A full-scale FE model of the PMB comprised of frame and shell elements was updated for two damage scenarios. Frame elements were used to model the six main girders of the bridge as well as the diaphragms and outriggers at the north end of the bridge. Offset was applied to frame elements for modeling supports at the bottom flange of the girder. The shell elements constituted the concrete bridge deck. The shell elements were offset upwards by half the shell thickness to model the deck resting on top flange of the girders. The PMB Shell-Frame model is shown in plan in Fig. 12
                            with gridlines 1 through 6 representing girder numbers and S1 through S4 representing abutment (S1 and S4) and pier support (S2 and S3) locations. Darker longitudinal lines indicate girders and darker transverse lines indicate diaphragms.

The static load cases were applied in a fashion similar to that for the solid-shell girder model with the addition of four test truck paths across the width of the bridge. Eight sets of truck loads were modeled in each of the five test truck paths on the bridge.


                           Damage case 1: A damage case that considers a theoretical 20% reduction in bending capacity of girders 4 and 5 was considered first. The entire length of these two girders was assumed to have a reduced EI33 value. Since each of the two girders in the model is comprised of 36 smaller frame elements connected at ends, the elements were grouped together into three groups where each group represents one span length. Starting with the initial guesses of EI33 of girders 4 and 5, the unknown moment of inertias converged to values very close to the true values of EI33 that were used for simulating NDT data.

The results from model updating for shell-frame model using SSTR error function are shown in Fig. 13
                           . The bending rigidity of frame elements representing girders 4 and 5 converged with a mean error of -1.33%. However maximum error in groups 3 and 6, which represents the north spans of the girders, was higher than for the center and south spans. This could be attributed to smaller deformations from increased stiffness at the north end of the bridge leading to lower sensitivity in estimating parameter values.


                           Damage case 2: Damage to the bridge deck is a prominent type of damage in bridges. This type of damage can be caused by traffic loads, environmental factors including diurnal and seasonal temperature variation, and water infiltration through expansion joints or poor quality control during construction. To simulate this damage scenario, a cluster of 30 shell elements equivalent to deck surface of 44.04m2 were grouped together to simulate damage. It represents a patch beginning at length 3.92m from south end till 11.75m length and lies on the right lane looking north. The damage level is taken to be 50% of the initial shell elasticity modulus (Ec). The concrete modulus of elasticity for all five deck groups was successfully estimated (see Fig. 14
                           ).


                           Ec
                            estimates for loss of 50% deck stiffness for a cluster of shell elements described under damage case 2 were quite accurate. The model updating process was automatically terminated when relative change in parameter values between two iterations became less than 10E−12. It took 13 iterations for the convergence criteria to be met.

The three examples presented here to demonstrate that the Application Programming Interfaces enable researchers to take advantage of the existing commercial programming and structural analysis software packages. PARIS has access to advanced programming with optimization mathematics as well as various finite elements for 3D modeling and analysis of large structures taking advantage of pre and post-processing tools. With these examples, the feasibility to perform finite element model updating of a 3D laboratory building model, a 3D bridge girder, and a full-scale 3D bridge model is demonstrated. The range of capabilities of the PARIS program using APIs include the utilization of error functions for use of NDT data such as static translations, rotations, and strains as well as dynamic frequencies and mode shapes for automated and systematic finite element model updating. Methods for updating full-scale structures with a large number of elements are presented using parameter grouping and stacking of various types of measurements for multi-response parameter estimation. Measurement errors are introduced to study the sensitivity of the inverse problem to the number, type, and location of loadings, measurements, and unknown parameters. Performing error sensitivity simulations prior to the use of NDT data is paramount in success of finite element model updating using measured test data of full-scale structures.

@&#CONCLUSIONS@&#

PARIS provides a platform for automated FE model updating of full-scale structures. The PARIS program is capable of automatically calibrating an a priori FE model created in SAP2000 by reconciling its analytical response with the measured response. PARIS achieves this by automatically accessing the finite element analysis (FEA) solver of SAP2000 program by using the available SAP2000 Application Programming Interface (API) function library. Through the API interface, MATLAB gains access to SAP2000 elements library, analysis modules, and the GUI interface for pre-processing and post-processing, thus using SAP2000 as a slave program. Additionally PARIS is written in MATLAB which is a powerful programming platform with access to various mathematical functions, matrix operations, and optimization routines. Successful implementation of MATLAB’s readymade optimization routines for constrained function minimization aids in handling of larger parameter estimation problems.

The performance of PARIS has been demonstrated using three examples with simulated test data. The program was used to update the analytical model of the IASC-ASCE SHM Benchmark Structure, the Powder Mill Bridge Girder-3 Solid-Shell model, and the full-scale Powder Mill Bridge Shell-Frame model. This study validates the feasibility of using static and modal NDT data for successful full-scale FE model updating as well as the potential of the newly developed statistical error function normalization using the covariance matrix of measured data in improving accuracy of the parameter estimates in presence of measurement error.

With these capabilities, PARIS significantly steers the use of FE model updating for structural health monitoring and assessment of in-service structures. Integration of commercial FEA packages with custom research software creates opportunities for validating and comparing several parameter estimation and FE model updating techniques. In development and deployment of frameworks such as this lies the benefit of utilizing modern technology for effective and thorough structural health monitoring and FE model calibration.

@&#FUTURE WORK@&#

Phase I and II of this project are completed. Further development of PARIS computer program aligns with the following future research goals: (1) Studying robustness of suggested improvements to parameter estimation process in the areas of sensor placement and accounting for modeling and measurement errors, and (2) Utilizing PARIS for full-scale bridge model calibration and damage detection using field measured NDT data.

@&#REFERENCES@&#

