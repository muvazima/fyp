@&#MAIN-TITLE@&#A real-time order acceptance and scheduling approach for permutation flow shop problems

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Proposed a new Real-Time strategy for solving Flow Shop Scheduling Problems.


                        
                        
                           
                           Designed a set of benchmark to test the performance of the approach.


                        
                        
                           
                           The algorithm is compared with the traditional Right Shifting strategy.


                        
                        
                           
                           Numerical results show that the approach improves financial return.


                        
                        
                           
                           A case study is provided to show the applicability of the proposed approach.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Real-Time multiple-order scheduling

Flow shop scheduling

Random order arrival

Genetic algorithm

Memetic algorithm

@&#ABSTRACT@&#


               
               
                  The Permutation Flow Shop Scheduling Problem (PFSP) is a complex combinatorial optimization problem. PFSP has been widely studied as a static problem using heuristics and metaheuristics. In reality, PFSPs are not usually static, but are rather dynamic, as customer orders are placed at random time intervals. In the dynamic problem, two tasks must be considered: (i) should a new order be accepted? and (ii) if accepted, how can this schedule be ordered, when some orders may be already under process and or be in the queue for processing? For the first task, we propose a simple heuristic based decision process, and for the second task, we developed a Genetic Algorithm (GA) based approach that is applied repeatedly for re-optimization as each new order arrives. The usefulness of the proposed approach has been demonstrated by solving a set of test problems. In addition the proposed approach, along with a simulation model, has been tested for maximizing the revenue of a flow shop production business under different order arrival scenarios. Finally, a case study is presented to show the applicability of the proposed approach in practice.
               
            

@&#INTRODUCTION@&#

The Permutation Flow Shop Scheduling Problem (PFSP) is one of the challenging scheduling problems that occurs in the manufacturing industries. A conventional PFSP considers how to process n jobs on m machines. Each job has predefined tasks that are processed by a specific set of machines through a specific processing order. In solving PFSPs, makespan minimization is a common and popular measure of performance. The time difference between the start of the first job in the first machine, and the end of the last operation in the last machine, can be defined as makespan. In order acceptance and scheduling problems, the objective is to maximize the number of accepted orders, while minimizing the order completion times. PFSPs can be categorized as either single-order or multiple-order. In this research, we assume each order contains a certain number of jobs. The basic difference between a single-order and a multiple-order problem is that in a single order problem the decision maker has to determine an effective schedule for a single order (a given set of jobs in the order) on a set of machines with known sequence of operations and processing times. Whereas, in a multiple-order problem, the decision maker has to face a stream, or pool, of orders which are scheduled on a set of machines, where the scheduler has the option of accepting or rejecting the arriving orders (Slotnick, 2011). Besides, the single-order problem is static and the multiple-order problem is either static or dynamic. In a multiple-order static problem, the order arrival times and due dates are known well in advance. For static problems, either single or multiple-order, it is expected to solve a problem only once. However, in dynamic multiple-order problems, it is assumed that the order arrivals continue with time (on a real-time basis), and the problem is to select a set of orders that would be feasible for processing within the available shop capacity, and to determine an effective schedule for the jobs of those selected orders over a given period of time. In this case, the order selection must be done immediately after the arrival of any new orders, and the job schedule must be updated, if any order is accepted.

Single-order PFSPs have been widely studied in the literature. First, in 1954, Johnson (1954) introduced the flow shop problem as an interesting scheduling problem and proposed a simple algorithm that guaranties the optimal solution for a two machines static flow shop problem, and for a special case with a three machine problem, in polynomial time. For solving PFSPs with three or more machines, many researchers used exact techniques such as mixed integer programming (Selen & Hott, 1986), and Branch and Bound (B&B) algorithms (Ignall & Schrage, 1965). However, as the single-order PFSP is NP Hard (when the number of machines is three or more) (Garey, Johnson, & Sethi, 1976), researchers have focused on heuristic techniques (Ruiz & Maroto, 2005). Among recent heuristics, Nawaz et al.’s (Nawaz, Enscore, & Ham, 1983) NEH algorithm is regarded as one of the best constructive heuristics for solving static PFSPs. However, it still deviates by up to 7 percent from the known optimum for some problems (Ruiz & Maroto, 2005; Taillard, 1990; Zobolas, Tarantilis, & Ioannou, 2009). This heuristic is based on the idea that longer jobs in the sequence should be processed as early as possible in the schedule. To improve the solution quality of PFSPs, researchers have switched their attention to metaheuristics, such as the Simulated Annealing (SA) algorithm (Ogbu & Smith, 1990; Osman and Potts, 1989), Cuckoo search algorithm (Dasgupta & Das, 2015), Genetic Algorithms (GAs), including Hybrid GAs (Murata, Ishibuchi, & Tanaka, 1996; Rahman, Sarker, & Essam, 2013; Ruiz, Maroto, & Alcaraz, 2006; Tseng & Lin, 2009; Zobolas et al., 2009), Ant colony algorithms (Rajendran & Ziegler, 2004), particle swarm optimizations (Tasgetiren, Liang, Sevkli, & Gencyilmaz, 2007), tabu search (Grabowski & Wodecki, 2004), and differential evolution (Onwubolu & Davendra, 2006). From the computational results provided in the literature, the hybrid metaheuristics, in general, show promising performance.

Many manufacturing firms receive a stream of orders (or a certain pool of orders) from which certain orders may be accepted and scheduled with respect to the available production capacity (Slotnick, 2011). If a firm either accepts a new order without checking its feasibility for on-time completion, or cannot schedule all the accepted orders for on-time completion, it will produce a poor production plan that would lead to reduced revenue (Guerrero & Kern, 1988). The order acceptance/rejection problem has been studied mainly in a single machine environment as a static problem, where the order arrival times are known well in advance (Lewis & Slotnick, 2002; Rom & Slotnick, 2009; Slotnick & Morton, 1996, 2007). A brief review of the single machine static acceptance/rejection problem is provided here. Slotnick and Morton (1996) proposed an integer programming algorithm with the objective of maximizing the profit. Lewis and Slotnick (2002) applied dynamic programming for a multi-period job selection process where job rejection involves future loss of customer. Slotnick and Morton (2007) later extended the problem of (Lewis & Slotnick, 2002; Slotnick & Morton, 1996) for limited capacity. In their work, a branch and bound algorithm was proposed to deal with order acceptance decisions and several heuristics were used to sequence the jobs to minimize weighted tardiness. Rom and Slotnick (2009) extended the previous approach of order acceptance and scheduling decision with lateness penalties (Lewis & Slotnick, 2002; Slotnick & Morton, 1996) and weighted tardiness (Slotnick & Morton, 2007). They proposed a GA which minimized weighted tardiness, and it performed well with respect to a previously proposed heuristic (Slotnick & Morton, 2007), even though it took more time in computation. Nobibon and Leus (2011) considered a problem where a company has to select orders from a pool of firms planned orders, as well as any other demanded orders. Wang, Zhu, and Cheng (2015) studied a subcontracting price scheme for the static order acceptance and scheduling problem in a single machine environment. The multi-order static problem has also been studied in a multiple machines environment (Chen, Mestry, Damodaran, & Wang, 2009; Pourbabai, 1989; Roundy et al., 2005; Wang, Huang, Hu, & Cheng, 2015; Wang, Xie, & Cheng, 2013a
                     , 2013b). Wang et al. (2013a) developed a modified artificial bee colony algorithm for solving the order acceptance problem in two machine static multiple-order PFSPs. Wang et al. (2013b) proposed a B&B algorithm and a heuristic to solve the order acceptance problem in two machine static multiple-order PFSPs. Xiao, Zhang, Zhao, and Kaku. (2012) studied a static multiple-order PFSP with order acceptance and weighted tardiness problems. Lin and Ying (2015) proposed a multi-initiator SA for the same problem, and the experimental results showed that the proposed algorithm outperforms Xiao et al. (2012)’s approach. In both studies, each order contained a single job and at the beginning of the planning period, the firm received a pool of candidate orders with known arriving times, order compositions, and due dates. Wang, Huang et al. (2015) proposed a Lagrangian relaxation technique based exact algorithm, and two heuristics to solve the order acceptance problem in a static multiple-order two identical parallel machine problem. Chen et al. (2009) addressed static order arrival in a job shop environment by using a mixed integer programming approach for smaller problems, and a B&B algorithm with Lagrangian bounds and approximate branching features for larger problems. Pourbabai (1989) developed a model to identify potential orders, order splitting considering due dates, and job set up, and scheduled jobs using a dispatch rule based on order availability and due dates on a multiple machine environment where the machines are grouped into cells (group technology concept). Roundy et al. (2005) considered a job shop environment, in which an order is accepted, if it can in any way be inserted into the current schedule. They developed both a single machine heuristic, as well as meta-heuristics (tabu search, GA, SA), to solve the problem.

There are a few studies that have considered dynamic order arrival in a single machine environment. Wester, Wijngaard, and Zijm (1992) studied the relationship between three different order acceptance strategies: order acceptance based on the knowledge of previously accepted orders, order acceptance based on the total workload of all accepted orders, and order acceptance based on the aggregated load profile of accepted orders, and scheduling jobs to maximize the utilization of capacity. In this case, the authors found that using knowledge of the current production schedule when generating new schedules because of new order arrivals, was superior over the other two approaches. Duenyas and Hopp (1995) considered that order arrival and processing times were stochastic. In that study, an arriving order was only rejected if it was beyond the customer's tolerance limits. Later, Duenyas (1995) extended the work of
Duenyas and Hopp (1995) to consider customer quoted due dates.

The next level of complexity is dynamic order arrival in a multiple machine environment, which is closer to the research presented in this paper. There is no doubt that this topic is much more complex and has more synergies with practical situations. Nandi and Rogers (2004) proposed simulation based order acceptance and scheduling decisions for two product types (regular and urgent), with profit maximization as the objective in a four stage hybrid flow shop environment. The order acceptance was done by pair look simulation (based on the total contribution in companies profit, if an order arrives and whether it is accepted or rejected), and scheduling was done by minimizing the amount of slack per operation remaining. Rogers and Nandi (2007) used a simulation tool to maximize the profit with a fixed capacity in a four stage hybrid flow shop. The scheduling was done by using dispatching rules (first come first serve rule, earliest due date, minimum slack per operation remaining). Moreira and Alves (2009) also used simulation to investigate multiple decision making (order acceptance, due date adjustment, order releasing and scheduling) in a job shop environment to improve lateness penalties and workload performance. Scheduling was generated by using both the earliest due date rules and also the first come first serve rules. Tang, Liu, and Liu (2005) proposed a neural network that integrated six priority rules, for the hybrid dynamic flow shop problem with the objective of minimizing the average flow time, average number of tardy jobs, and average tardy time. In that work, jobs arrival (each order containing a single job) was assumed to follow a Poisson distribution. Kang, Duffy, Shires, Smith, and Novels (2014) developed an integrated approach, based on the concept of advanced planning and scheduling, with a closed looped methodology for Lean-scheduling of practical dynamic semiconductor and cable manufacturing environments.


                     Pinedo (2012) criticized that most of the theoretical models for multiple machine scheduling made an assumption of scheduling an n set of jobs in an m set of machines, while in an actual manufacturing environment, the jobs of an order may be processed at any specific time, because orders may be placed by the customers at any point in time, i.e. new orders arrive in the system randomly. Machine and resource availabilities also change with time (Schmidt, 2000). The static single-order and static multiple-order PFSPs thus ignore the status of the manufacturing shop floor. In addition, each order has customer or manufacture specified due dates, within which it should be processed and delivered to a customer. Considering all these conditions, it may be feasible to accept all the orders that arrive at a manufacturing firm. On the other hand, frequent order rejection will diminish a Company's goodwill. So an effective approach is necessary to deal with this situation. Although the order acceptance/rejection decisions and scheduling decisions are interdependent, in multiple machine environments where orders arrive dynamically, almost all previous research considered the order acceptance/rejection decision and scheduling decisions separately.

In this research, we have considered a real-time multiple-order PFSP, where the orders are placed with a flow shop at random time intervals. In this case, each individual order can be thought of as being similar to a static single-order PFSP, but with no prior knowledge about the order compositions, due dates and arrival time. Each order has a customer or manufacturer specified due date (or delivery date). If the inter-arrival time of orders is greater than the makespan (calculated under a static single-order PFSP scenario) of the previously accepted orders, then the schedule generated for their static single-order PFSPs can be implemented without any alteration. However the situation is different when their processing times overlap. In such cases, it may not be feasible to accept all the arrival orders while satisfying production capacity and due date constraints. The production scheduler has to make two decisions: (i) is it possible to accept a new order? (ii) if the processing time of a new order overlaps with the other orders; how should the order be scheduled? The first decision depends on the orders already accepted, orders under process, and the availability of resources to process the new order. The second decision can be made in two ways. (i) Each order can be assumed as a static single-order PFSP and the order can block the machines for the time slot equal to their makespan. Each new accepted order should then be scheduled immediately after finishing the orders currently under process. That means new orders will be scheduled by shifting them to the right of the schedule. Such an approach is known as the Right Shifting (RS) strategy. (ii) This strategy intends to utilize any free machines, instead of blocking all machines for a certain period of time that is equal to the makespan of each individually accepted order. For example, the current order or orders may finish processing in the first machine, or the first couple machines while a new order has been accepted. The newly arrived order can then start processing in the first machine. After processing in the first machine, the second or third machine may not be available immediately. In that case, the order may have to wait in a queue until the following machine is free. But the immediate start of an order has the benefit of finishing the order early, as well as of increasing the chance of accepting upcoming orders by the same facility. This advantage can be taken by rescheduling the order while considering the individual machine availability constraints.

In this paper, a GA based Memetic Algorithm (MA) for rescheduling an order in real-time has been developed. We introduce this as the Real-Time (RT) strategy. There is no standard benchmark available for the real-time multiple-order PFSPs. For experimentation, we have chosen 40 instances of 10 machine PFSPs from the standard Taillard's benchmark (Taillard, 1993). We then generated random inter-arrival times and due dates for arriving orders. To judge the quality of the solutions, we compare with the upper and lower bounds of possible solutions. The experimental results show the benefits of the proposed algorithm. As a consequence of the variability in the inter-arrival times of new orders and their due dates, and production capacity, it may not be feasible to accept all arriving orders. However, it may be profitable to accept some tardy orders, with an agreed tardiness penalty, if they are completed within a given tardiness limit. To examine the possibility of accepting tardy orders, we have developed a simulation model for experimenting with different level of tardiness limits. This approach shows interesting results. Finally, to demonstrate the usefulness of the developed approaches in practice, we have presented a brief case study of a Sanitaryware production system. The proposed approaches will provide numerous advantages over the existing methodologies, such as better production capacity utilization, higher financial return, higher organization satisfaction, higher customer satisfaction and real-time decision making.

This paper is organized as follows: after the Introduction, the problem definition and necessary assumptions have been provided in Section 2. Section 3 describes the proposed algorithm for solving single-order PFSPs, as well as two new strategies for real-time multiple-order order acceptance and scheduling for a Permutation Flow Shop. Section 4 provides an experimental study for static single-order and real-time multiple-order PFSPs. In Section 5, a simulation model has been presented for studying the influence of tardiness in accepting new orders. A case study on a Sanitaryware production system has been presented in Section 6. In the final section, conclusions are given.

In this section, the static single-order and the real-time multiple-order PFSPs are briefly defined.

In this problem, it is assumed that a single-order contains a set of finite jobs n that are to be processed in a finite set of m machines with the same processing sequence. The processing time pi, j
                         of job j (j = 1,2,3, … , n) on each machine i (i = 1,2,3, … , m) is known in advance. Here, π = (π
                        1, π
                        2, … , πn
                        ) is the permutation of n jobs and C(i,j) represents the completion time of job j on machine i. The competition time of the last job on the last machine (i.e., makespan) can be calculated as follows.

                           
                              (1)
                              
                                 
                                    Makespan
                                    ,
                                    
                                       C
                                       
                                          m
                                          a
                                          x
                                       
                                    
                                    (
                                    π
                                    )
                                    =
                                    C
                                    
                                       (
                                       m
                                       ,
                                       n
                                       )
                                    
                                 
                              
                           
                        
                     

So the objective is to identify a job sequence, π
                        * so that

                           
                              (2)
                              
                                 
                                    
                                       C
                                       
                                          m
                                          a
                                          x
                                       
                                    
                                    (
                                    
                                       π
                                       *
                                    
                                    )
                                    ≤
                                    
                                       C
                                       
                                          m
                                          a
                                          x
                                       
                                    
                                    
                                       (
                                       π
                                       )
                                    
                                    ∀
                                    π
                                    ∈
                                    Π
                                 
                              
                           
                        where, Π is the set of all feasible job sequences, and π
                        * is the best schedule achieved by the algorithm. C(m, n) is the completion time of the nth job in the mth machine.

The following assumptions are made for the single-order PFSPs.

                           
                              •
                              The processing time of each job on each machine is known well in advance.

Each machine can process only one job (of an order) at a time.

Each job should follow the same predefined processing sequence of machines.

No interruption of processing is allowed.

Inventory costs of work-in-process and finished goods are not considered.

Set up and transportation costs are negligible.

In practice, production occurs on a continuous basis and new orders are received while processing other orders on hand. However, in most cases, without prior knowledge new orders are placed by customers on a real-time multiple-order basis.

In defining Real-Time multiple-order PFSPs, the following assumptions are made.

                           
                              •
                              The order arrives randomly (no prior knowledge of arrival time).

Each order may contain multiple jobs (similar to a single-order PFSP).

The composition of each order is not known in advance.

The due date of each job is provided by the customer.

The manufacturer has the right to accept or reject any new order.

The completion of an accepted order, within the given due date, will have a positive impact on productivity.

An order in process cannot be interrupted.

Once an order is accepted, it cannot be later rejected.

There may be a financial benefit for early completion, and a penalty may be imposed for tardiness.

The order processing flow diagram for Real-Time multiple-order PFSPs is presented in Fig. 1. In it, orders from customers are received by the system. The management then decides whether to accept or reject the new order. If a new job is accepted, it must be scheduled while considering the current jobs of the order/orders in the system, shop capacity, and the due dates of all of the accepted orders waiting for processing. This means that some of the jobs of an order waiting for processing may be rescheduled. If the machines are available, an order may be processed immediately after being accepted. Otherwise the order waits in the queue according to the generated schedule. After the completion of each order, it is delivered to the appropriate customer. Alternatively, if a new order cannot be completed by meeting its due date, then it should be rejected. A rejected order leaves the system immediately.

The parameters and performance measures for real-time multiple-order PFSPs are as follows.

                           
                              
                                 h – index for an order


                                 i – index for a job in an order h
                              


                                 j – index for a particular machine


                                 
                                    
                                       p
                                       
                                          i
                                          j
                                       
                                       h
                                    
                                  – processing time of job i (of order h) on machine j
                              


                                 nh
                                  – number of jobs in order h
                              


                                 m – number of machines in the flow shop


                                 
                                    
                                       C
                                       
                                          m
                                          a
                                          x
                                       
                                       h
                                    
                                  – makespan for order h
                              


                                 
                                    
                                       C
                                       
                                          c
                                          o
                                          m
                                       
                                       h
                                    
                                  – completion time for order h
                              


                                 dh
                                  – customer specified due dates (or delivery time)


                                 Th
                                  – tardiness of order h
                              


                                 H – number of orders that arrive in one production shift


                                 
                                    
                                       S
                                       j
                                       h
                                    
                                  – the starting time of the first job of order h on machine j
                              


                                 
                                    
                                       F
                                       j
                                       h
                                    
                                  – the finishing time of the last job of order h on machine j
                              

The makespan of an individual order, h, can be determined as the makespan of an equivalent static single-order PSFP, which is 
                           
                              C
                              
                                 m
                                 a
                                 x
                              
                              h
                           
                        
                        . The completion time for that order, 
                           
                              C
                              
                                 c
                                 o
                                 m
                              
                              h
                           
                        
                        , can be expressed as

                           
                              (3)
                              
                                 
                                    
                                       C
                                       
                                          c
                                          o
                                          m
                                       
                                       h
                                    
                                    =
                                    
                                       S
                                       1
                                       h
                                    
                                    +
                                    
                                       C
                                       
                                          m
                                          a
                                          x
                                       
                                       h
                                    
                                 
                              
                           
                        where, the start time of the first job of the first order (start of production shift) is 
                           
                              
                                 S
                                 1
                                 1
                              
                              =
                              0
                           
                        
                        
                           
                              (4)
                              
                                 
                                    
                                       
                                       
                                       
                                          
                                             So
                                             
                                             the
                                             
                                             completion
                                             
                                             time
                                             
                                             for
                                             
                                             the
                                             
                                             first
                                             
                                             order
                                             
                                             is
                                             
                                             equal
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             
                                             to
                                             
                                             its
                                             
                                             makespan
                                             ,
                                             
                                                C
                                                
                                                   c
                                                   o
                                                   m
                                                
                                                1
                                             
                                             =
                                             
                                                C
                                                
                                                   m
                                                   a
                                                   x
                                                
                                                1
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The tardiness of an order is then:

                           
                              (5)
                              
                                 
                                    
                                       T
                                       h
                                    
                                    =
                                    
                                       C
                                       
                                          c
                                          o
                                          m
                                       
                                       h
                                    
                                    −
                                    −
                                    
                                       d
                                       h
                                    
                                    ,
                                    
                                    h
                                    =
                                    1
                                    ,
                                    2
                                    ,
                                    3
                                    ,
                                    …
                                    ,
                                    H
                                    
                                    and
                                    
                                    
                                       d
                                       h
                                    
                                    ≥
                                    0
                                 
                              
                           
                        
                        
                           
                              (6)
                              
                                 
                                    Order
                                    
                                    
                                    h
                                    
                                    
                                    
                                       is
                                       
                                       accepted
                                       
                                       only
                                       
                                       if
                                    
                                    
                                    
                                    
                                       T
                                       h
                                    
                                    ≤
                                    0
                                    ,
                                    
                                    
                                    
                                       or
                                       
                                       else
                                       
                                       it
                                       
                                       is
                                       
                                       rejected
                                    
                                 
                              
                           
                        
                     

In any machine, the (h+1)th order cannot be started until the hth order has been finished. In this case, the following condition must be satisfied.

                           
                              (7)
                              
                                 
                                    
                                       S
                                       j
                                       
                                          h
                                          +
                                          1
                                       
                                    
                                    ≥
                                    
                                       F
                                       j
                                       h
                                    
                                    
                                    ∀
                                    h
                                    ,
                                    j
                                 
                              
                           
                        
                     

The objective of the real-time multiple-order PSFP, is to maximize the number of accepted orders (in order to maximize productivity), for a given period of time, while satisfying the constraints described above.

Before we propose a solution approach for real-time multiple-order PFSPs, we will consider the solution approaches used for single-order PFSPs. Although heuristics and metaheuristics are both popular, metaheuristics have been found to be relatively better performing algorithms for single-order PSFPs. In this research, we first developed a Genetic Algorithm (GA) based Memetic Algorithm (MA) approach for solving single-order PFSPs with an objective of minimizing the makespan of a single-order. We later extended the algorithm for dealing with real-time multiple-order PFSPs. The extended algorithm helps to reduce the completion time of each order (with respect to the production capacity constraints and due dates) and increases the number of accepted orders (reduces the number of rejected orders).

GA is a popular stochastic global search algorithm for finding either optimal or near optimal solutions for complex optimization problems. GA starts with a set of initial solutions, known as its population, and the solutions are then altered using the search operators (such as crossover and mutation), until its stopping criteria are met. The individual solutions are represented what is known as a chromosome. The details of the chromosome, search operators, and parameters used for the GA in solving static PFSPs, are briefly discussed below.

In a GA, chromosomes can be represented by binary, integer or real numbers. For PFSP, using an integer representation of the job sequences representation is most popular. Traditionally, the initial population in GA is generated randomly. But in PFSP, random initialization may not help to achieve a quality solution within reasonable times. We have proposed to have certain non-random individuals in the initial population, where those individuals are generated by using the NEH heuristic and Johnson's algorithm. In the first case, some individuals are generated by randomly swapping two jobs from the NEH heuristic's solution. In the second case, because more than two machine flow shop problems can be divided into multiple two machine flow shop problems, and these problems can be optimally solved by Johnson's algorithm, a certain percentage of the initial population is generated using both this and the previous method. The rest of the individuals are randomly generated.

Traditional tournament selection is used to select parents from the selection pool. We also replaced parents directly with their offspring. In a heavily constrained combinatorial optimization problem, it is common to produce many duplicate individuals, which can cause stagnation in local optima. To solve this problem, in every generation, newly generated random individuals replace any duplicate ones. It is important to note that different sequences may have the same fitness value (Ruiz et al., 2006), so by duplication we strictly mean the same job sequence. Also, if the evaluation process stagnates into the same solution for some generations, a restart scheme (Rahman et al., 2013; Ruiz et al., 2006; Zobolas et al., 2009) has been implemented. For this, if the makespan stagnates for a certain number of generations, all members are classified into three sections, best 5 percent, middle 85 percent and worst 10 percent. The middle group is replaced by newly generated individuals through shift mutations of the top section. In this algorithm, an elitism strategy has been used to save and pass the fittest individuals from one generation to its next.

Similar Order Crossover (SJOX) (Ruiz et al., 2006) and shift mutation (Murata et al., 1996; Ruiz et al., 2006; Zobolas et al., 2009) have been selected as the reproduction operators, as they performed well in earlier experiments. In SJOX, the job sequence from each parent is inspected one by one. The same job in the same position from each parent is directly inserted into both offspring. Next, each offspring copies all of the other jobs from one of the parents up to a randomly chosen crossover point. For example offspring 1 inserts jobs directly from parent 1 and offspring 2 inserts jobs directly from parent 2. Finally, the missing jobs from each offspring are selected from the other parent and are inherited in the relative same job sequence of that parent. That is to say, offspring 1 inherits the missing job elements from offspring 2 and offspring 2 inherits the missing job elements from offspring 1. In shift mutation, a randomly selected job is inserted into a randomly selected position in the job sequence. Between these two points, each job is moved to its adjacent position in the job sequence.

To achieve a quality solution within a reasonable amount of time, it is common to integrate a local search method within a GA. In the current algorithm, we have applied three stage local search methods. They are insertion neighborhood, gap filling, and a job shifting process. The individual which is selected for local search, initially goes through the insertion neighborhood search process, then through the gap filling process and finally through job shifting.

                              
                                 •
                                 
                                    Insertion neighborhood search: In PFSPs, insertion neighborhood performs satisfactorily as a local search (Osman and Potts, 1989; Ruiz et al., 2006; Taillard, 1990). For it, each job permutation has (n − 1)2 neighbors. So it checks each pair position, and if a better sequence is found, it then replaces the current best sequence. The process continues until all of the jobs have been selected and evaluated.


                                    Gap filling: In PFSPs, no inter-job gap is allowed in the first machine. But due to precedence constraints, there may be some gaps on the rest of the machines. The job schedule can be improved if these gaps can be minimized or removed. From preliminary experiments, it has been observed that if in a job sequence an inter-job gap exists in the last machine, or the last couple of machines, the makespan of that sequence can often be improved by placing a job from the right of the gap location, into that gap. The process for this is: the total processing times for all jobs in the schedule is calculated and then the job which has the least total processing time is selected. The selected job is then placed in the gap. If such a movement improves the schedule then the new solution is accepted. If not, then the job whose total processing time is the second best in the schedule is tried. The trial is limited up to three times for each gap. After the gap identification, job selection and insertion, if the makespan improves then the new schedule is accepted.


                                    Job shifting: The makespan can often be minimized if the jobs with (a) longer processing time at the lower right-hand-side (last few machines) of the schedule, and (b) shorter processing time at the upper left-hand-side (first or first few machines) of the schedule, can be shifted from the right hand side to the left hand side in the schedule as much possible. To do this, the ratio of processing times (processing time in the last machine and the processing time in the first machine) for all of the jobs in the sequence is calculated. Then if any of the three last jobs have one of the three highest ratios, then those jobs are then placed as early as possible in the sequence.

In real-time multiple-order PFSPs, two important tasks are: (i) how to decide which orders are to be accepted or rejected and (ii) how to schedule the jobs in each order with respect to the available capacity. There have been a few studies where order acceptance/rejection decisions in multiple machine layouts (flow shop and job shop) have previously been considered. First, Nandi and Rogers (2004) proposed an order acceptance mechanism where an arriving order is accepted or rejected by comparing the profit of the current orders. Rogers and Nandi (2007) proposed an order acceptance/rejection rule that was based on the total workload (total processing time of each job in all machines), or the workload in the busiest machines. Moreira and Alves (2009) proposed order acceptance rules based on workload and negotiable due dates. After accepting an order, a scheduling was then generated by simple dispatching rules, namely least slack per remaining operations (S/OPN) (Nandi & Rogers, 2004; Rogers & Nandi, 2007), earliest due dates (EDD) (Moreira & Alves, 2009; Rogers & Nandi, 2007), and first come first serve rules (FCFS) (Moreira & Alves, 2009; Rogers & Nandi, 2007). In these papers, the order acceptance/rejection decisions and the scheduling decisions were made separately and sequentially. However, the overall system performance can be improved by integrating these two related problems. In this research, we first propose a heuristic based approach for the order acceptance/rejection decision. This approach is then integrated with the scheduling decisions. The integrated process thus selects a set of jobs that would be both feasible to process within the processing capacity, and that would do so by the customer specified due dates.

The order acceptance/rejection decision is made when an order arrives to the manufacturing system. The decision depends on the start time, available shop capacity within the time window, completion time, and the due date of each order. An arriving order will only be accepted if it can be processed and completed by its specified due date. So a trial schedule has to be generated to make the acceptance/rejection decision.

The algorithm for the order acceptance/rejection decision can be described as follows.

Assume O represents the total number of orders arriving in a production shift and 
                                 
                                    C
                                    
                                       c
                                       o
                                       m
                                    
                                    i
                                 
                               is the completion time (time to complete) of the ith order and di
                               is the due date of that order. Also assume that Ti
                               is the tardiness of that order. The completion time, 
                                 
                                    C
                                    
                                       c
                                       o
                                       m
                                    
                                    i
                                 
                              , is calculated based on the scheduling algorithm that will be discussed later in this paper.

                                 
                                    
                                       
                                       
                                          
                                                1. Initialize the Orders and the Production Shift starts.
                                          
                                          
                                                 Set order number, o = 1
                                          
                                          
                                                2. Repeat until (o = O)
                                          
                                          
                                                   A. Calculate 
                                                   
                                                      C
                                                      
                                                         c
                                                         o
                                                         m
                                                      
                                                      i
                                                   
                                                 for an order i.
                                          
                                          
                                                   B. Accept the order, if Ti
                                                 ≤ 0 (
                                                   
                                                      C
                                                      
                                                         c
                                                         o
                                                         m
                                                      
                                                      i
                                                   
                                                 <= di
                                                ).
                                          
                                          
                                                   C. Else Reject.
                                          
                                          
                                                   D. Set, o = o + 1.
                                          
                                          
                                                [End of the step 2 Loop].
                                          
                                          
                                             [End of the algorithm].
                                          
                                       
                                    
                                 
                              
                           

It may not be possible to process all new orders, immediately after their arrival, due to the machine availability constraints. If an order arrives at a time when at least the first machine is free, the order may start processing without interrupting the other orders being processed. If the first machine is not free when a new order arrives, or the order has to wait for processing on other machines, the scheduling or rescheduling of some or all of the accepted jobs (based on the conditions of that time) may be able to improve the system utilization. In this paper, we attempt to schedule or reschedule using two strategies, which are referred to as Right Shifting strategy and Real-Time multiple-order strategy.

In this approach, each accepted order is first considered as a single-order PFSP and the sequence of jobs is then generated by minimizing the makespan using a MA. Note that MA is a variant of GA that includes additional local search techniques. The accepted order is placed in the queue and it will start processing as soon as the first machine is free. In this case, the sequence of the jobs will follow the best job sequence of its single-order PFSP. Note that any number of accepted orders can be placed in the queue, and that each order contains a number of jobs. After processing a job of a particular order in one machine, it may need to wait for processing on the next machine, as the processing of an earlier order may not be completed by that time. That means, the job may need to shift to the right of the schedule and so may require more time than its single-order makespan for completion. To demonstrate the process, a simple example with a Gantt chart is shown in Fig. 2.

In this example, we consider a 3 machine flow shop with 2 orders (say orders M and N). These orders (consisting of 5 jobs each) have different arrival times and due dates. In Fig. 2, the Gantt chart in the upper left hand corner represents order M. The single-order Makespan for order M is 30 and the job sequence is 2-5-3-4-1. The due date for order M is 48. Assume that order N arrives after 20 units of time from the start of order M and has due date 58. The single-order makespan for order N is also 30 and the sequence of jobs is 2-5-3-4-1. The Gantt chart, in the upper right hand corner, of Fig. 2 represents order N. When order N arrives, order M is still in process. In the worst case scenario, order N can only start processing after completely processing order M. In that case, the sequence of jobs are taken from the best static schedule for order N, which gives the completion time of order N of 60 (=30 + 30) as shown in the lower left Gantt chart. Note that this is later than the delivery time. This scenario refers to the upper bound of the problem and will be referred to later. However, the overall processing time can be reduced by applying a simple strategy. For example, order N can start processing as soon as machine-1 is free from order M. However, when the first job of order N is completed on machine-1, machine-2 may not be available for processing order N. So the start time in machine-2 must be shifted to the right to generate a feasible schedule. Such shifting is known as the Right Shifting (RS) strategy. This process provides the completion time of 56 for order N (lower right corner in Fig. 2). This is basically a tighter upper bound than the worst case scenario discussed above. Further, as the given due date is 58, order N can now be accepted.

The algorithm with the Right Shifting (RS) strategy can be described as follows.

Let N be the total number of orders that arrive in a production shift. Also assume c is the current time of the clock and the due date of the nth order is dn
                              . The algorithm must then determine the single-order makespan of the nth order (Cmax
                              )
                                 n
                              . For this, the start time of that order is Sn
                              , the completion time is (Ccomp
                              )
                                 n
                              , and its tardiness, Tn
                              . It must also calculate ti
                              , which is the clock time when the first job of the ith order will start to be processed in the first machine. Also assume that Nacpt
                               is the number of accepted orders per production shift.

The algorithm starts at the beginning of the Production Shift, when the initial order arrives.

                                 
                                    
                                       
                                       
                                          
                                             I. Set n = 1, Nacpt
                                                 = 0, and clock t1
                                                 = 0
                                          
                                          
                                             II. Repeat until n = N (up to the end of the production shift).
                                          
                                          
                                                 A. update the clock, tn
                                                 = c, and Sn
                                                 = c
                                             
                                          
                                          
                                                 B. Use MA to find the single-order makespan for the schedule of the job set
                                          
                                          
                                                  of the current order.
                                          
                                          
                                                 C. Revise the makespan (Cmax
                                                )
                                                   n
                                                 of the order depending on the current
                                          
                                          
                                                  system state:
                                          
                                          
                                                   a. If the nth order overlaps with the (n − 1)th accepted order, right shift
                                          
                                          
                                                    the jobs of the nth order.
                                          
                                          
                                                   b. Else, the makespan (Cmax
                                                )
                                                   n
                                                 is unchanged.
                                          
                                          
                                                   c. Calculate the completion time,
                                          
                                          
                                                 D. With respect to completion time, (Ccomp
                                                )
                                                   n
                                                 = Sn
                                                 + (Cmax
                                                )
                                                   n
                                                
                                             
                                          
                                          
                                                   a. Calculate Tn,
                                                 as Tn
                                                 = (Ccomp
                                                )
                                                   n
                                                 − dn
                                                
                                             
                                          
                                          
                                                   b. Store the completion time, (Ccomp
                                                )
                                                   n, and the tardiness, Tn
                                                
                                             
                                          
                                          
                                                   c. If Tn
                                                 ≤ 0
                                          
                                          
                                                      i. Accept the order.
                                          
                                          
                                                      ii. Nacpt
                                                 = Nacpt
                                                 + 1
                                          
                                          
                                                   d. Else, Reject the order.
                                          
                                          
                                                 E. Set n = n + 1
                                          
                                          
                                             [End of step II Loop]
                                          
                                          
                                             IV. Store, Nacpt
                                                 (total number of accepted order in one production shift).
                                          
                                          
                                             [End of Algorithm]
                                          
                                       
                                    
                                 
                              
                           

In this approach, similarly to the RS strategy, the new order is started as soon as the first machine is available. However, instead of using the best static schedule of order N and shifting any job of an order to the right due to machine unavailability, the jobs of order N are rescheduled while considering the machine availability/unavailability constraints. As shown in Fig. 3, order M has a makespan of 30 and its sequence is 2-5-3-4-1. Order N is processed in the first machine immediately after order M is completed in that machine. However, the new sequence of jobs for order N is generated while taking into consideration that some machines are available for only certain time windows (in this case, there is a strict lower bound for the starting time). For convenience of explanation, we refer to this process as Real-Time multiple-order strategy. Note that the static schedule is generated assuming all machines are unconditionally available. As a result, the new sequence of jobs from RT may differ from the single-order schedule. After rescheduling with the RT strategy, the completion time for order N is 55 and the job sequence is 5-1-4-3-2. Note that in this case the completion time with RT is shorter than it was for RS.

The MA based Real-Time (RT) strategy can be described as follows.

Let the total number of orders that arrive in a production shift be N, and also assume that the number of accepted orders per production shift is Nacpt
                              . Assume that c is the current time of the clock, the start time of that order is Sn
                              , and that the due date of the nth order is dn
                              . The algorithm must then determine the makespan of the nth order (Cmax
                              )
                                 n
                              , the completion time (Ccomp
                              )
                                 n
                              , and its tardiness, Tn
                              . It must also calculate ti
                              , the clock time when the first job of the ith order will start to be processed in the first machine.

When the initial order arrives at the beginning of the Production Shift, the following algorithm starts.

                                 
                                    
                                       
                                       
                                          
                                             I. Set n = 1, Nacpt
                                                 = 0, and clock t1
                                                 = 0
                                          
                                          
                                             II. Repeat until n = N (up to the end of the production shift).
                                          
                                          
                                                 A. update the clock, tn
                                                 = c, and Sn
                                                 = c
                                             
                                          
                                          
                                                 B. Considering any machine availability/unavailability constraints, use MA
                                          
                                          
                                                  to generate a schedule for the job set of the current order.
                                          
                                          
                                                 C. Evaluate Tn
                                                 with respect to its completion time, (Ccomp
                                                )
                                                   n
                                                :
                                          
                                          
                                                   a. calculate the completion time, (Ccomp
                                                )
                                                   n
                                                 = Sn
                                                 + (Cmax
                                                )
                                                   n
                                                
                                             
                                          
                                          
                                                   b. calculate, Tn
                                                 = (Ccomp
                                                )
                                                   n
                                                 − dn
                                                
                                             
                                          
                                          
                                                   c. Save completion time, (Ccomp
                                                )
                                                   n
                                                 and tardiness, Tn
                                                
                                             
                                          
                                          
                                                   d. if Tn
                                                 ≤ 0.
                                          
                                          
                                                     i. Accept the order
                                          
                                          
                                                     ii. Nacpt
                                                 = Nacpt
                                                 + 1
                                          
                                          
                                                   e. Else, Reject the order.
                                          
                                          
                                                 D. Set n = n + 1
                                          
                                          
                                             [End of step II Loop]
                                          
                                          
                                             III. Save, Nacpt
                                                 (total number of accepted orders in one production shift).
                                          
                                          
                                             [End of Algorithm]
                                          
                                       
                                    
                                 
                              
                           

We first implemented a MA for solving static PFSPs. That algorithm was coded in C++ and ran on a personal computer with an Intel core i7, 2.80 GHz processor and 4 GB RAM. For the single-order PFSPs, 120 standard benchmark problems from Taillard (1993) were tested to judge the performance (by minimizing the makespan) of the MA, by analyzing those results.

The parameters were chosen based on our earlier study (Rahman et al., 2013). The population size was set to 100. The first member in each initial population was constructed by the NEH (Nawaz et al., 1983) algorithm, another 40 percent of the individuals were generated from the modified NEH (Nawaz et al., 1983) algorithm, 10 percent of the individuals were produced from the modified Johnson's Algorithm (Johnson, 1954), and the remaining individuals were generated randomly. The selection pool size was limited to 5. The crossover probability was 90 percent and mutation probability was 60 percent. If the solution did not improve for 10 generations, then the restart mechanism was applied to escape from the local optimum. The local search process was applied to 30 members in each generation. The results of 10 independent runs were recorded and analyzed.

@&#RESULTS AND DISCUSSIONS@&#

Our algorithm has been compared with four state-of-the art algorithms. These were: NEH (Nawaz et al., 1983) which is both simple and is one of the best constructive heuristics for static PFSPs. HGA_RMA (Ruiz et al., 2006) which is a powerful and robust hybrid GA for static PFSPs. NEGAVNS (Zobolas et al., 2009) that is another simple and robust metaheuristic algorithm which combines variable neighborhood search with GA, and lastly PSOVNS (Tasgetiren et al., 2007) is a Particle Swarm Optimization algorithm hybridized with variable neighborhood search. In Table 1, the average relative percentage of deviation (ARD) for each problem set for these algorithms has been tabulated.

In Table 1, the results obtained by MA are compared with the above mentioned algorithms. The results show the average percentage of difference between the algorithms and the so far determined best makespan. The problem size (number of jobs × number of machines) is shown in the first column. The next column represents the problem instances, where each problem consists of a set of 10 different instances. The next five columns represent the average ARD (average of 10 independent runs) for each algorithm (note that NEH (Nawaz et al., 1983) is an exception because it is a deterministic algorithm, so the result for a single run has been listed). From Table 1, it is clear that in most problems our algorithm performs better than the others, and in terms of overall average (reported in the bottom row), our algorithm shows the lowest deviation from the best known solutions. So we extended this algorithm for real-time multiple-order PFSPs, as discussed in the next section.

For experimentation with real-time multiple-order flow shop scenarios, there are no benchmark problems available in the literature. Instead for this purpose the orders were generated randomly. To do this each order contains three pieces of information: (i) a randomly selected job from a pool of problem instances, (ii) a random arrival time of the order, and (iii) a random due date of the order. We have chosen a pool of 40 static problem instances (Ta011–020, Ta041–050, Ta071–080, Ta091–100) from Taillard's Benchmark (Taillard, 1993). These all involve only ten machine problems. We have tested a total of 46 instances (40 instances for Scenario I, 4 instances for Scenario II and 2 instances for Scenario III). The problem scenarios are described later. To validate the solutions, we have derived an upper bound (UB) and a lower bound (LB) for the accepted orders. In deriving the UB and LB, we have made one basic assumption, that the shop may be left idle if there is no job to process. Depending on the assumptions, these bounds could be different. However, we have instead proposed a reasonable one for comparing the results.

Suppose an order l with the arrival time of Atl
                         has been accepted by some manufacturing firm. Also, suppose Ctl
                         is the completion time of order l. If (Atl − Ctl-
                        
                        1) > 0, the machines will be idle for the (Atl − Ctl
                         
                        − 
                        1) time period, which is between the completion time of order (l − 1) and the arrival time of order l. Let us define the positive time difference (TDl
                        ) as follows.

                           
                              (8)
                              
                                 
                                    T
                                    
                                       D
                                       l
                                    
                                    =
                                    
                                       {
                                       
                                          
                                             
                                                
                                                   A
                                                   
                                                      t
                                                      l
                                                   
                                                   −
                                                   C
                                                   
                                                      t
                                                      
                                                         l
                                                         −
                                                         1
                                                      
                                                   
                                                   ,
                                                
                                             
                                             
                                                
                                                   if
                                                   
                                                   (
                                                   A
                                                   
                                                      t
                                                      l
                                                   
                                                   −
                                                   C
                                                   
                                                      t
                                                      
                                                         l
                                                         −
                                                         1
                                                      
                                                   
                                                   )
                                                   >
                                                   0
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                   0
                                                   
                                                
                                             
                                             
                                                Otherwise
                                             
                                          
                                       
                                    
                                    
                                    
                                       for
                                       
                                       all
                                    
                                    
                                    
                                    l
                                    ≥
                                    2
                                 
                              
                           
                        
                     

So the upper bound of completing L accepted jobs can be expressed as follows, because that is the worst case scenario for completing all of the accepted orders.

                           
                              (9)
                              
                                 
                                    U
                                    B
                                    =
                                    
                                       ∑
                                       
                                          l
                                          =
                                          1
                                       
                                       L
                                    
                                    
                                       C
                                       m
                                       a
                                       
                                          x
                                          l
                                       
                                    
                                    +
                                    
                                       ∑
                                       
                                          l
                                          =
                                          2
                                       
                                       L
                                    
                                    
                                       T
                                       
                                          D
                                          l
                                       
                                    
                                 
                              
                           
                        Here, Cmaxl
                         is the makespan of the static PFSP problem for order l.

If (Atl − Ctl
                         
                        − 
                        1) < 0, order l may start processing as soon as machine-1 completes the order l − 1. Now, suppose (Atl − Ctl
                         
                        − 
                        1) < 0, and order l starts processing just after completing order l − 1, and that will require a Cmaxl
                         period of time for completing all the processes. Further assume that order l arrives just after completing order l − 1 on machine-1. This situation can be represented as the best case scenario for completing all of the accepted L orders. Now assume that 
                           
                              P
                              
                                 t
                                 1
                                 l
                              
                           
                         is the total processing duration required for order l on machine-1, and 
                           
                              C
                              P
                              
                                 t
                                 1
                                 l
                              
                           
                         is the time of completing order l on machine-1. Let us define the reduction in processing duration (RPTl
                        ) as follows.

                           
                              (10)
                              
                                 
                                    
                                       
                                          
                                             R
                                             P
                                             
                                                T
                                                l
                                             
                                          
                                       
                                       
                                          =
                                       
                                       
                                          
                                             {
                                             
                                                
                                                   
                                                      
                                                         C
                                                         m
                                                         a
                                                         
                                                            x
                                                            l
                                                         
                                                         −
                                                         P
                                                         
                                                            t
                                                            1
                                                            l
                                                         
                                                         ,
                                                      
                                                   
                                                   
                                                      
                                                         if
                                                         
                                                         
                                                            (
                                                            A
                                                            
                                                               t
                                                               l
                                                            
                                                            −
                                                            C
                                                            
                                                               t
                                                               
                                                                  l
                                                                  −
                                                                  1
                                                               
                                                            
                                                            )
                                                         
                                                         <
                                                         0
                                                         
                                                         and
                                                         
                                                         A
                                                         
                                                            t
                                                            l
                                                         
                                                         =
                                                         C
                                                         P
                                                         
                                                            t
                                                            1
                                                            l
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                      0
                                                   
                                                   
                                                      Otherwise
                                                   
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                for
                                                
                                                all
                                             
                                             
                                             
                                             l
                                          
                                       
                                       
                                          ≥
                                       
                                       
                                          2
                                       
                                    
                                 
                              
                           
                        
                     

So the best case scenario, which represents the lower bound of completing all L accepted orders, can be expressed as follows.

                           
                              (11)
                              
                                 
                                    L
                                    B
                                    =
                                    
                                       ∑
                                       
                                          l
                                          =
                                          1
                                       
                                       L
                                    
                                    
                                       C
                                       m
                                       a
                                       
                                          x
                                          l
                                       
                                    
                                    −
                                    
                                       ∑
                                       
                                          l
                                          =
                                          2
                                       
                                       L
                                    
                                    
                                       R
                                       P
                                       
                                          T
                                          1
                                          
                                             l
                                             −
                                             1
                                          
                                       
                                    
                                    +
                                    
                                       ∑
                                       
                                          l
                                          =
                                          2
                                       
                                       L
                                    
                                    
                                       T
                                       
                                          D
                                          l
                                       
                                    
                                 
                              
                           
                        
                     

The experimental study has been carried out using the proposed algorithm with both the RS and RT strategies. The algorithm was coded in C++ and was run with a personal computer with a core i7 processor and 4 GB RAM.

In the experimental study, we considered three different scenarios. In the first scenario, only one type (out of the 40 instances discussed earlier) of order was considered. In the second scenario, different types of orders were considered, where each order consisted of a fixed number of jobs (for example, n jobs). The third scenario considered different types of orders, with any number of jobs in each order. To demonstrate the applicability of the proposed algorithm, we considered 10 orders for Scenario I, and Scenario II and Scenario III both considered 25 orders.


                           Table 2 presents the simulation results, for 10 orders under Scenario I, using both the RS and RT strategies, where each order contains a set of 50 jobs (problem instance Ta046). The first column shows the order number. The arrival time and the due date for each order are generated randomly and they are shown in the next two columns. These two time parameters are generated based on the current clock time. The column headed with completion time represents the time to complete each order in all machines. The next column shows the tardiness or earliness for each order. A negative value of tardiness means that the order completes before the due date and the order is accepted. A positive value of tardiness represents a delay in completing the order. As a result the order is rejected.

The first order can start processing without any delay. The makespan of the first order will be the same as the single-order PFSP version of this problem instance for both the RS and RT strategies. The 2nd order arrives in the system when the first order is in process on the first machine. The total processing time for all jobs from the 1st order in the first machine is 2625 and the arriving time for the 2nd order is 360. So the 2nd order overlaps with the 1st order. The first machine starts processing the first job from the 2nd order at 2625. With the RS strategy, the completion time for the 2nd order is 5740. Whereas with the RT strategy, the completion time for the 2nd order is 5718. So the completion times for the 2nd order, with RT (rescheduling the sequence) gives 22 units of improved result over RS (schedule is shifted to the right). The 4th and 5th orders arrive in the shop when all their previous orders have finished processing by the machines. So there is no overlapping for the 4th and the 5th orders and so these orders can be considered as static PFSPs. However there is overlapping between the 5th and 6th orders in the first machine. In this situation, the completion time for the 6th order improves by 30 units of time by RT over RS. Similar situations arise for the 7th, 8th, 9th and 10th orders (that arrive in the system when their previous orders are still in process by the first machine).

It is important to note, that out of 10 consecutive orders, RS allows the acceptance of 6 orders, whereas the MA based RT is able to accept all the orders. This is because with the RS strategy, overlapped orders block the overall capacity for a longer period, as their completion time is more than with the RT strategy. When multiple orders arrive in the shop within a short time interval, like the 2nd, 3rd, 7th, 8th, 9th and 10th orders; RT is more effective than RS. The simulation results for Scenario II (mixed order with the same order sizes) and Scenario III (mixed order with different order sizes) are presented in Appendix A.

The effectiveness of each method (RS or RT) can be represented by the following equations:
                           
                           
                           
                              
                                 (12)
                                 
                                    
                                       
                                          Average
                                          
                                          deviation
                                          
                                          from
                                          
                                          the
                                          
                                          UB
                                       
                                       ,
                                       
                                          D
                                          U
                                       
                                       =
                                       
                                          [
                                          
                                             
                                                ∑
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                
                                                   N
                                                   s
                                                
                                             
                                             
                                                (
                                                
                                                   
                                                      U
                                                      B
                                                      i
                                                      −
                                                      R
                                                      i
                                                   
                                                   
                                                      R
                                                      i
                                                   
                                                
                                                )
                                             
                                          
                                          ]
                                       
                                       /
                                       
                                          N
                                          S
                                       
                                    
                                 
                              
                           
                           
                              
                                 (13)
                                 
                                    
                                       
                                          Average
                                          
                                          deviation
                                          
                                          from
                                          
                                          the
                                          
                                          LB
                                       
                                       ,
                                       
                                          D
                                          L
                                       
                                       =
                                       
                                          [
                                          
                                             
                                                ∑
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                
                                                   N
                                                   s
                                                
                                             
                                             
                                                (
                                                
                                                   
                                                      R
                                                      i
                                                      −
                                                      L
                                                      B
                                                      i
                                                   
                                                   
                                                      L
                                                      B
                                                      i
                                                   
                                                
                                                )
                                             
                                          
                                          ]
                                       
                                       /
                                       
                                          N
                                          S
                                       
                                    
                                 
                              
                           where Ri is the makespan of the ith accepted order achieved by MA based RS or RT. NS
                            is the total number of accepted orders by the particular technique (as the number of accepted orders may vary for both of the strategies).


                           Table 3 represents a summary comparison between RS and RT, where the same types of orders arrive at the shop with random inter-arrival times. The first column of each table represents the number of jobs in each order. The columns headed with DU
                            show the average improvement from the worst case (i.e. deviation from the UB) for 10 different problem instances after applying RS and RT. The bigger values mean more improvements. The following columns represent the deviation from the LB i.e. if the processing times are overlapping, how quickly the orders can be processed by the machines. Even though in the LB calculation we ignored the violation of resource availability constraints i.e. it is not possible to start an order before that time. From all the results, it is clear that in almost all cases RT has better solutions (bigger values in terms of DU
                            and smaller values in terms of DL
                           ). The last two columns represent the number of accepted orders by the RS or RT strategies. For each problem instance, 10 orders arrive with different inter-arrival times and due dates. For most of the cases, RT allows the same or greater numbers of orders to be accepted in comparison to the RS strategy. The detailed results of each problem instance are presented in Appendix B.


                           Tables 4 and 5 illustrate a comparison between RS and RT for Mixed orders with the same number of jobs in each order (Table A.1 from Appendix A) and different numbers of jobs in each order (Table A.2 from Appendix A). The table representations are the same as for the tables described above. Each production shift contains 25 orders with different due dates (delivery) and inter-arrival times. In Table 5, a comparison between RS and RT is shown with respect to simulation results for two independent problem instances, namely cases 1 and 2. The tables also show the better performance of RT over RS.

In the previous two sections, we assumed that an order will be accepted if the facility has the capacity to process it within the customer specified delivery time. In this section, we have relaxed this condition and examined the effect of accepting tardy orders. To make this concept useful in practice, we have imposed a penalty cost for tardiness that is expressed as cost per unit tardiness time per order. Such a relaxation may allow us to accommodate more orders that may improve the overall financial performance of the company. In fact, it will make a compromise between idle capacity utilization and cost of tardiness for the company. In a similar fashion, depending on the customers’ desire, we can consider an earliness benefit if an order is completed ahead of its due date.

For experimentation, we use different level of tardiness and examine its effect on revenue generation. It also helps to find the appropriate level of tardiness for order acceptance. In this research, we define the level of tardiness as the additional time (= (δ
                     *
                     
                        
                           C
                           
                              m
                              a
                              x
                           
                           h
                        
                     )) required to complete an order. A high value of δ will incur a higher penalty cost, and a small value of δ may force some of the tardy orders to be rejected. So a question arises of ‘what is the appropriate value of δ that would maximize the overall profit of the company’? To answer this question, in this research a simulation model has been developed. The simulation model is presented below.

In this section, a simulation model has been developed to analyze the effect of δ on profit (or revenue) of the shop floor. In the model, an order h is accepted if it is completed within the extended due date. The extended due date is expressed as follows.

                           
                              (14)
                              
                                 
                                    
                                       d
                                       h
                                       ′
                                    
                                    =
                                    
                                       d
                                       h
                                    
                                    +
                                    
                                       (
                                       δ
                                       *
                                       
                                          C
                                          
                                             m
                                             a
                                             x
                                          
                                          h
                                       
                                       )
                                    
                                 
                              
                           
                        
                     

Here, dh
                         is the customer requested due date and d'
                           h
                         is the extended due date. So Eq. (5) can now be revised as follows.

                           
                              (15)
                              
                                 
                                    
                                       T
                                       h
                                       ′
                                    
                                    =
                                    
                                       C
                                       
                                          c
                                          o
                                          m
                                       
                                       h
                                    
                                    −
                                    −
                                    
                                       d
                                       h
                                       ′
                                    
                                    ,
                                    
                                    h
                                    =
                                    1
                                    ,
                                    2
                                    ,
                                    3
                                    ,
                                    …
                                    ,
                                    
                                    H
                                    
                                    and
                                    
                                    
                                       d
                                       h
                                    
                                    ≥
                                    0
                                    ,
                                    
                                    
                                       d
                                       h
                                       ′
                                    
                                    ≥
                                    0
                                 
                              
                           
                        
                     

Here, we assumed that if an order is processed earlier than its due date, that there will be an earliness benefit for that order of, EBh
                         = ebh
                         * Th
                        , where, ebh
                         is the earliness benefit per unit time per order. On the other hand, if an order is accepted that uses the extended due date, tardiness cost may be imposed on order. That cost will be, TCh
                         = tch
                         * Th
                        , where, tch
                         is the tardiness cost per unit time per order. As (δ * dh
                        ) is the hypothetical duration over the actual due date, so the tardiness penalty will actually be imposed on the positive difference between 
                           
                              C
                              
                                 c
                                 o
                                 m
                              
                              h
                           
                         and the customer specified due date, dh
                        . Under this situation, profit (or loss) earned by the company for a specific order can be calculated as follows, Ph
                         (in $) = SPh
                         + EBh
                         − TCh
                         − OLh
                        . Here, SPh
                         is the selling price of an order and OLh
                         is the opportunity loss cost on an order h.

Profit per order equals the financial gain from an order, plus the financial benefit earned from that order, minus the tardiness cost for any delay, minus the opportunity loss cost. The opportunity loss cost imposes more pressure to accept more orders, by increasing the value of δ, especially for the scenarios of lower tardiness cost.

Finally, the total profit earned from a particular production shift can be expressed as

                           
                              (16)
                              
                                 
                                    P
                                    =
                                    
                                       ∑
                                       
                                          h
                                          =
                                          1
                                       
                                       H
                                    
                                    
                                       P
                                       h
                                    
                                 
                              
                           
                        
                     

In this section, the modified Real Time (RT) strategy is presented. In the RT strategy, an order is accepted if it can be completed on or before the extended due date. The algorithm is described as follows.

At the beginning of the Production Shift, suppose the initial order arrives and the following algorithm starts.

                           
                              
                                 
                                 
                                    
                                       I. Set n = 1, Nacpt
                                           = 0, and clock t1
                                          =0
                                    
                                    
                                       II. Repeat until n = N (up to the end of the production shift).
                                    
                                    
                                           A. update the clock, tn
                                           = c, and Sn
                                           = c
                                       
                                    
                                    
                                           B. Considering any machine availability/unavailability constraints, use MA
                                    
                                    
                                            to generate a schedule for the job set of the current order.
                                    
                                    
                                           C. Evaluate Tn
                                           with respect to its completion time, (Ccomp
                                          )
                                             n
                                          :
                                    
                                    
                                             a. calculate the completion time, (Ccomp
                                          )
                                             n
                                           = Sn
                                           + (Cmax
                                          )
                                             n
                                          
                                       
                                    
                                    
                                             b. calculate, Tn
                                           = (Ccomp
                                          )
                                             n
                                           − dn
                                          
                                       
                                    
                                    
                                             c. Save completion time, (Ccomp
                                          )
                                             n
                                           and tardiness, Tn
                                          
                                       
                                    
                                    
                                             d. If Tn
                                           ≤ 0.
                                    
                                    
                                               i. Accept the order
                                    
                                    
                                               ii. Nacpt
                                          = Nacpt
                                           + 1
                                    
                                    
                                               iii. Calculate the Profit, Pn
                                          .
                                    
                                    
                                             f. Else if T’n
                                           ≤ 0.
                                    
                                    
                                               i. Accept the order
                                    
                                    
                                               ii. Nacpt
                                           = Nacpt
                                           + 1
                                    
                                    
                                               iii. Calculate the Profit (or loss), Pn
                                          .
                                    
                                    
                                             e. Else, Reject the order and calculate the opportunity loss cost, OLn
                                          .
                                    
                                    
                                           D. Set n = n + 1
                                    
                                    
                                       [End of step II Loop]
                                    
                                    
                                       III. Calculate and save P (total profit in one production shift) (by Eq. (16)).
                                    
                                    
                                       [End of Algorithm]
                                    
                                 
                              
                           
                        
                     

The simulation model was coded in C++ and was run on the same environment that was stated in Section 4. We have run the simulation for 100 orders with eleven different δ (from 0 to 0.50 with an increment of 0.05). Note that, when the value of δ equals 0, the approach is the same as the RT approach described in Section 3.2.2.1. For the experiments, we have chosen three 50 jobs × 10 machine problem instances, Ta41, Ta45, and Ta50, from Taillard (1993) under Scenario I. The inter-arrival times and due dates for 300 orders (10 instances and 10 orders per production shift for each problem instance) were generated randomly. To find the overall financial gain i.e. profit (or loss), all costs and revenue figures were randomly generated, where sales were within [500, 2000], earliness benefit and tardiness cost were within [0, 1], and opportunity loss cost was within [100, 500]. All sales, revenue and cost figures are in dollars ($).


                        Table 6
                         shows the number of orders accepted (with and without penalty) and rejected for problem instance Ta45. The table starts with a column that shows the different values of δ. The column headed with ‘accepted without penalty’ shows that out of the 100 orders (from 10 instances), the total number of accepted orders which were completed within their due dates. The following column presents the total number of orders that were accepted with an extended due date. The final column shows the number of rejected orders. From the results, it is clear that the number of accepted orders decreases and the number of accepted with penalty increases as δ increases. The reason for this is that with the increase of δ, the value of extended due date per order increases and the shop then has a better chance to accept more orders. Moreover, if an order cannot be accepted with its original due date, but can be accepted with an extended due date, then it will occupy more capacity, which forces other orders that comes later to be accepted, not with their original due date but with an extended due date.

A plot with the average total profit with respect to different values of δ is presented in Fig. 4
                        . The average value of total profit is calculated using Eq. (17).

                           
                              (17)
                              
                                 
                                    
                                       Average
                                       
                                       total
                                       
                                       profit
                                    
                                    ,
                                    A
                                    P
                                    =
                                    
                                       
                                          
                                             ∑
                                             
                                                i
                                                n
                                                t
                                                =
                                                1
                                             
                                             
                                                i
                                                n
                                                s
                                                =
                                                I
                                             
                                          
                                          P
                                       
                                       I
                                    
                                 
                              
                           
                        
                     

Where, I= number of instances (here, I =10)

Total profit per production each production shift, P is calculated using Eq. (16).

In Fig. 4 consider the Ta045 case. At δ = 0, single value for average total profit are shown. Apart from δ = 0, the other values of δ show the average total profit of the modified RT strategies. From the trend of line, it can be seen that at δ = 0.05 (or 5 percent increment of the due dates of an order, if it is tardy), the average total profit of modified RT approach is maximum. However, the total profit gradually decreases with the increase of δ, and after a certain limit (after δ = 0.30), the values are negative. The reason for this is that if an order with a small increment of extended due dates is accepted, and if its tardiness cost is small in comparison to its sales value, then it can contribute to the total profit of the company. On the other hand, if the value of δ increases, the possibilities of accepting an order increases, even it is tardy and for such orders, the tardiness cost also increases. Therefore, an order accepted with an extended due date may have a higher profit value over its sales value, the company will face a loss on producing such order. Table 6 shows, that as more orders are accepted with extended due dates or penalty, so the total profit per production run decreases with the increase of δ, and after a certain level, the total profit becomes negative.

From the above experimental analysis, it can be seen that with the RT strategy using δ = 0.05, the company can maximize the revenue in its flow shop business. The same experimental analysis for problem instances Ta041 and Ta050 also gives with the same findings.

In this section, a case study is presented that is based on a Sanitaryware production system which is located in Dhaka, Bangladesh. In the system, the order acceptance and scheduling problem is time sensitive and complex, as the decision making depends on real-time order arrival, customer specified due dates, number of products per order (here each product refers to a job), and capacity constraints. As the problem is very much similar to the PFSPs considered in this paper, and we have investigated the production line problem using our proposed RT approach. The inter-arrival times, due dates, and processing times of each order were obtained from the company's database.

The production flow diagram is shown in Fig. C.1 (Appendix C). The production process can be divided into a series of 10 stages or operations (from jaw crusher to packaging). To demonstrate the performance of the proposed algorithms, we have experimented with 10 order problems under Scenario I.


                     Table 7 shows the comparison between the RS and RT strategies under Scenario I, where each order consists of 50 products or jobs, and Table C.1 (Appendix C) shows the composition of each order. Currently, the company does not use any scientific approach, but uses an ad hoc approach that is similar to RS. In addition, we cannot get any actual figures of the existing approach due to business confidentiality.

The first column presents the order number. The second and third columns show the order arrival time and due dates for each order respectively. The column headed with completion time shows the time to complete each order under the current production capacity. The following column shows each order's tardiness or earliness. A negative value of tardiness (or positive value of earliness) means that the order is accepted with the available production capacity, and that the order can be finished before its due date. Otherwise the order is tardy and rejected. Note that in this study, the company only accepts an order if it is finished on or before its delivery date. So there is no tardiness cost. The following column is headed with profit, and shows the profit/loss gained from each order, where a positive value means profit and a negative value means loss. For the convenience of readers, all of the production costs figures used for the current study have been shown in Table C.2 (Appendix C). In the average computation time per order column, the average time required to compute the order acceptance and scheduling decisions for each order has been presented. The computational time has been measured on the computational environment described in Section 4.1.

At the beginning of production, the 1st order arrives into the shop and starts to process on machine-1 instantly. As the overall capacity is available instantly, the makespan and completion time (which is 2889) of this order, is the same. At time 141, the 2nd order arrives into the system. Meanwhile machine-1, is processing products on machine 1 as the total time to complete all products from order 1 on machine 1 is 2500. So, after 2500 units of time, the first product from the 2nd order starts to process on machine-1. If the 2nd order is scheduled with the RS strategy, the completion time of the 2nd order is 5492 and the profit gain is $1157.74. On the other hand, if the same order is scheduled with the RT strategy, it completes at 5434 and the company earns $1281.86 of profit. The 3rd order arrives in the system, while the 1st and 2nd order orders are still in process. With both the RS and RT strategies, the 3rd and 4th orders are rejected, as with the current production capacity, they cannot be completed on or before their due dates. So the opportunity loss cost is imposed on the company for rejecting these orders. Note that the 5th order is rejected, if it is scheduled by the RS strategy, but it is accepted by scheduling by the RT strategy. With both the RS and RT strategies, the 6th and 7th orders are rejected.

Note that the 8th order arrives in the shop after the 2nd order (5th order for the RT strategy) is completed. With both RS and RT strategies, the 9th order is rejected. Finally a similar situation arises for the final 10th order of the production shift (it arrives in the system when the previously accepted orders are in process by the system). The final rows represent the total profit earned from this particular production shift, and the profit value shows that the proposed RT approach ensures higher profit gain than the RS strategy. The computational time columns show that this occurs within a reasonable computational time.

@&#CONCLUSION@&#

In this research, we have discussed some of the research issues that occur with real-time order acceptance and scheduling problems in a permutation flow shop environment. The problem involves multiple decision strategies, such as whether an arriving order will be accepted, how the accepted order will be scheduled with other existing orders, and how the jobs within each order will be scheduled. As order arrival is a continuous process in any real world production facility, these integrated decisions must be made, repeatedly on a real time basis, after the arrival of a new order. In the literature, we have not found any paper that has considered such a complex decision process in such a production environment. To deal with this problem, we have proposed a procedure in this paper that involves a heuristic and a memetic algorithm. To test the performance of our approach, we have generated a set of benchmark problems on real-time multiple-order PFSPs, and conducted experimental studies with them. From the experimental studies, for a given duration, it is clear that our approach improves the performance of the flow shop business by maximizing the number of orders, and minimizing the combined makespan of accepted orders, as compared to the traditional Right Shifting strategy. Using this approach, flow shop businesses can appropriately accept the orders they can process within their capacity, and so maximize their benefits.

In this research, we have also developed a simulation model and extended the proposed approaches to find the best approach for maximizing revenue. The simulation model basically suggests a way to minimize financial risk in dynamic shop floor environments. Finally, the proposed approach has been applied to solve a real time multiple order PFSP, which was inspired from a practical Sanitaryware production problem. The simulation results shows that the proposed approach is capable of improving the revenue return of the Sanitaryware production company, as compared to existing practices.

The research carried out in this paper opens up opportunities to study and improve different methodologies for solving different make to order production problems. First, in this research we considered a dynamic order arrival and scheduling problem in a flow shop environment while assuming that there was no disturbance of any kind. However, in practice, the production system may be interrupted for many different reasons, such as machine breakdown, shortage of materials, and delay in supply. Second, the current studies can be linked with supply chains, where order acceptance and production scheduling decisions are integrated with supply chain decisions. Besides considering in house production floor scheduling decisions, the proposed decision making approaches can be integrated with out sourcing or capacity expansion decisions. Third, the proposed algorithms can be extended to study other PFSPs variants, like flexible flowshop, limited buffer, blocking, or re-entrant flowshop scheduling problems. Finally, the algorithms have been developed to solve single objective permutation flowshop problems. However, often problems require considering more than one objective, such as minimizing makespan and also optimizing earliness costs. In our future research, we intend to extend our algorithm to deal with such problems of interest.
                     
                     
                  

@&#ACKNOWLEDGMENTS@&#

This research is funded by UNSW TFR, UCPRS and research publication fellowship.


                     Table A.1 represents a sample production shift with different orders (20 jobs in each order). In this production shift, 25 orders arrive with different inter-arrival times and due dates. Even though the order size is the same (20 jobs in each order) for each order, orders may occupy different job sets. For example, the first two orders are the same as the Ta016 job set, the third order is the same as Ta012, the fourth order is the same as the Ta011 problem set etc.


                     Table A.2 represents a sample production shift with different orders. In this production shift, 25 orders arrive with different inter-arrival times and due dates. In the production shift, not only are the order sizes different, but also the orders may occupy different job sets. For example, the first order is the same as the Ta047 job set (50 jobs), the second order is the same as Ta014 (20 jobs), the sixth order is the same as Ta092 (200 jobs), the eighth order is the same as Ta071(100 jobs) etc.


                     Tables B.1–B.4
                     
                      give the results for the cases of the same types of order. They are summarized in Table 3 of the main section of the paper.


                     
                     
                  

@&#REFERENCES@&#

