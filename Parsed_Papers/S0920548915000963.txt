@&#MAIN-TITLE@&#Security-aware Business Process as a Service by hiding provenance

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We address the security issues that arise when outsourcing business processes in the cloud as BPaaS (Business Process as a Service).


                        
                        
                           
                           We formally define the concept of sharing and reusing process fragments for faster and easier development of process-based applications.


                        
                        
                           
                           We provide an efficient anonymization-based protocol to preserve the process fragment provenance, and to guarantee the end-to-end availability of process-based applications.


                        
                        
                           
                           We evaluate the performance of the proposed approach on real datasets.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

BPaaS

Cloud computing

Process composition

Process reuse

Security by design

@&#ABSTRACT@&#


               
               
                  We adress in this paper the security issues that arise when outsourcing business processes in the BPaaS (Business Process as a Service). In particular when sharing and reusing process fragments coming from different organizations for faster and easier development of process-based applications (PBA). The goal is twofold, to preserve the process fragment provenance, i.e., the companies's business activities which provide the reused fragments in order to avoid the competition, and to guarantee the end-to-end availability of PBA to fragment's consumers. We formally define the problem, and offer an efficient anonymization-based protocol. Experiments have been conducted to show the effectiveness of the proposed solution.
               
            

@&#INTRODUCTION@&#

Cloud services have been extensively studied in recent years and two categories were proposed: application services and utility computing services [1]. Application services, i.e., Software as a Service (SaaS), offer complete and pre-designed services, where end-users access with authentication protocols and use services maintained by cloud providers. Utility computing services, i.e., Infrastructure as a Service (IaaS) and Platform as a Service (PaaS), provide fundamental computing resources that are used to develop, test, deploy and monitor process-based application (PBA). Therefore, hosting business processes in specialized cloud providers may lead to lower costs, by sharing hardware and software resources, as well as administrative staff, and enables pay-as-you-go pricing model [2].

The cloud model also gives the opportunity for organizations to compose and re-use cloud services from a variety of cloud providers to create what's known as cloud syndication [3–5]. Cloud syndications at the SaaS level are termed Business Process as a Service (BPaaS), which, according to business analysts, is the next step forward in the evolution of cloud computing [6]. The BPaaS model considers a multi-party cloud system, which consists of multiple cloud platforms and cloud's users. Thus, we define each cloud platform as being a process curator that hosts a set of business processes and maintains them long-term such that they are available for execution.

Currently, organizations outsource more and more business processes to process curators in order to take benefits from the cloud business model, and also to share data and services [7]. Each complex business process deployed can be broken down into smaller (and more manageable) process fragments suitable for re-use to accelerate future process modeling [8–13]. Indeed, a process fragment represents a self-contained and functionally complete artifact for process design and execution. These organizations are therefore defined as process providers.

As a result, process curators built over time and maintain large repositories of process fragments [14]. Such repositories may contain hundreds or even thousands of process fragments (e.g., Amazon.com, schema.org, etc.). These process fragments can be extracted, published and shared through libraries, allowing the design of new PBAs by selection [15–18]. The development of new PBAs supports to reduce not only the cost of designing new business processes but also to enhance homogeneity between them. In this paper, we use the term process consumer to refer to such third organization that re-uses process fragments provided by process curators in the cloud.

The main problem that cloud computing paradigm implicitly contains is that secure outsourcing of sensitive as well as business-critical data and processes [19]. In fact, there are several security risk issues when reusing process fragments in the BPaaS delivery model. The first issue is how to ensure the end-to-end availability of PBAs? Existing secure process composition mechanisms assume a fully trusted process provider, which is not always true, and focus on announced Service-Level Agreement (SLA) availability rates of process fragments.

However, in reality, a process provider may suspend the outsourcing of a given service including process fragment. Consequently, all PBAs that re-use this cloud service will be impacted and abnormalities on their executions will occur. One possible solution consists in keeping a copy of each process fragment by the process curator as long as it is needed. However, this solution requires that the process provider should let available its own process fragments after unsubscribing. In some cases that may well be true, but very often that is not the case.

A second key problem in outsourcing is that the hosting, the execution and the re-use of process fragments are considered as sensitive that may contain business secrets or provide personal information (e.g., SSN). Consequently, fragment's compositions may expose process providers' business activities, as well as process consumers and their end-users to confidentiality issues. Thereby, an adversary may be able to:
                        
                           1.
                           Reveal sensitive information about the process provider activities, such as details of how certain process fragments are composed or the list of process fragments provided by an organization;

Infer connections between end-users and a process provider by analyzing intermediate data, like input/output values produced by a process fragment, thus obtain and/or modify confidential and sensitive information by using SQL injection attacks [20].

Both are considered to be unacceptable breaches of confidentiality.

Existing solutions characterize security as a set of attributes, where process providers and process consumers define their security constraints in terms of these attributes (e.g., Goettelmann et al. [21]). Thus, PBA's security is ensured if the security constraints of each fragment reused satisfy security constraints of the process consumer. But as the first issue, these mechanisms assume a fully trusted process provider and consumer, and are used to prevent only external attacks. In the case where an attacker is one of parts of cloud system, these mechanisms are not efficient.

In our previous works [22,23], we proposed a privacy agreement model that spells out a set of requirements related to consumer's privacy rights in terms of how Web Service provider must handle privacy information as a bilateral SLA. Moreover, we provided a private data usage flow model to monitor at run time the compliance of requirements defined in the privacy agreement [24,25]. However, such approaches are not handling privacy preservation and do not deal with the availability of Web Services involved in a fragment of a business process and in a setting of the Cloud. There have been some works on security-aware compositions [26–28]. Unfortunately, these works do not consider service provenance and focus on access control, data integration and provenance.

This paper is an extension of our earlier works [29,30] in which we formalized the reuse of process fragments in the cloud, and introduced the notion of anonymous process fragments for privacy-preserving business activities of organizations. In this paper, we investigate how much we can secure PBAs while multi-organizations share a BPaaS in a multi-party cloud system and we provide a positive answer to the above questions. For that purpose, we propose an anonymization-based approach providing anonymous views on BPaaS to preserve the confidentiality of multi-tenant fragments, and to reduce the cost associated with the approach. At the same time, we enrich the approach with a notion of diverse view to guarantee the end-to-end availability of PBAs, and to reduce the cost associated with the approach. We make the following contributions:
                        
                           1.
                           Anonymous and diverse views: In order to hide the activity of a process provider sharing some of its process fragments with other organizations, we define a new notion of views on BPaaS handling the instances of shared and reused process fragments. Moreover, to ensure the availability of process fragments for building new PBAs, we also introduce the notion of diverse views handling the diversity of process fragment provenances.

Confidentiality and availability costs: To quantify the proposed framework's security, we use two types of cost: one for confidentiality, and another for the availability of process fragments in the BPaaS.

Secure Business Process as a Service: To take into account the aforementioned goals, the proposed secure framework is based on a multi-objective optimization approach.

Evaluation on real datasets: To validate the effectiveness and evaluate the performance of the proposed protocol, we have applied it to the QWS datasets [31,32], then studied the impact on the quality of the BPaaS views. Experiments permitted us to set parameter values of the protocol.

The remainder of the paper is structured as follows: Section 2 describes the problem statement through motivating examples. Section 3 gives some preliminaries on BPaaS and process fragment provenance for faster and easier design of process-based applications. After defining the security model for the BPaaS in Section 4, Section 5 presents the details of our protocol, including the anonymous and diverse views on BPaaS model for securing process fragment reuse. Experiment results of the proposed protocol and an optimization are presented in Section 6. Section 7 discusses related works and Section 8 concludes the paper.

We start by setting out examples that motivate the research presented in the paper. We present scenarios for reusing process fragments, that cannot resist several possible attacks. We assume the existence of two kinds of adversaries: curious and malicious. Curious adversaries attempt to learn or make use of information from the system but do not affect system resources (i.e., make passive attack). However, malicious adversaries attempt to alter system resources or affect their operations (i.e., make active attack). These scenarios infer availability and confidentiality issues.

In the first scenario, we allow for the possibility of an adversary using the BPaaS to outsource new business processes as process provider. Accordingly, an adversary may enrich the repository with new process fragments that can be reused by other organizations. We also allow for the possibility of an adversary to remove its own process fragments previously deployed on the BPaaS. Thereby, the availability of the adversary's process fragments will not be assured. The following example illustrates the availability issue.
                           Example 1
                           Let us consider an Employer Business Process EBP used by a Human Resources Department (HRD) to manage employee accidents at work. EBP is a simple sequential pattern, it means an activity is enabled after the completion of another one. So, EBP can be represented as a business graph with a set of activities as depicted in Fig. 1
                              . Activities are listed in the following:
                                 
                                    1.
                                    Check insurance number (CIN).

Create new accident declaration (CNA).

Check personal information (CPI).

Validate employee declaration (VED).

Make insurance declaration (MID).

Make appointment with insurance (MAI).

Note that compositions in the application level (SaaS) are similar to the Web service compositions in SOC (Service-Oriented Computing). Thus, CIN, MID and MAI are considered as cross-organization activities and require service invocations and data exchanges with insurance company through application programming interface (API).

The main problem in this scenario is, an adversary may provide a set of process fragments in the BPaaS as a process provider. Suppose MAI is one of these process fragments. As depicted in Fig. 2
                        , MAI is split up into two roles: the sender (entity A) and the receiver (entity B). Sometime later, Bob, the process designer of HRD, uses the BPaaS for a faster design of EBP by selecting MAI. So, the end-to-end availability of EBP requires the availability of all reused process fragments including MAI. Thus, if the process curator or the (malicious) adversary chooses to remove MAI from the BPaaS repository, then EBP will become unavailable. This example perfectly illustrates the availability issue when reusing process fragments provided by a malicious process provider.

In a multi-party cloud system, an adversary can use the BPaaS as a process consumer to design new PBAs by selection. Therefore, the adversary will have access to all process fragments available in the BPaaS' repository. Fig. 3
                         depicts the confidentiality issue when reusing process fragments.
                           Example 2
                           Let us consider the same PBA of Example 1 where EBP is used by HRD to manage employee accidents at work. In the novel scenario, we assume that Bob was the first using the BPaaS to outsource EBP. The fact to outsource a new business process enabled Bob to add a set of process fragments, including CPI, to the process repository.

Sometime later, an adversary may re-use CPI to design a new PBA by selection (e.g., PACS
                                 1
                              
                              
                                 1
                                 PACS (Picture Archiving and Communication System) is a hospital business process used by hospital staff to manage images and patients history.
                              ). Consequently, if the adversary is curious then he may be able to infer the provenance of CPI and make the connection between EBP and his end-users, i.e., respondents, by using SQL injection attacks to retrieve, for instance, the list of employees who have an accident during work.

In this section, we give preliminary knowledge about business process outsourcing to the cloud. Business Process as a Service is also modeled at the end of the section.

We consider the general multi-party cloud system depicted in Fig. 4
                        , which consists of multicloud platforms and multiple organizations or entities outsourcing their business processes (BPs). Each cloud platform includes a set of deployed process fragments (PFs) and a business process composer, i.e., BPEL engine. PFs are provided by cloud platform itself or by external entities. For that, we define each cloud platform as being a process curator that hosts a set of PFs and maintains them long-term such that they are available for execution.

Entities can be categorized into process providers and process consumers. Process providers are these companies or organizations that share and make their PFs available to the public. Process consumers are these organizations that re-use PFs in the cloud. An entity might at the same time be a process provider and a process consumer, and has its own end-users, i.e., respondents, and data resources. Formally,
                           Definition 3.1
                           (Multi-party cloud system)


                           A multi-party cloud system includes a set of cloud platforms {C
                              1,
                              C
                              2,…} and a set of entities {E
                              1,
                              E
                              2,…}, where:
                                 
                                    •
                                    Each cloud platform C
                                       
                                          i
                                        is a tuple 
                                          
                                             
                                                P
                                                
                                                   F
                                                   
                                                      C
                                                      i
                                                   
                                                
                                                ,
                                                D
                                                
                                                   S
                                                   
                                                      C
                                                      i
                                                   
                                                
                                                ,
                                                B
                                                
                                                   C
                                                   
                                                      C
                                                      i
                                                   
                                                
                                             
                                          
                                       , where 
                                          P
                                          
                                             F
                                             
                                                C
                                                i
                                             
                                          
                                          =
                                          
                                             
                                                f
                                                
                                                   C
                                                   i
                                                
                                                1
                                             
                                             
                                                f
                                                
                                                   C
                                                   i
                                                
                                                2
                                             
                                             …
                                          
                                        is the set of all PFs in C
                                       
                                          i
                                       ; 
                                          D
                                          
                                             S
                                             
                                                C
                                                i
                                             
                                          
                                          =
                                          
                                             
                                                d
                                                
                                                   C
                                                   i
                                                
                                                1
                                             
                                             
                                                d
                                                
                                                   C
                                                   i
                                                
                                                2
                                             
                                             …
                                          
                                        is the set of all data resources and databases of C
                                       
                                          i
                                       ; and 
                                          B
                                          
                                             C
                                             
                                                C
                                                i
                                             
                                          
                                        is the business process composer of C
                                       
                                          i
                                       .

Each entity E
                                       
                                          i
                                        is a pair 
                                          
                                             
                                                D
                                                
                                                   S
                                                   
                                                      E
                                                      i
                                                   
                                                
                                                ,
                                                E
                                                
                                                   U
                                                   
                                                      E
                                                      i
                                                   
                                                
                                             
                                          
                                       , where 
                                          D
                                          
                                             S
                                             
                                                E
                                                i
                                             
                                          
                                          =
                                          
                                             
                                                d
                                                
                                                   E
                                                   i
                                                
                                                1
                                             
                                             
                                                d
                                                
                                                   E
                                                   i
                                                
                                                2
                                             
                                             …
                                          
                                        is the set of all data resources and internal databases of E
                                       
                                          i
                                       ; and 
                                          E
                                          
                                             U
                                             
                                                O
                                                i
                                             
                                          
                                          =
                                          
                                             
                                                e
                                                
                                                   u
                                                   
                                                      E
                                                      i
                                                   
                                                   1
                                                
                                                ,
                                                e
                                                
                                                   u
                                                   
                                                      E
                                                      i
                                                   
                                                   2
                                                
                                                ,
                                                …
                                             
                                          
                                        is the set of all end-users and respondents of E
                                       
                                          i
                                       .

Business processes are at the core of organizations and an important success factor. They consist of a group of business activities undertaken by one or more entities. These activities are combined within or from different organizations and in turn offering them as value-added services. Therefore, software, that implement BPs, typically operate in a cross-organization and distributed environment. Based on existing works on business process modeling, e.g. Beeri et al. [33], where the authors model a BP as a directed labeled graph. We enrich it with the definition of process fragments.

We assume the existence of two domains 
                           N
                         of nodes, and 
                           L
                         of node labels. 
                           L
                         is the disjoint union of several domains including data values, attribute names, data element names, and activity names. Formally,
                           Definition 3.2
                           
                              (Business graph) 
                              [33,34]
                           


                           A business graph is a pair 
                                 G
                              , where:
                                 
                                    •
                                    
                                       G
                                       =(N,
                                       E,Ψ) is a directed graph in which 
                                          N
                                          ⊂
                                          N
                                        is a finite set of nodes, E is a set of edges with endpoints in N, and Ψ is an incidence function that associates with each edge of E an ordered pair of nodes of N; and

Γ:
                                       N
                                       →
                                       
                                          L
                                        is a labeling function for the nodes. Depending on their label type, we refer to the nodes in 
                                          G
                                        as data element names, data attribute, data value, activity name, etc.

We now use business graphs to represent BPs. This representation can be considered as an early stage phase before BPEL or BPMN modeling. The business process is defined in Definition 3.3.
                           Definition 3.3
                           
                              (Business process) 
                              [33]
                           


                           A business process (BP for short) is a triple 
                                 p
                                 =
                                 (
                                 G
                                 ,
                                 start
                                 ,
                               
                              end), where: 
                                 G
                               is a business graph; start, end are two distinguished activity nodes in 
                                 G
                              ; and each activity node in 
                                 G
                               resides on some path from start to end.

A BP is specified as a collection of business activities and is defined using a business graph. For convenience, we use the terms of abstract process fragment (abstract PF) and concrete process fragment (concrete PF) to represent each business activity, where: An abstract PF, i.e., task, defines what a PF is supposed to do explicitly in the sense of a mathematical function or a black box description (with inputs and outputs). An abstract PF is implemented by several substitute concrete PFs. The choice among these substitute concrete PFs is based on their non-functional properties, which are also referred to as Quality of Service (QoS) [5].

As discussed in [15], PFs can be created using two approaches. In the first one, called top-down, PFs are created by extracting connected structures from a given process. Thus, the PF is indeed a sub-graph of a process graph. In the second one, named bottom-up, a PF needs to be created from scratch. We consider the top-down approach, where process fragmentation is already done and concrete PFs are well distinguished and identified in the cloud platform. There are techniques in the literature that can help resolve BP's fragmentation issues. During process fragments composition, a list of desired abstract PFs is given to the business process composer, which instantiates each abstract PF by a concrete PF. In the following, we define process fragments.

We assume the existence of two domains 
                           F
                         of concrete PFs and 
                           A
                         of abstract PFs. Like instances and classes respectively in object-oriented programming. Two instances, i.e., concrete PFs, of the same class, i.e., abstract PF, are clones (see [36] for a recent paper on the topic). Then formally,
                           Definition 3.4
                           
                              (Business subgraph) 
                              [34,29,30]
                           


                           
                              
                                 H
                               is said a business subgraph of 
                                 G
                               (written 
                                 H
                                 ⊆
                                 G
                              ) iff :
                                 
                                    •
                                    
                                       
                                          N
                                          
                                             H
                                          
                                          ⊆
                                          N
                                          
                                             G
                                          
                                       , where 
                                          N
                                          ⊂
                                          N
                                        is a set of nodes; and


                                       
                                          E
                                          
                                             H
                                          
                                          ⊆
                                          E
                                          
                                             G
                                          
                                       , where E is a set of edges; and

Ψ(
                                          H
                                       ) is the restriction of 
                                          Ψ
                                          
                                             G
                                          
                                       .

As BPs, we use the notion of business subgraph to define PFs as follows:
                           Definition 3.5
                           
                              (Process fragment) 
                              [29,30]
                           


                           A process fragment (PF for short) is a pair f
                              =(α,Δ), where: 
                                 α
                                 ∈
                                 A
                               is an activity requirement (abstract PF); and 
                                 Δ
                                 :
                                 A
                                 →
                                 F
                                 ,
                                 Δ
                                 
                                    α
                                 
                                 =
                                 
                                    F
                                    α
                                 
                               is a function providing a set F
                              
                                 α
                              
                              ⊂
                              
                                 F
                               of business proper subgraphs (concrete PFs) having the same abstract α.

If the cardinality |F
                              
                                 α
                              |>1, then f is a multi-tenant PF with |F
                              
                                 α
                              | clones: 
                                 
                                    f
                                    
                                       p
                                       1
                                    
                                 
                                 ,
                                 
                                    f
                                    
                                       p
                                       2
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    f
                                    
                                       p
                                       
                                          
                                             F
                                             α
                                          
                                       
                                    
                                 
                              .

We consider that a process consumer, generally an organization, submits a request for an abstract PF to the business process composer. The composer explores potential candidates and selects the best concrete PF according to functional and non-functional Service Level Agreement (SLA), as well as, security constraints of the process consumer [5,4]. A concrete PF may need to be replaced per clone at runtime if it becomes unavailable or Quality of Service (QoS) degrades [35,36].

Business Process as a Service (BPaaS) consists of a set of BPs deployed in a multi-party cloud system containing process curators, providers, and consumers. These BPs are composed by BP composers (BPEL Engine) using multi-tenant PFs and different data resources. Usually, end-users or respondents have to use BPs in their everyday life through Web frontends and mobile applications (e.g., to submit an insurance claim or to apply for a permit to build a house). In order to model a BPaaS, we assume the existence of two domains 
                           P
                         of BPs, and 
                           I
                         of BP's identifiers. Then formally,
                           Definition 3.6
                           (Business Process as a Service) [29,30]
                           


                           A BPaaS model is a pair 
                                 S
                                 =
                                 
                                    P
                                    Θ
                                 
                              , where: 
                                 P
                                 ⊂
                                 P
                               is a finite set of BPs deployed on the BPaaS, P
                              =(p
                              1,
                              p
                              2,…,
                              p
                              
                                 i
                              ); and 
                                 Θ
                                 :
                                 P
                                 →
                                 I
                                 ,
                                 Θ
                                 
                                    p
                                 
                                 =
                                 I
                                 
                                    d
                                    p
                                 
                               is an identification function for the whole BPs. Depending on the tenant deploying a BP, we identify the BP p
                              
                                 i
                               in 
                                 S
                               by 
                                 i
                                 
                                    d
                                    
                                       p
                                       i
                                    
                                 
                              .

Let 
                                 S
                               be a BPaaS shown in Fig. 5
                              , where: P
                              ={p
                              1,
                              p
                              2,
                              p
                              3,
                              p
                              4} is a set of BPs, and F
                              ={f
                              1,
                              f
                              2,
                              f
                              3} is a set of PFs. Each BP p
                              
                                 i
                              
                              ∈
                              P is identified by an identifier 
                                 i
                                 
                                    d
                                    
                                       p
                                       i
                                    
                                 
                              ; and ∀
                              f
                              
                                 j
                              
                              ∈
                              F, we define an abstract PF 
                                 
                                    α
                                    
                                       f
                                       j
                                    
                                 
                              .

We give for each 
                           
                              α
                              
                                 f
                                 j
                              
                           
                         in 
                           S
                        , 
                           Δ
                           
                              
                                 α
                                 
                                    f
                                    j
                                 
                              
                           
                         the set of concrete PFs:
                           
                              •
                              
                                 
                                    Δ
                                    
                                       
                                          α
                                          
                                             f
                                             1
                                          
                                       
                                    
                                    =
                                    
                                       
                                          f
                                          1
                                          
                                             p
                                             1
                                          
                                       
                                       
                                          f
                                          1
                                          
                                             p
                                             2
                                          
                                       
                                       
                                          f
                                          1
                                          
                                             p
                                             3
                                          
                                       
                                       
                                          f
                                          1
                                          
                                             p
                                             4
                                          
                                       
                                    
                                 , we say f
                                 1 is a multi-tenant PF provided by all BPs in 
                                    S
                                 .


                                 
                                    Δ
                                    
                                       
                                          α
                                          
                                             f
                                             2
                                          
                                       
                                    
                                    =
                                    
                                       
                                          f
                                          2
                                          
                                             p
                                             1
                                          
                                       
                                       
                                          f
                                          2
                                          
                                             p
                                             2
                                          
                                       
                                       
                                          f
                                          2
                                          
                                             p
                                             3
                                          
                                       
                                    
                                 , we say f
                                 2 is a multi-tenant PF provided by three BPs (p
                                 1, p
                                 2, and p
                                 3) in 
                                    S
                                 .


                                 
                                    Δ
                                    
                                       
                                          α
                                          
                                             f
                                             3
                                          
                                       
                                    
                                    =
                                    
                                       
                                          f
                                          3
                                          
                                             p
                                             2
                                          
                                       
                                       
                                          f
                                          3
                                          
                                             p
                                             4
                                          
                                       
                                    
                                 , we say f
                                 3 is a multi-tenant PF provided by two BPs (p
                                 2 and p
                                 4) in 
                                    S
                                 .

The greatest advantage of using multi-party cloud platform is the possibility to share one or a set of PFs. In fact, given a BPaaS 
                           S
                         with some BPs deployed in it, we can design a new process-based application (PBA) by selecting existing PFs, and reusing them as Web Services. This concept is known as Design by Selection 
                        [17]. How to glue the PFs is out of the scope of the paper, see [15] for more details. Formally,
                           Definition 3.7
                           (Design by selection)


                           Let us consider:
                                 
                                    •
                                    
                                       
                                          S
                                          =
                                          
                                             P
                                             Θ
                                          
                                        a BPaaS,


                                       p a new PBA to be developed in 
                                          S
                                       , and


                                       
                                          Ω
                                          :
                                          F
                                          →
                                          P
                                          ,
                                          Ω
                                          
                                             F
                                          
                                          =
                                          
                                             p
                                             ′
                                          
                                        a function performed to design a new BP p′ by selecting some PFs deployed in S and available in F.

In the BPaaS 
                                 S
                                 '
                                 =
                                 
                                    P
                                    Θ
                                    Ω
                                 
                               where F is a set of PFs, we say that 
                                 p
                                 
                                    →
                                    f
                                 
                                 
                                    p
                                    ′
                                 
                               w.r.t. Ω if p′ is obtained by reusing a PF f
                              ∈
                              F in order to develop p.

If 
                                 p
                                 
                                    →
                                    
                                       f
                                       1
                                    
                                 
                                 
                                    p
                                    1
                                    ′
                                 
                                 
                                    →
                                    
                                       f
                                       2
                                    
                                 
                                 
                                    p
                                    2
                                    ′
                                 
                                 
                                    →
                                    
                                       f
                                       3
                                    
                                 
                                 …
                                 
                                    →
                                    
                                       f
                                       k
                                    
                                 
                                 
                                    p
                                    ′
                                 
                               w.r.t. Ω, then we say that p′ is construction of p by reusing a set {f
                              1,
                              f
                              2,
                              f
                              3,…,
                              f
                              
                                 k
                              } of PFs deployed in 
                                 S
                              .

The Algorithm 1 presents the mechanism for designing and developing process-based applications by reusing PFs in BPaaS.
                           Algorithm 1
                           Design by selection in BPaaS


                           
                              
                                 
                              
                           

Hasan et al. [37] defined data provenance as information that summarizes the history of the ownership of the item, as well as the actions performed on it. In other words, a record of where data came from and how it has been processed. Data provenance is extremely important for verifiability and repeatability of results, as well as for debugging and trouble-shooting workflows and business processes [28,38,39].

In BPaaS context, the fragment provenance permits to identify the process provider, i.e., the entity or organization that outsources, manages and monitors the process fragment. Currently, process consumers have access to the BPaaS' repository, and all information about process providers (see e.g., [31,32]). However, the provenance of PFs may be private information. Indeed, a process consumer should not be able to guess with a specified degree of certainty the provenance of a concrete PF. Formally,
                           Definition 3.8
                           (Fragment's provenance)


                           Let us consider F a set of concrete PFs f
                              
                                 i
                               deployed in the BPaaS 
                                 S
                                 =
                                 
                                    P
                                    Θ
                                 
                              . ∀
                              f
                              
                                 i
                              
                              ∈
                              F there exists a set of functional and non-functional requirements that allows the description of f
                              
                                 i
                               in 
                                 S
                              .


                        Provenance requirements of f
                        
                           i
                        , denoted 
                           Pr
                           
                              o
                              
                                 f
                                 i
                              
                           
                        , is any functional or non-functional requirement that uniquely identifies the provider of f
                        
                           i
                         (e.g., identity of the provider). Provenance should be removed entirely from the description of PFs in the BPaaS.


                        Quasi-provenance requirements denoted 
                           Q
                           P
                           r
                           
                              o
                              
                                 f
                                 i
                              
                           
                        , is a minimal set of functional and non-functional requirement that can be linked with external information to reduce the uncertainty over process providers. For instance, consider the activity requirement PhoneService or SMService can be linked external information such as business of entities to reveal the process provider's identity.


                        Simple requirements does not fall into any of the two categories above.

The framework of this paper is one where organizations, i.e., process providers and process consumers, are connected to a trusted third party, i.e., process curator, in order to (i) outsource their BPs, and (ii) design new PBAs by selection, as depicted in Fig. 6
                     .

We assume each BP designer has a personal account to use the BPaaS via Web Portals: Service Hosting Portal and Service Design Portal. Before the deployment phase, a new BP must be decomposed into a set of PFs and each PF should be identified, i.e., its activity requirement defined. The decomposition of BPs (respectively identification of PF) is carried out manually or automatically at the Service Decomposition Engine (respectively Service Identification). The Fragment Service Repository is assumed to be hosted at the process curator and, of course, the design of a new PBA requires the selection of a concrete PF in the repository.

An adversary is defined by the capabilities that it has. We now list these resources, and of course an adversary may have combinations of these capabilities:
                           
                              1.
                              
                                 Account (Design, Host, and View). An adversary may make multiple connections over time, with a personal account, to design process-based applications (Design), and/or to host process fragments to a process curator (Host). We consider an adversary that can crack the personal accounts as outside of our attack model. An adversary is able to query BPaaS repositories through views, and sees the set of process fragments available to be selected (View). Only adversaries with Design access right can use views on BPaaS. We consider adversaries that can access the BPaaS repositories as outside of our attack model.


                                 Tenants (List). An adversary may obtain the list of BPaaS tenants or process providers/consumers, possibly by homogeneity or background attacks, or by other extreme measures.


                                 Malicious (Mcs). An adversary can delete its own process fragments from the BPaaS. We consider an adversary that deletes the process fragments of other tenants as outside of our attack model.


                                 Curious (Crs). An adversary may be able to eavesdrop on the BPaaS to disclose respondent privacy, and retrieve inputs/outputs values, i.e., intermediate data, manipulated by multi-tenants process fragments (e.g., by using SQL injection attacks).

We look at the availability of PBAs, and confidentiality of the multi-tenant PFs. The availability of a process fragment requires that an adversary cannot make an organization unable to execute its process based application (i.e., availability of the reused fragments). The confidentiality requirements of the PFs are that an adversary should not be able to infer the provenance of a PF. We now formally define the security requirements for the notions above:
                           
                              1.
                              
                                 Availability. The attack we consider is that where an adversary removes concrete PF, reused to design PBAs, from the BPaaS. We present an oracle that is considered secure in our paper, and we prove availability by showing an adversary is equivalent to this oracle. Suppose the adversary has an oracle 
                                    A
                                    :
                                    
                                       
                                          V
                                          F
                                       
                                       
                                          f
                                          i
                                       
                                    
                                    →
                                    
                                       V
                                       F
                                    
                                 , where 
                                    A
                                    
                                       
                                          
                                             V
                                             F
                                          
                                          
                                             f
                                             i
                                          
                                       
                                    
                                  is a view on the BPaaS without f
                                 
                                    i
                                 . In other words, the adversary can delete an arbitrary number of process fragments f
                                 
                                    i
                                  from the BPaaS. We consider a protocol that allows such adversaries to be strongly secure.


                                 Confidentiality. We present a second oracle, and we prove confidentiality by showing an adversary is equivalent to this oracle. Suppose the adversary has an oracle 
                                    B
                                 
                                 :∅→
                                 V
                                 
                                    F
                                 , where 
                                    B
                                 () returns a view on the BPaaS. In other words, the adversary sees a carefully chosen subset of PFs available in the BPaaS. A protocol with such an adversary has acceptable security only in cases where the subset is well chosen. We consider a protocol that allows such adversaries to be weakly secure.

Before we define the security of our system, we discuss the security (in the terms outlined above) of an ideal implementation that uses the trusted oracles. Such a system would require that the tenant uses the secure views on the BPaaS to design PBAs. The trusted oracles provide the secure views to the tenants. Clearly, we cannot do better than such an implementation.


                        Table 1
                         is a summary of an adversary's power with various resources (in our protocol); there are three categories of security: Strong, Weak, and No Secure. Where the first two are defined in the previous section, and No Secure means that the system does not protect this resource against this type of adversary. Thus, in many ways, the view is the lynchpin of the system. In the following sections we will present how to calculate the BPaaS view, and show the impact of each implementation on Security.

In this section, we outline a preliminary solution presented in [30] for secure business process outsourcing that should be viewed as warmup for the better solutions given later in the end of the section. The primary question that needs to be addressed is: “How does the tenant develop the process-based application without knowing the business activities of process's provider?”

As explained above, a BPaaS is a set of BPs outsourced by organizations to multi-party cloud system. A BPaaS view provides a set of concrete PFs having the same abstract PF, i.e., activity, called clones [36]. Formally,
                           Definition 5.1
                           (BPaaS views)


                           Let us consider: 
                                 S
                               a BPaaS including a set of BPs, α an abstract PF, and V
                              
                                 α
                               a set of concrete PFs having the same abstract PF α. V
                              
                                 α
                               is called a view on 
                                 S
                               w.r.t. α.


                        Table 2
                         shows a process fragments repository containing a set of concrete PFs with their QoS [31,32]. The view on the repository w.r.t. Phone (depicted in Table 3
                        ) provides a set of concrete PFs: Phone, PhoneVerify, PhoneNotify and PhoneService, that implement this activity. In the following and in order to manage the views, we define a set of operations :
                           Definition 5.2
                           
                              (Operations on BPaaS views)
                           


                           Let us consider: 
                                 S
                               a BPaaS including a set of BPs; α and β two abstract PFs; V
                              
                                 α
                               (resp. V
                              
                                 β
                              ) a view on 
                                 S
                               w.r.t. α (resp. β); We assume that it is possible to have one concrete PF that implements several abstract PFs, then:


                                 V
                                 ¬
                                    α
                                  is said a view on 
                                    S
                                  w.r.t. ¬
                                 α, iff V
                                 ¬
                                    α
                                  contains all concrete PFs in 
                                    S
                                  not having the abstract PF α (Negation).


                                 V
                                 
                                    α
                                    ∧
                                    β
                                  is said a view on 
                                    S
                                  w.r.t. α
                                 ∧
                                 β iff V
                                 
                                    α
                                    ∧
                                    β
                                  contains all concrete PFs in 
                                    S
                                  having the abstract PFs α 
                                 and 
                                 β (Conjunction).


                                 V
                                 
                                    α
                                    ∨
                                    β
                                  is said a view on 
                                    S
                                  w.r.t. α
                                 ∨
                                 β, iff V
                                 
                                    α
                                    ∨
                                    β
                                  contains all concrete PFs in 
                                    S
                                  having the abstract PFs α 
                                 or 
                                 β (Disjunction).

As previously mentioned, PFs can be selected when designing PBAs. Unfortunately, the fact to know the provenance of a concrete PF may disclose the process provider's business secret. Therefore, the process curator would like to protect reused concrete PFs against link to process providers in 
                              S
                           .

Our approach to ensure BPaaS confidentiality, will be to hide a carefully chosen subset of process fragments. Inspired by k-anonymity model in databases, we have defined k-anonyfrag, an anonymity model for process fragments, which consists in generating anonymous views on the BPaaS [30]. In other words, we will project BPaaS repository on a restricted subset F of concrete PFs called anonymous view, allowing users access only to the V
                           
                              F
                           .

The k-anonyfrag requirement below, which states that in every view V
                           
                              α
                            on BPaaS repository we have at most K clones. Otherwise, there exists at most K concrete PFs having the same AF α in 
                              S
                           .
                              Definition 5.3
                              
                                 (K
                                 
                                    l
                                 
                                 −
                                 anonyfrag requirement) 
                                 [29,30]
                              


                              
                                 K
                                 
                                    l
                                 
                                 −
                                 anonyfrag requirement is for each view V
                                 
                                    α
                                  on BPaaS w.r.t. α, it must contain at most K clones.

Since it seems impossible or highly impractical and limiting to make assumptions on PFs to a curious adversary to discover business activities of process providers when reusing a concrete PF to design a new PBA. In the following, we define a K
                           
                              l
                           
                           −
                           anonyfrag:
                              Definition 5.4
                              
                                 (K
                                 
                                    l
                                 
                                 −
                                 anonyfrag) 
                                 [29,30]
                              


                              Given a BPaaS 
                                    S
                                  used by l tenants; and an abstract PF α implemented by at most K concrete PFs or clones in 
                                    S
                                 . An adversary knows that it exists at most K clones implementing α are hosted in 
                                    S
                                 ; and doesn't know:
                                    
                                       1.
                                       Exactly the number of tenants that provide the K concrete PFs among l tenants.

Which tenants exactly have provided/hosted the abstract PF in 
                                             S
                                          .

A view V
                                 
                                    F
                                  satisfies K
                                 
                                    l
                                 
                                 −
                                 anonyfrag if for every abstract PF α
                                 
                                    i
                                 
                                 ∈
                                 F the cardinality 
                                    
                                       
                                          V
                                          
                                             α
                                             i
                                          
                                       
                                    
                                    ∈
                                    
                                       1
                                       K
                                    
                                 .

We assume each entity deploying exactly one concrete PF implementing α is the best-case scenario, and the worst-case scenario when an entity provides more than one concrete PF implementing the same abstract PF α. K
                           
                              l
                           
                           −
                           anonyfrag implies that for any concrete PF f
                           
                              i
                            in 
                              S
                           :

A curious adversary can guess the process provider of a concrete PF with probability P
                           
                              pro
                           (f
                           
                              i
                           ), even if the view is calculated an arbitrary number of times. Note that the probability is always minimum in the best-case. We have l tenants and each tenant can deploy exactly one concrete PF. Therefore, the probability to infer the process provider for a given concrete PF is calculated as follows:
                              
                                 (1)
                                 
                                    
                                       P
                                       pro
                                    
                                    
                                       
                                          f
                                          i
                                       
                                    
                                    =
                                    
                                       1
                                       l
                                    
                                 
                              
                           
                        

However, in the worst-case scenario when each tenant can deploy more then one concrete PF (and maximally K), the probability is calculated as follows:
                              
                                 (2)
                                 
                                    
                                       P
                                       pro
                                    
                                    
                                       
                                          f
                                          i
                                       
                                    
                                    =
                                    
                                       K
                                       l
                                    
                                 
                              
                           
                        

Note:
                              
                                 1.
                                 If 
                                       
                                          
                                             V
                                             
                                                f
                                                i
                                             
                                          
                                       
                                       ≃
                                       l
                                    , the probability P
                                    
                                       pro
                                    (f
                                    
                                       i
                                    )≃1 is maximum. It means practically all entities in the BPaaS provide the concrete PF f
                                    
                                       i
                                    . In this case we cannot hide the provenance of a concrete PF, i.e., all tenants have deployed the same abstract PF.

If 
                                       
                                          
                                             V
                                             
                                                f
                                                i
                                             
                                          
                                       
                                       =
                                       1
                                    , the probability 
                                       
                                          P
                                          pro
                                       
                                       
                                          
                                             f
                                             i
                                          
                                       
                                       =
                                       
                                          1
                                          l
                                       
                                       ≃
                                       0
                                     is minimum. It means only one tenant in the BPaaS deploys the concrete PF f
                                    
                                       i
                                    . In this case we have a low probability that an adversary can guess the provenance of the concrete PF f
                                    
                                       i
                                    .

A malicious adversary can make unavailable a PBA with probability P
                           
                              avai
                           (f
                           
                              i
                           ). In the case where an adversary deploys exactly one concrete PF, i.e., best-case, the probability is minimum:
                              
                                 (3)
                                 
                                    
                                       P
                                       avai
                                    
                                    
                                       
                                          f
                                          i
                                       
                                    
                                    =
                                    
                                       1
                                       K
                                    
                                    .
                                 
                              
                           
                        

However, in the worst-case, an adversary can deploy K concrete PFs, the probability is maximum and equal to:
                              
                                 (4)
                                 
                                    
                                       P
                                       avai
                                    
                                    
                                       
                                          f
                                          i
                                       
                                    
                                    =
                                    
                                       K
                                       K
                                    
                                    =
                                    1
                                    .
                                 
                              
                           
                        

In the following, we define the new notions of confidentiality cost and availability cost in anonymous views on BPaaS:
                              Definition 5.5
                              
                                 (Confidentiality and availability costs)
                              


                              Given a BPaaS 
                                    S
                                  used by l tenants, a set F of concrete PFs f
                                 
                                    i
                                  deployed on 
                                    S
                                 , and V
                                 
                                    α
                                  a view on 
                                    S
                                  w.r.t an abstract PF α that satisfies K
                                 
                                    l
                                 
                                 −
                                 anonyfrag.

The confidentiality cost of a view V
                                    
                                       α
                                    , denoted C
                                    
                                       c
                                    (V
                                    
                                       α
                                    ), is the probability that a curious adversary can guess the provenance of a concrete PF f
                                    
                                       i
                                     implementing α
                                    
                                       
                                          (5)
                                          
                                             
                                                C
                                                c
                                             
                                             
                                                
                                                   V
                                                   α
                                                
                                             
                                             =
                                             
                                                P
                                                pro
                                             
                                             
                                                
                                                   
                                                      f
                                                      i
                                                   
                                                
                                                
                                                   worst
                                                   −
                                                   case
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          (6)
                                          
                                             
                                                C
                                                c
                                             
                                             
                                                
                                                   V
                                                   α
                                                
                                             
                                             =
                                             
                                                K
                                                l
                                             
                                             .
                                          
                                       
                                    
                                 

The availability cost of a view V
                                    
                                       α
                                    , denoted C
                                    
                                       a
                                    (V
                                    
                                       α
                                    ), is the probability that a malicious adversary can make unavailable a process-based application that reuses a PF f
                                    
                                       i
                                     implementing α.
                                       
                                          (7)
                                          
                                             
                                                C
                                                a
                                             
                                             
                                                
                                                   V
                                                   α
                                                
                                             
                                             =
                                             
                                                P
                                                avai
                                             
                                             
                                                
                                                   
                                                      f
                                                      i
                                                   
                                                
                                                
                                                   wrst
                                                   −
                                                   case
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          (8)
                                          
                                             
                                                C
                                                a
                                             
                                             
                                                
                                                   V
                                                   α
                                                
                                             
                                             =
                                             1
                                             .
                                          
                                       
                                    
                                 


                                 Anonymous views do not guarantee the availability of process-based application.
                              


                                 The proof of this claim is easy, we just have to take the worst-case (where an attacker deploys K concrete PFs). We found the availability cost C
                                 
                                    a
                                 (V
                                 
                                    α
                                 )=1 (i.e., the probability that an attacker can make unavailable a process-based application is equal to 1).
                              

We introduce a new notion of diverse views on BPaaS to guarantee availability of PBAs. Our notion is close to that of l-diversity in databases [40], in which there are at least l different values of sensitive attributes. We extend this work to BPaaS security problem. For that, we define T
                           
                              l
                           
                           −
                           diverfrag, a diversity model for process fragments, which consists in generating diverse views on the BPaaS. This means the anonymous BPaaS views will be projected on a restricted subset F
                           ' of concrete PFs (called diverse view).

We consider the BPaaS S used by l tenants. V
                           
                              F
                           
                           ⋆ a view on S that satisfies K
                           
                              l
                           
                           −
                           anonyfrag requirement. The T
                           
                              l
                           
                           −
                           diverfrag requirement below, which states that in every anonymous view V
                           
                              F
                           
                           ⋆ on BPaaS and for each concrete PF f
                           
                              i
                           
                           ∈
                           F, we have at least T different process providers. Otherwise, there exists at least T different process providers have deployed at most K concrete PFs having the same abstract PF in S. In the following a tenant may deploy a set of concrete PFs having the same abstract PF a in S.
                              Definition 5.6
                              
                                 (T
                                 
                                    l
                                 
                                 −
                                 diverfrag requirement)
                              


                              
                                 T
                                 
                                    l
                                 
                                 −
                                 diverfrag requirement is for each anonymous view V
                                 
                                    α
                                 
                                 ⋆ on BPaaS w.r.t. a, it must contain at most K concrete PFs provided by at least T different process providers.

Since it seems impossible or highly impractical for a malicious adversary to make unavailable a PBA when removing a concrete PF from the BPaaS. In the following, we define a T
                           
                              l
                           
                           −
                           diverfrag:
                              Definition 5.7
                              
                                 (T
                                 
                                    l
                                 
                                 −
                                 diverfrag)
                              


                              Given a BPaaS S used by l tenants; and an abstract PF a implemented by at most K concrete PFs or clones deployed by at least T different tenants in S. A malicious adversary:
                                    
                                       1.
                                       can make unavailable at most K
                                          −
                                          T
                                          +1 concrete PFs implementing α; and

cannot make unavailable at least T
                                          −1 concrete PFs implementing α in 
                                             S
                                          .

A view V
                           
                              F
                              '
                           ⋆ satisfies T
                           
                              l
                           
                           −
                           diverfrag if for every abstract PF α
                           
                              i
                           : the number of tenants that deployed concrete PFs implementing α
                           
                              i
                           : 
                              
                                 
                                    Tenan
                                    
                                       t
                                       id
                                       
                                          α
                                          i
                                       
                                    
                                 
                              
                              ≥
                              T
                           .

As previously mentioned, it is assumed a tenant deploying exactly one concrete PF implementing a is the best-case scenario, and the worst-case scenario when a tenant can deploy more than one concrete PF implementing an abstract PF α. In the following, we define confidentiality and availability costs in diverse BPaaS views. T
                           
                              l
                           
                           −
                           diverfrag implies that for any concrete PF f
                           
                              i
                            in 
                              S
                           :

A curious adversary can guess the process provider with probability P
                           
                              pro
                           (f
                           
                              i
                           ), even if the view is calculated an arbitrary number of times. Note that the probability is always minimum in the best-case scenario i.e., where K
                           =
                           T:
                              
                                 (9)
                                 
                                    
                                       P
                                       pro
                                    
                                    
                                       
                                          f
                                          i
                                       
                                    
                                    =
                                    
                                       1
                                       l
                                    
                                    .
                                 
                              
                           
                        

In the worst-case scenario, an adversary can maximally deploy K
                           −
                           T
                           +1. Therefore, the probability is calculated as follows:
                              
                                 (10)
                                 
                                    
                                       P
                                       pro
                                    
                                    
                                       
                                          f
                                          i
                                       
                                    
                                    =
                                    
                                       
                                          K
                                          −
                                          T
                                          +
                                          1
                                       
                                       l
                                    
                                    .
                                 
                              
                           
                        

We note:
                              
                                 1.
                                 If 
                                       
                                          
                                             V
                                             
                                                f
                                                i
                                             
                                          
                                       
                                       ≃
                                       l
                                     and 
                                       
                                          
                                             Tenan
                                             
                                                t
                                                id
                                                
                                                   α
                                                   i
                                                
                                             
                                          
                                       
                                       ≃
                                       1
                                    , the probability 
                                       
                                          P
                                          pro
                                       
                                       
                                          
                                             f
                                             i
                                          
                                       
                                       ≃
                                       
                                          l
                                          l
                                       
                                       ≃
                                       1
                                     is maximum. It means that one tenant in the BPaaS deploys the l PFs f
                                    
                                       i
                                    .

If 
                                       
                                          
                                             V
                                             
                                                f
                                                i
                                             
                                          
                                       
                                       ≃
                                       l
                                     and 
                                       
                                          
                                             Tenan
                                             
                                                t
                                                id
                                                
                                                   α
                                                   i
                                                
                                             
                                             
                                                ≃
                                             
                                             
                                                V
                                                
                                                   f
                                                   i
                                                
                                             
                                          
                                       
                                    . It means that all tenants in the BPaaS use the PF f
                                    
                                       i
                                    . In this case we cannot hide the business activity of tenants, i.e., all tenants have deployed the same PF.

If 
                                       
                                          
                                             V
                                             
                                                f
                                                i
                                             
                                          
                                       
                                       =
                                       1
                                    , the probability 
                                       
                                          P
                                          pro
                                       
                                       
                                          
                                             f
                                             i
                                          
                                       
                                       =
                                       
                                          1
                                          l
                                       
                                       ≃
                                       0
                                     is minimum. It means that only one tenant in the BPaaS deploys the PF f
                                    
                                       i
                                    . In this case we have a low probability that an adversary can guess the process provider of f
                                    
                                       i
                                    .

A malicious adversary cannot make unavailable PBA with probability P
                           
                              avai
                           (f
                           
                              i
                           ). The probability is maximum in the best-case:
                              
                                 (11)
                                 
                                    
                                       P
                                       avai
                                    
                                    
                                       
                                          f
                                          i
                                       
                                    
                                    =
                                    
                                       
                                          K
                                          −
                                          1
                                       
                                       K
                                    
                                    .
                                 
                              
                           
                        

However, in the worst-case the probability is minimum:
                              
                                 (12)
                                 
                                    
                                       P
                                       avai
                                    
                                    
                                       
                                          f
                                          i
                                       
                                    
                                    =
                                    
                                       
                                          K
                                          −
                                          T
                                          +
                                          1
                                       
                                       K
                                    
                                 
                              
                           
                           
                              Theorem 2
                              
                                 Diverse views guarantee the availability of process-based application.
                              


                                 As 
                                 
                                    Theorem 1
                                 , we just have to take the worst-case. We found the availability cost 
                                 
                                    
                                       C
                                       a
                                    
                                    
                                       
                                          V
                                          α
                                       
                                    
                                    =
                                    
                                       
                                          T
                                          −
                                          1
                                       
                                       K
                                    
                                    ≠
                                    0
                                  (i.e., the probability that an attacker can make unavailable a process-based application is different from zero).
                              


                           Table 4
                            summarizes the contribution of the diverse views to improve availability and confidentiality in the worst-case scenario.
                        

In this section, we present an approximative algorithm that provides a secure view on BPaaS. We model it as a multi-objective optimization problem, which consists in optimizing simultaneously the conflicting objectives of availability and confidentiality.

We are given a BPaaS S used by l entities, a set F of concrete PFs f
                        
                           i
                         deployed on S, and V
                        
                           α
                         a view on S w.r.t an abstract PF α. A view V
                        
                           α
                        (K,
                        T) is feasible if it constitutes a set of at most K concrete PFs implementing a provided by at least T tenants. The objectives of availability and confidentiality are modeled with functions A and C respectively, which have to be minimized simultaneously are considered:
                           
                              (13)
                              
                                 
                                    A
                                    
                                       V
                                       F
                                    
                                 
                                 
                                    K
                                    T
                                 
                                 =
                                 Max
                                 
                                    
                                       
                                          C
                                          a
                                       
                                       
                                          
                                             f
                                             i
                                          
                                       
                                       :
                                       
                                          f
                                          i
                                       
                                       ∈
                                       F
                                    
                                 
                              
                           
                        is the maximum of availability costs of all concrete PFs f
                        
                           i
                        
                        ∈
                        F; and
                           
                              (14)
                              
                                 
                                    C
                                    
                                       V
                                       F
                                    
                                 
                                 
                                    K
                                    T
                                 
                                 =
                                 Max
                                 
                                    
                                       
                                          C
                                          c
                                       
                                       
                                          
                                             f
                                             i
                                          
                                       
                                       :
                                       
                                          f
                                          i
                                       
                                       ∈
                                       F
                                    
                                 
                              
                           
                        is the maximum of confidentiality cost of all concrete PFs f
                        
                           i
                        
                        ∈
                        F.

Let OPT
                        
                           A
                         (resp. OPT
                        
                           C
                        ) be the minimum availability cost (resp. confidentiality cost) of a feasible view (best case), where:
                           
                              (15)
                              
                                 OP
                                 
                                    T
                                    A
                                 
                                 =
                                 
                                    1
                                    K
                                 
                              
                           
                        and
                           
                              (16)
                              
                                 OP
                                 
                                    T
                                    C
                                 
                                 =
                                 
                                    1
                                    l
                                 
                                 .
                              
                           
                        
                     

A feasible (α,
                        β)−
                        approximate view is such that:
                           
                              (17)
                              
                                 A
                                 
                                    K
                                    T
                                 
                                 ≤
                                 α
                                 O
                                 P
                                 
                                    T
                                    A
                                 
                              
                           
                        and
                           
                              (18)
                              
                                 C
                                 
                                    K
                                    T
                                 
                                 ≤
                                 β
                                 O
                                 P
                                 
                                    T
                                    C
                                 
                              
                           
                        where α
                        ≥1 and β
                        ≥1. An (α,
                        β)−
                        approximation secure view outputs a solution which is simultaneously α
                        −
                        approximate on the first criterion (the availability), and β
                        −
                        approximate on the second criterion (the confidentiality).

To solve secure view problem, our protocol takes into account the criteria mentioned above. In order to set parameter values K
                        
                           ideal
                         and T
                        
                           ideal
                        , we define a quality function of a BPaaS view to compare the different views that can be obtained. For this purpose, we calculate the ratio between the number of PFs requested to the BPaaS and the number of PFs obtained in the view. Formally, we have:
                           
                              (19)
                              
                                 Qualit
                                 
                                    y
                                    V
                                 
                                 =
                                 
                                    
                                       
                                          V
                                          obtained
                                       
                                    
                                    
                                       
                                          V
                                          requested
                                       
                                    
                                 
                              
                           
                        where: Quality
                        
                           V
                        
                        ∈[0,1]. Our goal is to obtain a high Quality
                        
                           V
                        , which indicates that the protocol used to create BPaaS views does not eliminate requested PFs. We say that V is feasible if Quality
                        
                           V
                         is greater than a threshold q. The threshold q is chosen manually that best selects acceptable and not acceptable BPaaS views.

Given a deterministic α
                        −
                        approximation algorithm A1 for the mono-criterion secure view problem, one can build an (α,
                        β)−
                        approximation algorithm for the bi-criteria secure view problem. We assume two boundaries 
                           
                              
                                 ln
                                 l
                                 ,
                                 
                                    l
                                 
                              
                           
                         as a starting point of our research. We think that these values are sufficient to ensure the availability and confidentiality of PBAs. The algorithm called K-Approx is given in the following:
                           Theorem 3
                           VF(K,T) is a deterministic 
                              
                                 
                                    
                                       
                                          
                                             l
                                          
                                          
                                             l
                                             n
                                             l
                                          
                                       
                                       ,
                                       
                                          l
                                       
                                       −
                                       l
                                       n
                                       l
                                    
                                 
                                 −
                                 approximation
                               
                              secure view on BPaaS.
                           


                              Three cases are considered in K-Approx. Table 5 
                              depicts availability and confidentiality costs for each case. So, we have
                              
                                 
                                    (20)
                                    
                                       A
                                       
                                          K
                                          T
                                       
                                       ≤
                                       α
                                       O
                                       P
                                       
                                          T
                                          A
                                       
                                    
                                 
                              and
                                 
                                    (21)
                                    
                                       C
                                       
                                          K
                                          T
                                       
                                       ≤
                                       β
                                       O
                                       P
                                       
                                          T
                                          C
                                       
                                    
                                 
                              where 
                                 α
                                 =
                                 
                                    
                                       l
                                    
                                    
                                       ln
                                       l
                                    
                                 
                                 ≥
                                 1
                               and 
                                 β
                                 =
                                 
                                    l
                                 
                                 −
                                 ln
                                 l
                                 ≥
                                 1
                              .


                              
                                 
                              
                           

To validate the effectiveness and evaluate the performance of our approach to secure process fragment reuse in the BPaaS delivery model, we design a set of experiments on real QWS datasets [31,32].
                           
                              1.
                              The dataset [31] is a collection of quality of service information for 9 criteria of 365 real Web services which are collected using a Web Service Crawler Engine (WSCE). We call it dataset 1.

An updated QWS Dataset [32] that includes a set of 2507 Web services and their QWS measurements that were conducted in March 2008 using a Web Service Broker (WSB) framework. We call it dataset 2.

We assume that these two datasets contain a large proportion of concrete PFs which are provided by a set of process providers to be reused in a BPaaS and allow us to test our protocol on real data.

We first randomly select a set 
                           A
                         of abstract PFs to build a BPaaS view with respect to 
                           A
                        . Let us assume that 
                           A
                           =
                           {
                        crypto&security, Phone, SMS, Data, calculator, news, zipcodes, ISBN, location, Fax}. 
                           A
                         will be used to generate views on both dataset 1 and 2.

As previously discussed, concrete PFs instantiate abstract PFs. We consider each abstract PF can be implemented by a set of concrete PFs, i.e., clones. Fig. 7
                         (resp. Fig. 8
                        ) depicts for each AF in 
                           A
                         the number of concrete PFs deployed on BPaaS as well as the number of process providers (PPs) providing the abstract PF in dataset 1 (resp. dataset 2). Note for some abstract PFs, the number of concrete PFs is higher than PPs. For example, for SMS fragment, there are eight (resp. 33) concrete PFS in dataset 1 (resp. dataset 2) provided by seven (resp. 26) providers in dataset 1 (resp. dataset 2). This confirms the fact that a process curator may offer several clones of PFs having the same process provider. The effectiveness of applying a deterministic approximation algorithm in order to secure BPaaS views will be examined in the context of these datasets.


                        Fig. 9
                         (resp. Fig. 10
                        ) depicts the evolution of the quality of views with respect to K. We note that the quality of the views is maximum (i.e., equal to 1) when K
                        ≈10 in dataset 1. However, the quality of the views is maximum when K
                        ≈40 in dataset 2. This is mainly due to the size of the datasets; and also to the number of concrete PFs that implement the abstract PFs. For instance, the SMS is implemented using 8 concrete PFs in dataset 1 and 36 in dataset 2, which is in line with the results obtained.


                        Fig. 11
                         (resp. Fig. 12
                        ) depicts the evolution of the quality of views with respect to T. We note that the quality of the views is maximum (i.e., equal to 1) when T
                        =1 in dataset 1, and gradually declines up T
                        =8. This is due to the fact that we have at most 8 providers that deployed an abstract PF in dataset 1. However, the quality of the views is maximum (i.e., equal to 0.9) when K
                        =4 in dataset 2, and gradually declines up T
                        =30. As dataset 1, this is due to the fact that it exists at most 30 providers that deployed an abstract PF in dataset 2.

@&#RELATED WORK@&#

There is a huge literature on business process decomposition (fragmentation), and we briefly focus here on the work most relevant to our paper. There are two main objectives: One is to enhance the execution of the original process [9,10], and another is to allow reusing process fragments in future business process modeling. Most of the recent work has focused on the second objective, and addressed the issue of identifying process fragments with the right level of abstraction in order to reuse, and increase the ability to communicate and analyze them [11–13,15]. In [41], a measurement approach was introduced to quantitatively evaluate service identification. Based on a set of design metrics (including: service granularity, coupling, cohesion and business entity convergence), the weighted features are combined to conduct an overall evaluation of a service. Other papers (e.g., [12,36]) address the problem of managing large process model repositories. Paper [12] designed a business knowledge repository enabling the reuse of process fragments. Along the same lines, [36] proposed an indexing structure to support the fast detection of clones (i.e., duplicate fragments) in repositories.

Moreover, nowadays, with the emerging technology of cloud computing, organizations have increased their interest in business process and service outsourcing to cloud providers [3,16]. Paper [3] presents a cloud blueprinting approach, which, equips developers with a unified approach that lets them develop cloud applications on top of existing applications at any layer of the cloud stack from multiple cloud providers. [16] provides a customization tool helping to manage configuring of functional and non functional aspects related to a BPaaS offering. However, privacy and security risk issues are not addressed in this papers. [4,5] propose techniques to calculate the QoS values of services in cloud computing as well as composite services with complex structures.

There have been some works on security-aware compositions [42,43,26–28]. In [42], it is investigated the execution of BPEL processes in different cloud computing delivery models (IaaS, PaaS and SaaS), and showed security and trust issues that affect the business processes outsourcing. However, they did not provide a solution architecture for the investigated challenges and requirements. The work in [43] addresses some of the security problems that arise when outsourcing business processes in the PaaS delivery model. They provided an architecture which follows the compliance-by-design principle, allowing to remotely verify the correct execution of a business process. Works in [44,26–28] do not consider service provenance and focus on access control, data integration and provenance.

In our previous works [22,23], we proposed a privacy agreement model that spells out a set of requirements related to consumer's privacy rights in terms of how Web Service provider must handle privacy information as a bilateral SLA. Moreover, we provided a private data usage flow model to monitor at run time the compliance of requirements defined in the privacy agreement [24,25]. However, such approaches are not handling privacy preservation and do not deal with the availability of Web Services involved in a fragment of a business process and in a setting of the cloud.

In the same line, Bacon et al. [45,46] proposed a data tagging schemes and enforcement techniques to have an end-to-end information flow control (IFC). Since IFC security is linked to the data that it protects, both tenants and providers of cloud services can agree on security policy, in a manner that does not require them to understand and rely on the particulars of the cloud software stack in order to effect enforcement. She et al. [27] developed a three-phase composition protocol integrating flow control to enforce access control in composite services. For that, they considered composition time access control validation.

The paper is an extension of our earlier works [29,30] in which we formalized the reuse of process fragments in the cloud, and introduced the notion of anonymous process fragments for privacy-preserving business activities of organizations. To the best of our knowledge, our work described in this paper is the first to address the availability and confidentiality issues at the same time when reusing process fragments in the BPaaS delivery model.

@&#CONCLUSION@&#

Cloud computing and Business Process as a Service are new emerging delivery models offering the possibility to Business Process Outsourcing and enabling the enterprises to focus on their competencies. In this paper we investigated the security issues when developing a new process-based application in BPaaS. We firstly proposed an anonymization-based approach to preserve the business activities of an organization. However, we demonstrated that it is not sufficient to guarantee availability for process fragments reuse in BPaaS. For that, we extended it with the vision of diverse view of multi-tenants BPaaS. Furthermore, we presented the costs of both confidentiality and availability to be ensured at BPaaS level when reusing fragments. As a perspective, we would like to study distributed and elastic BPaaS in the cloud.

@&#ACKNOWLEDGMENTS@&#

The authors would like to thank the anonymous reviewers for their valuable comments and suggestions to improve the paper. This work was supported by the French Association Nationale de la Recherche et de la Technologie (ANRT) under CIFRE contract 1169/2010 between Université Paris Descartes and SOMONE France. Portions of this work were supported by National Science FoundationGrants CPS-1329979, Science and Technology Center CCF-0939370; by an NPRP grant from the Qatar National Research Fund; and by sponsors of the Center for Education and Research in Information Assurance and Security. The statements made herein are solely the responsibility of the authors.

@&#REFERENCES@&#

