@&#MAIN-TITLE@&#An object-coding genetic algorithm for integrated process planning and scheduling

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           An object-coding GA is proposed for integrated process planning and scheduling.


                        
                        
                           
                           Operation sequences are used to represent chromosomes.


                        
                        
                           
                           An inferior selection mechanism is adopted for parent selection.


                        
                        
                           
                           A simplified version of crowding is proposed for replacement.


                        
                        
                           
                           A population degeneration is introduced to preserve population diversity.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Process planning

Jobshop scheduling

Genetic algorithm

Object-coding

@&#ABSTRACT@&#


               
               
                  Process planning and jobshop scheduling problems are both crucial functions in manufacturing. In reality, dynamic disruptions such as machine breakdown or rush order will affect the feasibility and optimality of the sequentially-generated process plans and machining schedules. With the approach of integrated process planning and scheduling (IPPS), the actual process plan and the schedule are determined dynamically in accordance with the order details and the status of the manufacturing system. In this paper, an object-coding genetic algorithm (OCGA) is proposed to resolve the IPPS problems in a jobshop type of flexible manufacturing systems. An effective object-coding representation and its corresponding genetic operations are suggested, where real objects like machining operations are directly used to represent genes. Based on the object-coding representation, customized methods are proposed to fulfill the genetic operations. An unusual selection and a replacement strategy are integrated systematically for the population evolution, aiming to achieve near-optimal solutions through gradually improving the overall quality of the population, instead of exploring neighborhoods of good individuals. Experiments show that the proposed genetic algorithm can generate outstanding outcomes for complex IPPS instances.
               
            

@&#INTRODUCTION@&#

Both process planning and scheduling functions are responsible for the efficient allocation and utilization of resources in manufacturing systems. Generally, these two functions are conducted sequentially (Usher & Fernandes, 1996). Process planning determines the selection and sequence of production operations, and essential manufacturing resources including machines and tools. The purpose of scheduling is to allocate the jobs and operations to limited manufacturing recourses in accordance with the process plan.

The dynamic manufacturing environment is susceptible to disturbances such as machine breakdowns, rush order arrivals and order cancellations. These uncertainties will cause deviations to the original process plans and schedules, and will affect the performance of a manufacturing system (Kumar & Rajotia, 2003). To cope with the unexpected disturbances, it is necessary to revise the process plan and the schedule dynamically. Integrated process planning and scheduling (IPPS) is proposed to integrate the process design, resource allocation and scheduling into a cohesive function to enhance the manufacturing feasibility and performance (Chryssolouris, Chan, & Suh, 1985).

For a manufacture order to produce n jobs (parts) on m machines in a jobshop or similar kind of flexible manufacturing environment, an IPPS system intends to generate the process plans for all n parts and the overall job-shop schedule concurrently, with the aim to optimize a manufacturing objective such as makespan. Massive research has been done respectively in the fields of process planning and jobshop scheduling. In contrast, there is only a limited number of research on IPPS. Due to the combination of the two optimization problems and the flexibilities in the manufacturing systems, large-scale IPPS problems are difficult to be solved with analytical approaches. Researchers have attempted to solve IPPS problems with various approximate approaches, for instance, evolutionary algorithms, tabu search, simulated annealing and ant algorithms. The authors’ research group has investigated on the applications of multi-agent system (MAS) in IPPS. Recently, work has been conducted on the combination of MAS and metaheuristics in solving IPPS problems. This hybrid approach is to adopt the excellent search ability of metaheuristics and autonomy of agents for dynamic adaptation in the manufacturing environment. A MAS structure has been designed to support a variety of metaheuristics for process planning and scheduling/rescheduling in dynamic manufacturing environments. For instance, an enhance ACO algorithm has been established to demonstrate the applicability of the hybrid MAS-ACO solution approach for IPPS problems. In addition to ACO, a novel genetic algorithm (GA) has also been implemented in the MAS architecture to evaluate the hybrid MAS-GA approach for IPPS. Descriptions on the design and implementation of the MAS architecture are available in Zhang et al. (Zhang, Wong, & Fung, 2013). This current paper presents details of the GA-based IPPS solution approach. The GA is denoted as an object-coding genetic algorithm (OCGA). In essence, the classical GA has been enhanced in three aspects to cater for the IPPS problem domain: (1) real objects (machining operations in IPPS) are used to represent chromosomes, and corresponding genetic operations are proposed; (2) an unusual selection method, based on the inferior selection mechanism, is adopted to give inferior solutions more chances to reproduce; (3) a simplified version of crowding is proposed to cater for the object-coding representation and release the selection pressure; and (4) a population degeneration mechanism is introduced to further preserve the population diversity.

The rest of the paper is arranged as follows: Section 2 is a review of relevant literature on GA implementation in process planning and scheduling; representation of the IPPS problem is presented in Section 3; the OCGA algorithm is elaborated in Section 4; experiments and results on benchmark problems are displayed in Section 5; the last section is the conclusion which restates the findings and suggests future research.

@&#LITERATURE REVIEW@&#

Several earlier research attempts on the IPPS problem were reported in 1980s and 1990s. For instance, Chryssolouris, Chan, and Cobb (1984) modelled the IPPS as two decision-making stages and used a decision matrix for the combination of process planning and scheduling. In Shaw and Whinston (1985), a knowledge-based system was established to collaborate process planning and scheduling. Chen and Khoshnevis (1993) embedded a process planning module into a scheduling system. Some researchers established IPPS models in terms of different levels of flexibilities, and they also attempted to solve these models with analytical approaches (Li, Gao, Shao, Zhang, & Wang, 2010; Tan, 1998). However, because of the manufacturing and product complexities, process planning and scheduling problems are NP-hard which are impossible to achieve optimal solutions by traditional accurate algorithms with reasonable efforts (Kim, Park, & Ko, 2003). A wide variety of approximate algorithms have been adopted to find near-optimal solutions efficiently. Various heuristics of this kind have been tried, such as Genetic Algorithms (Morad & Zalzala, 1999), Simulated Annealing (Li & McMahon, 2007), Particle Swarm Optimization (Guo, Li, Mileham, & Owen, 2009), ant algorithm (Leung, Wong, Mak, & Fung, 2010), a new hybrid algorithm (HA) (Li, Shao, Gao, & Qian, 2010), an imperialist competitive algorithm (ICA) (Lian, Zhang, Gao, & Li, 2011), etc. Reviews of literature relevant to IPPS and MAS-based IPPS solution approaches are available in previous publications (Wong, Leung, Mak, & Fung, 2006) and not repeated here. The review in this section is focused on GA applications in IPPS problems.

Davis reported one of the first attempts to use GAs for jobshop problems (Davis, 1985). Thereafter GAs have been widely implemented in this field (Falkenauer & Bouffouix, 1991; Fang, Ross, & Corne, 1993; Gen, Tsujimura, & Kubota, 1994; Zhang, Zhang, & Nee, 1997). Some researchers contributed their efforts to improve GA-based jobshop scheduling systems, examples include GA for jobshop scheduling problems with alternate routings (Hussain & Joshi, 1998), and population-diversity-oriented selection procedures (Brizuela & Sannomiya, 1999), etc. A significant amount of relevant research was identified with implementation approaches based on different GA encoding schemes and different genetic operators. GAs were also hybridized with local search algorithms for the performance enhancement (Cai, Wu, & Yong, 2000; Liu & Xi, 2006; Resende, Goncalves, & Mendes, 2005). Particularly, Simulated Annealing (SA) was hybridized with GA to enhance the neighborhood search and avoid premature convergence (Wang & Zheng, 2002). A Tabu Search (TS) approach was also applied to enhance the performance of GA (Ombuki & Ventresca, 2004). Wong, Chan, and Lau (2003) used a hybrid of fuzzy and genetic approach for solving the process sequencing problem, which was based on a fuzzy expert system incorporated with GA for machining cost optimization according to the cost–tolerance relationship.

In IPPS consideration, GAs were traditionally applied individually (Morad & Zalzala, 1999), or combined with other optimization methods (Ye & Zhang, 2000). Lee and Kim (2001) reported the application of a simulation based GA to deal with the IPPS problem. Kim et al. (2003) proposed a symbiotic evolutionary algorithm (SEA) based on the idea of parallel search. Moreover, GA-based IPPS systems were also enhanced by adjusting the evolutionary procedure adaptively (Zhang & Gen, 2010), or improving the genetic representations and operator schemes (Li, Gao, Shao, Zhang, & Wang, 2010). Qiao and Lv (2012) proposed an improved genetic algorithm (IGA) which could generate good results for an IPPS benchmark problem.

Majority of GA implementations in constrained problems adopt an encoding/decoding scheme with which genes on chromosomes are represented by numbers or letters (Michalewicz, 1996). Commonly used encoding approaches include binary encoding, permutation encoding, real number encoding, and general data structure encoding (Gen & Cheng, 2000). According to the structure of encodings, encoding approaches can be classified into two types: one-dimensional encoding and multi-dimensional encoding (Gen & Cheng, 2000). With one-dimensional encoding, genes are arranged orderly in a succession. One-dimensional encoding is commonly adopted in previous implementations. However, for some complex problems, multi-dimensional encoding has to be adopted to encode chromosomes into a more complex structure. For instance, with two-dimensional encoding, a chromosome mostly looks like a matrix or a graph, for which Vignaux and Michalewicz (1991) provided a successful implementation in a linear transportation problem. Fixed-length and binary coded strings for encodings have dominated GA implementations. Theoretically, it is evident that they are the most appropriate approaches since they are amenable and could be easily implemented (Goldberg, 1990). Other categories of representation scheme include the real number representation (Lucasius & Kateman, 1989), and such an application for JSP problem has been provided by Gen et al. (1994). This kind of approach to represent chromosomes with strings of numerical numbers is generically named numerical-number representation.

Some researchers found that the numerical-number representation scheme might severely limit the ability of GAs to explore the search space (Koza, 1994). This limitation is intensified in the IPPS problem domain. Zhang et al. (1997) proposed a GA for the process planning and scheduling problem. They used operations directly for the representation of genes on chromosomes, however, only one job was considered in their approach. Wong et al. (2003) also applied a non-numerical-number representation scheme in their fuzzy-GA approach for machining process sequencing problems. Their approach behaved much like permutation encoding since all operations were labeled with consecutive integer numbers, and the algorithm followed the paradigm of permutation-encoding based GAs.

In summary, conventional GAs possess several core functions and traditional practices which have some unavoidable weaknesses in the IPPS problem domain.

                           
                              (i)
                              Representation schemes – for a practical IPPS model with consideration of alternative machines, alternative processes and alternative sequences, the transformation between practical operations and numerical numbers is usually quite difficult and rigid, which substantially ruins the flexibility of practical applications. Besides, not properly designed encoding schemes may have negative impacts on the algorithm performance.

Selection methods – inspired by the mechanism of nature selection, major GAs usually adopt the analogy of natural evolution strategy directly where relatively good individuals are more likely to be selected to breed the next generation. “Elitism” is regarded as one of the best strategies for genetic evolution (De Jong, 1975). However, the analogy of natural evolution may cause premature convergence or even search stagnation.

Crossover and mutation – Crossover and mutation are two main methods for neighborhood construction. Dedicated crossover and mutation approaches have to be defined when applying GAs in different areas. For instance, the one-point or two-point crossover which is commonly used for numerical optimization is not suitable for the IPPS problem, restricted by complex relationships among operations. To ensure that the process precedence constraints were not violated, job-based crossover approaches were adopted in many of the GA-based IPPS implementations (Pinedo, 2012; Qiao & Lv, 2012).

Replacement schemes – the replacement scheme is to define how to yield the next generation from current population. A large proportion of GAs adopts a complete replacement scheme with which the current population is completely replaced by the offspring. De Jong (1975) proposed another kind of replacement schemes called crowding, where only a fraction of the population propagate offspring and replace old ones at each generation, aiming to preserve the population diversity. There are several variants of De Jong's crowding scheme, the most widely-known ones are deterministic crowding (Mahfoud, 1995), restricted tournament selection (Harik, 1995), and the struggle genetic algorithm (Grüninger & Wallace, 1996). The complete replacement scheme is commonly used in the field of numerical optimization problems and performs very well. However, for large-scale discrete problems, the evolution process becomes more unpredictable. The GA may quickly converge or get trapped in a suboptimal solution, especially for those instances with high flexibility. Crowding and its variations are proposed to tackle this issue through preserving population diversity and maintaining multiple solutions, but they also introduce selection pressure to measure the similarity of individuals.

It is difficult or almost impossible to extend conventional GA approaches with numerical-number representations to solve the IPPS problem. Therefore, the GA approach proposed in this paper abandons the numerical encoding and uses a sequence of operations directly a chromosome. The significance of the proposed approach is not only to save the computational efforts, but also to enhance the search abilities.

This paper is to deal with the n jobs m machines IPPS problems in flexible jobshop type of manufacturing systems. Each job refers to the production of a single piece of product of a given design, comprising production operations which have to be processed on several non-identical machines. That is, a part or product is regarded as a job, and each job is composed of a series of operations. An operation can be processed on a dedicated set of alternative machines, and operations may have conjunction, disjunction and precedence relationships between them. Processing is non-preemptive. Setup and internal logistic consumption is deemed negligible or included in the processing time of the corresponding operation. For a job, operations are not allowed to overlap, that is, it is not legitimate to produce more than one operations of the same job at the same time. Also a machine is not allowed to process more than one operations at a time.

One aim of the IPPS is to increase manufacturing flexibilities. Three kinds of flexibilities: operation flexibility, sequencing flexibility and processing flexibility are taken into consideration in this paper. The IPPS system normally works in static environment, but it should also have abilities to react to changes and disruptions like machine breakdowns or rush order, updating current schedule or rescheduling if necessary.

To represent an IPPS problem, the complete set of feasible and alternative production processes and sequences for each part are recorded in an AND/OR graph. As an illustrative example, Fig. 1
                     (a) and (b) presents feature descriptions of part 1 and part 2, respectively. Sequence relationships between features are given in Fig. 1(c). Corresponding machining operations include turning (F1.1–F1.3, F2.1–F2.6), milling (F1.4–F1.5, F2.1, F2.7), and drilling/reaming/boring (F1.6). An OR-link depicts a pair of alternative features’ sequences for part 2, which are

                        
                           (i)
                           F2.1, F2.2 (turing) → F2.7 (milling) → …

F2.1, F2.7 (milling) → F2.2 (turning) → …

Assume that a lathe m
                     1, an NC lathe m
                     2, a milling machine m
                     3 and a drilling machine m
                     4 are available for processing all machining operations.

The AND/OR graphs in Fig. 2
                      are used to depict the relevant operations, sequence relationships and alternative process routes for the two sample parts respectively. The AND/OR graph model is denoted as D = (O, A), where O is a set of nodes, and A is a set of directed arcs. Two types of nodes are introduced in our AND/OR graph representation: operation nodes and dummy nodes (Wong et al., 2006). The operation nodes correspond to machining operations denoted by 
                        
                           O
                           
                              j
                              .
                              i
                           
                           k
                        
                     , which means an operation with index number i of job j to be processed on machine k. The start and end dummy nodes of job j are denoted by Sj
                      and Ej
                     , respectively. A directed arc from 
                        
                           O
                           
                              
                                 j
                                 1
                              
                              .
                              
                                 i
                                 1
                              
                           
                           
                              k
                              1
                           
                        
                      to 
                        
                           O
                           
                              
                                 j
                                 2
                              
                              .
                              
                                 i
                                 2
                              
                           
                           
                              k
                              2
                           
                        
                     implies that 
                        
                           O
                           
                              
                                 j
                                 1
                              
                              .
                              
                                 i
                                 1
                              
                           
                           
                              k
                              1
                           
                        
                      is an immediate predecessor of 
                        
                           O
                           
                              
                                 j
                                 2
                              
                              .
                              
                                 i
                                 2
                              
                           
                           
                              k
                              2
                           
                        
                     . An OR relationship in the AND/OR graph represents a pair of alternative process routes, where only one route is needed to finish the job. Additional input data like alternative machines and corresponding processing times are listed in Table 1.

The OCGA is a variant of GAs with object-coding representation. Its features include the real-object represented chromosome, customized genetic operations, and reconstructed evolutionary strategies. The “object” refers to practical components, such as the job, the machine, the machining operation, etc. Specifically in the IPPS problem, an “object” refers to a machining operation on a dedicated processing machine.

The OCGA follows the classical GA approach in the overall procedure whose single iteration is mainly composed of the population maintenance, selection of parent individuals, genetic operations, and population evolution, as shown in Fig. 3.

In major cases, the numerical-number representation can easily be implemented in GAs to solve the jobshop type of scheduling problems where the process plans for each job are usually fixed. Qiao and Lv (2012) proposed a dual-numerical-number coding for their improved genetic algorithm to cope with the IPPS model with full consideration of flexibilities of process plans. The dual-numerical-number coding uses two integer numbers to represent a gene and has two preliminary stages to generate operation sequences which are then encoded as chromosomes.

According to Qiao and Lv (2012), all operations involved in AND or OR relationships are combined and sequenced in different ways to form basic process routes for each job. All feasible process plans of the job can be yielded from shifting processing machines of each operation on these basic process routes. Shifting the processing machine of any operation results a new process plan. After that, a subsequent stage is carried out to combine process plans of different jobs to get a complete operation sequence for the IPPS instance which is then encoded as a chromosome. A chromosome based on Qiao and Lv's approach for the sample IPPS instance given in Section 3 is as follows:

                           
                              
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                    
                                       1,1
                                       2,3
                                       1,1
                                       1,1
                                       2,3
                                       2,3
                                       1,1
                                       2,3
                                       2,3
                                       1,1
                                       2,3
                                    
                                 
                              
                           
                        
                     

where the first number of a gene is a job index, and the second is the index of a chosen process plan.

With such encoding approach, the process plan information is not visible in the chromosome representation and extra means is required to store and interpret the detailed meanings of codes. In general, the information held by each gene may be used by genetic operators during the search procedure. With the numerical-number representation, however, this kind of information is hidden by codes or not directly accessible. It may then be necessary to prepare all feasible solutions before exploring the whole search space. This is a tedious task and the heuristic ability will be affected significantly. Furthermore, in cases where an operation can be processed by alternative machines, even if it is only required to choose another machine for the operation, the mutation operator will affect a series of genes on the chromosome, and hence the process plan for the job hosting this operation will be entirely replaced. Apparently this encoding/decoding scheme is rigid and not efficient for IPPS problems. It also infers that the GA approach with numerical-number representation is not potentially suitable for dynamic situations.

In this paper, genetic representation in OCGA is based on real objects. That is, a chromosome is expressed in terms of the operation sequence directly. A chromosome representing the sample IPPS instance for the two parts is presented in Fig. 4.

With the AND/OR
                        
                         graph model, the GA is required to handle a population of existing sequences to obtain improved sequences in terms of incorporated criteria. Obviously the object-coding chromosome exposes much more information which is directly accessible during the heuristic process. The relative positions of any two operations on a chromosome reflect the precedence relationship between them. For instance, if 
                           
                              O
                              
                                 
                                    j
                                    1
                                 
                                 .
                                 
                                    i
                                    1
                                 
                              
                              
                                 k
                                 1
                              
                           
                         is a predecessor of 
                           
                              O
                              
                                 
                                    j
                                    2
                                 
                                 .
                                 
                                    i
                                    2
                                 
                              
                              
                                 k
                                 2
                              
                           
                        , 
                           
                              O
                              
                                 
                                    j
                                    1
                                 
                                 .
                                 
                                    i
                                    1
                                 
                              
                              
                                 k
                                 1
                              
                           
                         must precede 
                           
                              O
                              
                                 
                                    j
                                    2
                                 
                                 .
                                 
                                    i
                                    2
                                 
                              
                              
                                 k
                                 2
                              
                           
                         on any chromosomes.

This function is to stabilize the size of the population in order to avoid population degeneration (population size keeps decreasing) or overgrowth (population size keeps increasing). Assume that the population size has to be stabilized to a constant N(N > 1). At the beginning of the algorithm, an initial population has to be prepared (N individuals have to be generated). Besides, at the beginning of subsequent iterations, if the population size is larger than N, a number of individuals have to be eliminated whilst if the number of individuals in the population is less than N, new individuals have to be generated to fill the vacancies.

With regard to the generation of new individuals, a random search based approach is adopted in this paper. Assume that an invisible crawler is put onto the AND/OR graph for an IPPS instance. The crawler starts from a start node of any job, and then crawls over the whole graph under the restriction of precedence relationships, until it collects a series of operations to finish all jobs. The trace of the crawler presents a feasible solution.

Individual evaluation is closely related to the optimization criteria. In this paper, the objective of the OCGA is to minimize the makespan which is the primary criterion. For evaluating individuals, in addition, machine utilization is also adopted as a secondary criterion. The affinity value for an individual Si
                         is calculated by

                           
                              (1)
                              
                                 
                                    A
                                    
                                       (
                                       
                                          S
                                          i
                                       
                                       )
                                    
                                    =
                                    α
                                    ×
                                    
                                       C
                                       i
                                    
                                    +
                                    β
                                    ×
                                    M
                                    
                                       U
                                       i
                                    
                                 
                              
                           
                        where A(Si
                        ) is the affinity value of Si; Ci
                         and MUi
                         are the makespan and machine utilization of Si
                         respectively. α and β are two positive constants and α is usually much bigger than β. Intuitively, an individual solution with a smaller makespan is a better solution. Thus, a larger affinity value implies a poor quality in Si
                        . In case if the makespans of two individuals are equal, the one possessing smaller machine utilization is better.

A given number of operators carry out the genetic operations simultaneously, each of which selects a pair of parent individuals according to the affinity values. The OCGA adopts an inferior selection method. Worse individuals are given more chances to yield offsprings. A linear rank approach is implemented for the selection. Firstly, all individuals are ordered by their affinity values in ascending order, so that each individual owns a fixed position in the sequence (the position index) and better individuals are positioned at the front. The position index of Si
                         is denoted as pos(Si
                        ) and the probability of taking Si
                         is calculated by

                           
                              (2)
                              
                                 
                                    p
                                    
                                       (
                                       
                                          S
                                          i
                                       
                                       )
                                    
                                    =
                                    
                                       
                                          2
                                          ×
                                          p
                                          o
                                          s
                                          (
                                          
                                             S
                                             i
                                          
                                          )
                                       
                                       
                                          N
                                          ×
                                          (
                                          N
                                          +
                                          1
                                          )
                                       
                                    
                                 
                              
                           
                        where N is the population size. It is clear that a worse solution possesses a higher probability to be selected since the corresponding position index pos(Si
                        ) is relatively larger. The inferior selection method intends to mine good genes in poor individuals before they die out. Better individuals are remained in the population. When the overall quality of the population is improved, old individuals become relatively worse and their selection probabilities grow accordingly. The inferior selection method can obviously preserve the population diversity and can somehow maintain multiple individuals.

In general, genetic operations in GA include crossover and mutation. With regard to the IPPS problem, the operation flexibility, sequencing flexibility and processing flexibility bring in three different dimensions. Hence the genetic operations must correspond to all three flexibilities to fulfill search toward different dimensions. In OCGA, the following GA operators are implemented for neighborhood construction: crossover (to recombine process plans of different jobs); mutation of shifting genes’ loci (to reorder partial operations in a parent sequence); and mutation of shifting processing machines (to alter processing machine for some operations).

Crossover is one of the most important neighborhood construction methods for GAs. With regard to the IPPS consideration, due to the sequencing and processing flexibilities, a job can have alternative process plans, that is, different sets of operations oi
                            or the same set of operations are sequenced in different orders. The crossover for the OCGA is similar to the Precedence Preserving Order-based Crossover (POX) (Lee, Yamakawa, & Lee, 1998), with the aim to exchange operations of a same job between two individuals, as well as preserve precedence relationships. As there may exist alternative process plans in a job, the crossover operator in OCGA also provides a chance for a job to choose an alternative process plan.


                           Fig. 5
                            depicts the approach of the crossover operator. P1 and P2 are two parent chromosomes, and C1 and C2 are initially two empty arrays. In essence, crossover for the OCGA is to copy operations of different jobs from two parent chromosomes in a specific way to fulfill the recombination. The approach is summarized as follows:

                              
                                 •
                                 firstly select a job randomly as a feature job (job 1 in the case);

copy operations of job 1 from P
                                    1 to corresponding positions on C
                                    1, and copy operations of job 1 from P
                                    2 to corresponding positions on C
                                    2;

fill vacancies in C
                                    1 with operations other than those of job 1 from P
                                    2, and fill vacancies in C
                                    2 with operations other than those of job 1 on P
                                    1 orderly from left to right;

eliminate vacancies on C
                                    1 and C
                                    2, and two child individuals can then be obtained.

The mutation of shifting genes’ loci is to rearrange partial operations’ order. However, relative positions of two operations of the same job cannot be shuffled since it may violate the precedence relationship. Hence an orderly moving method is proposed for the OCGA. The shifting genes’ loci perform on one child individual obtained from the crossover, say, C
                           1 in Fig. 5.

                              
                                 •
                                 Initially, make a copy of C
                                    1, named C
                                    3;

randomly select two loci on C
                                    3, say L
                                    1 and L
                                    2. If operations on L
                                    1 and L
                                    2 belong to the same job, eliminate C
                                    3 and terminate.

for operations on L
                                    1 and L
                                    2 not belonging to the same job, handle C
                                    3 as follows: assume that the two operations on L
                                    1 and L
                                    2 belong to J
                                    1 and J
                                    2 respectively

                                       
                                          -
                                          eliminate the operation on L
                                             1, and then move those operations of J
                                             2 backwards to fill the vacancies one by one until the operation on L
                                             2 is moved. A vacancy will then appear on L
                                             2;

move operations of J
                                             1 between L
                                             1 and L
                                             2 forward to fill the vacancies one by one; the last vacancy is then filled by the original operation on L
                                             1. Those operations between L
                                             1 and L
                                             2 but not belonging to J
                                             1 or J
                                             2 are remained.


                           Fig. 6
                            illustrates the shifting genes’ loci, where the directed arcs show the movements of operations, numbers on which indicate the movement priorities. Finally, a new mutated individual C
                           3 is obtained.

The mutation of shifting processing machines is exerted on the other child individual which is not mutated with shifting genes’ loci, that is, C
                           2 in Fig. 5. It denotes that each gene on the chromosome has a very small probability pm
                            (usually pm
                            < 0.1) to change its processing machine. An overview of this mutation is given in Fig. 7
                           , where the process machine for 
                              
                                 O
                                 
                                    1
                                    ,
                                    4
                                 
                                 4
                              
                            shifts from machine No. 4 to machine No. 3.

Intuitively, crossover and shifting genes’ loci will not change the relative positions of any two operations of the same job. Hence all children are feasible since no genetic operations that violate precedence relationships are carried out. However, strict proof for this issue needs to be investigated intensively in future research.

A simplified version of crowding is implemented for the population replacement. Only a fraction of the population is selected to reproduce, and partial old individuals are replaced at each generation. De Jong's crowding and its variations usually need to measure the similarity of children to the old individuals, and most similar old individuals are most likely to be replaced. But in the context of discrete problems with high flexibility and real-object representation, the similarity measurement may be quite difficult or it may introduce heavy computing pressure. In the IPPS problem domain, alternative process plans for each job and non-identical machine set for each operation substantially increase the difficulty to use Hamming-distance, Euclidean distance or Common-edge distance for the similarity measurement.

The simplified crowding approach for the OCGA is:

                           
                              •
                              
                                 r pairs of parents are selected in the parent selection stage;

around 4 × r children are reproduced in the stage of genetic operations (as discussed in Section 4.5.2, shifting gene's loci may not produce new individuals, so the number of children cannot be exactly 4 × r);

all 2 × r selected parents are replaced by the offspring.

Obviously, the new population size will exceed the original size N. Therefore, after population replacement, the worst individuals are eliminated immediately until the new population size is dropped to 
                           
                              N
                              ×
                              (
                              1
                              −
                              R
                              )
                              :
                              0
                              ≤
                              R
                              <
                              1
                           
                         where R is the degeneration ratio. This is another mechanism to further enhance the ability to maintain population diversity, that is, the degeneration ratio R is introduced to reduce the population size below the original level. The shortage of individuals will be replenished at the next population maintenance stage.

The procedure of processing the sample IPPS instance by OCGA is summarized as follows. Assume that the set of individuals in the population at iteration i is denoted by Gi
                         and only one pair of parent individuals P
                        1 and P
                        2 are selected for propagation at each iteration. Three child individuals C
                        1, C
                        2, C
                        4 and possibly the fourth child C
                        3 are generated. The overall procedure of
                         the OCGA can be presented as follows:

                           
                              
                                 
                                 
                                    
                                       Iteration 
                                             i
                                           starts:
                                    
                                    
                                       While(the population size<N){
                                    
                                    
                                         Generate a new solution to cover the individual shortage.
                                    
                                    
                                       }
                                    
                                    
                                       Select a given number of parent individuals for propagation. (
                                             
                                                P
                                                1
                                             
                                           and 
                                             
                                                P
                                                2
                                             
                                           are selected.)
                                    
                                    
                                       Perform genetic operations and generate offspring. (
                                             
                                                
                                                   C
                                                   1
                                                
                                                ,
                                                
                                                   C
                                                   2
                                                
                                                ,
                                                
                                                   C
                                                   3
                                                   *
                                                
                                                ,
                                                
                                                   C
                                                   4
                                                
                                             
                                           are generated.)
                                    
                                    
                                       Replace parent individuals with their offspring. (
                                             
                                                
                                                   G
                                                   i
                                                
                                                ←
                                                
                                                   (
                                                   
                                                      G
                                                      i
                                                   
                                                   ∖
                                                   
                                                      {
                                                      
                                                         P
                                                         1
                                                      
                                                      ,
                                                      
                                                         P
                                                         2
                                                      
                                                      }
                                                   
                                                   )
                                                
                                                ∪
                                                
                                                   {
                                                   
                                                      C
                                                      1
                                                   
                                                   ,
                                                   
                                                      C
                                                      2
                                                   
                                                   ,
                                                   
                                                      C
                                                      3
                                                   
                                                   ,
                                                   
                                                      C
                                                      4
                                                   
                                                   }
                                                
                                             
                                          )
                                    
                                    
                                       While(
                                             
                                                c
                                                u
                                                r
                                                r
                                                e
                                                n
                                                t
                                                
                                                p
                                                o
                                                p
                                                u
                                                l
                                                a
                                                t
                                                i
                                                o
                                                n
                                                
                                                s
                                                i
                                                z
                                                e
                                                >
                                                N
                                                ×
                                                
                                                   (
                                                   
                                                      1
                                                      −
                                                      R
                                                   
                                                   )
                                                
                                                :
                                                0
                                                ≤
                                                R
                                                <
                                                1
                                             
                                          ){
                                    
                                    
                                         Eliminate the worst individual. (
                                             
                                                
                                                   G
                                                   i
                                                
                                                ←
                                                
                                                   G
                                                   i
                                                
                                                
                                                   ∖
                                                   {
                                                
                                                t
                                                h
                                                e
                                                
                                                   worst
                                                   individual
                                                   }
                                                
                                             
                                          )
                                    
                                    
                                       }
                                    
                                    
                                       If(Terminate criteria are not fulfilled){
                                    
                                    
                                            
                                          
                                             
                                                i
                                                ←
                                                i
                                                +
                                                1
                                             
                                          . Go to next iteration.
                                    
                                    
                                       }
                                    
                                    
                                              Else {Terminate!}
                                    
                                 
                              
                              
                                 
                                    *
                                    
                                       
                                          C
                                          3
                                       
                                     may not exist.
                              
                           
                        
                     

The proposed approach will be repeated for a number of iterations until the terminate criteria are all fulfilled. A run of the OCGA on the sample IPPS instance (given in Figs. 1 and 2) generates the schedule in Fig. 8, from which it is easy to verify that all assumptions and constraints given in Section 3 are satisfied.

For benchmarking, the IPPS problem test bed proposed by Kim et al. (2003) is adopted for the experiments. The test bed is composed of 18 separate jobs including 300 operations. Different combinations of the 18 jobs form 24 problem sets of different problem complexity and strength of flexibilities.

For system implementation, the software programs of OCGA were developed in JAVA with MySQL database. Experiments in this paper were conducted on a personal computer equipped with Intel core i-5 CPU (M520 2.4 gigahertz) and 6 gigabytes RAM.

The objective of OCGA was to minimize the makespan. The coefficients were set as follows: population size 
                        
                           N
                           =
                           100
                        
                     ; number of genetic operators working synchronously 
                        
                           r
                           =
                           7
                        
                     ; probability for crossover 
                        
                           
                              p
                              c
                           
                           =
                           1
                        
                     ; probability for shifting genes’ loci 
                        
                           
                              p
                              e
                           
                           =
                           1
                        
                     ; probability for shifting process machines 
                        
                           
                              p
                              m
                           
                           =
                           0.06
                        
                     ; degeneration ratio 
                        
                           R
                           =
                           0.09
                        
                     . The termination criterion was that the algorithm would terminate if a better solution could not be obtained in successive 2500 iterations. Every problem of the test bed was repeated for 11 times and best solutions with smallest makespans at each time were recorded. The main reason for conducting 11 runs of simulations was to compare the performance of OCGA with the other algorithms which also recorded results of similar simulation runs.

A series of regular experiments with fixed coefficients setting as listed above were conducted on all 24 problems, and best and mean results were recorded and compared with other three algorithms: the cooperative co-evolutionary genetic algorithm (CCGA) (Potter & De Jong, 1994), symbiotic evolutionary algorithm (SEA) (Kim et al., 2003), and an improved genetic algorithm (IGA) (Qiao & Lv, 2012). This experiment is to figure out the global performance of the proposed approach.


                        Table 2 lists the best makespans in 11 runs of repeated experiments. It shows the results of 14 problems have reached their lower bounds, which implies that the OCGA has found optimal solutions for these 14 problems. For the other 10 problems, the best results were just a bit higher than their lower bounds, which would be even closer to optimal solutions. In conclusion, Table 2 reveals that the OCGA possesses wonderful search ability.


                        Table 3
                         accounts
                         for mean makespans of SEA, CCGA, IGA and OCGA. The column “improved rate” depicts the relative improved ratio of the OCGA result compared to the minimum result yielded by the other three algorithms. A positive improved rate indicates that the OCGA presents the best result for the corresponding problem. It shows that the OCGA achieved significant improvements in 12 out of the 24 problems whose improved ratios were larger than 3.5 percent. And for another 11 problems the OCGA just made a slight improvement or did a little worse. It is because that most results of these 11 problems obtained by all four algorithms almost reached the optimal, and insignificant differences in these results were basically due to the randomness of heuristics. Furthermore, the OCGA performed better in more complex problems: problems No. 16–24. It also shows that the computing time for each problem increased steadily as the complexity of problems increases, but it was always controlled at an acceptable level.

An extra experiment was performed on the most complex problem No. 24 under an extreme situation where the algorithm was allowed to run for unlimited number of iterations so that the OCGA could sufficiently explore the solution space. It can be known from Table 3 that
                         in regular experiments, the OCGA can usually find good solutions for the problem No. 24 in around 50 seconds. In the extreme test, the OCGA ran for around 400 seconds (around 20,000 iterations) and yielded the solution with makespan equaled to 457. The schedule of this solution can be found in Fig. 9.

The outstanding search ability and high performance of the OCGA are mainly due to the following factors. First of all, the real-object representation enables the algorithm to easily perform neighborhood search, and the whole solution space can be covered. Then, three genetic operations can explore the search space in three different directions. Crossover helps the algorithm to move to unexplored solution, whilst two kinds of mutation enable the algorithm to extensively search an area. Finally, the population can be gradually evolved and a high population diversity can always be maintained under the two evolutionary mechanisms: the inferior selection and population degeneration.

Experiments under the ordinary selection method with the same context setting as experiment 1 were repeated. But in the phase of selecting parent individuals, all individuals were sequenced in descending order so that good individuals possessing higher probabilities to reproduce. Fig. 10 depicts the comparison of mean makespans under the inferior and ordinary selection methods.

With regard to problems No. 1–10, the OCGA could easily achieve good solutions close to the lower bounds, hence the difference in selection methods is not significant. However, for more complex problems No. 11–24, the improvements of mean makespans using the inferior selection method are obvious. Particularly, iterative data from iteration 1250–3500 (when the search procedure becomes relatively stable) of two experiments conducted on problem No. 24 using the ordinary and inferior selection methods are compared to demonstrate the transition of population diversity during a relatively stable evolutionary process.

The best-so-far makespans and makespans’ standard deviation of the population at each iteration are recorded and mapped on a sequence diagram as shown in Fig. 11. The best-so-far makespan and standard deviation are abbreviated to ms and s.d. respectively in this graph. It shows that the standard deviation of the population using inferior selection fluctuates around 11 and shows no downward trend, whilst standard deviation using ordinary selection usually falls to 0 and stays at a very low level. This phenomenon reflects that the inferior selection method can maintain much higher population diversity during the heuristic process.

The experiment similar to the one in experiment 1 was repeated under the setting of different degeneration ratios. Here simple problems No. 1–15 and complex problems No. 16–24 are considered separately, and the results are presented in Fig. 12(a) and (b), respectively.

In Fig. 12(a) and 
(b), 
                           
                              R
                              =
                              0
                           
                         means there is no population degeneration. As R grows, more inferior individuals in the population are eliminated and more new individuals are introduced at each iteration. Fig. 12(a) shows that mean makespans at 
                           
                              R
                              =
                              0
                           
                         for problem No. 2, 3, 8 and 11 are significantly much higher. It reveals that population degeneration does have effects to prevent quick premature convergence. For other simple problems, there are no significant differences. The reason may be that optimal solutions to these problems can be easily reached, then the impact of population degeneration is not that obvious.

In Fig. 12(b), as the degeneration ratio increases, mean makespans for major problems go downward and then upward. The valley point usually appears at around 
                           
                              R
                              =
                              0.09
                           
                        . The reason for the downward trend is clear that newly introduced individuals at each iteration increase the probability to find better solutions. But the following upward trend is mainly because that a high degeneration ratio may disturb the evolutionary coherence, that is, offspring may be wiped out of the population quickly and too many new individuals successively pour into the population, which will certainly impede the population's evolution and convergence.

@&#CONCLUSION@&#

A variant of GA, named object-coding GA (OCGA), has been implemented to solve the IPPS problem. The OCGA uses operation sequences directly as chromosomes. Genetic operators including crossover and mutation, therefore, have to be customized to cope with the new genetic representation. In addition, the OCGA adopts an inferior selection method to select parents for propagation. A simplified version of crowding and a degeneration ratio factor are introduced to accommodate the population evolution. The combined effect of the unique approaches, including object-coding, inferior selection, modified replacement and degeneration ratio, leads to the preservation of high population diversity and yield of outstanding results. Experiments on benchmark problems have confirmed the performance of the systematic approach.

The focus of the current article is on the design and implementation of OCGA. From simulation experiments, it is obvious that OCGA is able to generate process plans and schedules for complex jobshop problems. The results, in terms of makespans, are very well converged and outperform the other algorithms in many of the test problems. Regarding the validity of the solutions, the process priority and precedence relationship of each job is governed by the AND/OR graph representation, and these process constraints are incorporated in the genetic operators in OCGA. In our IPPS research, we have attempted to deal with the validity issue in the AND/OR graph model, and the correctness of the solution algorithms are evaluated with the graph modelling and corresponding mathematical programming methods. This is not the focus of the current paper and will be reported in separate publication.

As future work, OCGA can be extended to cope with the process planning and scheduling requirements of other manufacturing scenarios, for instance, assembly operations, dynamic process planning and rescheduling.

Furthermore, there is great potential to extend and apply the object-coding representation to other discrete problems where decision variables are related to discrete elements. For example, “cities” in the traveling Salesman Problem (TSP) where can be conveniently be regarded as “objects” with the approach in OCGA.

@&#ACKNOWLEDGMENT@&#

The work described in this paper is fully supported by a grant from the Research Grants Council, University Grants Committee, Hong Kong (Project Code HKU 718809E).

