@&#MAIN-TITLE@&#Specifying model changes with UMLchange to support security verification of potential evolution

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We present a security verification approach which can deal with software evolution.


                        
                        
                           
                           It includes tools to analyze whether evolution preserves a security property.


                        
                        
                           
                           The tool can compute all possible evolution paths of the given model.


                        
                        
                           
                           We also present the UML profile UMLchange used for specifying potential evolutions.


                        
                        
                           
                           UMLchange makes our approach independent from specific modeling tools.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Model evolution

Security verification

UML profile

Tool support

@&#ABSTRACT@&#


               
               
                  In model-based development, quality properties such as consistency of security requirements are often verified prior to code generation. Changed models have to be re-verified before re-generation. If several alternative evolutions of a model are possible, each alternative has to be modeled and verified to find the best model for further development.
                  We present a verification strategy to analyze whether evolution preserves given security properties. The UMLchange profile is used for specifying potential evolutions of a given model simultaneously. We present a tool that reads these annotations and computes a delta containing all possible evolution paths. The paths can be verified wrt. security properties, and for each successfully verified path a new model version is generated automatically.
               
            

@&#INTRODUCTION@&#

A significant portion of software development nowadays is based on models. Especially in safety or security critical domains, modeling offers advantages such as formal specification and automated code generation. The formal semantics of models allow us to specify recurring security requirements and security assumptions on the system environment. This way knowledge on prudent security engineering is encapsulated as annotations in models. The models can be verified with regard to certain properties such as consistency of security requirements. Such verification is performed by dedicated analysis tools [1–3].

However, systems are neither developed in one step nor are they carved in stone. Hence, the task of evolving software systems such that the desired security requirements are preserved through a system's lifetime is of great importance in practice. We propose a model-based approach to support the evolution of software systems and preserving consistency of security requirements. Our approach allows the verification of potential future evolutions using an automatic analysis tool. An explicit model evolution implies the transformation of the model and defines a difference ∆ between the original model and the transformed one. The proposed approach supports the definition of multiple evolution paths, and provides tool support to verify evolved models based on the delta of changes. This idea is visualized in Fig. 1
                     : The starting point of our approach is a software system model M which was already verified against certain security properties. Then, this model can evolve within a range of possible evolutions (the evolution space). We consider the different possible evolutions as evolution paths each of which defines a delta ∆
                        i
                     . The result is a number of evolved system models M
                     
                        i
                     ′. The main research question is “Which of the evolution paths leads to a target model that still fulfills the security properties of the source model?”.

Theoretically, one could simply re-run the security analysis done to establish the security of the original model on the evolved model to decide whether these properties are preserved after evolution. This would, however, result in general in a high resource consumption for models of realistic size, in particular since the goal in general is to investigate the complete potential evolution space (rather than just one particular evolution) in order to determine which of the possible evolutions preserve security. Also, verification efficiency is very critical if a continuous verification is desired (i.e. to determine in real-time and in parallel to the modeling activity whether the change preserves security).

We use models specified using the Unified Modeling Language (UML) and the security extension UMLsec [4]. UMLsec is given in form of a UML profile. Stereotypes are used together with tags to formulate the security requirements such as secrecy, integrity, and authenticity, and other security-relevant information. Constraints give criteria to determine if the requirements are met by the system design, by referring to a precise semantics of the used fragment of UML. The security-relevant information added by using stereotypes includes security assumptions on the physical level of the system, security requirements related to the secure handling and communication of data, and security policies that system parts are supposed to obey. Based on UMLsec models and the semantics defined for the different language elements, possible security vulnerabilities can be identified at an early stage of software development. One can thus verify that the desired security requirements, if fulfilled, enforce a given security policy. This verification is supported by a tool suite
                        2
                     
                     
                        2
                        Available online via 
                              http://carisma.umlsec.de
                           
                        
                      
                     [5].

In this paper we present a general approach for the incremental security verification of UML models regarding the consistency of security requirements inserted as UMLsec stereotypes. We discuss the possible atomic (i.e. single model element) evolutions annotated with certain security requirements according to UMLsec. Moreover, we present sufficient conditions for a set of model evolutions, which, if satisfied, ensure that the desired security properties of the original model are preserved under evolution. We demonstrate our general approach by applying it to a representative UMLsec stereotype, ≪secure dependency≫. As one result of our work, we demonstrate that the security checks defined for UMLsec allow significant efficiency gains by considering this incremental verification technique.

To explicitly specify possible evolution paths, we have developed a further UML profile, called UMLchange, that allows a precise definition of which model elements are to be changed in a model. Constraints can be defined to coordinate and define more than one evolution path (and thus obtaining the deltas for the analysis).

Note that UMLchange is not intended as a general-purpose evolution modeling language. While existing evolution specification or model transformation approaches (such as [6–10]) are primarily used as a tool to change models, we needed a notation that allows us to put evolution in the focus of analysis. Thus, UMLchange is specifically intended to precisely define possible evolution paths of models. This enables the investigation of the preservation of security requirements by evolution. Thus, UMLchange does not aim to be an alternative for any of the existing approaches mentioned above. It will be interesting future work to demonstrate how the results presented in this paper can be used in the context of those approaches.

A preliminary version of UMLchange has been presented under the name UMLseCh at the ECMFA'11 conference [11]. Meanwhile we have improved the language. While UMLseCh was a set of additional stereotypes to UMLsec, we have now extracted the evolution specific parts and elaborated them into the UMLchange profile. This separation of concerns allowed us to deeper investigate the possible evolutions of a model, resulting in new stereotypes enabling a more precise description of evolution and supporting more complex types of evolution. Moreover, former limitations have been smoothed out. UMLchange is now fully compatible to UML version 2.4. The new grammar makes it possible to annotate multiple independent change alternatives to a single model element. New changes such as moving or copying elements can now be modeled, which better matches the perception of the user of how the model could evolve. Finally, the separation of evolution descriptions into a new profile enables its application of the evolution analysis to other quality properties. However, this is not the focus of this paper. Here, we introduce the new profile and how it can be used to describe different evolutions. In particular we will explain the grammar used to describe additive changes, which has been omitted in [11]. We furthermore show how the specified evolution paths can be verified wrt. preserving security properties.

The remainder of this paper is organized as follows: The change-specific extension UMLchange is defined in Section 2. Section 3 explains our general approach for evolution-aware security verification. In Section 4, we give an overview of the verification tool and evaluate our approach in Section 6. We conclude with an overview of the related work (Section 6) and a brief discussion of the results presented (Section 7).

The UMLchange profile consists of multiple stereotypes that can be used for the description of changes in a model. The majority of the stereotypes of the profile (excluding ≪old≫ and ≪keep≫) describe changes (i.e. the change stereotypes). To enable the description of all possible changes to a UML model, the change stereotypes can be applied to any UML model element. This is indicated by the extension relationships targeting the meta class Element, the super class of all UML elements.


                     Fig. 2
                      provides some basic examples for using UMLchange. Class Redundant will be deleted. Class TooConcrete is replaced with the Interface IGeneral. A new element NewClass is inserted into the main package. Furthermore, class OuterClass will be moved to package Outside and the class FalseName will be renamed to CorrectName.

The components of the profile (see Fig. 3
                     ) are described in more detail below.


                     Secure dependency. To be able to demonstrate the UMLchange profile for evolution-aware security analysis, we give a short description of the UMLsec stereotype ≪secure dependency≫. A detailed explanation of all of the tags and stereotypes defined in UMLsec can be found in [13]. ≪secure dependency≫ can be used to label subsystems containing static structure diagrams. It ensures that the ≪call≫ and ≪send≫ dependencies between objects or subsystems respect the security requirements on the data that may be communicated across them, as given by the tags {secrecy}, {integrity}, and {high} of the stereotype ≪critical≫. More exactly, the constraint enforced by this stereotype is that if there is a ≪call≫ or ≪send≫ dependency from an object or subsystem C to an interface I of an object or subsystem D then the following conditions are fulfilled:
                        
                           •
                           For any message name n in I, n appears in the tag {secrecy} (resp. {integrity} resp. {high}) in C if and only if it does so in D.

If a message name in I appears in the tag {secrecy} (resp. {integrity} resp. {high}) in C then the dependency is stereotyped ≪secrecy≫ (resp. ≪integrity≫ resp. ≪high≫).

If the dependency goes directly to another object or subsystem without involving an interface, the same requirement applies to the trivial interface containing all messages of the server object.

Each change stereotype has the following tags: {ref}, {ext} and {constraint}. To enable the description of multiple independent changes at a model element (e.g. two independent additions, each adding one operation to a class), each of these tags is multi-valued.

Every change has an ID so that it can be referenced by other changes. The tag {ref} contains the change IDs for each change at the stereotype application. Each application of a change stereotype must at least have one ID. These IDs should be unique in the model scope. The change IDs are used in constraints and in change stereotype tags to relate their entries to the corresponding change. Examples for IDs are deleteTransition, some_Change and add2Operations.

Stereotypes cannot be applied to UML extension elements themselves. {ext} helps to describe changes of stereotype applications and their tagged values. Its format is:
                           
                              
                                 
                                    ChangeID
                                    =
                                    StereotypeName
                                    
                                       
                                          .
                                          TagName
                                       
                                    
                                    .
                                 
                              
                           
                        
                     

If a change is directed at a model element, no {ext} entry is necessary. If the change target is the extension of an element, {ext} follows a convention of most UMLchange stereotype tag values. Each entry has to be prefixed with the ID of the corresponding change so that entries in the value lists do not need to adhere to a certain order. If the target is a stereotype application, the name of the applied stereotype must be given. If a tagged value of a stereotype application is the target of the change, the stereotype name must be appended with the name of the targeted tag.

Every change may have constraints attached to it describing when the change may or may not take place. The corresponding tag {constraint} has the following format:
                           
                              
                                 
                                    
                                       
                                          
                                             ChangeID
                                             =
                                             
                                                
                                                   AND
                                                   
                                                      OtherChangeID
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                             
                                                
                                                   NOT
                                                   
                                                      OtherChangeID
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                             REQ
                                             
                                                OtherChangeID
                                             
                                             
                                                
                                                   ,
                                                   …
                                                
                                             
                                          
                                       
                                    
                                    .
                                 
                              
                           
                        
                     

The obligatory change ID is followed by a constraint that either forces another change to be simultaneously applied (AND(OtherChangeID)), excludes a change from being applied simultaneously (NOT(OtherChangeID)) or requires another change to be applied before the change in question (REQ(OtherChangeID)). A change may have more than one constraint. For ease of use, each constraint can either be a separate {constraint} entry or be part of a comma-separated list of constraints. Contradicting constraints lead to not including any of the conflicting changes.

A change to a model element can be of one of three basic types:
                           
                              •
                              deletion of an element from the model

addition of a new element to an existing model element

substitution of an element with another element.

Every possible evolution to a model can be described with one or more of these three types. The UMLchange profile offers the corresponding stereotypes to enable the description of the basic types.

The stereotype ≪del≫ is used to delete the targeted model element. It recursively deletes all model elements owned by the targeted element. Any connecting model elements (e.g. associations) are also deleted to preserve the validity of the model. If the target of ≪del≫ is the multi-valued tagged value of a stereotype application, this stereotype deletes all values of the tag.

The stereotype ≪add≫ serves the purpose of describing additions to model elements. ≪add≫ has to be applied to the elements which will own the new elements. If the target of ≪add≫ is a stereotype application, multi-valued tags receive additional values. Additions to single-valued tags are treated as substituting the old tagged value with the new value.

Applying ≪subst≫ allows us to describe the substitution of the targeted model element by one or more new model elements. The owner of the new substitute element (or elements) is the parent of the old substituted element. By substituting old elements, all of their contained elements are removed from the model, as well as all connection model elements. To prevent deleting contained elements, the stereotype ≪keep≫ must be applied accordingly (see Section 2.3.3). If tagged values are to be substituted, both single and multi-valued tags are completely substituted by the new values.

To describe the addition of new model elements or the substitutes of old elements, the stereotypes ≪add≫ and ≪subst≫ use expressions built with the UMLchange grammar. New elements are described by their metaclass names and pairs of keys and values. The new elements can be further defined by recursively describing contained elements. Changes on the grammar level are dependent on each other. Alternatives provide the ability to describe change variations. The elements described inside these alternatives are meant to be processed together.

The UMLchange grammar expressions are used in the {new} tag. Its format is:
                           
                              
                                 
                                    ChangeID
                                    =
                                    UMLchangeGrammarExpression
                                    .
                                 
                              
                           
                        
                     

For example, to describe the addition of a new class named someClass to a package, ≪add≫ has to be applied to the package. The appropriate {new} entry is:
                           
                              
                                 
                                    someID
                                    =
                                    
                                       
                                          Class
                                          
                                             
                                                name
                                                =
                                                someClass
                                             
                                          
                                       
                                    
                                    .
                                 
                              
                           
                        
                     


                        someID is the ID of the corresponding change. The UMLchange grammar is described in detail in Section 2.4.

In the example model in Fig. 4
                        , the integrity tag value for the Server is substituted with a high requirement. As the resulting model would be insecure, the integrity tag value for the Client is removed and a security preserving appropriate high value is added.

Although every change to a model can be described using the three basic stereotypes, these descriptions lead to long-winded and rather cumbersome applications of these stereotypes. It would, for example, be an arduous task to create a copy of an already existing model element in another package in the model, depending on how detailed the original element has been modeled. To ease the description of certain special forms of changes to a model, UMLchange provides several stereotypes for small modifications of model elements, moving and copying elements to another namespace, changes to multiple elements, and the description of more complex changes to a model.

Minor changes can be expressed by applying ≪edit≫ to a model element, which can be mapped to the substitution of old with new property values. Its tag {values} has the format:
                              
                                 
                                    
                                       ChangeID
                                       =
                                       
                                          
                                             KeyValuePairs
                                          
                                       
                                       
                                          
                                             ,
                                             …
                                          
                                       
                                       .
                                    
                                 
                              
                           
                        


                           KeyValuePairs represents the corresponding subset of the UMLchange grammar. The keys have to be valid attribute names of the targeted element. An example entry to change the name of a class to NewName and its visibility to private would be:
                              
                                 
                                    
                                       someID
                                       =
                                       
                                          
                                             
                                                name
                                                =
                                                NewName
                                                ,
                                                visibility
                                                =
                                                private
                                             
                                          
                                       
                                       .
                                    
                                 
                              
                           
                        

As with the description of new model elements, {values} entries can describe alternative evolutions using the correct syntax. Editing stereotype applications is not possible, as changes would amount to redefining the stereotype instead of its application. Editing tagged values is analogous to substituting old with new tag values.

For structural changes, ≪copy≫ is used to indicate that the targeted model element is to be duplicated in one or more comma-separated namespaces given in the tag {to}. ≪move≫ works in the same vein, but removes the targeted model element from its original owner and only allows one target namespace. While ≪copy≫ can be mapped to the basic addition of the original element and its contents to the target namespace, ≪move≫ can simply be mapped to a substitution of the owner of the changed element.

The format of {to} is:
                              
                                 
                                    
                                       
                                          
                                             
                                                ChangeID
                                                =
                                                
                                                   QualifiedNamespace
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                   
                                                      
                                                         
                                                            KeyValuePairs
                                                         
                                                      
                                                      
                                                         
                                                            ,
                                                            …
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                      ,
                                                      …
                                                   
                                                
                                             
                                          
                                       
                                       .
                                    
                                 
                              
                           
                        

The QualifiedNamespace needs to be qualified in so far that the uniqueness of the namespace in the model is guaranteed. The copied or moved model element in the target namespace can then be modified with KeyValuePairs using the same format as in the {values} tag of ≪edit≫. Multiple destination namespaces must be comma-separated. An example for an entry in {to} is:
                              
                                 
                                    
                                       
                                          
                                             
                                                copySomething
                                                =
                                                {
                                             
                                          
                                          
                                             
                                                
                                                mainPackage
                                                :
                                                :
                                                SubPackage
                                                
                                                   
                                                      name
                                                      =
                                                      NewName
                                                   
                                                
                                                ,
                                             
                                          
                                          
                                             
                                                
                                                
                                                   
                                                      mainPackage
                                                      :
                                                      :
                                                      SubPackage
                                                      
                                                         
                                                            name
                                                            =
                                                            OtherNewName
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       .
                                    
                                 
                              
                           
                        

This describes two copies of the targeted model element to the same SubPackage, renaming each one in the process. For obvious reasons it is not allowed to copy a model element to the same namespace as the source element without changing the name of the copied element.

If a stereotype application is the target, all of its tagged values are also copied to the targeted element. If the targeted element already has the stereotype applied to it, all tagged values are replaced in the process. It is not allowed to change the name of the stereotype, as this would change the applied stereotype itself.

In the example model (see Fig. 5
                           ) which uses ≪secure-links≫ [13], the Database is to be moved to its own node Database-Server. As there is a ≪secrecy≫ requirement at the dependency between the Webserver and the Database, the ≪Internet≫ link has to be substituted with an ≪encrypted≫ connection. Additionally, the adversary attacking the system is edited to be the custom attacker defined in [17]. ≪Internet≫ links would be vulnerable to this attacker, but since the link in question has already been substituted with an ≪encrypted≫ connection, this change does not invalidate security of the model.

Describing changes to expansive models can be hard to manage. If, for example, all applications of a certain stereotype in the model are to be removed, finding each and every application of it can be tedious task. UMLchange provides stereotypes to ease the process of describing changes to multiple elements. The changes can be focused on certain types of model elements or elements having a certain property.

≪del-all≫, ≪add-all≫ and ≪subst-all≫ are applied to the namespace in which the changes are to take place and can be mapped to multiple applications of the basic stereotypes. The {new} tag has the same syntax and semantics as the {new} tag of the respective basic stereotypes, while the {pattern} tag allows to identify the model elements in the namespace affected by the described change. The format of {pattern} is:
                              
                                 
                                    
                                       ChangeID
                                       =
                                       TargetedElementsPattern
                                       .
                                    
                                 
                              
                           
                        

The tag uses the same syntax as the {new} tag of the basic stereotypes. First the metaclass of the targeted elements must be given. For example, if the given metaclass is Class, then the changes would affect all classes in the namespace marked with the *-all stereotype. The affected elements can be further filtered by giving key value pairs defining certain attributes that the affected elements must possess. For example, to affect all dependencies having a certain supplier, the entry would be Dependency(supplier
                           =
                           somePackage::certainSupplier). Some further examples for entries in {pattern} are
                              •
                              
                                 Dependency(supplier=somePackage::certainSupplier,contents=Stereotype(name=secrecy))
                                       –
                                       
                                          all dependencies that have the supplier somePackage::certainSupplier and the stereotype application of ≪secrecy≫

Action(contents=Stereotype)
                                       –
                                       
                                          all stereotyped actions.

In the example model (see Fig. 6
                           ) based on a smart card life-cycle, the stereotype ≪locked-status≫ is to be added to the TERMINATED state. Applying this stereotype adds the constraint that the marked state may not have any outgoing transitions. To fulfill this requirement, ≪del-all≫ is applied to the region containing the state machine. Its application, named removeOutgoing, describes the removal of all outgoing transitions of the state TERMINATED, securing the model once again.

Describing complex changes with the UMLchange grammar can lead to long-winded grammar expressions. To provide a simpler method for modeling complex changes, UMLchange provides the ability to reference changes modeled in a namespace in the original model. The namespace containing the new model elements can be placed anywhere in the model.

To connect the new model elements to the correct owner in the original model, the owner relation has to be modeled in the namespace by modeling the owners of the new elements. However, it is not necessary to completely re-model the owning elements. For example, one would not need to re-model a class with all of its operations and attributes to model two new operations for it. Instead it is sufficient to just model the owning class and its name, as long as the class can be uniquely identified within the original model. To support this method, ≪old≫ is used to mark those incompletely modeled references to the original model. Complex additions using ≪old≫ can be mapped to additions to the original elements in the model.

In addition to that, ≪keep≫ is used to mark model elements that would otherwise be removed in the process of substituting a model element. Applications of ≪keep≫ can be mapped to the addition of the kept elements to the substitutes.

Its tag {adopter} has the format:
                              
                                 
                                    
                                       ChangeID
                                       =
                                       
                                          AdoptingElementDescription
                                       
                                       
                                          
                                             ,
                                             …
                                          
                                       
                                       .
                                    
                                 
                              
                           
                        

As each alternative description in {new} could describe different new elements, an entry in {adopter} must describe the receiving element for each alternative in {new}. If an alternative of {new} should not receive the element, its corresponding alternative in {adopter} is left empty. If, after a certain point, the remaining alternatives should not receive the element, then the entries can be omitted. Transferring model elements using ≪keep≫ is only supported when complex namespaces are used to describe the new model elements.

The tag uses the same syntax as the {new} tag of the basic stereotypes (see also Section 2.4). For example, let ≪subst≫ be applied to a class. Its {new} entry:
                              
                                 
                                    
                                       substClass
                                       =
                                       
                                          
                                             @
                                             newElements
                                          
                                       
                                       ,
                                       
                                          
                                             
                                                @
                                                otherVersion
                                             
                                          
                                       
                                    
                                 
                              
                           means that the old class is either substituted by the elements in the namespace newElements or alternatively by those elements in otherVersion. To keep an old contained element of substituted class, it has to be marked with ≪keep≫. If, for example, an old element is to be left out in the first alternative and should be adopted by a class NewClass when using the second alternative, the appropriate entry for {adopter} is:
                              
                                 
                                    
                                       substClass
                                       =
                                       {}
                                       ,
                                       
                                          
                                             Class
                                             
                                                
                                                   name
                                                   =
                                                   NewClass
                                                
                                             
                                          
                                       
                                       .
                                    
                                 
                              
                           
                        

In the example model (see Fig. 7
                           ), the dependency between the Algorithm interface and the Calculator UI receives both ≪call≫ and ≪high≫. The Calculator UI would violate the secure dependency property, but the UI class is substituted with the Secured Calculator UI, which adds a host of other attributes and operations to the previously relatively small class and provides security by using the appropriate ≪critical≫ application.

The UMLchange grammar can be used to describe changes adding new model elements to existing elements. Each change consists of one or more comma-separated descriptions of alternative evolutions. The format for these alternatives is:
                           
                              
                                 
                                    
                                       Description
                                    
                                    .
                                 
                              
                           
                        
                     

The description can be either a series of comma-separated simple element descriptions depicting new model elements or the single reference of a namespace wherein the additions to the model are shown.

An example for the UMLchange grammar is:
                           
                              
                                 
                                    
                                       
                                          
                                             
                                                Class
                                                
                                                   
                                                      name
                                                      =
                                                      NewClass
                                                   
                                                
                                             
                                          
                                          ,
                                       
                                    
                                    
                                       
                                          
                                             
                                                Class
                                                
                                                   
                                                      name
                                                      =
                                                      OtherNewClass
                                                      ,
                                                      visibility
                                                      =
                                                      private
                                                   
                                                
                                             
                                          
                                          ,
                                       
                                    
                                    
                                       
                                          
                                             
                                                @
                                                addClasses
                                             
                                          
                                          .
                                       
                                    
                                 
                              
                           
                        
                     

This example poses two alternative evolutions. The first adds two classes named NewClass and OtherNewClass, of which the second receives a private visibility. The second alternative references a namespace add-Classes in the model. The referenced namespace contains new model elements to be added to the original model, by either adding to old model elements using ≪old≫ or substituting model elements while keeping some of their contents using ≪keep≫.

Simple element descriptions (SED) succinctly describe a UML model element. The format of a SED is:
                              
                                 
                                    
                                       Metaclass
                                       
                                          KeyValuePairs
                                       
                                       .
                                    
                                 
                              
                           
                        

Each SED starts with the metaclass name of the new element. Every UML metaclass of an actual non-abstract model element can be used.

Apart from that, simple comma-separated key-value pairs can be given to set the properties of the new model elements, ranging from common properties (e.g. name) to connection-specific ones (e.g. source and target for an association). The format of a key-value pair is:
                              
                                 
                                    
                                       key
                                       =
                                       value
                                       .
                                    
                                 
                              
                           
                        

When setting values for properties which reference other model elements in the original model, a sufficiently qualified string representation of the referenced model element has to be given. Assuming there are two different classes of the same name WantedClass in two different packages SuperPackage and SubPackage, referencing a class would need the containing package namespace to be incorporated into the attribute value. However, it is not necessary to add the model namespace to the reference, as the containing package namespace is sufficient to identify the referenced class.


                           Table 1
                            shows some metaclasses, their corresponding keys, their value type and a description. The value type of a key may be a String, an element of a given enumeration, or the adequately qualified reference to a model element.

Apart from describing the new model element itself, an additional optional key named contents with the format:
                              
                                 
                                    
                                       contents
                                       =
                                       
                                          SimpleElementDescriptions
                                       
                                    
                                 
                              
                           provides the means to describe further new model elements that are contained in the new element, e.g. an operation to be owned by a new class. The usage of the contents key is not restricted by a maximum depth.

To avoid long descriptions of complex additions, the UMLchange grammar allows to reference namespaces containing the new elements. The syntax for namespace referencing is
                              
                                 
                                    
                                       @
                                       NamespaceName
                                       .
                                    
                                 
                              
                           
                        

The namespaces referenced by the namespace name must be placed in the scope of the original model, but it is not necessary to place them in the same scope where the changes will take place. Connecting the new elements of the namespace to the original model is accomplished by modeling part of the target model element and application of the ≪old≫ stereotype (see Section 2.3.3).

Other stereotypes of the UMLchange profile use subsets of the UMLchange grammar to provide a consistent syntax (see Table 2
                           ).

The tag {values} of stereotype ≪edit≫ uses the same key-value pairs to describe changes to model element attributes, as does {to} of ≪copy≫ and ≪move≫. The target of the copy or move operation is an adequately qualified namespace equivalent to the model element references used in simple element descriptions. The descriptions of the targeted elements of the *-all stereotypes using {pattern} are the grammar's simple element descriptions, as is the target element description of {adopter}.

Although UMLchange originates from UMLseCh, differences between the two profiles exist. While UMLseCh allowed multiple applications of the same stereotype to the same model element, this is not allowed in UML 2.x. Hence, to make UMLchange compliant to UML, the stereotypes and tagged values have been adopted to enable the definition of multiple changes to a single model element.

With UMLseCh, it was very hard to describe more complex alternative evolutions which can now be easily modeled using the namespaces and simple grammar expressions. ≪keep≫ and ≪old≫ have been added to provide additional control when making complex changes to models.

The stereotypes ≪copy≫, ≪move≫ and ≪edit≫ also provide easier methods to make both minor changes and to duplicate model structures, while the stereotypes for changing multiple elements have been reworked to both allow a more precise pattern-matching.

While UMLseCh conceptually allowed us to change UML extensions, UMLchange provides the technical realization of these concepts, which prompted the change in syntax to certain tag values, i.e. the UMLchange grammar. The grammar further provides the additional ability to describe alternative evolutions to a model, as well as describing multiple independent changes of a type to the same model element, e.g. the independent addition of two stereotypes to a class.

To provide a formal foundation for the UMLchange profile, the verification of evolutions described with the profile is discussed in the following section.

The evolution information annotated with UMLchange stereotypes to the model elements is parsed into an internal representation. Based on this representation we can check whether an evolution path preserves the consistency of the security requirements, which is described in what follows.

As stated in the previous sections, all changes can be expressed with the basic change stereotypes (see Section 2.2). All other change stereotypes could be mapped to their basic counterparts. Hence, evolving a model means that we add, delete, or substitute elements of this model. A set of these changes is called a Delta. To distinguish between big-step and small-step evolutions, we will call “atomic” the modifications involving only one model element (or sub-element, e.g. adding a method to an existing class or deleting a dependency). In general there exist evolutions from model A to model B such that there is no sequence of atomic modifications for which security is preserved when applying them one after another, but such that both A and B are secure. Therefore the goal of our verification is to allow some modifications to happen simultaneously. A DeltaFactory could be used to create all possible permutations of changes that can be applied simultaneously without violating basic modeling principles of the UML.

Since the evolution is defined by additions, deletion and substitutions of model elements, we introduce the sets Add, Del, and Subs, where Add and Del contain objects representing model elements together with methods id, type, path, parent returning respectively an identifier for the model element, its type, its path within the diagram, and its parent model element. These objects also contain all the relevant information of the model element according to its type (for example, if it represents a class, we can query for its associated stereotypes, methods, and attributes). For example, the class “Customer” in Fig. 8
                         can be seen as an object with the subsystem “Book a flight” as its parent. It has associated a list of methods (empty in this case), a list of attributes (“Name” of type String, which is in turn a model element object), a list of stereotypes (≪critical≫) and a list of dependencies (≪call≫ dependency with “Airport Server”) attached to it. By recursively comparing all the attributes of two objects, we can establish whether they are equal.

The set Subs contains pairs of objects as above, where the type, path (and therefore parent) methods of both objects must coincide. We assume that there are no conflicts between the three sets, more specifically, the following condition guarantees that one does not delete and add the same model element:
                           
                              
                                 
                                    ∄
                                    o
                                    ,
                                    
                                       o
                                       ′
                                    
                                    
                                       
                                          o
                                          ∈
                                          Add
                                          ∧
                                          
                                             o
                                             ′
                                          
                                          ∈
                                          Del
                                          ∧
                                          o
                                          =
                                          
                                             o
                                             ′
                                          
                                       
                                    
                                    .
                                 
                              
                           
                        
                     

Additionally, the following condition prevents adding/deleting a model element present in a substitution (as target or as substitutive element):
                           
                              
                                 
                                    ∄
                                    
                                    o
                                    ,
                                    
                                       o
                                       ′
                                    
                                    
                                       
                                          o
                                          ∈
                                          Add
                                          ∨
                                          o
                                          ∈
                                          Del
                                       
                                    
                                    ∧
                                    
                                       
                                          
                                             o
                                             
                                                o
                                                ′
                                             
                                          
                                          ∈
                                          Subs
                                          ∨
                                          
                                             
                                                o
                                                ′
                                             
                                             o
                                          
                                          ∈
                                          Subs
                                       
                                    
                                    .
                                 
                              
                           
                        
                     

As explained above, in general, an “atomic” modification (that is the action represented by a single model element in any of the sets above) could by itself harm the security of the model. So, one has to take into account other modifications in order to establish the security status of the resulting model. We proceed algorithmically as follows: we iterate over the modification sets starting with an object o
                        ∈
                        Del, and if the relevant simultaneous changes that preserve security are found in the delta, then we perform the operation on the original model (delete o and necessary simultaneous changes) and remove the processed objects until Del is empty. We then continue similarly with Add and finally with Subs. If at any point we establish the security is not preserved by the evolution we conclude the analysis. Given a diagram M and a set ∆ of atomic modifications we denote M[∆] the diagram resulting after the modifications have taken place. So in general let P be a diagram property. We express the fact that M enforces P by P(M). Soundness of the security preserving rules R for a property P on diagram M can be formalized as follows:
                           
                              
                                 
                                    P
                                    
                                       M
                                    
                                    ∧
                                    R
                                    
                                       M
                                       Δ
                                    
                                    ⇒
                                    P
                                    
                                       
                                          M
                                          
                                             Δ
                                          
                                       
                                    
                                    .
                                 
                              
                           
                        
                     

To prove that the algorithm described above is sound with respect to a given property P, we show that every set of simultaneous changes accepted by the algorithm preserves P. Then, transitively, if all steps were sound until the delta is empty, we reach the desired P(M[∆]).

One can obtain these deltas by interpreting the UMLchange annotations presented in the previous section. Alternatively, one could compute the difference between an original diagram M and the modified M′. This is nevertheless not central to this analysis, which focuses on the verification of evolving systems rather than on model transformation itself.

To define the set of rules R, one can reason inductively by cases given a security requirement on UML models, by considering incremental atomic changes and distinguishing them according to a) their evolution type (addition, deletion, substitution) and b) their UML diagram type. In the following section we will spell-out a set of possible sufficient rules for the sound and secure evolution of class diagrams annotated with the ≪secure dependency≫ stereotype.

Incremental verification after change is a useful technique if only relatively small parts of the model need to be re-verified. In general, this is more challenging for security properties on behavioral models where small changes may impact the semantics in a non trivial way. To deal with this problem, a less local perspective of the system is useful: if the system model is built up on interacting components then the effects of changes to single components to the overall system security can be established if there exist a compositionality result for the security property under consideration. In other words, instead of re-verifying the complete system when modification is made to a small number of components, it suffices to re-verify the modified components only and apply the compositionality result. In the following we summarize two such compositionality results that can be applied in the context of evolution and security.

Communicating processes can be specified as sequence diagrams, and it is possible to reason about the security of the communication by means of a semantic model based on process composition and a cryptographic DSL (as it is done for example in UMLsec). In [26] a sound decision procedure is presented that given proof artifacts for Dolev–Yao secrecy on separate components can establish whether their composition will be security preserving or not. The proof artifacts considered are dependency trees that represent the information needed by an adversary to obtain secret messages and keys. Those trees can be calculated separately for each process, and to decide on the security of a given composition the respective trees are merged. This merging process is empirically more efficient than the complete re-verification of the composition, as we will discuss in Section 5.3.

Non-interference is an information flow property that relates the inputs and outputs of groups of users (typically high and low, that is privileged and unprivileged) for all possible runs of the system. This property can be specified for instance in state diagrams where the inputs and outputs are assigned to specific groups of users. For a deterministic version of this property defined in UMLsec it holds that:
                              Theorem 1
                              
                                 Let I
                                 =
                                 I|
                                    H
                                 
                                 ∪
                                 I|
                                    L
                                  
                                 and O
                                 =
                                 O|
                                    H
                                 
                                 ∪
                                 O|
                                    L
                                  
                                 a partition of the input and output alphabets of A
                                 ⊗
                                 B. If non-interference holds for an extension of the policy in I and O to the unspecified events in I
                                 
                                    B
                                 
                                 ∩
                                 O
                                 
                                    A
                                  
                                 in A and B, then non-interference holds on A
                                 ⊗
                                 B.
                              

In other words if both components are secure (non-interferent) their composition is also secure (for a proof see [46]). It is furthermore possible to verify that a component is non-interferent in a sound way using static analysis and unwinding techniques. This technique is a sound approximation: an exact verification of non-interference would require us in general to consider all possible input and output traces, which is in turn computationally unfeasible. For instance, assume there are only two possible kinds of input events to the system: a low event L and a high event H, parametric on a 64 bit long integer (that is for instance L(10), H(232)). Then to compute all possible outputs of the model one would have to consider at least 2128 inputs. However practical models usually contain a much smaller amount of internal transitions (usually less than 100). This number is the main input to the static approach presented in [46], allowing for practical verification, as observed empirically on models verified using a prototypical implementation of that technique.

In this section we demonstrate the incremental verification strategy by applying it to the case of the UMLsec stereotype ≪secure dependency≫, which is defined for class diagrams. The associated constraint requires that for every communication dependency (i.e. a dependency annotated ≪send≫ or ≪call≫) between two classes in a class diagram the following condition holds: if a method or attribute is annotated with a security requirement in one of the two classes (for example {secrecy
                        =
                        {method()}}), then the other class has the same tag for this method/attribute as well (see Fig. 8 for an example). In addition to that, the communication dependencies have to have the corresponding stereotypes applied to them. It follows that the computational cost associated with verifying this property depends on the number of dependencies. We analyze the possible changes involving classes, dependencies and security requirements as specified by tags and their consequences to the security properties of the class diagram.

Formally, we can express this property as follows:
                           
                              
                                 
                                    
                                       
                                          P
                                          
                                             M
                                          
                                          :
                                          ⇔
                                          ∀
                                          C
                                          ,
                                          
                                             C
                                             ′
                                          
                                          ∈
                                          M
                                          .
                                          Classes
                                          
                                          
                                             
                                                ∃
                                                d
                                                ∈
                                                M
                                                .
                                                dependencies
                                                
                                                   C
                                                   
                                                      C
                                                      ′
                                                   
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                ⇒
                                                C
                                                .
                                                critical
                                                =
                                                C
                                                '
                                                .
                                                critical
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where M.Classes is the set of classes of diagram M, M.dependencies(C, C′) returns the set of dependencies between classes C and C′ and C.critical returns the set of pairs (m,s) where m is a method or an object shared in the dependency and s∈{high, secrecy, integrity} as specified in the ≪critical≫ stereotype for that class.

We now analyze the set ∆ of modifications by distinguishing cases on the evolution type (deletion, addition, substitution) and the UML type.


                           Class: We assume that if a class 
                              
                                 C
                                 ¯
                              
                            is deleted then also the dependencies coming in and out of the class are deleted, say by deletions D={o
                           1,…,on
                           }, and therefore, after the execution of o and D in the model M (expressed M[o,D]) property P holds since:
                              
                                 
                                    
                                       
                                          
                                             P
                                             
                                                
                                                   M
                                                   
                                                      o
                                                      D
                                                   
                                                
                                             
                                             ⇔
                                          
                                       
                                       
                                          
                                             ∀
                                             C
                                             ,
                                             
                                                C
                                                ′
                                             
                                             ∈
                                             M
                                             .
                                             Classes
                                             /
                                             
                                                C
                                                ¯
                                             
                                             
                                                
                                                   ∃
                                                   d
                                                   ∈
                                                   M
                                                   
                                                      o
                                                      D
                                                   
                                                
                                             
                                             .
                                             dependencies
                                             
                                                C
                                                
                                                   C
                                                   ′
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                                
                                                   ⇒
                                                   C
                                                   .
                                                   critical
                                                   =
                                                   C
                                                   '
                                                   .
                                                   critical
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           and this predicate holds given P(M), because the new set of dependencies of M[o,D] does not contain any pair of the type 
                              
                                 x
                                 
                                    C
                                    ¯
                                 
                              
                           , 
                              
                                 
                                    C
                                    ¯
                                 
                                 x
                              
                           .


                           Tag in critical: If a security requirement (m,s) associated to class 
                              
                                 C
                                 ¯
                              
                            is deleted then it must also be removed from other methods having dependencies with C (and so on recursively for all classes 
                              
                                 C
                                 
                                    C
                                    ¯
                                 
                              
                            associated through dependencies to 
                              
                                 C
                                 ¯
                              
                           ) in order to preserve the secure dependencies requirement. We assume P(M) holds, and since clearly 
                              
                                 M
                                 .
                                 Classes
                                 =
                                 
                                    
                                       M
                                       .
                                       Classes
                                       /
                                       
                                          C
                                          
                                             C
                                             ¯
                                          
                                       
                                    
                                 
                                 ∪
                                 
                                    C
                                    
                                       C
                                       ¯
                                    
                                 
                              
                            it follows P(M[o,D]) because the only modified objects in the diagram are the classes in 
                              
                                 C
                                 
                                    C
                                    ¯
                                 
                              
                            and for that set we deleted symmetrically (m,s), thus respecting P.


                           Dependency: The deletion of a dependency does not alter the property P since by assumption we had a statement quantifying over all dependencies (C, C′), that trivially also holds for a subset.


                           Class: The addition of a class, without any dependency, clearly preserves the security of P since this property depends only on the classes with dependencies associated to them.


                           Tag in critical: To preserve the security of the system, every time a method is tagged within the ≪critical≫ stereotype in a class C, the same tag referring to the same method should be added to every class with dependencies to and from C (and recursively to all dependent classes). The execution of these simultaneous additions preserves P since the symmetry of the critical tags is respected through all dependency-connected classes.


                           Dependency: Whenever a dependency is added between classes C and C′, for every security tagged method in C (C′) the same method must be tagged (with the same security requirement) in C′ (C) to preserve P. In addition to that, the dependency has to be marked with the stereotypes corresponding to the used ≪critical≫ tags. So if in the original model this is not the case, we check for simultaneous additions that preserve this symmetry for C and C′ and transitively on all their dependent classes.


                           Class: If class C is substituted with class C′ and class C′ has the same security tagged methods as C then the security of the diagram is preserved.


                           Tag in critical: If we substitute {requirement
                           =
                           method()} in class C with {requirement′
                           =
                           method()′}, then the same substitution must be made in every class linked to C by a dependency.


                           Dependency: If a ≪call≫ (≪send≫) dependency is substituted by ≪send≫ (≪call≫) then P is preserved if the substitute dependency has the same subset of the stereotypes ≪secrecy≫, ≪integrity≫ and ≪high≫ applied to it. If this is not the case, we check for simultaneous additions that apply the required stereotypes to the new dependency.


                           Example. The example in Fig. 9
                            shows the Client side of a communication channel between two parties. At first (disregarding the evolution stereotypes) the communication is unsecured. In the packages Symmetric and Asymmetric, we have classes providing cryptographic mechanisms to the Client class.

Applied to the Channel is ≪add≫ describing two changes with the reference ID's add_symenc and add_asymenc specifying two possible evolution paths: merging the classes contained in the current package (Channel) with either Symmetric or Asymmetric.

Another application of ≪add≫, this time to the Client, describes the addition of either a pre-shared private key Ksym
                            (ak1) or a public key Kserver
                            of the server (ak2). To limit the allowed evolution paths for the model, the changes have constraints associated with them indicating that the addition of the symmetric and asymmetric mechanism have to be applied simultaneously with the addition of their respective keys (AND(ak1), AND(ak2)). The simultaneous addition of both keys is also forbidden (NOT(ak2)).

The two deltas, representing two possible evolution paths induced by this notation, can be then given as input to the decision procedure described for checking ≪secure dependency≫. Both evolution paths respect sufficient conditions for the consistency of the security requirement to be satisfied.

This section briefly describes the tool environment we have implemented to verify security properties of evolving models.

The approach of evolution-based security analysis with the UMLchange profile has been implemented in the model analysis tool CARiSMA.
                           3
                        
                        
                           3
                           
                              http://carisma.umlsec.de
                           
                         The tool is built on the basis of Eclipse and fully integrates into the Eclipse GUI by providing different views for defining analyses and presenting results to the user.

In order to analyze a model, the user has to define the analysis to be performed. The Analysis Editor provides a graphical user interface for the definition of analyses (see Fig. 10
                        ). The user can select the model he wants to analyze and choose one or more checks from a list of available checks. The different checks might require additional parameters. Therefore, the analysis editor displays a list of input fields for the currently selected check. The supported parameter types for a check are the primitives string, integer, float, and boolean, as well as folders and files. The analysis configuration is stored in a file which allows the user to repeat the analysis with the same configuration of parameters.

During an analysis, CARiSMA loads the model and triggers all checks listed in the analysis configuration. The results are displayed in the Analysis Result View. Each performed analysis is shown as a root entry while the checks are second level entries. The checks return as either success or failure based on the result of their execution, which is indicated by different icons in the result view. Each check entry may contain further subentries offering details about the execution of a check. Subentries may be simple status information for the user, warnings in case of precautionary findings (i.e. noteworthy, but the check can still be successful), and errors that express the reasons why the check fails.

In addition to the output presented in the analysis result view, CARiSMA generates a textual report. Each check can verbosely contribute to the report, e.g. by describing counterexamples for violated security properties or proposing improvements.


                        Analysis of evolution. Apart from allowing the static analysis of models, CARiSMA provides mechanisms for analyzing evolutions to models. This is supported by certain checks that can be selected when defining an analysis.

Basically, an evolution analysis follows the pipeline illustrated in Fig. 11
                        . The steps shown have to be followed in the given order, using checks provided by CARiSMA. After identifying the changes to a model (Step 1), a second component computes the sets of deltas from the changes (Step 2). When analyzing model evolution with respect to security or compliance, it is possible that a subset of the changes are valid evolutions while others are not. The delta computation component computes these subsets for analysis. The actual security checks are then performed on either the deltas (Step 3a) or the modified models themselves (Step 3b). Valid deltas and the corresponding models can be persistently stored (Step 4). The process is explained in more detail in Section 4.3. CARiSMA allows the user to convert a normal analysis to an evolution analysis by providing a context menu entry for automatic conversion.

Like Eclipse, CARiSMA has been implemented as a plugin based architecture. Using the modularity provided by this method, CARiSMA is distributed as plugins, of which the core plugin includes the main functionality. Furthermore, CARiSMA offers extension points facilitating the contribution of functionality of other plugins to provide different checks. CARiSMA can be started standalone as an RCP application or within an existing Eclipse. It is also possible to smoothly integrate it into existing modeling tools such as TOPCASED,
                           4
                        
                        
                           4
                           
                              http://www.topcased.org/
                           
                         IBM Rational Software Architect
                           5
                        
                        
                           5
                           
                              http://www.ibm.com/software/awdtools/swarchitect/
                           
                         or other tools based on Eclipse.

CARiSMA is kept as model-type independent as possible. The framework and the core components are model-type independent, while the checks are mostly model type specific. Checking security properties specified with UMLsec stereotypes is of course bound to UML. However, it is also possible to realize model-type independent checks. For instance, we offer an OCL check plugin that can read arbitrary constraints from a catalog file and evaluate them on the structural properties of a model regardless of its type.

Model access is provided via the Eclipse Modeling Framework (EMF) [18], which implements, among other tools, the OMG Meta Object Facility (MOF) specification [19]. It provides the basis for the metamodel implementation and allows us to work with models of arbitrary types.


                        Fig. 12
                         visualizes the overall architecture of CARiSMA. The CARiSMA core contains the graphical user interface and the routines for performing analyses, i.e. managing preferences, executing checks, etc. In order to enable the analysis of models of certain types, a metamodel wrapper plugin has to provide the EMF-based metamodel and register it at the CARiSMA core. The metamodel wrapper can further provide convenience functions for working with models of that type, e.g. for getting all elements of a certain type. The metamodel wrapper can be based on an existing metamodel implementation such as the Eclipse UML2 Plugin in case of UML models. Currently, we offer metamodel wrappers for UML2 and BPMN2. On top of the core and the metamodel wrappers, different plugins can be realized that contain the checks performed during model analysis. Some plugins, e.g. those checking UMLsec properties, might require further extensions of the metamodels such as the UMLsec profile offering security-related stereotypes. The evolution support will be explained separately in Section 4.3.

The CARiSMA core provides a blackboard architecture that allows checks to exchange data. Required data can be specified as a pre-condition in the metadata of a check. Data provided by a check can be specified as a post-condition.


                        Future contributions to CARiSMA. Users can easily contribute additional checks to CARiSMA. An extension point provides ability to define meta information of the check such as name, parameters, or conditions. The implementation of a checks is basically a simple Java class realizing the interface CarismaCheck provided by CARiSMA. The interface specifies the perform operations which will contain the actual model analysis of a check. The parameter values entered by the user are passed to that operation at runtime. The check also receives a reference to the framework to access the analyzed model and the blackboard as well as to generate output. For the latter, CARiSMA offers operations to append text to the analysis report and to create result entries. The report itself and the graphical components cannot be accessed by a check directly. The perform operation has to return a boolean expressing whether the check was successful.

Support for additional modeling languages can be added by creating a corresponding metamodel wrapper plugin. It has to provide an EMF-based metamodel implementation or import it from some existing plugin and register it at the CARiSMA core.

The components that provide the support for analyzing evolving models are shown in Fig. 13
                        .

Evolutions to a model are reflected by collections of change descriptions. A change consists of one or more exclusive alternative evolutions to a part of the model. These alternatives can then be broken down to one or more delta elements, which describe atomic changes to model elements. More specific, we support the description of the addition, deletion, substitution, editing and copying of model elements. The content of an alternative has to be applied in a single evolutionary step.

Changes can be constrained using the three constraint types AND, NOT and REQ. While AND forces another change to be applied simultaneously, meaning during the same evolutionary step of the model, NOT excludes the referenced change from being applied to the model in the same evolution. Finally, REQ ensures that the referenced change is applied to the model before the constrained change takes place. This is to make sure that dependent changes are applied in the correct order.

CARiSMA provides an interface to generate change descriptions (see Fig. 11, Step 1). Two implementations of this interface are incorporated into CARiSMA: the UMLchangeParser, which creates the change descriptions from UMLchange applications on the model [20], and the EMFDelta, which generates the change descriptions by computing the difference between the original and the evolved model using EMF Compare [21].

A delta is a set of the above mentioned delta elements. The elements in the set are the atomic changes that amount to a possible evolution to the model. The delta factory (Step 2) receives a collection of change descriptions and processes the change constraints and alternatives, thereby generating all possible permutations over the alternatives, including the empty set, while following the constraints imposed by the changes. The elements of each valid change permutation are stored as a delta.

A delta can be applied to the model using implementations of the IModifier interface (Step 3b). An existing implementation is the UMLModifier. The UMLModifier receives the original model, creates a copy of it and applies each atomic change described by a delta element to the model copy. The resulting model is stored for use in CARiSMA evolution-aware checks (Step 3a). To avoid unnecessary computation of model modifications, the models are lazily initialized only when a check needs the modified model for validation. Modifications are mainly executed via generic EMF methods, while the selection of UML-specific aspects are handled using a custom logic. It would therefore be easy to build other model-specific modifier implementations.

The existing CARiSMA evolution checks each receive the list of computed deltas and iterate over each delta while checking the validity of the delta's modifications. If any change leads a model violating the checked security property, the corresponding delta is removed from the list to prevent subsequent checks from unnecessarily checking this delta again.

The evolved models which passed all checks can then be persistently stored using the ModelExporter (Step 4), which is also able to store their corresponding deltas in an XML format alongside the models.

@&#EVALUATION@&#

The UMLchange profile and the approach of delta-based security analysis have been successfully evaluated in different case studies.

Besides adopting our approach to different security properties of UMLsec, we have also considered domain-specific properties. In the context of the EU project SecureChange
                           6
                        
                        
                           6
                           
                              https://www.securechange.eu
                           
                         we have developed new stereotypes for behavioral models, namely statecharts. In the Global Platform smart card specification [22], we can identify two properties: 1.) “For any execution, whenever the card is put in the TERMINATED state by means of a set status issued by a privileged application, then it should not be possible to revert to another state”, and 2.) “It should not be possible for an application that doesn't have the Card Terminate privilege to switch the card life cycle state to Terminated, whether via a SET STATUS command (if the application is a SD) or the invocation to the GPSystem.terminateCard() method”. These properties have been developed into the new stereotypes ≪locked status≫ and ≪authorized status≫. Furthermore, we have implemented the delta-based verification of these properties and successfully applied that to the evolution of the changes of the smartcard specification from version 2.1.1 to version 2.2 [23].

In order to evaluate the usability and applicability of UMLchange, we have organized a half-day workshop at an industrial partner which is a leading company for smart card solutions. The participants of the workshop have been technical experts with longtime experiences in UML and security modeling. During the workshop the new tool and the UMLchange notation have been presented to industrial practitioners. The presentation included an introduction into architecture, user interface, and functionality of the tool, as well as teaching the UMLchange notation. Furthermore, a live demo of the tool was given. Exercises have been elaborated in order to allow the practitioners to get started with the tool. After the workshop the practitioners were able to use the tool and to further evaluate the tool as “homework”.

The first impression of the practitioners was that UMLchange is a nice and powerful tool. The concept of UMLchange was rated with 4 (of maximal 5) points. The handling of the stereotype-based approach to describe evolution was rated with 3 points. The major problem is, that many modeling tools have only limited support for stereotypes and tagged values from the usability perspective. Especially, the UMLchange grammar for describing new elements was seen as problematic, as typographic errors can arise, e.g. when entering qualified names of referred model elements. To tackle this problem, one could implement an auto-completion tool that allows the user to select the referenced element from a list instead of typing its name manually. This feature is evaluated for the next version of CARiSMA.

Nonetheless, the practitioners rated the tool to be applicable in daily practice, if UML is thoroughly used for modeling and if the usability of the tool implementation was improved to meet industrial standards. The ability to evaluate potential evolution paths and alternative solutions at the same time was liked. The fact that the modeling of many arbitrary models just to find the valuable evolution path became dispensable was seen as a major argument for our approach, although the direct editing of the models would be easier. A thorough review of the basic concepts of UMLchange and the CARiSMA tool is contained in [24].

Another validation activity focused on the run-time behavior of a sound delta-based verification (as discussed in Section 3) compared to a complete re-verification of the changed model. The duration of the check for ≪secure dependency≫ implemented in the UMLsec tool behaves in a more than linear way depending on the number of dependencies. Table 3
                         shows a comparison between the running time of the verification
                           7
                        
                        
                           7
                           On a 2.26GHz dual core processor
                         on a class diagram where only 10% of the model elements were modified. One should note that the inefficiency of a simple re-verification would prevent analyzing evolution spaces of significant size, or supporting online verification (i.e. verifying security evolution in parallel to the modeling activity), which provides the motivation to profit from the gains provided by the delta-verification presented in this paper. Similar gains can be achieved for other UMLsec checks such as ≪rbac≫, ≪secure links≫ and other domain-specific security properties for smart-cards, for which sound decision procedures under evolution have been worked out (see [25]). For instance, the evaluation for evolving models marked with the ≪secure links≫ stereotype [17] showed that analyzing a model using the delta of changes is significantly faster than re-analyzing the modified model (see Table 4
                        ).

As discussed in Section 3, the incremental analysis is appropriated when small parts of the model need to be re-verified. In general, this is more challenging for security properties on behavioral models where small changes of the model may impact the semantics in a non trivial way. Nevertheless, this problem can be tackled by taking a less local perspective of the system: if the system model is built up on interacting components then the effects of changes to single components to the overall system security can be established if there exist a compositionality result for the security property under consideration. For instance, we have conducted experiments to measure the time of the composition compared to the overall re-verification run-time as depicted in Table 5
                         for the Dolev–Yao secrecy result we discussed in Section 3. Again, a significant time gain results from reusing information of previously verified components of the model. Since the compositionality result guarantees the security of the composition, a complete re-verification is not required.

@&#RELATED WORK@&#

Model-based development is nowadays a well accepted paradigm. The formal semantics of models allow us to verify them with regard to certain properties such as security requirements. Hence, there has so far been work on tools for analyzing security properties on models. Most approaches are dedicated to specific problems. Basin et al. have presented a tool for the analysis of access control properties in UML models [2]. Siveroni et al. developed a tool which performs static verification on models composed of UML class and state machine diagrams [3]. The UMLsec tool [13,14], which can be seen as a predecessor of CARiSMA, combines the analysis of various security properties in a single tool [12,15,16]. However, these tools did not target the situation of model evolution as in the case of CARiSMA and the UMLchange approach. In addition, the Eclipse-based architecture of CARiSMA enables a smooth integration into the secure development processes with existing modeling tools.

There are different approaches to deal with evolution that are related to our work. Within Software Evolution Approaches, [27] derives several laws of software evolution such as “Continuing Change” and “Declining Quality”. [28] argue that it is necessary to treat and support evolution throughout all development phases. They extend the UML metamodel by evolution contracts to automatically detect conflicts that may arise when evolving the same UML model in parallel. Similarly [29] discusses the verification of consistency through refinement, and [30] discusses consistency of models for incremental changes of models. These works can be integrated with the approach presented in this paper to enhance the detection of inconsistencies and conflicts. Our approach, however, focuses on the evolution of software systems while preserving security properties. [31] proposes an approach for transforming non-secure applications into secure applications through requirements and software architecture models using UML. However, the further evolution of the secure applications is not considered, nor verification of the UML models.

In the context of Requirements Engineering for Secure Evolution there exists some recent work on requirements engineering for secure systems evolution such as [32]. However, this does not target the security verification of evolving design models. A research topic related to software evolution is software product lines, where different versions of a software are considered. For example, Mellado et al. [33] consider product lines and security requirements engineering. However, their approach does not target the verification of UML models for security properties. Evolving Architectures is a similar context with a different level of abstraction. [34] discusses different evolution styles for high-level architectural views of the system. It also discusses the possibility of having more than one evolution path and describes tool support for choosing the “correct” paths with respect to properties described in temporal logic (similar to our constraints). Again, this approach is not security specific. On a similar fashion, but more focused on critical properties, [35] also discusses the evolution of Architectures.

The UMLchange notation was informally introduced in [36], however, there it was called UMLseCh and tightly bound to UMLsec. Note that UMLchange does not aim to be an alternative for any existing general-purpose evolution specification or model transformation approaches (such as [6–10]) or model transformation languages such as QVT [37] or ATL [38]. The latter offers the possibility to express model transformation rules for horizontal and vertical transformations from any source metamodel to any target metamodel. Since ATL was initially developed to answer the QVT RFC issued by the OMG (Object Management Group), it shares common requirements [39] with QVT. Some efforts to have graphical notations for transformation languages include UMLX [40], a graphical model transformation language that was also developed to answer the QVP RFP [41] issued by the OMG. MOLA (MOdeling transformation LAnguage) [42] is another graphical language for model transformations. The Epsilon framework offers both model analysis and transformation capabilities for EMF-based models [43]. However, security analysis is not in the focus of these frameworks. It will be interesting future work to demonstrate how the security results presented in this paper can be used in the context of those approaches, that is, whether the mentioned transformation approaches can be used to extract the relevant delta information which can then be plugged-in in the security preservation decision procedures. In particular, the Epsilon approach sounds promising since it is based on EMF and should be compatible to our tool implementation.

Tools for difference computation and analysis are discussed in [44]. It is obvious that one could integrate model differencing with security analysis. In this case, one would have two models as input and computes the delta in order to verify it. Currently, we are evaluating this idea. First results can be found in [20]. Very interesting in that area is also the approach presented in [45], which defines a profile for describing changes. However, that paper focuses on configuration management aspects and model merging. Security aspects or quality properties in general are not considered.

@&#CONCLUSION@&#

This paper focuses on the preservation of security properties of models given different evolution scenarios. We considered selected classes of model evolutions such as addition, deletion, and substitution of model elements based on UMLsec models. Assuming that the starting UMLsec diagrams are secure, which one can verify using UMLsec checks (e.g. implemented in CARiSMA), our goal is to re-use these existing verification results to minimize the effort for the security verification of the evolved UMLsec models. This is critical since simple re-verification would in general result in a high resource consumption for models of realistic size, especially if a continuous verification is desired (i.e. it should be determined in real-time and in parallel to the modeling activity whether the modeled change preserves security).

We achieved this goal by providing a general approach for the specification and analysis of a number of sufficient conditions for the preservation of different security properties of the starting models in the evolved models. The approach contains a novel UML profile, called UMLchange, which allows modelers to specify possible evolution paths of a model and to verify them with respect to quality properties such as consistency of security requirements. We demonstrated this approach at the hand of the UMLsec stereotype ≪secure dependency≫. Applications for the consistency of other UMLsec security requirements such as ≪secure links≫ can be found in [25]. The evolution of behavioral security properties of UMLsec is challenging to verify incrementally. Changes can be also specified with UMLchange for those properties, but the verification technique is different: compositionality leads to more suitable results (see [26] for Dolev–Yao, or [46] for non-interference).

The approach has been implemented in the analysis tool CARiSMA. It can parse the UMLchange stereotypes applied to model elements, compute all possible evolution paths, and verify whether they preserve the consistency of the security requirements. The industrial validation has shown that the approach enables secure model evolution. Evolving systems can be developed by pointing out possible security-violating modifications of previously secure models. We also showed that the implementation of the techniques described in this paper leads to a significant efficiency gain compared to the simple re-verification of the entire model.

Our work can be extended in different directions. So far we have researched the different classes of evolution and change types and successfully applied our approach to security properties. Besides supporting further security properties, it would be interesting to prove in more detail whether our approach is sufficient to handle other kinds of quality properties beyond security properties. Another direction of research is alternative source of evolution information. Instead of annotating models with UMLchange stereotypes, one could just compare two versions of a model to gain evolution information. We have recently started to implement such an approach [21] based on the model comparison framework EMFcompare [47]. However, such a solution is not as powerful as the approach presented in this paper. Model comparison is limited to two models and it has a higher resource consumption, which reduces the runtime advantages of evolution-aware security checks compared to re-verification of entire models. A detailed analysis of the drawbacks and an evaluation of whether the difference-based approach is sufficient are part of ongoing and future work.

@&#REFERENCES@&#

