@&#MAIN-TITLE@&#Programming with event loops and control loops – From actors to agents

@&#HIGHLIGHTS@&#


               
                  
                  
                     
                        
                           
                           The event loop architecture has a strong impact on actor programming.


                        
                        
                           
                           Main weaknesses concern asynchronous spaghetti and fragmentation.


                        
                        
                           
                           Control loops adopted in agent programming can be framed as an extension.


                        
                        
                           
                           It leads to a more procedural structure of programs yet preserving reactivity.


                        
                        
                           
                           It allows us to improve modularity, encapsulation and abstraction.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Event loops

Control loops

Concurrent programming

Actors

Agents

Agent-oriented programming

@&#ABSTRACT@&#


               
               
                  
                     Event loops are a main control architecture to implement actors. In this paper we first analyse the impact that this choice has on the design of actor-based concurrent programs. Then, we discuss control loops as the main architecture adopted to implement agents, and we frame them as an extension of event loops effective to improve the programming of autonomous components that need to integrate both reactive and proactive behaviors, in a modular way.
               
            

@&#INTRODUCTION@&#


                     Event loops are a control architecture pervasively adopted to govern the behavior of applications, in particular in those context where reactivity is an important aspect. Modern examples include Rich Internet Applications, based on HTM5 and JavaScript, and mobile applications, based on e.g., the Android platform. In this architecture, the control flow of an application is logically organized as an infinite loop waiting for events on an event queue. As soon as one event is available, it is fetched and a corresponding event handler is executed, if available. When the event handler execution is terminated, the control flow goes back waiting for the next event.

In the case of actors 
                     [4,5,27], the event loop architecture is brought down to the computational model of the basic first-class abstractions adopted to design the active part of programs, so that a system or application is organized in terms of a possibly large number of active entities whose execution is loop-based. This has a deep impact on programming. In the literature, the properties of the computational model of actors based on event loops have been already largely discussed (e.g., in [42]). What is missing instead is an analysis and discussion about the impact on the programming principles and discipline used to design computational entities encapsulating control and featuring degrees of reactivity and proactivity. This need is particularly relevant as soon as we consider the programming of complex actors, whose behavior could be articulated. In that case, clear principles and mechanisms are important to foster well-known properties such as modularity, encapsulation, extensibility, abstraction. Accordingly, a first contribution of this work is an analysis of this aspect, providing a first formalization of the behavior of actors based on event loops and considering programming examples based on reference technologies (Section 3).

Furthermore, to overcome the problems of event loops, we introduce and discuss control loops, typically adopted to define the execution cycle of agents in agent-oriented programming languages [56,11]. Besides agent-oriented programming, control loops have been adopted in different contexts in computer science. A main example is Autonomic Computing [38], where coarse-grained control loops – referred as MAPE (Monitor, Analyze, Plan, Execute) – are used to define the behavior of autonomic entities. More generally, control loops are used to define the execution cycle of computing systems – being them full applications or individual components – that must be autonomous, from a control point of view, and, at the same time, must be capable to react to changes in their surrounding environment, and act accordingly, given some design objective. In this paper then we develop an analysis and discussion of the value of control loops from a programming point of view, when adopted as control architecture to define the behavior of the first-class abstractions in concurrent programming (Section 4).

@&#RELATED WORK@&#

In the literature, there are works providing a comparison between the actor and agent abstractions [35,23,52], as well as between the programming abstractions provided by actor and agent languages [34]. However, as far as author׳s knowledge, there are no works discussing the impact that event loops and control loops have on programming, especially in the case of actor-based programming and agent oriented programming. A notable exception is [23], where authors discuss the extension of the event loop of an active object into a more sophisticated control loop of an agent. However, the main focus of that work is not about programming, so the impact at that level is not discussed.

The contribution of this paper is related to existing research work in the literature discussing the problem of integrating threads with event-driven programming, in particular in the context of object-oriented concurrent programming [12,3] and actors [2]. In [24] authors describe the approach used to implement the Scala Actors library unifying thread-based and event-based actors. An actor can suspend with a full stack frame (using the receive primitive) or it can suspend with just a continuation closure (using the react one). The first form of suspension corresponds to thread-based programming, the second form to event-based programming. Kilim [57] has been one of the first actor frameworks for Java using a Continuation Passing Style (CPS) technique to integrate ultra-lightweight threads and events. In particular, a weaver transforms methods identified by a @pausable annotation into CPS to provide cooperatively scheduled lightweight threads with automatic stack management [1] and trampolined call stack [21].

Besides the actor context, the dualism between multi-threaded and event-driven models is a well-known topic discussed in the literature in particular in the context of Operating Systems [39,43,63], as well as asynchronous I/O management. This paper is related in particular to those works that aim at integrating the models, so as to finally simplify programming and improve modularity, avoiding problems such as stack-ripping 
                     [1], in which the logical control flow between operations is broken across a series of callbacks. Recent approaches include AC [26], extending native languages such as C/C++ with constructs for asynchronous I/O; the asynchronous programming model of F# [58]; GHC Haskell, combining call-back based and thread-based communication abstractions [40]; TaskJava [19], proposing tasks as a new programming model for organizing event-driven programs in Java.

In the software design pattern literature, the pro-actor pattern has been introduced for event handling where long running activities are running in an asynchronous part [55]. It is based on callbacks, in particular a completion handler is called after the asynchronous part has terminated. The pro-actor pattern is an asynchronous version of the reactor pattern [55], which corresponds to the event loop architecture.

This work is an extended and revised version of a previous contribution [46]. This extension in particular includes a first formalization of event loops and control loops, which is useful to ease the discussion and comparison of the two control architectures.

In the literature and in the practice there are two basic ways to implement actors: without an explicit receive – like in the original model [27] – and with an explicit receive. Examples for the former case include ActorFoundry [37], SALSA [61] and Akka [6]. Examples for the latter case include Erlang [8] and Scala Actors as defined in [25]. Even if these could be considered equivalent from the computational model point of view, the two different programming models lead to actor programs with a quite different organization and shape.

Event loops are the main approach adopted to define the control architecture of actors in the former case. The behavior of an actor can be abstractly represented by an infinite loop (Algorithm 1) composed essentially by three main stages: 
                        Algorithm 1
                        Abstract version of a basic actor event loop. 
                              
                                 
                                    
                                    
                                       
                                          1: loop
                                          
                                       
                                       
                                          2: 
                                             
                                                msg
                                                ←
                                                
                                                   WaitForMsg
                                                
                                                (
                                                )
                                             
                                          
                                       
                                       
                                          3: 
                                             
                                                h
                                                ←
                                                
                                                   SelectMsgHandler
                                                
                                                (
                                                msg
                                                )
                                             
                                          
                                       
                                       
                                          4: 
                                             
                                                args
                                                ←
                                                
                                                   GetMsgArgs
                                                
                                                (
                                                msg
                                                )
                                             
                                          
                                       
                                       
                                          5: 
                                             ExecuteMsgHandler(h,args)
                                       
                                       
                                          6: end loop
                                          
                                       
                                    
                                 
                              
                           
                        

First, a message is retrieved from the mailbox, when available (line 2); then, a proper handler or method associated to the message is selected (line 3); finally, the selected handler – if any – is executed, before cycling again (lines 4 and 5). Three key points of the model are:
                        
                           •
                           pure reactive behavior – an actor starts working only if there is a message in the mailbox;

a macro-step (or run-to-completion 
                              [60]) semantics – the execution of a message handler is atomic, i.e., can be represented as a computational step atomically changing the internal state of the actor, and its external environment by delivering new messages or creating new actors.
                                 1
                              
                              
                                 1
                                 It is worth noting that the macro-step semantics does not necessarily imply that inner actions are executed serially: in a pure actor model, actions may be processed concurrently.
                              
                           

strict no-blocking discipline – handlers cannot block or engage infinite loops: they must be necessarily finite computations manipulating the internal state of the actors and using asynchronous primitives to send messages and create new actors.

From a formal viewpoint, event loop based actors can be modeled as reactive machines mapping input streams of messages into output streams of messages. In the following we sketch a model inspired by the approach introduced in [9] for describing the behavior of reactive computations in general. An actor can be represented by a tuple: 
                           
                              
                                 〈
                                 ReactState
                                 ,
                                 ActState
                                 ,
                                 InputMsg
                                 ,
                                 OutputMsg
                                 ,
                                 →
                                 〉
                              
                           
                        where 
                           →
                         is a labeled transition system whose states are 
                           State
                           =
                           ReactState
                           ∪
                           ActState
                         and whose labels are 
                           Act
                           =
                           InputMsg
                           ∪
                           OutputMsg
                        . ReactState represents the set of states in which the actor is waiting to receive messages. ActState represents the set of states in which an actor, after receiving an input message, is going to produce some (possibly empty) sequence of output messages. The states and the labels are subject to the following constraints:
                           
                              (C1)
                              for all 
                                    R
                                    ∈
                                    ReactState
                                 , if 
                                    R
                                    
                                       
                                          →
                                       
                                       
                                          m
                                       
                                    
                                    Q
                                 , then 
                                    m
                                    ∈
                                    InputMsg
                                  and 
                                    Q
                                    ∈
                                    ActState
                                 ;

for all 
                                    A
                                    ∈
                                    ActState
                                 , if 
                                    A
                                    
                                       
                                          →
                                       
                                       
                                          m
                                       
                                    
                                    Q
                                 , then 
                                    m
                                    ∈
                                    OutputMsg
                                 , and 
                                    Q
                                    ∈
                                    State
                                 ;

for all 
                                    R
                                    ∈
                                    ReactState
                                  and 
                                    im
                                    ∈
                                    InputMsg
                                 , there exists a 
                                    A
                                    ∈
                                    ActState
                                  such that 
                                    R
                                    
                                       
                                          →
                                       
                                       
                                          im
                                       
                                    
                                    A
                                 ;

for all 
                                    A
                                    ∈
                                    ActState
                                  and 
                                    om
                                    ∈
                                    OutputMsg
                                 , there exists a 
                                    Q
                                    ∈
                                    State
                                  such that 
                                    A
                                    
                                       
                                          →
                                       
                                       
                                          om
                                       
                                    
                                    Q
                                 ;

for all 
                                    A
                                    ∈
                                    ActState
                                 , there always exists a 
                                    R
                                    ∈
                                    ReactState
                                  and a finite sequence 
                                    
                                       
                                          om
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          om
                                       
                                       
                                          2
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       
                                          om
                                       
                                       
                                          n
                                       
                                    
                                  and 
                                    
                                       
                                          A
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          A
                                       
                                       
                                          2
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       
                                          A
                                       
                                       
                                          n
                                          −
                                          1
                                       
                                    
                                    ∈
                                    ActState
                                  such that 
                                    A
                                    
                                       
                                          →
                                       
                                       
                                          
                                             
                                                om
                                             
                                             
                                                1
                                             
                                          
                                       
                                    
                                    
                                       
                                          A
                                       
                                       
                                          1
                                       
                                    
                                    
                                       
                                          →
                                       
                                       
                                          
                                             
                                                om
                                             
                                             
                                                2
                                             
                                          
                                       
                                    
                                    
                                       
                                          A
                                       
                                       
                                          2
                                       
                                    
                                    
                                       
                                          →
                                       
                                       
                                          
                                             
                                                om
                                             
                                             
                                                3
                                             
                                          
                                       
                                    
                                    ⋯
                                    
                                       
                                          →
                                       
                                       
                                          
                                             
                                                om
                                             
                                             
                                                n
                                             
                                          
                                       
                                    
                                    R
                                 .

Remarks on the high-level meaning of these rules:
                           
                              •
                              the actor can always make some kind of progress unless it is blocking on input;

when processing an input message, an actor will eventually return to a 
                                    ReactState
                                  state after a finite number of steps;

it is impossible for 2 inputs to be processed simultaneously. If an input arrives while the system is busy producing outputs, we assume that it is transparently enqueued and processed later.

Like in [9], for convenience here every small step is meant to produce an output message (which can be empty). In this model, each state of an actor system – i.e., a set of actors – has a natural interpretation as a (non-deterministic) transducer between input message streams and output message streams, where for streams we refer here to finite or infinite sequences of elements. Formally, this is the co-inductive interpretation of the grammar: 
                           
                              
                                 S
                                 ::=
                                 [
                                 ]
                                 |
                                 
                                 s
                                 
                                 ::
                                 
                                 S
                              
                           
                        where s ranges over stream elements. We use metavariables 
                           IM
                           ∈
                           Stream
                           
                           Input
                         and 
                           OM
                           ∈
                           Stream
                           
                           Output
                         to range over streams of input messages im and output messages om, respectively. Actors relate input message streams into output streams according to the following definition:
                           Definition 1
                           Actor event loops


                           
                              We co-inductively define 
                              
                                 Q
                                 (
                                 IM
                                 )
                                 ⇒
                                 OM
                               (Q translates the input message stream IM to the output message stream OM) with the following rules:
                                 
                                    (R1)
                                    
                                       
                                          
                                             R
                                             (
                                             [
                                             ]
                                             )
                                             ⇒
                                             [
                                             ]
                                          
                                          
                                             ¯
                                          
                                       
                                    
                                 
                              
                              
                                 
                                    (R2)
                                    
                                       
                                          
                                             R
                                             
                                                
                                                   →
                                                
                                                
                                                   im
                                                
                                             
                                             A
                                             
                                             A
                                             (
                                             IM
                                             )
                                             ⇒
                                             OM
                                          
                                          
                                             R
                                             (
                                             im
                                             :
                                             IM
                                             )
                                             ⇒
                                             OM
                                          
                                       
                                    
                                 
                              
                              
                                 
                                    (R3)
                                    
                                       
                                          
                                             A
                                             
                                                
                                                   →
                                                
                                                
                                                   om
                                                
                                             
                                             Q
                                             
                                             Q
                                             (
                                             IM
                                             )
                                             ⇒
                                             OM
                                          
                                          
                                             A
                                             (
                                             IM
                                             )
                                             ⇒
                                             om
                                             
                                             ::
                                             
                                             OM
                                          
                                       
                                    
                                 
                              
                           

The rule labelled (R2) is a high-level meaning of the constraint labelled as (C1) and (C3); (R3) corresponds to (C2) and (C4).

Given this transition system, we can introduce then a minimal actor language, called ACT-IMP (imperative actor programming language), capturing main aspects of actor programming. Messages are syntactically represented by msg(m), where m is a data structure, msg ranges over a set of messages (names). Input messages 
                           im
                           ∈
                           InputMsg
                         and output messages 
                           om
                           ∈
                           OutputMsg
                         are defined as: 
                           
                              
                                 im
                                 ::=
                                 msg
                                 (
                                 m
                                 )
                              
                           
                        
                        
                           
                              
                                 om
                                 ::=
                                 aid
                                 :
                                 msg
                                 (
                                 m
                                 )
                                 
                                 |
                                 
                                 •
                              
                           
                        The syntax of an actor program can be defined as follows: 
                           
                              
                                 
                                 
                                    
                                       
                                          
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

An actor program consists of a (possibly empty) collection of message handlers, each of which accepts a message and runs some command – in which the x parameter is substituted with the message content – in terms of a sequence of actions in response. The handler code may examine and modify the state of the actor (shared among handlers), send a message to some actor (given the actor identifier aid), change handlers (by means of become). A handler always terminates, returning to a state in which the actor can handle another input. The usual definition of expressions e is omitted.

Given this language, 
                           R
                           ∈
                           ReactState
                         and 
                           A
                           ∈
                           ActState
                         can be defined as 
                           R
                           ::=
                           (
                           μ
                           ,
                           p
                           )
                         and 
                           A
                           ::=
                           (
                           μ
                           ,
                           p
                           ,
                           c
                           )
                        , where μ represents the actor store, mapping from variables r to data values, and p the actor program. Act state additionally includes the command that is currently being executed. The full operational semantics can be defined accordingly, including the rules defining the general transition 
                           Q
                           
                              
                                 →
                              
                              
                                 a
                              
                           
                           
                              
                                 Q
                              
                              
                                 ′
                              
                           
                        , where 
                           a
                           ::=
                           im
                           
                           |
                           
                           om
                        ; a judgement defining how a message handler (and a command) is selected in response to an input message; a judgement defining the execution of commands paired with an actor store and a judgement defining the big step evaluation of expressions, using the store to look up variables. The constraint (C5) previously defined allows for adopting a big step semantics also for the judgement defining the execution of commands.

From a design and programming point of view, the event loop model promotes a decomposition based on behaviors similar to the state pattern [20]. Transitions in a state are triggered by the receipt of a message and the atomic execution of the message handler represents the effect of the transitions, changing atomically the state. Quite obviously, this makes the model particularly effective for implementing actors that can be properly modeled as finite state machines. Conversely, the implementation of more process-oriented behaviors, involving patterns of synchronous and asynchronous interactions, possibly nested, can be quite problematic. The problem in this case is the fragmentation of the code in handlers, which does not necessarily correspond to a good modularization from the point of view of organization of the wanted behavior. That is, a designer is forced to decompose the behavior following the message flows, eventually using self-sending of messages to structure articulated, long-term activities without tampering reactivity [49]. This is clearly a programming trick, decreasingly the level of abstraction used to describe the strategy identified at the design level. It produces similar effects to the goto for sequential programs [18], tampering program understanding.

As a concrete case, we consider here a well-known example in concurrent programming, the dining philosophers 
                        [17]. Philosophers must feature a behavior in which repeatedly alternate thinking with eating, and for the latter they need to properly interact with their environment – efficiently acquiring and using their couple of forks in a mutual exclusive way. The simplest solution to avoid deadlocks is to acquire the forks (labelled with a numerical identifier, from 0 to 
                           N
                           −
                           1
                        , being N the number of philosophers) always in the same order, so that the 
                           N
                           −
                           1
                         philosopher using the forks tagged as 
                           N
                           −
                           1
                         (left) and 0 (right) collects first the fork 0 and then, after this succeeded, the 
                           N
                           −
                           1
                         one. In a well-modularized solution the behavior of the philosopher is decomposed in four main parts: thinking, acquiring forks, eating, releasing forks: 
                           
                              
                                 
                                 
                                    
                                       
                                          process Philosopher(Fork f1, Fork f2) {
                                    
                                    
                                       
                                          
                                          loop {
                                    
                                    
                                       
                                          
                                          think()
                                       
                                    
                                    
                                       
                                          
                                          acquireForksInOrder(f1,f2)
                                       
                                    
                                    
                                       
                                          
                                          eatUsingForks(f1,f2)
                                       
                                    
                                    
                                       
                                          
                                          releaseForks(f1,f2)
                                       
                                    
                                    
                                       
                                          }
                                    
                                    
                                       }
                                    
                                 
                              
                           
                        The modules should be as loosely coupled as possible and well-separated, so that e.g., thinking and eating should not need to know anything about the strategy to adopt to acquire/release forks.


                        Fig. 1
                         shows a solution in ActorFoundry [37] and Fig. 2
                         a solution in Akka [6], adapted from a version called “dining hakkers” available in the Akka distribution [7]. In both cases, forks are modeled as actors. In the former, the philosopher behavior is decomposed into message handlers that correspond to the different states in which the actor can be. In ActorFoundry message handlers are implemented by methods annotated with @message. The method self() – defined in the Actor base class – returns the identifier of the actor itself. Fork actors use a local variable (waitingActor) to keep track of the actor who requested the fork – in the case that the fork was not available, because already in use. As soon as the fork turns to be free again (after processing a message release), a message is sent to the waiting actor.

In Akka, the philosopher is more explicitly decomposed into state/behaviors, using a become mechanism to make transitions. Fig. 2 shows the source code of the hakker (philosopher) only: the source code of the forks (chopticks in this case) is reported in Appendix A. The become mechanism is implemented by dynamically replacing the function used to receive the messages, referenced by the receive field, initially waiting for a Think message. The exclamation mark is used in Akka as infix operator to send asynchronous messages (e.g., left ! Take(self)). The solution adopts busy waiting as a strategy to manage the case in which forks are not available.

Both in ActorFoundry and in Akka the fragmentation of the philosopher behavior into a set of handlers that depends on the message flow is quite evident. From a programming point of view, this fragmentation leads to problems that are quite similar to those remarked by Dijkstra in the well-known paper about the use of the goto statement in sequential programs [18]. That is, the logical control flow of the activity is broken into multiple pieces (“spaghetti”), not explicitly related in the source code but related at the execution time.

This problem can be mitigated by the use of continuations 
                        [28], specifying the message to be replied when sending a request message, i.e. the handler to be executed when the request has been completed. A main example of actor language supporting different forms of continuations is SALSA [61]. SALSA (Simple Actor Language, System and Architecture) is a concurrent object-oriented programming language extending Java with actors as first class abstractions, to support the development of Internet and mobile computing applications. An actor in SALSA can be defined using the behavior construct. Actor behaviors can be grouped in modules. A behavior definition may extend another behavior (single inheritance). Every SALSA behavior extends a top-level UniversalActor behavior. Message handlers can be defined in a similar way to methods in Java; to send a message to an acquaintance actor the arrow operator is used. More about SALSA syntax and semantics can be found in [62,61].


                        Fig. 3
                         shows the philosopher in SALSA as reported in [62]. The chopstick actor is modeled as an extension of the Semaphore actor. The solution adopts a busy waiting strategy like in the case of Akka, so that a philosopher actor keeps trying acquiring the chopsticks until they are available. As previously mentioned, SALSA supports different forms of continuations directly in the language – token-passing continuations, join continuations and first-class continuations [61]. Token-passing continuations can be used to specify sequences of actions in the same handler. In the philosopher, for instance, in the eat message handler, a sequence of two asynchronous statements is chained by this kind of continuation (pickLeft() @ gotLeft(token)), so that gotLeft will be self-sent only when pickLeft has been processed. The same occurs in gotLeft message handler. In gotRight a join block (i.e., join continuations) is used first to send the release message to forks and a println to the standard output actor in parallel, and then to send a print message about the beginning of the thinking stage after that all the replies concerning the previous messages have been received.

On the one hand the use of continuations mitigates the fragmentation problem: in a single message handler (e.g., eat) we can embed a kind of plan about the chain of handlers to be executed when receiving the replies of the individual request messages. On the other hand, it complicates the semantics, introducing some issues that are not found in the basic actor model. An example is about atomicity. According to the run-to-completion semantics, message handlers are executed atomically. The extension of such atomicity to chains of asynchronous statements can have an substantial impact on the behavior of actors and then on the shape of their programs.

A further aspect that impacts on the programming of actors based on event loops is the model adopted to integrate actors and objects. In the model underlying the approaches discussed in previous subsection, actors and objects are essentially two independent levels. It is true that in OOP frameworks like ActorFoundry and Akka actors are implemented in terms of OOP API. However, this is just an implementation-level choice: the two levels are conceptually independent and objects are used to represent the data structures that are manipulated and exchanged by actors.

A different integrating approach has been introduced with the communicating event loops model [42], where actors (called vat) are containers of objects, and message passing occurs among the objects themselves. This model has been introduced with the E language [42], and has been further adopted by other more recent languages/platforms like AmbientTalk [60]. A similar model has been adopted also by approaches based on active objects such as JCoBox [54] and ABS [32], extending the basic Creol model [31]. In communicating event loops, an actor contains an entire heap of regular objects, possibly state-full, all sharing a single event loop which executes their code. Any object created by an actor is owned by that actor, and forever remains contained in that actor. Objects owned by one actor may hold references to individual objects owned by other actors – i.e. objects contained by an actor may be referenced from outside of the actor, they are not necessarily private. There is no blocking synchronization primitive: both the sending and the receiving of messages between actors happen asynchronously. Message reception happens implicitly by invoking a method on an object. When created, the actor hosts a single object (called actor׳s behavior), functioning as a public interface to the actor, whose far reference is returned to the actor creator.

The event loop in the communicating event loops model is a refinement of the basic one (see Algorithm 2), where a heap is used to keep track of the objects inside the actor and message dispatch occurs by first locating the object target of the message, and then invoking the corresponding method, which is run to completion. 
                           Algorithm 2
                           Abstract version of the event loop in the communicating event loops model. 
                                 
                                    
                                       
                                       
                                          
                                             1: loop
                                             
                                          
                                          
                                             2: 
                                                
                                                   msg
                                                   ←
                                                   
                                                      WaitForMsg
                                                   
                                                   (
                                                   )
                                                
                                             
                                          
                                          
                                             3: 
                                                
                                                   o
                                                   ←
                                                   
                                                      LocateObject
                                                   
                                                   (
                                                   msg
                                                   )
                                                
                                             
                                          
                                          
                                             4: 
                                                
                                                   m
                                                   ←
                                                   
                                                      GetMethod
                                                   
                                                   (
                                                   msg
                                                   )
                                                
                                             
                                          
                                          
                                             5: 
                                                
                                                   args
                                                   ←
                                                   
                                                      GetMethodArgs
                                                   
                                                   (
                                                   msg
                                                   )
                                                
                                             
                                          
                                          
                                             6: 
                                                CallMethod(obj,m, args
                                             
                                          
                                          
                                             7: end loop
                                             
                                          
                                       
                                    
                                 
                              
                           

The processing of an asynchronous message to completion is called turn, and possibly involves a chain of synchronous method calls among objects inside the hosting actor, backed by a stack. The formalization of this event loop is almost the same as the one discussed in previous sections. In this case, after reacting to an input message from a 
                           R
                           ∈
                           ReactState
                        , the sequence of transitions between state 
                           A
                           ∈
                           ActState
                         represents a turn. Input and output messages contain also the identifier of the object inside the actor which is the target of the message.

Even if actors based on the communicating event loops model are still event loop based actors, the way in which their behavior is designed and programmed is deeply different. In this model the promoted programming style is more similar to the classic object-oriented one, integrated with asynchronous message passing and strictly no-blocking behavior. Continuation Passing Style (CPS) is heavily adopted as a mechanism to manage asynchronous computations, based on non-blocking futures and nested closures expressing the successive callbacks. This leads to a different shape for actors, compared to the one based on states/behaviors. As an example, Fig. 4
                         shows a snippet of a philosopher implemented in AmbientTalk, available in the AmbientTalk distribution [59]. The full source code is reported in Appendix B. Actors in AmbientTalk are created similar to objects. The actor: method, defined in the global lexical scope, takes a closure as its sole argument and uses that closure to initialize the behavior of the new actor. In the example, i, name, room are the parameters of the closure. The when:becomes: function is used to register an observer (taking the form of a closure) on the future returned by sending asynchronous messages—think, room 
                        
                           <
                        
                        -pickUp(i), eat(forks). When a message sending is annotated with the @FutureMessage, a future is attached to the message. Instead, the annotation @OneWayMessage means that no result is required. In the example, a single room actor is used to manage the forks, that are collected with a single request. The plan of the whole behavior is encapsulated in the method live, where futures and continuations are used to manage the interactions first to get the forks, and then to eat, and finally to release the forks and start again the cycle.

On the one hand, compared to behavior based actors, this style reduces fragmentation, making it possible to encapsulate in a method of an object inside an actor the application logic possibly involving articulated interaction – synchronous and asynchronous – with other objects. On the other hand, CPS and nested futures/callbacks makes programming challenging, as witnessed by other fields where event loops and CPS are heavily exploited. A main example is asynchronous programming in JavaScript, which is the main approach adopted to develop modern client-side web applications. In that context, the terms callback hell and pyramids of doom are often used to refer such deep continuation nesting, which often results in code which is harder to read and maintain, less modular and more difficult to separate into concerns, and in which error propagation and exception handling is harder to manage [15,36]. The use of callbacks, like in the case of goto, breaks the linearity of the source. The resulting code requires the programmer to mentally unwind the stack to understand the current context. Consequently, the extensive use of CPS can increase the cognitive dissonance for the programmer between the original intent of the function as written and the context from which is finally executed [15].

Control loops have been introduced and adopted in different contexts – from control theory, to AI and software engineering – in particular to define the control architecture of autonomous/autonomic components (devices, agents, robots, etc.) interacting with some kind of environment. In the case of agent-oriented programming as defined originally in [56], the execution cycle at the core of the architecture of cognitive agents is a control loop. A key aspect of this architecture is to bring together proactivity – i.e., acting towards the achievement of some goal – and reactivity – to promptly react to relevant events occurring in the environment. In particular, the reasoning cycle of cognitive agents based on the Belief-Desire-Intention (BDI) model [45] is a control loop based on three macro-stages – sense, plan, act – that are executed at each cycle of the loop. Different variants of this cycle have been implemented in practical agent programming languages/frameworks, such as Jason 
                     [10], AgentFactory [53], 2APL [16], GOAL [29] – all these mainly in the context of Distributed Artificial Intelligence.

Besides that context, in our previous work [48] we started exploring the value of the sense-plan-act control loop also for defining the behavior of agents adopted as fine-grained first-class abstraction in concurrent and distributed programming, comparable to actors. Agents in the simpAL language [51] and in its most recent evolution called ALOO 
                     [50] embed a simplified variant of the BDI reasoning cycle, sharing many characteristics and features with actors׳ event loop. In this paper we aim at discussing control loops as an extension of event loops, featuring properties that allow for solving some of the programming issues that have been remarked in the previous sections. To that purpose, we consider in the following the control loop model adopted first in Jason and then in the ALOO language.


                        Jasonis a concrete implementation and extension of the AgentSpeak(L) language [44]. It has been conceived to be a practical language to implement intelligent BDI-based agents, adopting Prolog and logic programming as background language to represent data structures. An agent in Jason is an autonomous entity – owning a logical control flow – functioning as a reactive planning system, reacting to events perceived from the environment where it is immersed and doing actions on that environment in order to achieve some assigned goal(s), possibly exchanging messages with other agents. It is programmed in terms of goals – representing the tasks that can be allocated to the agent –, beliefs – Prolog-like facts and rules used to represent the internal/hidden agent state, including the information about the current perceived state of the environment –, and plans – which encapsulate the procedural knowledge to be used to react to events like changes to beliefs, new goals to achieve or goal failures.


                        Fig. 5
                         shows a simple example of agent program written in Jason. The syntax of a plan is E : C 
                        
                           <
                        
                        - B, where E is the event – which can be, e.g., a new goal to achieve +!G (e.g., +!monitor_plant, line 4) or a change to a belief +B (e.g., +temperature(T), line 8). The context C is a predicate expression over the belief base specifying when the plan could be considered applicable, and B is the body of the plan, modeled as a sequence of actions to be executed, separated by a semi-colon. Actions can be either internal (changing only the inner state of the agent) or external (interacting with the environment or other agents). Among the internal actions, +B (e.g., +n_alarms(0), line 5) is used to add a new belief to the belief base, !G is used to instantiate a new sub-goal G to achieve before proceeding (e.g., !update_alarms, line 10), and !!G is used to instantiate a new independent goal G to be achieved in parallel to the current one(s) (e.g., !!start_cooling_process, line 11). In the example, switch_on_cooler (line 19) and switch_off_cooler (line 21) are examples of external actions, provided by the environment where the agent is working. Instead, .wait (line 20) and .println (line 6) are examples of internal actions – .wait suspends the current plan in execution of the specified amount time and .println logs a message on the agent console.

Different approaches can be used to concretely implement the concept of environment in agent-oriented programming and in Jason 
                        [47]. In spite of the specific approach adopted, the interaction model is always based on the following semantics: (a) actions requested on the agent side and asynchronously executed on the environment side; (b) observable events generated by the environment and asynchronously perceived on the agent side. Observable events generated by the environment can be either changes to its observable state or events related to the completion or failure of actions. There is no control coupling between agents and the environment: actions requested by agents on the environment are eventually executed by a control flow which is logically different from the one executing the agent control loop. On the agent side, when an action is requested, the corresponding plan is suspended until the action has been either completed with success, or a failure has occurred. In the case of success, the next action of the plan can be selected and executed.

Algorithm 3 shows an abstract simplified version of the Jason control loop. 
                           Algorithm 3
                           Simplified version of the Jason control loop. 
                                 
                                    
                                       
                                       
                                          
                                             1: 
                                                   B
                                                   ←
                                                   
                                                      
                                                         B
                                                      
                                                      
                                                         0
                                                      
                                                   
                                                ; 
                                                   PlanLib
                                                   ←
                                                   
                                                      
                                                         PlanLib
                                                      
                                                      
                                                         0
                                                      
                                                   
                                                ; 
                                                   Ev
                                                   ←
                                                   {
                                                   }
                                                 ; 
                                                   I
                                                   ←
                                                   {
                                                   }
                                                
                                             
                                          
                                          
                                             2: loop
                                             
                                          
                                          
                                             3: 
                                                
                                                   ρ
                                                   ←
                                                   
                                                      SenseEnv
                                                   
                                                   (
                                                   )
                                                
                                             
                                          
                                          
                                             4: 
                                                
                                                   
                                                      BelUpdate
                                                   
                                                   (
                                                   ρ
                                                   ,
                                                   B
                                                   ,
                                                   Ev
                                                   )
                                                
                                             
                                          
                                          
                                             5: 
                                                if 
                                                Ev is not empty then
                                             
                                          
                                          
                                             6: 
                                                
                                                   ev
                                                   ←
                                                   
                                                      FetchEvent
                                                   
                                                   (
                                                   Ev
                                                   )
                                                
                                             
                                          
                                          
                                             7: 
                                                
                                                   p
                                                   ←
                                                   
                                                      SelectPlan
                                                   
                                                   (
                                                   ev
                                                   ,
                                                   B
                                                   ,
                                                   PlanLib
                                                   )
                                                
                                             
                                          
                                          
                                             8: 
                                                if 
                                                ev is an env change or a new goal to achieve then
                                             
                                          
                                          
                                             9: 
                                                
                                                
                                                   I
                                                   ←
                                                   I
                                                   ∪
                                                   {
                                                   
                                                      NewInt
                                                   
                                                   (
                                                   p
                                                   ,
                                                   ev
                                                   )
                                                   }
                                                
                                             
                                          
                                          
                                             10: 
                                                else if 
                                                ev is a sub-goal to achieve then
                                             
                                          
                                          
                                             11: 
                                                
                                                PushPlan(currInt,p,ev)
                                          
                                          
                                             12: 
                                                end if
                                             
                                          
                                          
                                             13: 
                                                end if
                                             
                                          
                                          
                                             14: 
                                                if 
                                                I is not empty then
                                             
                                          
                                          
                                             15: 
                                                
                                                   currInt
                                                   ←
                                                   
                                                      SelectIntention
                                                   
                                                   (
                                                   I
                                                   )
                                                
                                             
                                          
                                          
                                             16: 
                                                
                                                   a
                                                   ←
                                                   
                                                      FetchNextAction
                                                   
                                                   (
                                                   currInt
                                                   )
                                                
                                             
                                          
                                          
                                             17: 
                                                
                                                   
                                                      ExecAction
                                                   
                                                   (
                                                   a
                                                   ,
                                                   currInt
                                                   ,
                                                   B
                                                   ,
                                                   I
                                                   ,
                                                   PlanLib
                                                   )
                                                
                                             
                                          
                                          
                                             18: 
                                                end if
                                             
                                          
                                          
                                             19: end loop
                                             
                                          
                                       
                                    
                                 
                              
                           

The key aspect of this control architecture as captured by Algorithm 3 is that the same control flow is used to both carry on one or multiple plans and react to new events.

The formalization of the control loop can be conceived as an extension and refinement of the basic actor event loop, modeling agents as a goal-oriented reactive machine mapping a stream of input percepts 
                           perc
                           ∈
                           InputPerc
                         into a stream of output actions 
                           oa
                           ∈
                           OutputAct
                        . An agent can be represented by a tuple: 
                           
                              
                                 〈
                                 SenseState
                                 ,
                                 
                                 PlanActState
                                 ,
                                 
                                 InputPerc
                                 ,
                                 
                                 OutputAct
                                 ,
                                 →
                                 〉
                              
                           
                        where 
                           →
                         is a labeled transition system whose states are 
                           State
                           =
                           SenseState
                           ∪
                           PlanActState
                        , and whose labels are 
                           Act
                           =
                           InputPerc
                           ∪
                           OutputAct
                        , with InputPerc that includes also ϵ, representing the no perceptions available condition.

An agent continuously loops from a SenseState to a PlanActState, to a SenseState again, until its task is fulfilled. In a SenseState, an agent fetches an input percept 
                           pe
                           ∈
                           InputPerc
                         (ϵ if no perceptions are available), updates its beliefs about the state of the environment and produces one or multiple internal events, tracked in the agent state. In a PlanActState, given the state of the agent (belief base, internal event queue, plans and current intentions), an output action 
                           oa
                           ∈
                           OutputAct
                         is produced.

In this case, the states and the labels are subject to the following constraints:
                           
                              (C1)
                              for all 
                                    S
                                    ∈
                                    SenseState
                                 , if 
                                    S
                                    
                                       
                                          →
                                       
                                       
                                          perc
                                       
                                    
                                    Q
                                 , then 
                                    perc
                                    ∈
                                    InputPerc
                                  and 
                                    Q
                                    ∈
                                    PlanActState
                                 .

for all 
                                    Q
                                    ∈
                                    PlanActState
                                 , if 
                                    Q
                                    
                                       
                                          →
                                       
                                       
                                          oa
                                       
                                    
                                    S
                                 , then 
                                    oa
                                    ∈
                                    OutputAct
                                 , and 
                                    S
                                    ∈
                                    SenseState
                                 .

for all 
                                    S
                                    ∈
                                    SenseState
                                  and 
                                    perc
                                    ∈
                                    InputPerc
                                 , there exists a 
                                    Q
                                    ∈
                                    PlanActState
                                  such that 
                                    S
                                    
                                       
                                          →
                                       
                                       
                                          perc
                                       
                                    
                                    Q
                                 .

for all 
                                    Q
                                    ∈
                                    PlanActState
                                 , there exists a 
                                    S
                                    ∈
                                    SenseState
                                  and a 
                                    oa
                                    ∈
                                    OutputAct
                                  such that 
                                    Q
                                    
                                       
                                          →
                                       
                                       
                                          oa
                                       
                                    
                                    S
                                 .

Remarks on the high-level meaning of these rules:
                           
                              •
                              a cycle is given by the sequence of a SenseState and a PlanActState;

the agent can always make some kind of progress – it is never blocked, neither on inputs nor in producing outputs;

in a PlanActState only one action is chosen and executed.

Agents too can be seen as a transducers between input streams (of percepts) and output streams (of actions). Being the metavariables 
                           IP
                           ∈
                           Stream
                           
                           InputPercepts
                        , 
                           OA
                           ∈
                           Stream
                           
                           OutputActions
                         to range over stream of input percepts 
                           perc
                         and output actions Act, then:
                           Definition 2
                           Agent control loop


                           We co-inductively define 
                                 Q
                                 (
                                 IP
                                 )
                                 ⇒
                                 OA
                               (Q translates the input precept stream IP to the output action stream OA) with the following rules:
                                 
                                    (R1)
                                    
                                       
                                          
                                             S
                                             
                                                
                                                   →
                                                
                                                
                                                   ϵ
                                                
                                             
                                             Q
                                             
                                             Q
                                             ⇒
                                             OA
                                          
                                          
                                             S
                                             (
                                             [
                                             ]
                                             )
                                             ⇒
                                             OA
                                          
                                       
                                    
                                 
                              
                              
                                 
                                    (R2)
                                    
                                       
                                          
                                             S
                                             
                                                
                                                   →
                                                
                                                
                                                   perc
                                                
                                             
                                             Q
                                             
                                             Q
                                             (
                                             IP
                                             )
                                             ⇒
                                             OA
                                          
                                          
                                             S
                                             (
                                             perc
                                             
                                             ::
                                             
                                             IP
                                             )
                                             ⇒
                                             OA
                                          
                                       
                                    
                                 
                              
                              
                                 
                                    (R3)
                                    
                                       
                                          
                                             Q
                                             
                                                
                                                   →
                                                
                                                
                                                   act
                                                
                                             
                                             S
                                             
                                             S
                                             (
                                             IP
                                             )
                                             ⇒
                                             OA
                                          
                                          
                                             Q
                                             (
                                             IP
                                             )
                                             ⇒
                                             act
                                             
                                             ::
                                             
                                             OA
                                          
                                       
                                    
                                 
                              
                           

Like in the actor case, we can devise then a simple agent language called AG-IMP (imperative agent programming language), based on this formalization. Beliefs are syntactically represented by bel(b), where b is a value of some type, bel ranges over a set of beliefs (names). Input percepts 
                           ip
                           ∈
                           InputPerc
                         and output actions 
                           oa
                           ∈
                           OutputAct
                         are defined as: 
                           
                              
                                 ip
                                 ::=
                                 perc
                                 (
                                 v
                                 )
                                 
                                 |
                                 
                                 ϵ
                              
                           
                        
                        
                           
                              
                                 oa
                                 ::=
                                 act
                                 (
                                 v
                                 )
                                 
                                 |
                                 
                                 •
                              
                           
                        The syntax of an actor program in AG-IMP can be defined as follows: 
                           
                              
                                 
                                 
                                    
                                       
                                          
                                             
                                          
                                       
                                    
                                 
                              
                           
                        an agent program p consists of a collection of plans pl (similar to event handlers), each of which reacts to some specific triggering event te that can be either the addition/change of a belief or the addition of a new goal. In plan definition, ctx stands for a boolean expression representing the context condition of the plan. Given this language, 
                           S
                           ∈
                           SenseState
                         and 
                           Q
                           ∈
                           PlanActState
                         can be defined as 
                           S
                           ::=
                           (
                           μ
                           ,
                           p
                           ,
                           ie
                           ,
                           i
                           )
                         and 
                           Q
                           ::=
                           (
                           μ
                           ,
                           p
                           ,
                           ie
                           ,
                           i
                           )
                        , where μ represents the agent store (i.e. the belief base), mapping from variables r to data values; ie represents the queue of internal events generated when processing percepts in SenseState; and i represents the list of current intentions (i.e. plans in execution).

Agent control loops have important similarities with event loops discussed in previous sections. The sense stage in this control loop corresponds to message fetching in event loops, the plan stage to message handler selection and the act stage to handler execution. Like in event loops, also in control loops:
                           
                              •
                              
                                 no low-level race conditions can occur inside the agent, since there is only one logical control flow accessing/modifying the agent state. This access is staged, so that in the sense stage the state is updated, in the plan stage it is read, and finally in the act stage it is read or updated, depending on the action executed;


                                 no low level deadlocks among agents – and also among intentions inside an agent – can occur since the control flow executing the cycle is never blocked. Even when the execution of a plan is suspended because an agent is waiting, e.g., for the completion of some action to execute the next one, it can always react to other events, instantiating new intentions.

Besides the similarities, there are some important differences that have a significant impact on programming. In particular, in control loops:
                           
                              •
                              the run-to-completion semantics is relaxed, in fact the execution of a plan can take multiple cycles;

if there are no events to process, the cycle is not blocked: it may go on selecting and performing actions following the current intention(s);

a preemptive scheduling schema is adopted to carry on multiple plans – instead of a cooperative one, as adopted in container-based actors and active objects. At each execution cycle, the control loop selects the intention to carry on and then execute an action of that intention. Intention selection typically follows a round-robin policy, possibly extended with priorities – like in operating systems. However, like in actors, as already said, no low-level race conditions can occur, since individual actions are executed atomically;

a plan in execution can be blocked, dropped or just suspended – this happens each time an environment/external action is executed (waiting for its completion before executing the next one) or by means of predefined .suspend internal actions that allows for suspending ongoing intentions. However, as mentioned before, the agent per se is not blocked: the agent execution cycle is always running, eventually reacting to events relevant for the agent.

From a programming point of view these features allow for a decomposition of the behavior based on plans as hierarchical procedural abstractions, so a quite different approach with respect to the state/behavior-based one promoted by the basic actor model.

As an example, Fig. 6
                         shows a dining philosopher implemented in Jason. The behavior is given by a set of plans, logically organized in a hierarchical fashion. The agent reacts to the initial goal !boot(F1,F2), by instantiating a plan (lines 1–3) in which first it sorts out the forks to be used (!sort_forks(...) sub-goal) and then starts an end-less living activity (!!living independent goal). The plan for living (lines 13–18) accounts for a sequence of subgoals: first think, then acquire forks, eat, and then release forks before starting again with the same activity. In the plan for acquiring the forks (lines 20–22), the agent interacts with the environment by performing the acquireFork actions in order. In fact, in this case forks are not modeled as agents, but as part of the agents׳ environment, providing the acquireFork and releaseFork actions. The shape of the resulting program is as simple as the one found in multi-threaded programming, even if here the control architecture is completely different.


                        Pros and Cons of Agent Control Loops: The agent control loop model makes it easier and more natural to design and implement activity/process oriented behaviors that need to integrate some kind of reactivity. A simple example of integration between proactivity and reactivity is given by an extension of the dining philosopher problem with a further specification that, besides repeatedly thinking and eating, a philosopher must be able to promptly react to an alarm notification from the environment and start an evacuation plan. In Jason, this could be done in a straightforward way by extending the agent program with a couple of further plans: 
                           
                              
                                 
                                 
                                    
                                       
                                          +alarm 
                                          
                                             <
                                          
                                          - .drop_all_intentions; !evacuate.
                                       
                                    
                                    
                                       
                                          +!evacuate 
                                          
                                             <
                                          
                                          - ...
                                       
                                    
                                 
                              
                           
                        in which the agent reacts to new belief alarm perceived from the environment (that could be replaced by a message sent by another agent), and then drops all ongoing intentions (.drop_all_intentions is a primitive internal action) and instantiates a new !evacuate goal. Apparently, this kind of flexibility is not that easy achievable in basic event loop based models – where it could require to explicitly modify each actor state/behavior to add a handler to react to the alarm message.

In order to provide such flexibility, the agent control loop requires a more complex control architecture than the actor case. A stack must be used for each plan in execution. This is similar to multi-threaded programming, where each thread has its own stack. In the case of Jason agents, the stack is necessary to manage sub-plans triggered by sub-goals in a plan. For instance, the instantiation of the subgoal !acquireRes (line 15) causes the living plan to be suspended, executing the corresponding sub-plan (lines 20–22) whose body is put on top of the stack. As soon as the sub-plan is completed, it is removed from the stack and the parent plan is resumed. Event loop based actors may use a single stack to manage synchronous method calls among objects in a single turn – however the model ensures that the stack is always empty when the loop is going to wait for the next message to be served.

The capability of flexibly integrating reactivity and proactivity makes this kind of control loop interesting also in the context of concurrent programming, where the integration of event-driven/asynchronous and thread-oriented/synchronous programming is still an issue today. Accordingly, we adopted a simplified version of the sense–plan–act control loop in simpAL 
                     [51] and in the more recent ALOO 
                     [50] language, which have been designed taking concurrent programming as reference context.

In ALOO in particular the objective is to explore the extension of classic sequential object-oriented programming with an agent-oriented abstraction layer to address concurrency and featuring agents with a minimal sense-plan-act loop. In ALOO, objects are used to model any kind of passive entity/data structure which can be dynamically created, possibly shared and used by agents. Agents are used to model fine-grained active entities in charge of autonomously fulfilling tasks, by dynamically using and observing objects. Fine-grained means that a program in execution can host as many agents as objects – they are like lightweight actors/processes in modern actor languages. The set of objects represents the environment where agents are logically situated, providing them actions and generating observable events.

The detailed description of the ALOO programming model is out of the scope of this paper: in the following we provide just the essential elements that are useful to support the discussion. To help this description, we consider the source code of philosophers and forks in ALOO, shown in Fig. 7
                     . The dining philosopher example will be discussed in detail after presenting the control loop.

The structure and behavior of an agent in ALOO is defined by agent scripts (e.g., the Philosopher agent script in Fig. 7). An agent script contains a set of plans, defining the behavior of the agent playing the script, and variables, similar to private fields in objects, defining the global state or memory of the agent playing the script. A plan contains the recipe that an agent can use to achieve some specific task. A plan in execution is called intention, like in Jason. At runtime, an agent is created with a task to do and it is automatically disposed when the corresponding intention is terminated. In doing a task, an agent can decompose it in subtasks. In the example, DiningTask is decomposed into Thinking, AcquiringForks, Eating, ReleasingForks subtasks. For each new sub-task to do, the agent must have at least one plan for it.

A plan is defined by the type of task for which it can be used (e.g., DiningTask, line 8) and a body, specifying how to achieve that kind of tasks. Tasks are uniformly represented by objects, as instances of classes whose interface (type) must be an extension of a predefined Task interface. To shorten the declaration and denotation of task objects, some syntactic sugar is provided. The construct task T { ... } (e.g., lines 1–3) implicitly defines an interface T extending Task with a corresponding default class implementing T.

The model of objects in ALOO extends/specializes the classic passive one with a couple of features that concern the interaction with agents. The interface of an object is given by both a set of operations and a set of observable properties. Operations represent the actions that an agent can do on the object. Their execution is guarantee to be atomic, so that no races can occur if multiple operations are concurrently requested on the same object. In particular, only one operation at a time can be in execution inside an object, and changes to observable properties are perceived atomically by agents accessing/observing the object. Observable properties represent sort of public variables that can be accessed and observed by agents, but can be modified only by the operations of the object itself.


                        Fig. 7 shows the source code of the Fork interface – including an observable property representing the fork identifier and the two operations to acquire and release a fork. Interfaces are used to define the type of objects. ForkImp class provides a concrete implementation of the Fork interface.

The body of a plan is given by a set of action rules and local variables, structured in action rule blocks {...}, defining their scope. Action rules drive the selection of actions, specifying when an action can be collected in a cycle in order to be executed. Action rule blocks can be nested, by specifying actions that are blocks themselves. Thus, for each intention, a stack is necessary to manage the action rule block nesting. The action rule model recalls guarded event handlers [30]: each action rule has the general form 
                           when
                           +
                           
                              
                                 E
                              
                           
                           |
                           
                              
                                 C
                              
                           
                           =
                           >
                           
                              
                                 A
                              
                           
                           #
                           
                              
                                 l
                              
                           
                         specifying that the action 
                           
                              
                                 A
                              
                           
                         – optionally labelled as 
                           
                              
                                 l
                              
                           
                         – can be selected to be executed each time an event 
                           
                              
                                 E
                              
                           
                         occurs and the condition over agent state 
                           
                              
                                 C
                              
                           
                         holds. Events concern either changes to observable properties of objects that the agent is observing or changes to the execution state of actions of the block. Either the event or the condition can be omitted, meaning that the action can be selected independently from some specific event or the current action state. The keyword always (line 18) can be used to specify actions that can be always selected, i.e., at each execution cycle – in spite of events occurred or conditions related to the state.

Actions can be external – i.e., invoking an operation on objects, given their references – or internal, e.g., assigning a value to a local variable. Actions related to method execution are executed asynchronously, by a different control flow from the control loop; the completion or failure of actions is implicitly perceived by the agent as an asynchronous event. Among the internal actions, the do action instantiates a new sub-task to be achieved, specifying the new task to accomplish. The do syntax allows us to specify directly the name of the task type (e.g., line 19), along with parameters – in that case, a new task object of that type is implicitly created.

An important feature of the model is the capability of reacting to observable events perceived from the environment, i.e., from observed objects. Such capability is defined at the action rule block level. In particular, inside a block it is possible to declare – by means of an #observing: attribute – the list of objects and observable properties to be observed while executing that block. Given an object owith an observable property obs, then in a block 
                           {
                           #
                           observing
                           :
                           
                              
                                 o.obs
                              
                           
                           
                           as
                           :
                           b
                           ;
                           
                           ...
                           
                           }
                         the agent will perceive all the changes occurring to 
                           
                              
                                 o.obs
                              
                           
                        , mapped into an implicitly declared local read-only variable 
                           
                              
                                 b
                              
                           
                        . These read-only variables are called beliefs, like in the case of BDI agents.
                           2
                        
                        
                           2
                           The term belief is used since the value of these variables, at a certain time, could be different from the actual value of the corresponding observable properties observed by the agent, due to concurrency.
                         Beliefs are used also to keep track of the execution state of actions.

This model is expressive enough to allow for specifying any behavior mixing proactivity and reactivity. On the one extreme, a purely reacting behavior can be specified in terms of set of rules uniquely reacting to events related to the observable state of some objects. On the other extreme, a purely sequential execution of actions can be realized by specifying action rules with guards in which the event is omitted and the condition refers uniquely to the state of action execution, so that an action labelled as 
                           
                              
                                 l
                              
                              
                                 i
                                 +
                                 1
                              
                           
                         is executed only when an action labelled as l
                        
                           i
                         has been completed with success. Being sequences a frequent pattern, some syntactic sugar is provided to ease their coding: they can be written as a chain of actions (omitting the guard part) using the semicolon separator, like a sequence of statements in the case of imperative programs.

In ALOO, agent communication and coordination can be realized by exploiting the environment, i.e., by developing and exploiting objects specifically designed for functioning as coordination media 
                        [22]. For instance, message passing can be realized by designing a channel object functioning as the communication medium. A simple example is sketched in Fig. 8
                        , where the channel is implemented similar to a bounded buffer in producers–consumers schema, providing send and receive operations. The send operation enqueues the message in the buffer – suspending the operation if the buffer is full. The receive operation retrieves the first message from the buffer – suspending the operation if the buffer is empty. In the ALOO object model, the await(
                           C
                        ) primitive is provided to suspend operation execution, until the condition 
                           C
                         – represented by a predicate expression over the state of the object – is verified. Similar to the case of condition variables in monitor, this mechanism is used to synchronize the execution of (concurrent) operation inside objects – without violating the basic invariant that only one operation at a time can be in execution. It is worth remarking that the suspension of an operation invoked by an agent does not cause a block of the control loop on the agent side – conceptually, the control loop is never blocked. Fig. 8 on the right shows a snippet of agent plan using the channel – the println action is executed only after that the receive action has been completed. In this case, the programming style on the agent side closely resembles the traditional imperative/synchronous one – even if, under the hood, there are no control flows blocked.


                        Fig. 9
                         shows the same example but a different style is adopted, more even-driven. In particular, the channel object does not provide a receive operation, but an observable property – lastMsg – which stores the last message sent to the channel, by means of the send operation. In this case, an agent can perceive the messages by observing the channel and reacting to changes related to the lastMsg observable property. In the example shown in Fig. 9 (right), an agent uses two channels – one representing its message box (myMsgBox) and one the message box of another agent (otherMsgBox). In the same action block (lines 5–12), the agent sends a message to one channel and reacts to message arriving to the other channel, which is being observed (line 6).

The ALOO control loop is shown in Algorithm 4. S represents the agent global state (variables), I the set of ongoing plans in execution (i.e., intentions), Ev is the event queue, PlanLib the plan library, storing the current set of plans available to the agent (loaded from agent scripts), AssignedTask the reference to the object representing the task assigned to the agent. 
                           Algorithm 4
                           ALOO control loop. 
                                 
                                    
                                       
                                       
                                          
                                             1: 
                                                   S
                                                   ←
                                                   
                                                      
                                                         S
                                                      
                                                      
                                                         0
                                                      
                                                   
                                                ; 
                                                   PlanLib
                                                   ←
                                                   
                                                      
                                                         PlanLib
                                                      
                                                      
                                                         0
                                                      
                                                   
                                                ; 
                                                   Ev
                                                   ←
                                                   {
                                                   }
                                                
                                             
                                          
                                          
                                             2: 
                                                   p
                                                   ←
                                                   
                                                      SelectPlan
                                                   
                                                   (
                                                   AssignedTask
                                                   ,
                                                   PlanLib
                                                   )
                                                
                                             
                                          
                                          
                                             3: 
                                                   I
                                                   ←
                                                   {
                                                   
                                                      NewInt
                                                   
                                                   (
                                                   p
                                                   ,
                                                   AssignedTask
                                                   )
                                                   }
                                                
                                             
                                          
                                          
                                             4: while 
                                                I is not empty do
                                             
                                          
                                          
                                             5: 
                                                
                                                   currInt
                                                   ←
                                                   
                                                      SelectIntention
                                                   
                                                   (
                                                   I
                                                   )
                                                
                                             
                                          
                                          
                                             6: 
                                                
                                                   ev
                                                   ←
                                                   
                                                      FetchEvent
                                                   
                                                   (
                                                   Ev
                                                   ,
                                                   currInt
                                                   )
                                                
                                             
                                          
                                          
                                             7: 
                                                if 
                                                ev is not nil then
                                             
                                          
                                          
                                             8: 
                                                
                                                   
                                                      UpdateBel
                                                   
                                                   (
                                                   currInt
                                                   ,
                                                   ev
                                                   )
                                                
                                             
                                          
                                          
                                             9: 
                                                if 
                                                ev is about a new sub-task t todo then
                                             
                                          
                                          
                                             10: 
                                                
                                                
                                                   p
                                                   ←
                                                   
                                                      SelectPlan
                                                   
                                                   (
                                                   t
                                                   ,
                                                   PlanLib
                                                   )
                                                
                                             
                                          
                                          
                                             11: 
                                                
                                                PushPlan(currInt,p,t)
                                          
                                          
                                             12: 
                                                else if 
                                                ev is about a new task t todo then
                                             
                                          
                                          
                                             13: 
                                                
                                                
                                                   p
                                                   ←
                                                   
                                                      SelectPlan
                                                   
                                                   (
                                                   t
                                                   ,
                                                   PlanLib
                                                   )
                                                
                                             
                                          
                                          
                                             14: 
                                                
                                                
                                                   I
                                                   ←
                                                   I
                                                   ∪
                                                   {
                                                   
                                                      NewInt
                                                   
                                                   (
                                                   p
                                                   ,
                                                   t
                                                   )
                                                   }
                                                
                                             
                                          
                                          
                                             15: 
                                                end if
                                             
                                          
                                          
                                             16: 
                                                end if
                                             
                                          
                                          
                                             17: 
                                                
                                                   
                                                      
                                                         a
                                                      
                                                      
                                                         l
                                                      
                                                   
                                                   ←
                                                   
                                                      CollectActions
                                                   
                                                   (
                                                   currInt
                                                   ,
                                                   S
                                                   ,
                                                   ev
                                                   )
                                                
                                             
                                          
                                          
                                             18:
                                                for all 
                                                a in a
                                                
                                                   l
                                                 
                                                do
                                             
                                          
                                          
                                             19: 
                                                
                                                   
                                                      ExecAction
                                                   
                                                   (
                                                   a
                                                   ,
                                                   currInt
                                                   ,
                                                   S
                                                   ,
                                                   I
                                                   ,
                                                   PlanLib
                                                   )
                                                
                                             
                                          
                                          
                                             20: 
                                                end for
                                             
                                          
                                          
                                             21: end while
                                             
                                          
                                       
                                    
                                 
                              
                           

In this control loop, there is a first plan stage before looping (lines 2 and 3), selecting a plan p for the assigned task and then instantiating the corresponding intention in the set of intentions I. The loop is used to carry on the execution of the plan (act stage, lines 17–19), while perceiving events from the environment (sense stage, lines 5–8). Similar to event loops, for each cycle an event is fetched from the event queue (line 6). Like in Jason and differently from event loops, fetching is not blocking (if no event is in the queue, ev is nil). Differently from Jason, fetching is driven by the intention, that is, fetching looks for an event related to the current intention currInt. Every event perceived by an agent is always related to some explicit action that the agent did before, in some intention. Under the hood, when an action is performed, the identifier of the corresponding agent intention is tracked (on the environment/object side). This occurs also when an agent starts observing an object, by executing a block with the #observing attribute.

If the event is about the change of an observable property of an object observed by the agent, or about the notification that an action previously executed has been completed (or failed), then the corresponding belief in the action rule block is updated (line 8). If the event is about a new task to do, caused by the execution of an action self-allocating a task such as the do action, then a new plan stage is executed (line 9–15). If the request is about a sub-task to do, then the plan body of the selected plan (which is an action rule block) is pushed on the current intention stack. Otherwise, if it is an independent task, a new intention is created.

In the act stage, an intention is selected to be the current intention currInt (line 5), using a round-robin schema to guarantee fairness, and then all actions that can be executed according to the rules of the intention are collected (line 17) and executed, sequentially (line 18–20).

The programming model induced by this control loop is quite similar to the one in Jason, based on the hierarchical decomposition of plans, as shown by the philosopher example in Fig. 7. The main differences concern the granularity of plans and the shape of the behaviors integrating proactivity and reactivity. Jason – following AgentSpeak(L) – adopts a fine-grained plan model, so that we have to write a plan for each possible event relevant to the agent. On the one hand this favors simplicity and flexibility, on the other hand it has a drawback on modularity and encapsulation: a strategy for doing some task that needs to integrate some actions and some reactions to asynchronous events cannot be encapsulated into a single plan, but must be necessarily split into multiple plans, not explicitly related at the source code level. For complex agent programs, this could lead to a large number of plans which are not sub-plans but implicit fragments of the same logical high-level plan.

For instance, suppose to consider a variant of the dining philosopher in which a philosopher agent must begin eating reactively, by perceiving a hungry stimulus after thinking. This could be implemented in Jason as follows: 
                           
                              
                                 
                                 
                                    
                                       
                                          +!living 
                                          
                                             <
                                          
                                          - !think.
                                       
                                    
                                    
                                       
                                          +hungry 
                                          
                                             <
                                          
                                          - !acquireRes; !eat; !releaseRes; !!living.
                                       
                                    
                                 
                              
                           
                        The plan for !living must be broken in two parts: a first plan triggering the !think goal and a second plan reacting to the event +hungry. At the logical level, these plans are part of the same conceptual higher-level plan, but they are not explicitly related at the program level. Actually, fragmentation in Jason can be avoided by exploiting an internal action (.wait) which allows for suspending the current plan waiting for some event to occur: 
                           
                              
                                 
                                 
                                    
                                       
                                          +!living 
                                          
                                             <
                                          
                                          -
                                       
                                    
                                    
                                       
                                          
                                          !!think;
                                       
                                    
                                    
                                       
                                          
                                          .wait(+hungry);
                                       
                                    
                                    
                                       
                                          
                                          !acquireRes; !eat; !releaseRes; !!living.
                                       
                                    
                                 
                              
                           
                        In this case, thinking is instantiated as an independent goal to achieve, and the current plan is suspended until a change about the hungry belief is perceived. This approach however is not fully correct: in the case that the +hungry event is generated and processed by the reasoning cycle before the internal action .wait is executed, the event cannot be detected by .wait and the plan gets stuck forever.

The ALOO control loop allows for adopting a more coarse-grained plan model: a plan is meant to encapsulate the strategy to accomplish some specific task – which may include some workflow of actions, including triggering further sub-tasks, and reactions. For instance, the variant of the dining philosopher could be implemented without breaking the plan, by simply adding an action rule: 
                           
                              
                                 
                                 
                                    
                                       
                                          agent-script Philosopher(body: MyBody){
                                    
                                    
                                       
                                          
                                          plan-for DiningTask {
                                    
                                    
                                       
                                          
                                          ...
                                       
                                    
                                    
                                       
                                          
                                          always=
                                          
                                             >
                                           {
                                    
                                    
                                       
                                          
                                          #observing: body.isHungry as: hungry
                                       
                                    
                                    
                                       
                                          
                                          do Thinking()
                                       
                                    
                                    
                                       
                                          
                                          when hungry=
                                          
                                             >
                                           {
                                    
                                    
                                       
                                          
                                          
                                          do AcquiringForks();
                                       
                                    
                                    
                                       
                                          
                                          
                                          do Eating();
                                       
                                    
                                    
                                       
                                          
                                          
                                          do ReleasingForks()
                                       
                                    
                                    
                                       
                                          }
                                    
                                    
                                       
                                          }
                                    
                                 
                              
                           
                        In this code, the agent observes the observable property isHungry of a body object, mapped into a belief hungry. As soon as it is perceived to be true, the agent executes an action rule block driving the eating stage. This avoids the enforced fragmentations into plans to handle reactivity, improving encapsulation – at the price of an increased complexity of the plan model adopted and of the structures used to manage it at runtime.

Given the analysis developed in previous sections, we can draw a path from threads to actors to agents concerning the control architecture adopted to define the behavior of autonomous entities.

In a thread-based model, the control architecture accounts for a simple control flow executing some body of code, possibly traversing objects shared with other control flows.

In models based on actors with explicit receive (i.e., without the event loop), such a control flow is encapsulated into boundaries so that it cannot cross with other control flows, it can traverse objects that are inside these boundaries and an explicit blocking receive primitive is provided to react to messages.

In models based on actors with implicit receive (i.e., with the event loop), the control architecture is extended to provide a stronger discipline: it allows the programmer for abstracting from the use of low-level receive primitives by organizing the execution flow in turns or cycles, and embedding the blocking receive as an implicit part of the control architecture. This promotes a state-based organization of the actor behavior; then, the adoption of mechanisms such as continuations and futures/promises allows for partially recovering a more activity-oriented style.

Going from event loops to control loops, the implicit blocking behavior of the control flow is removed, so that conceptually the cycle is continuously running, fetching an event if available at each cycle, deciding the next action(s) to do according to the current plan(s) being executed and executing these actions. This leads to a more procedural-based organization of the behavior, allowing for integrating blocking actions without tampering reactivity. The increased complexity of the control architecture corresponds to an increase of the level of abstraction provided by the programming model, where e.g., mechanisms such as continuations are no more necessary to manage synchronous interactions or to realize articulated activities.

What is quite clear in this path is that the evolution of the level of abstraction provided to program active entities is strongly related to the evolution of the control architecture adopted. Finally, we conclude the paper with some remarks about the limits of this contribution and, accordingly, future works to overcome such limits.

In this paper we provided a first formalization of event loops and control loops, inspired by existing formalization of reactive computations [9]. Such a formalization can be further enhanced and developed, so as to make it useful to develop a more rigorous discussion of the properties, features and limits of such control architectures, as well as their comparison.

About software principles, further investigations could be developed about the impact of control architectures on the mechanisms and models that can be adopted to extend/reuse/compose the structure and behavior of actors/agents. A simple example which is mentioned also in this paper is about how easy or hard can be extending the task/behavior of a dining philosopher with the capability of promptly reacting to an alarm stimulus and evacuate, starting from the pre-existing basic implementation. This problem can be tackled in different ways depending on the kind of organization of the behavior promoted, e.g., either in states or in plans. In actor literature, most of the discussion about reuse and extensibility has been developed around the problem of inheritance anomaly [41], focusing in particular on purely reactive entities – the typical example is a bounded buffer actor. This could be the starting point to consider also more proactive entities, like agents, and organization of behaviors that are more plan-oriented, integrating existing research works about inheritance available in the context of agent programming [33,14].

Finally, a further relevant issue which has not been covered in this paper is about performance, i.e. how the control architecture may impact performance. Indeed, the evolution of the control architectures discussed before corresponds to an increase of complexity and a greater challenge in achieving efficient execution. In particular, the use of an explicit control loop in defining the behavior of an agent could lead to an important decrease of performance compared to event loops in actors. This could be devised also by considering some first benchmarking and analysis recently carried on in literature [13]. However, the level of maturity of agent technologies is far from the level of maturity in the development of actor languages; in the case of actors, different kinds of optimization have been devised and applied making the performance of event loop based actors comparable with the one based on explicit receive [37]. Analogously, we believe that a deeper study of control loop implementation schema can lead to optimizations making the performance of agents comparable to that in actor languages/frameworks. An example is given by cycling-by-need: even if the control loop is, in principle, always cycling, without blocking, it is possible to identify those situations in which cycling can be avoided since it is not going to change the actual agent state.


                     Figs. A1 and A2
                     
                     .


                     Figs. B1 and B2
                     
                     .

@&#REFERENCES@&#

