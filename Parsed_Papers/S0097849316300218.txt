@&#MAIN-TITLE@&#Artist-oriented 3D character posing from 2D strokes

@&#HIGHLIGHTS@&#


               
                  
                  
                     
                        
                           
                           Fast artist-oriented 2D stroke driven incremental refinement of 3D poses.


                        
                        
                           
                           Novel linear-time stroke-chain matching and feature extraction techniques.


                        
                        
                           
                           Modular joint rotation computation preserving joint depth and bone rigidity.


                        
                        
                           
                           Intuitive integration stroke-driven 3D pose design with Inverse Kinematics.


                        
                        
                           
                           Usability study with 22 subjects resulting in high SUS score.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Artist-oriented interface

Sketch-based system

3D character posing

@&#ABSTRACT@&#


               
                  Graphical abstract
                  
                     
                        
                           fx1
                           
                        
                     
                  
               
            

@&#INTRODUCTION@&#

3D character posing is a time-consuming process which requires not only artistic talent but also extensive technical ability. In order to achieve high artistic subtlety in the animated motions, current solutions involve separating these tasks between 2D artists and 3D animators. This separation causes an undesired loss in spontaneity and creativity. For this reason, research has recently been focused on developing more artist-oriented interfaces.

In this paper we present a novel artist-oriented 3D character posing system. It combines the advent of touch-enabled pen tablets with recent developments in sketch-based interactions, and leads to a more natural 3D character posing interface. We propose a technique which has two main advantages: firstly, our method allows for wider range of people with artistic talent to begin posing characters with complex structures. Secondly, thanks to its intuitive interface, our system helps in reducing the time spent for character animation. The benefits of our approach become even more evident when working with complex characters that have large number of DOFs. Even with state of the art tools, these characters are especially time-consuming to pose since they require very complex rigs with numerous controllers. A 2D drawing-based interface does not only preserve the inherent artistic nature of a 2D artist׳s drawn strokes but also speeds up the process of character posing by allowing a more natural medium for animation.


                     Intuitive: An artist-oriented interface should be intuitive and easy-to-use. The interactions need to closely resemble the 2D artist׳s natural workflow of using a stylus on a 2D surface. The method should not require extensive technical 3D animation knowledge, but instead employ techniques in line with a 2D artist׳s prior experience. Our interface allows 3D character posing through 2D strokes akin to a 2D artist׳s natural working methodology. The techniques used help 2D artists in bringing their 2D artistic talent into 3D character animation.


                     Real-time: One frequently observed practice among artists when drawing involves repeatedly trying multiple strokes in succession until a satisfactory stroke is obtained. The artist usually does not know the final outcome, and hence makes many attempts in order to evaluate and determine the modifications needed to achieve the final stroke [1]. For the artist to use this dialectic approach, the method must fulfill two conditions: it has to be real-time, so that the artist can immediately evaluate the intermediate steps, and it has to be deterministic, so that the results are predictable and repeatable. The technique we present in this paper satisfies both of these requirements.


                     Versatile: An artist-oriented interface should work with any character of any topology with any number of DOFs. The method should not rely on any prior data so that the artist may animate characters for which it is impossible to obtain motion capture data. Furthermore, the algorithm should work with any type of stroke. Our approach is versatile and generic and satisfies all these requirements. It does not impose any requirements on the input character or stroke.


                     Locally refinable: The artist should have full control over the final results. As a consequence, the system should provide mechanisms to animate a character at different levels of granularity. The artist should be able to draw a pose at a coarse level but, at the same time, be able to set a single joint. Our method provides both coarse and fine control. The artist can set an entire chain from head to toe, a partial chain such as a leg or an arm, or a single joint using the same technique.

@&#RELATED WORK@&#

Hand drawing has always been one of the most intuitive methods of conveying information between people. Although the media on which the drawing is performed has kept abreast of various technological advances, the techniques of natural drawing have remained unchanged. Traditional drawing techniques [2–4] are still very relevant for artists who use computer devices for drawing [5]. Therefore, ensuring that these devices have all the required elements of naturalness and intuitiveness is an important aspect of developing artist-oriented interfaces.

An early work on the dialectic nature of drawing has been researched by Goldschmidt [1]. The two separate cognitive states ‘seeing as’ and ‘seeing that’ emerging from the process of drawing and the necessity to rapidly switch between these two states have been important conditions to reproduce in computer devices. Towards achieving this goal, a number of research efforts have been developed in drawing 3D objects on 2D interfaces [6–13]. Furthermore, new techniques were developed to understand the semantics of the sketched objects [14], such as the work of Noris et al. [15] which developed a segmentation technique to distinguish different parts of sketches given a set of scribbles.

Along with objects, characters are a major element in story telling and drawing. Because humans are highly trained to understand underlying circumstances from human body movement alone, drawing characters and conveying the right information has always been an involved task. Traditionally characters have been represented as articulated figures [16,17] and their movements controlled through their articulation. Later, Inverse Kinematics (IK) techniques were developed to further speed up the animation process and retain the full control of articulated 3D characters [18,19].

More recently, various works were developed to animate characters based on stick figures using 2D interfaces: Davis et al. [20], Mao et al. [21–23], and Zamora et al. [24]. These methods first try to estimate the joint rotations from the drawn 2D stick figures and then dress the characters with appropriate models. Similarly, the algorithms by Jain et al. [25,26] use a semi-automatic method combined with a motion capture database of character postures to generate 3D characters from 2D drawings. In contrast to these works, we do not generate a character from user drawings but take it as an input from the user.

Related methods that use similar ideas for different purposes include the work by Choi et al. [27] which uses drawn stick figures in order to query similar postures from a database of motions, and the work by Lin et al. [28] which computes 3D sitting poses for characters by sketching them on a 2D interface. The work of Milliez et al. [29] uses 2D motion brushes from a painting device to generate stylized hierarchical content and movement. Miranda et al. [30] use a sketch-based interface to create facial animation for characters.

Motion doodles were used to draw motions for a character by first building a library of parametrized motions and then processing the drawn stroke to generate motions for the 3D character from this library that best fits the drawn strokes [31]. Other methods based on motion capture and optimization have been developed to learn 3D poses from a motion capture database in order to generate 3D character poses from 2D strokes [32]. Another line of attempt has been on learning poses from monocular video feed [33]. Despite the challenges in solving this problem [34], these algorithms manage to learn 3D poses based on characters silhouettes [35] or by using a low-dimensional Laplacian representation [36]. However, relying on a motion capture database is not suitable for a general solution where the artist should be able to pose 3D characters of any topology.

As we do not construct the character from the 2D drawing, but rather use a character as an input from the user, our work is closer to works which pose 3D characters through 2D strokes. Similar works solving this problem were developed by Noble et al. [37], and more recently by Guay et al. [38] which squash and stretch the bones of the character to best fit the strokes drawn by the artist. Since we implement an artist-oriented interface, we are careful to not induce any unwanted effects. In particular, squash and stretch is known to be one of the most powerful animation techniques [4] and, as such, must be used with care. For that reason, our technique employs additional constraints to enforce bone rigidity and relies on the artist to afterwards add squash and stretch effects when strictly needed.

Öztireli et al. [39] focus on providing a novel differential blending technique to handle skinning for curved bones. We, however, believe posing 3D character from 2D strokes using rigid-boned characters is still mandatory in many 3D animation applications, such as video games for example.

Other works on 3D character posing which use rigid bones are the works of Mathews et al. [40] and Guay et al. [41,42]. Similar efforts are also made at Pixar [43]. The method by Matthews et al. [40] resolves depth ambiguities based on the pressure of the drawing device and uses isomorphic mapping to find a match between the shapes of the strokes and the topology of the skeleton. However, their method does not allow for local adjustments, since it expects an entire stroke for the character to compute the isomorphism. This is not suitable for our artist-oriented interface. Moreover, resolving depth ambiguities automatically produces wrong results occasionally and thus limits the control of the artist. A better approach to resolve depth ambiguities for an artist-oriented interface is to use the camera look-at direction to pose from different views. This is the technique used by Guay et al. [41,38,42], and we also use this same approach, as this is the most suitable method for interfaces such as ours.

In terms of the technique used to solve the posing problem, the two optimization-based works of Guay et al. [41,38] are not suitable for our artist-oriented interface, as they are not scalable (cubic time complexity) and thus not sufficiently fast for large characters. Moreover, as their latter work [42] shows, and as also validated in this paper, a linear time closed-form solution exists for solving this problem. Therefore, we base our system on the closed-form method and add additional constraints to enforce bone rigidity.

As a result, our method is highly scalable and works with characters with very large number of DOFs. The closed-form solution is much faster and gives immediate results. Additionally, our approach allows for coarse-to-fine control through its local adjustment capability. This makes it possible for our method to pose any character chain without limiting them to maximum body lines. Moreover, our method has no restriction on the stroke used by the artist.


                     Contributions: We list four principles which we believe are important for an artist-oriented interface. Motivated by this, we use a general closed-form 3D character posing mechanism by solving the 2D stroke to 3D bone registration problem in a novel way. Our general solution allows solving for default- and plane-posing, as well as options for position-, and shape-tracking. Our method׳s linear time complexity is suitable for the dialectic approach required by artists [1]. Moreover, it enforces bone rigidity of the character and thus avoids inducing unwanted squash and stretch [4]. Our technique works with any kind of stroke, and it does not depend on prior motion capture data. We also provide a way to sketch poses while enforcing user-specified constraints.

@&#OVERVIEW@&#

To pose a character, the artist uses a pen to draw a 2D stroke 
                        
                           S
                           =
                           (
                           
                              
                                 p
                              
                              
                                 0
                              
                           
                           ,
                           
                              
                                 p
                              
                              
                                 1
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 p
                              
                              
                                 n
                              
                           
                           )
                           ,
                           
                              
                                 p
                              
                              
                                 i
                              
                           
                           ∈
                           
                              
                                 R
                              
                              
                                 2
                              
                           
                        
                     . The input points may not be evenly distributed, so we uniformly reparametrize S into a piecewise cubic Hermite spline S(t) such that t represents the arc-length of the stroke. The character 
                        
                           Ω
                           (
                           J
                           )
                        
                      is a tree whose vertices are the set of all joints J. A skeletal chain 
                        
                           X
                           ⊆
                           J
                        
                      is a sequence of joints forming a path π between any two joints of Ω.

The 3D character posing can be separated into four problems: stroke-chain matching, which picks an appropriate skeletal chain X for a given S(t) (Section 4); intermediate representation which pre-processes S(t) and prepares it for feature point extraction (Section 5); feature extraction which finds a matching between segments of S(t) and bones of X (Section 6); and joint alignment which computes the joint rotations of X according to S(t) (Section 7).


                     Stroke-chain matching is done automatically to match a chain X from Ω with the stroke S(t). The matching algorithm traverses down Ω and uses the local gradient of S(t) to pick a child at the branches of Ω. As discussed in Section 4, the general form of this problem is highly difficult to solve due to the ambiguities arising from capturing the artist׳s intentions. Therefore, we also provide a mechanism for the artist to resolve these ambiguities by selecting the chain manually. When the user chooses X manually, the 2D stroke to 3D chain matching is not invoked.


                     Intermediate representation changes the representation of S(t) depending on the chain X. This step may involve scaling, splitting, translating, and reversing the direction of S(t). These steps ensure that good feature extraction and joint alignment can be obtained for S(t) and X.


                     Feature extraction solves the problem of extracting interesting feature points from S(t) by defining a discrete matching function 
                        
                           w
                           (
                           i
                           )
                           =
                           (
                           S
                           (
                           
                              
                                 u
                              
                              
                                 i
                              
                           
                           )
                           ,
                           S
                           (
                           
                              
                                 v
                              
                              
                                 i
                              
                           
                           )
                           )
                        
                     , 
                        
                           w
                           :
                           N
                           →
                           
                              
                                 R
                              
                              
                                 2
                              
                           
                           ×
                           
                              
                                 R
                              
                              
                                 2
                              
                           
                        
                     . This function associates the feature points on S(t) with the joints x
                     
                        i
                      of the chain X in a robust manner by accounting for noise within S(t). The matching function generates a partitioning of S(t), such that each individual section w(i) is associated with a bone 
                        
                           (
                           
                              
                                 x
                              
                              
                                 i
                              
                           
                           ,
                           
                              
                                 x
                              
                              
                                 i
                                 +
                                 1
                              
                           
                           )
                        
                     . We propose a closed-form solution for defining the matching function w(i) which solves the 2D stroke to 3D bone registration problem.


                     Joint alignment computes the joint rotations of X according to feature extraction function 
                        
                           w
                           (
                           
                              
                                 x
                              
                              
                                 i
                              
                           
                           )
                        
                     . Rotations may also be computed using plane-posing mode, depending on which option is requested by the artist for a given case leading to different results. This module also solves for position-, or shape-tracking.

This section discusses the problem of finding X within Ω given S(t). Understanding and finding a good solution for this problem is not only important for enabling local-refinability, but it also has implications on the practicality of the method.

In general, this problem was solved by only considering maximum body lines [41,38]. Although this choice is suitable for line-of-action strokes, as these strokes are intended to modify the entire posture of the character, it does not allow for the local-refinability of the pose. Therefore, we relax this requirement for our interface and allow more general strokes. Being able to pose any chain of the skeleton greatly enhances the usability of the method. As there are 
                        
                           n
                           (
                           n
                           −
                           1
                           )
                        
                      possible chains in a skeleton with n joints, solving for all of them and picking the chain which leads to the lowest error [41,38] is no longer practical. We propose a more efficient and intuitive way of solving the stroke-chain matching problem.

In its most general sense, the challenge of finding a matching between the stroke and the chain is highly ambiguous (Figs. 1 and 2
                     
                     ). The artist uses S(t) to find a chain X but at the same time poses X according to S(t). Since a chain X is uniquely defined by its two end joints 
                        
                           〈
                           
                              
                                 x
                              
                              
                                 0
                              
                           
                           ,
                           
                              
                                 x
                              
                              
                                 n
                              
                           
                           〉
                        
                     , we suggest picking these two joints in the following manner: we let the user pick the starting joint x
                     0 by starting to draw S(t) in the vicinity of x
                     0 and then run a graph traversal on the character skeleton, as guided by S(t), to find the end joint x
                     
                        n
                      (without posing the chain). This solution is not only in line with natural drawing techniques, but it is also efficient, as it is on average logarithmic on the number of skeletal joints.

However, this approach alone is not sufficient to resolve an often occurring ambiguity of the stroke-chain matching problem. When traversing the skeleton starting from x
                     0, it is not clear in which direction the traversal should occur (see Fig. 1). Therefore, we only allow traversals which are downwards through the skeletal hierarchy. In addition, when faced with a branching joint, we base our decision on the local gradient of S(t). Depending on the shape of S(t), our algorithm chooses the closest branch to S(t) and continues traversing downwards from this joint. The exact metric is explained in Section 7 and is based on the magnitude of the computed joint rotations at the branching joints.

Nevertheless, these design choices alone do not clear all the ambiguities. The algorithm cannot always capture the intention of the artist, even if algorithmically it makes the “right” choice (see Fig. 2). Hence, we additionally allow the user to select a direction joint x
                     
                        d
                      before drawing the stroke S(t). As discussed earlier, we use S(t) to pick the initial joint x
                     0 and, with the added direction joint x
                     
                        d
                     , we traverse within the uniquely defined chain 
                        
                           
                              
                                 X
                              
                              
                                 d
                              
                           
                           =
                           〈
                           
                              
                                 x
                              
                              
                                 0
                              
                           
                           ,
                           
                              
                                 x
                              
                              
                                 d
                              
                           
                           〉
                        
                      and return a final chain 
                        
                           X
                           =
                           〈
                           
                              
                                 x
                              
                              
                                 0
                              
                           
                           ,
                           
                              
                                 x
                              
                              
                                 n
                              
                           
                           〉
                           ∈
                           
                              
                                 X
                              
                              
                                 d
                              
                           
                        
                     . This way, we can ensure that the artist can easily clear any ambiguity by first picking a direction joint.

The last remaining unhandled scenario involves cases where the artist wishes to pose a character by drawing a stroke which does not start in the vicinity of a joint (see Fig. 3
                     ). For these cases, it is necessary that the artist choose both the start joint x
                     0 and end joint x
                     
                        n
                      manually. This form of selection is usually needed when posing long chains with line-of-action like strokes.

The intermediate representation module modifies the stroke S(t) in order to ensure that requirements of the feature extraction module are met. When solving only for the shape of the stroke in order to pose a chain [38], the stroke processing is not essential. However, to solve a more general instance of this problem, intermediate representation of the stroke is important for the overall method to succeed. For there to be an intersection between the projected stroke S(t) and the chain X, the beginning of S(t) has to be translated on top of the first joint of X. In addition, the hierarchical direction of the chain X and that of the stroke S(t) must be the same.

This module receives a chain X as an input from the 2D stroke to 3D chain matching module. Depending on where X is situated within the skeleton Ω, we process the stroke in two separate ways. When X is on one branch of Ω (Fig. 2), we call this type of posing Forward Posing (FP); otherwise, we are in Over-Root (OR) posing (Fig. 3). Since the stroke S(t) for FP posing already starts on top of a joint of X and traverses only in one direction, no stroke processing is needed for this type of posing. However, for OR posing, additional steps are taken.

When OR posing, the stroke S(t) may start anywhere on the screen and may be of any length. Therefore, the first step is to scale S(t) such that its arc-length matches the length of the chain X, defined as 
                           
                              ∥
                              X
                              ∥
                              =
                              
                                 
                                    ∑
                                 
                                 
                                    i
                                 
                              
                              ∥
                              
                                 
                                    Px
                                 
                                 
                                    i
                                 
                              
                              −
                              
                                 
                                    Px
                                 
                                 
                                    i
                                    +
                                    1
                                 
                              
                              ∥
                           
                         for some projection 
                           
                              P
                              :
                              
                                 
                                    R
                                 
                                 
                                    3
                                 
                              
                              →
                              
                                 
                                    R
                                 
                                 
                                    2
                                 
                              
                           
                        . The scaling gives the artist the freedom to draw strokes of any length without having to make sure that the chain X and the stroke S(t) are of the same arc-length.

The second step determines whether the stroke needs to be split into separate strokes. This step is required due to the coupled nature of our feature extraction and joint alignment method as explained in Section 7. If the chain X is only on one branch of the Ω skeleton, then splitting is not necessary. However, if the chain is situated within two different branches of Ω (Fig. 3), as in the OR posing, then X needs to be posed using split strokes. In this case, the feature extraction and joint alignment algorithms run on the two branches separately. From the user experience perspective, the method appears to be working on one single stroke. For example, if the artist is selecting the right arm and the left foot, the stroke is split in half: one starting at the root of the skeleton down to the right arm and the other from the root to the left foot.

If the joints x
                        0 and x
                        
                           n
                         meet at some common ancestor 
                           
                              
                                 
                                    x
                                 
                                 
                                    r
                                 
                              
                              ∈
                              X
                           
                        , then X is divided into 
                           
                              
                                 
                                    X
                                 
                                 
                                    begin
                                 
                              
                              =
                              (
                              
                                 
                                    x
                                 
                                 
                                    0
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    x
                                 
                                 
                                    r
                                    −
                                    1
                                 
                              
                              )
                           
                        , 
                           
                              
                                 
                                    X
                                 
                                 
                                    middle
                                 
                              
                              =
                              (
                              
                                 
                                    x
                                 
                                 
                                    r
                                 
                              
                              )
                           
                        , and 
                           
                              
                                 
                                    X
                                 
                                 
                                    end
                                 
                              
                              =
                              (
                              
                                 
                                    x
                                 
                                 
                                    r
                                    +
                                    1
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    x
                                 
                                 
                                    n
                                 
                              
                              )
                           
                        , and, similarly, the stroke S(t) is split into three parts:
                           
                              (1)
                              
                                 
                                    
                                       
                                          
                                          S
                                       
                                       
                                          begin
                                       
                                    
                                    (
                                    t
                                    )
                                    =
                                    S
                                    (
                                    0
                                    ,
                                    ∥
                                    
                                       
                                          X
                                       
                                       
                                          begin
                                       
                                    
                                    ∥
                                    )
                                    
                                       
                                          S
                                       
                                       
                                          middle
                                       
                                    
                                    (
                                    t
                                    )
                                    =
                                    S
                                    (
                                    ∥
                                    
                                       
                                          X
                                       
                                       
                                          begin
                                       
                                    
                                    ∥
                                    ,
                                    ∥
                                    
                                       
                                          X
                                       
                                       
                                          begin
                                       
                                    
                                    ∥
                                    +
                                    ∥
                                    (
                                    
                                       
                                          x
                                       
                                       
                                          r
                                          −
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          x
                                       
                                       
                                          r
                                          +
                                          1
                                       
                                    
                                    )
                                    ∥
                                    )
                                    
                                       
                                          S
                                       
                                       
                                          end
                                       
                                    
                                    (
                                    t
                                    )
                                    =
                                    S
                                    (
                                    ∥
                                    
                                       
                                          X
                                       
                                       
                                          begin
                                       
                                    
                                    ∥
                                    +
                                    ∥
                                    (
                                    
                                       
                                          x
                                       
                                       
                                          r
                                          −
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          x
                                       
                                       
                                          r
                                          +
                                          1
                                       
                                    
                                    )
                                    ∥
                                    ,
                                    ∥
                                    X
                                    ∥
                                    )
                                 
                              
                           
                        The stroke S(t) is split in this manner, because we have to set the rotation of the root x
                        
                           r
                         first and then the two individual branches X
                        
                           begin
                        , and X
                        
                           end
                        . The next step is to reverse the direction of S
                        
                           begin
                        (t) such that it matches the direction of the X
                        
                           begin
                         chain, as seen within the Ω skeleton. The reversed stroke is defined as: 
                           
                              
                                 
                                    S
                                 
                                 
                                    begin
                                 
                                 
                                    ′
                                 
                              
                              (
                              t
                              )
                              =
                              
                                 
                                    S
                                 
                                 
                                    begin
                                 
                              
                              (
                              ∥
                              
                                 
                                    X
                                 
                                 
                                    begin
                                 
                              
                              ∥
                              −
                              t
                              )
                           
                        .

When analysing S(t) and posing X, S(t) is always analyzed according to its direction. In FP posing, the direction is determined as drawn by the artist. However, when in OR posing, we associate 
                           
                              S
                              (
                              0
                              )
                           
                         with the x
                        0 joint and 
                           
                              S
                              (
                              
                                 
                                    t
                                 
                                 
                                    end
                                 
                              
                              )
                           
                         with the x
                        
                           n
                         joint. For example (see Fig. 4
                        ), if the artist selects the left ankle of a humanoid character, then the right ankle, and then makes a stroke from the left to the right (drawing from the side of the character), the left ankle will be in front of the character and the right ankle will be behind the character. However, if the artist draws from the right side to the left side of the screen, then the legs will be in opposite sides; that is, the left leg would be behind and the right leg in the front of the character. This ensures that x
                        0 is associated with the beginning of the stroke 
                           
                              S
                              (
                              0
                              )
                           
                         and the second selected joint x
                        
                           n
                         with the end of the stroke 
                           
                              S
                              (
                              
                                 
                                    t
                                 
                                 
                                    end
                                 
                              
                              )
                           
                        . This gives the artists an additional degree of control.

The last step of stroke processing involves translating the stroke S(t). In FP posing 
                           
                              S
                              (
                              0
                              )
                           
                         is already close to x
                        0, and thus, in this mode, we only slightly translate S(t). The translation ensures 
                           
                              S
                              (
                              0
                              )
                           
                         is exactly aligned with the projection of the joint x
                        0, i.e. 
                           
                              ∥
                              
                                 
                                    Px
                                 
                                 
                                    0
                                 
                              
                              −
                              S
                              (
                              0
                              )
                              ∥
                              =
                              0
                           
                        . When the chain X is manually selected, the artist may draw S(t) anywhere on the screen. In this case, we perform the following depending on where X falls in Ω: if X falls on the same branch of Ω, then we translate S(t) similarly to the FP posing; otherwise, if OR posing, we translate the strokes separately such that 
                           
                              ∥
                              
                                 
                                    S
                                 
                                 
                                    begin
                                 
                                 
                                    ′
                                 
                              
                              (
                              0
                              )
                              −
                              
                                 
                                    Px
                                 
                                 
                                    r
                                    −
                                    k
                                 
                              
                              ∥
                              =
                              0
                           
                         and 
                           
                              ∥
                              
                                 
                                    S
                                 
                                 
                                    end
                                 
                              
                              (
                              0
                              )
                              −
                              
                                 
                                    Px
                                 
                                 
                                    r
                                    +
                                    k
                                 
                              
                              ∥
                              =
                              0
                           
                        . For an example, see Fig. 3.

The most challenging part of posing 3D characters through 2D strokes is finding a good matching between the stroke S(t) and the joints 
                        
                           
                              
                                 x
                              
                              
                                 i
                              
                           
                           ∈
                           X
                        
                     . We define a discrete matching function 
                        
                           w
                           (
                           i
                           )
                           →
                           (
                           S
                           (
                           
                              
                                 u
                              
                              
                                 i
                              
                           
                           )
                           ,
                           S
                           (
                           
                              
                                 v
                              
                              
                                 i
                              
                           
                           )
                           )
                        
                      which associates a discrete bone 
                        
                           (
                           
                              
                                 x
                              
                              
                                 i
                              
                           
                           ,
                           
                              
                                 x
                              
                              
                                 i
                                 +
                                 1
                              
                           
                           )
                        
                      with a corresponding segment 
                        
                           S
                           (
                           
                              
                                 u
                              
                              
                                 i
                              
                           
                           ,
                           
                              
                                 v
                              
                              
                                 i
                              
                           
                           )
                        
                      on the continuous stroke S(t). For each joint x
                     
                        i
                     , we need to find two parameters u
                     
                        i
                      and v
                     
                        i
                      to compute the local rotation q
                     
                        i
                     . One naive approach would be to partition S(t) according to the travelled projected distance of the joint x
                     
                        i
                      over the chain X, such that 
                        
                           
                              
                                 u
                              
                              
                                 i
                              
                           
                           =
                           
                              
                                 ∑
                              
                              
                                 i
                              
                           
                           ∥
                           
                              
                                 Px
                              
                              
                                 i
                              
                           
                           −
                           
                              
                                 Px
                              
                              
                                 i
                                 −
                                 1
                              
                           
                           ∥
                        
                      and 
                        
                           
                              
                                 v
                              
                              
                                 i
                              
                           
                           =
                           
                              
                                 u
                              
                              
                                 i
                              
                           
                           +
                           ∥
                           
                              
                                 Px
                              
                              
                                 i
                                 +
                                 1
                              
                           
                           −
                           
                              
                                 Px
                              
                              
                                 i
                              
                           
                           ∥
                        
                     . However, a frequently observed behavior among artists is that, although they can very accurately reproduce a drawing respecting its relative proportions and shape, they can rarely reproduce it respecting its absolute dimensions. Therefore, our approach accounts for this and provides the artist with the flexibility of drawing naturally.

We process the stroke in a similar fashion as Koparkar et al. [44], but instead we use the curvature of S(t) for partitioning. High curvatures best capture turns usually seen in the joints of articulated figures. Although we discuss joint alignment in the next section (Section 7), feature extraction and joint alignment are intertwined and are performed in sequence for each joint during the feature extraction procedure. See Fig. 5
                      for a depiction of this procedure. For x
                     0, 
                        
                           
                              
                                 u
                              
                              
                                 0
                              
                           
                           =
                           0
                        
                      since 
                        
                           ∥
                           
                              
                                 Px
                              
                              
                                 0
                              
                           
                           −
                           
                              
                                 S
                              
                              
                                 0
                              
                           
                           ∥
                           =
                           0
                        
                      as required during the intermediate representation module (Section 5). We then find an intermediate point 
                        
                           
                              
                                 v
                              
                              
                                 i
                              
                              
                                 ′
                              
                           
                           =
                           
                              
                                 u
                              
                              
                                 i
                              
                           
                           +
                           ∥
                           
                              
                                 Px
                              
                              
                                 i
                                 +
                                 1
                              
                           
                           −
                           
                              
                                 Px
                              
                              
                                 i
                              
                           
                           ∥
                        
                      by traveling along S(t) as far as the length of the projected bone between x
                     
                        i
                      and 
                        
                           
                              x
                           
                           
                              i
                              +
                              1
                           
                        
                      (right column of Fig. 5). This point defines the center of the window on which we look for the highest curvature point v
                     
                        i
                     . The half range of the window is set to 
                        
                           τ
                           =
                           ∥
                           
                              
                                 Px
                              
                              
                                 i
                                 +
                                 1
                              
                           
                           −
                           
                              
                                 Px
                              
                              
                                 i
                              
                           
                           ∥
                           /
                           3
                        
                     , and v
                     
                        i
                      is defined as follows:
                        
                           (2)
                           
                              
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                 
                                 =
                                 argmax
                                 ∥
                                 
                                    
                                       
                                          
                                             
                                                d
                                             
                                             
                                                2
                                             
                                          
                                          S
                                       
                                       
                                          
                                             
                                                dt
                                             
                                             
                                                2
                                             
                                          
                                       
                                    
                                    (
                                    
                                       
                                          t
                                       
                                       
                                          k
                                       
                                    
                                    )
                                 
                                 ∥
                                 ,
                                 
                                 ∀
                                 
                                    
                                       t
                                    
                                    
                                       k
                                    
                                 
                                 ∈
                                 {
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                    
                                       ′
                                    
                                 
                                 −
                                 τ
                                 ,
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                    
                                       ′
                                    
                                 
                                 −
                                 τ
                                 +
                                 
                                    ks
                                 
                                 ,
                                 …
                                 ,
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                    
                                       ′
                                    
                                 
                                 +
                                 τ
                                 }
                              
                           
                        
                     where 
                        
                           k
                           ∈
                           
                              
                                 N
                              
                              
                                 +
                              
                           
                        
                      and s is the distance between two consecutive samples. The value of s is predefined and remains constant. In our implementation s is set to 1 pixel. Having a window for the computation of the v
                     
                        i
                      provides the flexibility we require in our method. However, it has the side effect of causing a discrepancy between how fast we travel on S(t) and the chain X. If we happen to continuously pick the farthest point in the window for our v
                     
                        i
                      computation, S(t) will advance a lot faster than X. Similarly, if we pick the nearest point, S(t) will lag behind X. Therefore, a renormalization is required to make sure that these two steps advance in synchronization. To achieve this, we compute the u
                     
                        i
                      parameter as the closest point on the stroke S(t) to the x
                     
                        i
                      joint (left column of Fig. 5) after the rotation of 
                        
                           
                              x
                           
                           
                              i
                              −
                              1
                           
                        
                      has been applied (Section 7). The computation of u
                     
                        i
                      is also done along a window on S(t). The window is situated at point 
                        
                           
                              
                                 u
                              
                              
                                 i
                              
                              
                                 ′
                              
                           
                           =
                           
                              
                                 ∑
                              
                              
                                 1
                              
                              
                                 i
                              
                           
                           ∥
                           
                              
                                 Px
                              
                              
                                 i
                              
                           
                           −
                           
                              
                                 Px
                              
                              
                                 i
                                 −
                                 1
                              
                           
                           ∥
                        
                      with a half range 
                        
                           τ
                           =
                           ∥
                           
                              
                                 Px
                              
                              
                                 i
                              
                           
                           −
                           
                              
                                 Px
                              
                              
                                 i
                                 −
                                 1
                              
                           
                           ∥
                           /
                           3
                        
                     , and u
                     
                        i
                      is defined as:
                        
                           (3)
                           
                              
                                 
                                    
                                       u
                                    
                                    
                                       i
                                    
                                 
                                 =
                                 argmin
                                 ∥
                                 S
                                 (
                                 
                                    
                                       t
                                    
                                    
                                       k
                                    
                                 
                                 )
                                 −
                                 
                                    
                                       Px
                                    
                                    
                                       i
                                    
                                 
                                 ∥
                                 ,
                                 
                                 ∀
                                 
                                    
                                       t
                                    
                                    
                                       k
                                    
                                 
                                 ∈
                                 {
                                 
                                    
                                       u
                                    
                                    
                                       i
                                    
                                    
                                       ′
                                    
                                 
                                 −
                                 τ
                                 ,
                                 
                                    
                                       u
                                    
                                    
                                       i
                                    
                                    
                                       ′
                                    
                                 
                                 −
                                 τ
                                 +
                                 
                                    ks
                                 
                                 ,
                                 …
                                 ,
                                 
                                    
                                       u
                                    
                                    
                                       i
                                    
                                    
                                       ′
                                    
                                 
                                 +
                                 τ
                                 }
                              
                           
                        
                     At this point we have computed both u
                     
                        i
                      and v
                     
                        i
                     , and we can use this information to compute the rotation q
                     
                        i
                      for the joint x
                     
                        i
                     . Feature matching is performed for all the bones of the chain X or until the procedure fully exhausts the stroke S(t).

In this section, we show how to set the rotation of the joints given the feature extraction performed in Section 6. Joint alignment is presented in a general and modular fashion in order to enable our method to produce different results depending on the needs of the artists. This allows our approach to achieve default- and plane-posing for both position- and shape-tracking. In addition, we make sure that the joint alignment module preserves important aspects, such as maintaining the z-depth and the twists of the joints, which are crucial for interfaces where the depth ambiguity is resolved by changing the camera view.

As the artist continuously changes the camera to pose from different views, it is important to make sure that posing from one view does not disrupt postures posed from a previous view. A 2D stroke may define the joint positions on the 2D plane but cannot specify the depth information. Therefore we want to keep their z-depths intact. This is important, because failing to maintain the z-depth of a chain makes it very difficult for the artist to converge to a desired 3D pose by repeatedly drawing from different 2D views. Moreover, to this end, it is also important not to change the bone length of the character when posing. If the bone lengths of the character are modified, the z-depth of the joints x
                        
                           i
                         are not preserved. In addition, by preserving the bone length, we do not propagate the noise from S(t) into the character. This prevents the artist from posing a character into a posture where the character has different lengths for its symmetric limbs, such as arms and legs. Therefore, we allow only rotations about the axis which is defined by the camera view. These restrictions automatically ensure that the z-depths of the joints are preserved between drawings (Fig. 6
                        ).

For a given bone b associated with two joints 
                           
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    x
                                 
                                 
                                    i
                                    +
                                    1
                                 
                              
                              ∈
                              X
                           
                        , the goal is to compute the rotation q
                        
                           i
                         applied to the bone b at joint x
                        
                           i
                        . Fig. 7
                         shows a diagram of the steps that compute the magnitude of the joint rotation. Since we preserve the rigidity of the bone, our first constraint limits 
                           
                              
                                 x
                              
                              
                                 i
                                 +
                                 1
                              
                           
                         around a sphere Ψ centered at x
                        
                           i
                         with radius 
                           
                              ∥
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                              −
                              
                                 
                                    x
                                 
                                 
                                    i
                                    +
                                    1
                                 
                              
                              ∥
                           
                        . The second requirement of maintaining the z-depth of 
                           
                              
                                 x
                              
                              
                                 i
                                 +
                                 1
                              
                           
                         constrains 
                           
                              
                                 x
                              
                              
                                 i
                                 +
                                 1
                              
                           
                         on a plane Φ centered at 
                           
                              
                                 x
                              
                              
                                 i
                                 +
                                 1
                              
                           
                         with a normal as that of the camera look-at direction 
                           
                              
                                 n
                              
                              
                                 ^
                              
                           
                        . The intersections between the sphere Ψ and plane Φ leaves us with a circle C:
                           
                              (4)
                              
                                 
                                    C
                                    =
                                    Ψ
                                    (
                                    
                                       
                                          x
                                       
                                       
                                          i
                                       
                                    
                                    ,
                                    ∥
                                    
                                       
                                          x
                                       
                                       
                                          i
                                          +
                                          1
                                       
                                    
                                    −
                                    
                                       
                                          x
                                       
                                       
                                          i
                                       
                                    
                                    ∥
                                    )
                                    ∩
                                    Φ
                                    (
                                    
                                       
                                          x
                                       
                                       
                                          i
                                          +
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          n
                                       
                                       
                                          ^
                                       
                                    
                                    )
                                 
                              
                           
                        centered on some point p on 
                           
                              Φ
                              (
                              
                                 
                                    x
                                 
                                 
                                    i
                                    +
                                    1
                                 
                              
                              )
                           
                        . Next we use the matching points on the stroke S(t) for the bone b as returned from the matching function w(i). This function returns two points 
                           
                              (
                              
                                 
                                    S
                                 
                                 
                                    a
                                 
                              
                              ,
                              
                                 
                                    S
                                 
                                 
                                    b
                                 
                              
                              )
                           
                         on S(t) which represent the portion of the stroke that corresponds to the bone b. Then, we unproject these two points by casting a ray into the scene fustrum to obtain two lines 
                           
                              
                                 
                                    l
                                 
                                 
                                    a
                                 
                              
                              =
                              ρ
                              (
                              
                                 
                                    S
                                 
                                 
                                    a
                                 
                              
                              )
                           
                         and 
                           
                              
                                 
                                    l
                                 
                                 
                                    b
                                 
                              
                              =
                              ρ
                              (
                              
                                 
                                    S
                                 
                                 
                                    b
                                 
                              
                              )
                           
                        , where the function ρ casts a ray to the scene for a given point on the 2D screen. The intersection between l
                        
                           a
                         and l
                        
                           b
                         with the plane Φ gives us two 3D points 
                           
                              r
                              =
                              Φ
                              ∩
                              
                                 
                                    l
                                 
                                 
                                    a
                                 
                              
                           
                         and 
                           
                              s
                              =
                              Φ
                              ∩
                              
                                 
                                    l
                                 
                                 
                                    b
                                 
                              
                           
                        . The problem can now be reduced to finding an intersection between the circle C and the line 
                           
                              
                                 rs
                              
                              
                                 →
                              
                           
                         to obtain a point 
                           
                              k
                              =
                              C
                              ∩
                              
                                 
                                    rs
                                 
                                 
                                    →
                                 
                              
                           
                        . Once we find the point k, the new bone location is defined by the 3D vector 
                           
                              
                                 
                                    
                                       x
                                    
                                    
                                       i
                                    
                                 
                                 k
                              
                              
                                 →
                              
                           
                        . The last step is to compute the local joint rotation q
                        
                           i
                         directly from 
                           
                              
                                 
                                    
                                       x
                                    
                                    
                                       i
                                    
                                 
                                 k
                              
                              
                                 →
                              
                           
                        .

When joint x
                        
                           i
                         has many children, we compute q
                        
                           i
                         for each of its children and pick the child whose computed rotation q
                        
                           i
                         has the lowest rotational magnitude. This metric is also used for the 2D stroke to 3D chain matching problem explained in Section 4 and determines which branches are picked within Ω when finding a chain X according to S(t).

When the bone b is parallel with the camera look-at direction 
                           
                              
                                 n
                              
                              
                                 ^
                              
                           
                        , b cannot be set because there exists no solution where the z-depth of the bone could be maintained. For the artist to set such a bone, she has to make sure that the bone is not fully parallel with the camera look-at direction. In the event when multiple bones are set, the ones which are aligned with the camera are skipped and are not set.

In complement to default-posing, we offer plane-posing which allows posing of bones regardless of their current joint orientation. This mode is convenient for posing bones which are aligned with the camera look-at direction. The artist has to request plane-posing proactively since, in this mode, z-depth joints are not preserved. This tool is powerful, as it enhances default-posing and can be used in conjunction with it depending on the needs of the artist. To compute the new bone position in plane-posing, we move the plane Φ from Eq. (4) from 
                           
                              
                                 x
                              
                              
                                 i
                                 +
                                 1
                              
                           
                         to x
                        
                           i
                        . As a result, the solution circle C always has a radius of 
                           
                              ∥
                              
                                 
                                    x
                                 
                                 
                                    i
                                    +
                                    1
                                 
                              
                              −
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                              ∥
                           
                        , and the final bone is always orthogonal to the camera look-at direction. The rest of the computations are identical to the default joint alignment.

When posing a bone by drawing a stroke, an artist has two options: favoring the position of the stroke or favoring its shape. See Fig. 15 for an example. By default, we choose to follow the position, such that the 3D chain matches the 2D stroke as closely as possible. However, the artist may want to follow the shape of S(t) instead. In cases when the artist wants to follow the shape, we perform an additional step in the joint alignment module. In position-tracking, when computing the intersection point k between the circle C and line 
                           
                              
                                 rs
                              
                              
                                 →
                              
                           
                        , we do not translate the line 
                           
                              
                                 rs
                              
                              
                                 →
                              
                           
                         such that 
                           
                              ∥
                              r
                              −
                              
                                 
                                    Px
                                 
                                 
                                    i
                                 
                              
                              ∥
                              =
                              0
                           
                        , because we favor the position of S(t). However if we make the above translation, such that x
                        
                           i
                         and r are aligned, then we would change the intersection point k and thus prefer the shape of the stroke instead of its position. The preference between tracking the position or shape can be made in both default-posing and plane-posing. Both of these modes are very useful depending on the situation. A few examples are also shown in the accompanying video.

As the rotation axes of the joints are constrained by the viewing plane, all the computed joint rotations are swing rotations. However, compounding swing rotations may induce an undesired twist rotation [45]. This is a major inconvenience for systems that use the viewing plane as a rotational constraint. See the accompanying video for an example. Therefore it is important to remove the induced twist from the posed bones. We overcome this problem in our joint alignment module by directly computing the joint rotations instead of compounding swing rotations. However, even though this solves the problem of the induced twist, we still have to maintain the twist set by the user. Hence we perform a swing-twist decomposition of the joint rotation along its bone direction 
                           
                              q
                              =
                              
                                 
                                    q
                                 
                                 
                                    sw
                                 
                              
                              
                                 
                                    q
                                 
                                 
                                    tw
                                 
                              
                           
                        . Then we record the twist rotation q
                        
                           tw
                         prior to aligning the bone and reapply it after the bone has been aligned. This decomposition avoids inducing a twist and maintains its original twist across drawings from different camera views.

Our posing technique also includes a mechanism to satisfy user specified constraints. We achieve this by first solving the posing problem for a given stroke, and then using the resulting posture as a reference for our Inverse Kinematics (IK) method. This produces a final pose which satisfies the constraints while remaining as close as possible to the drawn pose.

Our IK method is based on a prioritized IK which can solve for multiple end effectors [19,46]. The user specified constraints are considered of highest priority, with the end result obtained from the posing considered as secondary priority. This combination turns posing into a powerful tool which works along with user provided constraints. Fig. 8
                      shows an example of sketching on top of an arm with the left hand being constrained.

@&#RESULTS@&#

We evaluated our method׳s performance and its usability by running several experiments. We first measured the computational time of our technique to validate that it is fast enough for an interactive interface. We then conducted an interface usability user evaluation with 22 subjects who had varying degree of experience. The subjects were asked to perform posing tasks on two different characters and then give a usability score to our method. We also asked a novice user, who had no prior 3D posing experience, to test our software. In addition, we tried to pose a chain into a spiral using only two strokes. A result of this trial is shown in the video. We now explain our experiments and present our results next.

We conducted all the experiments mentioned in this section on an Apple Mac mini computer (MacOSX 10.10) with a i7 Intel processor and 16GB of memory. The artists used a Wacom Cintiq 24HD Touch interactive pen display to pose the characters (Fig. 9
                        ). We found the mouse pointer to be ineffective and not sufficiently precise for 3D pose drawing. For the camera manipulation, we implemented a driver to make use of the tablet׳s touch capabilities (Fig. 10
                        ). We let the users pose different characters using our artist-oriented interface. Some examples are shown in Figs. 11 and 12
                        
                        .

Our method is designed to use the default-posing algorithm, but it also provides an option to the user to switch to plane-posing by pressing a button on the interface. The values presented here measured computations involving 2D stroke to 3D chain matching, intermediate representation, feature extraction, and joint alignment. We experimented with 3 different skeletons of various joint numbers and topology and measured the time taken to compute the joint rotations of the character. Table 1
                         shows the results of the experiment. As can be seen from the table, our method is very fast and can compute a rotation for a joint in about 0.10ms.

To confirm the linear scalability of our method, we took the octopus examples and plotted the average times required to pose chains of different sizes. Fig. 13
                         shows the time-complexity of our method for all the 589 strokes in the ‘Octopus’ example of Table 1. Here we see individual times for the different strokes as a function of the number of joints, including the minimum and maximum times for each joint. As can be seen from the figure, the time complexity of the algorithm is linear in the number of joints. In the largest example posing the longest chain of the ‘Octopus’ character which contained 45 joints, our algorithm runs in less than 6ms. This fast computation makes it possible for the artist to receive immediate feedback as intermediate strokes are posed. The artist can make repeated strokes on parts of the tentacle until the final form is reached. This is important, because the artist usually tries various strokes before settling for the desired pose [1].

The closest prior work to our proposed approach is the work by Guay et al. [38]. Similarly to our work, this method uses line-of-action strokes to pose 3D characters in linear time. For a fair comparison, we have slightly modified their method: we have relaxed their requirement of posing only maximum body lines; we have also disabled the automatic bone length modification used in their joint computation in order to preserve the z-depth of the joints as we do in our method. In other words, their method can be seen as an instance of our default-posing with shape-tracking. Their method, however, uses uniform sampling of the stroke instead of performing any feature extraction as we do in Section 6. Fig. 14
                         shows some differences between the two methods which highlight the importance of providing additional posing options to the artist.

We tested our method with a novice user who had no prior experience with 3D character posing and observed the results. Examples from one such session are shown in Fig. 15
                        . The user was able to pose various postures for different actions in a matter of minutes. Thanks to the closed-form solution, the user quickly learned how the algorithm worked and was able to improve her posing as she began predicting the solution for a given stroke. Our observations of novice users showed that the natural sketching interface is highly intuitive for users who have no 3D experience allowing them to pose compelling postures quickly.

Usability testing of our method was conducted to investigate the usability benefits of our artist-oriented interface. The testing was based on Brooke׳s SUS survey [47]. We now discuss the user profile, the experimental setup, and the evaluation results of this usability study.

We sampled subjects similar to the study done by Matthews et al. [40]. Our participating subjects were also not required to have any extensive background in 2D or 3D animation, a strong mathematical background, nor technical skills. The users were only required to have basic drawing skills.

There were 22 subjects participating in our evaluations. Eleven subjects were complete beginners and had no experience with 2D or 3D animation, nine subjects had some experience with 3D modelling (of which six had one year or less experience with 3D modelling, and the remaining three had more than one year experience). Two of the subjects were professional 2D or 3D animators. There were 18 males subjects and four female subjects. Three of the subjects were in their teenage years, 13 subjects in their 20s, four subjects in their 30s, and two subject in their 40s. Two of the subjects were left-handed.

The users were instructed to control the camera through Wacom Cintiq׳s touch interface and draw using its pen device. They were given a task plan with four tasks and an SUS questionnaire once they had finished the tasks. The experimental procedure began by giving a 1min brief introduction to Cintiq and our method. Then the subject proceeded to complete the tasks in the task plan. The subjects were timed as they were completing the tasks.


                           Task 1: Load the application, load a 3D character, draw anywhere on the display, and learn how to manipulate the camera through Cintiq׳s touch interface (zoom, orbit, pan).


                           Task 2: Load an octopus character, learn to draw using Forward Posing and Over-Root Posing. In addition, learn how to undo, set a key, and replay the motion in the timeline. Lastly, save the resulting motion into a file.


                           Task 3: Load the octopus character (Fig. 3) and pose it as closely as possible to the octopus swimming reference posture given in the task plan.


                           Task 4: Load the humanoid character and pose three different humanoid running postures. The three reference postures were shown in the task plan. Each of the postures was shown in front and side views.

An observer led the evaluations and took notes as the subjects completed the tasks. Occasionally the observer answered questions from subjects giving them verbal guidance. A pilot study with five participants was conducted to validate the experimental procedure.

Evaluations of our method showed that all of the 22 subjects were able to finish all the tasks. In interviews conducted after the evaluations, all of the subjects said that our method׳s strongest points were in its ease of use and its intuitiveness. More experienced users mentioned that they found they could get more accomplished by using our method, indicating a gain in productivity. Fig. 16
                            shows all the scores of the evaluation. The three most salient points of the SUS survey, where the subjects were most in agreements, were: “I needed to learn a lot of things before I could get going with this system” with a low score of 1.18 (
                              
                                 σ
                                 =
                                 0.39
                              
                           ), “I found the system unnecessarily complex” with a low score of 1.32 
                              
                                 (
                                 σ
                                 =
                                 0.49
                                 )
                              
                           , and: “I think that I would need the support of technical person to be able to use this system” with a low score of 1.41 
                              
                                 (
                                 σ
                                 =
                                 0.59
                                 )
                              
                           . All of these confirm the intuitiveness and ease of use of our system. The average SUS score was 85.00 
                              
                                 (
                                 σ
                                 =
                                 6.55
                                 )
                              
                            indicating a passing grade well above 70, which is considered the minimum passing threshold for an SUS survey [48], further validating the ease of use of our method. None of the subjects reported a score lower than the passing threshold of 70. The lowest reported score was 72.5.

Task 1 and Task 2 were designed to make the subjects comfortable with the Cintiq׳s interface as well as with our method׳s sketching capabilities before they could proceed to Task 3 and Task 4. Subjects spent 8min on average for both Task 1 and Task 2, suggesting that the system can be easily learned in several minutes. Task 3 and Task 4 were designed to measure how quickly the subjects can pose characters using our system. The average time spent for Task 3 was 3min 42s (σ=1min 25s); for Task 4, the average was 7min 44s (σ=2min 43s). Figs. 17 and 18
                            
                            show the average times for these two tasks respectively. Although Task 4, in comparison to Task 3, has three times the number of poses, the amount of time taken to pose them was not three times the amount taken for Task 3, indicating that the subjects were learning how to pose faster as they were completing the tasks. A similar observation was noted by Matthews et al. [40].

The results obtained from our usability evaluations indicate that our method׳s artist-oriented interface passes the usability test with an SUS score of 85, showing that our technique provides an easy-to-use sketching interface for 3D animation. The algorithm was well received by novice users who were able to pose compelling poses in matter of minutes. Our system was seen as natural, interactive, and with a potential to positively impact productivity.

@&#CONCLUSION@&#

We provided an artist-oriented system for posing 3D characters. It uses a closed-form solution for the 2D stroke to 3D skeleton registration problem. By extracting meaningful features from the 2D strokes, we can registrate 3D bones to input 2D strokes while preserving bones rigidity. Our algorithm allows for real-time posing and produces predictable results. In addition to default-posing, we presented plane-posing for both position- and shape-tracking. Our method is versatile and works with any kind of skeletal topology as well as any type of stroke. It supports sketching while still enforcing user-specified constraints. We showed that our algorithm is fast, scalable, versatile, and supports local refinements, allowing 2D artists to animate 3D characters while still respecting their natural workflow.

Our posing algorithm does not rely on prior knowledge except on the skeleton topology. As a result, it may sometimes produce unnatural results with self collisions or violated joints limits. Taking the 3D character׳s mesh and joint limits into account may be an interesting direction for further research for these types of interfaces. In addition, specifying the twist rotation of a joint is very challenging by drawing strokes alone. This is one limitation of sketching. However, since our method is used together with FK and IK, the twist can be efficiently set through its integrated FK-IK mechanism.

Convincing motions generally require subtle time offsets between the keyframes of adjacent joints (as well as DOFs) in the skeleton. However, one side-effect of sketch-based systems is that all the animation variables (DOFs) related to the matched skeletal chain are typically all keyed at the same frame and our sketching mechanism is no exception. As a consequence, sketching techniques alone hardly allow for production of high quality 3D animation. For this reason, our system fully integrates with established techniques such as FK, IK, curve editing techniques, etc. This provides the artists with full control over characters poses.

In the future, we intend to complement our system by integrating various interpolation techniques and intuitive animation curve fine-tuning in order to precisely edit the temporal aspects of the keyed poses. These methods will allow artists to create high fidelity 3D character animations in an interactive and easy-to-use manner.

@&#ACKNOWLEDGMENTS@&#

We would like to kindly thank Mireille Clavien, Jocelyn Weiss, and Celia Pansard for all their help and input in preparing this paper. The research was funded by the Swiss Center for Technology and Innovation (CTI 15870.1 PFES-ES).

Supplementary data associated with this paper can be found in the online version at 10.1016/j.cag.2016.03.008.


                     
                        
                           Video 1
                           
                              The accompanying video shows various features of our 3D character posing via 2D strokes method on different 3D characters. In addition, the video demonstrates hand posing and face posing using the same algorithm. An instance of posing with IK constraints is also shown in the video.
                           
                           
                        
                     
                  

@&#REFERENCES@&#

