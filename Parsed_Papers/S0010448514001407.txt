@&#MAIN-TITLE@&#Layered shape grammars

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We propose a computer-aided conceptual design system to assist modelling in the early phases of design.


                        
                        
                           
                           Our system enhances shape grammars with layers and logic predicates.


                        
                        
                           
                           Layers improve time performance and structuring of shape grammars, and predicates control the application of shape grammars.


                        
                        
                           
                           We have applied these new techniques to examples taken from the architectural and video games domains.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Computational design

Computer-aided conceptual design

Shape grammars

Architecture

Video games

@&#ABSTRACT@&#


               
               
                  In this article we propose a computer-aided conceptual design system to assist modelling at the early stages of design. More precisely, we address the problem of providing the designer with design alternatives that can be used as starting points of the design process. To guide the generation of such alternatives according to a given set of design requirements, the designer can express both visual knowledge in the form of basic geometric transformation rules, and also logic constraints that guide the modelling process. Our approach is based on the formalism of shape grammars, and supplements the basic algorithms with procedures that integrate logic design constraints and goals. Additionally, we introduce a layered scheme for shape grammars that can greatly reduce the computational cost of shape generation. Shape grammars, constraints, goals and layers can be handled through a graphic environment. We illustrate the functionalities of ShaDe through two use cases taken from the architectural design and video games domains, and also evaluate the performance of the system.
               
            

@&#INTRODUCTION@&#

Computer-aided design tools traditionally help designers in many tasks, such as description, documentation and visualization of their projects. However, these tools can also play a more active role in creative aspects of the design process. Some approaches automatically produce highly polished visualizations of designs to be used in movies, video games or computer graphics applications  [1–3]. Others offer support in the early, conceptual stages of design, when the involved shapes and ideas are still malleable. These last assistants are usually called computer-aided conceptual design (CACD) tools  [4–6]. Assistant systems that evaluate, propose and allow exploration of different conceptual design alternatives can be of great help in the early stages of the design process  [7–9].

A number of CACD tools have been developed to date. They share the need for some kind of expert knowledge specification, in the form of design requirements and performance criteria, that can be used to evaluate solutions or to guide generation/exploration processes. Approaches range from visual methods, like shape grammars  [10], to more explicit techniques such as semantic models  [11] or object-oriented relations  [12].

In this paper we present two main contributions. In the first place, we propose a CACD system to help in modelling at the early stages of design. The system provides the designer with design alternatives that aid to overcome the blank page syndrome. This condition appears when facing a new design project and the absence of starting points entails a lack of inspiration. The alternatives provided can be used as starting points to be further completed and polished by the human designer. To guide the generation of such alternatives according to a given set of design requirements, the designer can express both visual knowledge in the form of basic geometric transformation rules, and also by logic requirements. This combination takes advantage of the fact that some requirements are better described using logic predicates (in the form of constraints or goals) that are evaluated during the generation process, in the form or constraints or goals. As far as we know, this combined specification procedure is a novel approach to CACD. Our approach is based on the formalism of shape grammars, supplementing the basic algorithms with procedures that integrate logic predicates.

In the second place, we propose to decompose shape grammars into layers. This reduces the computational cost of algorithms for grammar interpretation, and can greatly speed up grammar execution. Moreover, layers can be used to better organize the process, arranging design elements in groups that can be later visualized separately.

These formalisms and algorithms to represent and process rules, constraints, goals and layers, have been implemented and integrated in ShaDe, a new CACD tool built on the commercial CAD software SketchUp. ShaDe provides a general editor and interpreter of 2D shape rules, logic predicates (constraints and goals), and layers. Rules are expressed in 2D, but height information can be associated to each layer, allowing to visualize the final drawings in three dimensions. We illustrate the modelling process with ShaDe through an example taken from the architectural field.

The rest of the paper is structured as follows: in Section  2 we provide the necessary background on shape grammars and discuss briefly some related prior work on CACD tools; then, in Section  3 we present the new concepts and algorithms that allow the representation and handling of layers and constraints in a grammar. In Section  4 we describe ShaDe, the software tool that we have developed based on the aforementioned ideas. To illustrate the capabilities of the method and the tool, in Sections  5 and 6 we develop two examples in the field of architectural design and the area of strategy/simulation video games. Section  7 presents a quantitative evaluation. Finally, in Section  8 some conclusions are drawn and future continuations of this research are outlined.

A shape grammar is a production system in which shapes are generated by means of replacement rules. The concepts of shape rule and shape grammar were introduced by Stiny and Gips  [10]. In this section we gather some necessary definitions  [13], and explain the role that shape grammars have played in computational design over the last decades.

A shape grammar is a 4-tuple 
                           
                              〈
                              S
                              ,
                              L
                              ,
                              R
                              ,
                              I
                              〉
                           
                         where: 
                           
                              •
                              
                                 
                                    S
                                  is a finite set of shapes


                                 
                                    L
                                  is a finite set of symbols


                                 
                                    R
                                  is a finite set of rules 
                                    α
                                    →
                                    β
                                 , where 
                                    α
                                  is a non-empty labelled shape and 
                                    β
                                  is a labelled shape


                                 
                                    I
                                  is a non-empty labelled shape, called initial shape or axiom.

A shape is defined by a finite set of distinct lines that cannot be combined to form another line, that is, they are maximal. The representation of a shape is thus unique. A labelled shape consists of two parts: a shape and a set of labelled points. A labelled point 
                           
                              (
                              p
                              ,
                              A
                              )
                           
                         is a point 
                           p
                         with a symbol 
                           A
                        . A labelled shape 
                           σ
                         is an ordered pair 
                           σ
                           =
                           
                              〈
                              s
                              ,
                              P
                              〉
                           
                         where 
                           s
                         is a shape and 
                           P
                         is a finite set of labelled points. A segment or line 
                        
                           l
                        , 
                           l
                           =
                           
                              {
                              
                                 
                                    p
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    p
                                 
                                 
                                    2
                                 
                              
                              }
                           
                         is defined by any pair of distinct points 
                           
                              
                                 p
                              
                              
                                 1
                              
                           
                         and 
                           
                              
                                 p
                              
                              
                                 2
                              
                           
                        , the so-called end points of the line.

A rule 
                           α
                           →
                           β
                         applies to a shape 
                           γ
                         when there is a transformation 
                           τ
                         such that 
                           τ
                           
                              (
                              α
                              )
                           
                         is a sub-shape of 
                           γ
                        , that is, 
                           τ
                           
                              (
                              α
                              )
                           
                           ≤
                           γ
                         (a labelled shape 
                           
                              
                                 s
                              
                              
                                 1
                              
                           
                         is sub-shape of another labelled shape 
                           
                              
                                 s
                              
                              
                                 2
                              
                           
                         if and only if every line and every labelled point of 
                           
                              
                                 s
                              
                              
                                 1
                              
                           
                         is in 
                           
                              
                                 s
                              
                              
                                 2
                              
                           
                        ). 
                           τ
                         can be any general geometric transformation. In particular, we will use translations, rotations and regular scales. The sub-shape recognition process needs at least three distinguished points (that can be labels or intersections between segments) in the left side of every rule, as well as in the current design, in order to properly determine 
                           τ
                        .

The labelled shape produced by the application of a rule 
                           α
                           →
                           β
                         to a labelled shape 
                           γ
                         under transformation 
                           τ
                         is given by the expression 
                           γ
                           −
                           τ
                           
                              (
                              α
                              )
                           
                           +
                           τ
                           
                              (
                              β
                              )
                           
                        . This labelled shape is obtained by substituting the appearance of 
                           τ
                           
                              (
                              α
                              )
                           
                         inside 
                           γ
                         with 
                           τ
                           
                              (
                              β
                              )
                           
                        . In Fig. 1
                         we can see a rule and one derivation, that is, a sequence of shapes generated by successive applications of the rule.

Shape grammars have been used for numerous recreation and generation tasks related to decorative arts, paintings, architectural plans and engineering design  [14]. This wide usage relies on the power of shape grammars to capture and recreate heterogeneous design styles. Indeed, many authors have pointed out the advantages of shape grammars as a visual design framework. For example, Stiny showed that they have the potential of producing any possible shape  [15]. They are also a compact method because few rules can yield such complex and unexpected shapes  [16]. More specifically, from the point of view of generative CAD tools, it has been noticed  [17] that grammar-based systems can easily automate design and thus allow a great deal of exploration. Shape grammars have been suggested as a geometric design framework due to some desirable properties  [18], such as their parametric (instead of symbolic) nature and their maximal unique shape representation.

In this section we provide an overview of several CACD tools. Some of these tools have provided support from an evaluative perspective. Kraft and Nagl  [8] developed prototype software providing a visual knowledge specification language for conceptual design. Graph-based domain ontologies define concepts and relations between them, as well as design rules. The designer can use the concepts and relations of this ontology in order to manually instantiate sketches of conceptual buildings (in the context of this work, a sketch is not a shape, but a graph of semantic objects that formalizes the different features of the design idea). The created sketch can be checked against the rule base specified inside the ontology. Pauwels et al. use Semantic Web technologies in order to formalize rules about building performance  [11]. The process of defining a design concept would be similar to the one in the work of Kraft and Nagl, using semantic web technologies instead of graph-based techniques. In both works, design concepts are not geometric objects, but explicit, symbolic descriptions about their features. Grabska et al.  [19] have developed prototype software to support architectural conceptual design that extracts symbolic information from graphical sketches drawn by the designer. It provides a form of visual requirement specification by means of arrows that relate rooms of different floors. The extracted symbolic information can be used to define logic rules that will check the validity of the sketches drawn by the designer.

Other CACD tools have focused on generation capabilities. A considerable part of the corpus of generative CACD tools are shape grammar interpreters. Chau et al.  [14] compared 21 implementations up to 2004. More recently, McKay et al.  [9] gathered some of the most relevant interpreters up to 2011. In this last review, the systems are evaluated according to a set of requirements for shape grammar implementations derived from the works of Gips  [20] and Chau et al.  [14]. Most of the evaluated tools are generic in the sense that they are not aimed at a particular field of design, and provide graphic means to deal with shape rules. To the best of our knowledge, the most recent contributions in this area are the works of Li et al.  [21], Hoisl and Shea  [22] and Trescak et al.  [23]. The first one provides means to create, edit and visualize shapes and rules in AutoCAD. The one of Hoisl and Shea focuses on facilitating user interaction, providing interactive and visual means to deal with parametric rules. The second also aims to provide a friendly interface, as well as to improve the traditional algorithm for recognizing subshapes.

There exist some generative approaches that rely on different techniques. For example, SEED  [12] is an object-oriented generative tool for the initial phases of architectural design that represents design requirements symbolically by means of specification units, which are objects that represent some part of a building (for example, the dining room inside a house). With the help of these objects, the user can establish different relationships among the elements to make up the input for a layout problem   [24], that will generate a valid solution. Shea et al. proposed efiForm, a tool based on the so-called shape annealing optimization method  [7]. The optimization system is integrated into a CAD tool by means of XML models. Designs are represented both in XML and natively in the CAD and optimization systems. Another generative approach is the one of Mora et al.  [25], who developed a CAD tool for the early phases of architectural design. They also use an object-oriented model to specify entities and relations among them. A set of ad-hoc algorithms are used to generate the geometry of every element represented by the entities, taking into account the established design conditions. Krish proposed a generic, generative tool for conceptual design  [26] based on evolutionary algorithms that make an initial population of shapes evolve to better solutions. Recently, Ruiz-Montiel et al. have developed a system based on shape grammars and machine learning techniques, that learns how to apply rules to generate a great variety of schematic architectural designs based on a housing program  [27–29]. In particular, policies obtained by reinforcement learning can be used to choose the best rule and transformation to be applied at every step of a grammar derivation in order to generate feasible designs.

Other generative approaches, not related to CACD, automatically produce highly polished visualizations of designs to be used in movies, video games or computer graphics applications. For example, Müller et al.  [1] use shape grammars to create building mass models. Merrell et al.  [2] use simulated annealing to produce floor plans according to a housing program automatically inferred by training a Bayesian network with numerous plan examples. Then they use ad-hoc algorithms to automatically generate 3D models from the produced plans. Yu et al.  [3] also use simulated annealing to determine the furniture arrangement of a room according to a set of relationships extracted from positive examples. Our work is related to some of these approaches, however it focuses on supporting the early stages of design. In particular, our approach to CACD focuses on automatically offering numerous, feasible starting points to be refined by the human designer. To guide the generation process, our tool provides the designer with different means to specify design requirements. These techniques are detailed in the next section.

Layers are a common structuring device in practical CAD tools. From a theoretical point of view, experts acknowledge the need of using partial descriptions of a design. Partial descriptions of designs have to be superimposed in order to make up the whole picture. A design is composed of several partial descriptions that have no meaning in themselves, that is, they are fragments of the design. They have to interact and overlap in order to form the whole meaning. Kotsopoulos, starting from the theoretical background of product shape algebras   [30], introduced this notion as a thinking-graphic device when working with shape grammars  [31]. Stiny also introduced the concept of multiple tuples (or channels, as Yue and Krishnamurti explain in a recent work  [32]) in shape grammars as a technique to deal with the difficulty of distinguishing segments embedded in the maximal lines  [15].

We have exploited this concept in order to lighten the complexity of the algorithms involved in shape grammar interpretation; more concretely, we might have several simple shapes separated in distinct layers instead of a complex one inside a single layer, thus decreasing the time requirements of the sub-shape recognition algorithm.

Formally, we define a layered shape grammar as a 5-tuple 
                           
                              〈
                              S
                              ,
                              L
                              ,
                              R
                              ,
                              I
                              ,
                              L
                              a
                              〉
                           
                         where: 
                           
                              •
                              
                                 
                                    S
                                  is a finite set of shapes


                                 
                                    L
                                  is a finite set of symbols


                                 
                                    R
                                  is a finite set of rules 
                                    α
                                    →
                                    β
                                 , where 
                                    α
                                  is a non-empty layered shape and 
                                    β
                                  is a layered shape


                                 
                                    I
                                  is a non-empty layered shape, called initial shape or axiom
                              


                                 
                                    L
                                    a
                                  is a finite set of 
                                    n
                                  layer names, 
                                    
                                       (
                                       L
                                       
                                          
                                             a
                                          
                                          
                                             0
                                          
                                       
                                       ,
                                       L
                                       
                                          
                                             a
                                          
                                          
                                             1
                                          
                                       
                                       ,
                                       …
                                       ,
                                       L
                                       
                                          
                                             a
                                          
                                          
                                             
                                                (
                                                n
                                                −
                                                1
                                                )
                                             
                                          
                                       
                                       )
                                    
                                 .

A layered shape is a set of 
                           n
                         labelled shapes 
                           
                              (
                              
                                 
                                    σ
                                 
                                 
                                    L
                                    
                                       
                                          a
                                       
                                       
                                          0
                                       
                                    
                                 
                              
                              ,
                              
                                 
                                    σ
                                 
                                 
                                    L
                                    
                                       
                                          a
                                       
                                       
                                          1
                                       
                                    
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    σ
                                 
                                 
                                    L
                                    
                                       
                                          a
                                       
                                       
                                          
                                             (
                                             n
                                             −
                                             1
                                             )
                                          
                                       
                                    
                                 
                              
                              )
                           
                        . That is, there is a labelled shape defined for each layer. In Fig. 2
                         we can see an example of a layered shape (the bottom-left cross represents the origin of coordinates).

A rule applies to a layered shape 
                           γ
                         when there is a transformation 
                           τ
                         such that 
                           τ
                           
                              (
                              
                                 
                                    α
                                 
                                 
                                    L
                                    
                                       
                                          a
                                       
                                       
                                          i
                                       
                                    
                                 
                              
                              )
                           
                         is a sub-shape of 
                           
                              
                                 γ
                              
                              
                                 L
                                 
                                    
                                       a
                                    
                                    
                                       i
                                    
                                 
                              
                           
                        , that is, 
                           τ
                           
                              (
                              
                                 
                                    α
                                 
                                 
                                    L
                                    
                                       
                                          a
                                       
                                       
                                          i
                                       
                                    
                                 
                              
                              )
                           
                           ≤
                           
                              
                                 γ
                              
                              
                                 L
                                 
                                    
                                       a
                                    
                                    
                                       i
                                    
                                 
                              
                           
                        , for every layer 
                           L
                           
                              
                                 a
                              
                              
                                 i
                              
                           
                        . Note that the applied transformation 
                           τ
                         must be the same in every layer. The rest of the arithmetic for labelled shapes is naturally extended to layered labelled shapes in a similar way, applying the operators in parallel to the shapes of every layer.

In Fig. 3
                         we can see a layered shape grammar with the content of each layer shown separately. The grammar is composed of three rules that are divided into three layers.

While defining and understanding a layered shape rule is apparently more complicated than in the case of a standard shape rule, this shortcoming can be circumvented by integrating the layered shape grammar interpreter into a CAD tool with layer facilities. These kind of tools usually allow viewing different layers separately, as well as any combination of them at once. As explained in Section  4, we have built our interpreter on a commercial tool that offers such layer capabilities.

Shape grammar interpreters spend most of their time solving the so-called subshape detection problem: given two shapes 
                              α
                            and 
                              γ
                           , find all transformations 
                              t
                            such that 
                              t
                              
                                 (
                                 α
                                 )
                              
                              ≤
                              γ
                           . A reference algorithm for this problem was proposed by Krishnamurti  [33]. We have extended this algorithm to the layered case.

Let us start describing the original algorithm. It works with a fixed set of three points in 
                              α
                           . This set, called 
                              D
                              
                                 
                                    P
                                 
                                 
                                    α
                                 
                              
                           , is mapped to every plausible combination of three points (a so-called triplet) inside 
                              γ
                           , and if both sets form similar triangles, then the six points are used to calculate a transformation 
                              t
                           . If 
                              t
                              
                                 (
                                 α
                                 )
                              
                              ≤
                              γ
                           , then 
                              t
                            is added to the solution set. The set 
                              D
                              
                                 
                                    P
                                 
                                 
                                    α
                                 
                              
                            must be carefully chosen, because the number of triplets inside 
                              γ
                            depends on the type of points involved in 
                              D
                              
                                 
                                    P
                                 
                                 
                                    α
                                 
                              
                           . For example, consider the shapes 
                              α
                            and 
                              γ
                            in Fig. 4
                           (a) and (b), respectively (in this work, labels are represented by means of circles). In 4(b) we can find 22 intersection points and 4 white labels. If the set 
                              D
                              
                                 
                                    P
                                 
                                 
                                    α
                                 
                              
                            is composed of three intersection points (namely, three corners of the square in Fig. 4(a)), then the number of triplets in 
                              γ
                            is 22×21×20. On the other hand, if 
                              D
                              
                                 
                                    P
                                 
                                 
                                    α
                                 
                              
                            is composed of two intersection points (two corners) and the white label, then the number reduces to 22×21×4, so the most efficient 
                              D
                              
                                 
                                    P
                                 
                                 
                                    α
                                 
                              
                            is the second one.

If we have a shape 
                              γ
                            with 
                              n
                            layers 
                              
                                 (
                                 L
                                 
                                    
                                       a
                                    
                                    
                                       0
                                    
                                 
                                 ,
                                 L
                                 
                                    
                                       a
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 …
                                 ,
                                 L
                                 
                                    
                                       a
                                    
                                    
                                       
                                          (
                                          n
                                          −
                                          1
                                          )
                                       
                                    
                                 
                                 )
                              
                           , our algorithm computes all the 
                              D
                              P
                              s
                            for 
                              
                                 
                                    α
                                 
                                 
                                    L
                                    
                                       
                                          a
                                       
                                       
                                          i
                                       
                                    
                                 
                              
                              ,
                              
                              0
                              ≤
                              i
                              ≤
                              
                                 (
                                 n
                                 −
                                 1
                                 )
                              
                           . We can compute the number of triplets for every three-point set, and run the original algorithm only in the layer that requires less combinations; as the subshape relation must hold in every layer simultaneously, we can stick to one layer in order to compute all the possible transformations. Table 1
                            shows the pseudo code for this algorithm. The method getTransformations (
                              α
                           , 
                              β
                           , 
                              D
                              P
                           ) in our algorithm performs the original Krishnamurti’s algorithm  [33] for subshape detection. The inputs for this original algorithm are shapes with presumably less points and segments than the complete shape resulting from the union of every layer, making the computation faster. Section  7 provides a more detailed evaluation of performance.

Shape Grammars with Constraints and Goals consider logic predicates during their execution in order to produce designs according to a set of design requirements. Logic predicates are Boolean-valued functions. They return true or false depending on whether the statement they represent is satisfied or not. We consider two kinds of logic predicates:


                        
                           
                              1.
                              Constraints: predicates that must be satisfied at every step of any rule derivation.

Goals: predicates that must be satisfied at the end of any rule derivation. They control termination. The design is considered satisfactory as soon as goals are attained. In such case, the derivation sequence can terminate.

The space of all shapes that can be generated through the repeated application of rules to an initial shape has a tree-shaped structure, with shapes at its nodes, and as many branches from each node as possible pairs (rule, transformation) are applicable to the corresponding shape (see Fig. 5
                        ). The process of generating a shape that complies with a given set of predicates can thus be formulated as a depth-first search over this tree. There are two kinds of nodes:


                        
                           
                              •
                              Goal nodes: nodes representing a shape that fulfils all the goals, without violating any constraint.

Terminal nodes: nodes representing a shape that either does not allow more rule applications (due to its geometry) or violates some of the current constraints.


                        Table 2
                         shows the pseudo code for a recursive algorithm that performs depth-first search. The search starts at the root node of the tree, checking if it is already a goal node (with the method isGoalNode) or a terminal one (with the method isTerminalNode). Otherwise it will explore the tree, exploring as deep as possible along each branch before backtracking, until it finds a goal node. In case that no goal nodes are found, the algorithm will return failure. The method getChildren computes all the possible shapes that can be obtained from a given shape 
                           s
                        , applying the rules of the shape grammar. The method takeChild takes a node of a given list and removes it from the collection. If the result of the recursive call is a shape, then the algorithm has found a solution. Otherwise, the result is failure and there does not exist any solution in that branch.

Note that constraints prune the search tree, effectively reducing the space that needs to be explored.

Let us illustrate the use of logic predicates with a simple example over the tree sketched in Fig. 5. Suppose that we need to produce shapes with the rule in Fig. 1(a) satisfying two design requirements: 
                           
                              1.
                              The shape must not contain segments larger than one metre.

The shape must contain at least ten squares.

The user/designer has to formalize each requirement as a constraint or goal. Let us formalize the first one as a constraint and the second one as a goal. With these premises, a possible path the algorithm may follow through the tree is depicted in Fig. 6
                        . In the first level, the axiom (which is a square with one metre side) does not violate the constraints but does not meet the goal, so the algorithm goes deeper. The same happens in the second level. In the third level, the algorithm now finds two nodes with shapes that violate the constraint, and are marked as terminal. The third shape in this level does not violate the constraints but still does not attain the goal, so the algorithm explores this node, finding a solution in the fourth level.

As we have seen in this example, some requirements are specified in terms of exact metric (it is the case of the constraint, stating that the shape must not contain segments larger than one metre). Although shape grammars involve dimensionless rules in the sense that the size of the pattern to be found (that is, the left part of the rule) does not matter, these rules apply to real shapes that can in fact have dimensions, as is the case of the axiom in the previous example. Since the requirements always refer to measurable shapes, there is no conflict in establishing predicates involving exact metric.

Constraints need to be defined with care. When a constraint is violated, the depth-first search algorithm prunes all the paths that could be followed from the offending node. If there were a valid solution inside some of those paths, the algorithm would never reach it. This could happen, for example, in the example depicted in Fig. 6, if the grammar had an additional rule that removed squares. As a general guideline, a predicate can be formulated as a constraint when we are sure that once it is violated, there is no possible derivation that will satisfy it again. Otherwise, it is better to define the predicate as a goal. For example, if the grammar contains rules that remove shapes, we cannot ensure this property.

ShaDe
                        1
                     
                     
                        1
                        ShaDe can be downloaded from http://www.lcc.uma.es/~perez/ntidapa/.
                      is a generative CACD tool that relies on layered constrained shape grammars in order to propose design solutions: it handles layered shapes that are intended to represent a design that meets a set of logic constraints and goals.

In this section we focus in the architecture of ShaDe and some relevant aspects of its interface. A more detailed description can be found in the user’s guide and technical Refs.  [34,35].

ShaDe is built on Trimble SketchUp, a popular, freely-available 3D modelling software that can be extended with Ruby  [36] plugins. ShaDe has been implemented as one of these plugins.
                        2
                     
                     
                        2
                        For efficiency reasons, the shape grammar algorithms are not executed within the Ruby interpreter that comes along with SketchUp, but by an external Ruby command.
                      This approach presents several advantages: 
                        
                           1.
                           Providing a generative CACD tool integrated with a commercial CAD tool can help to overcome the alleged confinement of design generative software to the academic world  [37].

Hoisl and Shea  [22] note that design practitioners tend to think visually. ShaDe incorporates the sophisticated tool set of Sketchup in the graphic interface of its grammar interpreter, avoiding the need to explicitly program shape rules.

Dynamically supported Ruby scripts provide support for the logic predicates used to control shape grammar application.

In Fig. 7
                      we can see the architecture of ShaDe. There are four ShaDe-specific modules: (1) Layered Shape Grammar Interpreter module, (2) Design Generation Module, (3) ShaDe Interface and (4) Predicate Generation Module. These are covered in the next sections.

The Layered Shape Grammar Interpreter (LSGI) module relies on our layered subshape detection algorithm, as well as in the arithmetic algorithms developed by Krishnamurti  [38], in order to implement the application of shape grammars. As the SketchUp representation of shapes is not maximal in general, ShaDe implements a translation method that receives the SketchUp entities that constitute a shape and returns the maximal representation for the same shape. This method is invoked every time a new shape is created or edited inside the graphical interface. When a layered shape needs to be painted, the LSGI module communicates with the Ruby API in order to create the corresponding SketchUp geometric entities.

Layered shape grammars are implemented by means of the entities that SketchUp provides for dealing with layers. We use the so-called Layer entity of SketchUp in order to organize the maximal representation of the shapes; for each layer we keep the structures that store the maximal representation of the corresponding shapes.

The Design Generation (DG) module takes into account the design requirements (specified as logic predicates) in order to propose solutions. The solution space to explore, configured as a tree-like structure (see Section  3.2), is generated thanks to the LSGI module.

The logic predicates that control the depth-first search described in Section  3.2 are implemented as Ruby scripts that are invoked every time a node is checked. Users can (de)activate both constraints and/or goals at any moment.

ShaDe allows the association of a shape grammar with a set of logic predicates. This is done by means of the project entity. Projects can be executed in two different modes: (1) applying a number of rules and (2) applying rules until the design goals are fulfilled. When (1) is chosen as execution mode, the goals of the project are not taken into account, applying a maximum depth search limit.


                        Design scripts can be used to establish sequences of projects. Each project in a script is executed from the shape produced by the previous project. The first project starts from an axiom, i.e., a shape provided by the user. Scripts allow to specify different phases in the generation of a design, as we will illustrate in Sections  5 and 6.

The DG module can also use functions of the SketchUp Ruby API in order to implement the behaviour of constraints and goals.

The Interface of ShaDe relies partly on the already provided canvas and basic drawing/layer tools of SkethUp. It adds several specific toolbars that gather different commands that deal with ShaDe entities.

In Fig. 8
                         we can see a screenshot of the graphical interface of ShaDe. In the following, we describe the user interaction with ShaDe. 
                           
                              1.
                              
                                 Rule Canvas. Rules appear at the left side of the canvas. All drawing tools can be used to create and edit all rule shapes with a pointing device.


                                 Design Canvas. The current shape (or the axiom, when no rules have been applied) appears at the right side of the canvas.


                                 Basic SketchUp Toolbar. This toolbar gathers some basic SketchUp commands that can be used to edit shapes and also to change the canvas view (zoom in/out, rotate, etc.).


                                 Edition Toolbar. Provides specific commands in order to perform shape grammar editing tasks like adding or removing rules, managing shapes and labels, and also visualizing the design in three dimensions.


                                 File Toolbar. This toolbar provides commands that save/load several ShaDe entities (shapes, grammars, projects or scripts).


                                 Execution Toolbar. These commands allow the user to execute the shape grammar with some of the following protocols: (a) applying certain rule once, (b) applying random rules a number of times, (c) applying random rules until goals are met, (d) executing a design script.


                                 Predicates Toolbar. Provides commands for managing constraints and goals (mainly activate/deactivate them, defining new predicates and checking if goals are met).


                                 Layers Window. Allows layer management (choosing the current layer, which layers are displayed, etc.).

The Ruby scripts for some logic predicates that we consider of common use are predefined in ShaDe. They are gathered in Table 3
                        . The user can activate these at any time, so that they are taken into account in rule application.

However, in many cases the user will probably need additional logic predicates. For this reason, ShaDe offers the possibility of defining personalized constraints and goals. This can be done in two ways: 
                           
                              1.
                              Graphically, thanks to a predicate generation module that asks for information about the logic predicate.

Directly coding the logic predicate in Ruby, inside a built-in code editor.

When the graphic option is chosen, the Predicate Generation (PG) module gathers information about the predicate by means of a set of graphic dialogues, and then automatically generates the corresponding Ruby code. We have tried to develop a general and user-friendly graphic interface, covering a wide range of possibilities by means of dialogues and forms that the designer has to fill in. Basically, the predicates can refer to five different entities: 
                           
                              1.
                              Rule IDs. Example: the applied rule is the one with ID 3; or the first applied rule is the one with ID 1.

Applied transformations. Example: the applied scale factor is bigger than 2.

Segments of the generated shape. Example: the shape must not contain segments larger than one metre.

Points of the generated shape. Example: there are more blue labels than yellow ones inside the shape, or there are at least two yellow labels at a distance
                                 of 3.6 m of a blue label.

The whole generated shape. Example: the shape is inside a contour, or the shape is a sub-shape of another given one.

In Figs. 9 and 10
                        
                         we can see some graphic dialogues for configuring predicates related to the applied transformations and the labels of the generated shape, respectively.

In this section we describe a design script used to generate housing unit schemes. This design script is based on some ideas of Rafael Leoz, a Spanish architect whose most productive period fell between 1950 and 1970.

The goal of this example is to focus on the conceptual design facet of ShaDe. More precisely, we show that our system can be used to generate many varied solutions that, although low-detailed, meet an essential set of design requirements and thus can be used as starting points for complete design projects. In addition, we describe in detail all the shape grammars, constraints and goals used in the example. A video displaying the most relevant steps of this example is available on the Web.
                        3
                     
                     
                        3
                        
                           http://youtu.be/1SwkKOinJ8A.
                     
                  

One of the main motivations behind Leoz’s work was the improvement of social housing. Leoz studied how to build affordable houses by means of mass production. The basic idea is to start from a small number of simple shapes that can be easily mass-produced, and aggregate them in order to obtain a vast number of more complex shapes. The most important contribution in this sense is the so-called Hele module or just Leoz module   [39]. Leoz chose this shape because it offers many harmonic combination possibilities, since it does not have symmetries and its perimeter is configured according to the Fibonacci numbers (see Fig. 11
                        ).

We have used pairs of Hele modules in order to produce samples of single-family housing units. Each Hele module is made up of four cells of 3.60×3.60 m. Two modules can be combined in many different ways. We can see some examples of such combinations in Fig. 12
                        .

Leoz usually employed a set of predefined rooms in order to easily configure the interior space of the houses  [40]. Since we are using two Hele modules for each housing unit, we have eight cells available to be filled with a set of rooms. The chosen set of rooms, inspired by those used by Leoz in several projects  [40], is depicted in Fig. 13
                        , with six single-cell rooms and a double one.

We developed a design script in Shade to produce several distinct 2D housing units schemes, using pairs of Hele modules and the set of predefined rooms depicted in Fig. 13.

Leoz usually worked with grids that divided the plane in a regular manner. From these grids, he extracted simple shapes that were further aggregated in order to produce more complex shapes  [40]. The Hele module comes from a rectangular grid. This grid can be used as axiom for our first production step. The subshape recognition algorithm used by the shape grammar interpreter will recognize the Hele modules inside this grid. We can now establish the layers that will reduce the computational cost of grammar execution. They will also help us to represent designs in three dimensions and to visualize different aspects of the design separately: 
                           
                              1.
                              The underlying grid.

The Hele modules yielded by the grid.

The walls of the rooms.

Elements with table-height.

Elements with seat-height.

Elements with wardrobe-height.


                        Fig. 15 depicts the layers with the help of an example. All the shapes and rules of the grammars need to be defined for the six layers.

The Leoz design script comprises three design projects, each one with its own shape grammar, constraints and goals (see Table 4
                        ). In the following we describe the aim of each project: 
                           
                              •
                              Project 1: First Hele module. The first production step is to add the first Hele module from the axiom (see Fig. 14
                                 ).
                                 Fig. 16
                                  displays the single rule for this project. Labels are black in the grid layer, blue in the modules layer and white in the rooms layer. Neither constraints nor goals are needed.

Project 2: Second Hele module. Starting from the shape produced by Project 1, Project 2 adds the second Hele module. In Fig. 17
                                  we can see the single rule for this project. Labels are black in the grid layer, yellow in the modules layer and white in the rooms layer. A constraint is needed to ensure that both modules are in contact. We have established that two labels of the second Hele module (coloured in yellow) must be at a distance of 3.6 m of a label from the first Hele module (coloured in blue). In Fig. 12 we can see a small set of Hele module combinations. Thanks to the emergence properties of shape grammars, ShaDe is able to automatically generate all the combinations of two Hele modules.

Project 3: Rooms. This project adds different predefined rooms that are depicted in Fig. 13 (the pieces of furniture are schematic), starting from the shape produced by Project 2. It has seven rules, one for each kind of room (Fig. 18
                                 ). Before the application of these rules, labels are white in the rooms layer. When rules are applied, their colours change depending on the room that is added. We need four constraints and one goal for the execution of this project: 
                                    
                                       –
                                       Constraint 1: The transformations involved in subshape recognition must not involve scaling, that is, the rooms are to be added in their original size. This constraint comes predefined with ShaDe (see Table 3).

Constraint 2: The first rule applied must be the one of the service cell, since it is the one that needs more space.

Constraint 3: The rules are applied in order, to make sure that every room is present.

Constraint 4: The dining room must be placed near the service room; these two rooms cannot be separated by more than 5 m. This constraint can be configured using the coloured labels that the rules add to the rooms layer.

Goal: All the rules of the grammar have been applied. This goal comes predefined in ShaDe (see Table 3).

@&#RESULTS@&#

We asked the tool to generate ten designs using our design script (although there is no limit to the number of designs we can ask ShaDe to generate). We show four of them in Fig. 19
                        . The designs satisfy the constraints and goals gathered in Table 4, and also present considerable variability. We show the housing unit of Fig. 19(a), once the height information for every layer has been determined, in Fig. 20
                        . Some tools of SketchUp have been used in order to add textures and visualize it in a friendly way.

In this section we describe a second example that generates virtual restaurants to be used in the context of restaurant simulation video games.
                        4
                     
                     
                        4
                        The script containing the shape grammars, layers, constraints and goals of this example can be downloaded from http://www.lcc.uma.es/~perez/ntidapa/restaurant-script.zip.
                      This example aims to produce more detailed solutions from the computer graphics point of view, and it also takes into account a set of requirements that are implicitly present in typical restaurant simulation video games, therefore it is oriented to provide gamers with complete (not conceptual) building solutions. Nevertheless, the produced designs can also be used as starting points in the construction process typical of this kind of video games.

In many strategy/simulation video games the player has to build her own world (for example The Sims, Restaurant Empire, Hotel Giant, etc.). For some users, part of the appeal comes from this construction process, whereas for others the main source of entertainment is the simulation, where they just take a predefined virtual world and start specifying the behaviour of the elements in the game. In this context, a system that automatically generates virtual worlds provides a twofold advantage: on one hand it can be used by construction-oriented gamers to obtain different starting points for their creations, and, on the other hand, it provides simulation-oriented gamers with an unlimited number of different starting points.

We have developed an example related to restaurant simulation video games. Some examples of this genre are the PC saga Restaurant Empire or the Android application Restaurant Story (see Fig. 21
                        ).

In our example we consider the following elements of a restaurant building: contour, entrance door, windows, kitchen, tables, chairs and bathroom. Each element is decomposed in several layers, summing up a total of 27 layers. These will significantly reduce the computation time of the involved shape grammars, as well as allow a simple three-dimensional representation with high level of detail, and a comfortable visualization of the different elements. More concretely, the following details have been included: 
                           
                              •
                              Walls have thickness.

The buildings have main doors and windows.

The furniture pieces are not box-shaped anymore. For example, the chairs have legs, seats and backs.

Further additional details have been provided: columns and stairs for the main door, frames for the windows, burners for the kitchen, etc.

These details are added by six shape grammars whose rules are decomposed in 27 layers. The rules are depicted in Figs. 23–28. The design process is divided into six projects with 9 constraints and 5 goals, establishing a strong interaction between the elements so as to produce restaurants according to the implicit design rules that we can find inside a typical restaurant video game. The first project starts applying rules from the axiom depicted in Fig. 22
                        , and the rest of projects start from the shape produced by the previous project. Note that, for space reasons, the empty layers do not appear in the figures for the axiom and projects of the restaurant script. 
                        
                        
                        
                        
                        
                     

Descriptions, constraints and goals for the six projects are gathered in Table 5
                        . The script generates restaurants of 
                           50
                           
                           
                              
                                 
                                    m
                                 
                              
                              
                                 2
                              
                           
                         with five tables and at least ten chairs, which are reasonable as starting points for this kind of games. Results can be further developed or improved by the players according to their preferences or game objectives.

@&#RESULTS@&#

As in the previous example, we asked the tool to generate ten designs using our design script. We show four of them in Fig. 29
                        . The designs satisfy the constraints and goals gathered in Table 5, and also present considerable variability. We show a restaurant in three dimensions, once the height information for every layer has been determined, in Fig. 30
                        . We can use the tools of SketchUp to add some textures and visualize it in a friendly way (in Fig. 31
                        (a) we can see another restaurant with textures). In Fig. 31(b) we can see the same restaurant of Fig. 31(a) with an automatically generated roof, thanks to the Sketchup plugin Roof Maker   [41].

The performance of the techniques integrated in ShaDe can be discussed from several points of view. We will focus on two issues that, from our point of view, are the most relevant to our work: (1) time performance and (2) knowledge specification.

The original Krishnamurti’s algorithm for subshape detection  [33] (that is, for computing all the transformations 
                           t
                         such that 
                           t
                           
                              (
                              α
                              )
                           
                           ≤
                           γ
                        ) considers all the triplets inside shape 
                           γ
                        . When 
                           γ
                         has 
                           n
                         points and all of the points inside 
                           α
                         and 
                           γ
                         are of the same type, the number of triplets to be considered in 
                           γ
                         is 
                           P
                           
                              (
                              n
                              ,
                              3
                              )
                           
                           =
                           
                              (
                              n
                              )
                           
                           
                              (
                              n
                              −
                              1
                              )
                           
                           
                              (
                              n
                              −
                              2
                              )
                           
                         (that is, the number of ordered 3-permutations of 
                           n
                         elements). Since it tries to compute the associated transformation for each triplet (if it exists), the original algorithm has a complexity of 
                           Θ
                           
                              (
                              
                                 
                                    n
                                 
                                 
                                    3
                                 
                              
                              )
                           
                        . However, a latter implementation of the algorithm  [42] reduces this bound to 
                           Θ
                           
                              (
                              
                                 
                                    n
                                 
                                 
                                    2
                                 
                              
                              )
                           
                        . This is achieved considering only two distinguishable points with two possible candidates for the third point.

Now suppose we use 
                           k
                         layers to reformulate the shape grammar. In the average case, a shape 
                           γ
                         has 
                           
                              
                                 n
                              
                              
                                 k
                              
                           
                         points inside each layer, that is, there are 
                           
                              
                                 n
                              
                              
                                 k
                              
                           
                           
                              (
                              
                                 
                                    n
                                 
                                 
                                    k
                                 
                              
                              −
                              1
                              )
                           
                           
                              (
                              
                                 
                                    n
                                 
                                 
                                    k
                                 
                              
                              −
                              2
                              )
                           
                         triplets in each layer. Since our algorithm for layered subshape detection (Section  3.1.1) only focuses in one layer to compute the transformations (the one with less triplets), now the performance is 
                           Θ
                           
                              (
                              
                                 
                                    
                                       (
                                       
                                          
                                             n
                                          
                                          
                                             k
                                          
                                       
                                       )
                                    
                                 
                                 
                                    3
                                 
                              
                              )
                           
                         (or 
                           Θ
                           
                              (
                              
                                 
                                    
                                       (
                                       
                                          
                                             n
                                          
                                          
                                             k
                                          
                                       
                                       )
                                    
                                 
                                 
                                    2
                                 
                              
                              )
                           
                         for the two-point version). For example, if we use 10 layers, then in the average case the performance is divided by 103 (102 for the two-point version). In the worst case, all the points are inside a single layer and thus we can only use that layer in order to determine the transformations, so the performance is the same as with single-layered grammars. In the best case, there is a layer that only has one triplet, so determining the unique associated transformation (if it exists) would have a complexity of 
                           Θ
                           
                              (
                              1
                              )
                           
                        .

To illustrate this with one example, we present the differences between the execution of a standard shape grammar and a layered one. All tests reported here have been run on an Intel Core i7 860 @2,80 GHz processor with 8 GB RAM and Windows 7 (64 bits).

Tests were run over the shape grammar of the third Leoz Project, that is, the one that adds the room cells inside the Hele modules. An example of one of the rules is depicted in Fig. 18. There are seven similar rules in total, one for each type of room cell. Two versions of this shape grammar have been used: the layered and the flattened one. The second one has all its shapes in one single layer. For example, the flattened rule equivalent to rule 4 in Fig. 18 is depicted in Fig. 32
                        .

Both shape grammars have been executed with the same protocol: the seven rules are applied in order, step by step, using as axiom an outcome (layered or flattened as appropriate) of the second Leoz project. Our aim here is not to produce valid housing units, but to measure performance, so a priori we do not need design constraints nor goals. Nevertheless, we have activated the constraint that prevents scaling, so both shape grammars produce the same outcomes.


                        Fig. 33
                        (a) shows the number of triplets that the subshape detection algorithm considers in both cases. Our proposal always considers less than 4000 triplets, while the unlayered approach considers many more, reaching almost 95000 triplets in the fifth iteration.


                        Fig. 33(b) shows execution time for both shape grammars. Measures include the time involved in the subshape detection algorithms, as well as the time needed for shape arithmetic operations. We can see that in the layered case we need less than one second for every rule application, while in the unlayered case we need more time, reaching almost four seconds in the fifth iteration.

In conclusion we can say that, if we can define layers for a shape grammar without sacrificing desired outcomes of its application, our layered approach can lead to a considerable improvement in time performance. This improvement is even more evident in the execution of the whole Leoz design script, where the design requirements are more demanding and thus the depth-first search algorithm backtracks more times. Table 6
                         gathers the maximum, minimum and average generation times of ten executions of the Leoz design script, for the layered and unlayered approaches.

In addition to speeding up the subshape recognition process, the use of layered shape grammars presents several important advantages for knowledge specification. First of all, they can help shape grammar designers in the rule creation process. Layered rules allow them to take advantage of the layer facilities provided by CAD tools. This leads to a cleaner visualization mode in which certain layers can be displayed or hidden in the canvas, focusing the designer’s attention on the particular segments and points that need to be dealt with at any given time. Secondly, legibility of the shape grammar also improves thanks to the aggregation of related segments and points into a single layer with a meaningful name. For example, in our restaurant shape grammars, all the segments aimed to represent the walls are grouped in the Walls layer, which can be displayed independently of the others. An unlayered shape grammar, in contrast, would hinder the interpretation of each segment or point. For example, a door-related segment might be mistaken for a wall, hampering further modifications of the shape grammar. Finally, different heights can be specified for each layer, so the results of executing a bi-dimensional layered shape grammar can be visualized in three dimensions. This is not possible with a bi-dimensional unlayered shape grammar.

Constraints and goals can also provide certain advantages in the creation process of a shape grammar. When creating shape rules, the consideration of expert design knowledge frequently leads to rules carefully crafted to produce valid designs. The execution of such rules would thus lead to admissible solutions: the structure of the shape grammar itself is the guarantee for the feasibility of the produced designs. Some of the methods actually used to include expert knowledge inside shape grammars are the following: (1) shapes in rules; this is the most direct mechanism, desired final shapes arise from the accumulation of the shapes in the rules, and (2) control marks; special labels added to the “real” shapes are typically used to control several aspects of rule execution such as the order in which rules are applied, the set of rules that can be applied at a certain moment, or the particular transformations that can be applied. We have made use of both methods in order to produce our house plan schemes. For example, we have drawn the desired Hele modules inside our rules (method (1)) and we have also used white labels to establish which portions of the modules were unoccupied and could be filled with a room cell (method (2)).

However, when these approaches are used to consider other design requirements, they can lead to some problems: 
                           
                              1.
                              Rules with this hard-coded knowledge can become very difficult to create, modify and maintain.

Hard-coded knowledge in rules promotes the use of deterministic shape grammars that could only produce certain kinds of shapes that are known a priori. Therefore, we are missing a main reason for using this formalism as design framework, that is, the possibility of obtaining many distinct, unanticipated and innovative solutions.

Moreover, the use of explicit programming methods alone is not an intuitive technique for design practitioners, as noticed by Hoisl and Shea  [22].

To deal with these issues, that arise when working only with visual techniques or only with explicit ones, our approach combines the visual method of shape grammars with the explicit programming of design constraints and goals. Certainly, when dealing with design problems, we can find design requirements of different nature, and it becomes clear that some of these criteria are easier to specify by means of their codification into visual rules, while others adapt better to the explicit mechanism. The considered architectural example accounts for this fact. For instance, the use of L-shaped modules is easier to elicit by means of geometric rules rather than by some kind of explicit programming. On the other hand, the fact that the two Hele modules have to be in contact is expressed better as a logic predicate (if we tried to express it by means of shape rules, we would need to configure one distinct rule for every possible combination of two modules). We believe that having these two possibilities can be of great help to design practitioners, facilitating the task of obtaining feasible designs.

The use of a backtracking-based search algorithm can impose heavy time demands in certain cases. The results presented here have been obtained in affordable times (for the layered case), but these times can grow exponentially when there are just a few admissible solutions. On the other hand, in the absence of a well-defined solution, the methodology of ShaDe is suitable, because the problem can have many solutions. For very constrained problems, other design methodologies must be taken into account. For example, shape grammars combined with reinforcement learning  [27–29] are to be provided by ShaDe in future versions, so the tool can learn how to apply rules to generate shapes that fulfil a set of design requirements.

In this paper we have presented a CACD system that combines two mechanisms to propose starting points for design projects: (1) a general interpreter for 2D layered shape grammars and (2) a depth-first search algorithm to generate and check designs according to a set of logic predicates representing constraints and goals.

We have illustrated the functionalities of the system with two examples: the first one generates 2D housing units schemes inspired by some ideas of the architect Rafael Leoz, and the second one generates virtual restaurants to be used in the context of strategy/simulation video games. A set of feasible starting points, according to a set of design criteria for each example, has been obtained. The possibility of specifying both visual and explicit design criteria inside ShaDe facilitates the development of design scripts that produce shapes according to a set of requirements. The generated designs can be easily visualized in 3D thanks to the use of layered shape grammars.

We have also evaluated the time performance of the layered subshape detection algorithm with respect to the reference algorithm for subshape detection. Results show that our layered approach can lead to a considerable improvement in time performance.

As future work, we aim to provide ShaDe with the possibility of incorporating reinforcement learning techniques into shape grammar execution  [27–29].

@&#REFERENCES@&#

