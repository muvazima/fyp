@&#MAIN-TITLE@&#Planning-based semantic web service composition in factory automation

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           WSDL annotation conventions facilitate semantic web service description derivation.


                        
                        
                           
                           A software agent composes semantic web services to achieve production goals.


                        
                        
                           
                           Graphical user interfaces visualize domain model and workflow execution statuses.


                        
                        
                           
                           Preprocessing algorithms neutralize syntactic restrictions imposed by AI planners.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Semantic web services

Web service composition

Factory automation

@&#ABSTRACT@&#


               
               
                  The Service Oriented Architecture (SOA) paradigm enables production systems to be composed of web services. In an SOA-based production system, the individual production devices provide web service interfaces that encapsulate the behavior of the devices and abstract the implementation details. Such a service-oriented approach makes it possible to apply web service orchestration technologies in the development of production workflow descriptions. While manual formulation of production workflows tends to require considerable effort from domain experts, semantic web service descriptions enable computer algorithms to automatically generate the appropriate web service orchestrations. Such algorithms realize AI planning and employ semantic web service descriptions in determining the workflows required to achieve the production goals desired. In addition, the algorithms can automatically adapt the workflows to unexpected changes in the goals pursued and the production devices available.
               
            

@&#INTRODUCTION@&#

The rapid development of microprocessors has dramatically increased the computational power embedded into miniature devices [1]. Consequently, the constituent devices of a modern manufacturing system are controlled by embedded computers. The increased use of computers has rendered manufacturing systems software-intensive. However, software developed by various vendors tends to be incompatible, and the adoption of new architectures may cause system integration problems in factory automation [2] as well.

The SOA paradigm enables system integration problems to be relaxed by encapsulating each device as a web service. When a device controller exposes a web service interface providing access to the device functionality, the implementation details, such as any vendor-specific programming languages, become less relevant [2]. Furthermore, production systems consisting of web services are highly reconfigurable [3]. For example, the workflow for producing a certain type of product using the production system devices can be formulated as an executable Web Services Business Process Execution Language (WS-BPEL) [4] process. BPEL processes extensively employ the syntactic web services descriptions formulated in the Web Services Description Language (WSDL) [5].

While WSDL defines the communication syntax of a web service, it conveys no information on the service semantics, which would be essential for the dynamic discovery of services suitable for a task [6]. Nevertheless, when semantic information is included, it facilitates the automated discovery, invocation, and composition [7] of the resulting semantic web services. Thus, encapsulation of production devices as semantic web services facilitates automatic composition of production workflows [3,8].

Successful integration of diverse production devices requires the semantic information to be explicitly formulated in a machine-interpretable language [9]. OWL-S (OWL for Services) [10] is currently one of the most popular languages for semantic web service descriptions. It is essentially an ontology formulated using the Web Ontology Language (OWL) [11]. OWL is a vocabulary extension for the Resource Description Framework (RDF) [12].

This paper is organized as follows. Section 2 presents earlier research on which the methodology proposed in Section 3 is based. The methodology is then applied to a manufacturing system in Section 4. Finally, Section 5 presents the conclusions on the application results and identifies points of further work.

Hatzi et al. [13] have developed a framework that translates OWL-S processes describing web services into Problem Domain Definition Language (PDDL) [14] descriptions, which the framework submits to external AI planning components. Based on the solution plans acquired, the framework generates composite OWL-S processes. Hatzi et al. compare the efficiency of different AI planners in computing the solution plans, and they intend to further extend the system with the deployment of the composite processes using external OWL-S facilities.

Semantic service descriptions, such as OWL-S processes describe the meaning of the services in terms of ontologies. While the manual formulation of such service descriptions requires considerable effort from domain experts, Paolucci et al. [15] point out that OWL-S descriptions can be automatically derived based on SAWSDL annotations. However, such automatically derived OWL-S descriptions include no information on the service pre- and post-conditions [15].

The approach presented in this article differs from most contemporary service composition approaches in the method of acquiring the OWL-S descriptions of the constituent services. Furthermore, the service composition framework presented in this paper includes a built-in planner component while retaining the option to attach external planners through a plugin mechanism. In addition, the explicit conversion of service descriptions to PDDL is omitted, unless the planning problems are submitted to external planners. Since the framework itself consists of a set of interacting web services, the services in the actual production systems are termed domain services.

The service composition framework proposed in this article includes a planner that automatically composes the domain web services to achieve production goals. An earlier version of the framework [16] required the service orchestration instructions to be specified through externally provided BPEL processes.

In the proposed methodology, a domain ontology is required for decision-making and planning. However, ontologies have been applied in various information processing tasks. For example, Rijgersberg et al. [17] have developed an ontology of measurement units that facilitates the exchange of quantitative information.

The framework proposed in this article employs semantic information on web service capabilities to determine the appropriate composition of services to achieve a production goal. Schubert et al. [18] present a framework in which semantic information somewhat analogously describes the participants of virtual organizations and the services they provide.

The production goals considered in this article differ in detail to those considered by Shea et al. [19]. This article focuses on assembly goals specifying the part types to be attached to a product template, whereas Shea et al. [19] consider fabrication goals specifying more qualitative properties of the products, such as geometry.

Lobov et al. [20] outline the basic principles for the proposed service composition framework. However, in the new framework discussed in this article, some implementation technologies, such as multi-agent systems are omitted, and the Orchestration Engine component is considerably less essential.

Ramis et al. [21] have proposed a knowledge-based framework for modeling production system statuses. The central framework component corresponds to the Ontology Service component discussed in the next section. However, Ramis et al. [21] suggest hosting the service on cloud resources to enable external agents to access the data.

Lastra et al. [22] have presented a framework for composing composite services in agent-based production systems. The semantic web service composition framework presented in this article is somewhat analogous, although it operates on a higher level where physical modeling is less critical.

Huckaby et al. [23] have applied PDDL in describing robotic production systems and the desired production goals. They have shown that the required workflows can be automatically acquired through AI planning, thus reducing the effort required from the end user. In addition to automated planning, this article will consider automated solution plan deployment, which is possible when the production devices are encapsulated as semantic web services.

Keddis et al. [24] have applied AI planning in scheduling the operations of production plans. They propose an algorithm that considers the temporal dependencies between individual operations to produce schedules with valid material flow between machines. The consideration of material flow enables manufacturing systems to automatically adapt work schedules to equipment changes. In addition, the algorithm is able to generate schedules involving the least idle time [24].

Jian and Ai-Ping apply genetic algorithms to manufacturing cell layout optimization problems [25]. Genetic algorithms start from a randomly selected initial population of solutions, which the algorithms iteratively refine until obtaining optimal solutions [26]. While genetic algorithms appear a promising approach to solving planning problems without exhaustive state space search, their application in AI planning is omitted in this paper.

While PDDL is widely applied in automated planning, Anis et al. [27] point out that the selection of modeling language affects the amount of modeling effort required. Furthermore, Anis et al. [27] compare PDDL, Prolog, and Timed Automata in terms of, for example, usability and performance.

This Section presents an approach to deriving OWL-S descriptions of web services and applying the descriptions in service composition.

Decentralized web service orchestration can be achieved through the use of a web service-based framework, such as the Orchestration Tools proposed in [28]. The framework consists of three web services, Ontology Service, Service Monitor, and Orchestration Engine, each of which fulfills a different task in service orchestration. Detailed descriptions of all the framework components are included in [29].


                        Ontology Service hosts a semantic model of the production system. It receives update requests from an event listener service, Service Monitor, as state changes manifest in the production devices. Thus, the OWL model remains synchronized with the current system status [30].

The primary responsibility of Service Monitor is, however, to compose and deploy workflows that achieve production goals. The goals are formulated as SPARQL queries and submitted to Service Monitor by invoking the StartGoal operation. As indicated in the sequence diagram of Fig. 1
                        , Service Monitor sends a GoalStatusChanged event notification, for example, when a new goal is registered or achieved.


                        Service Monitor creates a separate goal achievement process for each goal received. A goal achievement process is initially in the pending state and proceeds to the planning state when it is submitted to a planner. Once the planner has produced a solution plan, the process continues to the executing state. Once the plan has successfully been carried out, the process will remain in the completed state.

This Section presents a set of conventions on the application of SAWSDL annotations that facilitate automatic derivation of the preconditions and effects of OWL-S processes. Thus, the conventions overcome one of the main deficiencies in the derivation of OWL-S processes identified by Paolucci et al. [15].

An OWL-S model can be extracted from any WSDL document containing sufficient information for invoking a web service. However, without additional semantic pointers, the model will be skeletal in that it provides semantic descriptions of neither the service input and output parameters nor the service preconditions and effects [15]. To facilitate the automatic derivation of the aforementioned aspects, it is necessary to define a set of conventions for attaching SAWSDL annotations to both components of WSDL definitions and components of XML Schema Definitions (XSD), which are frequently embedded in the WSDL documents.

WSDL Operations correspond to OWL-S processes [31]. Thus, Service Monitor generates one OWL-S process for each WSDL Operation.

An SAWSDL model reference attached to a WSDL Operation may primarily refer to a set of SWRL rules and optionally instances of the Binding class in the OWL-S ontology. Service Monitor considers each specified SWRL rule to define the conditions and effects of one OWL-S process result. The Binding instances, if present, specify variable substitutions. Each binding specifies a variable name and a value to which each occurrence of the variable should be substituted in the condition and effect expressions derived from the SWRL rules.

A model reference attached to a Port Type may refer only to instances of the Binding class in the OWL-S Ontology. Service Monitor will then apply the variable substitutions defined in the bindings in the derivation of the condition and effect expressions of each of the Operations in the Port Type.

Each WSDL Output may have at most one SAWSDL model reference, which refers to an OWL individual. If an Output includes such a reference, Service Monitor generates one instance of the OutputBinding class in the OWL-S ontology for each of the Process Results.

Each message part in an Operation input or output message results in the derivation of one OWL-S input or output parameter. An SWSDL model reference attached to a message part may refer to at most one SWRL variable. If such a model reference exists, Service Monitor replaces each occurrence of the variable with the derived OWL-S input or output when copying the condition and effect expressions from the SWRL rules to the derived OWL-S process results.

Since WSDL Message Parts refer to XSD Elements, the model references attached to XSD Elements enable Service Monitor to determine the value types of the derived OWL-S process input and output parameters. The model reference of an XSD Element may refer to either a class in an OWL ontology or a datatype property defined in such an ontology. While the former referent type directly specifies the parameter value type as an OWL class, the latter referent type specifies the data value range for the parameter as the range of the specified datatype property.

Instead of being explicitly attached to XSD Elements, SAWSDL model references may be attached to the XSD Types of the elements. The approach can considerably reduce the number of annotations when XSD Types are reused in several XSD Elements.

In addition to specifying the goal, a planning problem must specify all feasible statements in the domain description, the statements that describe the initial state, and all actions possible in the domain. Finally, all four components of the planning problem must be converted to a format processable by the planning algorithm.


                        Service Monitor extracts both the entire set of feasible statements and the subset of statements that describe the initial state by analyzing the domain OWL model. Each statement built from the OWL individuals and properties corresponds to an assertion describing the initial state. The entire set of feasible statements can be derived from the domains and ranges of the OWL properties.

Finally, Service Monitor extracts planning actions from the OWL-S processes describing the web service operations. Similarly to SWRL rules, each action includes a set of preconditions and effects. Thus, it is straightforward to extract a planning action from an OWL-S process result derived from a SWRL rule.

Once Service Monitor receives a new goal, it extracts a numeric model representing the planning problem. The numeric model is based on the assumption that the number of domain entities, such as objects and actions, remains constant. With this assumption, everything in the model can be represented as a number. Furthermore, each statement composed of the objects can be assigned a unique number. Thus, a planning problem is essentially a tuple 
                           
                              〈
                              S
                              ,
                              I
                              ,
                              G
                              ,
                              A
                              〉
                           
                        , where
                           
                              •
                              
                                 
                                    
                                       S
                                       ⊂
                                       
                                          
                                             Z
                                          
                                          
                                             ⩾
                                             0
                                          
                                       
                                    
                                  is the set of feasible statements


                                 
                                    
                                       I
                                       ⊂
                                       S
                                    
                                  is the set of statements valid in the initial state


                                 G is the set of alternative goals, so that each 
                                    
                                       g
                                       ∈
                                       G
                                    
                                  is a pair 
                                    
                                       (
                                       
                                          
                                             g
                                          
                                          
                                             +
                                          
                                       
                                       ,
                                       
                                          
                                             g
                                          
                                          
                                             -
                                          
                                       
                                       )
                                    
                                  in which
                                    
                                       –
                                       
                                          
                                             
                                                
                                                   
                                                      g
                                                   
                                                   
                                                      +
                                                   
                                                
                                                ⊂
                                                S
                                             
                                           is the set of positive subgoals


                                          
                                             
                                                
                                                   
                                                      g
                                                   
                                                   
                                                      -
                                                   
                                                
                                                ⊂
                                                S
                                             
                                           is the set of negative subgoals

A is the set of actions, so that each 
                                    
                                       a
                                       ∈
                                       A
                                    
                                  is a tuple 
                                    
                                       (
                                       
                                          
                                             pre
                                          
                                          
                                             +
                                          
                                       
                                       (
                                       a
                                       )
                                       ,
                                       
                                          
                                             pre
                                          
                                          
                                             -
                                          
                                       
                                       (
                                       a
                                       )
                                       ,
                                       
                                          
                                             post
                                          
                                          
                                             +
                                          
                                       
                                       (
                                       a
                                       )
                                       ,
                                       
                                          
                                             post
                                          
                                          
                                             -
                                          
                                       
                                       (
                                       a
                                       )
                                       )
                                    
                                  in which
                                    
                                       –
                                       
                                          
                                             
                                                
                                                   
                                                      pre
                                                   
                                                   
                                                      +
                                                   
                                                
                                                (
                                                a
                                                )
                                             
                                           is the set of positive preconditions


                                          
                                             
                                                
                                                   
                                                      pre
                                                   
                                                   
                                                      -
                                                   
                                                
                                                (
                                                a
                                                )
                                             
                                           is the set of negative preconditions


                                          
                                             
                                                
                                                   
                                                      post
                                                   
                                                   
                                                      +
                                                   
                                                
                                                (
                                                a
                                                )
                                             
                                           is the set of positive effects


                                          
                                             
                                                
                                                   
                                                      post
                                                   
                                                   
                                                      -
                                                   
                                                
                                                (
                                                a
                                                )
                                             
                                           is the set of negative effects


                        Service Monitor extracts the sets S and I from the OWL domain model, which it acquires from Ontology Service by invoking the operation GetNewerOntologyModel.

While extracting the planning actions from the OWL-S service descriptions, Service Monitor creates a mapping from each action to the source OWL-S process and input parameter value combination. The mapping enables Service Monitor to convert the solution plans acquired into composite OWL-S processes.


                        
                           Algorithm 1
                           The BFS algorithm proceeds forward from the initial state. 
                                 
                                    
                                       
                                       
                                          
                                             
                                                Require: 
                                                
                                                   
                                                      maxNodeCount
                                                      >
                                                      0
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                   
                                                      relevant
                                                      ←
                                                      
                                                         
                                                            
                                                               a
                                                               |
                                                               a
                                                               ∈
                                                               A
                                                               ∧
                                                               isRelevant
                                                               (
                                                               a
                                                               )
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                   
                                                      current
                                                      .
                                                      state
                                                      ←
                                                      I
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                   
                                                      graph
                                                      .
                                                      nodes
                                                      ←
                                                      
                                                         
                                                            
                                                               current
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                   
                                                      unprocessed
                                                      ←
                                                      
                                                         
                                                            current
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                while 
                                                
                                                   
                                                      unprocessed
                                                      
                                                      ≠
                                                      
                                                      ∅
                                                   
                                                 
                                                do
                                             
                                          
                                          
                                             
                                                
                                                
                                                   
                                                      current
                                                      ←
                                                      unprocessed
                                                      .
                                                      first
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                   
                                                      unprocessed
                                                      
                                                      ←
                                                      
                                                      unprocessed
                                                      ⧹
                                                      
                                                         
                                                            
                                                               current
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                for all 
                                                
                                                   
                                                      a
                                                      ∈
                                                      relevant
                                                   
                                                 
                                                do
                                             
                                          
                                          
                                             
                                                
                                                
                                                if 
                                                
                                                   
                                                      
                                                         
                                                            pre
                                                         
                                                         
                                                            +
                                                         
                                                      
                                                      (
                                                      a
                                                      )
                                                      ⊂
                                                      current
                                                      .
                                                      state
                                                      ∧
                                                      
                                                         
                                                            pre
                                                         
                                                         
                                                            -
                                                         
                                                      
                                                      (
                                                      a
                                                      )
                                                      ∩
                                                      current
                                                      .
                                                      state
                                                      =
                                                      ∅
                                                   
                                                 
                                                then {The action preconditions are satisfied; create a new node}
                                          
                                          
                                             
                                                
                                                
                                                
                                                   
                                                      newNode
                                                      .
                                                      state
                                                      ←
                                                      current
                                                      .
                                                      state
                                                      ∪
                                                      
                                                         
                                                            post
                                                         
                                                         
                                                            +
                                                         
                                                      
                                                      (
                                                      a
                                                      )
                                                      ⧹
                                                      
                                                         
                                                            post
                                                         
                                                         
                                                            -
                                                         
                                                      
                                                      (
                                                      a
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                
                                                   
                                                      graph
                                                      .
                                                      nodes
                                                      ←
                                                      graph
                                                      .
                                                      nodes
                                                      ∪
                                                      
                                                         
                                                            newNode
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                
                                                   
                                                      newLink
                                                      ←
                                                      (
                                                      current
                                                      ,
                                                      newNode
                                                      )
                                                   
                                                 {Create a link to the new state space node}
                                          
                                          
                                             
                                                
                                                
                                                
                                                   
                                                      newLink
                                                      .
                                                      action
                                                      ←
                                                      unprocessed
                                                      .
                                                      first
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                
                                                   
                                                      graph
                                                      .
                                                      links
                                                      ←
                                                      graph
                                                      .
                                                      links
                                                      ∪
                                                      
                                                         
                                                            
                                                               newLink
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                
                                                   
                                                      unprocessed
                                                      ←
                                                      unprocessed
                                                      ∪
                                                      
                                                         
                                                            newNode
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                if 
                                                
                                                   
                                                      ∃
                                                      g
                                                      ∈
                                                      G
                                                      |
                                                      
                                                         
                                                            g
                                                         
                                                         
                                                            +
                                                         
                                                      
                                                      ⊂
                                                      newNode
                                                      .
                                                      state
                                                      ∧
                                                      
                                                         
                                                            g
                                                         
                                                         
                                                            -
                                                         
                                                      
                                                      ∩
                                                      newNode
                                                      .
                                                      state
                                                      =
                                                      ∅
                                                   
                                                 
                                                then {Solution discovered}
                                          
                                          
                                             
                                                
                                                
                                                
                                                return newNode
                                          
                                          
                                             
                                                
                                                
                                                else if 
                                                
                                                   
                                                      |
                                                      graph
                                                      .
                                                      nodes
                                                      |
                                                      >
                                                      maxNodeCount
                                                   
                                                 {No solution discovered}
                                          
                                          
                                             
                                                
                                                
                                                
                                                return nil
                                          
                                          
                                             
                                                
                                                
                                                end if
                                             
                                          
                                          
                                             
                                                
                                                
                                                end if
                                             
                                          
                                          
                                             
                                                
                                                end for
                                             
                                          
                                          
                                             
                                                
                                                end while
                                             
                                          
                                       
                                    
                                 
                              
                           


                        Service Monitor includes a built-in planner employing breadth-first search (BFS) algorithm that proceeds from the initial state until discovering a state that satisfies one of the alternative goals 
                           
                              g
                              ∈
                              G
                           
                        . Algorithm 1 describes the structure of the search procedure in pseudo code.

The search space nodes are the domain states that can be reached by applying the different actions in the planning problem. Since the size of the search space explored by Algorithm 1 increases exponentially in the number of considered actions, considerable improvements in planner efficiency can be achieved by ignoring actions irrelevant to the goal pursued [32]. However, to preserve completeness of the search algorithm, the selection of potentially relevant actions in the subalgorithm isRelevant is somewhat relaxed. Moreover, to reduce the computational overhead, the selection is performed in a single step before initiating the actual planning algorithm. Therefore, an action 
                           
                              
                                 
                                    a
                                 
                                 
                                    i
                                 
                              
                              ∈
                              A
                           
                         is considered relevant if it satisfies one of two conditions:
                           
                              •
                              The action directly achieves a statement in one of the alternative goals:
                                    
                                       –
                                       
                                          
                                             
                                                ∃
                                                g
                                                ∈
                                                G
                                                :
                                                
                                                   
                                                      post
                                                   
                                                   
                                                      +
                                                   
                                                
                                                (
                                                
                                                   
                                                      a
                                                   
                                                   
                                                      i
                                                   
                                                
                                                )
                                                ∩
                                                
                                                   
                                                      g
                                                   
                                                   
                                                      +
                                                   
                                                
                                                ∪
                                                
                                                   
                                                      post
                                                   
                                                   
                                                      -
                                                   
                                                
                                                (
                                                
                                                   
                                                      a
                                                   
                                                   
                                                      i
                                                   
                                                
                                                )
                                                ∩
                                                
                                                   
                                                      g
                                                   
                                                   
                                                      -
                                                   
                                                
                                                
                                                ≠
                                                
                                                ∅
                                             
                                          
                                       

The action directly achieves a statement in the conditions of another action:
                                    
                                       –
                                       
                                          
                                             
                                                ∃
                                                
                                                   
                                                      a
                                                   
                                                   
                                                      j
                                                   
                                                
                                                ∈
                                                A
                                                :
                                                
                                                   
                                                      post
                                                   
                                                   
                                                      +
                                                   
                                                
                                                (
                                                
                                                   
                                                      a
                                                   
                                                   
                                                      i
                                                   
                                                
                                                )
                                                ∩
                                                
                                                   
                                                      pre
                                                   
                                                   
                                                      +
                                                   
                                                
                                                (
                                                
                                                   
                                                      a
                                                   
                                                   
                                                      j
                                                   
                                                
                                                )
                                                ∪
                                                
                                                   
                                                      post
                                                   
                                                   
                                                      -
                                                   
                                                
                                                (
                                                
                                                   
                                                      a
                                                   
                                                   
                                                      i
                                                   
                                                
                                                )
                                                ∩
                                                
                                                   
                                                      pre
                                                   
                                                   
                                                      -
                                                   
                                                
                                                (
                                                
                                                   
                                                      a
                                                   
                                                   
                                                      j
                                                   
                                                
                                                )
                                                
                                                ≠
                                                
                                                ∅
                                                ∧
                                                i
                                                
                                                ≠
                                                
                                                j
                                             
                                          
                                       


                        Algorithm 1 produces a directed graph, in which each node has exactly one incoming arc. By retracing the incoming arcs from the goal state to the initial state, the planner obtains a sequential solution plan. BFS guarantees that any plan discovered is optimal in that it contains the minimum number of actions.
                           Algorithm 2
                           The BFS algorithm converts a sequential plan to tree form. 
                                 
                                    
                                       
                                       
                                          
                                             
                                                Require 
                                                
                                                   
                                                      dependent
                                                      (
                                                      i
                                                      ,
                                                      j
                                                      )
                                                      ↔
                                                      dependsOn
                                                      (
                                                      sequence
                                                      (
                                                      i
                                                      )
                                                      ,
                                                      sequence
                                                      (
                                                      j
                                                      )
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                   
                                                      graph
                                                      .
                                                      nodes
                                                      ←
                                                      
                                                         
                                                            
                                                               current
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                   
                                                      current
                                                      .
                                                      pending
                                                      ←
                                                      
                                                         
                                                            
                                                               a
                                                               ∈
                                                               sequence
                                                               |
                                                               ∀
                                                               b
                                                               ∈
                                                               sequence
                                                               :
                                                               ¬
                                                               dependsOn
                                                               (
                                                               a
                                                               ,
                                                               b
                                                               )
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                   
                                                      current
                                                      .
                                                      finished
                                                      ←
                                                      ∅
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                   
                                                      unprocessed
                                                      ←
                                                      
                                                         
                                                            current
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                while 
                                                
                                                   
                                                      unprocessed
                                                      
                                                      ≠
                                                      
                                                      ∅
                                                   
                                                 
                                                do
                                             
                                          
                                          
                                             
                                                
                                                
                                                   
                                                      current
                                                      ←
                                                      unprocessed
                                                      .
                                                      first
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                   
                                                      unprocessed
                                                      ←
                                                      unprocessed
                                                      ⧹
                                                      current
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                for all 
                                                
                                                   
                                                      a
                                                      ∈
                                                      current
                                                      .
                                                      pending
                                                   
                                                 
                                                do
                                             
                                          
                                          
                                             
                                                
                                                
                                                if (
                                                   
                                                      ∄
                                                      b
                                                      ∈
                                                      sequence
                                                      :
                                                      dependsOn
                                                      (
                                                      a
                                                      ,
                                                      b
                                                      )
                                                      ∧
                                                      b
                                                      
                                                      ∉
                                                      
                                                      current
                                                      .
                                                      finished
                                                      )
                                                      ∧
                                                      (
                                                      ∄
                                                      l
                                                      ∈
                                                      graph
                                                      .
                                                      links
                                                      :
                                                      l
                                                      .
                                                      action
                                                      =
                                                      a
                                                      )
                                                   
                                                 
                                                then
                                             
                                          
                                          
                                             
                                                
                                                
                                                
                                                   
                                                      enabled
                                                      ←
                                                      
                                                         
                                                            
                                                               m
                                                               ∈
                                                               sequence
                                                               |
                                                               dependsOn
                                                               (
                                                               m
                                                               ,
                                                               a
                                                               )
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                
                                                   
                                                      remaining
                                                      ←
                                                      enabled
                                                      ⧹
                                                      
                                                         
                                                            
                                                               a
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                
                                                   
                                                      newFinished
                                                      ←
                                                      current
                                                      .
                                                      finished
                                                      ∪
                                                      
                                                         
                                                            
                                                               a
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                if 
                                                
                                                   
                                                      ∃
                                                      n
                                                      ∈
                                                      graph
                                                      .
                                                      nodes
                                                      :
                                                      n
                                                      .
                                                      pending
                                                      ∩
                                                      remaining
                                                      
                                                      ≠
                                                      
                                                      ∅
                                                      ∧
                                                      isReachableFrom
                                                      (
                                                      n
                                                      ,
                                                      current
                                                      )
                                                   
                                                 
                                                then {Augment a previously discovered node with the action a}
                                          
                                          
                                             
                                                
                                                
                                                
                                                
                                                   
                                                      newNode
                                                      ←
                                                      n
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                
                                                
                                                   
                                                      n
                                                      .
                                                      finished
                                                      ←
                                                      n
                                                      .
                                                      finished
                                                      ∪
                                                      newFinished
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                
                                                
                                                   
                                                      n
                                                      .
                                                      pending
                                                      ←
                                                      n
                                                      .
                                                      pending
                                                      ∪
                                                      remaining
                                                      ⧹
                                                      newFinished
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                else {Create a new node}
                                          
                                          
                                             
                                                
                                                
                                                
                                                
                                                   
                                                      graph
                                                      .
                                                      nodes
                                                      ←
                                                      graph
                                                      .
                                                      nodes
                                                      ∪
                                                      
                                                         
                                                            newNode
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                
                                                
                                                   
                                                      newNode
                                                      .
                                                      finished
                                                      ←
                                                      newFinished
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                
                                                
                                                   
                                                      newNode
                                                      .
                                                      pending
                                                      ←
                                                      remaining
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                end if
                                             
                                          
                                          
                                             
                                                
                                                
                                                
                                                   
                                                      newLink
                                                      ←
                                                      (
                                                      current
                                                      ,
                                                      newNode
                                                      )
                                                   
                                                 {Create a link between the two nodes}
                                          
                                          
                                             
                                                
                                                
                                                
                                                   
                                                      newLink
                                                      .
                                                      action
                                                      ←
                                                      a
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                
                                                   
                                                      graph
                                                      .
                                                      links
                                                      ←
                                                      graph
                                                      .
                                                      links
                                                      ∪
                                                      
                                                         
                                                            
                                                               newLink
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                end if
                                             
                                          
                                          
                                             
                                                
                                                end for
                                             
                                          
                                          
                                             
                                                
                                                end while
                                             
                                          
                                       
                                    
                                 
                              
                           

Especially in the factory automation domain, a purely sequential plan is rarely desired, since such a plan typically results in an inadequate device utilization rate throughout the production system. Therefore, the planner applies another search algorithm to transform the sequential plan into a form that includes the maximum amount of concurrent operations. Algorithm 2 contains the simplified pseudo-code for the plan refinement phase.


                        Algorithm 2 refers to the auxiliary functions dependsOn and isReachableFrom, both of which require two arguments. The former function yields the Boolean value true if and only if the action represented by the first argument requires that the action represented by the second argument has already been performed. The latter function yields true if and only if the directed graph links allow traversal to the node represented by the first argument from the node represented by the second argument.


                        Algorithm 2 applies BFS in processing the action sequence produced by Algorithm 1. Since the length of the action sequence is typically somewhat limited due to the computational efficiency of the planning algorithms and the contemporary computers, Algorithm 2 requires no artificial termination condition, such as the parameter maxNodeCount specified for Algorithm 1. The basic principle is to concurrently perform the maximum number of actions that are mutually independent and enabled by the previously performed actions.

The output of Algorithm 2 is a directed graph, in which each link corresponds to a planning action. Thus, to obtain the final deployable solution plan, Service Monitor applies the mapping from planning actions to OWL-S processes and input parameter value combinations.

A purely sequential solution plan consists of a sequence of instantiated actions, which are actions whose input parameters are bound to concrete values. Thus, such a plan can be deployed by sequentially invoking the web service operations corresponding to each of the actions. However, the deployment of a plan involving concurrent operations typically requires synchronization measures to ensure that actions occur in parallel when possible and that an action occurs no earlier than the actions that achieve its preconditions.


                        Service Monitor employs a recursive algorithm in executing solution plan graphs while properly addressing synchronization requirements. Nevertheless, before deploying the plan, Service Monitor constructs a composite OWL-S process corresponding to the plan structure. OWL-S defines several control constructs that enable complex workflows to be formulated. Service Monitor currently employs the Perform, Sequence, and SplitJoin constructs.

The composition and reuse OWL-S processes enables Service Monitor to achieve repeated production goals without excessive planning overhead. If the original preconditions still hold, Service Monitor can simply deploy the previously composed OWL-S process. OWL-S processes can be deployed using non-recursive algorithms employing the visitor design pattern.

This section exemplifies the application of the service composition approach proposed in Section 3.

To exemplify the application of the proposed service composition framework, this section will consider a production system consisting of 12 manufacturing cells. Each cell contains a conveyor line, and the lines are cyclically interconnected, as illustrated in Fig. 2
                        . A detailed description of the line can be found in [29].

Each cell essentially contains two devices: a robot and a conveyor. The conveyor is divided into five zones, as indicated in Fig. 3
                        . The robot uses one of the zones, zone 3, as its processing location. That is, a robot can perform assembly operations on the product carried by a pallet only when the pallet is occupying conveyor zone 3 in the cell containing the robot. One of the conveyor zones, zone 4, provides an alternative route bypassing the robot. In the particular implementation of the line considered in this paper, the cell number seven is different in that it includes no robot, and it behaves as a direct link between the cells 6 and 8. Hence, it can be completely ignored when modeling the system. Cell 1 forms another exception in that conveyor zone 4 is absent and zone 2 is the robot processing location, instead of zone 3.

Each robot and conveyor device contains an embedded S1000 controller hosting a web service, whose interface provides access to the device functionality.

The robot service interface provides one request-response type operation, Draw, which performs an action to the assembly carried by the pallet occupying the robot processing location. The commencing and completion of an operation, as well as the arrival of and departure of a pallet at the processing location, trigger changes in the robot status, which the robot conveys to registered subscribers through the EquipmentChangeState event notification. In the case of robot 1, the Draw operation is substituted by the ReplacePaper operation, which unloads the potential assembly on the pallet to the storage of completed products and retrieves a new assembly from the storage of blank product templates.

The operation naming reflects that the production line currently simulates the assembly of products through drawing. For example, when the robot attaches a keyboard to an assembly carried by a pallet, it actually uses a marker to draw a keyboard on the paper carried by the pallet.

The conveyor service interface provides two request-response type operations, Transfer and TransferOut. The former operation conveys a pallet between two neighboring conveyor zones within the same conveyor. The latter operation activates the motor controlling the conveyor belt, so that the conveyor unloads to the next manufacturing cell for 10s. In addition, the conveyor service provides two notification operations, TransfResultEvt and EquipmentChangeState. The former notification signals the completion of a transfer operation between two neighboring conveyor zones, and the latter notification signals the activation of a conveyor motor due to the TranferOut operation and its eventual automatic deactivation.

On each conveyor, zone 5 includes no pallet stopper. Therefore, when the Transfer operation is invoked for moving a pallet to zone 5, the pallet will stop due to friction when approximately half of it resides on zone 1 of the next conveyor. Moreover, the friction will prevent the pallet from moving from zone 1 to zone 2 unless the TransferOut operation is invoked on the preceding conveyor.

The domain is described through the OWL model illustrated as a UML class diagram in Fig. 4
                        . The OWL model contains individuals that represent the various devices as well as their properties and interrelationships. The associations in the diagram represent the object properties in the OWL model. For example, the domain and range of the OWL property hasPallet are the OWL classes ConveyorZone and Pallet, respectively. Pallets include unique identifiers, which are data values. The OWL datatype property hasRfidTag is represented by the attribute in the Pallet class.

The absence of a pallet stopper on conveyor zone 5 is reflected in the OWL model so that the corresponding ConveyorZone instances are never connected to an instance of the Pallet class through the hasPallet property.

In addition to the OWL classes and individuals describing the types of objects and their instances in the system, the OWL model includes SWRL rules representing the conditions and effects of the aforementioned operations. For example, the WSDL file of robot 2 includes an SAWSDL annotation linking the operation Draw to the SWRL rule robotOperationRule in the OWL model. The rule antecedents require that a pallet must reside at the processing location of the robot, and the rule consequents specify that a new component is attached to the product template on the pallet. Because the actual robot, pallet, template, and component instances are represented by SWRL variables in the rule, the same rule describes the behavior of each robot instance.

To exemplify the automatic achievement of production goals through the service composition framework proposed in Section 3, this section will consider a production goal that involves the concurrent production of two different mobile phone types. The production of each phone type requires three different components to be attached to the product template: a phone frame, keyboard, and screen. Finally, both products should be removed from the conveyor line and placed into storage.


                        Service Monitor requires that the production goal is formulated as a SPARQL query, and Listing 1
                         contains a SPARQL ASK query representing the aforementioned production goal. Since the goal involves the attachment of specific components, the query explicitly refers to the names of the corresponding OWL individuals. Conversely, the product template instances, to which the components will be attached, are irrelevant and therefore appear as variables, assembly1 and assembly2, in the query. However, since the system contains 5 different assembly instances, the query would require the exploration of an excessively large state space. To accommodate the current limitations of the planning algorithms, this section will consider a simplified goal that explicitly appoints the two assembly template instances to be employed in the production process. The corresponding SPARQL query is depicted in Listing 2
                        .

The SPARQL query representing the production goal can be submitted to Service Monitor by invoking the StartGoal operation or by using the graphical user interface that Service Monitor provides on the host computer.

To apply the service composition framework, the framework services must reside in the same network as the domain services constituting the production system, so that the services may discover each other and communicate via SOAP [33] messages. In this application example, the Java-based framework services are deployed on a Windows laptop connected to the same network as the domain services.

Each of the framework services is deployed by an individual Java application, so that a pre-specified amount of memory can be allocated to each of the services. While only 64 megabytes of RAM is sufficient for Ontology Service and Orchestration Engine, Service Monitor typically requires 1 gigabyte of RAM for the calculations necessary in automatic service composition.

Since Ontology Service initially hosts an empty OWL model, the temporally accurate domain OWL model must be submitted to Ontology Service by invoking the SetBaseModel operation and specifying the OWL model URL as an input parameter value. The operation may be invoked either through the graphical user interface provided by the Ontology Service Client application, which is depicted in Fig. 5
                        , or the Service Explorer application described in [29]. The former has been developed specifically for monitoring and communicating with Ontology Service, whereas the latter is a utility intended for communication with SOAP-based web services in general.


                        Ontology Service Client submits SPARQL queries to exactly one Ontology Service instance at a time. In addition, the client application automatically subscribes to receive event notifications from the service instance, which enables it to refresh the query results without periodically resubmitting the queries to Ontology Service.

In Fig. 5, the Ontology Service Client application has been configured to automatically execute a SPARQL query whenever it receives an OntologyUpdated notification from Ontology Service. The notification is sent to all registered subscribers by Ontology Service whenever the service has modified the hosted ontology model. The query in Fig. 5 retrieves the current locations of the product templates in the system as well as the components attached to the templates.

The query results displayed in Fig. 5 represent the initial state, in which no components have been attached to the templates and all of the templates are located in the storage (tray) reserved for blank product templates.

As demonstrated in Fig. 1, the SPARQL query specifying the production goal can be automatically submitted to Service Monitor by the Orchestration Engine service. The goal is embedded into the BPEL process deployed by Orchestration Engine. The structure of the deployed BPEL process is illustrated in Fig. 6
                        . The process includes two partner links, FastoryProcess and ServiceMonitor. The former represents the composite web service provided by the BPEL process itself, whereas the latter represents the partner web service invoked by the process. The main activity is a Sequence initiated by a Receive activity that processes the request message sent to the conceptual web service provided by the BPEL process. The sequence continues with an Assign activity that initializes the process variables. For example, the activity assigns the goal expression of Listing 2 to the input variable subsequently used by Invoke2.

While standard BPEL prohibits notification operations, the BPEL framework employed by Orchestration Engine service includes the custom convention that invoking a notification operation creates a new event subscription. The activity Invoke1 employs the feature by subscribing to the GoalStatusChanged event notifications. In addition, Invoke1 specifies the process variable to store the contents of the notification messages received. The activity Invoke2 then invokes the StartGoal operation of Service Monitor. The process contains a While loop that examines the value of the variable every two seconds. Once Service Monitor notifies that the goal has been achieved, the variable value changes, and the BPEL process terminates. The activity Assign2 copies the final status value, typically COMPLETED, into the process output variable used by the final activity in the sequence, Reply1.

After the activity Invoke2 has completed execution. Service Monitor prepares a composite process achieving the goal specified in Listing 2. The planning phase completes in approximately 78s, and Service Monitor deploys the plan in 217s. The plan consists of 65 atomic web service operation invocations. The status of the solution plan deployment can be monitored on the graphical user interface that Service Monitor provides on the host computer. The GUI provides direct controls for several of the operations in the Service Monitor web service interface, such as the registering and deregistering of goals. Fig. 7
                         shows the GUI displaying the status of a solution plan deployment once 70 percent of the operations have successfully been invoked.

While Service Monitor includes an internal planner implementation, several other planners have been implemented by various authors. Many of the contemporary planners read planning domain and problem descriptions from PDDL files. The planner used by Service Monitor can be replaced by such a planner through a Java plugin mechanism. A compatible plugin must initially convert the planning problem Java object model into a format processable by the third-party planner. Service Monitor source code includes utilities that convert between PDDL and the Java object model used by the internal planner.

This section will compare the performance of the planning algorithm discussed in Section 3.4 against three third-party PDDL planners: CRIKEY 
                        [34], JavaFF 
                        [34], and GraphPlan 
                        [35]. The first two are from the same source and include similar restrictions on the supported PDDL syntax. For example, all aforementioned planners reject the PDDL :equality and :negative-preconditions requirements. Thus, the planners provide no support for the built-in predicate=or the keyword not in condition expressions.

Gazen and Knoblock [36] have described the process of eliminating negative preconditions from planning domain descriptions. The use of the built-in predicate = can be eliminated somewhat similarly by explicitly declaring a predicate, for example, equals, which requires two parameters, in the domain description and augmenting the initial state in the problem description with statements declaring each object to be equal to itself. Assuming that the number of domain constants and problem objects is 
                           
                              n
                              ∈
                              N
                           
                        , the preprocessing results in n new initial state assertions. However, the elimination of the = predicate must precede the elimination of negative preconditions, which will then result in 
                           
                              
                                 
                                    n
                                 
                                 
                                    2
                                 
                              
                              -
                              n
                           
                         additional initial state assertions. The additional assertions employ the complement predicate, for example, complement-equals, to declare each pair of objects mutually different.


                        GraphPlan includes two additional restrictions: domain descriptions must declare no constants, and action parameter types must strictly respect the argument types of the predicates referenced in the action preconditions and effects. While the latter restriction is satisfied when the action parameter types are restricted according to the predicate definitions, the former restriction is more complicated to eliminate, since domain constants are typically referenced in action preconditions and effects. Nonetheless, domain constants can be replaced with unary predicates. For example, the condition hasStatus(?robot,loaded) is replaced with the condition loaded(?robot), thus eliminating the domain constant loaded and introducing a new predicate with the same name. Similar replacements should then be made in the initial state assertions and goal definitions in the problem description.


                        Service Monitor extracts planning problems directly from semantic descriptions. Since Service Monitor requires semantic web services to be available, it is a somewhat impractical environment for planning algorithm tests. Moreover, to compare the efficiency of the built-in planning algorithm to alternative planner implementations, it is necessary to initially convert the planning problem to PDDL, which is the language accepted by the majority of planners available. To facilitate such tests, a separate graphical user interface application, SWRL Planner, has been developed.


                        SWRL Planner is able to extract a PDDL domain and problem description from an OWL file describing the domain, a set of SWRL rules describing the planning actions, and a SPARQL ASK query specifying the goal. Alternatively, PDDL descriptions can be directly loaded from files. Fig. 8
                         illustrates the graphical user interface.


                        SWRL Planner supports external planners added as Java plugins. Such plugins should be packaged in JAR (Java ARchive) files and placed into a folder named plugins in the application installation directory. Each plugin should accept as input parameters the PDDL domain and problem files. While the built-in planner includes a similar interface, it is directly linked with the SWRL Planner source code instead of being packaged in a JAR file.

The planner plugins should measure the delays of invoking the third-party libraries. While both CRIKEY and JavaFF include a public method requiring only the PDDL domain and problem files as input parameters, GraphPlan includes separate utility methods that must initially be invoked to extract the domain and problem Java objects from the input files, which can then be submitted to the actual planner. Despite the difference in the number of code statements, the time durations measured in the tests include exactly the processing of the PDDL files and the actual planning process for each of the planners. The time spent in, for example, result post-processing is excluded. Thus, the performance of different planners can be accurately compared. The diagram in Fig. 9
                         illustrates the plugin framework that is applied to measure the performance of each planner.

While the goal expression in Listing 1 is convertible to PDDL, the corresponding PDDL expression would exceed the syntactic limitations of several planners. The requirement of employing two different product templates in particular is difficult to express through the language constructs supported by each of the aforementioned planners. The somewhat simplified goal formulated as a SPARQL query in Listing 2 explicitly specifies the correct product template instances. Therefore, no FILTER statement is required, and the SPARQL expression is directly convertible to a PDDL expression containing atomic formulas only. While such an expression is directly supported by all of the planners considered in this section, and the overall PDDL descriptions can be preprocessed to adhere to all syntactic requirements of the planners, the resulting planning problem is excessively complex to be solved by all of the planners.

To compare the performance of all four planners in the sequel, a simplified experiment scenario is considered. Fig. 10
                         illustrates the simplified domain ontology through a class diagram. The diagram includes the base OWL class Thing from which every class inherits. The domain contains three workstations and a robot, which can transport products between the workstations.

The OWL model contains four SWRL rules, which SWRL Planner converts to actions while extracting the PDDL domain description: load, transport, unload, and move.

The original PDDL domain description employs the built-in = predicate and the not keyword in action preconditions. Moreover, the action conditions and effects extensively refer to the domain constants vacant and loaded, which represent the robot statuses. Therefore, the aforementioned preprocessing techniques must be applied before submitting the PDDL descriptions to the third-party planners considered. The preprocessing algorithms yield the domain description in Listing 3
                         and the problem description in Listing 4
                        . While the domain description remains approximately identical during the preprocessing, the number of initial state assertions in the problem description increases from 5 to 41 due to the large number of explicit assertions using the equals and complement-equals predicates. Although names in PDDL descriptions are generally case-insensitive [14], type names in the PDDL listings have been converted to lowercase to avoid incompatibilities between the different planners. For the purpose of brevity, the original PDDL descriptions are omitted.

The optimal solution plan for the simplified planning problem is a sequence consisting of five steps. The sequence starts with first unloading phone1 from robot1 at its initial location workstation3 and ends with unloading phone2 from robot1 at workstation2. In between, robot1 retrieves phone2 from workstation1.


                        Table 1
                         contains the test results of applying the considered planners in solving the problem described by Listing 4. Each table column corresponds to an individual test sequence using one of the planners. SWRL Planner has exported the result data as CSV files, which have then been imported to a spreadsheet application for analysis. Since Java is a high-level language typically demonstrating indeterministic performance, the planning process was repeated 10 times using each planner. The chart in Fig. 11
                         indicates that the planning duration varies considerably in different test repetitions. In the chart, the results for the GraphPlan planner are plotted in a separate panel with a different scale.

Each of the assessed planners, except for GraphPlan, demonstrates considerably higher performance after the initial test. The reason may be that the Java virtual machine initially needs to load application modules from binary code. The built-in planner additionally retains data storage objects and reuses them on subsequent iterations for optimal performance.

@&#CONCLUSIONS@&#

This paper has presented a web-service-based framework capable of automatically composing web services based on their semantic descriptions. While the framework is general, this paper has demonstrated its application in the factory automation domain. The results indicate that the framework reduces the workload of developing semantic web service descriptions and is able to automatically compose and deploy workflow descriptions. Although the development of the semantic descriptions constitutes a considerable workload, the approach enables production systems to automatically achieve both modified and completely new goals without additional efforts from domain experts.

Although application of the proposed web service composition framework requires careful development of semantic descriptions, the framework removes the effort of prescribing and modifying production workflows. In addition, the framework employs a set of conventions that considerably reduce the effort of developing semantic web service descriptions.

The performance of the AI planner implemented as part of the proposed service composition framework has been compared to three third-party planner implementations. While reliable comparison of the planner performances would require more extensive tests, the results indicate that the embedded planner demonstrates performance comparable to recent developments of AI planning research.

Further research will improve the performance of the embedded planner and investigate alternatives for the forward search algorithm. For example, genetic algorithms could be applied in planning problems, in which the objective is to find an optimal action sequence. Each action sequence would then be considered a chromosome whose fitness value would be computed with intent to maximize the number of goal statements achieved and minimize the number of actions performed. Such genetic algorithms could solve the planning problems without exhaustive exploration of the system state space.

@&#REFERENCES@&#

