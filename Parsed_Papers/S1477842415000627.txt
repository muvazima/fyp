@&#MAIN-TITLE@&#DSML4CP: A Domain-specific Modeling Language for Concurrent Programming

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Concurrent programs are structurally complex and their design and implementation can be error prone.


                        
                        
                           
                           A DSML provides higher abstraction level and can reduce the complexity of the concurrent programs.


                        
                        
                           
                           This paper proposes a DSML, DSML4CP, which can generate the artifacts automatically in Java and C#.


                        
                        
                           
                           DSML4CP has a graphical tool capable of static controls as constraints to reduce error occurrence.


                        
                        
                           
                           The experiments indicate a raise in the performance of developing the software using DSML4CP.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Domain-specific Modeling Language

Metamodel

Code generation

Constraint control

Concurrent programming

@&#ABSTRACT@&#


               
               
                  Nowadays, concurrent programs are an inevitable part of many software applications. They can increase the computation performance of the applications by parallelizing their computations. One of the approaches to realize the concurrency is using multi thread programming. However, these systems are structurally complex considering the control of the parallelism (such as thread synchronization and resource control) and also considering the interaction between their components. So, the design of these systems can be difficult and their implementation can be error-prone especially when the addressed system is big and complex. On the other hand, a Domain-specific Modeling Language (DSML) is one of the Model Driven Development (MDD) approaches which tackles this problem. Since DSMLs provide a higher abstraction level, they can lead to reduce the complexities of the concurrent programs. With increasing the abstraction level and generating the artifacts automatically, the performance of developing the software (both in design and implementation phases) is increased, and the efficiency is raised by reducing the probability of occurring errors. Thus, in this paper, a DSML is proposed for concurrent programs, called DSML4CP, to work in a higher level of abstraction than code level. To this end, the concepts of concurrent programs and their relationships are presented in a metamodel. The proposed metamodel provides a context for defining abstract syntax, and concrete syntax of the DSML4CP. This new language is supported by a graphical modeling tool which can visualize different instance models for domain problems. In order to clarify the expressions of the language; the static semantic controls are realized in the form of constraints. Finally, the architectural code generation is fulfilled via model transformation rules using the templates of the concurrent programs. To increase level of the DSML׳s leverage and to demonstrate the general support of concurrent programming by the DSML, the transformation mechanism of the tool supports two well-known and highly used programming languages for code generation; Java and C#. The performed experiments on two case studies indicate a high performance for proposed language. In this regard, the results show automatic generation of 79% of the final code and 86% of the functions/modules on average.
               
            

@&#INTRODUCTION@&#

In recent years, programmers׳ attention to parallel programming has significantly increased. A need for a high processing rate in software applications is an important motivation for the users that forms and develops concurrent programs [1]. Different problems exist in developing correct and efficient parallel and distributed applications in general and concurrent programs in specific. On the other hand, due to the performance issues reaching optimal efficiency (as a main goal of parallel and distributed computations) is difficult. Moreover, engagement of concurrent program developers with the issues such as coordinating the threads (in parallel and distributed form) and synchronizing them (such as controlling mutual exclusiveness and deadlock) [2,3] adds even more complexity to such software. Thus, for concurrent programs, a resolution is needed to reduce the complexity of their development. Basically, such methods need to be independent from the programming context and language and in a higher level than code. One possible solution is to promote the abstraction level in the development of concurrent programs. This approach allows the programmer to work in a higher level than code and this abstraction level decreases involvement of developer with details during design and implementation. It is worth to mention that the targeted environment for the concurrent programing in this study is shared memory.

Model Driven Development (MDD) is one of the approaches to promote abstraction level in software development with the aim of changing programming focus from code to model. In this approach, models are created with required details; then, codes are generated automatically based on those models. This increases productivity, reuse (through reusing standardized models), simplifying design process, and promoting team work capability. It must be considered that a modeling paradigm is effective when its models are understandable from a domain user’s viewpoint [4,5]. This can be realized by using the domain terms and concepts along with their relations as the main elements of the new language during modeling the problem.

One of the typical ways of applying a Domain-specific Language (DSL) [6–8] is that a developer designs his/her own model in a language specific for the applied domain and the language produces the architectural code for the program model. In this way, instead of dealing with coding details, the programmer works with a model of the program. Also, instead of working with a General Purpose Language (GPL), the developer works with a specific language of the domain; thus, keywords, relations, and concepts will be very close to the ones in the application domain. One type of DSLs is Domain-specific Modeling Language (DSML) [9,10], in which graphical elements and models are used for designing programs, giving a better insight about software elements and relations. This methodology is applied in many other cases [11,12]. In [13], we examined different approaches of designing and implementing DSMLs by using available tools for developing these languages which paved the way for development of DSML for this study. Also, in [19], we presented a metamodel for concurrent programs along with a textual tool for their development. In this paper, concurrent programs are addressed as the domain to apply DSML techniques and benefits from MDA methodology. We propose a new language for increasing the abstraction level and reducing development complexities of the domain. We call this language as Domain-specific Modeling Language for Concurrent Programming, DSML4CP. To increase level of the DSML’s leverage and to demonstrate the general support of concurrent programming by the DSML, the transformation mechanism of the tool supports two well-known and highly used programming languages for code generation; Java and C#.

The remainder of this paper is organized as follows: in Section 2 the language syntax including abstract syntax and concrete syntax is discussed. Section 3 discusses static semantic controls and code generation of the language. In Section 4, the language is utilized in two case studies. In Section 5, we evaluate, analyze and discuss DSML4CP. Related work and comparison between the new language and the previous studies are discussed in Section 6. Finally, Section 7 concludes the paper and states the challenges and future work.

In computer science, language syntax is a set of rules which define the combination of the symbols and describe the structure of the language. Similarly, based on MDD principles, a DSML includes abstract and concrete syntaxes. So, accordingly we provide these two syntaxes for DSML4CP in this section.

In recent years, different metamodels for various domains have been proposed which are used as abstract syntaxes of DSLs [14,15]. Besides, Object Management Group (OMG)
                           1
                        
                        
                           1
                           Object Management Group, http://www.omg.org.
                         has played an important role in applying them in a standard way. With the advent of Model-Driven Architecture (MDA) [16,17] by OMG and with the increasing need of standardization, applications of metamodels have been growing steadily. For development of a DSML, an abstract syntax can appear as a metamodel which can be implemented in a metamodeling tools such as Ecore.
                           2
                        
                        
                           2
                           EMF Ecore, http://eclipse.org/modeling/emf/.
                         Abstract syntax of a language specifies domain terms and identifies how they can be combined for creating instance models [18,5]. In this part, we present an updated version of the metamodel as the abstract syntax for concurrent systems. The base metamodel was presented in our previous study which can be accessed in [19]. To have thorough comprehension and efficient use of the metamodel, we imagine various meta-elements (as illustrated in 
                        Fig. 1) in the metamodel which are explained in this section.

Concurrent programs are lists of instructions to be executed in parallel. Since each program has logic, they can realize special tasks. Thus, the “Program” meta-element on our metamodel is used for determining the intended program which is modeled. In concurrent programming, a thread plays the main role which allows the users to do tasks in parallel. So, a meta-element, called “Thread” is considered in the metamodel which is connected to the “Program” with a composition relationship indicating that a program may have several threads. Considering the fact that a thread is able to create another thread within a program, we have considered this feature for the “Thread” meta-element and a thread can make any number of other threads. Threads require including a start point to kick off the tasks from. The “StartResumePoint” meta-element in the proposed metamodel is representing start point. Aside from this, a start point can be also within a task which leads to a resume case. A stop point is also necessary to show when the task of a thread has ended and when it is going to deliver execution order to another thread. This element is called as the “StopPoint” meta-element.

Threads are specifically useful when it is required that the program wait for the response of another part of it which ends up overall speedup. Therefore, the “WaitPoint” meta-element is needed for the threads to pause. In general case, execution of a thread stops at a point, the thread goes into waiting mode and resumes later. The “StartResumePoint” meta-element also provides this capability. Besides, a program with a multi threads which can meet in a point, necessitates the “MeetingPoint” element. Every task consists of one or more threads and each task can have some sub tasks. So, we consider a meta-element called “Task”. This meta-element is connected to the “Thread” meta-element by an association link. This support a thread to have one or more tasks which can be constituted of subtasks. In addition to the “Thread” element, a “ThreadStore” meta-element can be regarded. It acts like a container in which threads can enter. Also, a link exists between “ThreadStore” and “Thread”, since a thread can be placed inside a “ThreadStore” or “Thread”. In addition, we specify a meta-element, called “CLASS”, which includes a class with some fields and methods to work on the data and offer services for requestors.

The use of a thread can be realized by instantiating an object from its specifying class. “Thread” and “CLASS” meta-elements represent these concepts and we should be able to create instances from them. If we imagine classes as drawn house plans, we will be able to make some objects based on a class as we can build houses based on plans. Creating instances from these meta-elements, leads to “ThreadObject” and “GeneralObject” meta-elements with a link in between; because a thread can hold other objects in itself. The instances created as data member or function member can be transferred among threads. So, these elements identify the point that the data or function members can be shared or locally used. Inheritance can be used in these meta-elements with which a class can inherit the attributes of another class. This important capability makes the hierarchical classification possible.

Synchronization has a great importance in concurrent programs, since it is used for coordination of competition among threads. When several threads run in the memory on a shared object, unpredictable results may occur, if they are not controlled. Therefore, multithread program behavior cannot be trusted without proper synchronization and coordination, needed to prevent problems from occurring runtime. Generally, when a coordination issue is regarded, Mutual Exclusion and Deadlock [20] are mainly concerned which play an important role in our metamodel as well. Therefore, we have included “MutualExclusion”, “Deadlock” and “Synchronization” meta-elements in the proposed metamodel. The “Mutualexclusion” meta-element represents the techniques to prevent problems from occurring during coordination, giving exclusive access permission to each thread working on a common object. While a thread is working on an object, the other threads trying to access that object need to wait. When the thread has performed its task with exclusive access, a waiting thread gains access permission to the shared object. In this way, when a thread accesses a shared object, the other threads are prevented from concurrent access to the shared object. To realize exclusive access to the resources, concurrent techniques and algorithms such as Semaphore, Monitor and Lock can be used [21]. We represented them in the proposed metamodel for managing exclusive access to resources and coordinating threads. The representing meta-elements in the metamodel are called “Semaphore”, “Monitor” and “Lock”.

Languages have notations for representing their concepts and have constraints for their syntaxes. These notations are known as concrete syntax of those languages. The concrete syntax has two main types: Graphical Concrete Syntax (GCS) and Textual Concrete Syntax (TCS), used by different languages [22,68]. In this paper the main concrete syntax for DSML4CP is a GCS for the concurrent programs. In this study, the concepts of concurrent programs have been defined in an Ecore file as a metamodel. To design the Ecore model, we have used the above mentioned metamodel for which validation has been examined in Epsilon [23], and then we developed EMF
                           3
                        
                        
                           3
                           Eclipse Modeling Framework (EMF): http://www.eclipse.org/modeling/emf.
                         file in EMFatic language using EuGENia tool. 
                        Listing 1 shows a part of the code for concrete syntax of DSML4CP in EMFatic language.

EuGENia provides a set of high-level annotations in EMFatic language with which shield the developer from the complexity of Graphical Modeling Framework (GMF
                           4
                        
                        
                           4
                           Graphical Modeling Framework (GMF): http://www.eclipse.org/modeling/gmp/.
                        ) and removes the initial barrier for creating the GMF editor. To this end, in Listing 1, we have added various annotations before each meta-element to define the notations. For example, in Line 2 “@gmf.diagram” annotation defines the class as a root element where all of the other meta-elements are located within its class using “val” keyword (Lines 3–14). Also by adding “@gmf.node” annotation in Line 15, this capability is provided for “Program” meta-element which appears as a node on the palette.

In addition, in Line 17, “@gmf.compartment” annotation defines a containment relation which creates a compartment for the model elements. Lines 18 and 21 are examples for this case and they make it clear that the “Thread” and “CLASS” meta-elements are inside the “Program” meta-element. It is worth mentioning that for showing links on the palette, we used “@gmf.link” annotation, e.g. Lines 28 and 34. In Line 29 the “ref” keyword indicates that between the “Thread” and “Task” meta-elements, there is a link named “hasTask”. Also, it is remarkable that, the “att” keyword provides attributes for meta-elements. In Lines 25–27, “name”, “description” and “priority” attributes are defined for “Thread” meta-element.

As a result, a set of graphical notations for the meta-elements in the metamodel has been selected for the concepts and relations to be added to the tool. 
                        Table 1 shows the graphical symbols for some of the concepts in the concrete syntax of concurrent programs. After selecting graphical symbols, Eclipse GMF was used for relating domain concept in Ecore format and their symbols. Resultant structure is a graphic editor developed based on the concrete syntax for concurrent programs and enables users to design concurrent programs on the modeling framework.

Although the main concrete syntax of DSML4CP is a graphical one, we also developed a textual concrete syntax [19] using Xtext [24] in order to increase the number of the users, since some developers are interested in textual programming. In addition, a textual language has the advantage of scalability comparing to graphical languages.

The concepts of a language have a critical importance and providing them in a language is one of the main issues in language development process. However, the meanings of the concepts are as important as their syntax. With exact understanding of the concepts’ meaning in a language, the ambiguity of the language is resolved and the artifacts can be easily generated for the target platforms. Because of the importance of this resolution, focusing on semantics and its definitions are inevitable for a language [25,67]. Hence, in this section, the semantics of DSML4CP is stated in the form of static semantics using constraint checks and operational semantics using model transformations.

Since abstract syntax and concrete syntax gives little information about language meaning, we need further controls to describe the language concisely. In this case, language concepts can be limited by constraints and can be described by the concepts of the other languages. These approaches are called constraint check and model transformation, respectively. These are necessary for an executable language to enable the language to operate accurately [22].

There are different tools for constraint check/control of language (e.g. Object Constraint Language (OCL)
                           5
                        
                        
                           5
                           Object Constraint Language (OCL): http://www.omg.org/spec/OCL/.
                         
                        [26] and Epsilon Validation Language (EVL)
                           6
                        
                        
                           6
                           Epsilon Validation Language (EVL): http://www.eclipse.org/epsilon/doc/evl/.
                         
                        [27]) from which necessary constraints can be applied on metamodels. In this section, static semantics are applied in DSML4CP, for the proposed metamodel and its corresponding elements and links, by providing different constraint controls including character/string constraints, “a number of elements and relations” constraints, and “a sequence of the relations” constraints using EVL. These constraints will be applied on models to limit the user when he/she designs the instance model based on the metamodel in DSML4CP framework. Each of these constraint controls is elaborated as follows.

For each meta-element of metamodel in Fig. 1, some character/string constraints have been added. One of these constraints is named “NameStartsWithCapital” and requires the initial character of each element to be capitally named, while designing, on the palette. Unless this happens, there will be a warning saying each element should be named with a capital letter. 
                           Listing 2 shows this constraint for the “CLASS” meta-element as an example. As another example, the “HasName” constraint is considered for some of the meta-elements that contain the “name” attribute. This constraint limits the elements to have a name while designing on the palette unless; a “not allowed” message is displayed for the developer. Listing 2 shows this constraint for the “Program” meta-element.

In addition to these constraints, the “BannedCharactersForName” constraint is introduced in a way that, while naming, none of the special characters (*, /, :, ?, >, <, |, \\, “) can be used for meta-elements; because starting with these characters will lead to an error. Listing 2 shows this constraint over the “ThreadStore” meta-element in Lines 18–40.

For some meta-elements in the proposed metamodel, the number of elements constraint is added which is called “NumberOfElements”. In Listing 2, we considered this constraint for the “StopPoint” element. Based on this constraint, the stop points for each program are checked in Line 43. If the stop point is more than one, there should be a warning saying that “every program should have one stop point”. A similar constraint has been specified to the “Shared” element.

There are other kinds of constraints provided for elements’ relations. One of these constraints is “RelationBetweenElement”. Listing 2 shows this constraint for “Thread” element. As it can be seen, first, the “guard” keyword in Line 49 guarantees that each link has a name. Then, in Line 50, the source and target meta-elements are controlled for the thread. If a link is forgotten to be designed between the meta-elements in the metamodel, there will be a message displayed saying that “Link is forgotten”.

In addition to the abovementioned constraints, DSML4CP provides some other constraint controls for the users which are implemented using the Eclipse framework capabilities. The produced tool in Eclipse has control facilities that check the following constraints.

The composition relationship among the meta-elements in the Ecore is transformed to a relationship in a way that an element can contain another element. The elements which do not have such a relationship have no possibility to be modeled in the form of a nested compartment. For example, this capability can be seen in the “Thread” and “CLASS” meta-elements as both of them are located in the “Program” meta-element.

Based on one-to-one, one-to-many, and many-to-many relationships in the metamodel, a control is done on the number of relationships among the elements in the models. For instance, this relationship is considered between the “Thread” and “StopPoint” meta-elements, meaning that every thread can only have one endpoint.

The direction of the relationship defines the source and destination of that relationship. This constraint is defined at the Ecore level to control this direction. For example, based on our constraints, relationship between “Task” and “Synchronization” meta-elements cannot be established at the time of designing models.

The inheritance relationships defined in DSML4CP bring some more constraints when modeling the language tools. Naturally, a subclass in a model includes all of the attributes and relationships of its superclass. “Semaphore”, “Monitor” and “Lock” meta-elements are examples of this case.

The constraints mentioned above show the intelligence of a DSM which forces the user to model accurately and reduce error occurrence in the level of modeling. This also leads to a code with fewer errors, after the code generation step.

It is not enough to develop a DSML simply with conceptualization of terms and relationships on a graphical tool. A complete definition of a DSML requires code generation on validated models. For code generation, there are different tools to implement the model-to-code transformations, such as, MOFScript [28], Acceleo [29], JET [30], and Xpand [31]. In this study, we selected Xpand due to its advantages such as simplicity, integrity with Eclipse, and working with EMF based models.

For code generation in the solution domain, we need to access metamodel of the domain (Ecore file), and the problem instance model (XMI file). To realize the code generation, we need to provide some rules based on the architecture of the selected domain using the Xpand tool (XPT file). Eventually, we can generate the artifacts, which are Java code in this case, by running these rules.


                        
                        Listing 3 shows part of the rules for code generation by Xpand tool. In line 1 of Listing 3, the metamodel namespace is imported in order to make the meta-types known to the editor. Next, the main template is created. Xpand’s keywords and meta-type references are always enclosed in “«” and “»” characters. In this Listing, the “javaClass” function is invoked for “this.programs”, “this.tasks”, “this.sync” and “this.threadStore” in Lines 3–7 to call the other sub-templates. In Xpand, it is also possible to invoke a function for each of the elements. For example, function call for “Program” meta-element is shown in Listing 3. As it can be seen in Line 10 of Listing 3, the “javaClass” function is defined for the “Program” element. In Lines 15–18, by receiving the program name, there are invocations of “InstanceVar” and “javaClass” functions for each “this.hasThread”; and also, invocations of “InstanceVar1” and “javaClass” functions for each “this.hasClass” to fill the rest of patterns using sub-patterns. Later in Line 23 of this Listing, the “InstanceVar” function is defined for the “Thread” meta-element. This function gets thread names and makes objects for each thread class and then, starts the thread. Additionally, we have defined “javaClass” function for each “Thread” in Line 32. Inside this function, the class is implemented for the “Thread” element which overrides the run method.

It should be noted that, for the other meta-elements the “javaClass” function is defined similarly. For example, we examine the rules for the “Program” meta-element. To get the output, we should run generator.mwe file in Xpand tool, as it is shown in 
                        Fig. 2. After completion of the workflow, the output files, in the form of Java codes, will be generated based on the provided rules for each element.

The left side in Fig. 2 shows that for each of the elements (XMI file), results have been generated automatically as a set of files including Java codes. 
                        Listing 4 shows a sample of codes generated for the “Program” element which is named “ClientServer”.

As it can be seen in Listing 4, an object is created for each thread in the main method. In addition, with having another class named Buffer, a separated object is created for this class to complete the task of the thread. Incidentally, all output files are generated likewise.

It is worth mentioning that the rules written for generating C# code is structurally similar with those for Java, see Listing 3, with only different templates. So, the generating rules for C# are not presented in the paper to avoid repeating. However, in the second case study (Parallel Matrix Multiplication Problem), the code generation for C# is used and the results are demonstrated.

The syntax and semantics of the DSML4CP language are explained in Sections 2 and 3. In this section, we are going to explain the performance of the developed language over two examples. We selected Producer/Consumer and Parallel Matrix Multiplication Problems as they are among the most well-known problems in parallel processing. Also, they have enough complexity in coding to be modeled in DSML4CP.

By considering the definition of the Producer/Consumer problem, we can see that there are two main actors in this problem; the producer and the consumer which access a shared memory with specific capacity as a buffer. The producer’s task is to make data items and put them in the shared memory. At the same time, the consumer can take data items and consume them. The producer and the consumer can produce or consume just one data item in each turn. These two processes can run simultaneously.

The problem is that we should make sure that a producer does not try to put a data item in a full memory. Similarly, a consumer should not try to get a data item out of empty memory. Whenever the memory is full and producer tries to save an item in, it should sleep until a consumer gets an item out and awakes it, similarly, whenever a consumer wants to get an item out of empty memory, it should sleep until a producer saves an item in and awakes the consumer. An unwanted situation is when both of the processes go to sleep and nothing can awake them. We can prevent this problem with semaphore and monitor algorithms [32,33].

To apply the development methodology proposed by DSML4CP on Producer/Consumer problem, we need to first model the solution in DSML4CP’s graphical language. Based on concepts discussed in Section 2, the instance model of the concurrent program is implemented in a graphical editor which models required instance elements. The model for the Producer/Consumer problem is designed in the tool and its snapshot is illustrated in 
                        Fig. 3.

In this instance model, each producer and consumer is regarded as a thread class including starting, waiting, and stopping points. Threads start their process at start point, wait in waiting point, and stop at stop point. Each point is a task and the tasks should be connected to a thread, as can be seen in Fig. 3. When a producer produces data, it must be stored in some place of the memory. In our metamodel, for storing data, a memory block is considered which is shared between producer and consumer.

The producer stores its produced data in this memory and the consumer has access to this data to take the produced data and remove it to use. If there is no data in the memory, a delay occurs between production and consumption. Then, the consumer waits to get produced data and remove it.

On the other hand, produced data should be accessed by only one consumer. To realize this, coordination is needed to make sure that produced values are consumed properly, e.g. mutual exclusiveness, which allows the program to coordinate threads. For managing the exclusive access to resources, techniques such as semaphore, monitor, and lock can be used.

During the modeling of the instance model for Producer/Consumer problem, the tool provided the semantic controls where needed. By adapting to the proposed constraints for the meta-elements discussed in Section 3, in this section, the Producer/Consumer problem is modeled in the provided tool and checked in accordance with those constraints.

As it can be seen in 
                        Fig. 4, the “HasName” constraint was not true for “Task”, “Program”, and “Thread” elements during the model design, so the language supposed it as an error and generated a relevant message for each of the elements separately. Also, the “NameStartsWithCapital” constraint was not true over “dataMember” and “consumer” elements, since the user has initialed them with small letters, so a warning is shown to the user meaning that a capital letter should be used for the initial letters. In addition, the connection between “WaitConsumer” and “StartConsumer” elements has been missed, so an error telling “the connection is missed” is given to the developer.

As the last step of using DSML4CP for Producer/Consumer problem, the code generation is realized. To this end, in this part, we describe how to generate the executable architectural code for this problem based on discussed concepts in Section 3. For this purpose, we applied the steps outlined in Fig. 2 and the output files were obtained as some Java codes for this case study. 
                        Fig. 5 shows a list of output files for the Producer/Consumer problem. Altogether, 18 files were generated which constitutes the program of the model.

It is worth mentioning that the generated code was completed with some manually added codes (developer’s delta codes) for each case study to become final executable programs. Some parts of the final codes for thread classes, Thread in Consumer and Thread in Producer, are presented in 
                        Listing 5. The analyses of the generated and added codes are provided in the next section.

In this section, we examine the Parallel Matrix Multiplication problem as one of the case studies in this paper. Parallel Matrix Multiplication is one of the most prevalent operations in scientific computing and its modeling can represent complex examples of concurrent programming.

Multiplication operation of matrixes is costly and time consuming when size of two matrixes is very large. If we consider the complexity of its algorithm in mathematics, it needs at least O(n
                        3) operations to multiple two n*n matrixes, which is time consuming for big sizes of n. It is intended to decrease this time to as low as O(n) by applying concurrent programming and using n*n processing threads. As regards in the parallel matrix multiplication, the calculation of every element in the product matrix is result of vector multiplication for a row in the first matrix with a column in the second matrix and this calculation is independent of computing the other elements. Therefore, for multiplying two n*n matrixes by having n
                        2 processors, multiplication of every rows and columns can be given to a processor which calculates one of the n
                        2 elements of product matrix [34].

For modeling the problem in a higher level, we design the Parallel Matrix Multiplication case study in the graphical editor of DSML4CP. 
                        Fig. 6 shows the modeling of this problem based on the proposed metamodel in this study. In this model, we considered two classes of “Thread” namely “Main” and “Mul”. The Main thread creates the other helper threads and distributes all the rows and columns of the matrix amongst those threads. Helper threads fulfil vector multiplication operations and return the results to the main thread which prints out the result matrix. As it can be seen in Fig. 6, considering the instantiation of the threads, “Main” and “Mul”, we have created “ObjMain” and “Obj1 to Obj16” objects from those classes and typed them as data. Given that, in this case study, we have considered the size of the matrixes as 4*4 (to be able to represent the models in the paper), 16 thread objects have been created from “Mul” class and each of them does multiplication of a row and column in the matrixes.

On the other hand, for each “Thread” class, we have start, wait, and stop points. In this way, threads can start their tasks from the start points, wait for each other in the wait points and end their tasks in the stop points.

It should be mentioned that the main thread acts as a coordinator and after the distribution of rows and columns of the matrix between the threads, it waits at a waiting point for the results and then it prints out the result. 
                        Fig. 7 shows the process of this computational model.

For applying the semantic controls for the Parallel Matrix Multiplication problem based on given constraints in Section 3, we examine the designed model in the graphical editor. As it is illustrated in 
                        Fig. 8, some proposed constraints have been forgotten by the developer for the model, for which some errors and warnings have been appeared aside the elements.

As an example, “HasName” constraint is not considered for the “ThreadObject” and “Task” elements. So the language shows an error for these elements. Also, threads need to have a start point to begin their tasks from that point. Similarly, the connection between “Mul” and “StartMul” elements has been missed by the developer, so an error appears aside the element until the user adds the link between the elements.

In addition, the constraint rule of “BannedCharactersForName” is not observed by the developer for “Program” element. The developer should not use “*” as the first character for the name of this element, so there is an error stating that the name must not have (/, *, :, ?, <, >, |, \\, ”) characters. Also, “NameStartsWithCapital” constraint was not true for the “Task” and “ThreadObject” elements (named “multiplicationAndCalculated” and “obj10”) and the developer has used lowercase as the initial character for the name, so there is a warning stating that the name should start with a capital letter.

Finally, to complete the procedure of development with DSML4CP, we need to generate architectural codes from the model for the Parallel Matrix Multiplication problem. The code generation for this case study is in C#. To this end, we have considered the model depicted in Fig. 6 (in an XMI format) as the model for the Parallel Matrix Multiplication problem. With having the other input files (such as the metamodel), we performed generator.mwe in Xpand tool and achieved the results in C#, based on the rules given in Listing 3 for model transformation. In order not to have repetition, we have avoided demonstrating the rules here. 
                        Fig. 9 illustrates generated artifacts for the Parallel Matrix Multiplication problem.

It should be mentioned that to achieve the final running codes, the generated codes have been completed with manual codes (the developer’s delta codes) which result in final codes for the case study. In 
                        Listing 6, part of final codes is shown for “Mul” element.

It is worth to note that in the excerpt result presented in Listing 6, the Lines 1–3, 5–6, 16–26, 32–34, 36, and 39–40 are the codes that have been generated automatically and the Lines 4, 7, 9–15 and 27–30 have been added manually, as user delta code, to complete the development.

In this section, we evaluate the DSML4CP language. To this end, we cover both evaluating the capabilities of DSML4CP and comparing it with other similar tools and languages. These are covered in this section and in the related work section respectively. In the following sections, we show that developing a DSML increases the speed of development and decreases the error occurrence probability (in the domain) which leads to improve efficiency. We performed quantitative evaluation for DSML4CP, based on case studies with considering required time for development [69]. In addition, qualitative evaluation is realized for DSML4CP.

Quantitative analysis of DSML4CP components is performed in this section. For this purpose the abstract syntax, concrete syntax and steps of the code generation for DSML4CP are analyzed. 
                        Table 2 shows the specification of these parts. With considering the proposed metamodel in Fig. 1, we can see that the metamodel has been created out of several meta-elements which are based on given issues in concurrency discussions. Each of these meta-elements symbolize a concept in a concurrent program. If a meta-element needs to be connected with another meta-element or with itself, there should be a link/relationship among them to let the connection happen. We have used different types of connections between meta-elements, such as association, composition, and inheritance. Table 2 shows the data for the above mentioned metamodel, editor, and code generation considering the number of meta-elements, links, attributes, and so on.

In short, all meta-elements and their links in the metamodel can be operated in the palette directly. By considering the results of quantitative analysis for language components, Table 2, it can be seen that, in DSML4CP, the number of the links in the palette has increased comparing to the metamodel. The reason is that we have used some inheritance relationships in the metamodel which make the possibility for all child meta-elements to inherit the links form their parent meta-elements. These child meta-elements have their own links when it comes to reflect the metamodel in the concrete syntax.

In Section 4, we selected the Producer/Consumer and the Parallel Matrix Multiplication problems as our case studies and explained their implementation in details. In this part of the paper, we evaluate the language based on these two case studies to examine the generation performance of the language. It should be stated that all the data collected in the tables afterward are based on the average numbers provided from both cases. Also, the fraction numbers are rounded to make it easier for comparison.

To get the results of DSML4CP, we need some input files to complete the code generation step. Considering Fig. 2, it can be seen that one of the input files is the XMI file in which we designed instance models in the graphical editor (Figs. 3 and 6). 
                        Table 3 shows the specification instance models for the case studies.

The result of the code generation phase is an architectural code for the elements in several files. We have already shown some of these files in the case studies. Table 3 also illustrates the information for the generated artifacts. This table shows the number of generated files, the total lines of generated code, total generated functions, and the sum of the generated threads.

As it is mentioned earlier, to execute the artifacts, we need to add delta codes manually to the generated codes to make them functionally complete. Therefore, for both problems (Producer/Consumer and Parallel Matrix Multiplication), besides the generated codes for element, we have added a set of codes manually (developer’s delta code). Table 3 also shows the specification of these added codes. The data in Table 3 is demonstrated in 
                        Diagram 1 as a diagram to have a better understanding of the figures.

According to Diagram 1, considering both case studies, the results show that 79% of the final program code and 86% of the functions have been developed automatically, while just 21% of the codes have been written manually and 14% of functions have been added manually to the programs to be executable. All the threads in the models have been created automatically.

By analyzing the information in Diagram 1, we can see that the majority of the codes have been generated automatically and a small amount of codes need to be written manually. This saves a significant amount of time in the development of the case studies which is examined in more details in the next section.

Given that the main purpose of this paper is the development of a DSML for reducing the complexity of concurrent programming and speeding up the development, we have evaluated the development times for the case studies both in the new language (automatically) and in the Java and C# programming languages (manually).

It worth to mention that we have considered two teams in the evaluation, one for using DSML4CP and the other one without using a DSML. Each of the teams is composed of four people to realize the evaluation. Evaluators of both teams were master students from software engineering department. They also had bachelor of computer engineering. They had passed “parallel computing (including multithread topic)” and “advanced software engineering (including MDE)” among other courses. For the evaluation, three case studies are used: Producer/Consumer Problem, Parallel Matrix Multiplication Problem, and Readers Writers Problem. Members of the first team have developed the case studies using production tool for DSML4CP, and members of the second team have done the same task without using the modeling language and its framework. This team has developed the case studies in Java and C# environments.

Finally, the timing and coding information for both teams are collected and reported as the results. The results show that Average development times for the case studies are 23min in DSML4CP and 39min in Java and C#. 
                        Diagram 2 shows the development times of the artifacts in DSML4CP, Java and C# languages for the case studies.

As it can be seen in Diagram 2, development time in the new language, DSML4CP, is lower (almost by half) than of the one with Java and C# programming languages. This is because a big part of the code is generated automatically, based on Diagram 1. In some other studies also supporting results are presented. For example in [66] three controlled experiments are conducted to compare a DSL and a GPL and in all three experiments, the participants took less time to complete the DSL tests than they did to complete the GPL tests. As a result, the development using DSML4CP helps in increasing the speed of development for concurrent programs. Meanwhile, it decreases the probability of error occurrence due to automatic generation of the code which is error free and thus, leads to overall performance improvement.

DSMLs brought changes to the software development with some key features. They are suitable for some specific domains for which they lead to increase development speed, decrease in the structural complexity, and improve the efficiency. Therefore, assessment of the quality of a modeling language is a significant part of this kind of research study. To this end, we evaluate the quality of DSML4CP by some of the success factors for the DSMLs suggested in [35]:

Development of DSMLs requires deep knowledge of the domain of interest. So, by focusing on that domain, we can achieve concepts and expressions (in addition to the rules and constraints of the system) with domain analysis [36]. After selecting a domain among possible choices, as the first step of developing the modeling language, we started to collect and process the information about that domain. Information relevant to our domain is obtained from various sources such as domain experts, and technical documents which feed our metamodel.

Determining a target for the domain is vital for developing a DSML. If the domain becomes so wide, there is no clear target for the domain. Also, if it is too narrow, the generation performance will be low. Certainly, these cases are not proper for developing DSML [36]. Therefore, based on the concepts that is considered for the concurrent programming domain, (such as synchronization, threads, mutual exclusion, deadlock, and so on), we have tried to develop a language to decrease the complexity of concurrent programs. In this manner, our target domain is clearly specified as concurrent programming in Java language.

To develop a DSML, one should carefully provide the metamodel used for defining the domain’s concepts and relations. Providing an appropriate metamodel requires that proper concepts to be extracted from the domain, e.g. from many sample programs in the target language or from the language documents. This is the vital pre-condition for the accurate artifact generation in any DSML. In contrast, an improper metamodel will lead to vague or incorrect specification which cannot be effective in the production for the domain [36]. In this case, we chose our metamodel based on existent concepts in concurrent programs from the experts and the texts, so that, each meta-element reflects a concept in concurrent programming.

Developing a DSML is a difficult task which needs expertise both in language engineering and in the targeted domain. Considering the earlier one, there is also a need to have technical knowledge of using some tools for development of a modeling language which can automatically do many tedious tasks of development process of a domain (for example, analyzing, designing, code generation, etc.). As indicated in the previous sections, we have also used several tools for developing our modeling language in order to facilitate the process of our domain [37]. With the help of these tools, we could create a graphical language and design various instances in it.

For a DSML, high level of abstraction is a key feature, basically coming from the MDD definition, because it causes the improvement in the efficiency and quality, and reduces the level of complexity. Adoption of each instance model form its metamodel which is validated by the tools guarantees to have structurally accurate models for the domain. Applying the semantic control over the instance models help to have meaningfully accurate models [37]. As a result, a DSML, say DSML4CP, forces the designer to design accurate models which can help to generate accurate artifacts, with having right transformation rules. This leads to error free architectural codes which is result of working in a higher level of abstraction from code, namely model.

@&#RELATED WORK@&#

In this section, we state the related studies. To this end, DSLs and tools for concurrent programming are examined in Section 6.1. Also, a comparison is made between the new language and the previous studies in Section 6.2.

General purpose languages such as Java [38], C# [39], and Ada [40] support concurrent programming. They have structures for creating threads and their control. Also, there are worthwhile studies in which MDE [65] has been used for parallelism. For example, in [57], the authors use model driven approach to provide a framework, called PPModel, for separating parallel blocks of a program, mapping them to different platforms, and executing the entire program in a parallel way. In [58], meta-programming is utilized for the domain of High Performance Computing (HPC) by introducing a DSL, called SPOT, for HPC in Fortran. The goal is providing source-to-source translation of Fortran programs with the consideration of software maintenance and evolution in HPC systems. The study in [59] proposes a DSL to obtain the Application-Level Checkpoints (ALC) for distributed and parallel applications from end-users. Its aim is reengineering of existing applications to insert ALC mechanism in the program. Also, in the study of [60], integration of several modern software engineering tools and techniques, such as DSL and meta-programming, are used in an infrastructure called Hi-PaL to determine the methods that have the potential of reducing the parallelization complexity. They address explicit parallelization in their study. However, the goal of none of the above mentioned studies is modeling the problem domain of concurrent applications and generating the architectural code from the models using MDD tools and techniques.

On the other hand, there are specific concurrent programming languages (e.g. Alef [41], Axum [42] and Concurrent Pascal [43]) that provide programmers with more facilities in this regard.

Alef [41] is a concurrent programming language designed for system software. It provides exception handling, process management, and synchronization primitives. It supports both programming with shared variables and message passing. Statements in this language have a syntax similar to C, however the type system is different. Alef provides OOP using static inheritance and information hiding. Nevertheless, it does not support garbage collection, thus programs need to handle it.

Axum [42] is a DSL for concurrent programming. It is based on the Actor Model which was initially developed by Microsoft. Axum is an OO language based on the .NET CLR with a syntax similar to C. As a DSL, it is designed to develop parts of a software application which fits to concurrency. However, it has sufficient general-purpose structures which leave no need for the programmers to use a GPL such as C# for the sequential portions of the program. The main concept in Axum is an Agent/Actor which is an entity runnable simultaneously with other Agents. Objects in a domain are not directly accessible from another object. To resolve this issue, Axum offers channels which can be considered as directed pathways for communication among agents.

Concurrent Pascal Language [43] is also a concurrent language that is based on shared memory and is developed from Pascal language. It has standard characteristics which are used in parallel programs. Although this language is based on Pascal in which the processes are executed serially, but it provides the possibility of writing concurrent programs. Since this language is imperative, related simulators make the possibility of programming based on a shared memory and message passing.

Generally, the languages mentioned above give programmers the ability to produce concurrent programs. However, design and execution complexities are up to the programmer. As mentioned earlier, involvement with the problems of concurrent program’s design and implementation such as thread coordination (in serial and parallel form) and their synchronization (e.g. mutual exclusion and deadlock control) in coding level is complex and erroneous, needing promotion of concurrent program’s abstraction level. In this respect, some researchers tried to develop tools and methods for reducing such complexities.

For example, Convit [44] is a visualization tool based on Java provided for learning and understanding concurrent programming. This tool is a debugger and emulator that runs concurrent programs written in a simple pseudo-code. It is worth to note that the code is initially converted to Java code and then executed. Since Convit is based on Java applet, it can be used on any computer using a web browser. The syntax of this tool is similar to a combination of Pascal [45] and C [46] and can be understood by a person who has threshold knowledge of concurrent programming. Although Convit is a visualization tool, the tool has been proposed as a learning tool and is not a programming language. Therefore, it does not have the capabilities of a language (such as syntax and semantic controls).

Krystosik [47] used EMLAN language [48] and automatic features of DT-CSM [48] to evaluate concurrent program models. The aim was educational modeling and evaluation for concurrency and cooperation of tasks. As a result, concurrent program’s error detection becomes possible though it is a difficult task. But despite using MDA, the aim of this approach is not producing code from model and decreasing structural complexities of concurrent programs.

Another work realized by Artho et al. [49] offers a method based on ordinal UML diagrams [50] to illustrate concurrent programs. This method facilitates analysis and design of concurrent programs, helping error detection. But, in this study, not only no language is offered for semantic control, but also, no tool is provided for using these models.

Visual language of VISO [51] is designed for making concurrent programs, based on OCCAM language [52,53]. In this language, concurrent programs are designed in several abstract layers in modular form. VISO does not support shared memory and uses message passing for communication between the processors. Semantic structures of this language are provided in Petri net [54] and process calculus [55,56]. But, this language does not support final code generation for other languages such as Java and C#.

In [61], Bull and Kambites has defined an OpenMP like interface for Java which enables a high level approach to shared memory parallel programming. As regards, OpenMP has been a relatively new industry standard for shared memory parallel programming, it is capable of increasing levels of support from both users and vendors in the HPC field. In addition, this standard defines a set of directives and library routines for both FORTRAN [62] and C/C++ [63], and provides a higher level of abstraction for programmers. In this study, although the possibility of writing parallel programs on a shared memory, which was originally difficult, became possible and implemented in Java. But in this study, not only no tool is offered to design the programs as graphical models; but also no facilities were considered for semantic control.

Java has provided a mechanism for concurrent programming implemented as language constructs, but it is too rudimentary for most programmers and includes a number of limitations. In research work [64], researchers have implemented Java4P, an extension of the Java language, which offers a simpler concurrency model and overcomes Java’s limitations. In this study, although semantic controls have been taken into consideration, but they are not providing a tool to support using models.

As it is discussed earlier in this section, each of the tools and languages has its shortcomings comparing to DSMLs. Not only can a DSML make the possibility of graphical modeling for concurrent programs and controlling them while designing, but it can also promote semantic level of the language by turning one model into another peer model in another language and finally generate the code which is executable in the well-known target languages. In this case, the speed of development increases and error occurrence reduces, resulting in the improvement on the quality of the procedure and the product.

Considering the tools and languages specific for concurrent programming which have been discussed in the previous section, it can be stated that although these languages give more facilities to the programmer to make use of them in creating a concurrent program, they only provide a textual syntax for the programmers without considering domain specific constraints. Thus, the complexity of the design and implementation of the program is the responsibility of the programmer.


                        
                        Table 4 shows that DSML4CP provides an environment which reduces the complexity of concurrent programs, so that, the users are able to design and implement concurrent programs by creating domain models. In addition, as it can be seen in this table, DSML4CP has most of the capabilities which are provided by the other tools and languages in the domain with an extra capability of architectural code generation. Despite all the advantages provided by the DSML4CP, it should be mentioned that it does not have the capability of controlling the program while the program is running which is an open research issue for the researchers.

Also, none of the above mentioned studies are based on MDA with the aim of code generation. On the contrary, DSML4CP not only can provide the possibility of modeling a concurrent program in a graphical form, but also it can do adequate controls during the design with which it improves semantics of the language. In addition, the speed of development increases by automatic generation and the efficiency rises by reduction of errors. A summary of discussed properties is given in Table 4 for the comparison between DSML4CP and the other tools and languages.

@&#CONCLUSION@&#

In this paper, concurrent programming has been addressed as a domain for developing a DSML, called DSML4CP. To this end, with regard to concurrency concepts and relations among them, a metamodel has been provided as the abstract syntax of the domain. Also, concrete syntax of the language has been prepared as a graphical tool, which provides the possibility of designing concurrent programs in the form of models in DSML4CP. It must be mentioned that for clarifying the meaning of this new language, static semantic controls for DSML4CP, in the frame of a series of constraints are considered, using EVL. Finally, for completing the language, code generation is fulfilled based on the abstract syntax, the instance model, and using the transformation rules in Xpand language. An evaluation based on case studies show a high efficiency forth proposed language. Regarding conducted evaluation on two case studies (Producer/Consumer problem and Parallel Matrix Multiplication problem), 79% of the final code and 86% of the functions are generated automatically and only 21% of the final code and 14% of the whole functions are added manually to have both case studies ready to run.

Although there are many advantages for DSML4CP and it is worth developing this DSML, there are some challenges in its development. These challenges are generic for DSMLs and DSML4CP is not an exception in this regard. Underneath, we address three of them to convey our experiences and lessons learnt:

DSML development has different steps in which various technologies and tools are used. For this reason, developing a DSML is costly and time consuming. It should be considered that developing a DSML should return the investment at some point. Multi-thread programming is a very popular way of concurrent programming. This technique is supported by many generic languages such as Java which are used by many developers. So, considering the number of users, developing a DSML for concurrent programming can return the investment by reducing time and a number of errors for many developers.

To develop a DSML for a domain, such as concurrent programming, we need to master both the domain and DSML development. From one side, the language designer should be well informed of the domain details; from the concepts and their relations to the implantation and architectural structures. From the other side, the language developer should fully cover the knowledge of the modeling language development, in this case DSML development. Bringing these two expertise together is a difficult task, since it demands a high expertise.

Developing a multi-thread program without using domain specific tools needs a limited level of expertise, since we can train a developer to do it in a single language. So, the developer who is going to implement a multi-thread program should only be trained in this field. However, if the developer is going to use a DSML (for instance DSML4CP) to use in development, he/she should not only get related training for multi-thread program, but they also must learn how to use domain specific tools. This requires some time and effort to start up a team for developing the programs using DSMLs. Although this time and effort will be retaliated in the later phases of development (e.g. problem domain analysis, design, and implementation), it will increase the learning curve of the language in the first development.

To gain the benefits (e.g. performance) of the proposed DSML in this paper, the users need to have programming skills in general and parallel/multithread programming experience (i.e. domain knowledge in the context of this paper) specifically. This is because the automatically generated codes should be completed with the users to have final codes. In addition, to use the proposed DSML the users need to have familiarity with its tool which is discussed in the previous item.

Finally for the further studies, based on the proposed metamodel, it is planned to develop a DSML in Platform Independent Metamodel (PIMM) level; so that, the user will be able to generate codes for different programming languages from the same model. In addition, since our domain is a dynamic domain, we can apply dynamic controls and model checking (using formal methods) alongside static controls to increase the quality of instance models which increases the quality of the final generated artifacts.

@&#ACKNOWLEDGMENT@&#

This study is partially supported by the Islamic Azad University of Shabestar, Department of Computer Engineering in the scope of a Master thesis. The authors would like to acknowledge Vahid Khalilpour Akram for his helpful comments and suggestions for preparation of the domain concepts in this study. Also, Elaheh Azadi Marand and Elham Azadi Marand would like to acknowledge Moharram Challenger, their M.Sc. thesis supervisor, for all his guidance and support during their thesis studies.

@&#REFERENCES@&#

