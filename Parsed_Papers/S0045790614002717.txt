@&#MAIN-TITLE@&#A combinatorial optimization algorithm for multiple cloud service composition

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           The COM2 algorithm efficiently considers multiple clouds while composing services.


                        
                        
                           
                           The proposed algorithm successfully competes with previous algorithms.


                        
                        
                           
                           Low examined service number is achieved without impacting the combined cloud number.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Combinational optimization

Web services

Service composition

Cloud computing

Multiple clouds

Cross-clouds

@&#ABSTRACT@&#


               
               
                  Service composition is an evolving approach that increases the number of applications of cloud computing by reusing existing services. However, the available methods focus on generating composite services from a single cloud, which limits the benefits that are derived from other clouds. This paper proposes a novel COMbinatorial optimization algorithm for cloud service COMposition (COM2) that can efficiently utilize multiple clouds. The proposed algorithm ensures that the cloud with the maximum number of services will always be selected before other clouds, which increases the possibility of fulfilling service requests with minimal overhead. The experimental results demonstrate that the COM2 successfully competes with previous multiple cloud service composition algorithms by examining a small number of services—which directly relates to execution time—without compromising the number of combined clouds.
               
            

@&#INTRODUCTION@&#

Cloud computing is an elastic service provisioning model that enables on-demand network access to a shared pool of computing resources. The popularity of cloud computing has increased in recent years. Currently, cloud computing provides a single set of physical resources for providing multiple information technology (IT) services to a large user base with varying needs [1]. Cloud services are offered as self-contained components that provide IT solutions for consumer requirements via the Internet [2]; they are typically delivered by a Web service interface. Although cloud services are used interchangeably with Web services, these services differ primarily with respect to their service level agreement (SLA) identification, quality of service (QoS) and service discovery [3].

In many cases, a user’s needs require multiple cloud services to be provided, which is the main driver for the concept of service composition. This concept focuses on the creation of a new value-added cloud service that incorporates previously existing cloud services [4].

The service composition problem is an NP-hard optimization problem [5,6]. Thus far, several service composition approaches have emerged to provide guidance for this problem by combining services to create higher-level business processes at a reduced time and cost with increased efficiency [7]. For instance, an optimal service composition algorithm was introduced based on the QoS of the candidate cloud services [8]. An additional criterion that accounts for the relationships among the different cloud services was added, which improves the quality of the composite services [9]. EFlow was presented [10] as a platform for service composition. The general idea behind this method is that software agents can be utilized by Web services to perform automatic Web service discovery, execution and composition. A semantic Web technique was proposed [11] to generate composite services from a high-level declarative description. This strategy uses the syntactic and semantic properties of the services to determine whether two services are composable. More than ten service composition methods have been reviewed and analyzed in [6]; however, a common assumption among these techniques was that all the services that are required for the composition are contained within a single cloud. This approach is simply unrealistic; many business processes require services from different providers and thus from multiple clouds [12].

Multiple cloud service composition is an emerging topic that has attracted much recent attention. Multiple clouds, multi-clouds and cloud federations are newly coined terms in cloud computing that have begun to attract attention. These synonymous terms refer to cloud services that are utilized through several cloud providers [13,14]. There are four approaches to implementing multiple clouds.
                        
                           •
                           
                              Horizontal multiple clouds. In this approach, multiple providers create a federated cloud by cooperating on an agreed upon price scheme.


                              Inter-clouds. In this approach, clouds are organized into groups based on common criteria, such as addressing, naming, identity, trust and time domains [15].


                              Cross-clouds. In this approach, multiple cloud providers create a federation in which they offer/consume resources through a series of steps, service discovery, match making and authentication [16].


                              Sky computing. In this approach, multiple cloud providers offer multiple services, such as resources, applications and platforms. This architecture enables new value-added services through the composition of existing services with dynamic support to real-time demands. The key feature of sky computing is the transparency of a multiple-cloud environment. Specifically, this architecture provides an image of a single cloud with a seemingly infinite pool of accessible resources [17].

Thus, leading cloud service providers, such as Microsoft, have begun to develop architectures and investigate the challenges associated with multiple cloud services [12]. In an attempt to overcome these challenges, an agent-based approach to composing services in multi-cloud environments has been proposed [18]. Although empirical results have shown that this work might successfully compose services to satisfy service requirements in multiple-cloud environments, the multiagent distributed solutions are always associated with processing and communication overhead costs that limit their benefits [19]. In contrast to this distributed approach, three multiple-cloud service composition algorithms with a centralized control were proposed [2]. The first algorithm, which is referred to as the All Clouds Combination Algorithm, considers all clouds as inputs for the composition and enumerates all possible solutions. This method locates a service composition sequence in an execution time that is relatively short; however, it does not minimize the number of clouds in the final service composition sequence. The second algorithm, which is referred to as the Base Cloud Combination Algorithm, recursively enumerates all cloud combination possibilities until a composition solution is identified in a cloud combination. This method generates an optimal cloud combination with a small number of clouds; however, it requires substantial execution time. The third algorithm, which is referred to as the Smart Cloud Combination Algorithm, is designed to find a near-optimal cloud combination based on an approximation algorithm. This method identifies a sub-optimal cloud combination after searching for a service composition sequence at a reduced cost while utilizing a cloud-reduced set. This algorithm provides a near-optimal cloud combination but remains time consuming.

Based on the above survey, there are always tradeoffs between the execution time and the number of clouds in the last service composition sequence when multiple clouds are considered. In this case, the service composition obstacle is considered to be a combinatorial optimization problem of finding a suitable combination with a short execution time and with a minimal number of clouds. Minimizing the number of clouds is critical because services that are distributed in different clouds substantially increase communication costs and financial charges [2]. This paper proposes a novel COMbinatorial optimization algorithm for cloud service COMposition (COM2) that can efficiently compose services with small numbers of examined services and combined clouds. The proposed algorithm ensures that the cloud with the maximum number of services will be selected before clouds with fewer services are selected, which increases the possibility of fulfilling service requests with minimal overhead costs. When evaluating the COM2 using an experimental framework based on the default Web service test set provided in the OWL-S XPlan package [20], the results showed that the COM2 challenges the available multiple cloud service composition algorithms by achieving a superior tradeoff between the number of combined clouds and the number of examined services.

The remainder of this paper is organized as follows: Section 2 illustrates the system design, giving an example of how it works, while Section 3 describes the implementation and evaluation processes. The experimental results and discussion are presented in Sections 4 and 5, respectively. The paper is concluded in Section 6 by highlighting future research directions.

Most research has focused on service composition in a single cloud and limits the benefits received from other clouds that might have more suitable services [12]. This paper utilizes combinatorial optimization concepts to develop a novel method for service composition that employs multiple clouds, has a short execution time and requires a minimal number of clouds.

To solve the cloud service composition problem, a framework was developed and is illustrated in Fig. 1
                     . This framework has four main components.
                        
                           •
                           A multiple-cloud environment (MCE) is a set of clouds for which MCE={C
                              1, C
                              2,…,
                              C
                              c}. Each cloud contains a set of service files—F
                              ={F
                              1, F
                              2,…,
                              F
                              f}—and each service file contains a set of services—S
                              ={S
                              1, S
                              2,…,
                              S
                              s}. This structure is similar to the structure described in [2,20].

The user interface accepts a user’s request and displays the service composition sequence.

The cloud combiner selects the appropriate cloud set (the set that has the most suitable services to fulfill the user’s requests) and generates a cloud combination list based on the set.

The service composer receives the resulting cloud combination list from the cloud combiner and determines which services in each cloud set can best fulfill the user’s request. Based on the selection, the service composer produces the service composition sequence.

The user sends a request through the interface to the cloud combiner, which selects the appropriate cloud combination from the MCE based on the algorithm’s suggestion and returns it to the composer, as detailed below. The composer determines if the service sequence matches the user’s request, generates the final composition sequence and sends it to the user. The complete COM2 algorithm is illustrated in Algorithm 1.
                        
                           
                        
                     
                  

After the initializations shown in lines 5–7, the algorithm accepts the user’s request for a composite service in line 8 and generates a suggestion by selecting the first cloud that contains the largest number of services, as shown by line 9. For simplicity, we assumed that the clouds are sorted in descending order based on the number of service files. This sorting helps to rapidly identify the cloud with the greater number of service files. However, clouds rarely appear in such a sorted manner in real-life applications. Subsequently, the algorithm determines if any of the cloud files listed first can fulfill the user’s request, as demonstrated by lines 16–18. If no cloud files are identified, the next cloud is checked until an appropriate cloud is obtained; otherwise, the algorithm will terminate when the last cloud is reached, as shown in lines 19–24. Once an appropriate cloud is located, it is added to Combiner List B, and its service files are added to Composer List P, as demonstrated by lines 14–15. If the user request is not satisfied, the next cloud that contains new services and that can fulfill the user’s request is selected. To ensure that the selected cloud contains services that are not previously included in the Composer List, the algorithm subtracts the content of the Composer List from the new services in the selected cloud (C
                     n
                     ∩
                     R), as shown in lines 10–11. If new services are unavailable, the selected cloud is disregarded in line 12, and the next cloud on the list is considered. The entire process is repeated until the user’s request is fulfilled; the Combiner List is subsequently sent to the composer.

To facilitate a better understanding of the COM2, suppose that an MCE contains four clouds: MCE1={C
                     1, C
                     2, C
                     3, C
                     4}. The cloud service files and the number of services in each file are illustrated in Tables 1 and 2
                     , respectively. If the user’s requested service is R
                     ={F
                     1, F
                     2, F
                     4}, then the algorithm will begin by determining the number of files for each cloud. Because the cloud with the highest number of files is C
                     4, the algorithm will confirm whether any of its files can be used to fulfill the user’s request. Because (C
                     4
                     ∩
                     R)={F
                     1, F
                     2}, C
                     4 will be added to the Combiner List (to generate B
                     ={C
                     4}) and to the Composer List (P
                     ={F
                     1, F
                     2}). Because the Composer List still does not equal R, the cloud that contains the largest number of files after excluding C
                     4 from MCE1 will be selected, i.e., C
                     1. Because ((C
                     1
                     ∩
                     R)−
                     P)=Ø, C
                     1 will be ignored. C
                     2 and C
                     3 both contain the same number of files after excluding C
                     1 and C
                     4 from MCE1; as a result, either cloud can randomly be selected. Suppose that we select C
                     2. In this case, (C
                     2
                     ∩R)−
                     P
                     ={F
                     4}. Therefore, C
                     2 will be added to the Combiner List B
                     ={C
                     4, C
                     2}, and F
                     4 will be added to the Composer List P
                     ={F
                     1, F
                     2, F
                     4} (which equals R). The algorithm will then terminate after generating the Composition Sequence and sending it to the user. In this example, the number of services that were examined by the composer before generating the Composition Sequence |N| represents the total number of services in C
                     1, C
                     2 and C
                     3:
                        
                           
                              |
                              N
                              |
                              =
                              (
                              |
                              
                                 
                                    F
                                 
                                 
                                    1
                                 
                              
                              |
                              +
                              |
                              
                                 
                                    F
                                 
                                 
                                    2
                                 
                              
                              |
                              +
                              |
                              
                                 
                                    F
                                 
                                 
                                    3
                                 
                              
                              |
                              +
                              |
                              
                                 
                                    F
                                 
                                 
                                    5
                                 
                              
                              |
                              )
                              +
                              (
                              |
                              
                                 
                                    F
                                 
                                 
                                    1
                                 
                              
                              |
                              +
                              |
                              
                                 
                                    F
                                 
                                 
                                    2
                                 
                              
                              |
                              +
                              |
                              
                                 
                                    F
                                 
                                 
                                    3
                                 
                              
                              |
                              )
                              +
                              (
                              |
                              
                                 
                                    F
                                 
                                 
                                    4
                                 
                              
                              |
                              +
                              |
                              
                                 
                                    F
                                 
                                 
                                    5
                                 
                              
                              |
                              )
                              =
                              2
                              +
                              3
                              +
                              8
                              +
                              3
                              +
                              2
                              +
                              3
                              +
                              8
                              +
                              3
                              +
                              3
                              =
                              35
                              
                              service.
                           
                        
                     
                  

@&#EVALUATION@&#

To evaluate the COM2 and to obtain a better understanding of its performance, a previously developed MCE model [2] was adopted. Thus, we were able to find a ready and suitable implementation for the benchmark algorithms, the All Clouds Combination Algorithm, the Base Cloud Combination Algorithm and the Smart Cloud Combination Algorithm. Additionally, we maintained identical simulation parameters, which leads to a more robust evaluation methodology. The experimental data were based on the default Web service test set provided in the OWL-S XPlan package [20]. OWL-S XPlan is an open-source composition planner that converts OWL-S services to equivalent domain descriptions, which are specified in the planning domain description language (PDDL), and invokes an AI planner Xplan to generate a service composition plan sequence and a QoS-optimized execution plan. The OWL-S XPlan package considers a dynamic MCE that includes four clouds, MCE={C
                     1, C
                     2, C
                     3, C
                     4}, all of which have five service files, F
                     ={F
                     1, F
                     2, F
                     3, F
                     4, F
                     5}, and each of which has several services. The MCE settings and the number of services in each service file are illustrated in Tables 2 and 3
                     
                     , respectively. The service composition request R
                     ={F
                     1, F
                     2, F
                     3, F
                     4} was assumed for all scenarios.

Experiments were conducted using a Sony VAIO laptop with a 2.10GHz Intel Core 2 Duo processor and 1GB of RAM. Two performance measures were considered:
                        
                           •
                           The number of combined clouds |B|: the number of clouds involved in the combination cloud in the Combiner List.

The number of examined services |N|: the number of services that were checked by the service composer to be included in or excluded from the Composer List. Whereas the Service Composer List P contains only the services that can fulfill the user request, the list N holds all the checked services. The number of elements in this list is the main factor that is used to compute the execution time for the service composition. Thus, the number of elements is used as an execution time indication, as previously reported [1].

@&#RESULTS@&#

The results of the experiment are shown in Table 4
                     , which lists the number of clouds that are involved in the resulting composition sequence |B| and the number of examined services |N|. The data indicate that the COM2 algorithm successfully maintained a low number of examined services, which is directly related to execution time, while reducing the number of combined clouds compared to the other algorithms. The number of services examined |N| did not exceed 50, and the number of combined clouds was as low as two clouds in some cases and never exceeded three.


                     Fig. 2
                      graphically depicts the difference between these four algorithms in terms of the number of examined services. The proposed algorithm, COM2, achieved the best results in MCE1 and MCE5 and the second best results (after the All Cloud Algorithm) in MCE2 and MCE4. Although the All Cloud and Base Cloud Algorithms outperformed the COM2 algorithm in MCE3, the differences were minor.

With respect to the number of clouds that are involved in the final combination list |B|, Fig. 3
                      illustrates the differences in the four algorithms. The COM2 algorithm performed as well as the Base Cloud Algorithm, with the maximum margin of one cloud. Only two clouds were involved when the algorithm was performing at its best, and even at its worst, the algorithm involved as few as three clouds.


                     Table 5
                      shows the performance of the COM2 algorithm for each MCE in terms of the actual running time. The results are obtained based on a presorted list of clouds in decreasing order of the number of service files.

@&#DISCUSSION@&#

The results for the three benchmark algorithms, the All Clouds, the Base Cloud and the Smart Cloud, are all consistent with previously reported results [2], which was expected because we followed the same evaluation methodology and adopted the same cloud simulation model.

Comparing the COM2 to the three algorithms discussed above, the COM2 surpassed the Base Cloud and Smart Cloud algorithms in nearly all cases by a high margin with respect to the number of examined services |N|. Even at its worst, at 50 examined services, the COM2 still performed notably better than the Smart Cloud and Base Cloud algorithms did, whereby both of which had as many as 140 services (or more) in their worst cases. At its best, examining 30 and 35 services, the COM2 even outperformed the superior All Clouds algorithm, which examined 32 and 46 services in these cases. Additionally, although the All Clouds algorithm outperformed the other algorithms in the majority of scenarios in terms of the number of examined services, it exhibited the worst performance with respect to the number of combined clouds |B|, with as many as four clouds in most cases. This renders the All Clouds algorithm inefficient as a result of the high communication costs and financial charges between clouds.

With respect to the number of combined clouds, the number of clouds in the COM2 algorithm was similar to that of the Smart Cloud. This relationship can be attributed to the subtraction step (line 11 in Algorithm 1), which is common to both algorithms. Although the Base Cloud is the optimal algorithm insofar as the number of combined clouds is concerned, its superiority came at a high cost in terms of its execution time. The number of examined services for the Base Cloud reaches 3X the number of services examined by COM2. Thus, the COM2 algorithm achieved a substantial improvement in execution time compared with the available cloud service composition algorithms without compromising the number of combined clouds. The results in Table 5 confirm the reasonable execution time for COM2, which did not exceed 325s. in the worst scenario; the best scenario required an execution time of approximately 195s.

@&#CONCLUSIONS@&#

The objective of this paper was to develop an algorithm that could efficiently consider multiple clouds and perform service composition with a short execution time and minimal numbers of clouds, thereby reducing communication costs and financial charges. The proposed algorithm, COM2, ensures that the cloud with the maximum number of services will always be selected before other clouds, which increases the possibility of fulfilling service requests with minimal overhead.

The results of our study suggest that the COM2 algorithm retains a low number of combined clouds without compromising the number of examined services, which significantly affects execution time. This result arises from the fact that the possibility of finding all the services in one cloud is higher when the number of services in that particular cloud is high.

In future work, we intend to further investigate how COM2 performs in real-life scenarios and when QoS performance measures are considered. We also plan to utilize an ontology to improve the proposed algorithm; using an ontology has the potential to significantly improve the COM2, particularly when QoS measures are considered.

@&#ACKNOWLEDGMENTS@&#

This work was funded by the Long-Term Comprehensive National Plan for Science, Technology and Innovation of the Kingdom of Saudi Arabia, grant number 11-INF1895-08.

@&#REFERENCES@&#

