@&#MAIN-TITLE@&#A matheuristic for the truck and trailer routing problem

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Simple and effective two-phase matheuristic for the truck and trailer routing problem.


                        
                        
                           
                           Set-partitioning formulation of the truck and trailer routing problem.


                        
                        
                           
                           Hybrid GRASP×ILS fills a pool of columns for the set-partitioning formulation.


                        
                        
                           
                           Set-partitioning phase finds improved solutions in short time.


                        
                        
                           
                           The matheuristic outperforms previous state-of-the-art methods.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Vehicle routing problem

Truck and trailer routing problem (TTRP)

Matheuristic

Greedy randomized adaptive search procedure (GRASP)

Iterated local search (ILS)

Set-partitioning problem

@&#ABSTRACT@&#


               
               
                  In the truck and trailer routing problems (TTRPs) a fleet of trucks and trailers serves a set of customers. Some customers with accessibility constraints must be served just by truck, while others can be served either by truck or by a complete vehicle (a truck pulling a trailer). We propose a simple, yet effective, two-phase matheuristic that uses the routes of the local optima of a hybrid GRASP×ILS as columns in a set-partitioning formulation of the TTRP. Using this matheuristic we solved both the classical TTRP with fixed fleet and the new variant with unlimited fleet. This matheuristic outperforms state-of-the-art methods both in terms of solution quality and computing time. While the best variant of the matheuristic found new best-known solutions for several test instances from the literature, the fastest variant of the matheuristic achieved results of comparable quality to those of all previous method from the literature with an average speed-up of at least 2.5.
               
            

@&#INTRODUCTION@&#

In the last years a new generation of hybrid optimization methods known as matheuristics has emerged. Matheuristics combine elements of exact mathematical programming algorithms and metaheuristics in a cooperative way [5,33]. Traditionally, solution methods for vehicle routing problems (VRPs), and also for other combinatorial optimization problems, have been classified into three groups: exact methods [4], heuristics [35], and metaheuristics [26]. More recently, matheuristics appeared as a promising fourth alternative. According to Doerner and Schmid [17], matheuristics for VRPs follow three different principles: local branching, decomposition, and set-partitioning/set-covering formulations. In the last category, different set-partitioning/covering based methods have solved successfully many vehicle routing problems including the capacitated VRP [29,34,53], the VRP with time windows [1], a min–max selective VRP [2], the split-delivery VRP [3], a complex dial-a-ride problem with heterogeneous customers and vehicles [43], the periodic VRP with time windows [45,46], the (periodic) location-routing problem [47], the technician routing and scheduling problem [44], the VRP with stochastic demands [42], VRPs with heterogeneous fleet [61,59], and several extensions of the VRP with homogeneous fleet [60]. All these solution methods share the same principle: a metaheuristic generates diverse high quality columns for a given set-partitioning/set-covering formulation of the problem. Moreover, one of the best methods for the capacitated vehicle routing problem to date is the adaptive memory programming by Rochat and Taillard [53] that uses a set-partitioning problem as post-optimizer. Along the same line, in this paper we solve two variants of the truck and trailer routing problem (TTRP) with a matheuristic that combines a set-partitioning formulation with a hybrid metaheuristic.

This paper is organized as follows. Section 2 describes the TTRP and gives a literature review of the methods to solve it. Section 3 presents a set-partitioning formulation of the TTRP. Section 4 describes the elements of the proposed matheuristic. Section 5 reports results of computational experiments. Finally, Section 6 presents some conclusions and future research directions.

In the classical truck and trailer routing problem, originally introduced by Chao [12], a fixed fleet composed of m
                     
                        t
                      trucks and m
                     
                        r
                      trailers (m
                     
                        r
                     
                     <
                     m
                     
                        t
                     ) serves a set of customers (nodes) N
                     ={1,…,
                     n} from a main depot, denoted as node 0. Each customer i
                     ∈
                     N has a nonnegative demand q
                     
                        i
                     
                     >0; the capacities of the trucks and the trailers are Q
                     
                        t
                      and Q
                     
                        r
                     , respectively. The distance c
                     
                        ij
                      between any two nodes i, j
                     ∈
                     N
                     ∪{0} is known and the distances satisfy the triangle inequality. Some customers with limited maneuvering space or accessible through narrow roads must be served only by truck, while other customers can be served either by truck or by a complete vehicle (i.e., a truck pulling a trailer). These incompatibility constraints create a partition of N into two subsets: the subset of truck customers N
                     
                        t
                      accessible only by truck; and the subset of vehicle customers N
                     
                        v
                      accessible either by truck or by a complete vehicle. A distinguishing feature of the TTRP is that vehicle-customer locations can be used to park the trailer before serving truck customers. This possibility gives rise to complex routes with a main first-level trip and one or more second-level trips as shown in Fig. 1
                     . In sum, the objective of the TTRP is to find a set of routes of minimum total distance such that each customer is visited by a compatible vehicle; the total demand of the customers visited in a route does not exceed the capacity of the allocated vehicle; and the number of required trucks and trailers is not greater than m
                     
                        t
                      and m
                     
                        r
                     , respectively. Recently, Lin et al. [39] proposed the relaxed TTRP (RTTRP) where the limited-fleet constraint is dropped (i.e., m
                     
                        t
                     
                     =
                     m
                     
                        r
                     
                     =∞). These authors showed that important reductions on the total distance can be obtained by increasing the number of available trailers.

An important characteristic of the TTRP is that both the truck and the trailer have hauling capacity and goods can be transfered between the truck and the trailer en-route in the parking places of the trailer. By contrast, in some vehicle routing applications for waste collection [8] and container movements [62], tractors (without hauling capacity) move large trailers (or semi-trailers) between different customer locations and a central depot. In that case the trailers are so large that the tractor can only transport one trailer at a time. Bodin et al. [8] coined this problem as the rollon-rolloff vehicle routing problem (RRVRP). It is important to note that some authors (e.g., Tan et al. [62]) have classified their RRVRP applications within the TTRP literature.

Real-world applications of the TTRP appear in distribution and collection operations in rural areas and crowded cities. For instance, in several European countries, milk collection is performed by a small tanker with a removable tank trailer of larger capacity [11,22,31,32,63]. Some farms are not reachable by large vehicles, so the tank trailer needs to be detached on main roads before visiting them. Gerdessen [27] reported two other applications of vehicle routing problems with trailers in the Netherlands. The first application deals with the distribution of compound animal feed in rural regions, while the second one, emerges in the context of the distribution of dairy products. Early, Semet and Taillard [58] described a vehicle routing problem with trailers, time windows, site dependencies, and heterogeneous fleet arising in the distribution operations of a chain of grocery stores in Switzerland.

Most of the methods to solve the TTRP follow a natural cluster-first, route-second approach. For instance, Chao [12] proposed a tabu search that solves a relaxed generalized assignment problem (RGAP) to allocate customers to routes in a clustering phase, followed by an insertion heuristic that sequences customers within routes. A multi-neighborhood search embedded within a hybrid tabu search/deterministic annealing method improves the initial solution. Likewise, Scheuerer [56] used two cluster-first route-second constructive heuristics, called T-Sweep and T-Cluster, to find an initial solution that is later improved with tabu search. More recently, Caramia and Guerriero [10] presented a mathematical programming-based heuristic that solves two subproblems sequentially. First, the customer-route assignment problem (CAP) assigns customers to valid routes. Then, given the assignment of customers to routes, the route-definition problem (RDP) defines the sequence of each route. Yu et al. [71] proposed a two-stage approach where an ant colony system constructs feasible routes in the first stage, followed by improving 2-opt, swap, and insertion moves, in the second stage. Finally, Derigs et al. [16] customized a flexible metaheuristic framework [70] to implement two hybrid metaheuristics for the TTRP combining the attribute based high climber (ABHC) and record-to-record travel (RTR) with large neighborhood search (LNS). Savings and sweep heuristics produce initial solutions that are further improved using standard VRP moves as well as new TTRP-specific moves embedded within the hybrid metaheuristic framework.

In contrast, few researchers have tackled the TTRP with route-first, cluster-second methods. Lin et al. [38] developed a simple and effective simulated annealing that works on a permutation of the customers with dummy zeros as route separators, along with a vector of binary variables that indicate the type of vehicle used to serve each customer in N
                     
                        v
                     . More recently, Villegas et al. [66,67] solved the TTRP using a route-first, cluster-second procedure embedded within an evolutionary path relinking (EvPR), which is an emerging hybrid between greedy randomized adaptive search procedures (GRASP) and path relinking that provides high quality results [52]. Villegas et al. [68] presented a preliminary version of the method proposed in this paper, they obtained high quality results but at the price of very long and uncontrollable running times. Villegas [69] showed that route-first, cluster-second methods can be embedded in heuristics, metaheuristics and matheuristics for the solution of truck and trailer routing problems with single and multiple vehicles.

The TTRP has been extended in several ways. Scheuerer [55] presented a solution framework based on tabu search that allows modeling additional cost components, multiple depots, and a multi-day planning horizon. In the same vein, Lin et al. [40] added time-window constraints to the RTTRP giving rise to the RTTRP with time windows (RTTRPTW). Derigs et al. [16] tackled the TTRPTW and also introduced the so-called TTRP without load transfer. This later variant is motivated by real world applications where goods are not fluid or light, then en-route transferring of goods between trucks and trailers is not possible.

Similarly, Drexl [20] proposed the vehicle routing problem with trailers and transshipments (VRPTT), an extension of the TTRP with time windows, vehicle-dependent routing cost, and transshipment locations (i.e., special parking places different from customer locations where it is possible to transfer goods between trucks and trailers). An important feature of the VRPTT is that the fixed assignment of trailers to trucks is dropped. Then, in a feasible solution of the VRPTT a trailer can be attached to any compatible truck during its trip and any truck can transfer goods to any trailer. According to Drexl [22], the VRPTT can be used as a framework to model several vehicle routing problems with synchronization constraints. Recently, Drexl [21] introduced the generalized truck and trailer routing problem (GTTRP) and solved it using a branch-and-price method and a heuristic column generation. The GTTRP is derived from the VRPTT when a fixed assignment of trailers to trucks is considered. Computational experiments on real-world based instances of the GTTRP showed that only small problems with no more than 30 nodes can be solved to optimality using branch-and-price methods.

Other TTRP-related problems have been presented in the literature. In an early work, Semet [57] introduced the partial accessibility constrained vehicle routing problem (PACVRP). The PACVRP is a variant of the TTRP where each parking place for the trailer is restricted to have only one departing second-level trip (implicitly there is no transferring of goods between trucks and trailers). Similarly, Gerdessen [27] presented the vehicle routing problem with trailers (VRPT). The VRPT can be seen as a simplified TTRP where customers have unit demands and do not have accessibility restrictions, rather a longer service time is needed when a customer is visited by a complete vehicle.

Lately, Villegas et al. [64] introduced the single truck and trailer routing problem with satellite depots (STTRPSD) where a single truck with a detachable trailer based at a depot serves the demand of a set of customers accessible only by truck. Due to the accessibility restrictions, it is necessary to detach the trailer in proper parking places (called satellite depots) before serving the customers. Villegas et al. [65] solved the STTRPSD with a multi-start evolutionary local search and a GRASP in which the local search was replaced by a variable neighborhood descent (VND). This work was followed by Belenguer et al. [7] who developed an exact branch-and-cut algorithm for the STTRPSD based on a two-index vehicle flow formulation strengthened with several families of valid inequalities. Hoff and Løkketangen [31] and Hoff [32] described milk collection operations where routes have a STTRPSD structure. Similarly, vehicle routing problems where several deliverymen are assigned to each vehicle also have routes with a STTRPSD structure. Pureza et al. [49] reported the use of this strategy to reduce service times in the distribution of beverage and tobacco in highly-dense Brazilian urban areas.

The arc-routing equivalent of vehicle routing problems with trailers arises in the design of park-and-loop routes for postal delivery [36], where the postman drives a vehicle from the postal facility to parking locations, loads his sack, and delivers mail on foot; in this case the postman corresponds to the truck and his vehicle to the trailer. Along the same line, [37] presented a mail pickup and delivery problem that shares some elements with the TTRP. Waste collection in small cities and towns also has a similar structure. For instance, in Due Carrare (Italy) small collection vehicles serve narrow streets and large compactors collect waste on streets without accessibility restrictions. Since the disposal facility is far from the town, small collection vehicles meet large compactors in the middle of the routes to dump their contents avoiding long empty trips [15].

Finally, Gonzalez-Feliu [28], classified the TTRP as a variant of the multi-echelon location-routing problem (NE-LRP). The NE-LRP is a general modeling framework for distribution systems composed of N echelons where the vehicle routing problem between consecutive echelons is taken into account. As a summary, Table 1
                      presents a chronological list of TTRP-related publications.


                     Fig. 1 illustrates the three types of routes in a TTRP solution. Let Ω be the set of feasible routes in a TTRP. Let Γ
                     ⊆
                     Ω be the set of pure truck routes performed by trucks visiting customers in N
                     
                        t
                      and N
                     
                        v
                     ; let Ψ
                     ⊆
                     Ω be the set of pure vehicle routes performed by complete vehicles serving only customers in N
                     
                        v
                     ; and finally, let Π
                     ⊆
                     Ω be the set of vehicle routes with second-level trips. The routes in the latter set Π involve a first-level trip with the complete vehicle visiting customers in N
                     
                        v
                      and one or more second-level trips. In vehicle routes with second-level trips the trailer is detached at a vehicle customer location (in the first-level trip) to visit in second-level trips (performed only by the truck) one or more customers in N
                     
                        t
                      and probably some customers in N
                     
                        v
                     .

Let a
                     
                        ij
                      be a binary parameter that takes the value of 1 if customer i
                     ∈
                     N is visited in pure truck route j
                     ∈
                     Γ; it takes the value of 0, otherwise. Likewise, b
                     
                        ik
                      takes the value of 1 if customer i
                     ∈
                     N
                     
                        v
                      is visited in pure vehicle route k
                     ∈
                     Ψ; it takes the value of 0, otherwise; and e
                     
                        il
                      takes the value of 1 if customer i
                     ∈
                     N is visited in vehicle route with second-level trips l
                     ∈
                     Π; it takes the value of 0, otherwise. Define the binary variables x
                     
                        j
                      that takes the value of 1 if and only if route j
                     ∈
                     Γ is used in the solution of the TTRP; y
                     
                        k
                      that takes the value of 1 if and only if route k
                     ∈
                     Ψ is used; and z
                     
                        l
                      that takes the value of 1 if and only if route l
                     ∈
                     Π is included in the TTRP solution. Finally, c
                     
                        r
                      represents the cost (total distance) of any route r
                     ∈
                     Ω(=Γ
                     ∪
                     Ψ
                     ∪
                     Π). The TTRP formulated as a set-partitioning problem follows:
                        
                           (1)
                           
                              
                                 min
                              
                              
                              z
                              =
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       j
                                       ∈
                                       Γ
                                    
                                 
                              
                              
                                 
                                    c
                                 
                                 
                                    j
                                 
                              
                              
                                 
                                    x
                                 
                                 
                                    j
                                 
                              
                              +
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       k
                                       ∈
                                       Ψ
                                    
                                 
                              
                              
                                 
                                    c
                                 
                                 
                                    k
                                 
                              
                              
                                 
                                    y
                                 
                                 
                                    k
                                 
                              
                              +
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       l
                                       ∈
                                       Π
                                    
                                 
                              
                              
                                 
                                    c
                                 
                                 
                                    l
                                 
                              
                              
                                 
                                    z
                                 
                                 
                                    l
                                 
                              
                           
                        
                     
                     
                        
                           (2)
                           
                              Subject to:
                              
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       j
                                       ∈
                                       Γ
                                    
                                 
                              
                              
                                 
                                    a
                                 
                                 
                                    ij
                                 
                              
                              
                                 
                                    x
                                 
                                 
                                    j
                                 
                              
                              +
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       k
                                       ∈
                                       Ψ
                                    
                                 
                              
                              
                                 
                                    b
                                 
                                 
                                    ik
                                 
                              
                              
                                 
                                    y
                                 
                                 
                                    k
                                 
                              
                              +
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       l
                                       ∈
                                       Π
                                    
                                 
                              
                              
                                 
                                    e
                                 
                                 
                                    il
                                 
                              
                              
                                 
                                    z
                                 
                                 
                                    l
                                 
                              
                              =
                              1
                              ,
                              
                              ∀
                              i
                              ∈
                              
                                 
                                    N
                                 
                                 
                                    v
                                 
                              
                           
                        
                     
                     
                        
                           (3)
                           
                              
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       j
                                       ∈
                                       Γ
                                    
                                 
                              
                              
                                 
                                    a
                                 
                                 
                                    ij
                                 
                              
                              
                                 
                                    x
                                 
                                 
                                    j
                                 
                              
                              +
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       l
                                       ∈
                                       Π
                                    
                                 
                              
                              
                                 
                                    e
                                 
                                 
                                    il
                                 
                              
                              
                                 
                                    z
                                 
                                 
                                    l
                                 
                              
                              =
                              1
                              ,
                              
                              ∀
                              i
                              ∈
                              
                                 
                                    N
                                 
                                 
                                    t
                                 
                              
                           
                        
                     
                     
                        
                           (4)
                           
                              
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       j
                                       ∈
                                       Γ
                                    
                                 
                              
                              
                                 
                                    x
                                 
                                 
                                    j
                                 
                              
                              +
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       k
                                       ∈
                                       Ψ
                                    
                                 
                              
                              
                                 
                                    y
                                 
                                 
                                    k
                                 
                              
                              +
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       l
                                       ∈
                                       Π
                                    
                                 
                              
                              
                                 
                                    z
                                 
                                 
                                    l
                                 
                              
                              ⩽
                              
                                 
                                    m
                                 
                                 
                                    t
                                 
                              
                              ,
                           
                        
                     
                     
                        
                           (5)
                           
                              
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       k
                                       ∈
                                       Ψ
                                    
                                 
                              
                              
                                 
                                    y
                                 
                                 
                                    k
                                 
                              
                              +
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       l
                                       ∈
                                       Π
                                    
                                 
                              
                              
                                 
                                    z
                                 
                                 
                                    l
                                 
                              
                              ⩽
                              
                                 
                                    m
                                 
                                 
                                    r
                                 
                              
                              ,
                           
                        
                     
                     
                        
                           (6)
                           
                              
                              
                                 
                                    x
                                 
                                 
                                    j
                                 
                              
                              ∈
                              {
                              0
                              ,
                              1
                              }
                              ,
                              
                              ∀
                              j
                              ∈
                              Γ
                           
                        
                     
                     
                        
                           (7)
                           
                              
                              
                                 
                                    y
                                 
                                 
                                    k
                                 
                              
                              ∈
                              {
                              0
                              ,
                              1
                              }
                              ,
                              
                              ∀
                              k
                              ∈
                              Ψ
                           
                        
                     
                     
                        
                           (8)
                           
                              
                              
                                 
                                    z
                                 
                                 
                                    l
                                 
                              
                              ∈
                              {
                              0
                              ,
                              1
                              }
                              ,
                              
                              ∀
                              l
                              ∈
                              Π
                           
                        
                     
                  

The objective function (1) minimizes the total distance of the solution. The first term corresponds to the total distance of truck routes, the second term represents the total distance of pure vehicle routes, and the third term is the total distance of vehicle routes with second-level trips. Constraints (2) assure that each vehicle customer is visited exactly once; whereas, constraints (3) assure that each truck customer is visited exactly once by a truck route or in a second-level trip of a vehicle route with this type of trips. Constraints (4) and (5) impose an upper bound on the number of trucks and trailers used, respectively. The RTTRP [39] can be modeled just removing constraints (4) and (5).

Even though an alternative set-covering formulation is appealing because distances hold the triangle inequality, we kept the set-partitioning formulation (according to the original definition of the TTRP introduced by Chao [12]), to allow a more direct comparison with previously published results. Better but infeasible solutions (with respect to the classical TTRP definition) may arise from the fact that a vehicle customer may be visited more than once. The first time the customer is visited, it is served, and its location used as parking place for the trailer; while the next visits solely use the customer site as parking place for the trailer. In the latter case (if a set-covering formulation were used), the additional visits to the customer cannot be eliminated without changing the structure of the routes. Moreover, preliminary experiments indicated that the set-partitioning formulation is easier to solve for the optimizer.

Since the number of feasible routes is huge, using model (1)–(8) directly is often impractical. Moreover, the structure of vehicle routes with second-level trips entails a very complex pricing subproblem when TTRPs are solved using traditional column-generation or branch-and-price methods [21]. Therefore, we devised a heuristic that solves the set-partitioning problem over a subset of routes 
                        
                           
                              
                                 Ω
                              
                              
                                 ¯
                              
                           
                           =
                           
                              
                                 Γ
                              
                              
                                 ¯
                              
                           
                           ∪
                           
                              
                                 Ψ
                              
                              
                                 ¯
                              
                           
                           ∪
                           
                              
                                 Π
                              
                              
                                 ¯
                              
                           
                           ⊆
                           Ω
                        
                     , where 
                        
                           
                              
                                 Γ
                              
                              
                                 ¯
                              
                           
                           ⊆
                           Γ
                           ,
                           
                              
                                 Ψ
                              
                              
                                 ¯
                              
                           
                           ⊆
                           Ψ
                        
                     , and 
                        
                           
                              
                                 Π
                              
                              
                                 ¯
                              
                           
                           ⊆
                           Π
                        
                     . Contrary to classical column-generation and branch-and-price methods, in which a pricing subproblem is used iteratively to generate promising feasible routes [23], the proposed matheuristic follows a two-stage approach. In the first stage, a hybrid metaheuristic populates a pool of columns (routes) 
                        
                           
                              
                                 Ω
                              
                              
                                 ¯
                              
                           
                        
                      with the routes of the local optima visited during the search; then, in the second stage, we solve problem (1)–(8) over the reduced set of routes 
                        
                           
                              
                                 Ω
                              
                              
                                 ¯
                              
                           
                        
                      to produce a solution.

In this section, we present the two stages of the matheuristic. To make the paper self-contained we first outline the main components of the hybrid metaheuristic that populates the pool of routes 
                        
                           
                              
                                 Ω
                              
                              
                                 ¯
                              
                           
                        
                     . A detailed description can be found in Villegas et al. [67].

A GRASP is an iterative metaheuristic where a greedy randomized procedure generates diverse solutions that are improved using local search. The proposed hybrid method uses the GRASP×ILS approach introduced by Prins [48], where the improvement phase is replaced by an iterated local search (ILS) [41]. Recent reviews on GRASP hybridization [24,25,50] show that despite being effective, algorithms combining GRASP and exact methods (like the matheuristic proposed in this paper) are seldom studied. On the other hand, hybrid metaheuristics combining GRASP with path relinking [51] or with data mining [54] are the current state-of-the-art methods used to compensate the independence of GRASP iterations. The pool of columns used in the matheuristic can be seen as an alternative mechanism to tackle the memory-less criticism faced by the basic GRASP scheme.

The greedy randomized construction of GRASP×ILS follows the route-first, cluster-second principle [6]. A giant tour T that visits all customers in N is computed using a randomized version of the well-known nearest neighbor heuristic for the traveling salesman problem. Starting from the depot, each iteration adds one customer after the last node i of the emerging tour. The κ nearest and unrouted customers are determined and stored in a restricted candidate list (RCL), and one is randomly selected for the addition. Then, a solution S of the TTRP is derived from T
                           =(0,…,
                           t
                           
                              i
                           ,…,
                           t
                           
                              n
                           ,0) by means of a tour splitting procedure (hereafter labeled Split). The Split procedure constructs one auxiliary acyclic graph H
                           =(X, U, W), where the set of nodes X contains a dummy node 0 and n nodes numbered 1 through n, where node i represents the customer in the ith position of T. The arc set U contains arc (i
                           −1, j) if and only if the subsequence (t
                           
                              i
                           ,…,
                           t
                           
                              j
                           ) can be served by a feasible route. Finally, weight set W contains the weight w
                           
                              i−1,j
                            of arc (i
                           −1, j)∈
                           U, which is the total distance of the corresponding route. If the arc (i
                           −1, j) represents a vehicle route with second-level trips, its weight w
                           
                              i−1,j
                            is found via a dynamic programming method that solves a restricted version of the single truck and trailer routing problem with satellite depots (STTRPSD) [65,67]. Whereas for pure truck routes and pure vehicle routes the weight calculation is straightforward given their simple structure. The use of the STTRPSD as a subproblem to define the structure of vehicle routes with second-level trips allows solving other complex truck and trailer routing problems. For instance TTRPs where parking places do not coincide with vehicle-customer locations, as in the milk collection application described by Hoff and Løkketangen [31] and Hoff [32]. This case could be tackled just changing the structure of the STTRPSD solved in this step.

To derive a TTRP solution S from the giant tour T, Split finds the shortest path between nodes 0 and n in H. The cost of the shortest path corresponds to the total distance of S and the arcs in the shortest path represent its routes. The Split procedure takes into account the heterogeneous fixed fleet by solving a resource-constrained shortest-path problem (RCSPP), where the resources are the available trucks and trailers. Thanks to the acyclic structure of the auxiliary graph H, it is possible to solve in polynomial time the RCSPP with a labeling algorithm with several labels per node [67]. Table 2
                            presents the TTRP instance used in Fig. 2
                            to illustrate Split.

As shown in Fig. 2, the splitting problem for certain giant tours can be infeasible because of the limited number of available trucks and trailers. This is more frequent in instances with a tight ratio between the total demand and the total capacity. Hence, if for a given giant tour there is no feasible solution that uses at most m
                           
                              t
                            trucks and m
                           
                              r
                            trailers, Split determines the infeasibility. In that case, the limit on the number of trucks and trailers is dropped to obtain an infeasible solution via a classical Bellman’s Algorithm for (unconstrained) shortest-path problems in acyclic graphs [14]. For instance, in Fig. 2, giant tour T
                           2 is infeasible because m
                           
                              t
                           
                           =3 and there is no path connecting the first and last nodes of its auxiliary graph using at most 3 trucks. An (infeasible) solution using 4 trucks and 1 trailer can be still obtained when the size of the fleet is ignored. The infeasibility of the resulting solution is tackled later during the improvement phase. However, this infeasibility is not very serious for the global strategy since the main purpose of the GRASP×ILS phase is filling the pool of columns 
                              
                                 
                                    
                                       Ω
                                    
                                    
                                       ¯
                                    
                                 
                              
                            rather than solving the problem.

An ILS in which the local search has been replaced by a variable neighborhood descent (VND) [30] is in charge of the improvement phase of the hybrid metaheuristic that populates the route pool 
                              
                                 
                                    
                                       Ω
                                    
                                    
                                       ¯
                                    
                                 
                              
                           . Within the ILS phase, the search alternates between solutions and giant tours; the perturbation is performed on giant tours, while VND operates over TTRP solutions. Therefore, the simple procedure Concat creates a giant tour T from a solution S by concatenating its routes in a single string.

The proposed ILS tries to improve a solution S by performing iteratively four steps: (i) use procedure Concat to obtain a giant tour T from solution S; (ii) randomly exchange p pairs of customers from T to obtain a new giant tour T′ (Perturb); (iii) derive a new solution S′ by applying Split to T′; and (iv) apply a VND to S′. The ILS is repeated over ni iterations, and the perturbation parameter p is controlled dynamically between 1 and p
                           max.

The VND procedure explores sequentially the following five neighborhoods using a best-improvement strategy: Or-opt (in single routes), node exchange (in single routes and between pairs of routes), 2-opt (in single routes and between pairs of routes), node relocation (in single routes and between pairs of routes), and the root refining procedure for second-level trips described by Chao [12]. Feasibility test with respect to vehicle capacities and accessibility constraints are performed each time a move is evaluated. All these movements are guided by the solution cost and are not allowed to increase the number of trucks or trailers used in a given solution, only empty routes are deleted to decrease the number of trucks or trailers needed.

As has been done by other authors [38,56], in the improvement phase we allow initial infeasible solutions. When the initial solution is infeasible, ILS may visit infeasible solutions during the search. Then, the incumbent solution is replaced by S′ if f(S′)<
                           f(S) and its infeasibility 
                              
                                 Φ
                                 (
                                 
                                    
                                       S
                                    
                                    
                                       ′
                                    
                                 
                                 )
                                 =
                                 max
                                 
                                    
                                       
                                          0
                                          ,
                                          
                                             
                                                ut
                                                (
                                                
                                                   
                                                      S
                                                   
                                                   
                                                      ′
                                                   
                                                
                                                )
                                             
                                             
                                                
                                                   
                                                      m
                                                   
                                                   
                                                      t
                                                   
                                                
                                             
                                          
                                          -
                                          1
                                       
                                    
                                 
                                 +
                                 max
                                 
                                    
                                       
                                          0
                                          ,
                                          
                                             
                                                ur
                                                (
                                                
                                                   
                                                      S
                                                   
                                                   
                                                      ′
                                                   
                                                
                                                )
                                             
                                             
                                                
                                                   
                                                      m
                                                   
                                                   
                                                      r
                                                   
                                                
                                             
                                          
                                          -
                                          1
                                       
                                    
                                 
                              
                            does not exceed a given threshold μ, where f(S) denotes the objective function of S, and ut(S) and ur(S) the number of trucks and trailers used in S. At each call of ILS, μ is initialized at μ
                           max, and it is updated at each iteration with 
                              
                                 μ
                                 ←
                                 μ
                                 -
                                 
                                    
                                       
                                          
                                             μ
                                          
                                          
                                             max
                                          
                                       
                                    
                                    
                                       ni
                                    
                                 
                              
                           . With this threshold decreasing mechanism, ILS accepts infeasible solutions at the beginning of the search but tends to accept only feasible improving solutions as the search progresses. When solving the RTTRP all the fleet feasibility test are ignored.

The pool 
                           
                              
                                 
                                    Ω
                                 
                                 
                                    ¯
                                 
                              
                           
                         is populated during the GRASP×ILS phase with the routes of the local optima reached after each VND call. When inserting routes in 
                           
                              
                                 
                                    Ω
                                 
                                 
                                    ¯
                                 
                              
                           
                        , we do not check the feasibility of the underlying solution with respect to fleet-size constraints (4) and (5) because good routes may be part of infeasible solutions. Moreover, preliminary experiments indicated that this is an important mechanism to find high quality solutions in TTRP instances with a tight demand to capacity ratio. However, every time a route is inserted in 
                           
                              
                                 
                                    Ω
                                 
                                 
                                    ¯
                                 
                              
                           
                         we avoid duplicates. Therefore, to check if a route is already in the pool and to insert new routes efficiently, the pool is stored in a hash table [14].

In the second phase of the matheuristic we solve the set-partitioning model given in (1)–(8) over the set of routes stored in 
                           
                              
                                 
                                    Ω
                                 
                                 
                                    ¯
                                 
                              
                           
                        . Constraints (4) and (5) are removed in the case of the RTTRP. To reduce the running time of this phase, the best solution found by GRASP×ILS is used as initial upper bound in the branch-and-bound tree (if it is feasible). Since a given column does not specify the route it represents, it is necessary to record the structure of the route (i.e., type, sequence, and parking places for the trailer) associated with each column in the set-partitioning problem, so that we are able to reconstruct a solution from the set of optimal columns.


                        Algorithm 1 presents the proposed matheuristic. The main GRASP×ILS cycle (lines 3–32) stops after ns iterations or as soon as 
                           
                              |
                              
                                 
                                    Ω
                                 
                                 
                                    ¯
                                 
                              
                              |
                              ⩾
                              σ
                              ×
                              n
                           
                         (i.e., a fixed pool size is reached). At each main iteration, an initial solution for ILS is generated using the RandomizedNearestNeighbor procedure (line 4) followed by Split (line 5). This solution is improved by VND (line 6) and its routes are added to the pool 
                           
                              
                                 
                                    Ω
                                 
                                 
                                    ¯
                                 
                              
                           
                         (line 7). After updating the incumbent solution (lines 8–11), the ILS cycle (lines 13–30) improves the solution. The ILS cycle uses procedure Concat (line 14) to find a giant tour that is randomly modified with procedure Perturb (line 15). The new solution S′ obtained with Split (line 16) is then improved by the VND procedure (line 17). The routes of the resulting local optimum are added to the pool (line 18) (note that no feasibility check is performed to S′ when adding its routes to 
                           
                              
                                 
                                    Ω
                                 
                                 
                                    ¯
                                 
                              
                           
                        ). If the new solution has a better objective function and its infeasibility falls below the threshold μ the current solution of ILS is updated (lines 19–21). Likewise, lines 22–28 update the best feasible solution visited during the search, and control the value of p. When the best feasible solution is updated, p is reset to 1 to search in regions close to it (line 25). Whereas, when the best solution is not updated, p is increased to diversify the search (line 27). Finally, the second phase solves the set-partitioning problem over the routes in the pool 
                           
                              
                                 
                                    Ω
                                 
                                 
                                    ¯
                                 
                              
                           
                         and the columns of the optimal solution are used to reconstruct a new TTRP solution S
                        ∗ (line 33). A final improvement of the solution is explored with a VND post-optimization of S
                        ∗ in line 34.

We tested more sophisticated controls, such as a mechanism where GRASP×ILS is called iteratively to increase the size of the pool until the set-partitioning phase does not report any further improvement. A negligible improvement on the quality of the results were obtained but with a significant increase in the running time. Therefore, we decided to keep this simple yet powerful sequential scheme for the matheuristic. We also tried to simplify the management of infeasible solutions with a variant that ignores completely the fleet size constraints in the GRASP×ILS phase (i.e., solving a RTTRP) and then uses the set-partitioning problem to assemble a feasible solution for the TTRP. This alternative did not improve the performance of the method.
                           Algorithm 1
                           Matheuristic for TTRP
                                 
                                    
                                       
                                       
                                       
                                          
                                             
                                                Parameters: ns, σ, κ, ni, p
                                                
                                                   max
                                                , μ
                                                
                                                   max
                                                
                                             
                                             
                                          
                                          
                                             
                                                Output: S
                                                ∗
                                             
                                             
                                          
                                          
                                             1: f
                                                ∗
                                                ≔∞, 
                                                   
                                                      
                                                         
                                                            Ω
                                                         
                                                         
                                                            ¯
                                                         
                                                      
                                                      =
                                                      ∅
                                                   
                                                
                                             
                                             
                                          
                                          
                                             2: i
                                                ≔1
                                             
                                          
                                          
                                             3: repeat
                                             
                                             
                                          
                                          
                                             4: 
                                                T
                                                ≔
                                                RandomizedNearestNeighbor(N, κ)
                                             
                                          
                                          
                                             5: 
                                                S
                                                ≔
                                                Split(T)
                                             
                                          
                                          
                                             6: 
                                                S
                                                ≔
                                                VND(S)
                                             
                                          
                                          
                                             7: Update 
                                                   
                                                      
                                                         
                                                            Ω
                                                         
                                                         
                                                            ¯
                                                         
                                                      
                                                   
                                                 with the routes of S
                                             
                                             
                                          
                                          
                                             8: 
                                                
                                                
                                                if 
                                                f(S)<
                                                f
                                                ∗ and Φ(S′)=0 then
                                             
                                             
                                          
                                          
                                             9: 
                                                
                                                S
                                                ∗
                                                ≔
                                                S
                                             
                                             
                                          
                                          
                                             10: 
                                                f
                                                ∗
                                                ≔
                                                f(S)
                                             
                                          
                                          
                                             11: 
                                                end if
                                             
                                             
                                          
                                          
                                             12: 
                                                p
                                                ≔1, μ
                                                ≔
                                                μ
                                                max
                                             
                                             
                                          
                                          
                                             13: 
                                                for 
                                                j
                                                =1 to ni 
                                                do
                                             
                                             
                                          
                                          
                                             14: 
                                                T
                                                ≔
                                                Concat(S)
                                             
                                          
                                          
                                             15: 
                                                T′≔
                                                Perturb(T, p)
                                             
                                          
                                          
                                             16: 
                                                S′≔
                                                Split(T′)
                                             
                                          
                                          
                                             17: 
                                                S′≔
                                                VND(S′)
                                             
                                          
                                          
                                             18: Update 
                                                   
                                                      
                                                         
                                                            Ω
                                                         
                                                         
                                                            ¯
                                                         
                                                      
                                                   
                                                 with the routes of S′
                                             
                                          
                                          
                                             19: 
                                                if 
                                                f(S′)<
                                                f(S) and Φ(S′)⩽
                                                μ 
                                                then
                                             
                                             
                                          
                                          
                                             20: 
                                                
                                                S
                                                ≔
                                                S′
                                             
                                          
                                          
                                             21: 
                                                end if
                                             
                                             
                                          
                                          
                                             22: 
                                                if 
                                                f(S′)<
                                                f
                                                ∗ and
                                                Φ(S′)=0 then
                                             
                                             
                                          
                                          
                                             23: 
                                                
                                                S
                                                ∗
                                                ≔
                                                S′
                                             
                                          
                                          
                                             24: 
                                                
                                                f
                                                ∗
                                                ≔
                                                f(S′)
                                             
                                          
                                          
                                             25: 
                                                
                                                p
                                                ≔1
                                             
                                          
                                          
                                             26: 
                                                else
                                             
                                             
                                          
                                          
                                             27: 
                                                
                                                p
                                                ≔min{p
                                                +1, p
                                                max}
                                             
                                          
                                          
                                             28: 
                                                end if
                                             
                                             
                                          
                                          
                                             29: 
                                                
                                                   
                                                      μ
                                                      ≔
                                                      μ
                                                      -
                                                      
                                                         
                                                            
                                                               
                                                                  μ
                                                               
                                                               
                                                                  max
                                                               
                                                            
                                                         
                                                         
                                                            ni
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                          
                                          
                                             30: 
                                                end for
                                             
                                             
                                          
                                          
                                             31: 
                                                i
                                                ≔
                                                i
                                                +1
                                             
                                          
                                          
                                             32: until 
                                                
                                                   
                                                      |
                                                      
                                                         
                                                            Ω
                                                         
                                                         
                                                            ¯
                                                         
                                                      
                                                      |
                                                      >
                                                      σ
                                                      ×
                                                      n
                                                   
                                                 or i
                                                =
                                                ns
                                             
                                             
                                          
                                          
                                             33: S
                                                ∗
                                                ≔Solve the set-partitioning problem over the columns in the pool 
                                                   
                                                      
                                                         
                                                            Ω
                                                         
                                                         
                                                            ¯
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                          
                                          
                                             34: S
                                                ∗
                                                ≔
                                                VND(S
                                                ∗)
                                             
                                          
                                          
                                             35: return 
                                                S
                                                ∗
                                             
                                             
                                          
                                       
                                    
                                 
                              
                           

The performance of the proposed method was evaluated in two sets of instances available at the public website http://140.118.201.168/ttrp/. The first testbed introduced by Chao [12] comprises 7 problem sizes ranging from 50 to 199 customers and three different fractions of truck customers for each problem (25%, 50% and 75%), for a total of 21 test problems. These public test instances were derived by Chao [12] from 7 classical vehicle routing problems [13] using the following procedure: for each customer i
                        ∈
                        N, A
                        
                           i
                         denotes the distance to its nearest neighbor. The generation procedure sorts N in non-increasing order by A
                        
                           i
                         and creates three TTRP instances by defining the first 25%, 50%, and 75% of the nodes as truck customers. Given that the procedure to break ties when sorting the customers using A
                        
                           i
                         is unclear and the test problems are no longer available at the original website provided by Chao [12] a disambiguation is necessary: a detailed check of the coordinates of instances 16–21 of this testbed reveals that some customers have the x-coordinate changed from the original value reported in Christofides et al. [13] (customers 54, 56–60 on Problems 16–18, and customer 26 for Problems 19–21. This difference makes uncomparable the results from previous papers like Chao [12], Scheuerer [56], Caramia and Guerriero [10] and Villegas et al. [67] that used the original coordinates. On the contrary, Lin et al. [38] and Derigs et al. [16] used the modified data. To tackle this difficulty, we ran the method from Villegas et al. [67] on these modified data to update their results and used this testbed to evaluate the matheuristic proposed in this paper. It is important to note that the metaheuristics that will be used for the comparison remain as the best for the TTRP despite the inaccuracy discovered.

The second set of test instances was introduced originally for the RTTRP by Lin et al. [39] but also includes data to be solved for the limited fleet case (i.e., the TTRP). Lin et al. [39] derived these instances from 12 VRPs presented by Rochat and Taillard [53] following the procedure described previously. This testbed comprises 36 problems ranging from 75 to 150 customers.

We implemented the proposed matheuristic in Java (JRE V.1.7.05) and solved the set-partitioning problem with Gurobi version 5.0.1. After some experimentation the default parameters of Gurobi were tailored to make more aggressive the separation of clique cuts (this strategy turns out to be very effective in reducing the running time of Gurobi). Additionally, to avoid the slow convergence when closing the optimality gap, the set-partitioning phase was set to terminate with a time limit of 30minutes, the best integer solution found is reported when the set-partitioning problem is not solved to optimality.

All the experiments were performed on a computer with an Intel Core 2 Quad processor running at 2.66gigahertz under Windows 7 Enterprise Edition (64 bits) with 4gigabytes of RAM. In the experiments, distances between points were calculated using the Euclidean metric and were stored using double-precision real numbers without rounding. Results reported in the following sections were obtained with 10 runs of the method for each problem using 10 different seeds for the random number generator. For the sake of completeness, the best solutions found in all the experiment are available at http://hdl.handle.net/1992/1141.

Based on our previous experience, the GRASP×ILS phase of the matheuristic uses the same parameters as Villegas et al. [67] to control the greedy randomized construction (RCL cardinality, κ
                        =2) and the improvement phase (ILS iterations ni
                        =200, maximum number of pairs exchanged in the perturbation procedure p
                        max
                        =6, and initial infeasibility threshold μ
                        max
                        =0.25). Two variants of the matheuristic were tested. A version with a large pool of routes that runs GRASP×ILS for ns
                        =60 global iterations and σ
                        =∞ (i.e., without limits in the pool size), and a version with a small pool of columns that stops GRASP×ILS as long as σ
                        =200×
                        n different routes are generated.


                        Table 3
                         compares the proposed method with previous methods from the literature. This table includes the results of the simulated annealing (SA) by Lin et al. [38], the evolutionary path relinking (EvPR) by Villegas et al. [67], the best hybrid metaheuristic by Derigs et al. [16] (Hybrid ABHC), and the method proposed in this paper. The rows of Table 3 summarize the number of times that each method found the best-known solution (BKS), and the average and maximum gaps above BKS (in %). This table also reports the average and maximum computational times (in minutes) over 10 runs of the corresponding method for the TTRP (except for [16] that used five runs). To compensate the technology gaps between the computers used by Lin et al. [38] and this paper and those used by Villegas et al. [67] and Derigs et al. [16] the original average time was multiplied by a time factor obtained using the Linpack benchmark [18,19] and row Avg. scaled time reports these values. Detailed results used to obtain this and the next summary tables are reported in the Appendix.

This summary results show that both variants of the matheuristic outperforms all previous methods from the literature. The large-pool variant has a narrow average gap to BKS of 0.22% that is almost fourth the gap of EvPR and Hybrid ABHC (the previous best methods). Moreover, the large-pool variant of the matheuristic found 15 out of 21 BKS, and among them, 2 were new BKS. Remarkably, all these BKS were found with the standard set of parameters. On the contrary, most methods discovered BKS after running extensive computational experiments or while trying different sets of parameters [38,56,16]. Additionally, the small difference between the large-pool and small-pool variant proves the robustness of the matheuristic. Moreover the maximum gaps obtained by the matheuristic are smaller than those of the previous methods.

The small-pool variant stands as the second best method after the large-pool one, it has an average gap with respect to BKS better than those of EvPR and Hybrid ABHC, yet with shorter running times. While, the large-pool variant of the matheuristic has running times that are comparable to those of the other methods, the comparison of the scaled running times shows that the small-pool variant is roughly 3.5 and 2.5 times faster than EvPR and Hybrid ABHC, respectively. Fig. 3
                         illustrates better the good running time behavior of the small-pool variant. As it can be seen in this figure, its running time grows at a much slower rate (compared to the other methods) as the number of customers increases.


                        Table 4
                         presents the average size of the pool of columns generated in 10 runs of each variant of the matheuristic (
                           
                              |
                              
                                 
                                    Ω
                                 
                                 
                                    ¯
                                 
                              
                              |
                           
                        ). The ratio between them shows that the small-pool variant produces on average pools that are 42.8% smaller. This suggests two possible explanations for the good running time performance of the small-pool variant: (i) having a small pool requires less iterations of the GRASP×ILS and (ii) the resulting set-partitioning problem is easier thanks to the reduced number of columns.

In sum, the small-pool offers the best trade-off between running time and solution quality. Then, further experiments were performed with the small-pool variant of the matheuristic.


                        Table 5
                         summarizes the comparison of simulated annealing [38] and the small-pool variant on the second testbed using the same metrics of Table 3. In this experiment, the matheuristic provides a significant improvement in comparison to simulated annealing in terms of solution quality and running time: the average gap to BKS of the matheuristic is again under 0.5% with roughly half the average running time used by simulated annealing to obtain an average gap of 15.84%. Remarkably, all 36 best-known solutions were improved.

This final experiment evaluates the performance of the matheuristic in the RTTRP (i.e., the case with unlimited fleet). Since the fleet is unlimited the number of trucks and trailers used are decision variables, note however that the objective function optimized in all the components of the matheuristic (i.e., GRASP×ILS and set-partitioning) is still the total distance of the solution. As usual when the fleet is unlimited [9] (additionally to the metrics included previously) summary results now report the cumulative number of trucks and trailers used by the best solutions. Since the only available solution method for this problem is the simulated annealing by Lin et al. [39], Table 6
                         compares its performance with the results obtained by the small-pool variant of the matheuristic in the two testbeds. Again, the average gap to BKS of the matheuristic is below 0.5%, and in this case 53 out of 57 BKS were found by the matheuristic. By contrast simulated annealing obtained an average gap to BKS of 0.96% in the first testbed and 16.41% in the second one. However, with respect to the fleet size simulated annealing offers slightly better results, it needs less trucks in the testbed by Chao [12]. In the second testbed the matheuristic reduced the number of trucks by 5% with an increase in the number of trailers of only 0.27 % and found 36 out of 36 BKSs.

@&#CONCLUSIONS AND FUTURE WORK@&#

In this paper we presented a set-partitioning formulation of the TTRP embedded in a two-phase matheuristic. First, the matheuristic fills a pool of routes with the local optima obtained by a hybrid GRASP×ILS metaheuristic. Second, these routes become columns in a set-partitioning problem solved with a mixed integer programming optimizer. With this two-phase approach the performance of GRASP×ILS is clearly improved giving rise to a very effective matheuristic combining GRASP and mathematical programming. This method seems to be a very promising alternative to hybrid GRASP with path relinking methods since it is able to reduce the running time and the gap to best-known solutions when compared to hybrid metaheuristics that follow the evolutionary path relinking framework (which is the state-of-the-art in GRASP hybridization). In sum, the results of this paper revealed that using GRASP×ILS as a column generator for set-partitioning formulations is a promising line of research extensible to other vehicle routing problems.

Two variants of the proposed matheuristic were tested. On the one hand, the large-pool variant achieved results with narrow gaps to best-known solutions (0.22% on average) with running times comparable to other previous methods for the TTRP. On the other hand, the small-pool variant offers the best trade-off between solution quality and running time. It takes only one third of the time of the large-pool variant to obtain solutions with an average gap to best-known solutions that are below 0.5%. Moreover, a total of 38 out 57 BKS were improved by the matheuristic (2 out of 21 in the testbed by Chao [12] and all 36 in the testbed by Lin [37]).

The experiments on the RTTRP show that this approach solves successfully other variants of the TTRP. In this case, the only available method for this problem (a simulated annealing) was outperformed in terms of running time and solution quality. The small-pool variant obtains average gaps to best-known solutions below 0.4% compared to the average gap of simulated annealing which is 0.96% in the first testbed and 16.41% in the second one. Moreover, this results were obtained with an speed-up factor of at least 3 with respect to simulated annealing. Nevertheless, the understanding of the trade-off between the fleet size and the total distance remains unclear since the solution method was not specifically designed to tackle this component. The matheuristic was able to reduce the total distance of the best-known solutions in several cases but with an increase in the size of the fleet (more trucks or more trailers). Further studies which take into account this trade-off arise as a promising research direction in the TTRP field.

@&#ACKNOWLEDGMENTS@&#

We thank professor V. Fu for providing us their testbed and professor U. Derigs for solving some doubts we had about the test instances. We gratefully acknowledged the comments of two anonymous referees that helped to improve the paper.

The authors would also like to thank Gurobi Optimization Inc. for providing a free academic license of their optimizer and for the support in the customization of the parameters to improve its running time. Finally, this research was partially funded by the Champagne-Ardenne Regional Council (France) and by Colciencias (Colombia), this support is gratefully acknowledged.


                     Tables A.7 and A.8
                     
                      report the best (Best) and average (Avg.) cost over 10 runs for each method (except for Hybrid ABHC whose results correspond to only five runs) in each problem of the testbeds by Chao [12] and Lin et al. [39] respectively. Column Avg. Gap reports the average gap to the BKS. In Table A.7 column Ref. points to the reference that reported for the first time the BKS for each instance. The average running time in minutes is reported in column Time. Bottom summary rows count the number of BKS obtained by each method, the average and maximum gaps, and the average and maximum running times for each method. Additionally, column Name of Tables A.8 and A.10 points to the instance of Rochat and Taillard [53] used by Lin et al. [39] to construct the corresponding TTRP instance. The percentage of truck customers is given in the next column. Likewise, in Table A.8 the number of available trucks and trailers are given in the next two columns (labeled Trucks and Trailers respectively). In all tables, values in bold indicate that the BKS has been found by a given method.


                     Tables A.9 and A.10
                     
                      report the detailed results for the RTTRP. Columns Trucks and Trailers have a different meaning in these tables, they represent the number of trucks and trailers used by the BKS (with respect to total distance) obtained by each method. Underlined results for the matheuristic indicate a different composition of the fleet with respect to that of the best solutions found by simulated annealing. Summary rows now include the cumulative number of trucks and trailers used by the best solutions as additional metrics to asses the performance of a given method.

@&#REFERENCES@&#

