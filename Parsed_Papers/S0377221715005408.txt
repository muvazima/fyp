@&#MAIN-TITLE@&#Network repair crew scheduling and routing for emergency relief distribution problem

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We addressed the scheduling and routing of a repair crew after a disaster.


                        
                        
                           
                           We present a dynamic programming model that solves small/mid-sized problems.


                        
                        
                           
                           We develop a IGRCP procedure to solve large problem instances efficiently.


                        
                        
                           
                           Our work has societal impact as it helps to efficiently repair a network damaged by a disaster.


                        
                        
                           
                           Considering the routing of the repair crew makes the problem more realistic.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Network repair

Repair crew scheduling

Repair crew routing

Dynamic programming

Iterated greedy-randomized constructive procedure

@&#ABSTRACT@&#


               
               
                  Every year, hundreds of thousands of people are affected by natural disasters. The number of casualties is usually increased by lack of clean water, food, shelter, and adequate medical care during the aftermath. One of the main problems influencing relief distribution is the state of the post-disaster road network. In this paper, we consider the problem of scheduling the emergency repair of a rural road network that has been damaged by the occurrence of a natural disaster. This problem, which we call the Network Repair Crew Scheduling and Routing Problem addresses the scheduling and routing of a repair crew optimizing accessibility to the towns and villages that demand humanitarian relief by repairing roads. We develop both an exact dynamic programming (DP) algorithm and an iterated greedy-randomized constructive procedure to solve the problem and compare the performance of both approaches on small- to medium-scale instances. Our numerical analysis of the solution structure validates the optimization model and provides managerial insights into the problem and its solutions.
               
            

@&#INTRODUCTION@&#

Every year, hundreds of thousands of people are affected by natural disasters such as floods and earthquakes, especially in less developed regions of the planet (Guha-Sapir, Vos, Below, & Ponserre, 2011). An important observation, however, is that the number of casualties is usually increased by lack of clean water, food, shelter, and adequate medical care during the aftermath (PAHO, 2000). An adequate logistics reply to a disaster is therefore crucial. It has been conjectured that 80 percent of the disaster relief effort consists of logistics (Trunick, 2005). To a first approximation, therefore, disaster relief is logistics.

One of the main problems influencing the delivery of food, shelter, and medical supplies to affected regions is the state of the road network. In many situations, it is not a lack of supplies that kills people, but the impossibility to get those supplies to the people that need it. In Haiti, for example, extensive media coverage of the 2010 earthquake resulted in a large excess stock of relief supplies. However, distributing those supplies to the affected villages proved far more difficult as road infrastructure had been damaged or destroyed (Pedraza Martinez, Stapleton, & Van Wassenhove, 2010; Van Wassenhove, Martinez, & Stapleton, 2010). Further complicating the repair of the road network is the often limited availability of road repair capacity, especially in impoverished regions of the world. Therefore, it is crucial that road repair is planned and executed in the most efficient way possible.

In this paper, we consider the problem of scheduling and routing the emergency repair crew of a rural road network that has been damaged by the occurrence of a natural disaster. We call this problem the Network Repair Crew Scheduling and Routing Problem, abbreviated as NRCSRP. The NRCSRP addresses the scheduling and routing of a single repair crew, starting from a single depot, while optimizing accessibility to the towns and villages that demand humanitarian relief. Extending this work to more than one repair crew and more than one depot is left for future research.

The problem is defined on an undirected and connected graph 
                        
                           G
                           =
                           (
                           V
                           ,
                           E
                           )
                        
                      of which the nodes (
                        V
                     ) are either demand nodes (
                        
                           V
                           d
                        
                     ) or damaged nodes requiring repair (
                        
                           V
                           r
                        
                     ). (Note that without loss of generality, we represent a damaged road link by a node located in the middle of the corresponding edge. Therefore, repairing a road connection is equivalent to repairing a node, and we use the two terms interchangeably.) There is one supply node that corresponds to the location in which the relief supplies are positioned and from which the repair crew initially departs. This node is called the depot. Demand nodes correspond to locations (usually villages) that demand humanitarian relief. The importance of a village (node i) is represented by a demand, i.e., a weight factor wi
                     , that might, e.g., correspond to the number of inhabitants. Damaged (repair) nodes represent the locations where the work of the repair crew is needed. Such nodes have a repair time sj
                      (for node j) that represents the time the repair crew spends on its first visit. Without loss of generality, we do not distinguish between demand nodes and transshipment nodes, i.e., cross points where two or more roads come together, since such nodes can be modeled as demand nodes with zero demand. Each edge 
                        
                           
                              e
                              
                                 i
                                 j
                              
                           
                           ∈
                           E
                        
                      represents a road that connects two nodes 
                        
                           i
                           ,
                           j
                           ∈
                           V
                        
                     . A travel time tij
                      is defined for each edge eij
                      to represent the time it takes the repair crew to traverse it.

The aim of this problem is to determine the optimal sequence in which the crew should traverse the graph, starting from the depot node. Every time it encounters a damaged node that it has not visited before, it repairs the node and incurs the repair time of this node. On subsequent visits the crew can pass that node without incurring any additional time. When damaged nodes are repaired, demand nodes can become accessible. A demand node i is called accessible if there exists a path connecting this node to the depot that contains only undamaged and/or repaired nodes, and is not longer than a certain maximum distance Di
                     . The maximum distance Di
                      is node-specific and can be computed based on pre-disaster conditions (e.g., the distance between a demand node and the depot should not be more than twice the distance it was before the disaster). Thus, in addition to the travel time tij
                     , each edge eij
                      has a distance measure, denoted dij
                     , that is used to evaluate nodes’ accessibility.

For each demand node, the schedule of the crew determines the moment in time at which this node becomes accessible. The objective function of the problem is the sum of the moments at which each demand node becomes accessible weighted by the node demand wi
                     . The objective of the network repair problem is to determine the schedule and route of the repair crew that minimizes this objective function. In general, it is not necessary for the repair crew to visit all damaged nodes. Fig. 1 illustrates an example problem and solution for the NRCSRP with four damaged nodes.

The NRCSRP captures the most important aspects of the problem of routing a road repair crew in order to restore accessibility to demand points affected by damaged roads. To solve this problem, we develop two very different approaches. A dynamic programming (DP) model is able to find optimal solutions to small and medium-sized instances and provides insight into the fundamental structure of the problem. An efficient iterated greedy-randomized constructive procedure (IGRCP) is able to solve medium- to large-scale instances in very small computing times. A comparison of the performance of both approaches yields interesting insight into the underlying problem structure.

The problem of scheduling the repair operations in a post-disaster situation can be modeled in many different ways and the exact formulation of the NRCSRP is the result of several design choices. As mentioned, one of the main causes of human casualties is the fact that a disaster tends to disconnect remote population centers from the main supply hub. In poorer countries around the world, people are usually dependent on a very limited number of economic centers (usually larger cities) for sustenance. The demand nodes in the NRCSRP may therefore represent small villages or settlements, temporary medical facilities, shelters, or food distribution points. The supply node on the other hand will represent a city, an airport, or a port area where the relief goods arrive. When these demand points can no longer be reached by road from the supply point, the results are often dramatic. This is especially the case in rural areas, that lack the redundancy in the road network that characterizes cities. For this reason, the NRCSRP is explicitly defined on sparse networks, that are more common in rural than in urban situations, and the graphs underlying all generated test instances are sparse.

By explicitly considering the routing of the repair crew, the NRCSRP —unlike most previous contributions— adds a crucial time component that makes the problem more realistic and more suitable for real-life post-disaster situations. Like in real life, roads cannot be repaired until they can be reached by a repair crew. As mentioned, the objective function of the NRCSRP minimizes the demand-weighted moment in time at which all the demand nodes are connected to the supply node. The demand assigned to each demand node should be interpreted as a function of the importance of connecting this node, e.g., its population size. The objective function also takes the urgency of connecting the nodes into account, as even less important demand nodes (with small demand) may cause a large objective function increase when ignored for too long. In a sense, the NRCSRP models aspects of both the immediate response (routing of the repair crew) and the recovery (connecting the demand nodes as soon as possible) phases.

In a post-disaster immediate response situation, budget constraints are not usually a predominant issue, and the focus is on restoring connectivity of the affected regions with the limited physical means available. Nevertheless, an in-depth analysis of solutions produced by our solution approaches for the NRCSRP reveal interesting managerial results with considerable implications for further budgetary analysis. More specifically, our analysis shows that only a limited number of damaged nodes (around 30 percent) needs to be repaired in order to restore full accessibility. Additionally, when studying the optimal or best-known solutions, we observe that the repair operations have, on average, a diminishing rate of return, connecting a lot of demand in the beginning and much less demand at the end. However, this simple observation hides a large amount of variation, and cannot be compressed into some simple rule-of-thumb that could replace an efficient algorithm. Moreover, we are able to demonstrate the importance of planning the repair several stages ahead by comparing our results to a greedy myopic heuristic.

The remainder of this paper is organized as follows. The next section reviews the literature on related network repair problems. In Sections 3 and 4 we develop two radically different solution approaches for the NRCSRP: a dynamic programming method and an iterated greedy-randomized constructive procedure (IGRCP), respectively. Both approaches are compared in Section 5, and the strong and weak points of each method are exposed. Section 5 also contains an analysis of the structure of optimal or high-quality solutions and managerial insights obtained from the numerical results. Conclusions and suggestions for future research can be found in Section 6. A detailed list of symbols used in the paper can be found in Appendix A. For a mixed-integer linear programming formulation of the problem, which we had to forgo as an inefficient solution method, readers are referred to Maya Duque, Dolinskaya, and Sorensen (2014, Appendix).

@&#LITERATURE REVIEW@&#

In recent years, the field of Operations Research and Management Sciences (OR/MS) has turned its attention to disaster management and humanitarian logistics in a big way. As pointed out by authors such as Ergun, Karakus, Keskinocak, Swann, and Villarreal (2010) and Van Wassenhove (2003), this subject is growing in importance due to the positive impact that the efficient planning of resources in humanitarian situations and the application of OR/MS techniques can have on alleviating the consequences of a disaster. However, several authors agree that disaster management is a topic in which the OR/MS community still has to strengthen its critical mass. Moreover, Altay and Green (2006) and Ergun et al. (2010) highlight that disaster recovery, i.e., the planning of actions taken during the reconstruction phase, is one of the main areas in which more research is needed. A recent survey by Kunz and Reiner (2012) confirms that “only ten papers specifically address the reconstruction phase” and stresses the importance of this stage by stating that “the quality of the logistical activities during this phase strongly impacts the success of the whole disaster recovery process, especially in terms of sustainability and long-term effectiveness (Beamon & Balcik, 2008; Benson, Twigg, & Myers, 2001; Besiou, Stapleton, & Van Wassenhove, 2011; Kovács & Spens, 2011).” Several authors such as Ergun et al. (2010) and Sheu (2007) point out the need for comprehensive models that: integrate multiple stages of the disaster management process as a way to account for the interaction between the decisions made at different stages; are adaptive to incorporate new information when a change occurs, due to the fact that in a disaster framework, information is usually limited at the beginning, and as time passes, more and more accurate information becomes available. Similarly, Holguín-Veras, Pérez, Jaller, Wassenhove, and Aros-Vera (2013) highlight that single-period formulations cannot account for the inter-temporal effects due to the impacts of delivery actions that accrue over subsequent time periods. Therefore, there is a need for models that involve the timing in which the recovery actions are taken when evaluating the performance of this stage of the disaster management process.

The problem we address in this paper lies on the intersection of the aforementioned areas of research. It mainly focuses on the recovery phase but also touches on the immediate response phase. Therefore, it integrates different phases of the disaster management process as it considers the emergency recovery of the road network while capturing the urgency of repairing a road to facilitate the relief distribution. The objective function of our problem accounts for the temporal impact of the repair decisions which is neglected in classical single-period models. Three different decisions are taken into account, on different managerial levels: decide which damaged nodes have to be repaired; assign the various repair activities to a repair team in a certain order; determine the actual route or sequence of nodes to be visited by the repair crew. Most papers in the literature address the first or second group of decisions and do not take into account the additional constraints that might be needed when routing the repair crew(s), such as precedence constraints to ensure a connected path that allows to traverse the network and reach the damaged arcs. Only a handful of papers address the actual routing of the repair crews. However, these contributions rely on intricate approaches that are not easily scalable to larger problems.

Most of the papers that simultaneously tackle the three different decisions discussed here, use mathematical programming to formulate the network recovery problem. Due to the complexity of those models, they are usually tested only in few small sized instances or heuristic approaches are used to find good feasible solutions. Additionally, some of those papers take into account several objective functions which are, in general, handled through classical multi-objective methods such as weighted sum approaches and goal programming.


                     Chen and Tzeng (1999) consider the problem of scheduling and routing a set of work-troops in order to repair a set of damaged points scattered throughout a road-network after a large-scale earthquake. Their model consists of an upper level that schedules the work teams and a lower level that is an asymmetric traffic assignment model. Three objectives are considered, and a fuzzy genetic algorithm multi-objective approach is applied to solve the model heuristically. The approach is tested on a single small instance based on the Northridge earthquake (USA, 1994). Feng and Wang (2003) focus on the road network repair activities that occur over the first 72 hours after the disaster. The authors propose a multi-objective programming model that assigns the repair tasks to the work teams and defines the route to be followed by each team while maximizing the performance of the emergency road repair activities, maximizing the number of people that benefit from it, and minimizing the risk for rescue crews. A case study presenting the Chi-Chi earthquake is used to assess the model on a small instance involving disruptions in 6 out of 62 arcs. Yan and Shih (2009) propose a mathematical bi-objective model based on two time-space networks, one for the emergency repair and another for the relief distribution, which considers multiple commodities and minimizes the length of time required for both emergency roadway repair and relief distribution. In a later paper, Yan and Shih (2012) develop an ant colony system based algorithm to solve an emergency roadway repair time-space network flow problem, and apply the presented method to the Chi-Chi earthquake.

The papers that do not explicitly consider the routing of the repair crew usually focus on prioritizing the elements of the network that should be upgraded or repaired while considering interdependencies among related infrastructure and budget constraints. (For example, Brown and Vassiliou (1993) introduce a decision support system that relies on optimization, simulation and the decision maker input and allows for prioritization and interdependence between the tasks.) These papers often solve larger instances as some of the more complicating constraints (e.g., precedence constraints) are not needed.


                     Karlaftis, Kepaptsoglou, and Lambropoulos (2007) develop a methodology to optimally prioritize bridge repair in an urban transport network following a natural disaster. The resource allocation problem is formulated as a three-stage model, and a genetic algorithm is implemented to solve it. An instance considering 400 bridges in the surroundings of Athens is used to test the approach and to draw useful insights regarding the magnitude of repairs and necessary funds for repairing a bridge network following an unforeseen event. A multi-objective network optimization model is proposed by Matisziw, Murray, and Grubesic (2010) to facilitate identification and scheduling of potential recovery scenarios following disruptions involving substantial loss of network nodes and arcs. The network performance is optimized across a planning horizon restricted to the constraints on resources for recovery efforts. The developed model is applied to support recovery planning for a telecommunication backbone network, which differs from road networks in the sense that a constraint to enforce accessibility to the damaged nodes is not required. Cavdaroglu, Hammel, Mitchell, Sharkey, and Wallace (2013) consider the problem of restoring critical interdependent infrastructure after a non-routine event causes disruptions. The authors propose a mixed-integer program that integrates three different decisions: the set of components to be installed or repaired (i.e., restoration decisions), the assignment of selected components (tasks) to available work groups, and the order in which each work group will complete the tasks assigned to it. The latter set of decisions involves a network design phase that does not explicitly considers precedence constraints. The objective function of this problem measures how well the services are being restored over the horizon of the restoration plan. A heuristic solution method is proposed and tested on a data set that is a realistic representation of the power and telecommunication systems of a large portion of Manhattan.


                     Maya Duque and Sorensen (2011) consider the problem of allocating scarce resources to repair a rural road network after it has been damaged by a natural or man-made disaster in order to improve the accessibility to a set of vertices in a network. The authors propose a solution approach based on the GRASP and VNS metaheuristics that aims to maximize the accessibility of as many people as possible to the main cities or regional centers where the economic and social infrastructure is usually located. In Maya Duque, Coene, Goos, Sörensen, and Spieksma (2013) the study of the problem is extended to analyze the complexity of specific cases, propose a linear integer programming formulation and two heuristic solution approaches. The problem addressed lies on the strategic and tactical level but does not involve the operational level as the actual scheduling and routing of the upgrading work is not considered. Tuzun Aksu and Ozdamar (2014) focus on the planning of road restoration efforts during disaster response and recovery. The road restoration work is scheduled with the goal of maximizing the total weighted earliness of all cleared paths as a measure of the network accessibility for all locations in the area during the restoration process. The authors propose a dynamic path based mathematical model in which a set of access paths are defined for each node in the network and the union of these paths compose the total set of pre-defined access paths to be cleared. Liberatore, Ortuño, Tirado, Vitoriano, and Scaparra (2014) develop a hierarchical optimization model balancing a combination of objective functions associated with distribution of relief supplies in a post-disaster setting where damaged roads with reduced reliability are considered. Their model selects a set of damaged links to be repaired given a fixed budget.


                     Stilp, Ergun, and Kekinocak (2012) study a related problem of managing debris collection and disposal operations following a disaster. While their work addresses various stages of debris management operations, the so-called clearance problem with complete information, focusing on clearing out the roads immediately following a disaster, is the most relevant to our problem. The authors consider a multi-period problem on a network with a given subset of supply and demand nodes. A subset of network arcs are blocked by debris and have to be cleared to connect supply to demand. Maximum budget caps how much debris (and correspondingly, how many arcs) can be cleared each time period. The objective of the clearance problem is to minimize total penalty for unmet demand incurred each period. The problem is modeled using mixed integer programming and solved using both CPLEX and a set of dedicated heuristics. Unlike Stilp et al. (2012), we do not have discrete time periods, and our model captures the actual time it takes for a repair crew to reach a damaged point and to repair it, before the crew can move on to the next task. Therefore, our solution includes the explicit route of the repair crew in the time-spatial domain.

A number of classic optimization problems, such as prize collecting traveling salesman problem (Balas, 1989), the vehicle routing problem (e.g., Laporte, 1992; Toth and Vigo, 2002), the prize collecting Steiner tree problem (Goemans & Williamson, 1995), and the orienteering problem (Golden, Levy, & Vohra, 1987), also have similarities with our work, where damaged points in our problem correspond to “customers” to be visited to collect a “reward”. In this way, our problem can be thought of as an optimal routing problem between a subset of repair nodes. However, a number of significant distinctions between our problem and these classic optimization problems prevent the straightforward extension of existing solution approaches. First, our problem seeks to simultaneously find the repair schedule and the paths between the nodes to be repaired, since those two entities are interdependent. Furthermore, the order in which we visit the repair nodes has significant impact on the set of feasible paths between the nodes and on the “reward” collected when we visit them. Finally, the actual moment in time at which each node is repaired is also a factor in the total collected “reward”, equating it to a time-dependent setting. Also note that unlike the Steiner tree problem setting, a tree solution structure is suboptimal in most instances of our problem.

First, we outline our dynamic programming (DP) model in words, then provide the mathematical formulation of the problem, and finally discuss the implementation. For a list of symbols used see Appendix A. A MIP formulation of our problem is given in Maya Duque et al. (2014, Appendix), but a direct implementation of this model in a commercial MIP solver resulted in an intractable solution method even for small problem instances.

Our DP model keeps track of the repair crew as it repairs one node in 
                        
                           V
                           r
                        
                      after another, and makes sequential decisions on which node the crew should repair next. When a node is repaired, a subset of demand nodes that have not been accessible so far can become connected to the supply node, and a “cost” is incurred corresponding to the new satisfied demand weighted by the time when the connection is established. A constraint is implicitly included requiring to connect all demand nodes to the supply node, and the weighted time the algorithm connects all the nodes in 
                        
                           V
                           d
                        
                      corresponds to the cost that is being minimized. Thus, the state of our model needs to keep track of the current time and location of the repair crew, as well as the subset of damaged nodes that have not been yet repaired, and the subset of demand nodes that are not yet accessible from the depot. Our DP formulation requires an additional auxiliary node 
                        
                           n
                           +
                           1
                        
                      to be added to the graph. This node corresponds to a dummy depot connected to all the damaged nodes (i.e., nodes in 
                        
                           V
                           r
                        
                     ) through arcs with zero travel time. Note that the DP model explicitly tracks the crew as it moves from one repair node to the next, while the fastest feasible paths between the repair nodes are calculated at each state transition to compute the corresponding travel time. Finally, we assume that the DP state is updated after repair of the current node is completed.

Formally, this problem can be expressed as a dynamic programming model as follows.


                        DP state:
                        
                           
                              s
                              =
                              (
                              i
                              ,
                              t
                              ,
                              
                                 
                                    V
                                    ¯
                                 
                                 d
                              
                              ,
                              
                                 
                                    V
                                    ¯
                                 
                                 r
                              
                              )
                              ,
                           
                         where

                           
                              
                                 
                                    i
                                    ∈
                                    
                                       (
                                       
                                          V
                                          r
                                       
                                       ∖
                                       
                                          
                                             V
                                             ¯
                                          
                                          r
                                       
                                       )
                                    
                                    ∪
                                    
                                       {
                                       0
                                       }
                                    
                                    ∪
                                    
                                       {
                                       n
                                       +
                                       1
                                       }
                                    
                                 
                              
                           
                           
                              current repair node location of the crew,

current time,

demand nodes that are not yet accessible,

damaged nodes that are not yet repaired.


                        DP state transition: g(s, a) is the state transition function that returns a state to which the system transitions when action a is chosen in state s. That is, 
                           
                              s
                              =
                              
                                 (
                                 i
                                 ,
                                 t
                                 ,
                                 
                                    
                                       V
                                       ¯
                                    
                                    d
                                 
                                 ,
                                 
                                    
                                       V
                                       ¯
                                    
                                    r
                                 
                                 )
                              
                              
                                 ⟶
                                 
                                    (
                                    a
                                    =
                                    j
                                    )
                                 
                              
                              
                                 (
                                 
                                    i
                                    ′
                                 
                                 ,
                                 
                                    t
                                    ′
                                 
                                 ,
                                 
                                    
                                       V
                                       ¯
                                    
                                    d
                                    ′
                                 
                                 ,
                                 
                                    
                                       V
                                       ¯
                                    
                                    r
                                    ′
                                 
                                 )
                              
                              =
                              
                                 s
                                 ′
                              
                              ,
                           
                         where

                           
                              
                                 
                                    
                                       
                                          
                                             i
                                             ′
                                          
                                       
                                       
                                          =
                                       
                                       
                                          
                                             j
                                             ,
                                          
                                       
                                    
                                    
                                       
                                          
                                             t
                                             ′
                                          
                                       
                                       
                                          =
                                       
                                       
                                          
                                             t
                                             +
                                             τ
                                             
                                                (
                                                i
                                                ,
                                                j
                                                ,
                                                
                                                   
                                                      V
                                                      ¯
                                                   
                                                   r
                                                
                                                )
                                             
                                             +
                                             
                                                s
                                                j
                                             
                                             ,
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                V
                                                ¯
                                             
                                             d
                                             ′
                                          
                                       
                                       
                                          =
                                       
                                       
                                          
                                             
                                                
                                                   V
                                                   ¯
                                                
                                                d
                                             
                                             ∖
                                             v
                                             
                                                (
                                                
                                                   
                                                      V
                                                      ¯
                                                   
                                                   d
                                                
                                                ,
                                                
                                                   
                                                      V
                                                      ¯
                                                   
                                                   r
                                                
                                                ,
                                                j
                                                )
                                             
                                             ,
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                V
                                                ¯
                                             
                                             r
                                             ′
                                          
                                       
                                       
                                          =
                                       
                                       
                                          
                                             
                                                
                                                   V
                                                   ¯
                                                
                                                r
                                             
                                             ∖
                                             
                                                {
                                                j
                                                }
                                             
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        
                     

Here, 
                           
                              v
                              
                                 (
                                 s
                                 ,
                                 a
                                 )
                              
                              =
                              v
                              
                                 (
                                 
                                    
                                       V
                                       ¯
                                    
                                    d
                                 
                                 ,
                                 
                                    
                                       V
                                       ¯
                                    
                                    r
                                 
                                 ,
                                 j
                                 )
                              
                           
                         is an accessibility function that returns a subset of nodes in 
                           
                              
                                 V
                                 ¯
                              
                              d
                           
                         that become accessible when node 
                           
                              j
                              ∈
                              
                                 
                                    V
                                    ¯
                                 
                                 r
                              
                           
                         is repaired. Note that 
                           
                              v
                              (
                              
                                 
                                    V
                                    ¯
                                 
                                 d
                              
                              ,
                              
                                 
                                    V
                                    ¯
                                 
                                 r
                              
                              ,
                              j
                              )
                           
                         can return an empty set when no new nodes are connected to the supply node by repairing node j. A set of shortest (distance) path problems on the updated network (where node j can be passed without incurring the repair cost) needs to be solved in order to evaluate v(.). An efficient way to do so is discussed later in this section.


                        DP action cost: c(s, a) is the instantaneous cost of action a when in state s, where for 
                           
                              s
                              =
                              (
                              i
                              ,
                              t
                              ,
                              
                                 
                                    V
                                    ¯
                                 
                                 d
                              
                              ,
                              
                                 
                                    V
                                    ¯
                                 
                                 r
                              
                              )
                           
                         and 
                           
                              a
                              =
                              j
                           
                         we have

                           
                              (1)
                              
                                 
                                    c
                                    
                                       (
                                       i
                                       ,
                                       t
                                       ,
                                       
                                          
                                             V
                                             ¯
                                          
                                          d
                                       
                                       ,
                                       
                                          
                                             V
                                             ¯
                                          
                                          r
                                       
                                       ,
                                       j
                                       )
                                    
                                    =
                                    
                                       (
                                       t
                                       +
                                       τ
                                       
                                          (
                                          i
                                          ,
                                          j
                                          ,
                                          
                                             
                                                V
                                                ¯
                                             
                                             r
                                          
                                          )
                                       
                                       +
                                       
                                          s
                                          j
                                       
                                       )
                                    
                                    ·
                                    
                                       ∑
                                       
                                          k
                                          ∈
                                          v
                                          (
                                          
                                             
                                                V
                                                ¯
                                             
                                             d
                                          
                                          ,
                                          
                                             
                                                V
                                                ¯
                                             
                                             r
                                          
                                          ,
                                          j
                                          )
                                       
                                    
                                    
                                       w
                                       k
                                    
                                    ,
                                 
                              
                           
                        
                     


                        Recursive equation: Let f(s) denote the minimum cost incurred by the system reaching from the initial state 
                           
                              
                                 s
                                 0
                              
                              =
                              
                                 (
                                 0
                                 ,
                                 0
                                 ,
                                 
                                    V
                                    d
                                 
                                 ,
                                 
                                    V
                                    r
                                 
                                 )
                              
                           
                         to the current state 
                           
                              s
                              =
                              (
                              i
                              ,
                              t
                              ,
                              
                                 
                                    V
                                    ¯
                                 
                                 d
                              
                              ,
                              
                                 
                                    V
                                    ¯
                                 
                                 r
                              
                              )
                           
                        . Then, we can write the following dynamic programming (Bellman’s) recursive equation:

                           
                              (2)
                              
                                 
                                    f
                                    
                                       (
                                       
                                          s
                                          ′
                                       
                                       )
                                    
                                    =
                                    
                                       min
                                       
                                          {
                                          s
                                          ,
                                          
                                          s
                                          .
                                          t
                                          .
                                          ,
                                          
                                          g
                                          
                                             (
                                             s
                                             ,
                                             a
                                             )
                                          
                                          =
                                          
                                             s
                                             ′
                                          
                                          ,
                                          
                                          a
                                          ∈
                                          A
                                          
                                             (
                                             s
                                             )
                                          
                                          }
                                       
                                    
                                    
                                       {
                                       f
                                       (
                                       s
                                       )
                                       +
                                       c
                                       (
                                       s
                                       ,
                                       a
                                       )
                                       }
                                    
                                    ,
                                 
                              
                           
                        where 
                           
                              f
                              (
                              
                                 s
                                 0
                              
                              )
                              =
                              0
                           
                        . Recursively solving Eq. (2) we find the minimum value for

                           
                              
                                 
                                    
                                       min
                                       
                                          {
                                          s
                                          =
                                          
                                             (
                                             i
                                             ,
                                             t
                                             ,
                                             
                                                
                                                   V
                                                   ¯
                                                
                                                d
                                             
                                             ,
                                             
                                                
                                                   V
                                                   ¯
                                                
                                                r
                                             
                                             )
                                          
                                          ,
                                          
                                          s
                                          .
                                          t
                                          .
                                          ,
                                          
                                          i
                                          =
                                          n
                                          +
                                          1
                                          }
                                       
                                    
                                    f
                                    
                                       (
                                       s
                                       )
                                    
                                    ,
                                 
                              
                           
                        which corresponds to the minimum value of our problem objective function.


                        Accessibility function: Recall, 
                           
                              v
                              
                                 (
                                 s
                                 ,
                                 a
                                 )
                              
                              =
                              v
                              
                                 (
                                 
                                    
                                       V
                                       ¯
                                    
                                    d
                                 
                                 ,
                                 
                                    
                                       V
                                       ¯
                                    
                                    r
                                 
                                 ,
                                 j
                                 )
                              
                           
                         is an accessibility function that returns a subset of nodes in 
                           
                              
                                 V
                                 ¯
                              
                              d
                           
                         that become accessible when node 
                           
                              j
                              ∈
                              
                                 
                                    V
                                    ¯
                                 
                                 r
                              
                           
                         is repaired. This function can be efficiently evaluated as follows.

First, let 
                           
                              G
                              
                                 (
                                 
                                    
                                       V
                                       ¯
                                    
                                    r
                                 
                                 )
                              
                              ⊆
                              G
                              =
                              
                                 (
                                 V
                                 ,
                                 E
                                 )
                              
                              ,
                           
                         be a modified network where the nodes of 
                           
                              
                                 V
                                 ¯
                              
                              r
                           
                         and the arcs adjacent to nodes in 
                           
                              
                                 V
                                 ¯
                              
                              r
                           
                         are omitted from the original graph 
                           G
                        . This accounts for the fact that the demand nodes cannot be connected to the supply node through the damaged nodes that have not been yet repaired. Then, observe that a previously unaccessible demand node 
                           
                              k
                              ∈
                              
                                 
                                    V
                                    ¯
                                 
                                 d
                              
                           
                         becomes accessible when node 
                           
                              j
                              ∈
                              
                                 
                                    V
                                    ¯
                                 
                                 r
                              
                           
                         is repaired if and only if there is a path from k to the depot node (node 0) in network 
                           
                              G
                              (
                              
                                 
                                    V
                                    ¯
                                 
                                 r
                              
                              ∖
                              
                                 {
                                 j
                                 }
                              
                              )
                           
                         that is not longer than Dk
                         and passes through node j. If there was a path from k to 0 that is not longer than Dk
                         and does not pass through node j, then that node would have been accessible prior to repairing node j, i.e., it would not have been in 
                           
                              
                                 V
                                 ¯
                              
                              d
                           
                        . Thus, to evaluate the accessibility function 
                           
                              v
                              (
                              
                                 
                                    V
                                    ¯
                                 
                                 d
                              
                              ,
                              
                                 
                                    V
                                    ¯
                                 
                                 r
                              
                              ,
                              j
                              )
                              ,
                           
                         we find the shortest distance path from each node in the set 
                           
                              
                                 V
                                 ¯
                              
                              d
                           
                         to node j and then add the shortest distance from j to 0 in network 
                           
                              G
                              (
                              
                                 
                                    V
                                    ¯
                                 
                                 r
                              
                              ∖
                              
                                 {
                                 j
                                 }
                              
                              )
                           
                        . For each node 
                           
                              k
                              ∈
                              
                                 
                                    V
                                    ¯
                                 
                                 d
                              
                           
                         that has the sum of the two distances less than or equal to Dk
                        , repairing node j would connect that node to the supply node, and the accessibility function v(.) returns a set of those nodes.

Note that the algorithm has to evaluate 
                           
                              v
                              (
                              
                                 
                                    V
                                    ¯
                                 
                                 d
                              
                              ,
                              
                                 
                                    V
                                    ¯
                                 
                                 r
                              
                              ,
                              j
                              )
                           
                         for all 
                           
                              j
                              ∈
                              
                                 
                                    V
                                    ¯
                                 
                                 r
                              
                              ,
                           
                         each of which would require to find a minimum path from j to all the nodes in 
                           
                              
                                 V
                                 ¯
                              
                              d
                           
                        . We can improve the implementation efficiency by intelligently sequencing these operations. To this end, the algorithm uses Dijkstra’s algorithm, which efficiently finds a minimum cost path in a static network from one node to all other nodes. At each iteration of our dynamic programming functional Eq. (2), we implement Dijkstra’s algorithm on 
                           G
                         where every node in 
                           
                              
                                 V
                                 ¯
                              
                              r
                           
                         is terminal. That is, as soon as the algorithm reaches one of the nodes that have not been previously repaired (i.e., in set 
                           
                              
                                 V
                                 ¯
                              
                              r
                           
                        ), the paths are not allowed to continue through that node. Thus, we find a shortest path from supply node 0 to all nodes in 
                           
                              
                                 
                                    V
                                    ¯
                                 
                                 r
                              
                              ,
                           
                         and let βj
                         for 
                           
                              j
                              ∈
                              
                                 
                                    V
                                    ¯
                                 
                                 r
                              
                           
                         denote such distance. Then, for each 
                           
                              j
                              ∈
                              
                                 
                                    V
                                    ¯
                                 
                                 r
                              
                           
                         such that 
                           
                              
                                 β
                                 j
                              
                              ≤
                              
                                 max
                                 
                                    k
                                    ∈
                                    
                                       
                                          V
                                          ¯
                                       
                                       d
                                    
                                 
                              
                              
                                 D
                                 k
                              
                           
                         we find a shortest path in network 
                           
                              G
                              (
                              
                                 
                                    V
                                    ¯
                                 
                                 r
                              
                              ∖
                              
                                 {
                                 j
                                 }
                              
                              )
                           
                         from j to all nodes in 
                           
                              
                                 
                                    V
                                    ¯
                                 
                                 d
                              
                              ,
                           
                         and let δjk
                         for 
                           
                              k
                              ∈
                              
                                 
                                    V
                                    ¯
                                 
                                 d
                              
                           
                         denote such distance. Then, 
                           
                              v
                              
                                 (
                                 
                                    
                                       V
                                       ¯
                                    
                                    d
                                 
                                 ,
                                 
                                    
                                       V
                                       ¯
                                    
                                    r
                                 
                                 ,
                                 j
                                 )
                              
                              =
                              
                                 {
                                 k
                                 ∈
                                 
                                    
                                       V
                                       ¯
                                    
                                    d
                                 
                                 ,
                                 
                                 s.t.
                                 ,
                                 
                                 
                                    β
                                    j
                                 
                                 +
                                 
                                    δ
                                    
                                       j
                                       k
                                    
                                 
                                 ≤
                                 
                                    D
                                    k
                                 
                                 }
                              
                           
                        . Observe, that our dynamic programming model requires solving a set of smaller dynamic programming models (shortest paths from node 0 to nodes in 
                           
                              
                                 V
                                 ¯
                              
                              d
                           
                         on a partially repaired network) to evaluate the cost associated with each decision in the action space.

@&#IMPLEMENTATION@&#

There are a number of observations and problem structure properties we use to facilitate efficient implementation of the DP model.

To initialize the DP recursive equation, the algorithm preprocesses the problem instance to find a more compact initial state than 
                              
                                 
                                    s
                                    0
                                 
                                 =
                                 
                                    (
                                    0
                                    ,
                                    0
                                    ,
                                    
                                       V
                                       d
                                    
                                    ,
                                    
                                       V
                                       r
                                    
                                    )
                                 
                              
                           . We note that in a given instance, a number of demand nodes can maintain their accessibility despite the damage to the road network, and s
                           0 does not need to include all the nodes in 
                              
                                 V
                                 d
                              
                           . Thus, a shortest path algorithm is run on the damaged network (i.e., no nodes in 
                              
                                 V
                                 r
                              
                            are assumed to be repaired) to find the minimum distance between the supply node 0 and all the demand nodes. Then, the distances found are compared to the values of Di
                           ’s, and nodes in 
                              
                                 V
                                 d
                              
                            that are already accessible are omitted from the initial state s
                           0. In addition, the demand nodes with 
                              
                                 
                                    w
                                    i
                                 
                                 =
                                 0
                              
                            are omitted, since these nodes correspond to transshipment (intersection) nodes and, regardless of their accessibility status, do not contribute to the value of the objective function.

The cost function defined in Eq. (1) assigns a positive value to an action corresponding to repairing a damaged node that connects new demand nodes to the supply and a zero value when a repair action does not establish accessibility for any demand nodes. When a network is severely damaged requiring to repair multiple nodes to improve accessibility, our DP state network has a significant number of action arcs correspond to zero cost, and only a small subset of actions has value larger than zero. Implementation of minimum cost algorithms on such networks is inefficient since a lot of actions and nodes have identical values (i.e., equal contribution to the objective function). To facilitate more efficient implementation of the DP model, we redefine the cost function as follows,

                              
                                 (3)
                                 
                                    
                                       
                                          c
                                          ′
                                       
                                       
                                          (
                                          i
                                          ,
                                          t
                                          ,
                                          
                                             
                                                V
                                                ¯
                                             
                                             d
                                          
                                          ,
                                          
                                             
                                                V
                                                ¯
                                             
                                             r
                                          
                                          ,
                                          j
                                          )
                                       
                                       =
                                       
                                          (
                                          τ
                                          
                                             (
                                             i
                                             ,
                                             j
                                             ,
                                             
                                                
                                                   V
                                                   ¯
                                                
                                                r
                                             
                                             )
                                          
                                          +
                                          
                                             s
                                             j
                                          
                                          )
                                       
                                       ·
                                       
                                          ∑
                                          
                                             k
                                             ∈
                                             
                                                
                                                   V
                                                   ¯
                                                
                                                d
                                             
                                          
                                       
                                       
                                          w
                                          k
                                       
                                       .
                                    
                                 
                              
                           Thus, Eq. (3) assigns a cost of going from node i to node j equal to the penalty accrued during that move (plus repair time at node j) for all the demand nodes that have not been accessible at that time. Then, the original recursive Eq. (2) is solved while substituting cost function c(.) with the new cost function c′(.). Observe that the modified formulation results in exactly the same objective function value, the only difference being how we sum the cost: all at once at the time of connecting a demand node to the supply (1), or progressively as crew moves along the path (3).

Due to the limitation on the size of problems that can be solved by our DP model, we present an alternative approach to tackle the NRCSRP: an iterated greedy-randomized constructive procedure. IGRCP is motivated by a GRASP (greedy randomized adaptive search procedure), a constructive metaheuristic introduced by Feo and Resende (1995) that generally consists of two phases: construction of a feasible solution and improvement of the constructed solution. Both phases are usually iterated several times, after which the best solution is reported. The construction phase uses a controlled amount of randomness in order to overcome the myopic behavior of a greedy constructive heuristic. The improvement phase uses, in most cases, a local search strategy that iteratively improves the initial solution by making small changes to it. IGRCP also consists of the construction and improvement phases, but unlike GRASP, we do not iterate between them, since our construction phase does not depend on the solution found in previous iterations. Instead, we implement multiple runs of the construction plus improvement routine. Due to the random nature of the algorithm, this multistart approach might return different solutions, which we compare and analyze later in the paper.

In Section 4.1, we present a set of basic definitions for our IGRCP solution approach. The construction phase is described in Section 4.2, while the improvement phase is presented in Section 4.3. Finally, the technical details related to the implementation are discussed in Section 4.4.

We consider the undirected and connected graph 
                           
                              G
                              =
                              (
                              V
                              ,
                              E
                              )
                           
                         that defines the NRCSRP, introduced in Section 1, and refer to it as the original graph. Additionally, we define a reduced graph
                        
                           
                              
                                 G
                                 0
                                 ′
                              
                              =
                              
                                 (
                                 
                                    V
                                    0
                                    ′
                                 
                                 ,
                                 
                                    E
                                    0
                                    ′
                                 
                                 )
                              
                              ,
                           
                         in which only the repair nodes and the depot node appear. In this reduced graph the set of vertices is 
                           
                              
                                 V
                                 0
                                 ′
                              
                              =
                              
                                 V
                                 r
                              
                              ∪
                              
                                 {
                                 0
                                 }
                              
                           
                        . The set of edges 
                           
                              E
                              0
                              ′
                           
                         consists of those node pairs 
                           
                              
                                 (
                                 i
                                 ,
                                 j
                                 )
                              
                              ∈
                              
                                 E
                                 0
                                 ′
                              
                           
                         between which a path in 
                           G
                         exists that does not contain any other nodes in 
                           
                              V
                              0
                              ′
                           
                         (i.e., that does not pass through nodes in 
                           
                              V
                              r
                           
                         that have not been repaired). The cost of edge 
                           
                              
                                 (
                                 i
                                 ,
                                 j
                                 )
                              
                              ∈
                              
                                 E
                                 0
                                 ′
                              
                           
                         is equal to the minimum travel time between nodes i and j in 
                           G
                        . Note that, for a given pair of nodes i and j, such a path might not exist. If that is the case, no edge is present in the reduced graph 
                           
                              G
                              0
                              ′
                           
                        . Fig. 2
                         presents an example of an original graph and the associated reduced graph.

Let 
                           
                              x
                              =
                              [
                              
                                 x
                                 1
                              
                              ,
                              
                                 x
                                 2
                              
                              ,
                              …
                              ,
                              
                                 x
                                 k
                              
                              ]
                           
                         where 
                           
                              
                                 k
                                 ≤
                                 |
                              
                              
                                 V
                                 r
                              
                              
                                 |
                              
                           
                         and 
                           
                              
                                 x
                                 n
                              
                              ∈
                              
                                 V
                                 r
                              
                           
                         for 
                           
                              n
                              =
                              1
                              ,
                              …
                              ,
                              k
                           
                         be a candidate solution of the NRCSRP. Such a candidate solution is a permutation of a subset of the damaged nodes, and corresponds to the sequence to be followed by the repair crew, where xn
                         is the nth repair node on the crew’s schedule (for 
                           
                              n
                              =
                              1
                              ,
                              …
                              ,
                              k
                           
                        ). Note, however, that not all permutations might be feasible due to existing precedence relationships. These precedence relationships are due to the fact that there might be some damaged nodes that can be reached only after another damaged node has been repaired. Therefore, we define a solution x to be feasible if the sequence that it represents makes all the demand nodes accessible to the depot and all precedence relationships hold.

For a given permutation 
                           
                              x
                              =
                              [
                              
                                 x
                                 1
                              
                              ,
                              …
                              ,
                              
                                 x
                                 k
                              
                              ]
                           
                         where 
                           
                              
                                 k
                                 ≤
                                 |
                              
                              
                                 V
                                 r
                              
                              
                                 |
                                 ,
                              
                           
                        
                        
                           
                              
                                 G
                                 n
                                 ′
                              
                              =
                              
                                 (
                                 
                                    V
                                    n
                                    ′
                                 
                                 ,
                                 
                                    E
                                    n
                                    ′
                                 
                                 )
                              
                           
                         for 1 ≤ n ≤ k denotes the updated reduced graph after nodes 
                           
                              
                                 x
                                 1
                              
                              ,
                              …
                              ,
                              
                                 x
                                 n
                              
                           
                         have been repaired and the repair crew is located at node xn
                        . Then, 
                           
                              
                                 V
                                 n
                                 ′
                              
                              =
                              
                                 V
                                 r
                              
                              ∖
                              
                                 {
                                 
                                    x
                                    1
                                 
                                 ,
                                 …
                                 
                                    x
                                    
                                       n
                                       −
                                       1
                                    
                                 
                                 }
                              
                           
                         and 
                           
                              E
                              n
                              ′
                           
                         is the set of edges such that 
                           
                              
                                 (
                                 i
                                 ,
                                 j
                                 )
                              
                              ∈
                              
                                 E
                                 n
                                 ′
                              
                           
                         for 
                           
                              i
                              ,
                              j
                              ∈
                              
                                 V
                                 n
                                 ′
                              
                           
                         if there exists a path in 
                           G
                         between nodes i and j that does not contain any other nodes in 
                           
                              V
                              n
                              ′
                           
                        .

Then, for a given x we define,

                           
                              t(xn
                              )
                           
                              Time at which node xn
                                  is repaired;

Demand nodes that remain inaccessible after repairing nodes x
                                 1, … , xn
                                  in sequence x;

Damaged nodes that have not been repaired after repairing nodes x
                                 1, … , xn
                                  in sequence x;

Reduced graph after repairing nodes x
                                 1, … , xn
                                  in sequence x;

Set of nodes adjacent to xn
                                  in the graph 
                                    
                                       
                                          G
                                          n
                                          ′
                                       
                                       ,
                                    
                                  that is 
                                    
                                       δ
                                       
                                          (
                                          
                                             x
                                             n
                                          
                                          ,
                                          
                                             G
                                             n
                                             ′
                                          
                                          )
                                       
                                       :
                                       =
                                       
                                          {
                                          i
                                          ∈
                                          
                                             
                                                V
                                                ¯
                                             
                                             r
                                             n
                                          
                                          :
                                          
                                             (
                                             
                                                x
                                                n
                                             
                                             ,
                                             i
                                             )
                                          
                                          ∈
                                          
                                             E
                                             n
                                             ′
                                          
                                          }
                                       
                                    
                                 .

Finally, solution 
                           
                              x
                              =
                              [
                              
                                 x
                                 1
                              
                              ,
                              …
                              ,
                              
                                 x
                                 k
                              
                              ]
                           
                         has an associated objective value f(x) that is equal to the demand-weighted sum of the time when each demand node in 
                           
                              V
                              d
                           
                         becomes accessible. Thus, the objective value f(x) of a solution 
                           
                              x
                              =
                              [
                              
                                 x
                                 1
                              
                              ,
                              …
                              ,
                              
                                 x
                                 k
                              
                              ]
                           
                         is

                           
                              (4)
                              
                                 
                                    f
                                    
                                       (
                                       x
                                       )
                                    
                                    =
                                    
                                       ∑
                                       
                                          n
                                          =
                                          1
                                       
                                       k
                                    
                                    
                                       {
                                       t
                                       
                                          (
                                          
                                             x
                                             n
                                          
                                          )
                                       
                                       ·
                                       
                                          ∑
                                          
                                             
                                                
                                                   
                                                      i
                                                      ∈
                                                      v
                                                      (
                                                      
                                                         x
                                                         ′
                                                      
                                                      ,
                                                      
                                                         x
                                                         n
                                                      
                                                      )
                                                      :
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         x
                                                         ′
                                                      
                                                      =
                                                      
                                                         [
                                                         
                                                            x
                                                            1
                                                         
                                                         ,
                                                         …
                                                         ,
                                                         
                                                            x
                                                            
                                                               n
                                                               −
                                                               1
                                                            
                                                         
                                                         ]
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          w
                                          i
                                       
                                       }
                                    
                                    .
                                 
                              
                           
                        
                     

The construction phase of our IGRCP algorithm aims to generate an initial feasible solution for the NRCSRP. Although some randomness is needed to generate a diverse set of initial solutions during different runs of the algorithm, a completely random procedure (e.g., a random permutation of the damaged nodes) is generally not advised. This is due to the fact that such procedure might either fail to generate a feasible solution or only generate low quality initial solutions. Therefore, we propose a procedure that generates feasible solutions for the NRCSRP taking into account the pre-disaster network conditions.

The repair sequence is initialized at time 0 with the depot node (i.e., 
                           
                              n
                              =
                              0
                              ,
                           
                        
                        
                           
                              
                                 x
                                 0
                              
                              =
                              0
                              ,
                           
                        
                        
                           
                              x
                              =
                              ∅
                           
                        ) and the following steps are iterated until either all damaged nodes are repaired or all demand nodes have become accessible, whichever comes first.

                           
                              Step 1.
                              Choose the next node to be repaired (
                                    
                                       x
                                       
                                          n
                                          +
                                          1
                                       
                                    
                                 ) from the set of nodes adjacent to xn
                                  (
                                    
                                       δ
                                       (
                                       
                                          x
                                          n
                                       
                                       ,
                                       
                                          G
                                          n
                                          ′
                                       
                                       )
                                    
                                 ). (Section 4.2.1 describes the procedure that is used to select node 
                                    
                                       x
                                       
                                          n
                                          +
                                          1
                                       
                                    
                                 .)

Update the repair time for node 
                                    
                                       x
                                       
                                          n
                                          +
                                          1
                                       
                                    
                                 :

                                    
                                       (5)
                                       
                                          
                                             t
                                             
                                                (
                                                
                                                   x
                                                   
                                                      n
                                                      +
                                                      1
                                                   
                                                
                                                )
                                             
                                             =
                                             t
                                             
                                                (
                                                
                                                   x
                                                   n
                                                
                                                )
                                             
                                             +
                                             
                                                t
                                                
                                                   
                                                      x
                                                      n
                                                   
                                                   
                                                      x
                                                      
                                                         n
                                                         +
                                                         1
                                                      
                                                   
                                                
                                                ′
                                             
                                             +
                                             
                                                s
                                                
                                                   x
                                                   
                                                      n
                                                      +
                                                      1
                                                   
                                                
                                             
                                             ,
                                          
                                       
                                    
                                 where 
                                    
                                       t
                                       
                                          
                                             x
                                             n
                                          
                                          
                                             x
                                             
                                                n
                                                +
                                                1
                                             
                                          
                                       
                                       ′
                                    
                                  is the travel time between damaged nodes xn
                                  and 
                                    
                                       x
                                       
                                          n
                                          +
                                          1
                                       
                                    
                                  in the reduced graph 
                                    
                                       G
                                       n
                                       ′
                                    
                                  (i.e., the time to traverse the edge that connects nodes xn
                                  and 
                                    
                                       x
                                       
                                          n
                                          +
                                          1
                                       
                                    
                                  in the reduced graph 
                                    
                                       
                                          G
                                          n
                                          ′
                                       
                                       
                                          )
                                       
                                    
                                 .

Evaluate the accessibility function 
                                    
                                       v
                                       (
                                       x
                                       ,
                                       
                                          x
                                          
                                             n
                                             +
                                             1
                                          
                                       
                                       )
                                    
                                  where 
                                    
                                       x
                                       =
                                       [
                                       
                                          x
                                          1
                                       
                                       ,
                                       …
                                       ,
                                       
                                          x
                                          n
                                       
                                       ]
                                    
                                 . (Section 4.4.2 describes this procedure.) Use the set of nodes returned to update 
                                    
                                       
                                          V
                                          ¯
                                       
                                       d
                                       
                                          n
                                          +
                                          1
                                       
                                    
                                  and 
                                    
                                       
                                          
                                             V
                                             ¯
                                          
                                          r
                                          
                                             n
                                             +
                                             1
                                          
                                       
                                       ,
                                    
                                  as follows,

                                    
                                       (6)
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         V
                                                         ¯
                                                      
                                                      d
                                                      
                                                         n
                                                         +
                                                         1
                                                      
                                                   
                                                
                                                
                                                   
                                                      =
                                                      
                                                         
                                                            V
                                                            ¯
                                                         
                                                         d
                                                         n
                                                      
                                                      ∖
                                                      v
                                                      
                                                         (
                                                         x
                                                         ,
                                                         
                                                            x
                                                            
                                                               n
                                                               +
                                                               1
                                                            
                                                         
                                                         )
                                                      
                                                      ,
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       (7)
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         V
                                                         ¯
                                                      
                                                      r
                                                      
                                                         n
                                                         +
                                                         1
                                                      
                                                   
                                                
                                                
                                                   
                                                      =
                                                      
                                                         
                                                            V
                                                            ¯
                                                         
                                                         r
                                                         n
                                                      
                                                      ∖
                                                      
                                                         {
                                                         
                                                            x
                                                            
                                                               n
                                                               +
                                                               1
                                                            
                                                         
                                                         }
                                                      
                                                      .
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              

Update the value of the objective function,

                                    
                                       (8)
                                       
                                          
                                             f
                                             
                                                (
                                                
                                                   x
                                                   1
                                                
                                                ,
                                                …
                                                ,
                                                
                                                   x
                                                   
                                                      n
                                                      +
                                                      1
                                                   
                                                
                                                )
                                             
                                             =
                                             f
                                             
                                                (
                                                
                                                   x
                                                   1
                                                
                                                ,
                                                …
                                                ,
                                                
                                                   x
                                                   n
                                                
                                                )
                                             
                                             +
                                             b
                                             
                                                (
                                                x
                                                ,
                                                
                                                   x
                                                   
                                                      n
                                                      +
                                                      1
                                                   
                                                
                                                )
                                             
                                             ,
                                          
                                       
                                    
                                 where 
                                    
                                       b
                                       (
                                       x
                                       ,
                                       
                                          x
                                          
                                             n
                                             +
                                             1
                                          
                                       
                                       )
                                    
                                  is the marginal contribution to the objective function value of repairing node 
                                    
                                       x
                                       
                                          n
                                          +
                                          1
                                       
                                    
                                  after having repaired the nodes 
                                    
                                       x
                                       =
                                       [
                                       
                                          x
                                          1
                                       
                                       ,
                                       …
                                       ,
                                       
                                          x
                                          n
                                       
                                       ]
                                    
                                 . That is,

                                    
                                       (9)
                                       
                                          
                                             b
                                             
                                                (
                                                x
                                                ,
                                                
                                                   x
                                                   
                                                      n
                                                      +
                                                      1
                                                   
                                                
                                                )
                                             
                                             =
                                             t
                                             
                                                (
                                                
                                                   x
                                                   
                                                      n
                                                      +
                                                      1
                                                   
                                                
                                                )
                                             
                                             ·
                                             
                                                ∑
                                                
                                                   i
                                                   ∈
                                                   v
                                                   (
                                                   x
                                                   ,
                                                   
                                                      x
                                                      
                                                         n
                                                         +
                                                         1
                                                      
                                                   
                                                   )
                                                
                                             
                                             
                                                w
                                                i
                                             
                                             .
                                          
                                       
                                    
                                 
                              

Update the new repair sequence 
                                    
                                       x
                                       ⟵
                                       [
                                       x
                                       ,
                                       
                                          x
                                          
                                             n
                                             +
                                             1
                                          
                                       
                                       ]
                                    
                                 .

Set 
                                    
                                       n
                                       ⟵
                                       n
                                       +
                                       1
                                       ,
                                    
                                  update the reduced graph 
                                    
                                       
                                          G
                                          n
                                          ′
                                       
                                       =
                                       
                                          (
                                          
                                             V
                                             n
                                             ′
                                          
                                          ,
                                          
                                             E
                                             n
                                             ′
                                          
                                          )
                                       
                                    
                                  and identify the set of adjacent nodes 
                                    
                                       δ
                                       (
                                       
                                          x
                                          n
                                       
                                       ,
                                       
                                          G
                                          n
                                          ′
                                       
                                       )
                                    
                                 .

In Algorithm 1
                        , we present a schematic overview of this procedure.


                           Algorithm 1 (Step 1) requires that, at each iteration and for a given current candidate solution 
                              
                                 x
                                 =
                                 [
                                 
                                    x
                                    1
                                 
                                 ,
                                 …
                                 ,
                                 
                                    x
                                    n
                                 
                                 ]
                                 ,
                              
                            we choose the next node to be repaired (
                              
                                 x
                                 
                                    n
                                    +
                                    1
                                 
                              
                           ) from the list of adjacent nodes 
                              
                                 δ
                                 (
                                 
                                    x
                                    n
                                 
                                 ,
                                 
                                    G
                                    n
                                    ′
                                 
                                 )
                              
                           . Depending on how this selection is performed, different solutions might be obtained. We propose a selection procedure that encompasses two basic principles: (1) it uses information about the network before the disaster (i.e., in which all nodes in 
                              
                                 V
                                 r
                              
                            are non-damaged); and (2) it includes randomness such that different solutions might be generated every time the constructive phase is executed. This procedure is carried out as follows.

Given the original network 
                              
                                 G
                                 =
                                 (
                                 V
                                 ,
                                 E
                                 )
                              
                            and assuming that all damaged nodes are repaired (corresponding to the network before the disaster), we solve a minimum cost flow problem in which the cost corresponds to the traveled distance; each demand node i has a demand wi
                           ; each damaged node has a demand equal to zero; and the depot has a supply capacity equal to 
                              
                                 
                                    ∑
                                    
                                       i
                                       ∈
                                       
                                          V
                                          d
                                       
                                    
                                 
                                 
                                    w
                                    i
                                 
                              
                           . Based on the solution of this minimum cost flow problem, parameter ui
                            is computed for each damaged node. The value of ui
                            is equal to the amount of flow that passes through node i and reflects the importance of node i in the pre-disaster conditions.

Next, given a candidate solution 
                              
                                 x
                                 =
                                 [
                                 
                                    x
                                    1
                                 
                                 ,
                                 …
                                 ,
                                 
                                    x
                                    n
                                 
                                 ]
                                 ,
                              
                            the next node to be repaired (
                              
                                 x
                                 
                                    n
                                    +
                                    1
                                 
                              
                           ) has to be selected from the set of nodes adjacent to xn
                            (
                              
                                 δ
                                 (
                                 
                                    x
                                    n
                                 
                                 ,
                                 
                                    G
                                    n
                                    ′
                                 
                                 )
                              
                           ). To accomplish this, for each node 
                              
                                 k
                                 ∈
                                 δ
                                 (
                                 
                                    x
                                    n
                                 
                                 ,
                                 
                                    G
                                    n
                                    ′
                                 
                                 )
                              
                            we compute a probability pk
                            of selecting that node to be the next node 
                              
                                 x
                                 
                                    n
                                    +
                                    1
                                 
                              
                           . Probability pk
                            is computed using Eq. (10). The first component of Eq. (10) represents the importance of node k relative to all the nodes in 
                              
                                 δ
                                 (
                                 
                                    x
                                    n
                                 
                                 ,
                                 
                                    G
                                    n
                                    ′
                                 
                                 )
                              
                           . This component is multiplied by λ ∈ [0, 1] that weighs the importance of the pre-disaster conditions. The second component of Eq. (10) distributes the remaining (i.e., 
                              
                                 (
                                 1
                                 −
                                 λ
                                 )
                              
                           -weighted) probability of selecting node k equally among all the nodes in 
                              
                                 δ
                                 (
                                 
                                    x
                                    n
                                 
                                 ,
                                 
                                    G
                                    n
                                    ′
                                 
                                 )
                              
                           .

                              
                                 (10)
                                 
                                    
                                       
                                          p
                                          k
                                       
                                       =
                                       λ
                                       
                                          
                                             
                                                u
                                                k
                                             
                                             
                                                
                                                   ∑
                                                   
                                                      j
                                                      ∈
                                                      δ
                                                      (
                                                      
                                                         x
                                                         n
                                                      
                                                      ,
                                                      
                                                         G
                                                         n
                                                         ′
                                                      
                                                      )
                                                   
                                                
                                                
                                                   u
                                                   j
                                                
                                             
                                          
                                       
                                       +
                                       
                                          (
                                          1
                                          −
                                          λ
                                          )
                                       
                                       
                                          
                                             1
                                             
                                                |
                                                δ
                                                (
                                                
                                                   x
                                                   n
                                                
                                                ,
                                                
                                                   G
                                                   n
                                                   ′
                                                
                                                )
                                                |
                                             
                                          
                                       
                                       .
                                    
                                 
                              
                           
                        

Using the presented procedure to generate the initial solution guides our algorithm to solutions that resemble the network before the disaster while simultaneously introducing diversity to the set of initial solutions. This random diversity of the initial solutions facilitates better exploration of the solution space.

The improvement phase of our IGRCP algorithm uses a local search algorithm to improve the solution generated during the construction phase. The local search improves this solution by iteratively making small changes, called moves to the current solution. The set of solutions that can be reached from the current solution by applying a single move, is called the neighborhood of that solution. In each iteration, a solution from the neighborhood of the current solution is selected to become the new current solution according to a pre-specified move strategy. The local search stops when all solutions in the neighborhood of the current solution have a worse objective function value, or when a given maximum number of iterations, θ, is reached.

The first step of the local search algorithm is to clean up the solution generated during the construction phase, 
                           
                              x
                              =
                              [
                              
                                 x
                                 1
                              
                              ,
                              …
                              ,
                              
                                 x
                                 k
                              
                              ]
                           
                         for 
                           
                              
                                 k
                                 ≤
                                 |
                              
                              
                                 V
                                 r
                              
                              
                                 |
                              
                           
                        . More specifically, the algorithm removes all the repair nodes in the sequence that do not improve connectivity nor accessibility of any other node. To do this, for each node xi
                         ∈ x, 
                           
                              
                                 V
                                 ¯
                              
                              d
                              
                                 i
                                 −
                                 1
                              
                           
                         is compared to 
                           
                              
                                 V
                                 ¯
                              
                              d
                              i
                           
                        . If both sets are the same, repairing node xi
                         has not improved the accessibility of the network. Equivalently, the algorithm evaluates the accessibility function discussed in Section 4.4.2 to check whether v(x′, xi
                        ) ≠ ∅, for 
                           
                              
                                 x
                                 ′
                              
                              =
                              
                                 [
                                 
                                    x
                                    1
                                 
                                 ,
                                 …
                                 ,
                                 
                                    x
                                    
                                       i
                                       −
                                       1
                                    
                                 
                                 ]
                              
                           
                        . It also compares sets of repair nodes that can be reached before and after repairing node xi
                        , i.e., it compares 
                           
                              δ
                              (
                              0
                              ,
                              
                                 G
                                 
                                    i
                                    −
                                    1
                                 
                                 ′
                              
                              )
                           
                         and 
                           
                              δ
                              (
                              0
                              ,
                              
                                 G
                                 i
                                 ′
                              
                              )
                           
                        . If xi
                         itself is the only difference between those two sets, the connectivity of the network has not been improved. Thus, we define a Boolean function h(xi
                        ) for all xi
                         ∈ x that is equal to 1 if repairing node xi
                         after nodes 
                           
                              
                                 x
                                 1
                              
                              ,
                              …
                              ,
                              
                                 x
                                 
                                    i
                                    −
                                    1
                                 
                              
                           
                         in x have been already repaired improves at least one of either connectivity or accessibility of the network. Otherwise, h(xi
                        ) is set to 0. The cleanup step of the improvement phase evaluates h(xi
                        ) for all xi
                         ∈ x and removes all xi
                         for which 
                           
                              h
                              (
                              
                                 x
                                 i
                              
                              )
                              =
                              0
                           
                         from the repair sequence x. We denote the new solution by 
                           
                              
                                 x
                                 0
                              
                              =
                              
                                 [
                                 
                                    x
                                    1
                                 
                                 ,
                                 …
                                 ,
                                 
                                    x
                                    
                                       k
                                       0
                                    
                                 
                                 ]
                              
                           
                        . Note that the new solution x
                        0 corresponds to a feasible solution with an objective function value that is guaranteed to be no worse than the initial solution x.

After the initial solution has been cleaned up, the second stage of the improvement phase is executed, which reorders the repair nodes in x
                        0 in order to improve the solution. This is carried out by iteratively relocating elements in x
                        0 one node at a time. To perform a relocation move three distinct steps are executed:

                           
                              Step 1.
                              
                                 Select node 
                                 
                                    x
                                    i
                                  ∈ x
                                 0 
                                 to be relocated. The algorithm chooses node xi
                                  that has the largest marginal contribution to the objective function, i.e.,

                                    
                                       (11)
                                       
                                          
                                             i
                                             =
                                             arg
                                             
                                                max
                                                l
                                             
                                             
                                                {
                                                b
                                                
                                                   (
                                                   
                                                      x
                                                      l
                                                   
                                                   )
                                                
                                                :
                                                l
                                                ∈
                                                
                                                   (
                                                   1
                                                   ,
                                                   …
                                                   ,
                                                   
                                                      k
                                                      0
                                                   
                                                   )
                                                
                                                }
                                             
                                             .
                                          
                                       
                                    
                                 
                              


                                 Choose the position j to which node xi
                                     will be relocated. Starting with 
                                    
                                       j
                                       =
                                       1
                                       ,
                                    
                                  the algorithm checks whether inserting xi
                                  into the jth position is feasible and decreases the objective value f(.). The algorithm iteratively increases j by one until it finds such a position or reaches the current position of node xi
                                 , i.e., 
                                    
                                       j
                                       =
                                       i
                                    
                                 . (See Section 4.4.1 for details on how the feasibility check is performed.)

If no such j is found, the algorithm goes back to Step 1 and selects the xi
                                  with the next largest value of b(xi
                                 ).


                                 Update the new solution. Let the relocation function r(x
                                 0, i, j) return the solution resulting from relocating xi
                                  ∈ x
                                 0 into the jth position and update b(xi
                                 ) values for i ∈ (1, … , k
                                 0) for the new repair sequence. That is

                                    
                                       (12)
                                       
                                          
                                             r
                                             
                                                (
                                                
                                                   x
                                                   0
                                                
                                                ,
                                                i
                                                ,
                                                j
                                                )
                                             
                                             =
                                             
                                                [
                                                
                                                   x
                                                   1
                                                
                                                ,
                                                …
                                                ,
                                                
                                                   x
                                                   
                                                      j
                                                      −
                                                      1
                                                   
                                                
                                                ,
                                                
                                                   x
                                                   i
                                                
                                                ,
                                                
                                                   x
                                                   j
                                                
                                                ,
                                                …
                                                ,
                                                
                                                   x
                                                   
                                                      i
                                                      −
                                                      1
                                                   
                                                
                                                ,
                                                
                                                   x
                                                   
                                                      i
                                                      +
                                                      1
                                                   
                                                
                                                ,
                                                …
                                                ,
                                                
                                                   x
                                                   
                                                      k
                                                      0
                                                   
                                                
                                                ]
                                             
                                             .
                                          
                                       
                                    
                                 
                              

The intuition behind Step 1 is to select the damaged node from the repair sequence that has the largest impact on the objective function (possibly, due to its connectivity to a large number of demand nodes or to the demand nodes with high demand values) and attempt to decrease its marginal value by inserting it as early as possible into the repair sequence. Note that another variation of the presented metaheuristic is to implement the cleanup step on the updated solution after each reordering iteration, but our numerical tests demonstrate no benefit of doing so.

In order to efficiently explore the neighborhood of the current solution 
                           
                              
                                 x
                                 0
                              
                              =
                              
                                 [
                                 
                                    x
                                    1
                                 
                                 ,
                                 …
                                 ,
                                 
                                    x
                                    
                                       k
                                       0
                                    
                                 
                                 ]
                              
                           
                         we form a list 
                           
                              L
                              (
                              
                                 x
                                 0
                              
                              )
                           
                         containing the nodes to be repaired, 
                           
                              (
                              
                                 x
                                 1
                              
                              ,
                              …
                              ,
                              
                                 x
                                 
                                    k
                                    0
                                 
                              
                           
                        ). This list is sorted in decreasing order with respect to the values b(xi
                        ) associated with each damaged node xi
                         ∈ x
                        0. The sorted list is explored from the beginning until we find the first node to be relocated that improves the solution. When a better solution is found, we update the solution and resort the list. Algorithm 2
                         presents a schematic overview of the improvement phase.

@&#IMPLEMENTATION@&#

Here, we discuss the nuances of implementation of the presented IGRCP algorithm. First, in Section 4.4.1, we describe the procedure to determine whether a solution obtained by a relocation move is feasible. Then, in Section 4.4.2, we present the procedure to evaluate the accessibility function v(x, i).

Each iteration of the improvement phase, described in Section 4.3, requires the algorithm to explore the neighborhood of the current solution x
                           0. To this end, for each neighboring solution 
                              
                                 x
                                 ^
                              
                            obtained by relocating a repair node xi
                            ∈ x
                           0, the algorithm first evaluates whether 
                              
                                 x
                                 ^
                              
                            is feasible, and then whether it improves the current solution x
                           0. In case a node xi
                            is relocated to position j that precedes its current position (i.e., j < i), the solution 
                              
                                 x
                                 ^
                              
                            obtained is feasible if node 
                              
                                 
                                    x
                                    i
                                 
                                 ∈
                                 δ
                                 
                                    (
                                    
                                       x
                                       
                                          j
                                          −
                                          1
                                       
                                    
                                    ,
                                    
                                       G
                                       
                                          j
                                          −
                                          1
                                       
                                       ′
                                    
                                    )
                                 
                                 ,
                              
                            where node 
                              
                                 x
                                 
                                    j
                                    −
                                    1
                                 
                              
                            is the node in the position 
                              
                                 j
                                 −
                                 1
                              
                            of the repair sequence.

Each time a node i is repaired and added to the repair sequence in solution x, the accessibility function v(x′, xn
                           ), for 
                              
                                 
                                    x
                                    n
                                 
                                 =
                                 i
                              
                            and 
                              
                                 
                                    
                                       x
                                    
                                    ′
                                 
                                 =
                                 
                                    [
                                    
                                       x
                                       1
                                    
                                    ,
                                    …
                                    ,
                                    
                                       x
                                       
                                          n
                                          −
                                          1
                                       
                                    
                                    ]
                                 
                                 ,
                              
                            has to be evaluated in order to determine the demand nodes that become accessible. This function requires to compute, for each demand node 
                              
                                 j
                                 ∈
                                 
                                    
                                       V
                                       ¯
                                    
                                    d
                                    n
                                 
                              
                            (i.e., each demand node j that is not yet accessible), the shortest path from j to the depot and to compare the length of that shortest path with the maximum acceptable distance Dj
                           .

To improve the efficiency of the algorithm, we formulate the problem of finding the shortest path from the depot to all the demand nodes as a minimum cost flow problem (Maya Duque et al., 2013).

                              
                                 (13)
                                 
                                    
                                       
                                          
                                             min
                                          
                                          
                                             
                                                
                                                   ∑
                                                   
                                                      (
                                                      i
                                                      ,
                                                      j
                                                      )
                                                      ∈
                                                      E
                                                   
                                                
                                                
                                                   l
                                                   
                                                      i
                                                      j
                                                   
                                                
                                                
                                                   y
                                                   
                                                      i
                                                      j
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (14)
                                 
                                    
                                       
                                          
                                          
                                             s.t.
                                          
                                       
                                       
                                          
                                          
                                             
                                                
                                                   ∑
                                                   
                                                      j
                                                      :
                                                      (
                                                      i
                                                      ,
                                                      j
                                                      )
                                                      ∈
                                                      E
                                                   
                                                
                                                
                                                   y
                                                   
                                                      i
                                                      j
                                                   
                                                
                                                −
                                                
                                                   ∑
                                                   
                                                      j
                                                      :
                                                      (
                                                      j
                                                      ,
                                                      i
                                                      )
                                                      ∈
                                                      E
                                                   
                                                
                                                
                                                   y
                                                   
                                                      i
                                                      j
                                                   
                                                
                                                =
                                                
                                                   d
                                                   i
                                                
                                             
                                          
                                          
                                             
                                                ∀
                                                i
                                                ∈
                                                V
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (15)
                                 
                                    
                                       
                                          
                                          
                                             
                                                
                                                   y
                                                   
                                                      i
                                                      j
                                                   
                                                
                                                ≥
                                                
                                                0
                                             
                                          
                                          
                                             
                                                ∀
                                                (
                                                i
                                                ,
                                                j
                                                )
                                                ∈
                                                E
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

In this model, for each edge eij
                            connecting nodes i and j, two decision variables are defined: yij
                            corresponding to the edge being traversed from i to j, and yji
                            corresponding to the traversal from j to i. Each demand node i has a demand 
                              
                                 
                                    d
                                    i
                                 
                                 =
                                 
                                    w
                                    i
                                 
                              
                           ; each damaged node has a zero demand; and the depot has a supply capacity di
                            equal to 
                              
                                 
                                    ∑
                                    
                                       i
                                       ∈
                                       
                                          V
                                          d
                                       
                                    
                                 
                                 
                                    w
                                    i
                                 
                              
                           . The parameter lij
                            depends on the length of edge eij
                            and the status of the nodes that it connects, i.e., whether i and j are damaged or repaired. Thus, when evaluating the accessibility function after repairing node xn
                           , the value of the parameter lij
                            would depend on the set of damaged nodes that remain unrepaired, 
                              
                                 
                                    V
                                    ¯
                                 
                                 r
                                 n
                              
                           . If, at least, either i or j
                           
                              
                                 ∈
                                 
                                    
                                       V
                                       ¯
                                    
                                    r
                                    n
                                 
                                 ,
                              
                           
                           
                              
                                 
                                    l
                                    
                                       i
                                       j
                                    
                                 
                                 =
                                 
                                    l
                                    
                                       j
                                       i
                                    
                                 
                                 =
                                 
                                    d
                                    
                                       i
                                       j
                                    
                                 
                                 +
                                 M
                                 ,
                              
                            otherwise 
                              
                                 
                                    l
                                    
                                       i
                                       j
                                    
                                 
                                 =
                                 
                                    l
                                    
                                       j
                                       i
                                    
                                 
                                 =
                                 
                                    d
                                    
                                       i
                                       j
                                    
                                 
                                 ,
                              
                            where M is a large constant value.

Based on the optimal value of decision variables yij
                            of the minimum cost flow problem, the shortest path from the depot to a given node j can be obtained by tracking back the edges that are used to pass the flow. Thus, the shortest path from the depot to j is equal to the sum of the lengths of the edges that carry the flow between these two nodes. For each node j that was not accessible after having repaired nodes 
                              
                                 
                                    x
                                    1
                                 
                                 ,
                                 …
                                 ,
                                 
                                    x
                                    
                                       n
                                       −
                                       1
                                    
                                 
                              
                            (i.e., for all 
                              
                                 j
                                 ∈
                                 
                                    
                                       V
                                       ¯
                                    
                                    d
                                    
                                       n
                                       −
                                       1
                                    
                                 
                              
                           ), the shortest paths obtained from the solution of (13)–(15) are compared to the maximum acceptable distances Dj
                           ’s. The function v(x′, xn
                           ), for 
                              
                                 
                                    x
                                    ′
                                 
                                 =
                                 
                                    [
                                    
                                       x
                                       1
                                    
                                    ,
                                    …
                                    ,
                                    
                                       x
                                       
                                          n
                                          −
                                          1
                                       
                                    
                                    ]
                                 
                                 ,
                              
                            returns a subset of nodes 
                              
                                 j
                                 ∈
                                 
                                    
                                       V
                                       ¯
                                    
                                    d
                                    
                                       n
                                       −
                                       1
                                    
                                 
                              
                            for which the obtained shortest paths are not greater than Dj
                           .

Note that, since at each iteration only one additional damaged node is repaired, only a few of the coefficients lij
                            have to be updated from one iteration to the next. Therefore, the minimum cost flow problem can be efficiently reoptimized at each iteration.

In this section, we evaluate the two solution approaches we propose for the NRCSRP. To this end, we use a set of randomly generated instances of the problem which are available from http://antor.ua.ac.be/downloads/NRCSRP. The dynamic programming algorithm was coded in MATLAB while the IGRCP algorithm was implemented in Java and CPLEX using Concert Technology (IBM ILOG CPLEX Optimization Studio Academic Research Edition V12.2).

To generate the instances necessary for the experiments, we use the network generator GNETGEN, which is a modification of the widely used NETGEN generator proposed by Klingman, Napier, and Stutz (1974). The generator creates a minimum cost flow network for a given number of nodes 
                           
                              n
                              =
                              |
                              V
                              |
                           
                         and edges 
                           
                              |
                              E
                              |
                           
                        . In the generated network, each node has associated a supply/demand value, being the supply equal to the total demand, and each edge has a cost for being traversed. In our case, this cost represents the travel distance dij
                         between the two nodes i and j connected by edge eij
                        , and it is a variable within the interval [0, 10]. This network is transformed into a network repair instance using the following procedure.

For each edge eij
                        , we generate the parameter tij
                         that represents the travel time. This parameter is defined as a function of dij
                         and an average travel speed 
                           υ
                         as shown in Eq. (16), where r is a uniformly distributed value in the interval [0, 1].

                           
                              (16)
                              
                                 
                                    
                                       t
                                       
                                          i
                                          j
                                       
                                    
                                    =
                                    
                                       (
                                       1
                                       +
                                       r
                                       )
                                    
                                    
                                       
                                          d
                                          
                                             i
                                             j
                                          
                                       
                                       υ
                                    
                                 
                              
                           
                        
                     

Next, a number of damaged nodes 
                           
                              
                                 n
                                 d
                              
                              =
                              
                                 |
                                 
                                    V
                                    d
                                 
                                 |
                              
                           
                         is determined. We use a parameter α that specifies the percentage of damage of the network, i.e., the percentage of the edges in the network that are damaged by the disaster. Thus, the number of damaged edges is 
                           
                              
                                 n
                                 d
                              
                              =
                              
                                 ⌈
                                 α
                                 |
                                 E
                                 |
                                 ⌉
                              
                           
                        .

We randomly select nd
                         edges. For each selected edge e: (1) an intermediate point on the edge is randomly chosen, and (2) a damaged node j is created corresponding to that intermediate point. The repair time sj
                         for the damaged node is set as a random variable uniformly distributed in the interval [10, 60]. (3) The edge e is replaced by two new edges, each of them connecting one of the extremes of edge e and node j. (4) The distance and travel time for each of the new edges depend on the proportion that it represents of the original edge e.

Finally, for each node i, we must generate the maximum acceptable distance Di
                         to the depot. That is, the maximum acceptable length of an undamaged or repaired path from i to the depot. The parameter Di
                         is defined as a function of SP
                           i
                        , the shortest path from i to the depot on the network in which all damaged nodes are repaired (i.e., the pre-disaster conditions). In order to compute Di
                        , we use a parameter β that represents the maximum tolerable percentage by which the path connecting i to the depot can increase. Thus, for each node i the maximum acceptable distance Di
                         is defined as 
                           
                              
                                 (
                                 1
                                 +
                                 β
                                 )
                              
                              
                                 SP
                                 i
                              
                           
                        .

Two sets of instances are considered for the computational experiments. First, we consider a set 
                           
                              S
                              1
                           
                         of small instances, a majority of which can be solved exactly by our dynamic programming model. We use these instances to analyze the performance of the DP approach, evaluate the components of the IGRCP algorithm, and compare the two solution methods. Second, we analyze a set 
                           
                              
                                 S
                                 2
                              
                              ,
                           
                         containing medium and large size instances, that is used to test the performance of the IGRCP algorithm. Note that using each one of the minimum cost flow networks generated by GNETGEN, several instances can be created by using different combinations of the parameters α and β. Table 1
                         shows the number of nodes considered in each instance, the number of instances generated for each number of nodes, the values used for parameters α and β, and the total number of instances in each set.

The performance of our dynamic programming model is evaluated using set 
                           
                              
                                 S
                                 1
                              
                              ,
                           
                         which consists of 300 small instances. Limiting the maximum computing time to 24 hours for each instance, the algorithm found optimal solutions for 225 of those instances. Table 2
                         presents the number of instances solved to optimality for each combination of number of nodes in the network and value of the parameter α, while Table 3
                         shows the number of optimal solutions found for each combination of number of nodes and value of the parameter β. The number of optimal solutions found decreases when the number of nodes and the level of damage of the network (α) increase. On the other hand, the number of instances solved to optimality slightly increases when β, the maximum tolerable percentage in which the path connecting i to the depot can augment, increases.


                        Table 4
                         presents the average computing time for each combination of number of nodes and value of parameter α that were solved within 24 hours. It increases when both, the value of α and the number of nodes, increase. However, the effect of the parameter α is considerably stronger. The average computing time for the instances with 31 nodes and 
                           
                              α
                              =
                              25
                           
                         percent is about 4 hours. From this point on, the increasing pattern of the computing times changes due to the fact that the number of instances that DP is able to solve to optimality within the 24 hours decreases.

We first use a subset of the small instances in 
                           
                              S
                              1
                           
                         and the corresponding optimal solutions found by dynamic programming model to evaluate the significance of the different parameters of the IGRCP algorithm. Then, using the optimal parameter setting, we evaluate the effectiveness of our IGRCP algorithm to generate good feasible solutions and discuss its general performance in terms of computing time and the effect of the different components and parameters of the algorithm when solving the larger instances (
                           
                              S
                              2
                           
                        ).

The IGRCP algorithm we propose in this paper has three parameters that can be tuned: the importance granted to the pre-disaster conditions when generating the initial solution (λ), the maximum number of relocation moves that can be performed in the local search (θ), and the number of times that the two phases of the algorithm are iterated (τ) (i.e., the number of feasible solutions that are generated initially).

In a statistical experiment using a subset of the instances in 
                              
                                 S
                                 1
                              
                            we determine the significance of the effect of the three parameters on the quality of the solutions and computing time. To this end, we use three different values for the parameters λ (25 percent, 50 percent and 75 percent) and θ (10, 50 and 100), and two values for the parameter τ (1 and 5). The analysis of variance (ANOVA) indicates that the parameters θ and τ have significant effect on the quality of the solution and computing time. Thus, when θ and τ increase, the value of the objective function decreases while the computing time increases. This is an expected behavior since the increasing values of θ and τ correspond to the increased number of solutions considered by our heuristic. However, we observe only marginal improvement in the quality of the solutions found as this parameter increases beyond the values of 
                              
                                 θ
                                 =
                                 100
                              
                            and 
                              
                                 τ
                                 =
                                 5
                              
                            (with significant increase in run time), and therefore they are not considered in our study. Given the good performance of our heuristic solution method, we do not believe that the increased run time is worth the corresponding improvement. At the same time, parameter λ does not have significant effect on the IGRCP performance. However, the computing times for the most difficult instances decrease when the value of λ increases. Based on the results of the designed experiment, the parameters λ, θ and τ are set to 50 percent, 100 and 5, respectively.

To evaluate the performance of our IGRCP algorithm, we solve the 300 small instances (set 
                              
                                 S
                                 1
                              
                           ) and compare the solutions found by IGRCP with those obtained using the DP approach. Due to the random nature of our algorithm, we perform 30 independent runs of IGRCP with random start over the set of instances in 
                              
                                 S
                                 1
                              
                           ; we call each of these runs a repetition. The IGRCP performance is assessed based on three metrics: (1) algorithm computation run time, (2) the quality of the found solutions, and (3) consistency of the algorithm performance among multiple repetitions.

The average computing time for IGRCP algorithm limited to the 225 (out of 300) instances that were solved to optimality by DP model was less than 2.34 seconds. When the analysis is extended to the complete set of 300 instances the average computing time increases considerably. In addition, the computing time increases for larger values of α and smaller values of β, i.e., when the network is severely affected by the disaster and the maximum tolerable increase in the shortest path from a node i to the depot to be considered accessible is small. Note, however, that the effect of the parameter α is significantly larger than the effect of the parameter β. Tables 5
                            and 6
                            present the average and standard deviation for computing times for each combination of the number of nodes and values of the parameters α and β, respectively, aggregated over 30 repetitions.

To evaluate the quality of the solutions found by IGRCP we compare its performance to the optimal solutions we obtain with the DP algorithm for 225 out of 300 instances. (The 30 repetitions for each instance results in a total of 6750 IGRCP solutions available for analysis.) Our algorithm finds the optimal solutions for 6264 out of 6750 comparisons, or for 92.8 percent of the cases. For each of the 225 instances, at least one of the 30 repetitions always finds an optimal solution. The average optimality gap for the cases that did not find an optimal solution is 6.5 percent and for the 82.8 percent of cases the gap is less than 10.0 percent.

To evaluate whether our IGRCP approach consistently finds good solutions among multiple repetitions, we analyze the variability of the solutions found over the 30 repetitions. We compute the coefficient of variation (CV) for the objective functions values, defined as the ratio of the standard deviation over the mean. Averaged over all 300 instances, the CV is 1.6 percent. Table 7
                            shows the average coefficient of variation with respect to the instance size and values of α and β. Results show that the variability of the solutions obtained by our approach is predominantly affected by the damage level (α) of the network. In addition, when analyzing the gap between the best solution found for each of 300 instances and the solutions of each repetition, we observe that for almost 80 percent (7150 out of 9000) of the runs our algorithm generates the same best solution. For 15 percent to 20 percent of the remaining cases (1300 out of 9000), the difference between the best solution found and the solution of the specific repetition is less than 10 percent.

We use instance set 
                              
                                 S
                                 2
                              
                            to evaluate the performance of our algorithm when solving medium and large size instances. Note that DP is unable to solve these instance within the 24 hours deadline. For each of the instances we run the IGRCP algorithm with parameters λ, θ and τ set to 50 percent, 100 and 5, respectively. Based on the favorable results of the IGRCP consistency performance analysis in Section 5.3.2 and increased computational demand of the larger instances, we restrict the algorithm run to a single repetition for each problem instance. Table 8
                            presents the average computing time for the combinations of number of nodes and α values for which all the instances were solved in less than 10 hours. Parameter α, the percentage of damaged network, has a higher impact on the computing time than the number of nodes. In addition, our results show that parameter β, the maximum tolerable percentage in which the path connecting each node i to the depot is allowed to increase, also affects the computing time such that when the value of β increases the computing time decreases. However, this effect is less significant than the one generated by the value of parameter α and the number of nodes.


                           Table 9
                            presents the average number of iterations it took IGRCP algorithm to find the best solution, by analyzing when among the five iterations it found the solution. We observe that as the value of α increases, the number of iterations also increases. That is, finding a good solution is more difficult for the instances in which the network is severely damaged.

In this section, we analyze the structure of the solutions found with the goal to validate our optimization model and obtain some managerial insights. The discussion in this section is restricted to the solutions found by the IGRCP algorithm for instance set S
                        1. While not all solutions found using IGRCP are guaranteed to be optimal (see Section 5.3), an analysis of the subset of S
                        1 instances for which IGRCP does find an optimal solution yields analogous results.

As discussed earlier, one important distinction between our model and the existing literature is the fact that we enforce predecessor constraints and ensure feasible repair schedules, where a damaged node cannot be repaired until the crew has repaired all the damaged nodes on a path between that node and the depot. The effect of these constraints is especially important when the crew needs to repair a sequence of nodes before a large demand can be connected. In such situations, repairing any of the intermediate nodes will have a small effect on the objective function value at best, and good solution strategies can only be found by considering several repairs into the future. The importance of this strategy is demonstrated by comparing our solutions to those found by a greedy heuristic that myopically selects the next node to repair without considering the effect of future repairs (we call such heuristic “myopic”). To this end, we considered 280 out of 300 instances in 
                              
                                 S
                                 1
                              
                            for which two or more nodes needed to be repaired to obtain full accessibility.

For 127 out of 280 instances, IGRCP found a better solution than the myopic heuristic, with an average difference between the two solutions of 54.52 percent and a maximum difference of almost 300 percent. The myopic heuristic found a better solution in 8 cases, with an average difference of 1.64 percent and a maximum difference of 3.19 percent. For the instances in which IGRCP found a better solution, the myopic heuristic solution always repairs a larger number of nodes. On average, the myopic heuristic repairs 58.78 percent of the damaged nodes while our IGRCP algorithm repairs only 34.04 percent. Moreover, for the instances with 10 or more damaged nodes, the myopic heuristic repairs, on average, 18.1 nodes while the IGRCP algorithm repairs 8.5 nodes. This demonstrates that failing to look ahead and, by doing so, ignoring the effects of repairing a given node on future demand accessibility generally results in a repair operation that takes much more time and consumes more resources, by repairing more roads, than strictly necessary.

The first important observation we make from a policy and planning perspective is that only a fraction of the damaged roads (i.e., repair nodes) need to be repaired to ensure accessibility for the entire network (see Tables 10
                            and 11
                           ). As expected, that percentage decreases as β values increase, since this corresponds to more relaxed requirements for a demand node to be accessible. The correlation with α values is not as clear. While there is an overall positive trend for the percentage of repaired nodes, instances with 
                              
                                 α
                                 =
                                 5
                              
                            percent correspond to a particularly high number of repaired nodes. This can be explained by an observation that for such low value of α a number of instances have only one or two damaged nodes, and the solution requires to repair all of them.

By analyzing the cumulative demand that becomes accessible over the duration of the repair operation we observe that, on average, the percentage of accessible demand follows a law of diminishing returns. Fig. 3
                            illustrates how cumulative demand accessibility changes over the course of the entire repair operation, for different numbers of nodes repaired. The figure graphs demand averaged over all 
                              
                                 S
                                 1
                              
                            instances and a few examples of demand averaged over subsets of instances with the same number of nodes repaired. To account for different repair times between the instances, the x-axis corresponds to normalized repair time. From the graphs, we observe an initial delay until the first set of demand nodes become accessible, which corresponds to the travel and repair times of the crew to complete its first assignment. Then, on average, the percentage of marginal demand connected decreases with the passing of time and with each additional repair of a node, resulting in a concave cumulative demand curve. We make the same observation in Fig. 4
                           , illustrating accessible demand versus number of nodes repaired. Towards the end of the repair operation (Fig. 3), the curves become flat, corresponding to the repair crew traveling farther away to repair the subsequent node or repairing multiple nodes before the next improvement in demand accessibility. At the very end, we observe a jump in percent of accessible demand, which is explained by a considerable amount of demand that becomes accessible after the last repair is carried out by the crew at the completion of the repair operation.

While, on average, the rule of diminishing returns is clearly illustrated, there is a lot of variation from instance to instance with regards to the percentage demand connected by each consecutive node repaired. This fact highlights the importance of solving the optimization model for each individual instance, and further explains poor performance of the myopic heuristic. Boxplots in Figs. 5–7
                           
                           
                            illustrate the distribution of cumulative demand accessible after each repaired node for all instances that require four, eight and twelve nodes to be repaired, respectively. While all instances connect a progressively higher percentage of demand as more nodes are repaired, we observe high variance earlier in the operation. Fig. 8
                            illustrates individual examples of the cumulative demand accessibility over the duration of the repair operation. Here, we see that Examples 1, 3, 5 and 6 have a significantly lower percentage of demand connected early on in comparison to Examples 2 and 4. At the same time, Examples 2, 3, 4 and 6 illustrate instances where multiple nodes need to be repaired before the next improvement in network accessibility. More specifically, in case of Example 3 the sixth node repaired does not directly contribute to the cumulative accessible demand, but its repair is necessary in order for the seventh repaired node to connect a substantial percentage of demand. Examples 4 and 6 illustrate the cases where multiple consecutive repairs are required before the next improvement in accessible demand. This diverse set of examples highlights the importance of finding a close-to-optimal solution of each individual problem instance.

In this paper, we study the problem of emergency repair of a rural road network that has been damaged by the occurrence of a natural disaster. We address the scheduling and routing of a repair crew, starting from a single depot, while optimizing accessibility to the towns and villages that demand humanitarian relief. This is an important problem given the impact that a functioning road network has on providing the opportune relief to the affected population. This paper extends the traditional network upgrading problems by considering not only the selection of the edges to be repaired or upgraded, but also the time dependency and crew routing associated with the required repair work.

While the NRCSRP was developed mainly to be used as a support tool in the initial response stage, our problem setting and solution methods could be directly extended to the later recovery stage, as long as the time scale of travel times and repair times are equivalent. Problems such as connecting remote villages to a central medical facility would be applicable here, where moving the repair equipment from one node to the next requires significant time that is comparable in scale to the actual repair time.

We develop a dynamic programming model and discuss efficient implementation techniques that allows us to find optimal solutions for a range of instance sizes of the problem. However, the DP approach limits the size of the road networks that can be solved within a 24-hour time limit. This fact motivated the development of a heuristic (IGRCP) that we develop for our problem. We run extensive computational experiments to analyze the difficulty of solving instances of the NRCSRP depending on the values of three distinct parameters. Two of the parameters are beyond the control of the decision maker: the number of nodes or population centers in a network and the level of network damage caused by the disaster, which is denoted by parameter α and determines the number of edges requiring repair. The third parameter, β, is the maximum tolerable percentage by which a path connecting each demand node i to the depot is allowed to increase in order to be considered accessible. This parameter can be controlled by the decision maker and depends on the specifics of each setting.

Our results show that the factor that has the highest impact on the difficulty of solving an NRCSRP instance is the α parameter. That is, the most severely affected networks correspond to the most difficult instances to solve. This is mainly due to the fact that the NRCSRP is, in part, a combinatorial problem for which a solution is represented by a permutation of the damaged nodes that have to be repaired. Therefore, as the level of network damages increases, so does the number of nodes that have to be repaired, which, in turn, increases the number of possible permutations to be considered. An instance of the NRCSRP also becomes more difficult to solve when the size of the network increases. However, the effect of this parameter is not as significant as it is for parameter α. Finally, when the value of the parameter β increases, the time required to solve each instance decreases. This phenomenon is explained by the fact that increasing the value of β implies that the decision maker is willing to accept a longer path between a demand node and the depot in order to consider that demand point accessible.

When comparing the difficulty of solving an instance of the NRCSRP using the dynamic programming model versus the IGRCP algorithm, the results show that the two algorithms experience similar trends in the levels of difficulty. That is, the instances that are easily solved by the DP are also easily solved by the IGRCP. Similarly, for the instances that could not be solved to optimality by DP within the time limit, the computational time of the IGRCP algorithm is also higher. However, the DP method performs better than the IGRCP for instances with few nodes and a small percentage of network damage (α), while the IGRCP performs better than the DP when both the size of the instance network and the level of damage increase. We use the IGRCP algorithm to solve instances containing up to 401 nodes, and the results confirm that parameter α strongly correlates with the level of difficulty of an NRCSRP instance.

Analysis of the solution structure provides important managerial insights for our problem. We observe that only a fraction of damaged nodes (approximately 30 percent, on average) needs to be repaired to establish accessibility for the entire network. In addition, while, on average, each subsequent repair of a damaged node follows a law of diminishing return, that property does not necessarily hold true for all instances. This fact, along with poor performance of the tested myopic heuristic, establish the need for optimization of the repair crew schedule and rout for each individual instance. This is especially the case when a sequence of multiple nodes need to be repaired before observing improvement in the network accessibility.

In this paper, we have designed an objective function to accurately capture and evaluate the accessibility measure, since it is closely tied to the performance of our solution strategies. An interesting open research direction to pursue in future work is to study alternative measures and objective functions for estimating network accessibility. Moreover, the efficiency of the IGRCP algorithm can be potentially improved by restricting the complete exploration of the current solution neighborhood, at each iteration, and instead, focusing on specific regions of the feasible solution space. Note, however, that from the perspective of the quality of the solutions, the suggested measures might not have any positive effect on the value of the objective function itself, just the algorithm run time.

From our extensive study of the NRCSRP, we are able to identify problem properties that can be useful in extending this work to more complex and realistic settings. The first promising research direction is to extend this problem to more than one repair crew and more than one depot node. This extended problem would model real-life situations where different organizations or relief entities are involved in the emergency reconstruction operations of the region’s road network. In addition, the collaboration and coordination aspects of such problem settings would have to be considered. For example, one would have to answer the question of what happens when two or more crews are able to work simultaneously on repairing a single damaged node. Another interesting extension that emerges from considering multiple depots is the distribution allocation decisions. In such cases, one has to consider the limited amount of resources available at each depot, and the repairing decisions are restricted by the need of fulfilling the relief demand of the towns that are made accessible.


                     
                        
                           
                              V
                           
                        
                        
                           Set of nodes 
                                 
                                    {
                                    0
                                    ,
                                    1
                                    ,
                                    …
                                    ,
                                    n
                                    +
                                    1
                                    }
                                 
                              ; node 0 is the depot; node 
                                 
                                    n
                                    +
                                    1
                                 
                               is a dummy node; 
                                 
                                    V
                                    =
                                    
                                       {
                                       0
                                       }
                                    
                                    ∪
                                    
                                       V
                                       d
                                    
                                    ∪
                                    
                                       V
                                       r
                                    
                                    ∪
                                    
                                       {
                                       n
                                       +
                                       1
                                       }
                                    
                                 
                              
                           

Set of demand nodes; 
                                 
                                    
                                       V
                                       d
                                    
                                    ⊂
                                    V
                                 
                              
                           

Set of damaged nodes requiring repair; 
                                 
                                    
                                       V
                                       r
                                    
                                    ⊂
                                    V
                                 
                              
                           

Set of edges or roads

Edge connecting nodes i and j; 
                                 
                                    
                                       e
                                       
                                          i
                                          j
                                       
                                    
                                    ∈
                                    E
                                 
                              
                           

Set of arcs adjacent to node 
                                 
                                    k
                                    ∈
                                    V
                                    ,
                                 
                              
                              
                                 
                                    E
                                    (
                                    k
                                    )
                                    ⊂
                                    E
                                 
                              
                           

Relief demand of node 
                                 
                                    i
                                    ∈
                                    V
                                 
                              
                           

Time required to travel between nodes i and j on edge eij
                              
                           

Time required to repair damaged node 
                                 
                                    j
                                    ∈
                                    
                                       V
                                       r
                                    
                                 
                              
                           

Length of edge eij
                               connecting nodes i and j, i.e., distance between nodes i and j
                           

Length of edge e
                           

Maximum acceptable distance from node 
                                 
                                    i
                                    ∈
                                    
                                       V
                                       d
                                    
                                 
                               to the depot in order for i to be accessible to it

@&#REFERENCES@&#

