@&#MAIN-TITLE@&#Automatic test case generation for WS-Agreements using combinatorial testing

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We propose a method to test SLAs using standard testing techniques.


                        
                        
                           
                           Constraints that avoid generating non feasible test cases are automatically obtained.


                        
                        
                           
                           Different coverage strategies are defined to grade the thoroughness of the tests.


                        
                        
                           
                           A tool named SLACT that automates the generation of the test cases is implemented.


                        
                        
                           
                           Application of the approach to a real and critical eHealth service-based scenario.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Software testing

Service based applications

Service Level Agreements

WS-Agreement

Combinatorial testing

@&#ABSTRACT@&#


               
               
                  In the scope of the applications developed under the service-based paradigm, Service Level Agreements (SLAs) are a standard mechanism used to flexibly specify the Quality of Service (QoS) that must be delivered. These agreements contain the conditions negotiated between the service provider and consumers as well as the potential penalties derived from the violation of such conditions. In this context, it is important to assure that the service based application (SBA) behaves as expected in order to avoid potential consequences like penalties or dissatisfaction between the stakeholders that have negotiated and signed the SLA. In this article we address the testing of SLAs specified using the WS-Agreement standard by means of applying testing techniques such as the Classification Tree Method and Combinatorial Testing to generate test cases. From the content of the individual terms of the SLA, we identify situations that need to be tested. We also obtain a set of constraints based on the SLA specification and the behavior of the SBA in order to guarantee the testability of the test cases. Furthermore, we define three different coverage strategies with the aim at grading the intensity of the tests. Finally, we have developed a tool named SLACT (SLA Combinatorial Testing) in order to automate the process and we have applied the whole approach to an eHealth case study.
               
            

@&#INTRODUCTION@&#

Service Oriented Architecture (SOA) has become a solid paradigm to develop interoperable, flexible and highly dynamic Service Based Applications (SBAs) by means of integrating available services over the web. The main features of these services include loose coupling between them, coarse grained service interfaces, dynamic service discovery and binding, self-containment of services, service interoperability and protocol independence [1]. SBAs are implemented using different Internet-based standards [2] such as the Simple Object Access Protocol (SOAP) [3] for transmitting data, the Web Service Description Language (WSDL) [4] for defining services or the Business Process Executable Language for Web Services (BPEL4WS) [5] for orchestrating services.

In SBAs, it is necessary for the stakeholders involved to specify the conditions related to the provision and consumption of the services. These conditions are usually specified in a contract or technical document, called Service Level Agreement (SLA), which is a standard mechanism that allows determining and regulating the trading between the service providers and the consumers. In the scope of SBAs, the WS-Agreement standard [6] is a language used to specify the conditions negotiated and agreed by these stakeholders. WS-Agreement supports the representation of information regarding the functional features of services, non-functional requirements related to the Quality of Service (QoS) level that should be achieved by the service provision, penalties derived from the violation of the terms and any other relevant information related to the agreement. It is therefore of utmost importance for both providers and consumers to develop suitable actions that allow avoiding or minimizing the consequences derived from SLA violations.

The management of SLAs [7] is an integral part of the applications developed under the rules of a standard SOA Governance framework [8] and has received considerable attention both in industry and academia (see, for example, the SLA@SOI FP7 European Project [9]). Many large companies, including Amazon, Microsoft, Google, AT&T and HP, that provide XaaS (Everything as a Service) use SLAs as a mechanism for specifying the functionalities and QoS levels that they are capable of providing in their XaaS offerings [10–14].

The management of SLAs involves different tasks including SLA negotiation [15], re-negotiation [16,17], specification [18,19], evaluation [20], testing [21], and monitoring [22]. Among these tasks, the testing of the SLAs has been identified as a challenge [23–25]. The testing of the SLAs involves designing and executing tests in the SBA by means of considering the specification of the SLA as the test basis. This requires that the specification of the SLAs needs to be somehow formalized in order to automate as much as possible the process of obtaining the tests.

Currently, there are different approaches that aim at detecting, forecasting or preventing SLA violations using testing techniques. Most of these works are reactive and use monitoring to observe the behavior of the SBA at runtime in order to detect potential deviations from the guaranteed conditions specified in the SLA [22,40]. These approaches are useful in detecting problems in SBAs but they present an important drawback: problems are detected after their occurrence and, therefore, consequences derived from such problems cannot be avoided. On the other hand, different proactive approaches have been proposed to predict or anticipate the detection of problems associated to the violation of the SLA [21,36].

Considering the characteristics of both approaches, in a previous work we presented a conceptual method to test SLA-aware service based applications. In that work, our aim was to combine the advantages of both proactive and reactive approaches [26]. Later, we addressed the identification of situations to be tested from the information contained in the individual SLA terms [27]. These situations may be used to guide the design of an appropriate test suite that exercises such situations and also to derive a monitoring plan allowing checking the compliance of the SLA at runtime.

In this article, and as a further step, we define a method to generate test cases from an SLA specified in WS-Agreement standard language by integrating testing techniques that have been used broadly in the industry and standardized in ISO/IEC/IEEE 29119 [28]. We also provide a tool that automates the whole process. The main contributions of this article are the following:
                        
                           1)
                           We define how standard techniques for testing, namely the Classification Tree Method and Combinatorial Testing can be applied in the context of SLAs in order to obtain a set of test cases that are suitable for testing an SBA in which the conditions that need to be satisfied are specified in a single SLA.

We define how to automatically obtain specific constraints from the specification of the SLA and the behavior of the SBA in order to avoid the generation of non-feasible test cases.

We define three different coverage strategies with the aim at grading the thoroughness of the resulting test suite.

We implement a tool called SLACT that automatically generates the test cases, making use of an existing testing tool [29].

We apply the approach to an eHealth scenario that was proposed by the EU F7 project PLASTIC [30] and has been previously used by other authors to test SLAs [31–34].

These contributions aim at taking into account some particular challenges that arise from the testing of service-based systems [23]. In our case, we have to deal with the controllability of the services and the infrastructure so, to mitigate this limitation, the services will be under our control and, consequently, the set of generated test cases will be executed in a controlled environment.

The rest of this article is structured as follows. Section 2 outlines related work. Section 3 provides a background about the two cornerstones of this research: Software Testing standards and WS-Agreement. It also summarizes the four-valued logic used to evaluate SLA Guarantee Terms, which was previously developed by the authors [27] and is again used in this article. Section 4 discusses the generation of test cases and the level of automation provided by SLACT. Section 5 presents the results derived from the application of our approach to the eHealth case study. Section 6 highlights the main limitations of this approach. Finally, Section 7 provides some concluding remarks and outlines plans for future work.

@&#RELATED WORK@&#

In the scope of service-based applications, considerable effort has been spent in detecting SLA violations using different testing approaches. Typically, related strands of work may be categorized in two main groups: (i) the set of works which are aimed at anticipating problems and/or prevent them before such problems lead to undesired consequences for the stakeholders who have signed the agreement; and (ii) the set of works that are aimed at detecting SLA violations at runtime when the Software Under Test (SUT) is already deployed in the operational environment.

Few approaches have focused on the identification of tests from the specification of the SLAs in order to anticipate problems. Di Penta et al. [21] perform black-box and white-box testing by means of using Genetic Algorithms with the aim of detecting SLA violations in atomic and composite services. This approach generates combinations of inputs, as we do in our contribution, and bindings of the constituent services that may cause violations of the SLA. Palacios et al. [35] identify test requirements from the conditions included in an SLA specified in WS-Agreement using a well known testing technique, called Category Partition Method. Once such test requirements have been identified, they are combined in order to derive the test cases. Such combinations of the identified test requirements are not addressed in that work whereas in our contribution we apply combinatorial testing techniques in order to derive the test cases from the test requirements. Palacios et at. [36] also provides a coverage based criterion in order to test SLA-aware service-based application. In that work they focus on the logical relationships between the guarantee terms of a SLA specified in WS-Agreement whereas in this article we are focusing on the content of the individual guarantee terms. Furthermore, Bertolino et al. [31] have proposed the PUPPET framework, which allows generating stubs from the WS-Agreement, WSDL and BPEL specification of the services to test SLA-aware service compositions. This work is related to our work. However, instead of specifying the tests for the SBA as we do, they provide the necessary infrastructure to deploy and execute such tests. Thus, both works may be mutually complemented. Kotsokalis et al. [37] have proposed to use Binary Decision Diagrams in order to model the content of SLAs for testing purposes. However they do not focus on a specific standard language as we do although they attempt to obtain the diagrams from this language (WS-Agreement). In their approach, they use two different values to evaluate the terms of the SLA. In our work, we show that four different values are necessary to consider all the potential situations derived from the evaluation of SLA Guarantee Terms. Finally, Muller et al. [38,39] propose to detect and explain conflicts within the specification of WS-Agreements by means of applying techniques based on Constraints Satisfaction Problems. This work focuses on checking whether the specification of the SLA guarantee terms is consistent so the detected problems are related to the SLA and not the services. In our work we focus on the detection of problems in the SUT by means of taking the specification of the SLA as the test basis.

Regarding the second group, several works have addressed the testing of SLAs using monitoring approaches in order to detect SLA violations. Mahbub and Spanoudakis [22] focus on WS-Agreement to propose modeling and monitoring the conditions contained in the SLA using an Event Calculus (EC) based approach. Raimondi et al. [40] proposed a system that automatically monitors SLAs, translating timeliness constraints into timed automata, which is used to verify traces of services executions. Comuzzi et al. [41] tackles the testing of SLA-aware SBA by monitoring the conditions specified in the SLA. This work was developed in the scope of the SLA@SOI European Project [9]. Beyond these works, there are other systems that have been developed to monitor whether service based applications violate SLAs including, for example, SALMon [42,43], SLAMonitor [44] HA-SLA [45] and CLAM [46].

Between these two groups, there is a set of works that make use of information gathered from monitoring techniques in order to prevent SLA violations. For example, Leitner et al. [47] propose a framework that allows monitoring and predicting SLA violations before they have occurred using machine learning techniques and they have also addressed the prevention of SLA violations using self-adaption [48]. Ivanovic et al. [49] propose a constraint-based approach to monitor and analyze the QoS metrics included in the SLA for the purpose of anticipating the detection of potential SLA violations. Schmieders et al. [50] combined monitoring and prediction techniques in order to prevent SLA violations. Finally, Lorenzoli and Spanoudakis [51] presented a framework (EVEREST+) which supports the monitoring and prediction of potential violations of the QoS metrics specified in an SLA.

@&#BACKGROUND@&#

In this section we present the basic concepts about the two cornerstones of our research. On the one hand, we introduce some important standard definitions which are broadly used in the field of software testing. On the other hand, we focus on the structure of WS-Agreement standard language and how it is been used within the provisioning of applications developed under the paradigm of service oriented architectures. We also briefly present our previous research which is extended and improved in this article.

Testing can be defined as “an activity in which a system is executed under specified conditions, the results are observed or recorded, and an evaluation is made of some aspect of the system”, according to the ISO/IEC 24765 (Software and Systems Engineering Vocabulary) [52].

The generation of test cases allows designing the conditions under which the SUT will be executed. This is important for the success of the tests as a good test design will allow detecting a higher number of faults. According to the IEEE Standard Glossary of Software Engineering Technology, a test case is “a set of inputs, execution conditions, and expected results developed for a particular objective” [53]. Thus, executing the software and comparing the obtained outputs with the expected results allows determining whether the behavior of the software is correct or not. The approaches that use the generation and execution of test cases are proactive in the sense that they are able to anticipate the detection of faults before the problems occur in a production environment. The generation of test cases tries to maximize the trade-off among different business criteria such as cost, benefit or risks. In some cases, it may be possible to design an in-depth and exhaustive test suite even if it involves a high cost in terms of money or effort. In other cases, however, there might be constraints hindering the definition and execution of exhaustive tests. When this happens, the tester is forced to select a less exhaustive testing technique. The generation of test cases is often a very tedious task so it is desirable to automate it as much of it as it is possible.

Currently, the fragmentation of the different standards is a common problem in this field. To fill this gap, the ISO/IEC/IEEE 29119 Systems and Software Engineering — Software Testing standard [28] is being developed with the aim of providing one definitive reference for software testing that defines vocabulary, processes, documentation and techniques. This standard comprises four parts: Definitions and Vocabulary (part 1), Test Process (part 2), Test Documentation (part 3) and Test Techniques (part 4).

In this article, we describe how two techniques which are used broadly in industry and academia [54] and are described in Part 4 of ISO/IEC/IEEE 29119, namely the Classification Tree Method and Combinatorial Testing, can be applied in testing SLAs.

The Classification Tree Method [55] provides a systematic way to hierarchically partition the inputs of a SUT into classifications and classes via the construction of an appropriate classification tree. Each classification is a disjoint partition related to the SUT and each class is a disjoint partition of the values of the corresponding classifications. From the constructed tree, test coverage items shall be derived by combining leaf nodes using combinatorial techniques. In this context, a test coverage item represents an attribute or combination of attributes regarding the SUT that will be exercised by a test case.

Combinatorial testing techniques [56] are used to generate test cases that achieve different levels of coverage. The combinations are defined in terms of parameters and the values that they can take. To align this with the constructed classification tree, classifications represent parameters and classes represent parameter values. There are different combinatorial testing techniques such as All combinations, Pair-wise or Each choice that will be later used in this article.

Over the last decade, different languages have been proposed with the aim to support and standardize the specification of SLAs (e.g., WSLA [57], WS-Agreement [6], WSLO [58], SLANG [59,18], WS-Policy [60], the SLA Model [61] and WS-QoS [62]). In our work, we focus on WS-Agreement because it is a well-accepted standard in the SOA protocol stack for the management of the SLAs (Fig. 1
                        ) and has been used in different approaches regarding the testing of SBAs.

WS-Agreement [6] was proposed by the Open Grid Forum working group (OGF). WS-Agreement is a standard that specifies a protocol for establishing agreements between two parties and a schema for the definition of SLAs. The specification of domain specific languages or extensions to express the conditions of the Guarantee Terms is out of the scope of WS-Agreement. The specification of an SLA in WS-Agreement is composed of three main parts (Fig. 2
                        ):
                           
                              •
                              Name: This part represents an optional name that can be given to the agreement.

Context: This part describes the involved parties and their role as initiator or responder. Additionally, it may specify any other information of the agreement that is not related with the obligations of these parties, such as the “Expiration Date”.

Terms: This part expresses the negotiated and agreed obligations of each party. Obligations are specified using different types of terms:
                                    
                                       ○
                                       Service Description Terms (SDT): describe information about the functional aspects of the services.

Service Properties (SP): provide measurable aspects that are used to express the requirements (guarantees) of the services.

Guarantee Terms (GT): describe the obligations that must be satisfied by a specific obligated party.

The Guarantee Terms are the most important section of an SLA. A Guarantee Term contains: an internal element, called Scope, that specifies the list of services and, an optional substructure of the service that the terms applies to (for example, a particular method or endpoint); a Qualifying Condition (QC) which is an assertion or precondition determining whether the term is valid or not; and a Service Level Objective (SLO) that is the guarantee that must be met. Optionally, a Business Value List (BVL) for such term may also be specified containing some information as the penalties for not having satisfied the associated guarantee.

It is worth noting that WS-Agreement allows the logical combination of these terms by means of elements named Compositors. More specifically, there are three different compositors: All, OneOrMore and ExactlyOne, which are equivalent to the logical AND, OR and XOR operators respectively.

In previous research [27], we have developed a four-valued logic and defined a method to identify a set of test values from the information contained in the SLA Guarantee Terms.

The evaluation is one of the most important tasks within the management of SLAs in the context of SBAs. It requires analyzing the information gathered from the monitors, checking the specification of the guarantee terms and their internal elements and, finally, making a decision about the fulfillment of the conditions contained in such terms. Typically, the evaluation of an SLA may be depicted with a two-way traffic light indicator (green/red), which represents whether the agreement has been fulfilled or violated respectively.

Focusing on WS-Agreement standard language, a Guarantee Term is specified by means of the internal elements Scope, Qualifying Condition (QC) and Service Level Objective (SLO). Considering the syntax of a Guarantee Term and the possible forms of analysis of the collected information from the service executions at runtime, there are four (as opposed to two) possible evaluation values for a Guarantee term, notably:
                           
                              •
                              
                                 Fulfilled — This value can be used if and only if the methods of the services specified in the Scope have been executed, the Qualifying Condition has been met and the Service Level Objective has been satisfied.


                                 Violated — This value can be used if and only if the methods of the services specified in the Scope have been executed, the Qualifying Condition has been met and the Service Level Objective has not been satisfied.


                                 Not Determined — This value can be used if and only if the methods of the services specified in the Scope have not been executed and the Qualifying Condition is met.


                                 Inapplicable — This value can be used if and only if the Qualifying Condition has not been satisfied.

The first three evaluation values are explicitly identified in the WS-Agreement standard as the three potential states in which the SLA can be so, from a testing point of view, we have added a four value (Inapplicable) in order to represent specific situations that are also interesting to be tested. In this case and in addition to the typical two evaluation values (i.e., Fulfilled/Violated), the utilization of Not Determined and Inapplicable leads to a four-valued logic where they are two similar interpretations of the treatment of the null value in the three-valued logic, broadly studied in the context of Data Base Management Systems (DBMS) and applied in the scope of software testing [64–67].

Hence, a Guarantee Term denoted by t can be evaluated using a function ev, which can provide four different values as output:
                           
                              
                                 e
                                 v
                                 
                                    t
                                 
                                 =
                                 
                                    
                                       Fulfilled
                                       ,
                                       
                                       Violated
                                       ,
                                       
                                       Not
                                       
                                       Determined
                                       ,
                                       
                                       Inapplicable
                                    
                                 
                                 .
                              
                           
                        
                     

At first glance and based on these four evaluation values, we could think that it is necessary to identify four different situations with the aim of achieving full coverage while evaluating the Guarantee Term. However, the internal syntactic structure and the semantics of a guarantee term specified in WS-Agreement standard language require a more exhaustive test suite to represent the whole set of situations that are interesting to observe or exercise from a testing point of view.

At this point, it is important to distinguish between the concepts of evaluation values and test values. An evaluation value is the outcome of the process of making a decision about the fulfillment of a Guarantee Term. If the behavior of this mechanism is grounded in the proposed logic, there will be four possible evaluation values (i.e., Fulfilled, Violated, Not Determined and Inapplicable). On the other hand, a test value (also known as test requirement in our previous work) represents a situation of the SBA that must be covered (and satisfied) during testing [68]. A test value includes a set of conditions and steps that need to be checked through the execution of the SUT. And during this check, useful information gathered from monitors can be used by the evaluation mechanism in order to make a decision and provide the final evaluation value for the test value. In Fig. 3
                        , we show an example where a test value is identified from the content of a Guarantee Term specified in WS-Agreement. This test value exercises the situation where the method (service) specified in the Scope is executed, the Qualifying Condition is met and the objective is not satisfied.

Thus, according to the above logic the guarantee term is evaluated as Violated.

Keeping this in mind, a Guarantee Term may be evaluated with four different values but it is possible to identify, for each term, six test values, as it can be seen in Fig. 4
                        . More specifically, as shown in the figure, the internal elements of a Guarantee Term include Scope, Qualifying Condition and Service Level Objective. At the top of the figure we check whether the methods of the services specified in the Scope element have been invoked or not at the time of evaluating the SLA (the verification of this condition is performed using satisfied/unsatisfied as outputs). Furthermore, the content of the Qualifying Condition and the Service Level Objective represent conditions that may also be evaluated as satisfied/unsatisfied. Thus, we apply the multiple combinations of these three internal elements of a Guarantee Term. As there are three conditions with two truth-values for each condition, we would obtain eight different situations to test regarding the content of the Guarantee Term. However, due to the semantic meaning of the internal elements of the term, there is a pair of combinations that do not make sense. These relate to cases where the methods of the services specified in the Scope have not been executed so it is useless to check whether the Service Level Objective have been satisfied or not (right branch of the Fig. 4). Hence, we obtain six test values that are interesting to test from the specification of a Guarantee Term (identified by TV1–TV6).

At the bottom of the figure, we align the relation between the test values and the value provided by the evaluation mechanism when exercising such test value.

An SLA specified in WS-Agreement has a hierarchical structure that logically combines the Guarantee Terms through the use of the specific elements named compositors (All, OneOrMore and ExactlyOne). Then, it is necessary to define how these terms are analyzed in order to identify the situations that need to be tested. In this section, we describe the method that allows deriving the test cases by means of elaborating the classification tree, specifying the constraints that guide the derivation of the test coverage items avoiding the generation of non feasible test cases and, finally, the tool that automates the whole process.

The first step of the method involves the construction of a suitable model to hierarchically represent the relevant information of the SLA specification in WS-Agreement, using the Classification Tree Method (CTM). This tree will later be used to derive the test coverage items and generate the test cases. To do so, we have to identify the classifications and classes that will formulate the tree.

The simplest approach could be to parse the structure of the SLA and construct a classification for each of the elements of the SLA. In this case the Service Level Objectives of the Guarantee Terms would represent the classifications at the lowest level whereas the evaluation of such SLOs would represent the classes of the tree. However, we need to ensure that the resulting tree represents all the test situations that may arise during the evaluation of the Guarantee Terms. Hence, we use the compositors of WS-Agreement to construct the first levels of the hierarchy in the tree and we raise the level of abstraction of the most internal elements of the SLA. In particular, we take the structure of each Guarantee Term as a whole (including its Scope, Qualifying Condition and Service Level Objective) and we construct a classification for each of the SLA Guarantee Terms. Each of these classifications (Guarantee Terms) has six potential test values as we described in Section 3.3. Hence the leaves of the tree that represent the classes of each classification are constructed by representing the six test values for each Guarantee Term. With this approach, both the classifications and the classes fulfill the restriction of being disjoint partitions with respect to the SLA. Note that both classifications and classes represent different levels of detail of the situations to be tested. The lowest level (class) represents each situation that arises from each of the test values that have to be covered by the test cases.

It is worth mention that in order to be consistent with the notation of the testing techniques described in the ISO/IEC/IEEE 29119, in the rest of the article we will use the concept of class (CL) when we refer to the different situations that arise from the evaluation of a Guarantee Term.

At this stage, we have to deal with an important issue regarding the construction of the classes of the tree. Depending on the internal syntax and semantics of the Guarantee Terms of WS-Agreement, we have to consider two particular cases where not all the six classes are identified. These two cases are described next.
                           Case 1 (C1)
                           Guarantee Terms without Qualifying Condition.

The first particular case (C1) arises when the Guarantee Term has no Qualifying Condition associated. The Qualifying Condition determines whether a term is valid and it must be considered during the evaluation process or not. In this case and given that there is no Qualifying Condition the term is always valid so only three classes (CL1, CL2 and CL5) are identified. Thus in the classification that represents such Guarantee Terms, only three classes are constructed in the tree (see Fig. 5
                        ). The specification of the classes CL1 and CL2 in this tree represent that the methods of the services are invoked and the Service Level Objective is satisfied or unsatisfied, respectively. Class CL5 represents that the methods of the services have not been executed.
                           Case 2 (C2)
                           Qualifying Condition is an assertion over service attributes.

WS-Agreement states in its specification that the Qualifying Condition is an assertion over service attributes and/or external factors. In the former case, for example, this condition may make reference to an input parameter or condition of the service while in the latter it can represent a specific state of the SUT. The second particular case (C2) arises when the Qualifying Condition of the Guarantee Term is an assertion over the service attributes. This case occurs because the semantics of the Qualifying Condition also affect the identification of the classes. In this case, it is impossible to check the fulfillment of the QC if the methods of the services have not been executed so the combinations performed in classes CL5 and CL6 do not make sense. In such case, classes CL5 and CL6 are joined in only one class representing that the methods of the services have not been executed (Fig. 6
                        ). This means that we would construct five classes for the classification that represents such Guarantee Term instead of the six that are constructed in the general case.

After considering the application of both cases when constructing the classification tree, we finally obtain a tree that contains one classification for each Guarantee Term specified in the SLA and each classification can have 6, 3 or 5 classes depending on the particular cases applied. In Fig. 7
                         we show an example of a tree constructed from the analysis of a WSAG-compliant agreement with three Guarantee Terms where no particular cases are applied to the first one, the particular case C1 is applied to the Guarantee Term GT2 and the particular case C2 is applied to the Guarantee Term GT3. The leaves that represent the classes are depicted with different colors depending on the evaluation value of the Guarantee Term when such class is exercised (green for Fulfilled, red for Violated, yellow for Inapplicable and gray for Not Determined).

Once we have constructed the classification tree, we can make a decision about the parts of the tree that represent the most critical situations and need to be covered with a higher intensity. To do this, we apply standard combinatorial testing techniques in order to derive the test coverage items and generate the test cases.

When deriving the test coverage items, not all the combinations of classes will be used because we have to deal with two potential problems:
                           
                              •
                              The first one is related to the number of derived test coverage items, which can be unmanageable if the SLA is complex.

The second problem affects the testability of specific test coverage items because there are combinations that lead to non feasible situations to be tested.

To solve the first of these problems, we apply standard combinatorial testing techniques with the aim of obtaining a reduced (but significant) number of test cases. To address the second problem, we define specific constraints that the test suite has to satisfy to avoid generating non feasible test cases.

Once we have defined the classification tree and in order to derive the test coverage items, we use different combinatorial testing techniques. These techniques are defined in terms of parameters and values. When we use the constructed tree to test the SLA, the parameters are the classifications that represent the Guarantee Terms and the values are the classes that represent the test values.

After the identification of the parameters and their corresponding values, we derive the test coverage items by means of applying any of the testing techniques standardized in the ISO/IEC/IEEE 29119, which allow grading the intensity of the tests. These techniques are usually based on coverage and there are different coverage criteria that can be applied. The simplest coverage criterion is provided by each choice testing (also known as 1-wise) which requires that every class of every classification (Guarantee Term) represents a test coverage item and it must be exercised in at least one test case in the test suite. The most exhaustive coverage criterion is provided by All Combinations testing, which requires that every possible combination of classes must be included in at least one test case. Between them, a widely used coverage criterion is provided by pair-wise testing (also known as all pairs or 2-wise). Pair-wise testing requires that every possible pair of classes of any two classifications represent the test coverage items and they must be included in at least one test case.

In addition to existing testing techniques, it is necessary to define a strategy that guides the combinations depending on factors related to the content of the SLA and the behavior of the SBA (e.g., critical SBA functionalities). This means that we may want to be more exhaustive and apply a combinatorial testing technique in a specific part of the tree (for example, a branch or a group of classifications) whereas a less exhaustive technique may be applied in a different part of the tree.

As a result of this process, we obtain the test coverage items that lead to the generation of test cases. Each test case contains a set of test coverage items where each classification is included in the test case just once (so each Guarantee Term will be evaluated once in each test case). The content of the classes combined in the test coverage items will determine the inputs of the test case. In addition to this information, it is necessary to have some knowledge about the behavior of the SUT in order to specify the test case steps that exercise the classes. For example, different sources of information can be used such as UML State Transition Diagrams or Sequence Diagrams.

The derivation of the test coverage items may produce some combinations, which do not make sense and lead to non feasible test cases that cannot be executed. In this section we define specific constraints that allow excluding unfeasible combinations of test coverage items.

We distinguish between two types of constraints: implicit and explicit. The implicit constraints are based on the information that is represented in the terms of the SLA. The explicit constraints are identified through the analysis of the SUT. Both sets of constraints are always related to combinations of classes that represent feasible or non-feasible situations to be exercised, disregarding the characteristics of the SUT.

Based on the syntax and semantics structure of WS-Agreement, we can identify a set of implicit constraints that can help avoiding non feasible combinations of classes used to derive the test cases. These constraints are automatically obtained from the specification of the SLA.

We have defined the following set of implicit constraints for the general case where six classes are identified for each classification. If any of the two particular cases described in Section 4.1 has been applied to the involved classifications, these constraints must be suitably adapted.

Before discussing the constraints, let us assume that the selection of a class within a classification is represented by the functionev(GT
                              
                                 x
                              )=
                              CLy, where GTx is the classification that represents such Guarantee Term and CLy is the corresponding class.
                                 
                                    I1
                                    
                                       Guarantee Terms (GT) that affect the same method/service
                                    

Suppose that the method/service specified in the scope of the Guarantee Term GT1 is the same as the one specified in Guarantee Term GT2. If any of the classes CL5–CL6 of the classification that represents GT1 is selected to be combined in a test coverage item (the method/service specified in the Scope of GT1 is not executed), then one of the classes CL5–CL6 of the classification that represents GT2 must also be exercised. This constraint can be formally expressed as:
                                          
                                             
                                                
                                                   
                                                      
                                                         if
                                                         
                                                            
                                                               
                                                                  
                                                                     ∃
                                                                     i
                                                                     ,
                                                                     j
                                                                     ∈
                                                                     
                                                                        1
                                                                        n
                                                                     
                                                                     :
                                                                     Scope
                                                                     
                                                                        
                                                                           G
                                                                           
                                                                              T
                                                                              i
                                                                           
                                                                        
                                                                     
                                                                     =
                                                                     Scope
                                                                     
                                                                        
                                                                           G
                                                                           
                                                                              T
                                                                              j
                                                                           
                                                                        
                                                                     
                                                                  
                                                               
                                                               ∧
                                                               
                                                                  
                                                                     e
                                                                     v
                                                                  
                                                               
                                                               
                                                                  
                                                                     G
                                                                     
                                                                        T
                                                                        i
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                         ∈
                                                         
                                                            
                                                               
                                                                  
                                                                     C
                                                                     L
                                                                     5
                                                                     ,
                                                                     
                                                                     C
                                                                     L
                                                                     6
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         ⇒
                                                         
                                                            
                                                               e
                                                               v
                                                               
                                                                  
                                                                     G
                                                                     
                                                                        T
                                                                        j
                                                                     
                                                                  
                                                               
                                                               ∈
                                                               
                                                                  
                                                                     C
                                                                     L
                                                                     5
                                                                     ,
                                                                     
                                                                     C
                                                                     L
                                                                     6
                                                                  
                                                               
                                                            
                                                         
                                                         .
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    


                                       Guarantee Terms that have the same Qualifying Conditions
                                    

If some Guarantee Terms share the same Qualifying Condition and this is not met, then all the classifications that represent these Guarantee Terms must take the values of the classes CL3, CL4 or CL6.
                                          
                                             
                                                
                                                   
                                                      
                                                         if
                                                         
                                                         
                                                            
                                                               
                                                                  ∃
                                                                  i
                                                                  ,
                                                                  j
                                                                  ∈
                                                                  
                                                                     1
                                                                     n
                                                                  
                                                                  
                                                                  :
                                                                  
                                                                     
                                                                        Q
                                                                        C
                                                                        
                                                                           
                                                                              G
                                                                              
                                                                                 T
                                                                                 i
                                                                              
                                                                           
                                                                        
                                                                        =
                                                                        Q
                                                                        C
                                                                        
                                                                           
                                                                              G
                                                                              
                                                                                 T
                                                                                 j
                                                                              
                                                                           
                                                                        
                                                                     
                                                                  
                                                                  
                                                                  ∧
                                                                  
                                                                     
                                                                        e
                                                                        v
                                                                        (
                                                                        G
                                                                        
                                                                           T
                                                                           i
                                                                        
                                                                     
                                                                  
                                                                  ∈
                                                                  
                                                                     
                                                                        C
                                                                        L
                                                                        1
                                                                        ,
                                                                        
                                                                        C
                                                                        L
                                                                        2
                                                                        ,
                                                                        
                                                                        C
                                                                        L
                                                                        5
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         ⇒
                                                         
                                                            
                                                               e
                                                               v
                                                               
                                                                  
                                                                     G
                                                                     
                                                                        T
                                                                        j
                                                                     
                                                                  
                                                               
                                                               ∈
                                                               
                                                                  
                                                                     C
                                                                     L
                                                                     1
                                                                     ,
                                                                     
                                                                     C
                                                                     L
                                                                     2
                                                                     ,
                                                                     
                                                                     C
                                                                     L
                                                                     5
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         if
                                                         
                                                            
                                                               ∃
                                                               i
                                                               ,
                                                               j
                                                               ∈
                                                               
                                                                  1
                                                                  n
                                                               
                                                               
                                                               :
                                                               
                                                                  
                                                                     Q
                                                                     C
                                                                     
                                                                        
                                                                           G
                                                                           
                                                                              T
                                                                              i
                                                                           
                                                                        
                                                                     
                                                                     =
                                                                     Q
                                                                     C
                                                                     
                                                                        
                                                                           G
                                                                           
                                                                              T
                                                                              j
                                                                           
                                                                        
                                                                     
                                                                  
                                                               
                                                               ∧
                                                               
                                                                  
                                                                     e
                                                                     v
                                                                     
                                                                        
                                                                           G
                                                                           
                                                                              T
                                                                              i
                                                                           
                                                                        
                                                                     
                                                                     ∈
                                                                     
                                                                        
                                                                           C
                                                                           L
                                                                           3
                                                                           ,
                                                                           
                                                                           C
                                                                           L
                                                                           4
                                                                           ,
                                                                           
                                                                           C
                                                                           L
                                                                           6
                                                                        
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         ⇒
                                                         
                                                            
                                                               e
                                                               v
                                                               
                                                                  
                                                                     G
                                                                     
                                                                        T
                                                                        j
                                                                     
                                                                  
                                                               
                                                               ∈
                                                               
                                                                  
                                                                     C
                                                                     L
                                                                     3
                                                                     ,
                                                                     
                                                                     C
                                                                     L
                                                                     4
                                                                     ,
                                                                     C
                                                                     L
                                                                     6
                                                                  
                                                               
                                                            
                                                         
                                                         .
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    


                                       Guarantee Terms that have mutually disjoint Qualifying Conditions
                                    

If the Qualifying Condition of the first Guarantee Term is met then it is obvious that the Qualifying Condition of the second term must not be met and vice versa.
                                          
                                             
                                                
                                                   
                                                      
                                                         if
                                                         
                                                            
                                                               ∃
                                                               i
                                                               ,
                                                               j
                                                               ∈
                                                               
                                                                  1
                                                                  n
                                                               
                                                               
                                                               :
                                                               
                                                                  
                                                                     Q
                                                                     C
                                                                     
                                                                        
                                                                           G
                                                                           
                                                                              T
                                                                              i
                                                                           
                                                                        
                                                                     
                                                                     
                                                                     =
                                                                     
                                                                     !
                                                                     Q
                                                                     C
                                                                     
                                                                        
                                                                           G
                                                                           
                                                                              T
                                                                              j
                                                                           
                                                                        
                                                                     
                                                                  
                                                               
                                                               
                                                               ∧
                                                               
                                                                  
                                                                     e
                                                                     v
                                                                     
                                                                        
                                                                           G
                                                                           
                                                                              T
                                                                              i
                                                                           
                                                                        
                                                                     
                                                                     ∈
                                                                     
                                                                        
                                                                           C
                                                                           L
                                                                           1
                                                                           ,
                                                                           
                                                                           C
                                                                           L
                                                                           2
                                                                           ,
                                                                           
                                                                           C
                                                                           L
                                                                           5
                                                                        
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         ⇒
                                                         
                                                            
                                                               e
                                                               v
                                                               (
                                                               G
                                                               
                                                                  T
                                                                  j
                                                               
                                                            
                                                         
                                                         ∉
                                                         
                                                            
                                                               
                                                                  C
                                                                  L
                                                                  1
                                                                  ,
                                                                  
                                                                  C
                                                                  L
                                                                  2
                                                                  ,
                                                                  
                                                                  C
                                                                  L
                                                                  5
                                                               
                                                            
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         if
                                                         
                                                            
                                                               ∃
                                                               i
                                                               ,
                                                               j
                                                               ∈
                                                               
                                                                  1
                                                                  n
                                                               
                                                               
                                                               :
                                                               
                                                                  
                                                                     Q
                                                                     C
                                                                     
                                                                        
                                                                           G
                                                                           
                                                                              T
                                                                              i
                                                                           
                                                                        
                                                                     
                                                                     =
                                                                     !
                                                                     Q
                                                                     C
                                                                     
                                                                        
                                                                           G
                                                                           
                                                                              T
                                                                              j
                                                                           
                                                                        
                                                                     
                                                                  
                                                               
                                                               
                                                               ∧
                                                               
                                                                  
                                                                     e
                                                                     v
                                                                     
                                                                        
                                                                           G
                                                                           
                                                                              T
                                                                              i
                                                                           
                                                                        
                                                                     
                                                                     ∈
                                                                     
                                                                        
                                                                           C
                                                                           L
                                                                           3
                                                                           ,
                                                                           
                                                                           C
                                                                           L
                                                                           4
                                                                           ,
                                                                           
                                                                           C
                                                                           L
                                                                           6
                                                                        
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         ⇒
                                                         
                                                            
                                                               e
                                                               v
                                                               (
                                                               G
                                                               
                                                                  T
                                                                  j
                                                               
                                                            
                                                         
                                                         ∉
                                                         
                                                            
                                                               
                                                                  C
                                                                  L
                                                                  3
                                                                  ,
                                                                  
                                                                  C
                                                                  L
                                                                  4
                                                                  ,
                                                                  C
                                                                  L
                                                                  6
                                                               
                                                            
                                                         
                                                         .
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    

In order to identify explicit constraints, an analysis of the business logic of the SUT must be carried out. These constraints refer to some specific situations concerning the possible behavior of the SUT with regards to the ability to execute particular combinations of service methods, and affect the evaluation of the Guarantee Terms involved in the corresponding execution.

The specification of these constraints is manually done by the tester by using IF–THEN statements in which specific combinations of the GT evaluation values are allowed or forbidden.

The set of explicit constraints includes the following:
                                 
                                    E1
                                    
                                       The execution of a method/service implies the non-execution of another method/service.
                                    

It means that if a method/service Si (specified in the Scope of GTi) is executed then the method/service Sj (specified in the Scope of GTj) cannot be invoked or, formally:
                                          
                                             
                                                
                                                   
                                                      
                                                         if
                                                         
                                                            
                                                               ∃
                                                               i
                                                               ,
                                                               j
                                                               ∈
                                                               
                                                                  1
                                                                  n
                                                               
                                                               
                                                               :
                                                               
                                                                  
                                                                     e
                                                                     v
                                                                     (
                                                                     G
                                                                     
                                                                        T
                                                                        i
                                                                     
                                                                  
                                                               
                                                               ∈
                                                               
                                                                  
                                                                     C
                                                                     L
                                                                     1
                                                                     ,
                                                                     
                                                                     C
                                                                     L
                                                                     2
                                                                     ,
                                                                     
                                                                     C
                                                                     L
                                                                     3
                                                                     ,
                                                                     
                                                                     C
                                                                     L
                                                                     4
                                                                  
                                                               
                                                            
                                                         
                                                         )
                                                      
                                                   
                                                   
                                                      
                                                         ⇒
                                                         
                                                            
                                                               e
                                                               v
                                                               (
                                                               G
                                                               
                                                                  T
                                                                  j
                                                               
                                                            
                                                         
                                                         
                                                         ∈
                                                         
                                                            
                                                               
                                                                  C
                                                                  L
                                                                  5
                                                                  ,
                                                                  
                                                                  C
                                                                  L
                                                                  6
                                                               
                                                            
                                                         
                                                         .
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    


                                       The non-execution of a method/service implies the non-execution of another method/service
                                    

It means that if a method/service Si (specified in the Scope of GTi) is not executed then the method/service Sj (specified in the Scope of GTj) cannot be invoked.
                                          
                                             
                                                
                                                   
                                                      
                                                         if
                                                         
                                                            
                                                               ∃
                                                               i
                                                               ,
                                                               j
                                                               ∈
                                                               
                                                                  1
                                                                  n
                                                               
                                                               
                                                               :
                                                               
                                                                  
                                                                     e
                                                                     v
                                                                     (
                                                                     G
                                                                     
                                                                        T
                                                                        i
                                                                     
                                                                  
                                                               
                                                               ∈
                                                               
                                                                  
                                                                     C
                                                                     L
                                                                     5
                                                                     ,
                                                                     
                                                                     C
                                                                     L
                                                                     6
                                                                  
                                                               
                                                            
                                                         
                                                         )
                                                      
                                                   
                                                   
                                                      
                                                         ⇒
                                                         
                                                            
                                                               e
                                                               v
                                                               (
                                                               G
                                                               
                                                                  T
                                                                  j
                                                               
                                                            
                                                         
                                                         
                                                         ∈
                                                         
                                                            
                                                               
                                                                  C
                                                                  L
                                                                  5
                                                                  ,
                                                                  
                                                                  C
                                                                  L
                                                                  6
                                                               
                                                            
                                                         
                                                         .
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    


                                       The execution of a method/service implies the execution of another method/service
                                    

It means that if a method/service Si (specified in the Scope of GTi) is executed then the method/service Sj (specified in the Scope of GTj) must be invoked
                                          
                                             
                                                
                                                   
                                                      
                                                         if
                                                         
                                                            
                                                               ∃
                                                               i
                                                               ,
                                                               j
                                                               ∈
                                                               
                                                                  1
                                                                  n
                                                               
                                                               
                                                               :
                                                               
                                                                  
                                                                     e
                                                                     v
                                                                     
                                                                        
                                                                           G
                                                                           
                                                                              T
                                                                              i
                                                                           
                                                                        
                                                                     
                                                                     ∈
                                                                     
                                                                        
                                                                           C
                                                                           L
                                                                           1
                                                                           ,
                                                                           
                                                                           C
                                                                           L
                                                                           2
                                                                           ,
                                                                           
                                                                           C
                                                                           L
                                                                           3
                                                                           ,
                                                                           
                                                                           C
                                                                           L
                                                                           4
                                                                        
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         ⇒
                                                         
                                                            
                                                               e
                                                               v
                                                               (
                                                               G
                                                               
                                                                  T
                                                                  j
                                                               
                                                            
                                                         
                                                         
                                                         ∈
                                                         
                                                            
                                                               
                                                                  C
                                                                  L
                                                                  1
                                                                  ,
                                                                  
                                                                  C
                                                                  L
                                                                  2
                                                                  ,
                                                                  
                                                                  C
                                                                  L
                                                                  3
                                                                  ,
                                                                  
                                                                  C
                                                                  L
                                                                  4
                                                               
                                                            
                                                         
                                                         .
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    


                                       The non-execution of a method/service implies the execution of another method/service
                                    

It means that if a method/service Si (specified in the Scope of GTi) is not executed then the method/service Sj (specified in the Scope of GTj) must be invoked.
                                          
                                             
                                                
                                                   
                                                      
                                                         if
                                                         
                                                         
                                                            
                                                               ∃
                                                               i
                                                               ,
                                                               j
                                                               ∈
                                                               
                                                                  1
                                                                  n
                                                               
                                                               
                                                               :
                                                               
                                                                  
                                                                     e
                                                                     v
                                                                     
                                                                        
                                                                           G
                                                                           
                                                                              T
                                                                              i
                                                                           
                                                                        
                                                                     
                                                                     ∈
                                                                     
                                                                        
                                                                           C
                                                                           L
                                                                           5
                                                                           ,
                                                                           
                                                                           C
                                                                           L
                                                                           6
                                                                        
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         ⇒
                                                         
                                                            
                                                               e
                                                               v
                                                               
                                                                  
                                                                     G
                                                                     
                                                                        T
                                                                        j
                                                                     
                                                                  
                                                               
                                                               
                                                               ∈
                                                               
                                                                  
                                                                     C
                                                                     L
                                                                     1
                                                                     ,
                                                                     
                                                                     C
                                                                     L
                                                                     2
                                                                     ,
                                                                     
                                                                     C
                                                                     L
                                                                     3
                                                                     ,
                                                                     
                                                                     C
                                                                     L
                                                                     4
                                                                  
                                                               
                                                            
                                                         
                                                         .
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    


                                       The execution of a method/service is required
                                    

It means that a method/service Si (specified in the Scope of GTi) is mandatory to be invoked during the execution of the SUT.
                                          
                                             
                                                
                                                   
                                                      ∃
                                                      i
                                                      ∈
                                                      
                                                         1
                                                         n
                                                      
                                                      :
                                                      e
                                                      v
                                                      (
                                                      G
                                                      
                                                         T
                                                         i
                                                      
                                                   
                                                
                                                ∉
                                                
                                                   
                                                      
                                                         C
                                                         L
                                                         5
                                                         ,
                                                         
                                                         C
                                                         L
                                                         6
                                                      
                                                   
                                                
                                                .
                                             
                                          
                                       
                                    


                                       Additional constraints
                                    

Depending on the content of QCs or SLOs, the use of a specific test value of GT (GTi) may require also the use of a specific test value for another GT (GTj). The specification of this rule (E6) depends on the information of the Guarantee Terms. For example, consider the following two guarantee terms (left part of Fig. 8
                                       ) and a subset of the identified classes (right part of Fig. 8). If GT1 is violated (exercising CL2) then GT2 must be evaluated as Inapplicable because the Qualifying Condition (client=Premium) is not met. In this case, the class CL4 must be exercised (note that CL3 could not be exercised because the response time forced by CL2 of GT1 is more than 10s so the Service Level Objective of GT2 would never be met).

To address the generation of test cases, we have developed a tool that is able to automatically generate test cases by means of deriving test coverage items through the combination of the classes identified from the SLA Guarantee Terms, called SLACT (SLA Combinatorial Testing). This tool builds upon an existing combinatorial testing tool [29].

SLACT has been implemented to automate: (1) the identification of classes and the definition of the implicit constraints, both processes from the specification of the WS-Agreement, (2) the application of the combinatorial testing technique according to the coverage strategy selected by the tester, and (3) the generation of a test suite that satisfies the expected coverage with the least number of test cases and the analysis of the coverage of the classes of each Guarantee Term.

SLACT has five components, as shown in Fig. 9
                        , namely the SLA Parser, Constraints Generator, Executor, Analyzer and, finally, the User Interface. The roles of these components are discussed below.

The first of the SLACT components is called SLA Parser. This component is in charge of parsing the XML document that contains the SLA specified in WS-Agreement language and extracting the relevant information of the individual Guarantee Terms.

The second component of SLACT is called Constraints Generator. This component provides the following functions:
                              
                                 –
                                 Analyzing the information extracted from the parser to automatically obtain the implicit constraints.

Allowing the definition of the explicit constraints.

Allowing the selection of the combinatorial strategy.

The Constraints Generator is in charge of analyzing the information received from the SLA Parser in order to construct the classification tree by means of identifying the classifications and classes as it is described in Section 4.1. Also from the specification of the SLA, it automatically obtains the set of implicit constraints (taking the general case and the particular cases into account). Furthermore, through its User Interface (UI), SLACT allows the definition of the set of explicit constraints and the selection of the strategy that will guide the combinations to derive the test coverage items. Regarding this strategy, the tool allows the application of 1-wise, 2-wise or N-wise to all the classifications as well as the definition of a hybrid strategy that partially applies different combinatorial techniques to specific sets of classifications.

The third component of SLACT is called Executor. This component is in charge of executing the combinations of test cases with the appropriate parameters and values, considering the constraints provided by the Generator and the coverage strategy selected by the tester. Executor may be run in two different ways:
                              
                                 (i)
                                 It may perform multiple executions with the aim at obtaining different test suites (the number of executions can also be specified by the tester).

It may perform a single execution with a specific and previously identified input in order to obtain the test suite that contains the least number of test cases for the selected strategy.

This component makes use of the Pairwise Independent Combinatorial Tool (PICT) [29], which is a free tool developed by Microsoft that has been previously used in other testing approaches [69–71]. The core generation algorithm of PICT is based on a greedy heuristic optimized for speed. The output of Executor is the specification of the test suite that satisfies the selected coverage strategy with the least number of test cases.

The forth component of SLACT is called Analyzer. This component is in charge of two main tasks:
                              
                                 (i)
                                 It receives the results of the multiple executions and obtains the test suite that satisfies the expected coverage with the least number of test cases.

It also receives the specification of a test suite and performs an analysis of the test cases in order to assure that all of the classes are exercised and provides a report regarding the coverage of such classes.

The last component of SLACT is the User Interface (Fig. 10
                           ). This component allows:
                              
                                 –
                                 Selecting the XML document of the SLA.

Representing the relevant information of the SLA as well as the implicit constraints automatically identified.

Specifying the explicit constraints.

Selecting the combinatorial testing strategy to be applied and the execution conditions.

To illustrate the complete process of generating test cases for SLAs, we have carried out a case study based on an eHealth service-based application scenario that has been proposed by the European Project PLASTIC [30] and has been used in previous service-aware testing approaches [31–34]. This scenario represents the set of conditions that must be satisfied by the constituent services of an eHealth service based application as described in an SLA specified in WS-Agreement. This SLA can be downloaded from [72]. All the steps of the method described in Section 4 have been automatically performed using SLACT.

The behavior of the eHealth case study is represented in Fig. 11
                        . In summary, the application is deployed as a composite web service (WSHealth) that receives an alarm from patients and triggers appropriate actions to solve such alarms. When an alarm arrives at the system, this service finds the list of professionals who can take responsibility for handling the incident by invoking a service called WSRegistry. WSRegistry provides a list of IP addresses of the professionals who are available at that moment depending on the type of the alarm (Emergency or Not Confirmation). These professionals (WSDoctor or WSSupervisor) are connected to the system through wired or mobile devices. Thus, the conditions related to these connections are different. If a doctor is contacted, (s)he may get measures from medical devices (available as WSMedicalDevice services) deployed in the patient's location. If the contacted agent is a supervisor, (s)he should arrange an appointment for the patient using the calendar service WSCalendar.

The conditions that have to be fulfilled by the constituent services of this eHealth system are specified in an SLA using WS-Agreement. The SLA contains 14 Guarantee Terms related to 6 different services and 9 service methods. Twelve of these terms present the whole structure of a Guarantee Term, i.e., a scope, a Qualifying Condition and a Service Level Objective. The other two Guarantee Terms do not have Qualifying Condition.

We have applied the steps described in Section 4.1 in order to construct the tree by means of identifying the classifications and classes from the eHealth SLA. The results of this process are summarized in Table 1
                        . The services and methods that constitute the case study are represented in the first column. The classifications at the lowest level of the tree are represented in the second column. The particular cases applied to identify the classes are outlined in the third column. The identifiers of the classes of the tree are represented in the last column. In this scenario, the case C1 is applied to GT5 and GT12 (only CL1, CL2 and CL5 are identified) and the case C2 is applied to all the other Guarantee Terms (class CL6 is never identified).

This table is a simplified representation of the classification tree without including the nodes that represent the compositor elements of WS-Agreement. The classifications at the lowest level represent the Guarantee Terms of the SLA and the classes represented in the leaves of the tree are related to the identified test values for each Guarantee Term. Hence, the number of identified classifications is 14 and the number of classes is 66. This model is the basis to generate the test cases by means of deriving the test coverage items. This task is performed by combining the classes using specific combinatorial criteria and specifying the rules that guide such combinations. In this case study, the derivation of test coverage items involves the combination of 14 classifications. Twelve of these classifications have 5 classes each. The other two classifications have 3 classes each.

In addition to the construction of the classification tree, we have identified the set of implicit and explicit constraints that will guide the combinations of the classifications and their classes. The implicit constraints are automatically obtained whereas the explicit constraints are specified through the User Interface of SLACT (see Fig. 10). After analyzing the content of the SLA and relevant information regarding the behavior of the SUT, 26 constraints have been identified in order to guide the generation of test cases. All these constraints are represented in Table 2
                        . The identifier of each constraint is represented in the first column. The reference to the implicit or explicit applied constraint is represented in the second column. The Guarantee Terms whose values will be affected by the constraint are represented in the third column. Finally, a brief explanation of the constraint is provided in the last column.

Once we have identified the constraints that should influence the generation of test cases, it is necessary to select the strategy for combining the parameters and their values, and obtaining the test coverage items that will be used during testing. In general three different strategies can be applied in order to grade the level of intensity of the obtained test suites:
                           
                              (i)
                              
                                 Each choice testing (1-wise) to all the classifications.


                                 Pair-wise testing (2-wise) to all the classifications.


                                 Hybrid.

The third strategy is a hybrid of the other two which involves applying pair-wise testing to a specific set of Guarantee Terms and each choice to the rest. Particularly, in the selected case study, we have applied pair-wise to the most critical functionalities of the SUT (the actions that are triggered after receiving an alarm of type Emergency). It is remarkable that the Guarantee Terms that are related to the arrival of an Emergency are dispersed in the SLA and, thus, the classifications that represent such Guarantee Terms (GT1, GT3, GT8, GT9, GT12, GT13 and GT14 of Table 1) are represented in different branches of the tree. This hybrid strategy provided an intermediate level of intensity between the weakest coverage provided by the each choice coverage and the strongest intensity provided by the pair-wise coverage.

Bearing these considerations in mind, we have executed SLACT for each of the three coverage strategies, and run the combinations for each strategy several times and get the output with the lowest number of test cases that satisfies such coverage strategy. In order to check the behavior of the combinations, for each strategy we have run the combinatorial testing tool 3000 times and we have obtained a minimum number of 10, 42 and 32 test cases for the each choice, pair-wise and hybrid strategies respectively.

The results of these multiple executions are represented in Fig. 12
                        . The x-axis in the figure represents the size of the obtained test suites (the number of test cases generated in each test suite) provided by the tool. The y-axis represents the number of times each size is obtained. For example, for the each choice strategy, a test suite with 11 generated tests cases has been obtained more than 1200 times.

In the case of the each choice strategy, the results obtained for SLACT presents a mean (μ) of 11.37 (number of test cases) and a standard deviation (σ) of 0.91. To be more specific, 95% of the test suites contain approximately between 10 and 13 test cases. In the case of the pair-wise strategy, the parameters are μ
                        =47.68, σ
                        =1.48 and 95% of the executions have provided a test suite with a number of test cases between 45 and 50. Finally, the hybrid strategy is represented by μ
                        =34.84, σ
                        =1.22 and 95% of the test suites would contain between 33 and 37 test cases.

Analyzing the results for each applied coverage strategy and starting with the first one (each choice), we have obtained a test suite that contains 10 test cases (the output file is represented in Fig. 13
                        ). In this file, the classifications of the tree (Guarantee Terms) are represented in columns and the test cases obtained through the combination of the classes are represented in rows. In order to describe how to derive test cases from the combinations of the classes to a test case, we consider, for example, test case number 6, outlined in the figure. The test case is generated by analyzing, according to the specification of the SLA, the meaning of each of the classes contained in such test case as well as the knowledge about the behavior of the SUT. In this test case, we are exercising the situation when an alarm arrives to the eHealth system. The steps included in this test case and their corresponding exercised classes are represented in Table 3
                        . To execute the test cases, we will have to sequentially exercise the steps described in such table.

With these ten test cases, 64 of the 66 classes are exercised at least once (except CL5 for GT1 and GT2 that are constrained by the explicit rule with ID 19 of Table 2 and, thus, they are impossible to be exercised) and the coverage report provided by the Analyzer component of SLACT is represented in Table 4(a). In the first column we represent the set of Guarantee Terms and in the first row we represent the classes obtained for each GT. In the table, each cell specifies the number of times such class is exercised within this test suite. For example, the class CL1 identified from the specification of GT5 is exercised in 8 test cases for this strategy. If there is a hyphen (-) in a cell, it means that the class represented in such column was not identified due to the application of the particular cases explained in Section 4.

Regarding the second of the applied coverage strategies (pair-wise), the test suite with the least number of test cases that we obtained contained 42 test cases. The number of test cases obtained is higher than in the 1-wise strategy because, now, each potential pair of classes of different classifications (Guarantee Terms) is included in at least one test case. The results provided by the Analyzer regarding the coverage for the classes of each Guarantee Term are also represented in Table 4 (b). As it can be seen in this table, all classes in the 2-wise strategy have been exercised more than in the case of each choice. This indicates a higher level of intensity in the tests. Here again and due to the specification of the explicit rule 19, there are two classes that are never exercised (CL5 for GT1 and GT2).

Finally, we have also applied the hybrid-wise strategy with the aim of grading the intensity of the tests depending on the critical functionality of the eHealth system. With this strategy, the smallest test suite we have obtained contains 32 test cases. The results provided by the Analyzer are represented in Table 4 (c). There are some classes that are as much tested as in the pair-wise strategy because they are related to Guarantee Terms that affect the more critical part of the SUT (Emergencies). On the other hand, there are other classes that are covered with less intensity, representing non-critical situations of the SUT.

All the results derived from the coverage of the different classes are synthesized in Fig. 14
                        . In the figure, the x-axis represents the Guarantee Terms and their corresponding classes and the y-axis represents the number of times each such class is exercised within the applied coverage strategy. As shown in the figure, in the hybrid strategy there are specific classes of Guarantee Terms that are much more exercised than others (for example, CL1 of GT1, CL2 and CL3 of GT2 or CL1 of GT5). These classes are related to situations that are considered critical for the behavior of the SUT (e.g., the arrival of an alarm of type Emergency). Thus, we have decided to combine them more thoroughly than classes related to a non-critical behavior of the SUT.

Analyzing the results obtained from the applied strategies, we hereafter highlight some considerations. First of all, it is the each-choice strategy the one that allows obtaining the smallest test suite whereas the pairwise strategy provides the largest set of test cases. Hence, the each-choice strategy is useful when, on the one hand, the criticity of the application is not high in the sense that an SLA violation does not lead to serious consequences for the users and, on the other hand, specific factors such as deadlines or budget hinder the design and execution of more detailed tests. Likewise, the application of pairwise testing is effective when the application needs to be exhaustively tested and we have fewer limitations that prevent from executing more thorough tests.

As intermediate solution we recommend to apply a hybrid testing strategy. By analyzing the application under test and identifying its more critical functionalities, we could design an appropriate strategy that allows obtaining a good balance between the number of generated tests and the intensity of such tests within the aforementioned parts of the application. In this case, we could decide to apply pairwise testing to the most critical functionalities whereas each-choice testing could be apply to the rest, as we have previously described.

Bearing these strategies in mind, the number of generated test cases depends on the strategy we choose when designing the tests. The more intensity we decide to test the SUT, the higher number of test cases will be obtained. However, even when the SUT has a complex SLA with many guarantee terms associated, the election of the each-choice testing allows obtaining a reduced number of test cases so the scalability does not represent a problem.

In addition to the choice of the testing strategy to be applied, the definition of the explicit constraints is another task that needs to be manually performed. As we have previously described, the use of the explicit constraints allows us to avoid the obtaining of non-feasible combinations of test requirements concerning the behavior of the SUT. If these explicit constraints are not defined and used, our approach allows identifying the test requirements and performs the combinations although the results would be less efficient. In this case, the tester would have to analyze each of the identified combinations of test requirements and, consequently, the test cases in order to detect situations that could not be exercised. Due to this, we would recommend to analyze the characteristics of the SUT and define the constraints before the obtaining of the tests because this is a task that is performed only once. After that, such constraints can be used to obtain different set of tests by applying the aforementioned testing strategies.

In our contribution, the most effort and time consuming tasks are the definition of the explicit constraints and the final derivation of the test cases from the identified combinations of test requirements because the identification of the test requirements, the obtaining of the implicit constraints and the combination of such requirements are fully automated. In this sense the scalability of the approach in terms of time-consuming is not a problem if we had to manage a SLA with a higher number of guarantee terms because the executions of SLACT are measured in the scale of a few seconds.

In this section we discuss the main limitations of this approach.

First of all, we have used the WS-Agreement [6] standard language in order to specify the SLAs that are taken as the test basis. In spite of the fact that many languages have been proposed to standardize the specification of SLAs, for example, WSLA [57], WSLO [58], SLANG [59,18], WS-QoS [62] or WS-Policy [60], the specification language that has received more attention regarding the testing of SLAs has been WS-Agreement, at least from the academic domain. As WS-Agreement presents a generic syntax, we envision that its derived outcomes could be extrapolated to any other existing SLA specification language.

In addition to this, in our work we are analyzing the content of the individual guarantee terms in order to generate the tests. However, an SLA may represent a hierarchy of terms that are logically combined using the specific compositor elements. As we state in our future work, we will improve the generation of tests by means of taking into account the logical structure of the agreement.

Likewise, in this work we are considering the content of the Qualifying Condition and the Service Level Objective elements as a whole, without analyzing the internal conditions of both elements. Hence, we say that the QC (or the SLO) is satisfied or not but we do not take into account whether the QC (or the SLO) contains a more complex expression that needs to be evaluated. We consider that a more detailed analysis of such elements could help to refine and improve the generated tests although the size of the test suite could grow and become unmanageable.

Finally, we have described that the SLA is our test basis and its analysis allows us to generate the test cases. From the content of the SLA, we use the developed tool, SLACT, to obtain the set of test requirements that will be later exercised through the generated test cases. However, any change in the specification of the SLA (even if it is a minor change) affects the identification of the tests so a new set of test requirements needs to be identified and, consequently, new test cases are generated without reusing the previous one.

@&#CONCLUSIONS AND FUTURE WORK@&#

In this article we have been concerned with the problem of testing service based applications (SBAs) regulated by Service Level Agreements (SLAs) that have been negotiated between the service provider and consumer. To address this problem, we propose a step-wise method that generates test cases from a specification based on WS-Agreement by means of defining how to apply existing testing techniques used in the industry. We have also developed tool, called SLACT (SLA Combinatorial Testing), to automate the process.

The approach is based on identifying a set of classifications and classes from the content of the SLA in order to construct a hierarchical model using the Classification Tree Method. From this structure, we apply standard combinatorial testing techniques in order to derive the test coverage items through the combination of the classes represented in the leaves. We have applied three strategies that provide different levels of thoroughness in the resulting test suites.

The main benefit of our work is that supports the automatic generation of a set of test cases from the specification of SLAs, described in WS-Agreement. The execution of the test cases allows detecting problems in the SBA proactively, i.e., before such problems lead to undesired consequences for the stakeholders who have agreed the SLA. In addition to this, our approach can assure that the number of generated test cases will be manageable and such test cases are feasible to be executed in the SBA. Furthermore, it gives the tester the possibility to decide whether the SBA should be tested with more or less thoroughness or even determine which parts of the SBAs should be tested and with what degree of intensity.

The whole process has been automated by SLACT. SLACT receives the SLA and automatically identifies the classes and extracts the implicit constraints. The tool can be used to define explicit testing constraints and selecting a combinatorial strategy for testing. Based on these inputs, SLACT generates different test suites and provides one that, while satisfying the expected coverage, contains the least number of test cases.

The approach has been validated using an existing eHealth service based application where we applied the above three testing strategies obtaining three different test suites with 10, 42 and 32 test cases respectively. Thus we were able to obtain a reasonable and manageable number of tests for a critical scenario.

In future work, we will focus on improving the definition of tests using additional information contained in the SLA and taking both the logical and hierarchical structure of the agreement into account. We expect to be able to identify new cases for testing by applying existing standard coverage criteria as, for example, the Modified Condition Decision Coverage (MCDC) defined in the RTCA/DO-178B standard [73]. In relation to this, we will have to evaluate the testability of these test situations and decide which of them can be exercised through the generation of tests and which of them should be checked at runtime using monitoring techniques. Finally, we are planning to study the feasibility of improving SLACT with the aim of integrating these new test criteria.

@&#ACKNOWLEDGMENT@&#

This work has been partially funded by the Department of Science and Innovation (Spain) and ERDF funds within the National Program for Research, Development and Innovation, project Test4DBS (TIN2010-20057-C03-01), project PERTEST (TIN2013-46928-C3-1-R) and FICYT (Government of the Principality of Asturias) Grant BP09-075.

@&#REFERENCES@&#

