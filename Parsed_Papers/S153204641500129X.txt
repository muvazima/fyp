@&#MAIN-TITLE@&#A privacy preserving protocol for tracking participants in phase I clinical trials

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We present a privacy-preserving protocol to detect concurrent trial participants.


                        
                        
                           
                           We present a name representation scheme resilient to frequency attacks.


                        
                        
                           
                           The accuracy of the protocol is similar to standard non-secure methods.


                        
                        
                           
                           For a database size of 20,000, the private query time is under 40s on 32 cores.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Clinical trial

Phase 1 volunteer

Secure multi-party computation

@&#ABSTRACT@&#


               
               
                  Objective
                  Some phase 1 clinical trials offer strong financial incentives for healthy individuals to participate in their studies. There is evidence that some individuals enroll in multiple trials concurrently. This creates safety risks and introduces data quality problems into the trials. Our objective was to construct a privacy preserving protocol to track phase 1 participants to detect concurrent enrollment.
               
               
                  Design
                  A protocol using secure probabilistic querying against a database of trial participants that allows for screening during telephone interviews and on-site enrollment was developed. The match variables consisted of demographic information.
               
               
                  Measurement
                  The accuracy (sensitivity, precision, and negative predictive value) of the matching and its computational performance in seconds were measured under simulated environments. Accuracy was also compared to non-secure matching methods.
               
               
                  Results
                  The protocol performance scales linearly with the database size. At the largest database size of 20,000 participants, a query takes under 20s on a 64 cores machine. Sensitivity, precision, and negative predictive value of the queries were consistently at or above 0.9, and were very similar to non-secure versions of the protocol.
               
               
                  Conclusion
                  The protocol provides a reasonable solution to the concurrent enrollment problems in phase 1 clinical trials, and is able to ensure that personal information about participants is kept secure.
               
            

@&#INTRODUCTION@&#

Although altruism is often considered the primary motive for patients to participate in clinical trials, many phase I clinical trials rely on healthy volunteers [1]. According to DeMets et al.
                     [20], clinical trials involving new drugs are commonly classified into several phases (labeled 0 to 5), which can span many years. Phase 1 clinical trials usually involve testing a drug on 20–100 healthy volunteers to determine whether the drug is safe (at certain dosages) to further check for efficacy on a larger scale. In the case of healthy volunteers, the main reason for participation is monetary compensation [3,4,7,19,27,34,35,44,70]: individuals are attracted to the promise of large sums for seemingly little effort or skill needed on their part. Unlike patients, there are no potential benefits that healthy volunteers might gain from the drug or intervention that is being tested on them. Therefore, it is not surprising that the compensation provided by those running the trials is the main reason that healthy volunteers choose to participate. Some argue that providing monetary compensation to participants could result in coercion to the poor and those in need [22,26,27,49,51,67,71]. Others argue that it is only fair to compensate healthy research subjects because they gain no other benefit from their participation [25,49,50].

From a research perspective, it appears that without monetary compensation, it would not be possible to recruit a sufficient number of healthy volunteers to fill the growing demand [3,4,7,19,34,35,44,70]. It has become more common for healthy volunteers participating in phase I clinical trials to earn at least part of a living that way [21,22,26,27,51,65]. There is an underground culture represented by publications like Guinea Pig Zero to assist those looking for trials to participate in [25] and websites that inform subjects of phase I trials available in their area [22].

Volunteering for well-paying studies may not in and of itself be detrimental. However, of concern to researchers, trial managers, contract research organizations (CROs), and regulatory bodies is the possibility that some research subjects may enroll in clinical trials concurrently [22,27,34,35,70] or sequentially without regard to the appropriate “cleansing” or “washout” period between trials—a period of at least 30days, and up to many months depending on the trial/intervention [3,7,27,34,35,44,70].

The practice of engaging in studies as an ‘overlapping trial participant’ can lead to nontrivial problems for phase I trials. These include introducing error and bias into the results of the trial, and an unnecessary early stop of the study due to elevated adverse events.

The potential for error and bias in the results may be higher in trials that include overlapping trial participants. The act of participating in a clinical trial can affect a subject both physically and mentally [22,26,35,44,51,65,67]. There are drug effects, or physical effects due to the intervention, that can potentially endure after the trial has ended [35]. These practices can lead to greater risk to the participant as well as greater potential bias to the results of the studies. A correlation has been found between reported adverse events and repeat participation, finding that adverse events were more common in those with a longer history of trial participation [35]. A safe drug could be deemed unsafe, or worse, an unsafe drug could be deemed safe due to the interaction between drugs. This raises questions on whether participants’ experiences work to bias the results. Will lasting drug effects carry over to the next trial? Will any omissions or untruthfulness result in harm to the subject or inaccuracy in the results? [27,67].

In clinical trials, stopping rules are typically defined in the study protocol to limit the amount of harm to participants [45]. If a percentage of serious adverse events is observed which exceeds the predefined limit, the trial is stopped early. Phase I trials typically involve the first introduction of a new drug to humans, and are testing for the maximum tolerable dosage [59]. These trials involve a small number of participants, and continuation of the trial is based on observed toxicity of the drug. To limit harm to participants, the acceptable level of toxicity is determined ahead of time. If participants do not show signs of toxicity, the drug dose is increased, if they do then the trial is stopped. Because of the small cohorts of participants in phase I trials, a very small number of individuals experiencing adverse events can have a significant impact on the overall outcomes of the study and may result in an unnecessary early stop. An early stop could lead to an under-dosage in future studies of the same compound, diluting its therapeutic effect.

Participants trying to be enrolled in multiple overlapping trials have adopted various strategies to increase the chances of being accepted. For instance, through their participation in trials, experienced participants may learn what criteria researchers are looking for in a subject and how to behave within a trial to be considered a ‘good subject’. It has been suggested that once a person enrolls in a second study, they have the experience needed to appear as a good participant to ensure that they are retained in the trial and obtain the promised financial reward [4,22,26,51,65]. It has also been identified that some participants choose to withhold information or can be untruthful about the information that they provide to increase the chances of being screened in, for example, by taking measures to ensure that drugs will not be detected in the screening tests (by exercising or taking herbal remedies) [27,65]. Not all ‘overlapping trial participants’ withhold information or are untruthful, but current evidence shows that dishonesty among these individuals is not uncommon [4,8,22,26,27,35,44,51,65,79].

According to ethical and legal guidelines regulating the conduct of research with human subjects, investigators are obliged to protect research participants from harm [38,54,58]. This holds true for all participants, even those who are not completely honest about their past or current participation in trials.

As noted in the review in Appendix A, where tracking systems have been deployed, there is evidence that between 0.9% and almost 9% of volunteers are concurrently or have recently enrolled in a trial [8,35,58,79]. However, knowledge of the existence of a tracking system may have resulted in fewer overlapping participants attempting to enroll [8,58], meaning that these numbers should be seen as a floor.

At the time of writing, the median enrollment for the 19,571 phase 1 clinical trials in clinicaltrials.gov was 33. If, say, 1% of participants in phase 1 trials are concurrently or have recently participated in other trials, it would mean that 1 in 3 trials are at risk of elevated adverse events unrelated to the compound under investigation, on average.

Therefore, for practical and ethical reasons it is important to identify such overlapping trial volunteers and exclude them from participating.

Organizations and sites that run phase 1 clinical trials have attempted to manage this problem by creating comprehensive registers of all participants in trials within a particular geographic area [8,79]. For example, one system used in Florida retains fingerprint (biometric) information about participants so that individuals can be checked against the database when they volunteer for a new trial [8]. In some cases, if a participant is found to be enrolled in overlapping trials they are excluded from those trials as well as any future trials within the institution or even the geographic region [79]. The creation of comprehensive tracking databases with personally identifying information about trial participants that are shared among multiple phase I sites creates privacy risks for the participants and regulatory risks for the sites. For example, if there is a data breach at the database the personal details of all those participating in trials would be exposed.

In this paper we describe a secure protocol for tracking individual participants across multiple sites without creating an identity database holding information in the clear. The protocol allows sites to identify those individuals who participate in multiple trials concurrently but also provides strong privacy guarantees to the participants.

@&#METHODS@&#

In this section we describe the secure protocol for tracking trial participants. The basic configuration is that there are multiple phase 1 sites that are members of a consortium, and all members of this consortium contribute information about the participants in their phase 1 trials to a central database (CD). The consortium members need to be within a small geographic distance of each other (e.g., a metropolitan area) since volunteers will not generally travel long distances to enroll and participate in multiple trials. When a site needs to check if a particular participant is concurrently enrolled in another trial within the consortium, they would run a query against the CD.

Checking against the CD proceeds in two steps that are consistent with the typical screening workflow for phase 1 clinical trials. In the first step individuals contact the site and volunteer over the telephone (they have usually heard about the study through advertisements or friends and acquaintances, or sometimes they are contacted directly by the site because they had volunteered for studies there in the past and were considered a good candidate). Those who pass the telephone screening are invited to come to the site for additional tests. These additional tests may include the completion of detailed questionnaires, and possibly laboratory tests on blood and urine that is collected at the site.

In the second step, volunteers are screened again when they come for the visit to the site. This ensures that they have not enrolled in other studies since the telephone interview, and they are asked to provide documentation to confirm their identity and other demographic information used for the query.

Below we provide a set of basic requirements for an efficient privacy preserving protocol that can be used to track phase 1 participants:
                           
                              1.
                              The protocol should not create a database with participant identity information in the clear. The operator of the CD must never know the identity of the participants in the database, and if the CD is compromised it should not be possible for an adversary to determine the identity of the participants.

The sites must be able to query the CD and only learn whether the volunteer information provided in the query matches a participant in the CD. Sites must not be able to view or access all records in the CD.

The site queries should allow exact matching (e.g., on health insurance card numbers) or approximate matching (e.g., for names).

In practice many sites are computationally constrained, and therefore any secure protocol should minimize the computational and communication requirements of the sites.

These requirements provided a framework for evaluating existing protocols and designing our own protocol.

There are several approaches that have been used in the past for matching patients or querying patient databases securely: secure equijoin, secure set intersection, private information retrieval, splitting strings into q-grams, Bloom filters, using reference tables, Sparse Map, and phonetic encoding. We examine examples of these types of protocols below.

In the secure equijoin protocol by Agrawal et al. [2], each of the two parties has her own unencrypted dataset. Using a hash function and commutative encryption they propose a number of secure protocols including computing the equijoin, set intersection, and set intersection size of the two datasets. There is no third party involved in these protocols. Their protocols, however, require both parties to perform computations on the other’s encrypted records. Applying their protocol to our setting, therefore, would require sites to perform significant computations on the encrypted records of the CD, which does not fit with our fourth requirement.

A generalization of the Agrawal et al. protocol by O’Keefe et al. uses a different topology [53]. Here there are two data custodians with databases holding information about overlapping individuals, and a third entity that wants to receive a linked data set without the protocol revealing personal information. In this protocol all parties must also perform significant computations, which would not meet our requirements.

Freedman et al. [31] proposed a private record linkage protocol in which a user generates a polynomial setting the roots to items in her dataset, and sends the encrypted coefficients to a server. For each file in the server’s dataset, the server homomorphically evaluates the user’s polynomial and returns the encrypted result to the user. The user decrypts and checks the result: if the server’s record is contained in the user’s database, the polynomial evaluates to 0. The result is a random number otherwise. There is no third party in this protocol. Like Agrawal et al., applying this solution to our setting would require sites to perform computations on the entirety of CD’s encrypted database, and thus does not meet our limited computing capacity requirements.

Private information retrieval is a set of methods that allow a user to retrieve an item from a server owning a database without revealing the retrieved item to the database owner [10]. Therefore, it is assumed that the dataset in the server is not encrypted. This is also the case in the symmetric private information retrieval [48], in which privacy is preserved for both the Sender and the Receiver. That is, on the one hand the Sender should not learn any information about the index of the record the Receiver is interested in, and on the other hand, the Receiver should not learn any information about the database, beyond the content of the record defined in the query.

Churches and Christen [16] presented a protocol that requires splitting a string into q-grams, i.e., a group of smaller strings based on consecutively splitting the original string into smaller groups. Each string would be represented by a power set of its subgroups. Each q-gram would be hashed using a common secret key for the two database owners. These owners create collections with the group of q-grams, the number of q-grams in the group, and the total number of q-grams, and then send them to a third party for matching. The authors also recommend inserting dummy q-gram groups in order to prevent frequency attacks. This protocol has a large communication and computational cost [14] because it relies on power sets of q-grams [15,72] and is still susceptible to frequency attacks for the groups of q-grams of size one [11,69].

Schnell et al. [63] presented a 3-party protocol for private record linkage based on Bloom filters. When comparing string fields, the authors split the string into q-grams that are then hashed using a number of different hash functions to calculate indices in the Bloom filter, which will be set to one. The third party will compare Bloom filters using the dice coefficient approach. The authors claim that their method produces similar results to non-encrypted identifiers and is superior to phonetic encoding. However, they do face the risk of frequency attacks especially against short names.

Durham improved on the Bloom filter technique of Schnell et al. [63]. Her technique is more secure by random bit sampling from attributes: instead of building a separate Bloom filter for each field in the record, Durham suggests representing the entire record in a single Bloom filter
                        [23]. She suggests that her method makes frequency attacks less likely because the domain from which the single filter is constructed is much larger than separate domains for separate filters. She suggests a private blocking method based on Bloom filters locality sensitive hashing (LSH). She describes LSH as a method that can map objects into partitions in a way that similar objects will share a partition with a high probability while different ones will not. A hamming distance method (number of positions at which strings differ) is used to create partitions from the Bloom filters record encodings. Durham suggests that it is not obvious how an attacker can use the properties of the partitions to determine information about the plain text values, but does not provide a solid privacy guarantee.

Randal et al. [57] use the same Bloom filter method developed by Schnell, but they don’t show that it satisfies the recommendation of Kuzu for privacy protection against cryptanalysis. They make the size of the Bloom filter smaller and reduce the number of hash functions (both by 10), using a 100 bit Bloom filter instead of 1000 and 3 hash functions instead of 30. There is no discussion of the security of their Bloom filter design. They use bigrams to populate it though they have also tried it with trigrams and it gave similar results. The blocking they use is by hashing the soundex [61] of the surname with first initial but the soundex mostly applies to the beginning of a name so it is questionable if adding the first initial helps. They also hash the date of birth for blocking which can lead to statistical attacks.

Pang and Hansen [55] suggested a protocol where two database owners agree on a set of common reference strings. Each party will compare each appropriate identifier from each record to the entire set of reference strings. The comparison produces a distance value. If that distance is less than a chosen threshold, the corresponding reference string is encrypted and added to a group containing an identifier number and the distance value. Each identifier is represented by a series of groups as defined earlier. Both parties send their groups to a third party that will compare them against each other. To classify two identifiers as a match, their distances from a common reference string should be below a specified minimum value. The performance and accuracy of this protocol is variable: it is based on the selection of the set of reference strings. Bachteler et al. conducted an empirical study that showed this protocol has poor precision and recall and requires longer run times than other protocols in the literature [5].

Scannapieco et al. [62] argued that cryptographic protocols are inefficient and proposed an efficient protocol that embeds the strings of the records to be matched in a vector space. The space is built from random strings and strings from the records are embedded using the Sparse Map method [37]. Both database owners send their vectors to a third party that compares them using the standard Euclidean distance between them. To make the protocol more efficient, using Sparse Map, the authors reduce the space dimension by applying a greedy re-sampling method and by distance approximations. However, the methods to achieve the performance gains negatively affect the accuracy of the protocol. Another problem with this protocol is that the third party will be able to mount a statistical attack based on the data it receives [33].

Karakasidis et al. [42] suggested a method using phonetic encoding to account for typing mistakes, coupled with encryption for privacy. The method also injects fake phonetic codes to protect against frequency attacks. However, phonetic encoding yields more false positive matches than string similarity functions [32].

The closest protocol that can address the problem described here is the secure equijoin proposed by Kantarcioglu et al. [40]. In that protocol it is assumed that two data providers have already submitted their encrypted records to a data storage site. After submitting a query from a client to the data storage site, the data storage site will compute the join of the two data sets and will send the results to the key holder, who owns the private key of the cryptosystem. The key holder will decrypt the match results to find the matches, and will send the final result to the client. This protocol has a configuration which is different from our problem (i.e., it assumes a researcher is trying to match records in two independent databases rather than running a query against a database) and does not consider probabilistic matching.

Yakout et al. [78] build on the protocol of Scannapieco et al. [62] and try to optimize it by reducing the number of candidate pairs to be compared. They do not require a third party. However, the use of the secure scalar product protocol to do the comparisons requires extensive computations and thus rendering their two-party protocol less efficient than its predecessor [62]. Yakout et al. developed a new protocol [77] that has acceptable performance for large datasets but it is only capable of handling string fields at the moment. Their experimental evaluation was limited to datasets that contain only the first name and last name fields.

Karapiperis and Verykios [43] provide a technique based on Bloom filters and a homomorphic matching technique. On top of the privacy concerns over Bloom filters, their protocol also requires a trusted third party which could present additional drawbacks in terms of administrative approval when it comes to healthcare data because it is difficult to earn trust then it comes to highly sensitive information. We don’t consider a protocol requiring a trusted third party for use in a real-world scenario.

Wen and Dong [75] present two protocols based on Bloom filters and garbled Bloom filters (an element is first split into multiple shares then the shares are inserted in the filter) for exact matching and approximate matching. While these protocols prove to be efficient for large databases, the Bloom filter data structure has been subjects to many recent successful attacks and the privacy provided under this structure is questionnable.

Though using Bloom filters has growing interest in the literature, it has also been shown that such filters are not mature enough to provide privacy guarantees. Kuzu et al. [47] presented the first cryptanalysis attack on Bloom filter encodings and showed that they were able to recover some the names in a database correctly. Researchers at the German Record Linkage Center [52] claim that little research on the security of Bloom filters has been published and present an attack that requires less computational effort and less resources than the one presented in [47] to be successful. They also offer techniques to make their attack more difficult to achieve but not infeasible. While the two attacks in [47] and [52] were based on Bloom filters that encode only one field at a time, and some researchers claiming that encoding more than one field in the Bloom filter makes it harder to be decoded, Kroll and Steinmetzer [46] present the first successful automated attack on Bloom filters encoding more than one identifier. In light of these recent attacks that are evolving and becoming less computationally demanding, we do not recommend that Bloom filters be used at the moment where strong privacy guarantees are required. The medical domain requires a strong privacy measure because patient and participant data is of a very sensitive nature and is the subject of many laws.

Our TRACK protocol allows the tracking of participants to ensure that they do not enroll in multiple concurrent trials. For the purpose of our description we assume that a concurrent trial is one where the washout period has not passed from when a participant has completed the trial. This can be easily extended to incorporate other criteria, such as volume of blood drawn during the trial, without loss of generality. In the healthcare context, organizations that agree to share information in a privacy preserving way are both benefiting from that arrangement. In such a situation, it may be reasonable to design a protocol based on a semi-honest adversary model [33]. The semi-honest adversary model assumes that all parties will follow the protocol steps but could try to learn as much information as possible from the data they are given. On the other hand, a malicious adversary model takes into consideration that a party may modify, spoof, or send wrong information on purpose in order to break the protocol and uncover confidential data.

There are three roles in this protocol:
                           
                              
                                 The Key Holder (KH). This is a semi-trusted third party who generates the key pairs and performs computations on intermediate results.


                                 Central Database (CD). The CD holds the encrypted data from all of the sites and processes queries with the KH.


                                 Sites. The sites provide information about their participants and execute queries to determine whether a volunteer is enrolled in a concurrent trial.

The KH role is not strictly necessary if sites and the CD can communicate in the context of a traditional two-party protocol in which both parties perform computations on each other’s encrypted data. In our setting, however, sites do not receive any encrypted data back from CD due to their limited computing capacity (requirement 4), making KH a necessary facilitator of the secure computation.

The protocol has three phases: initiation, screening, and recruitment. During initiation the keys are exchanged. Screening allows sites to query the CD. Recruitment allows the sites to add new recruits in the CD. Our protocol utilizes a homomorphic cryptosystem which is described below. A detailed security analysis of this protocol is provided in Appendix A.

Throughout the protocol we make use of the exponential variant of the Elgamal public-key encryption scheme [18], which we will briefly review here.

Let 
                                 
                                    p
                                    ,
                                    q
                                 
                               be large primes such that 
                                 
                                    p
                                    =
                                    α
                                    q
                                    +
                                    1
                                 
                               for some 
                                 
                                    α
                                    >
                                    1
                                 
                              . Current recommendations on the size of these parameters are 
                                 
                                    |
                                    p
                                    |
                                    ⩾
                                    2048
                                 
                               bits and 
                                 
                                    |
                                    q
                                    |
                                    ⩾
                                    224
                                 
                               bits [68]. Select 
                                 
                                    g
                                 
                               to be an element generating the prime order cyclic sub-group 
                                 
                                    
                                       
                                          G
                                       
                                       
                                          q
                                       
                                    
                                 
                              , i.e., 
                                 
                                    2
                                    ⩽
                                    g
                                    <
                                    (
                                    p
                                    -
                                    1
                                    )
                                 
                               and 
                                 
                                    
                                       
                                          g
                                       
                                       
                                          q
                                       
                                    
                                    ≡
                                    1
                                    
                                    mod
                                    
                                    p
                                 
                              .

The key holder selects a random 
                                 
                                    x
                                    
                                    
                                       
                                          ∈
                                       
                                       
                                          R
                                       
                                    
                                    
                                    
                                       
                                          Z
                                       
                                       
                                          q
                                       
                                    
                                 
                               and computes
                                 
                                    
                                       y
                                       =
                                       
                                          
                                             g
                                          
                                          
                                             x
                                          
                                       
                                       
                                       mod
                                       
                                       p
                                       .
                                    
                                 
                              The public parameters are 
                                 
                                    p
                                    ,
                                    q
                                    ,
                                    g
                                 
                              . The key holder’s private key is 
                                 
                                    x
                                 
                               and the public key is y.

Let 
                                 
                                    m
                                    ∈
                                    
                                       
                                          Z
                                       
                                       
                                          q
                                       
                                    
                                 
                               be the message to be encrypted. To encrypt a message, the sender selects a random 
                                 
                                    r
                                    
                                    
                                       
                                          ∈
                                       
                                       
                                          R
                                       
                                    
                                    
                                    
                                       
                                          Z
                                       
                                       
                                          q
                                       
                                    
                                 
                               and computes
                                 
                                    
                                       Enc
                                       (
                                       m
                                       )
                                       =
                                       c
                                       =
                                       〈
                                       
                                          
                                             c
                                          
                                          
                                             1
                                          
                                       
                                       ,
                                       
                                          
                                             c
                                          
                                          
                                             2
                                          
                                       
                                       〉
                                       =
                                       〈
                                       
                                          
                                             g
                                          
                                          
                                             r
                                          
                                       
                                       
                                       mod
                                       
                                       p
                                       ,
                                       
                                          
                                             g
                                          
                                          
                                             m
                                          
                                       
                                       
                                          
                                             y
                                          
                                          
                                             r
                                          
                                       
                                       
                                       mod
                                       
                                       p
                                       〉
                                       .
                                    
                                 
                              
                           

Given 
                                 
                                    c
                                    =
                                    〈
                                    
                                       
                                          c
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          c
                                       
                                       
                                          2
                                       
                                    
                                    〉
                                 
                               the key holder computes decryption 
                                 
                                    Dec
                                    (
                                    c
                                    )
                                 
                               first by computing


                              
                                 
                                    
                                       
                                          
                                             
                                             
                                                
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         1
                                                      
                                                      
                                                         -
                                                         x
                                                      
                                                   
                                                   ·
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         2
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                             
                                                
                                                   =
                                                   
                                                      
                                                         g
                                                      
                                                      
                                                         -
                                                         rx
                                                      
                                                   
                                                   ·
                                                   
                                                      
                                                         g
                                                      
                                                      
                                                         m
                                                         +
                                                         rx
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                             
                                                
                                                   =
                                                   
                                                      
                                                         g
                                                      
                                                      
                                                         m
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           

The key holder then computes
                                 
                                    
                                       m
                                       =
                                       
                                          
                                             log
                                          
                                          
                                             g
                                          
                                       
                                       
                                          
                                             g
                                          
                                          
                                             m
                                          
                                       
                                       .
                                    
                                 
                              This last step is equivalent to solving a discrete logarithm in 
                                 
                                    
                                       
                                          G
                                       
                                       
                                          q
                                       
                                    
                                 
                              , which is a hard general, but can be efficient when the message space 
                                 
                                    |
                                    M
                                    |
                                 
                               is sufficiently small. For our application, this condition is satisfied: we are only ever interested in whether 
                                 
                                    
                                       
                                          m
                                       
                                       
                                          ′
                                       
                                    
                                    =
                                    
                                       
                                          g
                                       
                                       
                                          0
                                       
                                    
                                 
                               or not.

One especially useful property of the exponential variant of Elgamal is the following additive homomorphism:
                                 
                                    
                                       Enc
                                       (
                                       
                                          
                                             m
                                          
                                          
                                             1
                                          
                                       
                                       )
                                       ·
                                       Enc
                                       (
                                       
                                          
                                             m
                                          
                                          
                                             2
                                          
                                       
                                       )
                                       =
                                       Enc
                                       (
                                       
                                          
                                             m
                                          
                                          
                                             1
                                          
                                       
                                       +
                                       
                                          
                                             m
                                          
                                          
                                             2
                                          
                                       
                                       
                                       mod
                                       
                                       q
                                       )
                                    
                                 
                              
                           

This scheme also exhibits a useful scalar multiplicative homomorphism:
                                 
                                    
                                       Enc
                                       
                                          
                                             (
                                             
                                                
                                                   m
                                                
                                                
                                                   1
                                                
                                             
                                             )
                                          
                                          
                                             
                                                
                                                   m
                                                
                                                
                                                   2
                                                
                                             
                                          
                                       
                                       =
                                       Enc
                                       (
                                       
                                          
                                             m
                                          
                                          
                                             1
                                          
                                       
                                       ·
                                       
                                          
                                             m
                                          
                                          
                                             2
                                          
                                       
                                       
                                       mod
                                       
                                       q
                                       )
                                    
                                 
                              These homeomorphisms are useful in the sense that protocol participants can perform arithmetic operations on encrypted values.

Elgamal is known to be semantically secure, providing the property that similar (or equivalent) message will encrypt to independent ciphertexts. For example, encrypting the same message twice will, with overwhelming probability, produce different random-looking ciphertexts. This is important to ensure that an adversary would not be able to compare an encrypted message to a dictionary and would not be able to perform a frequency attack.

We assume that all communications among the parties in this protocol occur through a secure channel (e.g., SSL), and are authenticated and digitally signed.

Private record linkage protocols typically aim to match records using a wide range of fields including names, addresses, and other demographic information. Our initial datasets were composed of six fields, typically available in healthcare: first name, last name, gender, date of birth, health card number, and postal code. These fields were used to match participant identities.

In order to compare text fields, it is known that approximate comparison techniques perform better than exact matching because they allow for small errors that can be introduced through a typing mistake. The best approximate matching techniques rely on splitting a text into a series of consecutive characters and calculating a similarity index to decide if the entire text is classified as a match or not. The implication of this comparison scheme on private protocols is the added complexity of encrypting and decrypting every subset of a text instead of the entirety of the text.

In our datasets, we calculate the computational time required to match one record against the dataset. Keep in mind that our datasets do not contain a full address, which is sometimes included and used for matching. This means that we are presenting a best case scenario. The text fields being matched are first name, last name, and postal code. In our datasets, including the 1990 US census, the average name length is 7 characters. The postal code is a fixed 6 alphanumeric values in Canada. Therefore the overall text fields produce a total of 23 bigrams to be encrypted on average (typically the fields are padded with a space at the beginning and at the end so a name with length x will be represented by x
                           +1 bigrams. In our case, first name+last name+postal code produces 7+1+7+1+6+1=23 bigrams). The maximum size of a dataset we considered for our clinical trial setup is 20,000. If a protocol performed one to one matching, in a worst case scenario, it would have to perform 20,000 comparisons. This means that we will have to match (8∗8+8∗8+7∗7)∗20,000=177∗20,000=3,540,000 bigrams. We developed an optimized code implementing the exponential ElGamal cryptosystem and our experiments showed that on average, a decryption required around one millisecond. The worst case scenario to match a record in that case is roughly one hour on a machine with a single processor. This computation time is unacceptable to check the eligibility of a participant in a trial specially that the participant can be waiting for an answer on the phone or in person. To address this problem, a more powerful machine can be used, one that has multiple processors. Typically, a well-built machine today would have a processor with multiple cores. Record linkage applications are known to be easily parallelizable. Data centers on the other hand have much more powerful machines but they also cost a lot of money. To do our part in reducing computational cost, we tried to minimize the number of bigrams that need to be compared by reducing the number of fields required to identify a participant.

Text fields are a bottleneck for privacy-preserving protocols that aim to provide higher matching accuracy. In the following, we calculate the values of the sensitivity for the eight different text field combinations for dataset sizes of 1000, 5000, 10,000, and 20,000 participants in a clinical trial.

The displayed values are the averaged results on 50 different sub-datasets. The legend indicates the selected fields with each letter representing a field that was included in our protocol. ‘F’ stands for first name, ‘L’ for last name, ‘G’ for gender, ‘D’ for date of birth, ‘P’ for postal code, and ‘H’ for health card number. Combinations consisting of only one or two fields are not considered because they lead to very poor results. The datasets we used for this evaluation are based on the lists of doctors from the College of Physicians and Surgeons of Ontario (CPSO)
                           [73] and the list of lawyers from the Law Society of Upper Canada (LSUC)
                           [74]. The results for both datasets are comparable.

We eliminated the GDH combination because it has lower sensitivity and negative predictive value than the other combinations, especially for larger datasets. We also eliminated the FGDH combination because it performed much worse (by at least 34%) in terms of precision than the other metrics for a smaller dataset size.

The remaining combinations perform similarly for the three metrics except for precision, where the LGDH metric performs considerably better especially on smaller dataset sizes, which is typical for phase 1 clinical trials. The difference is meaningful: at least 17% between LGDH and the best one of the remaining metrics for the CPSO dataset (see Figs. 1–6
                           
                           
                           
                           
                           
                           ).

Our goal was to reduce the number of text fields to the least amount possible with the least sacrifice of accuracy. The experiments above show us that the best field combination with the least amount of text fields and best accuracy is LGDH. We were hence successful in building new datasets that contained only four fields: last name, date of birth, gender, and health card number. The reduction of the text fields by a third allowed our experimental protocol to gain around 64% improvement in terms of performance. Instead of comparing 177 bigrams (first name+last name+postal code) for each record, we only compare 64 bigrams (last name). For larger datasets, the performance improvement is important because it translates into shorter wait times for participants to know whether they are eligible to participate in a trial. If a party had a machine with a 32-core configuration, they would be able to check the eligibility of a potential participant in roughly 40s for a dataset size of 20,000 participants.

During the initiation phase the KH generates a key pair and sends the public key to the sites and the CD. Whenever a new site is added to the consortium it is sent a copy of the public key. This phase is illustrated in Fig. 7
                           .

During the screening phase a site runs a query against the CD, as illustrated in Fig. 8
                           .

Initial contact with volunteers is often by telephone. During the call, the study coordinator would collect basic information about them. The fields collected would be: last name, gender, date of birth, and a unique identifier, such as the health insurance card number (known as the OHIP number in Ontario) as we determined in Section 2.3.2 to improve performance while maintaining high accuracy.

After collecting the information over the telephone, the study coordinator enters the fields into our system. The system then encrypts the values using the Elgamal public key and sends these values as a query to the CD (hexagon 1 in Fig. 8).

The CD performs a secure comparison of the values submitted by the site to the values stored in its database and sends the encrypted results to the KH (hexagon 2 in Fig. 8) to determine if a match exists or not. The values stored in the database have been encrypted using the same public Elgamal key as the sites. Let there be N records in the database. Out of these let N′ have a washout period that is within the date of the query. If the values in the query match any of these N′ records then that would be considered a concurrent participant.

The exact protocol for the matching will depend on the type of field. For non-string fields we use a secure comparison protocol as follows [41]:
                              
                                 1.
                                 Let 
                                       
                                          j
                                       
                                     index the record in the CD being matched with the values in the query, and let 
                                       
                                          E
                                          (
                                          c
                                          )
                                       
                                     be the value sent in the query and 
                                       
                                          E
                                          (
                                          
                                             
                                                d
                                             
                                             
                                                j
                                             
                                          
                                          )
                                       
                                     be the value in the database.

Given public modulus 
                                       
                                          q
                                       
                                    , the CD generates a random number 
                                       
                                          
                                             
                                                r
                                             
                                             
                                                j
                                             
                                          
                                          ∈
                                          
                                             
                                                Z
                                             
                                             
                                                q
                                             
                                          
                                       
                                    .

The CD computes 
                                       
                                          
                                             
                                                x
                                             
                                             
                                                j
                                             
                                          
                                          =
                                          
                                             
                                                (
                                                E
                                                (
                                                c
                                                )
                                                ×
                                                E
                                                
                                                   
                                                      (
                                                      
                                                         
                                                            d
                                                         
                                                         
                                                            j
                                                         
                                                      
                                                      )
                                                   
                                                   
                                                      -
                                                      1
                                                   
                                                
                                                )
                                             
                                             
                                                
                                                   
                                                      r
                                                   
                                                   
                                                      j
                                                   
                                                
                                             
                                          
                                          =
                                          E
                                          (
                                          
                                             
                                                (
                                                c
                                                -
                                                
                                                   
                                                      d
                                                   
                                                   
                                                      j
                                                   
                                                
                                                )
                                             
                                             
                                                
                                                   
                                                      r
                                                   
                                                   
                                                      j
                                                   
                                                
                                             
                                          
                                          )
                                          =
                                          E
                                          (
                                          
                                             
                                                
                                                   
                                                      d
                                                   
                                                   
                                                      j
                                                   
                                                
                                             
                                             
                                                ^
                                             
                                          
                                          )
                                       
                                    . Note 
                                       
                                          
                                             
                                                
                                                   
                                                      d
                                                   
                                                   
                                                      j
                                                   
                                                
                                             
                                             
                                                ^
                                             
                                          
                                          =
                                          0
                                       
                                     if and only if 
                                       
                                          c
                                          =
                                          
                                             
                                                d
                                             
                                             
                                                j
                                             
                                          
                                       
                                    . Otherwise 
                                       
                                          
                                             
                                                
                                                   
                                                      d
                                                   
                                                   
                                                      j
                                                   
                                                
                                             
                                             
                                                ^
                                             
                                          
                                       
                                     is a random number in 
                                       
                                          
                                             
                                                Z
                                             
                                             
                                                q
                                             
                                          
                                       
                                    .

The KH uses the private key to decrypt the 
                                       
                                          
                                             
                                                x
                                             
                                             
                                                j
                                             
                                          
                                       
                                     value. If this value is equal to zero then the value in the query matches the value in the database, otherwise it is a non-match.

Following the date matching guidelines used by the National Death Index [6], the following three matches are attempted for dates and the dates are considered a match if any of them matches: (a) exact month and year of birth, (b) exact month and day of birth, and (c) exact month and +/− 1year of birth. Therefore, for DoB values that are encrypted and sent are day, month, year−1, year, and year+1.

The last name is a string field and would have to be considered differently to allow for approximate matching of strings. It is possible to use phonetic encoding functions, such as Soundex [61] and NYSIIS [66], and perform exact comparisons as for the other fields. This generally tends to be robust in case of spelling mistakes and typographical errors. However, this approach has two disadvantages. The first is the high percentage of false matches [9]. The second issue is that they are not robust when there are errors in the initial character or because of truncation variations [16]. For instance, a unique code, C623, is generated for three names, “Christine”, “Cristina”, and “Christopher”, while each of “Chris” and “Kristine” generate different codes, C620 and K623 respectively. We therefore use an approximate matching approach. In this case the string fields are converted into bi-grams and these are encrypted individually. For example, if the last name has s characters, these are encrypted as 
                              
                                 E
                                 (
                                 last
                                 _
                                 
                                    
                                       name
                                    
                                    
                                       1
                                    
                                 
                                 )
                                 ,
                                 E
                                 (
                                 last
                                 _
                                 
                                    
                                       name
                                    
                                    
                                       2
                                    
                                 
                                 )
                                 ,
                                 …
                                 ,
                                 E
                                 (
                                 last
                                 _
                                 
                                    
                                       name
                                    
                                    
                                       s
                                    
                                 
                                 )
                              
                           . These are then transmitted, sorted lexicographically, to the CD. We call this new last name representation scheme Health Card Number Interleaving (HCN In). The following steps are performed for matching on the last name:
                              
                                 1.
                                 All unique bigrams for the volunteer’s last name are generated using a character from the last name and a digit from the health card number. If the health card number digits are not enough to cover the length of the name, we restart from the first digit after reaching the last one (the documentation of the Febrl [13] tool has reviews of the types of real-world errors that happen in names and shows that the majority of these errors are single character substitutions. This scheme performs well in handling these errors and other types as shown in Section 3).
                                       
                                          –
                                          Let the number of bigrams in the query be 
                                                
                                                   s
                                                
                                              with a maximum value of 16 (based on experimentation, the limitation to 16 bigrams performs almost identically to an unconstraint number of bigrams, the method of choice of the 16 bigrams was varied between the first 16, last 16, random 16, most or least common 16 but did not show any differences experimentally). This constraint guards against analysis attacks on very long names that are rare.

All values of 
                                       
                                          E
                                          (
                                          
                                             
                                                c
                                             
                                             
                                                i
                                             
                                          
                                          )
                                       
                                     where 
                                       
                                          i
                                          ∈
                                          {
                                          1
                                          ,
                                          …
                                          ,
                                          s
                                          }
                                       
                                     are sent to the CD.

Let the number of unique bigrams in record 
                                       
                                          j
                                       
                                     in the database for the same field be 
                                       
                                          z
                                       
                                     (also limited to 16), and the CD has 
                                       
                                          E
                                          (
                                          
                                             
                                                d
                                             
                                             
                                                k
                                                ,
                                                j
                                             
                                          
                                          )
                                       
                                     where 
                                       
                                          k
                                          ∈
                                          {
                                          1
                                          ,
                                          …
                                          ,
                                          z
                                          }
                                       
                                    . The CD applies the secure comparison protocol above to all pairs of bigrams in the query and record 
                                       
                                          j
                                       
                                    . There will be 
                                       
                                          s
                                          ×
                                          z
                                       
                                     encrypted comparison results 
                                       
                                          
                                             
                                                x
                                             
                                             
                                                i
                                             
                                          
                                       
                                    , where 
                                       
                                          i
                                          ∈
                                          {
                                          1
                                          ,
                                          …
                                          ,
                                          s
                                          ×
                                          z
                                          }
                                       
                                    .

CD adds a random number of fake bigram comparisons that do not match any real bigrams (for example two underscores compared to any two letters). This does affect the real number of common bigrams but prevents the KH from knowing the original lengths of the individual names being compared.

These cipher texts are sent to the KH, sorted lexicographically. The CD also sends the KH the sum of the lengths of both names being compared in order for the KH to compute the dice coefficient [63].

The KH decrypts all 
                                       
                                          
                                             
                                                x
                                             
                                             
                                                i
                                             
                                          
                                       
                                     values and computes the Dice coefficient based on the number of bigrams that matched. If the Dice coefficient is above a certain threshold then this is considered a match on the last name.

Some recently proposed methods for secure string matching used Bloom filters to compare bigrams [64]. However, multiple cryptanalysis attacks revealed that these Bloom filters are vulnerable to a frequency analysis under certain conditions [47,52] and additional attack papers on Bloom filters are being published. Our approach would not be vulnerable to such attacks because of the probabilistic nature of the ciphertexts.

The above protocols for exact matching and string matching would result in a binary match/nonmatch value for all of the fields that are being sent in the query. The KH would have these plaintext binary values. A probabilistic score can then be computed based on each comparison result using the Fellegi–Sunter (FS) model [36,30] (if a field value is not available, it could be replaced by an obsolete value which will not match but the result of the probabilistic matching on all fields may still be able to match the record). The parameters of this model were estimated using the EM algorithm [39]. If the score is higher than a cutoff then the query is considered a match, otherwise it is considered a nonmatch. The KH sends the final match/nonmatch result to the site that initiated the query (hexagon 3 in Fig. 8).

When a patient is confirmed recruited the site sends that participant’s encrypted information to the CD for storage. The site must pre-compute all of the bigrams for the strings and the date of birth variants before encryption. The end of the washout period for that participant must also be sent, and this value is not encrypted. This phase of the protocol is illustrated in Fig. 9
                           .

The queries above contain encrypted forms of an individual’s demographic information. In order to guard against any potential attack on this protocol, we suggest the implementation of fake queries when there is a partial work load on the KH.

Since the KH has the private key and calculates the DC, it has the biggest learning potential of the parties in the protocol. Some information from the queries are forwarded after processing from the CD to the KH so the CD knows how much work load it has passed onto the KH. We suggest that at times when the KH is not processing too many queries, the CD sends it random queries to which the sites will ignore the results. This mechanism breaks the assumption that each calculation the KH is performing is related to demographic information of an individual wanting to participate in a trial and so makes any attack on the protocol more difficult because of the introduction of fake queries that the KH cannot differentiate from real queries. The system is protected from being slow because the CD knows the work load it has passed onto the KH and in general, the KH will not be bombarded with queries.

The protocol uses a limited set of four fields (last name, gender, date of birth, and health card number) that were determined to be efficient and provide good matching accuracy. If a party wishes to change these four fields, they are required to perform similar evaluations to make sure they do not affect the accuracy of the protocol. Ultimately, the last name representation scheme (HCN In) that we developed cannot be changed. It is a cornerstone of privacy protection of the protocol: it guards against dictionary and frequency attacks. Parties wishing to extend this protocol can also add additional fields to the evaluation and the results of the matching on these fields can be easily included in the Fellegi–Sunter probabilistic evaluation to determine a match based on all field comparison values. Special attention needs to be considered when adding a new field to make sure it will not provide an attacker with a tool to mount dictionary or frequency attacks based on the new field. Techniques including HCN In can be used to protect fields with uneven distribution like the last name field against such attacks.

The purpose of the empirical evaluation of the protocol was to determine how it scales as the CD database size increases in terms of computation time, and what the accuracy of the probabilistic matching would be. For the evaluation we developed a optimized version of the protocol written in C# (see the discussion on optimizations in Appendix A). A 1024 bit key was used for p and a 160 bit key for q (Section 2.3.1), and each processor core used for performance evaluation was running a Windows XP SP3 operating system at 2.8GHz.

Three data sets were used in our evaluations: name lists from the 1990 US census provided by the Census Bureau (88,799 unique last names), “the CENSUS data”, a list of members from the College of Physicians of Ontario (38,295 unique names), “CPSO data”, and the list of members of the Law Society of Upper Canada (26,635 unique names), “LSUC data”. We also validated our results with additional data sets based on the North Carolina voters database and parts of the Australian phone book. In addition to the names and gender, we generated random dates of birth and valid health insurance card numbers (OHIP numbers) such that we had four fields for each individual that we used for evaluating our protocol.

We used a tool that introduces realistic optical, phonetic, and typographical errors into a data set [56,13]. The tool took as input actual data sources (census, LSUC, CPSO) and produce data sets of 100,000 records that can be used for matching experiments. The types of modifications in the generated data sets included misspellings, character insertion, deletion, substitution or transposition, missing field, OCR errors, and phonetic errors. There is evidence that up to 25% of records have misspellings and typographical errors in names [76,32]. We therefore introduced errors to a random subset of 25% records. For each original data set we created a perturbed version and made that the CD data. The number of fields with a perturbation was set to two (i.e., half the fields had errors introduced) and the number of errors was limited to one error per field. The records did not have any missing data.

We created our own tools [28,29] to generate a range of datasets supporting the correct prevalence levels of dual enrollers according to real-world considerations (discussed in Appendix A). The size of the database in the CD was varied from 1000 to 20,000. This is a reasonable number given that usually phase 1 trials recruit a small number of participants. As noted in the introduction, the median enrollment for phase 1 clinical trials was 33. A database with 20,000 participants would amount to 606 trials of that size that have completed recently within a limited geographic area. This is arguably a large number of trials and represents a large database size for our evaluation.

The CD database was sampled from one of the generated (perturbed) data sets. We sampled 1000 records from a second generated data set to simulate the queries. The accuracy and performance results were computed across the 1000 queries. We used a prevalence of 2% for participants that are in the CD, which is consistent with the prevalence range reported in the literature (as summarized in Appendix A). Prevalence represents the percentage of records in the CD that would match the queries. Note that in general higher values of prevalence tended to have higher accuracy, therefore the value we chose erred on the conservative side.

The metrics we computed were sensitivity, precision (also known as positive predictive value), and the negative predictive value. To determine whether the secure string matching protocol had an impact on accuracy, we also compared these metrics with non-secure string-matching methods using the Levenshtein distance [36] and the Jaro-Winkler score [36]. The whole evaluation was performed on 50 independently perturbed data sets and the above metrics averaged across them.

Computational performance was measured in terms of seconds to execute the query. The query consisted of encryption at the site, matching with the database at the CD, and decryption at the KH. Other computations, such as the EM algorithm, consume negligible time compared to the cryptographic functions. Communication was not considered as this would vary depending on network traffic at the time the query was executed, and each query only requires a fixed 3 messages.

Total computation time at the CD and KH were measured for 1000 queries on CD databases of different sizes. For our simulations, we used 32 core and 64 core clusters (16/32 dual core machines) to represent the KH, and all of the computations were parallelized [28]. Record matching problems are known to be easily parallelizable for improved performance [12].

The CENSUS data was used for calibration, to find optimal cutoff values for the string comparison metrics: the Dice coefficient [63], Jaro-Winkler [36], and Levenshtein [36]. In addition, an optimal value for the probabilistic matching score cutoff was determined on the CENSUS data set. An optimal value is one that produced high values on the sensitivity, specificity, and precision metrics. All subsequent evaluation were performed on the LSUC and CPSO data sets only.

@&#RESULTS@&#

The performance results in terms of computation time as the database size increases are shown in Fig. 10
                     . For a 20,000 individual database, the total computation time is just under 40s on 32 cores and under 20s on 64 cores for a query.

Our objective was to provide an acceptable performance for a privacy-preserving protocol and we were successful in achieving that. We also present a comparison of the runtime of the non-secure methods (dice coefficient without encryption, Jaro-Winkler, and Levenshtein) versus our method in Fig. 11
                      that shows that the non-secure methods are much less expensive in terms of computations (around 5000 times faster). However, those methods cannot be used to preserve privacy. We have to pay the price for privacy, even though it is much larger, it is still acceptable (40s on a 32-core machine) and can be used in real-world applications.

The accuracy results for the three metrics, specificity, precision, and negative predictive value against database size are provided in Figs. 12–14
                     
                     
                     . There are three key observations from these graphs: (1) there is little difference in accuracy between our secure computation protocol and one that does not use secure matching on the last names, except for precision where we perform consistently better. A high precision value indicates that the protocol disqualifies very few individuals incorrectly and this is important because CROs have a hard time recruiting trial participants. (2) The accuracy on the three metrics is quite high at 0.9 for almost all database sizes. (3) There is generally little variation in accuracy as the database size changes.

Finally, we compared the matching accuracy of our probabilistic matching technique to an exact matching technique based solely on matching the health card number. The values for precision and negative predictive value but the main difference was in terms of sensitivity. Sensitivity measures the percentage of true matches. It was expected that our method performs better than exact matching: on average, the improvement was by 2% but the full results are displayed in Fig. 15
                     .

@&#DISCUSSION@&#

External validity [60] determines if the results of a given evaluation can be generalized to other domains and similar use cases. It was a main consideration while we designed our experimental evaluations. The risks that we wanted to mitigate in our evaluations included the following: bias in using a dataset from only one country, bias in introducing typographical errors not representative of real-world errors, and inaccurate name frequencies in generated datasets compared to their real-world counterparts. Prevalence was also an important factor for phase 1 clinical trials. We wanted to measure the accuracy of our protocol given a similar percentage of individuals that try to enroll in trials concurrently. We chose to set the prevalence value at 2% because clinical trial managers reported a concurrent enrolment percentage between 2% and 7% (Appendix A.1) and we discovered from our experiments with prevalence values between 1% and 10% that higher prevalence values tend to have better accuracy so we wanted to provide a worst case scenario with acceptable accuracy numbers.

To address the first risk of a dataset from a single country, we used data sources based on the 1990 US census data, the College of Physicians and Surgeons of Ontario (CPSO) database and the Law Society of Upper Canada (LSUC) database. We also included two additional datasets: the North Carolina voters’ database and parts of the Australian phone book which produced similar results in recent validation of our work. Using data sets from Canada, the United States, and Australia gives us more confidence in the external validity of our work in western English speaking countries.

Another threat to external validity is that the populations and typing mistakes that were generated are not similar to the ones that exist in real-world cases. To mitigate this threat, we used the Febrl tool [13] to generate our simulated populations based on the 1990 US census, the College of Physicians and Surgeons of Ontario (CPSO) database, the Law Society of Upper Canada (LSUC) database, the North Carolina voters’ database and parts of the Australian phone book. Febrl has been used by many other researchers working on the same type of problems. It generates populations based on the name frequencies in the databases to simulate real-world populations. The errors introduced by Febrl are also following the same distribution of real errors in real-world datasets: insertions, deletions, substitutions, OCR, etc.

To gain confidence in our generated data sets, we analyzed each data source to extract its name frequencies in order that data sets closely matched with the real-world versions. Febrl accepted a frequency file as input and generated populations with names based on the values of the frequency file. Based on our analysis of the original data sets, we created the frequency files required by Febrl and used Febrl to generate data sets of similar, smaller, or bigger sizes that still had similar frequency properties as the original data sets.

We created 50 different versions of each data set. The number 50 was chosen as a good reference point based on prior experiments in the Electronic Health Information Laboratory. Our accuracy and performance results are the average results of running each experiment independently over 50 different versions of each data set.

Lastly, the protocol has not yet been deployed in a real-world environment. However, we tried our best to mimic a real-world environment taking into consideration prevalence between the datasets and real-world errors in generated datasets.

@&#LIMITATIONS@&#

Limitations to the TRACK protocol include the situation where one of the clinical trial sites in proximity of the others refuses to be included in the system for detecting dual enrollers: this site would pose a threat to the concept because all the individuals that go to that site would not be detected by our protocol. However, we made the process of a site joining the team very easy: the key holder sends the new site the public key that is used to contribute all its records to the central database and it becomes part of the private matching group as soon as it completes that step.

Additional limitations include the requirement of the four fields (last name, gender, date of birth, and health card number) for high accuracy matching. Other protocols include a larger number of fields for the matching procedure and therefore may allow a missing value in one of the fields. We determined a minimilistic set of fields required for matching but the downside is that for the quality of the matching to be high, all four fields need to have values. We do however support a small mistake in any of the four fields because we use a probabilistic matching scheme.

Not all phase 1 trials require healthy volunteers. In most cancer trials, for example, cancer patients may be the participants. There is no evidence that patient volunteers engage in concurrent trial participation. Also, not all phase 1 healthy volunteers get paid. For example, in some vaccine trials in Canada the participants only get paid for expenses incurred. In such cases there are no incentives for concurrent trial participation and our protocol may not be needed.

@&#FUTURE WORK@&#

The following items would be interesting and important to investigate or to perform:
                           
                              •
                              Deployment of a system based on TRACK to a real group of CROs to better suit their needs and how to develop a complete solution for detecting concurrent enrolment.

Evaluation of our methods using datasets from countries using another language (e.g., French) or alphabet (e.g., Arabic or Chinese).

Evaluation of probabilistic matching techniques for every single field if resource constraints are freed with the increased computation power to be available in the future to increase the accuracy of the protocol.

El Emam et al. [24] developed a protocol that secures the identity of a data provider in order to monitor the spread of a disease by aggregating data from several providers (without revealing their identities) and presenting only the sum of the results to a health authority. It would be of interest for clinical trial sites to include that work along the TRACK protocol to detect concurrent enrollers and report on their numbers without affecting the credibility of a site (in case it had many concurrent enrollers).

Evaluation of the extendibility of the protocol to detect individuals who attempt to obtain a prescription drug several times from multiple pharmacies.

@&#SUMMARY@&#

In this paper we have provided a privacy-preserving protocol for tracking phase 1 clinical trial participants to ensure that there are no concurrent enrolments with acceptable computational and accuracy results. The main benefit of such a protocol is that healthy volunteers in these trials will have a much smaller risk of their personal information being compromised, compared to current systems that hold their personal information on centralized databases accessible over the Internet in the clear. The techniques presented in the protocol protect the data against dictionary and frequency attacks. Clinical Trials Ontario 
                        [17] presents a report with a definition of a technological system for clinical trials. They suggest the usage of a cloud solution because it would be common to all clinical trial sites as individual sites do not have the technical expertise to choose and to maintain independent systems. The system that we presented matches this criterion and enables clinical trial sites to adopt our protocol with very low overhead.

None of the authors have any conflicts of interest to declare.

@&#ACKNOWLEDGMENTS@&#

We wish to thank Lisa Gaudette for her help in the performance evaluation of the encryption software. We also wish to thank Dr. Daniel Amyot for reviewing some of the revisions to this paper.

This work was funded by the Canada Research Chairs program, the Ontario Institute for Cancer Research, the Canadian Institutes of Health Research, National Institutes of Health Grant 1R01LM009989, National Science Foundation (NSF) Grant Career-CNS-0845803, NSF Grants CNS-0964350 and CNS-1016343, NSERC Canada Graduate Scholarship and Ontario Graduate Scholarship programs.

Boyar and Goldfarb [8] looked at a tracking system deployed by five clinical research sites in South Florida. The system that was developed tracked patients using demographic and biometric identifiers. During the study period, 2081 research volunteers were registered. All participants were informed of the registry prior to enrollment. They found that 21.8% of the volunteers enrolled in a second study within the 18month period, with 50 (2.4%) trying to enroll within 30days of a previous trial and 186 (8.9%) within 60days [8,58]. Researchers reported that study sites rejected an additional 10 to 20 subjects who tried to enroll in a second study before dosing commenced in the first trial. The researchers believed that knowledge of the registry may have discouraged some participants from attempting to enroll in overlapping trials.

Zanini and Marone [79] piloted a registry system which included all healthy volunteers participating in drug studies approved by the central Research Ethics Committee in Southern Switzerland within a three year period. The total number of volunteers involved in clinical trials during this period was 1436. All trial participants were informed of the registry at the time of enrollment. The researchers identified 192 (13.4%) habitual or regular volunteers who participated in 6–8 successive trials during the period (with a mandated 30day waiting period in between). Three subjects attempted to enroll in overlapping trials during the study period.

Hermann, et al. conducted a survey of healthy research volunteers in Germany [35]. Four hundred and forty people participated in the survey, 47.1% who were employees of the research centers and 52.9% who were outside volunteers. A small number of those surveyed, 2.7%, reported having considered participating in 2 studies within the restricted period of time (2months), while 0.9% reported that they had participated in 2 overlapping trials. Also, 3% of participants reported that they had provided incorrect answers regarding their medical histories in order to be accepted by recruiters.

In preparation for developing our secure tracking protocol, we interviewed 4 phase 1 site managers and study coordinators for phase 1 trials to understand the issue of volunteers participating in multiple trials concurrently. During these interviews we asked for the interviewees’ estimate of the proportion of volunteers who attempt to enroll in multiple trials concurrently based on their experiences. The interviewees were recruited by sending invitations to ACRO (Association of Clinical Research Organizations), CRAC (Clinical Research Association of Canada), and CRO’s (Contract Research Organizations) in Canada doing phase 1 trials contacted through an industry list. Our interviewees indicated that, based on their experiences, between 2% and 7% of screened volunteers may be participating in other trials.

We now state the claims of security of the protocol in the semi-honest model. Note that the literature provides a discussion of the security of the secure comparison protocol that we use [41].
                              Statement 1
                              It is not possible to do a frequency attack on the bigrams to determine the original names.

Because the Elgamal cryptosystem is semantically secure, an adversary would not be able to perform a frequency attack on the bigrams. Two bigrams that are exactly the same will, in general, have different ciphertexts. □

The protocol correctly evaluates the Dice coefficient between two names.

The proof is based on the fact that KH receives an encryption of 0 if the compared bigrams match or an encryption of a random value otherwise. Knowing the total number of bigrams, and the number of bigrams that matched is sufficient to compute the Dice coefficient. □

Sites do not learn anything from the protocol, other than whether their patient is concurrently enrolled in other trials.

By definition, sites do not receive any communication except the public key and an indication of whether a double enrollment is detected. □

The CD learns nothing from the protocol except the number of participants recruited by each site.

By definition, the CD does not receive any communication, other than the public key and the encrypted values associated with each record (including bigrams) when a site executes a query. The encryptions are indistinguishable from randomness assuming Elgamal is semantically secure against chosen-plaintext attack (i.e., it is IND-CPA secure). The CD knows when a site has recruited a participant and stores those values in the database, but because these values are also encrypted it does not know what the values are. □

KH learns nothing from the protocol except the number of records held by the CD, and the sum of bigrams contained in the records being compared.

By definition, KH receives no communication, other than encrypted comparisons of record fields (including bigrams). A decrypted comparison equals 0 if the compared fields matched, and a random value otherwise. Lexicographical ordering of semantically secure ciphertexts is equivalent to a random shuffle of the associated plaintexts. The sum of the number of bigrams is given to compute the DC but the KH does not know the individual length of each name being compared. A maximum of 16 bigrams is computed for each last name in order to prevent the disclosure of rare names that have more than 16 bigrams. Our bigram generation strategy prevents the KH from doing statistical analysis on the last name field: since we combine the digits from the health card number with the letters of the last name, two last names that are the same will not match in their encrypted form if the health card number is different. Note though if the health card number has a small mistake, the match will return true since we are using the dice coefficient approach. Fake queries were also implemented to reduce the number of deductions that the KH is able to make about the number of records that are in reality requested by different sites in their queries and the content of those queries. □

Colluding sites learn nothing about other sites.

This follows directly from Statement 3. □

KH colluding with CD results in total disclosure of all participant identities.

The CD receives encrypted records from all sites. KH has the secret key required to decrypt them. But this breaks the semi-honest adversary model that we assume in our protocol. Therefore it is important to choose the KH and CD as well respected organizations preferably in different jurisdictions. □

Sites colluding with the CD learn nothing about other sites except how many matches the other site was determined to have.

Owing to the semantic security of Elgamal, learning the plaintext/ciphertext pairs of the colluding site gives the CD no advantage in guessing the plaintexts associated with the ciphertexts of a non-colluding site. □

Sites colluding with the KH only learn the number of participants matching/nonmatching with records in the CD at other sites and which fields exactly match the queries from other sites, but not the values of the non-matching ones.

Since the KH only receives encrypted results of matching, and then decrypts them, that is all of the information that a colluding site can learn. This consists of the binary results of comparing fields (including the shuffled bigrams) and the final decision on whether a query matches or not. □

One concern is whether the CD or KH would be able to determine the last name by knowing the number of bigrams. A plot of the distribution of last name bigrams from our data sets is shown in Fig. 16
                           . Names with too few and many bigrams have low frequency. However, it is only names with 21 and 22 bigrams that have a low frequency of 3 in our data set. All other names have frequencies higher than 8. We also performed experiments and discovered that limiting the number of bigrams to 16 did not have any negative effect on the accuracy of our protocol. This limitation helps conceal the rare long names that have more than 16 bigrams. We also do not pass the number of bigrams in each field to the KH since it only needs the sum of the number of bigrams in both fields being compared, this makes it harder to infer the number of bigrams in each field given our frequency distribution.

To avoid a site from running a large number of queries (say, with the assistance of a directory of names such as the White Pages or by looking at all combinations of field values) and determining the identity of all participants in the CD, the CD may limit the number of queries that can be executed by a site over time. For example, it may limit the number of per site queries to 100 per day and flag a consistently high number of queries over a number of days. If a site attempts to run more queries than that, then an administrator would be alerted to investigate.

In order to decide if two lists of bigrams match or don’t match, we calculate the value of the dice coefficient between those two lists and compare it against a threshold that was determined most suitable based on experimentation. Consider A as the first list of bigrams and B as the second list of bigrams. The lists contain unique bigrams.

|X| represents the number of bigrams in list X. The dice coefficient’s formula is the following: 
                           
                              DC
                              =
                              2
                              ∗
                              
                                 
                                    |
                                    A
                                    ∩
                                    B
                                    |
                                 
                                 
                                    |
                                    A
                                    |
                                    +
                                    |
                                    B
                                    |
                                 
                              
                           
                        .

The CD knows the values of |A|, |B|, and the KH know the value of |A|+|B| and they both know the threshold for DC. To decide if the two lists match, we need to find out if the dice coefficient is above or under the threshold. Since we know |A|+|B|, and the threshold value of DC, we can calculate a threshold value for 
                           
                              |
                              A
                              ∩
                              B
                              |
                           
                        .

For a true match the following must be true:
                           
                              
                                 Threshold
                                 (
                                 DC
                                 )
                                 <
                                 =
                                 2
                                 ∗
                                 
                                    
                                       |
                                       A
                                       ∩
                                       B
                                       |
                                    
                                    
                                       |
                                       A
                                       |
                                       +
                                       |
                                       B
                                       |
                                    
                                 
                              
                           
                        
                        
                           
                              
                                 |
                                 A
                                 ∩
                                 B
                                 |
                                 >
                                 =
                                 
                                    
                                       Threshold
                                       (
                                       DC
                                       )
                                       ∗
                                       (
                                       |
                                       A
                                       |
                                       +
                                       |
                                       B
                                       |
                                       )
                                    
                                    
                                       2
                                    
                                 
                              
                           
                        
                        
                           
                              
                                 Let
                                 :
                                 
                                 K
                                 =
                                 
                                    
                                       Threshold
                                       (
                                       DC
                                       )
                                       ∗
                                       (
                                       |
                                       A
                                       |
                                       +
                                       |
                                       B
                                       |
                                       )
                                    
                                    
                                       2
                                    
                                 
                              
                           
                        
                     

If |A|<
                           K or |B|<
                           K, it is impossible that 
                              
                                 |
                                 A
                                 ∩
                                 B
                                 |
                                 ⩾
                                 K
                              
                            so we don’t even need to ask the key holder to perform any decryptions. The result is immediately a non-match.

The rule 
                              
                                 |
                                 A
                                 ∩
                                 B
                                 |
                                 ⩾
                                 K
                              
                            must always hold. If the remaining number of bigrams to compare cannot meet that threshold, we can stop processing decryptions because at best, if everything else matches, we still will not be able to reach the threshold.

The following are practical considerations necessary when deploying the TRACK protocol in real world settings:
                           
                              •
                              Deploying our protocol requires collaboration among multiple phase 1 sites in a relatively small geographic area. In practice, participants who are moving among phase 1 trial sites will not travel large distances. Because the sites that do not track will become attractive to these professional participants who enroll on multiple concurrent trials, there is a strong incentive to join a secure tracking protocol.

To ensure appropriate consent is obtained, the study coordinators would need to inform individuals that a query will be run against the CD beforehand. Volunteers who refuse may not be eligible for the trial.

In our protocol we used the OHIP number as a field. In other jurisdictions other identifiers can be used, such as social security number. We did allow for errors in that number, therefore its inclusion in the protocol does not guarantee perfect matches.

In practice the CD would purge the 
                                    
                                       N
                                       -
                                       
                                          
                                             N
                                          
                                          
                                             ′
                                          
                                       
                                    
                                  records that are no longer within the washout period on a regular basis. This will ensure that the database does not grow in size, and hence deteriorate in performance over time.

To achieve reasonable performance levels it is necessary for the CD and KH to deploy a cluster of computers. In our simulations we used second hand commodity machines with dual cores. Given the linear performance gain from adding more cores to the cluster and the ease of parallelizing the computations, it would be relatively straight forward to gain performance improvements by simply adding more machines.

Our protocol uses the KH as a semi-trusted third party. The main functions of the KH are to decrypt the comparison results using the private key and perform probabilistic matching computations on these. The use of parties similar to our KH is not uncommon in secure multi-party computation protocols [24,40]. The KH can be an academic or commercial site with strong security, and as noted in [24] it would ideally be located in a different jurisdiction than the CD and sites to ensure an additional level of scrutiny for compelled disclosures.

Approval from the Research Ethics Board of the CHEO Research Institute was obtained before conducting the interviews with the site managers and study coordinators discussed in the earlier part of this appendix.

We provide example code in C# to facilitate the adoption of our protocol by interested parties. They would also need to obtain the GnuMP library that is publicly available. The code contains the following components:
                           
                              •
                              TrialParticipant
                                    
                                       –
                                       This class holds the information in the clear of a trial participant.

EncodedTrialParticipant
                                    
                                       –
                                       This class holds the encrypted information of a trial participant including the modified representation of the last name (split into bigrams according to the HCN In scheme) and date of birth (different variations according to the matching criteria of the protocol).

Objects from this class can be securely sent to the central database to find a match for the participant in a privacy-preserving manner.

SiteParticipantEncoder
                                    
                                       –
                                       This class encrypts the information of a trial participant to make it ready to be sent to the central database.

It transforms an object of type TrialParticipant to an object of type EncodedTrialParticipant.

ExpElGamalEncryption
                                    
                                       –
                                       This class holds two values representing the first and second part of the exponential ElGamal encryption.

CDEncodedParticipantComparison
                                    
                                       –
                                       This class holds the secure comparison of two EncodedTrialParticipant objects to be decrypted at the KH to check for a match.

CDParticipantComparator
                                    
                                       –
                                       This class is used by the central database. It creates the secure comparison of two participants according to the matching rules for each field to be sent to the key holder to check for a match.

CDSecureDataComparator
                                    
                                       –
                                       This class creates a secure comparison of two values in order to be decrypted and discover if they are equal at the KH.

PublicExpElGamalUtility
                                    
                                       –
                                       This class utilizes the ElGamal public key to allow the SiteParticipantEncoder class to encrypt the information of a trial participant and the CDSecureDataComparator to create the secure comparisons to be decrypted at the KH.

KHExpElGamalUtility
                                    
                                       –
                                       This class belongs at the key holder. It is capable of decrypting data to check the result of a secure comparison.

KHParticipantComparator
                                    
                                       –
                                       This is a main class at the KH. It compares all the trial participants to the one in the query by decrypting all the secure comparisons then performs the Fellegi–Sunter technique with the Estimation-Maximization steps to find out if there is a match or not.

This class can decrypt the secure comparison of every field for two encoded trial participants.

BigInteger
                                    
                                       –
                                       This class has been developed by a third party and made freely available to the public for re-use given that its documentation is also presented.

TestExpElGamalKeyGenerator
                                    
                                       –
                                       This class provides sample public and private keys as well as the parameters for the exponential ElGamal cryptosystem in order to test it. Note that these parameters should never be reused on real data.

Test
                                    
                                       –
                                       This is a test class to make sure the encodings, decodings, and comparisons are working properly, and they do.

Supplementary data associated with this article can be found, in the online version, at http://dx.doi.org/10.1016/j.jbi.2015.06.019.


                     
                        
                           Supplementary data 1
                           
                        
                     
                     
                        
                           Supplementary data 10
                           
                        
                     
                     
                        
                           Supplementary data 11
                           
                        
                     
                     
                        
                           Supplementary data 12
                           
                        
                     
                     
                        
                           Supplementary data 13
                           
                        
                     
                     
                        
                           Supplementary data 14
                           
                        
                     
                     
                        
                           Supplementary data 2
                           
                        
                     
                     
                        
                           Supplementary data 3
                           
                        
                     
                     
                        
                           Supplementary data 4
                           
                        
                     
                     
                        
                           Supplementary data 5
                           
                        
                     
                     
                        
                           Supplementary data 6
                           
                        
                     
                     
                        
                           Supplementary data 7
                           
                        
                     
                     
                        
                           Supplementary data 8
                           
                        
                     
                     
                        
                           Supplementary data 9
                           
                        
                     
                  

@&#REFERENCES@&#

