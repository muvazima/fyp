@&#MAIN-TITLE@&#XML privacy protection model based on cloud storage

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A new XML privacy protect model by separating the structure and content is proposed.


                        
                        
                           
                           Based on access purposes and privacy preferences, DTD sub-views are created.


                        
                        
                           
                           Start–end region encoding scheme is used skillfully in this model.


                        
                        
                           
                           Only content of XML is stored in the cloud, which has high security and efficiency.


                        
                        
                           
                           This mechanism has a good performance in space and time.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

XML privacy protection

Privacy policy

DTD views

Cloud storage

@&#ABSTRACT@&#


               
               
                  When eXtensible Markup Language (XML) becomes a widespread data representation and exchange format for Web applications, safeguarding the privacy of data represented in XML documents can be indispensable. In this paper, we propose an XML privacy protection model by separating the structure and content, and with cloud storage to save content information and Trusted Third Party (TTP) to help manage structure information. To protect data privacy more effectively, we will create different Document Type Definition (DTD) views for different users according to users' privacy practice and the provider's privacy preferences. To further speed up the process of gaining access to data we will adopt the start–end region encoding scheme to encode the nodes in XML document and DTD views. The experiment result shows that this mechanism has a good performance in space and time.
               
            

@&#INTRODUCTION@&#

With the development of information technology, XML documents have been applied in many fields as a standard for data representation and exchange over the Web, especially in economic, finance and medical areas. More and more personal information will be collected, stored and released by different organizations and institutions, which can easily be accessed in a network environment so that privacy disclosure is facing security threats. The traditional solution for privacy protection is to establish the access control model or to encrypt the sensitive information [1–3]. Access control mechanism focuses on the authorization user to get valid access data, and the encryption mechanism adopts the encryption method to protect the secret information. However, access control mechanisms may ignore the privacy protection, and the encryption methods may limit the access of data, which have become the major obstacles in data sharing. In a word, these traditional solutions can't ensure the protection of privacy while legitimating access is permitted, at the same time they also lack flexibility and efficiency. Therefore, there is now a strong demand for a new privacy protection model to protect data privacy and prevent disclosure of sensitive information in XML documents.

In this paper, we propose a new XML privacy protection model by separating the structure and content, using TTP to manage the structure and choosing the cloud to save the content. As far as an XML document is concerned, its tree-structure determines that it is meaningless to have a structure with no content or to have the content with no structure. Therefore, this method of separating information can protect the private information in an XML document effectively. To further protect such sensitive information, we create DTD views based on the users' purposes and the data provider's privacy preferences [4]. Privacy policies are focused on the purpose rather than on the user, which offers more flexibility to both data collectors and providers. The DTD view is a tailored structure tree, which can reflect structure information and access authorization. Valid authorized users with different purposes can get different DTD views. Further we will adopt the start–end region encoding scheme to encode the nodes in XML document and DTD views skillfully, which can speed up the process of data access.

The main contributions of this paper are as follows:
                        
                           (1)
                           We propose a new model for protecting privacy by separating storage of the structure and content in an XML document.

With the help of TTP, we develop DTD views based on the users' access purposes and the data provider's privacy preferences, so that authorized users with different purposes can have different DTD views.

We adopt the start–end region encoding scheme to encode the nodes in XML document and DTD views skillfully, which can speed up the process of data access.

Only content of XML document without structure information is stored in the cloud, which will get high efficiency in both storage and management.

The rest of this paper is organized as follows. Some current access control mechanisms and privacy protection models concerning XML document are described in Section 2. Section 3 presents the new model and an algorithm for producing DTD views, which is the primary component of this architecture, and then gives an example to describe the search processing. In Section 4, we have set up a series of experiments to measure the model's performance. Section 5 concludes the privacy protection model and makes suggestions for future work.

@&#RELATED WORK@&#

In recent years, there has been a growing need for the privacy protection. Many domestic and foreign research institutions, enterprises and scholars have carried out research into privacy protection. At present, they have made consistent efforts to supply privacy protection for XML data. Representative work includes the Platform for Privacy Preference (P3P) developed by the World Wide Web Consortium (W3C) organization, the Enterprise Privacy Authorization Language (EPAL) formulated by IBM as well as some access control models that are combined with privacy protection. In general, access control and data encryption have been the main forms to protect privacy.

Agrawal et al. [5] first lead ‘access’ into the relational database, namely Hippocratic database. This database ensures that the users access the data with reference to only the data provider's intention by first checking the purposes specified in privacy authorizations at the schema level, and then by checking the purposes stored with the data at the record level. The Hippocratic database model incorporates privacy protection capabilities into relational databases. Jae-Gil et al. [6] propose a Hippocratic XML model based on the ancestor's authorization. In this model, the descendant node can inherit the ancestor's authorization, so some nodes' authorization is decided by their ancestor's authorization. This solves the problem of finding the nearest ancestor node's authorization and proposes an efficient access control mechanism that uses the authorization index and the nearest neighbor search technique.

Damiani et al. [7] proposed a view-based access control mechanism (ViewAC). This mechanism creates and maintains a separate view for each user, which contains exactly the set of data elements that they are authorized to access, so the size of storage is summed up by the number of bytes in different XML documents with respective views. Angela et al. [8] put forward a privacy model called Privacy for All (P4A), which is an extension of an XML schema that includes purpose definitions and node access codes. In this model, a privacy policy considers two major elements: data and the purpose of its use. Each provider decides which information is private and all possible purposes for which it can be used. This model offers more flexibility than current approaches in that it allows unconditional and conditional access [9,10]. Data providers can agree to the collector's purpose or impose their own privacy preferences. Here the collector's view is expressed as the privacy practice.

Data encryption is another efficient technology in privacy protection. In September 2002, W3C and the Internet Engineering Task Force (IETF) provide a set of XML secure protocols and technical standards to satisfy security requirements [11,12]. In XML encryption standard, it defines the encrypting granularity: (1) It is a complete XML document (2) It is single element (and all their descendants) inside an XML document and (3) It is the contents of an element (some or all children nodes and all their descendants) inside an XML document or arbitrary binary contents outside of an XML document. In general, in (1) the XML document is seen as the common file to encrypt the entire file. However, in (2) and (3), the encrypting granularity of the XML document is divided into element type and content type, regardless of which way it is used and it cannot encrypt a single element node.

In order to solve the problems in the XML encryption standard, the literature [13] proposes XML pool encryption to hide the size and the existence of encrypted contents. The basic idea of pool encryption is to encrypt each node separately and to move all encrypted nodes (intermediate nodes or leaf nodes) from their original position into a pool, which can be located either inside the XML document where the plaintext nodes originated from or in one or multiple different documents. In this approach, before pushing the encrypted nodes into the pool, there is a need to bundle the original position information with the encrypted nodes, in order to reconstruct the document when the user can decrypt the nodes.

Currently, as almost all the access control models [6,9,10] share one common characteristic, which is that: the descendant nodes can inherit the authorization from their ancestor node, so that the nodes' access authorization becomes one of the difficulties involved in the querying process. Moreover, the leaf nodes' content is the core information, so the leaf nodes' authorization should be different from other nodes. But in the above models, they were rarely differentiated from other nodes. In ViewAC mechanism [7], although views are prepared off-line, this mechanism suffers from high maintenance and storage costs especially for a large number of users. The P4A model [8] only considers the leaf nodes' authorization and ignores the XML's structure information. In other words, it only provides leaf nodes with clear authorization and ignores the intermediate nodes' authorization. In short, the above-mentioned models either ignore the protection of the content or ignore the protection of the structure, but an XML document needs dual protection whatever the content or the structure.

Although all kinds of data encryption technologies can effectively protect privacy information, there are still many unsolved issues to be explored [11–13]. In W3C XML encryption standard, from the encrypted granularity, we can conclude that the encryption standard has two problems: (1) It is impossible to encrypt an ancestor node while leaving the descendants of the node unchanged. (2) Information could be disclosed between users. The xenc:EncryptedData element tells the adversary where the plaintext had been before, and at same time the intruder can infer the size of plaintext from the size of cipher text. So there may be information leakage including the disclosure of position and the size of plaintext information in this scheme. In XML pool encryption, the deletion of encrypted nodes breaks down the structure of the XML document, which makes reconstruction difficult and time-consuming. Moreover, the choice of encryption granularity is difficult with regard to XML's tree-structure, and it is time-consuming with regard to the process of encryption and decryption, so there may be some problems in finding certain information.

In summary, we need a new privacy protection model, which can protect privacy information effectively. It not only considers the protection of the content but also pays attention to the structure. Based on the problems of existing models, in order to achieve the goal of privacy preservation, in the following section, we will propose a new XML privacy protection model.

According to the existing problems in the privacy protection model, we can conclude that the main information is the leaf nodes' content, which is the main body of information protection. The structural characteristics of XML determine that its structure also hides information, so this also needs to be focused on. In view of the above questions, we will establish a privacy protection model that not only considers the content but also pays attention to the structure of XML document. We can capture information on collectors' access purposes and data providers' privacy preferences in order to build DTD views, and then store the content separately and the structure to achieve the goal of privacy protection.


                        Fig. 1
                         shows the architecture of an XML privacy protection model. The model consists of three components: the cloud module, the user module and TTP module. TTP module is the core component among these modules.
                           
                              (1)
                              The cloud module is responsible for the management of leaf nodes' content in cipher text. In the cloud, the storage structure of the content is a two-dimensional tabular form, which includes the leaf nodes' encoding as a key and specific content.

The user module represents the client who has valid access authorization and wants to get information service. These clients must be the authorization users formed by Recipient–User-constraints, whose information is under the control of identity authorization module in TTP.

TTP module is responsible for the storage of structure and the management of authorization users. In TTP module, we assume that TTP is trusted by collectors and data providers directly. Therefore, in the preprocessing stage TTP firstly resolves the entire XML document, and then creates the complete structure view and corresponding DTD document. It is mainly divided into three sub-modules. First, the policy sub-module includes the collector's privacy practice and the provider's privacy preference, which forms the architecture of TTP, but this must be finished beforehand [14]. Secondly, the DTD views and access key sub-module, according to the strategy information provided by the collectors and providers, while TTP creates DTD views, and then takes nodes' encodings as the keys. Thirdly, identity authorization module is responsible for confirming the legitimate users' identities in terms of the authentication table.

In order to store separately the content and the structure of an XML document, we will choose TTP to assist in implementing the protection of the structure. TTP has the following main functions:
                           
                              (1)
                              Generating DTD views for users with different purposes and encoding all the nodes in DTD views. DTD view is an authorized structure tree tailored according to the user's access purposes and the provider's privacy preferences. The authorization user takes the encoding as the key through which he can get the content saved in the cloud.

Managing the authorization users. By the identity authorization table, it identifies which user in which recipients are entitled to search for which purposes. TTP can update this table for security access.

According to the user's identity and access requirements, TTP will search his or her corresponding DTD view. If the user is a legitimate authorization user, the corresponding structure information and keys will return to the user, and then the user may use the keys to get the content of XML document.

The detailed function diagram of TTP module is displayed in Fig. 2
                        .

A complete definition of a privacy policy must include a combination of privacy constraints and access constraints as suggested in Hippocratic databases [5]. In this part, we use many symbols to describe the information. All the symbols are showed in Table 1
                           .

Let Γ be the set of all the nodes from the tree associated with an XML document, Λ the set of all the leaf nodes, Ψ the set of purposes for data collection, ϒ the set of recipients, and Ω the set of data providers.
                              Definition 1
                              
                                 Privacy Practice Policy is a function PPra: Λ
                                 ×
                                 Ψ
                                 ×
                                 ϒ
                                 →
                                 α
                                 ×
                                 β. PPra expresses collectors' privacy practice. For each leaf node, λ
                                 ∈
                                 Λ, an access code a∈
                                 α and an operation code b∈
                                 β are specified in relation to each query purpose ψ
                                 ∈
                                 Ψ for the recipient c∈
                                 ϒ.


                           α is the access code associated with a node in the XML tree that expresses its accessibility in relation to a query purpose in a privacy concerned database, the set of access codes is α
                           ={yes(Y), no(N)}.


                           β is the operation code associated with a node in the XML tree that expresses the permitted operations to be performed on this node in relation to a query's purpose in a privacy concerned database. The set of operation codes is β
                           ={no operation (ϕ), read (r)}.
                              Definition 2
                              A Privacy Preference Policy involves a function PPre: Γ
                                 ×
                                 Ψ
                                 ×
                                 Ω
                                 ×
                                 ϒ
                                 →
                                 α. PPre is a collection of privacy preferences. It specifies the access code a∈
                                 α for each node n∈
                                 Γ for purpose ψ
                                 ∈
                                 Ψ. The recipient c∈
                                 ϒ has been specified for cases where third parties query private data stored by the collector. Ω is the set of data providers, and the others' definition will be the same as Definition 1.

Based on above definitions, we can conclude that the Privacy Practice Policy emphasizes the authorization of leaf nodes, because the structure is implicit to the collectors, and the Privacy Preference Policy guides the authorization of all the nodes in XML document, because all the contents and structures of XML are distinct to the providers.

In this case, let us take the Electronic Medicine Record (EMR) for example [15], a security scheme about the electronic patient records has been proposed to solve the sharing problem of m-health services [16]. In this model, we can assume that the provider has the entire XML document, the complete DTD structure view and the corresponding DTD document. The entire XML document is displayed in Fig. 7, while the complete DTD view and DTD document are displayed in Fig. 3
                           .

In Fig. 3, the complete DTD structure view denotes the structure of the entire XML document, the node ‘Patient’ and the node ‘Record’ are the repeated nodes. The DTD view indicates that EMR contains the node ‘HosName’ and the node ‘Patient’, which describe the name of the hospital and the information about the patient. In a DTD document, their relationship can be described as ‘<ELEMENT EMR (HosName, Patient*)>’, in which “*” means that the ‘EMR’ contains many ‘Patient’. The information about the patient includes the ‘personinfo’ and ‘Record’. The ‘personinfo’ describes the patient's personal information (including the patient's ID, their name, their date of birth and so on), while ‘Record’ describes the patients' hospital records (including the ID of doctor, treatment, fees and so on). In this DTD view, the leaf node is described as “(#PCDATA)”, which means that the leaf node's content is a character string, with no child element. For example, the leaf node ‘HosName’ is described as ‘<ELEMENT HosName (#PCDATA)>’.

According to the design flow in Fig. 2, TTP will tailor the complete DTD structure view based on their privacy practice and privacy preference, and then generate the corresponding DTD views for different users. The transformation and tailor rule is: for an intermediate node, if authorization is denied to every leaf node, we will omit this intermediate node and all its leaf nodes from the DTD views. Otherwise, we can present this intermediate node and all its granted leaf nodes in DTD view.

Here, we take the EMR as a real example. In Examples 1 and 2, we assume that the complete DTD structure view and corresponding DTD document are in Fig. 3, we provide their privacy practice and privacy preference respectively, and then based on the transformation and tailor rule, TTP will create their structure sub-view and corresponding DTD document. The detailed process is in Examples 1 and 2:
                              Example 1
                              A user authorized by the recipient wants to get the medicine information for ‘purchasing’ purposes. The corresponding privacy practice and privacy preference policy are described below:

PPra shows if a user wants to get the information about ‘medicine’, ‘HosName’, and ‘treat’, after being filtered by the preference policy, while the recipient ‘purdepartment’ will provide the DTD view and the partial DTD document. Through the tailored DTD view, we can understand that the authorized user who wants to get the medicine information for ‘purchasing’ purposes only gets the ‘HosName’ and ‘Medicine’ information. The permitted structure is displayed in Fig. 4
                           .
                              Example 2
                              A user authorized by the recipient wants to know about the diagnose information, whose purpose is to analyze and research the reason of disease. The privacy practice PPra and the privacy preference PPre are described below:

PPra shows that a user wants to get the information about ‘medicine’, ‘treat’, ‘Diagnose’, and ‘dateofBirth’. PPre shows the preference policy. Based on the tailored rule, after all the preference and practice policies were filtered by the policy, TTP creates the tailored DTD sub-view and corresponding partial DTD document. The permitted structure view is shown in Fig. 5
                           .

When a user wants to search some information in EMR, he first submits a search request. If the user is a valid authorized user, TTP first helps him or her to search the corresponding DTD view, and then returns the structure information to the user. To facilitate the processing of the query, several encoding schemes have been proposed to directly determine the structural relationships between two arbitrary nodes without accessing the original XML document [17,18].

In order to search the leaf nodes' content quickly, we can use the start–end region encoding to encode the entire XML document. The detailed method is in [19] and the pseudo-code is displayed in Fig. 6
                           . In this algorithm, its time complexity degree is O (nlogn/log2), the parameter n is the number of nodes in the XML document.

In order to know about this encoding scheme, we provide a specified encoding tree that is shown in Fig. 7
                           . In this figure, the oval denotes the node, and the rectangular shape represents the content of the leaf node.

In this encoding scheme, each node has two values assigned to it, start and end, based on the positions of the start and end tags of the node in XML document, while every node is labeled as (start, end). The node's start value can be generated by carrying out a depth-first traversal of the tree and sequentially assigning a number at each visit. Since each non-leaf node is always traversed twice once before visiting all its children and once afterwards: it has two numbers assigned to it, while leaf nodes have an equal two value.

For example the leaf node ‘No’ is labeled as ‘(4, 4)’, while the leaf node ‘treat’ will be labeled as ‘(19, 19)’. Why choose start–end region encoding? In the case of some nodes, if we only know their start–end region encoding, then all its leaf nodes' encodings are within the scope of it. Thus, we can easily get all its leaf nodes. Through the leaf nodes, we can get the leaf nodes' content. Using this encoding scheme, we can understand that the leaf nodes' encoding has to follow the same rule: its start is equal to its end, so we choose the leaf node's start to encode the leaf node's content. For example, ‘A1’ is encoded as ‘4’, ‘Alice’ is encoded as ‘5’ in accordance with this rule, and others are so on. For example, if a user wants to know his or her personinfo's content information, it is first necessary to find its encoding (3,12). As a result we can show that its leaf nodes' contents are ‘A1(4)’, ‘Alice(5)’, ‘1966-12-12(6)’, etc. 4, 5, 6, 7, 9, 10 are between digital 3 and digital 12.

In the entire XML document, we can use this start–end region encoding to label every node, but in the DTD view the encoding scheme is little different. The difference in encoding in DTD view is the repeated structure's node. With regard to the repeated node in DTD view, we can encode it by using the first encoding code in the XML document, labeled as (start, end, frequency). The definition of start and end are the same, with the above mentioned ‘frequency’ being the number of node appearing in the entire XML document. Corresponding to Figs. 4 and 5, the encoding in DTD view is shown in Fig. 8a and b
                           .

In this model, we follow the privacy police, formed by Recipient–User-constraints<User, Recipient, Purpose, Retention time>(Table 2
                           ). The Recipient–User-constraints describe connections between recipients, users and purposes, by identifying which user in which recipients are entitled to search for which purposes. For the purpose of security, the retention time is included in this table. The retention time for a recipient is the maximum allowed time for querying data as specified by the purpose. This time can vary for each recipient and purpose. When authorization information is not required for any purpose of any recipient then it must be deleted from the table according to the Minimum Retention Time Principle as enunciated by Agrawal et al. [5].

In this model, we have created the identity authorization table by collecting all the users and recipients. Any visitor who wants to get the information in the XML document must first provide the identity information. This is the safeguard for security access.

Cloud computing has been defined by the National Institute of Standards and Technology (NIST) as a model for enabling convenient, on-demand network access to a shared pool of configurable computing resources (e.g., networks, servers, storage, applications, and services) that can be rapidly provisioned and released with minimal management effort [20]. These features make cloud computing attractive. However, security and privacy issues present a strong barrier for users to adapt to cloud computing systems. Many companies, such as Amazon, Google, Microsoft and so on, accelerate their paces in developing cloud computing systems and enhancing their services to provide for a larger amount of users. The security and privacy in the cloud are also hot topics, a considerable amount of research work has been carried out in recent years [21,22], but this is beyond what our study covers.

In this model, the information inside the cloud is in a secure way using cryptography. We assume that the cloud providers are reputable and have adequate systems in place to protect sensitive corporate data. Thus, we can assume that the data saved in the cloud is safe. There are three reasons for choosing the cloud to save the content: (1) If the information saved in the XML document is mass data, the information in the cloud will get high efficiency in both storage and management. For example, the Electronic Medicine Record contains large amounts of saved large information, in which efficient storage enables electronic storing and sharing of medical data between health practitioners. (2) In the cloud, it has its own protection mechanism, which can further protect the information saved in the cloud. (3) This model could be applied appropriately to a shared environment, different users with different requirements can be easy to access the XML database and execute queries. Even if intruders gain access to the data, they would have not rules to follow, because the data in the cloud peeled off the structure, and the content with no structure is safe.

In the cloud, the storage structure of the content is displayed in Table 3
                         corresponding to Fig. 7: in this table, the first column is the encoding of leaf nodes' content, and the second is the specified leaf nodes' content. In order to search the information conveniently and speed up the query, we must make the table sorted as its keys.

When a user wants to get some information from the XML document with sensitive information, he must first go through several stages to finish the register and identify authentication:
                           
                              (1)
                              The user must register to a third party, and then he/she can get the public–private key pair in this process.

The user registers his/her private information to the TTP, TTP will save this user's ID and private information.

The user will send the access message with a signature to TTP for identity authentication.

TTP will affirm the user's message signature. If the authentication is successful or failed, TTP will send ACK or ERR message to the user.

The detailed process is (d1)–(d6) in Fig. 9
                        .

After the register and identify authentication, the user could go on searching information. We choose XPath as the structured query language. If the user is a legitimate user according to the identity authorization table, TTP will search and return a correspondingly partial DTD view and nodes' encoding to the user. Secondly, when the user receives the message from TTP, the user will save the partial DTD view as the result's structure information, and then using the encoding as a key to access the cloud, the corresponding content will be returned to the user. Finally, the user will combine the structure and leaf node's content as the query result. Fig. 9 shows the process of the user's access.

For example, the user Bob sends a query ‘/EMR/Patient [0]/Record’ to TTP, with the intention of searching in the first patient's information. After receiving this message, TTP first searches its authorization user table and finds that Bob is an authorization user. Then TTP will find Bob's corresponding partial DTD view and the Record's encoding ‘(13, 21, 2)’ returning to Bob as the query result. When Bob gets the message from TTP, he will keep the partial DTD view and sends the key ‘(13, 21, 2)’ to the cloud, and the programming in the cloud will be based on the key required to select the corresponding result for the user. Because the key ‘(13, 21, 2)’ indicates the frequency of Record, based on the encoding ‘(13, 21)’, we can calculate the other Record's encoding and all its leaf nodes' encoding. We may assume that Bob's DTD view is shown in Fig. 5. Corresponding to Fig. 5, the process of search is shown in Fig. 10
                        .

In this experiment, we use three computers to simulate the user, the cloud and TTP respectively. All the schemes were implemented through Visual C++ 6.0 and all the experiments were carried out on the Intel (R) Core (TM) 2 Duo, 2.93GHz CPU, memory 2GB, the operating system is Windows XP Professional. We use the Document Object Model (DOM) to obtain the nodes and leaf nodes' content information in XML document [23]. DOM is a platform and language-neutral interface that allows programs and scripts to dynamically access and update the content, structure, and style of a document. In order to compare the storage space, five kinds of XML test set are used, of which three kinds, respectively come from the proceedings page, ordinary issue page and index terms page. The others are from xml-actors and xml-movies [24]. Among the XML document set, maximum number of the nodes is 597, maximum fan-out is 197 and maximum storage size of XML document is 56KB. Table 4
                      shows the characteristics of the different XML test sets.

The storage space and search time are often used to evaluate performance. Here, we compare the storage space and search time in two mechanisms, but in order to facilitate the processing, we ignore the preprocessing in each model. To evaluate the performance of this model, ViewAC's approach [7] is performed and compared with ours.

According to the access control rules of ViewAC mechanism, its storage space is calculated and shown in formula (1). In formula (1), K is the number of users with different purposes for a common XML document, and ‘Mi’ stands for the space bytes for the ith XML document in ViewAC. Every user has a respective view, which is a special XML document according to its access control authorization.
                           
                              (1)
                              
                                 
                                    M
                                    =
                                    
                                       
                                          ∑
                                          
                                             i
                                             =
                                             1
                                          
                                          K
                                       
                                       
                                          M
                                       
                                    
                                 
                              
                           
                        
                     

With regard to our model, the storage space is composed of two parts: the compressed DTD view saved in TTP and the leaf nodes' content saved in the cloud as a table. The storage space is shown in formula (2). K is the number of users with different purposes, and ‘Di’ stands for the space bytes of every compressed DTD views. Because every user has a respective view, which is a special and tailored DTD document based on the complete DTD document. ‘Mleaf’ stands for the space bytes of leaf nodes' content, which is saved as a table in the cloud.
                           
                              (2)
                              
                                 
                                    M
                                    =
                                    
                                       
                                          M
                                          leaf
                                       
                                    
                                    +
                                    
                                       
                                          ∑
                                          
                                             i
                                             =
                                             1
                                          
                                          K
                                       
                                       
                                          
                                             D
                                             i
                                          
                                       
                                    
                                 
                              
                           
                        
                     

Based on the formula (1) and (2), we analyze their difference from the view of space complexity. In ViewAC mechanism, if the number of different users with different purposes is K, then it will keep K different documents, so its space complexity degree is O (KM), M is the space bytes of a single XML document. In our scheme, the space complexity degree is O (KD+Mleaf), D is the compressed structure bytes of this XML document, ‘Mleaf’ stands for the space bytes of leaf nodes' content. Obviously, D≪M.

According to each special XML document shown in Table 4, if every node is authorized by being granted in every document, this means that all the users have one same view. The comparison of storage space is shown in Fig. 11
                        . The horizontal abscissa digit stands for the number of test document, the “proceedings” XML document is labeled as 1, and the ‘ordinary’ XML document is labeled as 2, and etc. From the data information and icons show, we can conclude that our method is much better than ViewAC's in terms of space compression ratios.

When a different user wants to get information with a different purpose from a common XML document, we can assume that one hundred users are the authorization users, and which of them have five different purposes to visit this common XML document. In ViewAC mechanism, it needs to store five different XML documents, whereas in our model it only needs to save five DTD sub-views and the leaf nodes' content. The comparison of storage space is shown in Fig. 12
                        .

From the result of experiment and the data shown in Fig. 11 and 12, we can conclude that with the increasing number of users, ViewAC's space is growing greater than that of our model. As far as the document ‘Proceedings’ is concerned, this is the largest document in all the test XML documents. With a single view, the compression ratio is about 5.6:1 in two mechanisms. With five views, the compression ratio comes to about 12.2:1. Therefore, the number of users with different views greatly affects the size of space in two mechanisms. At same time, we can conclude that the larger XML document has a good compression ratio in space. In the document ‘Movie’, its number of leaf nodes is 398. With a single view, the compression ratio is about 2.5:1, but with five views, the compression ratio comes to about 6.8:1. Therefore, we can conclude the number of leaf nodes has a greater influence in space, and that the number of elements slightly influences. The maximum fan-out and the depth of XML document have less influence. In a word, our model has a good compression ratio in space.

The query time is another standard to judge its performance. In order to calculate its query efficiency, we calculate the query time under the same experiment condition. In our approach, its query time is determined by the following factors: (1) The resolution time of XML document (2) The query time of structure (3) The query time of content and (4) The communication time. In ViewAC approach, its query is determined by the resolution time of XML document and the query time for a special XML document. In this experiment, we simulate the cloud storage by the Microsoft's Access 2003 database, and the structure is also saved in an Access database. In this experiment, we simulate it in the LAN, so we can ignore the communication time.


                        Tables 5 and 6
                        
                         show the test information and the result. In Table 5, Number 1 to Number 5 are from above-mentioned test set in Table 4. Number 6 to Number 9 are generated by XMark datasets [25]. The resolution time is the time of extracting information from a tree-structure XML document. In Table 6, the test sets are created by Microsoft's Access 2003. The number of record is the record number saved in an Access database. The maximum query time is the time of search of all the records in a specified table of Access database.

With regard to two methods, they have same resolution time. In ViewAC's approach, the number of nodes in the result tree determines the query time. Because it needs to travel every node in the result tree to get the nodes' information, the number n of nodes in the result tree determines the number of accesses. From the view of time complexity, we can conclude that the time complexity degree is O (nlogn/log2). In our approach, it needs only two times to access the database, once is for the structure, another is for the content, so its time complexity degree is O (1). From the view of complexity degree, our approach is more efficient than ViewAC's. In a word, from the resolution time for XML document and the query time for Access database, we can conclude that our approach has good query performance.

In this model, if an adversary is presented, he may get the structure information or content information for some purpose. XML's tree-structure decides that it is meaningless to have the structure with no content or to have content with no structure. In this part, we discuss several situations:
                           
                              (1)
                              The adversary knows the structure view for some purpose, but he doesn't know the decryption key to the cipher text in the cloud, which means that he can't get the content information. In this case, the structure with no content is meaningless to him.

The adversary knows the structure view for one purpose, at same time he also knows the content for another purpose. In this case, even with knowing about the combination information of the content and the structure, as far as the adversary is concerned the combination information is meaningless, because the combination information is an error, and not the real data.

The adversary gets many structure views for some purposes. In this case, the structure with no content is meaningless. Likewise, the adversary knows many different content tables for some purposes, we know the content with no structure is also useless.

Therefore, from the analysis above-mentioned, we can conclude that the information disclosure is difficult in the separating storage mechanism.

@&#CONCLUSIONS@&#

We have proposed a new privacy protection model that separates the structure and the content in an XML document. This method of separating information can effectively protect the private information in an XML document. As it is meaningless to have the structure with no content or to have content with no structure, only by simultaneously taking structure and content into account can obtain the complete information. To further protect the sensitive information, while offering more flexibility to data collectors and providers, we produce different DTD views for different users. The DTD views not only represent the structure information but also reflect the collector's access purposes and data provider's privacy preferences. Furthermore, we adopt a start–end encoding scheme to encode the nodes in XML document and DTD views skillfully, which can quickly find the content information and speed up the access process.

The results of experiment show that this model has a good compression ratio in space compared with the ViewAC mechanism, which effectively make maintenance more convenient and lower storage costs especially for a large number of users. On the other hand, the method of separating information has changed the way of information storage, which benefits the query of information. From the time of query, we conclude that the method obviously improves the efficiency of the query, which benefits to data access.

In this paper, the focuses of study are on protecting data privacy and getting good performance in space and time, but some problems should be further concerned. This model only considers the query of information, but sometimes some special users with super authorization need to add, modify or delete some information in an XML document, so adding an update function to data is very necessary. In addition, the security of an XML document involves not only confidentiality but also integrity and usability, so further problems should be considered in the future.

@&#ACKNOWLEDGMENTS@&#

The authors sincerely acknowledge all the referees' suggestions for this paper. This work was supported by Funding of Jiangsu Innovation Program for Graduate Education (CXZZ12_0161) and the Fundamental Research Funds for the Central Universities.

@&#REFERENCES@&#

