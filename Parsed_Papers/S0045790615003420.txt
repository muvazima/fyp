@&#MAIN-TITLE@&#From model-driven specification to design-level set-based analysis of XACML policies

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We provide UML profile for model-driven specification of XACML policies.


                        
                        
                           
                           We propose a set-based design-level XACML policy analysis approach.


                        
                        
                           
                           We devise algorithms for design-level detection of conflicts, redundancies, and flaws.


                        
                        
                           
                           We provide dynamic policies evaluation to control access to critical resources.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Web services security

XACML policies

Model-driven specification

Design-level analysis

Logical deductions

Access control

@&#ABSTRACT@&#


               
               
                  With lot of hype surrounding policy-based computing, XACML (eXtensible Access Control Markup Language) has become the widely used de facto standard for managing access to open and distributed service-based environments like Web services. However, like any other policy language, XACML has complex syntax, which makes the policies specification process both time consuming and error prone, especially with large size policies that govern complex systems. Moreover, with the diversity of rules and conditions, hidden conflicts, redundancies and access flaws are more likely to arise, which expose Web services to security breaches at runtime. This paper proposes a UML profile that allows systematic model-driven specification of XACML policies to resolve the complexity of policies designation. Based on mathematical sets that explore the rules meanings, the paper provides also a design-level analysis to detect anomalies in the specified policies, prior to their enforcement in the system. A real life case study demonstrates the feasibility and efficiency of the proposition.
               
            

@&#INTRODUCTION@&#

Web services technology is undoubtedly revolutionizing distributed computing with its phenomenal support to expose, integrate and enable access to open, distributed and heterogeneous services ubiquitous over the internet. Yet, the vistas opened by this technology cannot hide its underlying security holes. With infinite accessibility to services over the internet and the evolution of cyber-crimes, access control is still one of the biggest concerns in the development of Web services. Hereof, policy-based computing [1–3] has gained considerable attention in controlling access to different systems including Web services. Particularly, XACML [4] has become the most widely used de facto standard for specifying and enforcing access control policies in this field [5–7].

However, like any other policy language, XACML has too low-level and complex syntax, which makes the policies specification process time consuming and error-prone. These problems emerge mainly when defining and combining many policies to govern access to complex systems like Web services composition [8]. Accordingly, some researchers [9–12] have proposed UML profiles to offer high-level graphical modeling mechanism for policies specification. UML profile [13] is a lightweight UML extension mechanism that allows creating a domain specific language. Existing approaches have proved the capabilities of such mechanism to define different access control models. Yet, these works lack a full coverage of XACML elements, which makes the proposed profiles unable to support all policies that can be expressed in this language.

Moreover, with the diversity of rules and conditions, anomalies are more likely to arise. Rules can overlap when single access request matches multiple rules. They may also conflict with each other in case these rules overlap and yield different decisions. Such conflicts in XACML policies are critical since they would allow unauthorized access to critical services or denial to legitimate entities. Redundancy is another type of anomalies in XACML policies. When an access request matches different rules with the same effect, these rules are considered as redundant. Redundancy affects mainly the performance of the access control decision-making process [14], which is influenced by the number of rules to be evaluated. The third critical anomaly in XACML policies is access flaw, which arises with badly defined and ordered rules and/or policies that allow users to gain accidental access to particular resources. Besides the achievements in the formal verification [15] of complex systems, several approaches [16–18] have proposed analysis mechanisms for XACML policies, few of them were able to detect all three aforementioned anomalies, yet not at the design level. In addition, none of these approaches is based on logical deductions that explore the meaning of the rules declared in the policies.

In this paper, we present a new approach that aims to tackle these issues. To resolve the complexity of policies specification, we propose a UML profile that covers all the elements of XACML and allow systematic model-driven specification of standard XACML policies. In addition, we devise set-based algorithms for design-level and logical analysis of the specified policies in order to detect conflicts, redundancies and access flaws within and among them, prior to their enforcement in the system. The detection algorithms are based on structured sets constructs automatically extracted from the policies models. These sets are analyzed based on mathematical relations that reflect the semantics of the rules declared in the model. A list of existing anomalies is generated to locate them and eventually help resolving them. The evaluation of the policies [19–21] is done by a decision-making engine that we presented in previous work [22] and proved its ability to accelerate the evaluation process over other existing engines [4,23]. Controlling access to single independent Web service implies direct call to this engine, while in case of several services composed in a business process, our approach involves an aspect-oriented policy enforcer. The latter is responsible of automatically generating calls for the evaluation engine and dynamically weaving them in the Web services composition to manage the critical resources declared in the model.

This work offers the following contributions:

                        
                           •
                           Providing UML profile that fully supports all XACML language constructs to allow model-driven specification of XACML policies. The profile can be systematically applied to design XACML access control policies for Web services.

Devising algorithms for design-level and logical analysis of XACML policies in order to detect anomalies like conflicts, redundancies, and access flaws. Moreover, identifying such anomalies between policies belonging to different Web services allows to appropriately select/eliminate the ones participating in the composed business model. The analysis is done on set-based constructs, which are automatically generated from the policies UML models.

Delivering policy enforcer that can automatically extracts critical resources from the designated policies model, generate calls for the evaluation engine and dynamically enforce these calls in the system to control access to these resources.

The rest of the paper is organized as follows. In Section 2, we study existing relevant approaches, while in Section 3 we give an overview of our proposition. In Section 4, we present the elaborated UML profile. In Section 5, we explain the intermediate set-based constructs for the XACML UML models. We present the logical detection mechanism and relevant algorithms in Section 6. In Section 7, we explain the policies enforcement process. In Section 8, we devote a case study to illustrate the proposed approach. Finally, we conclude the paper and draw future research directions in Section 9.

@&#RELATED WORK@&#

We present in this section existing works for model-driven specification techniques and analysis mechanisms for XACML policies. We also discuss their limitations to emphasize on the contributions offered by our proposition.

A very few works have been proposed for mode-driven specification of XACML policies. Jin [9] has proposed model-driven architecture to build role based access control (RBAC) model. To address the complexity of XACML XML-based documents, they proposed a UML profile that provides UML notations to ease the specification of XACML RBAC applications. In the proposed approach designers are able to create RBAC XACML specification platform-independent models based on the access control requirements along with the application models. However, the proposed profile does not cover important elements of XAMCL like obligations and advices.

Busch et al. [10] argued that XML syntax of XACML makes the process of policies specification difficult and error-prone and thus they proposed a UML-based notation to offers graphical modelling of security properties for Web applications. The authors leverage the UML-based Web Engineering using the extension mechanisms UML profile extension mechanism. Yet, again the proposed approach does not support obligations within the policy sets, policies and rules.

A few initiatives have been proposed in this area exploiting the UML profile extension mechanism provided by UML. Existing profiles notations presented in these approaches did not cover all the constructs of XACML, hence their profiles cannot support all policies that can be designated with this language. Besides that these approaches do not rely on the latest version of XACML. Per contra, we present in this paper a UML profile that covers all the elements of XACML including policy sets, policies, rules, targets, conditions, obligations and advices, hence offering the ability to design any policy that can be expressed via the standard XACML and conforms with the latest version of this language.

For the analysis of XACML policies, several approaches have been proposed. Huonder [18] proposed an approach that focuses on the detection and resolution of conflicts in XACML policies. To detect conflicts, the proposed approach maps each target to the n-dimensional space and locate all overlapping policies with different effects. With such technique, every policy is considered as a set of attributes and a non-empty intersection in all dimensions between policies defines a conflict among them. Yet, the proposed approach did not address access flaws and redundancies anomalies, does not support the combining algorithms between XACML policies and excludes the rule conditions from the analysis.

Kolovski et al. [16] proposed an approach based on description logics (DL), which are a decidable fragment of First-Order logic. To verify policies, the authors use the existing DL verifiers. Their analysis process can discover redundancies at the rule level. However, they do not address access flaws and do not support many important criteria like multi-subject requests, complex attribute functions, rule Conditions and Only-One-Applicable combining algorithm.

Rao et al. [17] introduced algebra for fine-grained integration that supports specification of a large variety of integration constraints. They introduced a notion of completeness and proved that their algebra is complete with respect to this notion. Their approach, however, does not support obligations and rule conditions and focuses on combined policies, unlike ours which offers the ability to analyze policy sets individually and after integration from different parties.

Several researchers have proposed analysis mechanisms to detect anomalies in XACML policies. With respect to these approaches, our work mainly differs in different aspects. First, it offers the ability to detect conflicts, flaws and redundancies, where to the best of our knowledge none of the existing approaches address these three anomalies. Second, the analysis is done at design level before enforcing policies in the system, assisting designers to locate anomalies and hence avoid their propagation. Third, our analysis mechanism is based on logical deductions that explore the meaning of the rules declared in the policies. Finally, it does not make any assumption or exclude any element of the standard XACML language.

The overall architecture of our approach is illustrated in Fig. 1
                      which includes a UML Profile, an Analysis Module, a Policy Enforcer and an Evaluation Module. Rather than struggling with the low level and complex syntax of XACML, the user creates a UML model (M in Fig. 1) where the proposed profile (see Section 4), can be systematically applied to design access control policies. The user can also analyze the models to detect conflicts, redundancies and access flaws and get the corresponding analysis report. The set-based constructs, which we interpret in Section 5, get automatically generated to allow the logical analysis based on the declared rules. The analysis process is conducted using the analysis module that embeds the algorithms in Section 6. The generated report details and locates the problematic rules in the policies model in order to assist the designer to select the appropriate strategy that best resolves the detected anomalies. XACML can resolve conflicts only through its combining algorithms, yet does not address flaws and redundancies and does not support design level solutions. Therefore resolving these anomalies require the definition of new customized strategies, which include cutting out rules overruled by others or selecting policies from different Web service providers that do not cause anomalies when combined together. The automation of such strategies forms part of our future work. The policies model is modified accordingly (M* in Fig. 1) and reanalyzed.

In addition, the approach offers the ability to evaluate the policies. The evaluation is done by a decision-making engine that we presented in previous work [22], where it proved its qualification to accelerate the decision-making process over other engines in the literature. Controlling access to single independent Web service implies direct call to this engine. Whereas for a business process of composite Web services, our approach adds a policy enforcer that can automatically generate calls for the evaluation engine and dynamically weave them in the composition to control access to the critical resources declared in the policy set model. The calls are created based on AspectBPEL [1], an Aspect-Oriented Programming language that offers the ability to define security, business and context-aware aspects as independent components and automatically integrate them in the Web services composition [24–28].

In this section, we present the UML profile that we are proposing to provide model-driven technique to design XACML policies. In the sequel, we interpret the profile elements illustrated in Fig. 2
                     . To remove any ambiguity, we used as much as possible the same names of the elements in the XACML language constructs.

We define the appropriate stereotypes, tagged definitions, operations and enumerations to cover all the elements of the latest version of XACML 3.0 that includes new elements and definition capabilities over its predecessors. A PolicySet, which extends the Metaclass Class, is a container of one or many Policies. It has an identifier ID, a policy proceeding order PPO that determines the order between its policies, and one of the policies combining algorithms PCA (i.e., Permit-overrides, Deny-overrides, First-applicable, and Only-one-applicable). These algorithms are used in XACML to resolve decision application problems between policies.

A Policy has also an identifier ID and may include many Rules. It has RPO to define precedence order among them and one of the rule combining algorithms RCA (i.e., Permit-overrides, Deny-overrides, and First-applicable) to resolve decision problems between its rules. Each rule can has a Condition, which is a function that should be validated before applying the rule.


                     PolicySet, Policy, and Rule can be all associated with Targets, Obligations and Advices. A Target identifies the action that a subject can exercise on certain resource, where in our case the action is an invoke and the resource is a service offered by partner Web service. The Obligation is a an action Operation(params) to be taken when certain trigger condition TriggerCond is met. A rule effect ER is the decision whether to permit or deny access. Finally, the Advice an analogous to Obligation, yet its common use is to detail why particular subject was denied access to certain resource.

The models are automatically converted into structured set-based constructs using the convertor module. The conversion to such intermediate representation allows at later stage the logical analysis of policies based on the semantics of their rules. The convertor takes the policies UML model defined by the user after applying the proposed profile, then parses the elements in the model and generates the appropriate sets, which are defined as follows:

                        
                           
                              
                                 
                                    
                                       
                                          P
                                          S
                                          =
                                          {
                                          I
                                          D
                                          ,
                                          S
                                          O
                                          P
                                          ,
                                          P
                                          P
                                          O
                                          ,
                                          P
                                          C
                                          A
                                          ,
                                          O
                                          B
                                          L
                                          s
                                          ,
                                          A
                                          D
                                          s
                                          ,
                                          T
                                          A
                                          R
                                          }
                                          
                                          
                                             (
                                             Construct
                                             1
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                  

The first generated set is the policy set PS, it includes its identifier ID, references to the set of policies it contains SOP, the order between the policies PPO, the combing algorithm PCA, sets of obligations OBLs and Advices ADs if any, and finally the target TAR defined as another set of subject S, resource RES and action A.

                        
                           
                              
                                 
                                    
                                       
                                          T
                                          A
                                          R
                                          =
                                          {
                                          S
                                          ,
                                          R
                                          E
                                          S
                                          ,
                                          A
                                          }
                                          
                                          
                                             (
                                             Construct
                                             2
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                  

Next, a set for policies is generated. Other than the policy ID, this set includes references to the set of corresponding rules SOR, precedence order between them RPO, combining algorithm RCA, sets of obligations OBLs and Advices ADs if any, and the target TAR.

                        
                           
                              
                                 
                                    
                                       
                                          P
                                          =
                                          {
                                          I
                                          D
                                          ,
                                          S
                                          O
                                          R
                                          ,
                                          R
                                          P
                                          O
                                          ,
                                          R
                                          C
                                          A
                                          ,
                                          O
                                          B
                                          L
                                          s
                                          ,
                                          A
                                          D
                                          s
                                          ,
                                          T
                                          A
                                          R
                                          }
                                          
                                          
                                             (
                                             Construct
                                             3
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                  

Finally comes the rule set R, which includes ID, condition C, sets of obligations OBLs and Advices ADs if any, target TAR, and rule effect E.

                        
                           
                              
                                 
                                    
                                       
                                          R
                                          =
                                          {
                                          I
                                          D
                                          ,
                                          C
                                          ,
                                          O
                                          B
                                          L
                                          s
                                          ,
                                          A
                                          D
                                          s
                                          ,
                                          T
                                          A
                                          R
                                          ,
                                          E
                                          }
                                          
                                          
                                             (
                                             Construct
                                             4
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                  


                     C is a function to be evaluated against the target elements (i.e., subject, resource and action), which is defined as

                        
                           
                              
                                 
                                    
                                       
                                          C
                                          =
                                          {
                                          O
                                          p
                                          e
                                          r
                                          a
                                          t
                                          i
                                          o
                                          n
                                          ,
                                          {
                                          p
                                          a
                                          r
                                          a
                                          m
                                          s
                                          }
                                          }
                                          
                                          
                                             (
                                             Construct
                                             5
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                  


                     OBLs is a set of obligations OBL, where each is defined as

                        
                           
                              
                                 
                                    
                                       
                                          O
                                          B
                                          L
                                          =
                                          {
                                          O
                                          p
                                          e
                                          r
                                          a
                                          t
                                          i
                                          o
                                          n
                                          ,
                                          {
                                          p
                                          a
                                          r
                                          a
                                          m
                                          s
                                          }
                                          }
                                          
                                          
                                             (
                                             Construct
                                             6
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                  

and ADs is a set of advices AD, also defined in the same way.

                        
                           
                              
                                 
                                    
                                       
                                          A
                                          D
                                          =
                                          {
                                          O
                                          p
                                          e
                                          r
                                          a
                                          t
                                          i
                                          o
                                          n
                                          ,
                                          {
                                          p
                                          a
                                          r
                                          a
                                          m
                                          s
                                          }
                                          }
                                          
                                          
                                             (
                                             Construct
                                             7
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        Example
                        Consider a policy set PS1 that consists of a single policy P1 with a combining algorithm 
                              
                                 P
                                 C
                                 A
                                 =
                                 p
                                 e
                                 r
                                 m
                                 i
                                 t
                                 −
                                 o
                                 v
                                 e
                                 r
                                 r
                                 i
                                 d
                                 e
                                 s
                              
                           . PS1 does not refer to any other policy and does not have a target or any obligation.

Policy P1 defines two rules R1 and R2, with a precedence order 
                        
                           P
                           R
                           O
                           =
                           R
                           1
                           >
                           R
                           2
                        
                     . It applies a combining algorithm of 
                        
                           R
                           C
                           A
                           =
                           p
                           e
                           r
                           m
                           i
                           t
                           −
                           o
                           v
                           e
                           r
                           r
                           i
                           d
                           e
                           s
                        
                      between its rules. P1 has no target and no obligations.

The first rule in this policy is R1, which has an effect 
                        
                           E
                           =
                           p
                           e
                           r
                           m
                           i
                           t
                           s
                        
                      conditioned by allowing access to getFinancialData only for Admin. Whereas the second rule R2 has an effect 
                        
                           E
                           =
                           d
                           e
                           n
                           y
                        
                      to prohibit access to getFinancialData only by an Employee. The set-based syntax of the policy set PS1, the policy P1 and both rules R1 and R2 is illustrated in Fig. 3
                     .

The first rule in this policy is R1, which has an effect 
                        
                           E
                           =
                           p
                           e
                           r
                           m
                           i
                           t
                           s
                        
                      conditioned by allowing access to getFinancialData only for Admin. Whereas the second rule R2 has an effect 
                        
                           E
                           =
                           d
                           e
                           n
                           y
                        
                      to prohibit access to getFinancialData only by an Employee. The set-based syntax of the policy set PS1, the policy P1 and both rules R1 and R2 is illustrated in Fig. 3.

Detecting conflicts, access flaws and redundancies is done based on set theory that explores the meaning of the rules in each policy to the generated sets. The relations between rules are mapped to sets mathematical relations (i.e. inclusion, intersection, union, etc.) in order to express their meanings. We present in what follows the algorithms that realize the analysis process, which is done at three levels. In the first level, the rules are analyzed using Algorithm 1
                     . In the second level, we devote Algorithm 2
                     , which calls two other Algorithm 3
                      and 4 to detect anomalies within each policy and among combined policies respectively. Finally, in the third layer, Algorithm 5 analyzes the policy set.

The rule analysis algorithm is illustrated in Algorithm 1. It takes two rules R1 and R2 as input, extract their targets, conditions and effects (Line 1 to Line 19) and compare them to determine if there exists any anomaly between the rules (Line 20 to Line 28). If the target (i.e., subject, resource and action sets) of rule R2 is subset of or matches the target of rule R2, the condition of R2 is a subset of or matches the one of R1 (Line 29), both rules have the same effect (Line 30) and R1 has precedence order over R2, then there is access control flaw between the rules R1 and R2 (Line 32). If the target of R2 intersects with the one of R1 (Line 35) and rules R1 and R2 have opposite effects (Line 36), then R1 and R2 are conflicting rules (Line 38). Otherwise, if R1 and R2 have the same effect (Line 39) then the rules are redundant (Line 41). The rule analysis algorithm returns the response to the second-level analysis. In case no anomalies found between the rules, the algorithm returns and empty set.

The policy analysis algorithm is presented in Algorithm 2. It calls Algorithm 3 to detect anomalies within each policy and Algorithm 4 to detect anomalies among combined policies. It takes two policies P1 and P2 as input and produces a set of all access flaws FS, conflicts CS and redundancies RS found. In both intra- and inter-policy analyses, the returned responses from the rule analysis calls are appended to the proper sets. For each policy, Algorithm 3 invokes the rule analyzer to check if there exists any flaw, conflict or redundancy between its rules, while inter-policy analyzer presented in Algorithm 4 checks anomalies between rules from different policies taking into account the policies targets and rule combining algorithms.

The policy set analysis process is presented in Algorithm 5. It takes a policy set PS as input and reports all access flaws, conflicts and redundancies found between policies and rules. It initializes global set FS, CS and RS and calls the policy analyzer in Algorithm 2 for checking and appending flaws, conflicts and redundancies at both policy and rule levels, within each policy and among different policies.

In independent Web service, policies are enforced before invoking its services and they can be evaluated by calling our policy evaluator engine to manage access to the requested resource. In more complex systems like Web services composition [29], policies are enforced and evaluated at the composition level. Therefore, we devise in this work a policy enforcer module, which extracts automatically the resources declared in the generated policies sets and creates calls for the evaluation engine to control access decisions. The calls are built with AspectBPEL constructs, which is an aspect-oriented language that we presented previously [1] to allow modular specification and dynamic integration of new aspects in business processes. The enforcer uses this language to create the evaluation aspects responsible of calling the evaluation engine and weave them in the composition, allowing the decision-making engine to take access control over the resources designated in the policies models.
                     
                  

Hereafter we recall the main constructs of the language to help understanding the generated code of the aspects, which are presented further in the text. The BPEL_Aspect represents the aspect module, which has a unique identifier. The aspect code starts with BPEL_Insertion_Point (i.e., before, after or around) to specify the point where the aspect will be injected followed by the BPEL_Location_Identifier that identifies the exact joint point or sets of joint points in the process where the aspect will be activated. In this case, identifies the relevant service. Finally, wrapped between BeginBehavior and EndBehavior, the BPEL_Behavior_Code contains the new behavior code that will be weaved in the composition. In our case, this element represents the call for the evaluation engine.

Taking the same sets generated in Fig. 3, the enforcer generates the corresponding aspect illustrated in Fig. 4. The sets declare the financial data as a resource subject to access control evaluation. Accordingly the enforcer generates FinancialData aspect that calls the evaluation engine (Line 9 to Line 14) before (Line 4) invoking the getFinancialData service (Line 5 to Line 8) in order to check the access right of the requestor.
                  

To better illustrate our approach, we suggest a Flight System (FS) as a running example (Fig. 5
                     ). The system is composed of three partners Web services. The Financial Data WS offers access to financial reports. The Flight Inquiries WS displays the flights with their schedules, available seats and comparable tickets prices, according to the user preferences. Finally, the Reservation WS offers the ability to book flight tickets. The system imposes many policies and rules that govern its services. Considering a policy set PS1 for FS that consists of two policies P1 and P2 and has a permit-overrides combining algorithm. P1 defines two rules R1 and R2. R1 permits anyone to access the financial data, while R2 is more restrictive. It gives only the admin the permission to access this resource. On the other hand, P2 defines two other rules R3 and R4. R3 allows anyone to make reservation in the flight agency system while R4 prevents anyone from making reservation after 23:30.

Defining the described policies and rules in XML-based format is without doubt verbose, time consuming and error prone. A design level specification is needed since it allows the designer to easily modify the policies in case anomalies are detected within its rules. Whereas in case the modification of policies is not feasible, and there exist anomalies between policies from different parties, such model-driven approach offers the ability to select others participating in composed model that do not cause anomalies when combined together. Following our approach, the user can create a simple UML model that contains: Policy set PS1, Policies P1 and P2, Rules R1, R2, R3 and R4, Conditions C1 and C2, and Targets and their sub-elements (i.e., subject, resource and action) for each rule. The user then applies systematic transformation on the model based on the proposed UML profile. This is done by:

                           
                              1.
                              Applying PolicySet stereotype on PS1 and specifying its tagged values ID, CA and PPO.

Applying Policy stereotype on P1 and P2 and specifying their tagged values ID, CA and RPO.

Applying Rule stereotype on R1, R2, R3 and R4 and specifying their tagged values ID and RE.

Applying Condition stereotype on C1 and C2 and specifying the appropriate operations Operation.

Applying Target stereotype and its substereotypes on the relevant targets elements and specifying the relevant tagged values of Subject, Resource, and Action.

Associate the elements together.


                        Fig. 6
                         depicts the policy set designation while Figs. 7
                         and 8
                         illustrate the policies specification P1 and P2 and their associated rules R1, R2 and R3, R4 respectively.

According to the set-based constructs that we presented in Section 5, the convertor module generates the sets illustrated in Fig. 9
                         that correspond to the model created in previous step.

The analyzer module takes care of the detecting anomalies existing in the sets based on the analysis technique and algorithms presented in Section 6. The analyzer generates an analysis report to support the designer in locating the problematic rules within and between policies. Fig. 10
                         presents a synopsis of the generated analysis report. The highlighted parts demonstrate the capability of the proposed algorithms to detect access flaws, conflicts and redundancies between policies and rules in the policy set.

XACML supports resolving conflicts between policies and rules using the combing algorithms. Yet it does not provide means to address access flaws and redundancies, which require more customized strategies that can assist the designer. To resolve the detected anomalies, designers have different options. The first can be to cut out the rules overruled by others. The rules to be eliminated are those which are more generic, while those more restrictive are to be kept in the model. For instance, in our example, eliminating R1 from P1 would resolve both access flaw and redundancies. R2 is more restrictive and hence it would be more secure to keep it in the model. Also removing R3 would resolve the conflict (R4 is more restrictive). Therefore, a possible extension to this work is to automate these strategies to include them in our proposition.

After anomalies being resolved, the enforcer generates the corresponding aspects. The latter call the evaluation engine before invoking the requested service in case it is subject to access control checking (i.e., specified in the model).

According to the policies model of FS, access should be controlled over financial data, where access to this resource is restricted to the admin, as well as before making reservation in order to verify the access request time. Figs. 11
                         and 12
                         show the generated aspects accordingly. The enforcer weaves these aspects in the composition in order to call the decision-making engine before granting any access to these services.

@&#EXPERIMENTAL RESULTS@&#

In this section, we present the experiments conducted in order to explore the detection rate, scalability and performance of the anomalies analysis process.

The experiments are done on small and large policies that include rules ranging between 400 and 4000. We use 5 policies to vary the number of rules between 400 and 2000, and 10 policies for rules ranging between 2400 and 4000. Conflicted, redundant and flawed rules were injected with rate that ranges between 1 and 5 for every 10 rules. An interesting observation in this set of experiments is that the analysis process could always achieve 100% detection rate. As for the processing time, it is calculated based on the average of 100k run for every policy set. The injected anomalies are 10%, and the processing time measured includes the conversion to the set-based representation. Fig. 13
                         shows the processing time where 1 out of 10 rules/policies cause access anomalies. With 400 rules, it takes 5.54 s to complete the analysis, while it takes 44 s for 1200 rules and 692 s for 4000 rules. These results demonstrate the performance efficiency of the analysis process for reasonable size of policies. Whereas the additional overhead in the other cases is not critical since such analysis is to be performed offline in most cases.

@&#CONCLUSION@&#

This paper addresses the complex specification of XACML policies, which is verbose, time consuming and error prone especially when multiple policies have to be defined to govern access in Web services composition. It tackles also the detection of anomalies within and among policies, at design-level. The proposed approach includes a UML profile to offer model-driven specification of XACML policies. It differs from the literature by its full coverage of all the constructs in the latest XACML version, offering the ability to designate any policy that can be expressed with this language. The proposition includes also a set-based design-level analysis technique that can detect all three anomalies of conflicts, redundancies and access flaws in the policies model. Differently from existing approaches, the proposed technique is based on logical deductions that explore the meaning of the rules declared in the policies and does not make any assumption or exclude any element of the standard XACML language. The real life case study and experimental results presented in this paper prove the efficiency of our approach and demonstrate the capability of the analysis technique showing 100% detection rate with acceptable overhead.

Two possibilities to extend this work in the future. The first proposition is to assist the designer to resolve the detected anomalies by developing and integrating relevant possible strategies compatible with each of them. The second direction is to work on detecting other type of anomalies, which can be influenced by the combined decisions of several partner Web services in the composition.

@&#ACKNOWLEDGMENTS@&#

This work has been supported by the Associated Research Unit of the National Council for Scientific Research, CNRS-Lebanon, Lebanese American University (LAU), Khalifa University of Science, Technology & Research (KUSTAR), and NSERC Canada.

@&#REFERENCES@&#

