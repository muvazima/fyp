@&#MAIN-TITLE@&#A dense subgraph based algorithm for compact salient image region detection

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Underlying dense subgraphs in a graph can be utilized in finding visually salient regions in an image.


                        
                        
                           
                           Dense subgraphs convey more information about local graph structure than simple centrality measures.


                        
                        
                           
                           Region compactness in addition to image intensity and color features has been used to compute image region similarities.


                        
                        
                           
                           Dense subgraph computation is performed after entropy based thresholding is applied on a sparse graph.


                        
                        
                           
                           Multiple salient objects in a scene are detected with dense subgraph computation.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Visual saliency

Markov chain

Equilibrium distribution

Random walk




                     k-dense subgraph

Compactness

@&#ABSTRACT@&#


               
               
                  We present an algorithm for graph based saliency computation that utilizes the underlying dense subgraphs in finding visually salient regions in an image. To compute the salient regions, the model first obtains a saliency map using random walks on a Markov chain. Next, k-dense subgraphs are detected to further enhance the salient regions in the image. Dense subgraphs convey more information about local graph structure than simple centrality measures. To generate the Markov chain, intensity and color features of an image in addition to region compactness is used. For evaluating the proposed model, we do extensive experiments on benchmark image data sets. The proposed method performs comparable to well-known algorithms in salient region detection.
               
            

@&#INTRODUCTION@&#

The saliency value of a pixel in an image is an indicator of its distinctiveness from its neighbors and thus its ability to attract attention. Visual attention has been successfully applied to many computer vision applications, e.g. adaptive image compression based on region-of-interest [34], object recognition [35–37], and scene classification [38]. Nevertheless, salient region and object detection still remains a challenging task.

The goal of this work is to extract the salient regions in an image by combining superpixel segmentation and a graph theoretic saliency computation. Dense subgraph structures are exploited to obtain an enhanced saliency map. First, we segment the image into regions or superpixels using the SLIC (Simple Linear Iterative Clustering) superpixel segmentation method [18]. Then we obtain a saliency map using the graph based Markov chain random walk model proposed earlier [1], considering intensity, color and compactness as features. Using this saliency map, we create another sparser graph, on which k-dense subgraph is computed. We get a refined saliency map by this technique. The use of dense subgraph on a graph constructed from segmented image regions helps to filter out the densely salient image regions from saliency maps.

A number of graph based saliency algorithms are known in literature that improvise on the dissimilarity measure to model the inter-nodal transition probability [1], provide better random walk procedures like random walk with restart [17], or use combinations of different functions of transition probabilities e.g., site rate entropy function [13] to build their saliency model. However, most graph-based methods produce a blurred saliency map. It would be useful to postprocess the map to filter out the most salient portions. Our model also being a graph based method, uses dense subgraph computation to filter out salient regions after random walk is employed. The suppression of non-salient regions combined with salient region shape retention, yields saliency maps more closely resembling ground truth data as compared to the existing methods used for comparison. This has been achieved by considering a more informative local graph structure, namely, dense subgraphs, than simple centrality measures in obtaining the map.

The remainder of the paper is organized as follows. Section 2 surveys some previously proposed saliency detection algorithms. Section 3 describes the proposed saliency detection procedures. Section 4 is devoted to experimental results and evaluation. We demonstrate that the proposed method achieves superior performance when compared to well-known models, on standard image data sets and also preserves the overall shapes and details of salient regions quite reliably. Finally in Section 5, we conclude this paper with future research issues.

@&#RELATED WORK@&#

Saliency computation is rooted in psychological theories about human attention, such as the feature integration theory (FIT) [43]. The theory states that, several features are processed in parallel in different areas of the human brain, and the feature locations are collected in one “master map of locations”. From this map, “attention” selects the current region of interest. This map is similar to what is nowadays called “saliency map”, and there is strong evidence that such a map exists in the brain. Inspired by the biologically plausible architecture proposed by Koch and Ullman [44], mainly designed to simulate eye movements, Itti et al. [3] introduced a conceptually computational model for visual attention detection. It was based on multiple biological feature maps generated by mimicking human visual cortex neurons. It is related to the FIT theory [43] which outlines the human visual search strategies. The recent survey by Borji and Itti [46] lists a series of visual attention models [46], which demonstrate that eye-movements are guided by both bottom-up (stimulus-driven) and top-down (task-driven) factors.

Region based saliency models have been proposed in a number of works. The early work of Itti et al. [3] was extended by Walther and Koch [14] who proposed a way to extract proto-objects. Proto-objects are defined as spatial extension of the peaks of this saliency map. This approach calculates the most salient points according to the spatial-based model, henceforth the saliency is spread to the regions around them. The work in [30] addresses the problem of detecting irregularities in visual data, e.g., detecting suspicious behaviors in video sequences, or identifying salient patterns in images. The problem is posed as an inference process in a probabilistic graphical model. The framework in [1], is a computer vision implementation of the object based attention model of Duncan [5]. In this paper, a grouping is done by conducting a segmentation method, which acts as the operation unit for saliency computation. In [6], the problem of feature map generation for region-based attention is discussed, but a complete saliency model has not been proposed. The method in [7] is based on preattentive segmentation, dividing the image into segments, which serve as candidates for attention, and a stochastic model is used to estimate saliency. In [8], visual saliency is estimated based on the principle of global contrast, where the region is employed in computation and is used primarily for the sake of speed up. In the work [22], two characteristics: rareness and compactness have been utilized. In this approach, rare and unique parts of an image are identified, followed by aggregating the surrounding regions of the spots to find the salient regions thus imparting compactness to objects. In the method followed in [21], saliency is detected by over-segmenting an image and analyzing the color compactness in the image. Li et al., in their work [32], offer two contributions. First, they compose an eye movement dataset using annotated images from the PASCAL dataset [53]. Second, they propose a model that decouples the salient object detection problem into two processes: (1) a segment generation process, and (2) a saliency scoring mechanism using fixation prediction. A novel propagation mechanism, dependent on Cellular Automata, is presented in [33] which exploits the intrinsic relevance of similar regions through interactions with neighbors. Here, multiple saliency maps are integrated in a Bayesian framework.

Several graph based saliency models have been suggested so far. It is shown in [9] that gaze shift can be considered as a random walk over a saliency field. In [10], random walks on graphs enable the identification of salient regions by determining the frequency of visits to each node at equilibrium. Harel et al. [1] proposed an improved dissimilarity measure to model the transition probability between two nodes. These kinds of methods consider information to be the driving force behind attentive sampling and use feature rarity to measure visual saliency. In this article, we base our model on such a graph based model and utilize the embedded dense subgraphs to better extract the most salient regions from an image. The work in [11] provides a better scheme to define the transition probabilities among the graph nodes and thus constructs a practical framework for saliency computation. Wang et al. [13] generated several feature maps by filtering an input image with sparse coding basis functions. Then they computed the overall saliency map by multiplying saliency maps obtained using two methods: one is the random walk method and the other based on the entropy rate of the Markov chain. Gopalakrishnan et al. [11,12] formulated the salient region detection as random walks on a fully connected graph and a k-regular graph to consider both global and local image properties in saliency detection. They select the most important node and background nodes and used them to extract a salient object. Jiang et al. [29] consider the absorption time of the absorbing nodes in a Markov chain (constructed on a region similarity graph) and separate the salient objects from the background by a global similarity measure. Yang et al. [28] ranks the similarity of the image regions with foreground cues or background cues via graph-based manifold ranking, and detects background region and foreground salient objects. In a more recent work by Changyang et al. [31], a novel bottom-up saliency detection approach has been proposed that takes advantage of both region-based features and image details. The image boundary selection is optimized by the proposed erroneous boundary removal and regularized random walks ranking is implemented to formulate pixel-wised saliency maps from the superpixel-based background and foreground saliency estimations.

Many other saliency systems have also been presented in previous years. There are approaches that are based on the spectral analysis of images [41,45], models that based on information theory [39,40], Bayesian theory [49,50]. Other algorithms use machine learning techniques to learn a combination of features [47,48] or employ deep learning techniques [42] to detect salient objects.

Our method aims to enhance graph based saliency computation techniques by considering higher level graph structures as compared to those utilized in Markov chain based measures. Note that it can be used in conjunction with any graph based saliency computation algorithm. We use superpixels, that are obtained by pre-segmentation while constructing the graphs. The goal here is to extract salient regions rather than pixels. In this section, we describe the proposed model of region-based visual saliency. We follow a multi-step approach to saliency detection. The block diagram is illustrated in Fig. 1
                      and the steps are mentioned below:


                     Step 1: SLIC superpixel segmentation method [18] is applied on the original image to generate image regions or superpixels.


                     Step 2: A saliency map is obtained by implementing graph based saliency model [1] on the region based graph taking three feature channels L
                     *, a
                     * and b
                     * (considered from the CIEL*a*b* color space) and the compactness factor for saliency computation.


                     Step 3: The graph corresponding to the saliency map obtained in step 2 is edge thresholded to form a sparser graph.


                     Step 4: Dense subgraph computation is performed on the sparse graph constructed in step 3, which results in detection of highly salient regions.


                     Step 5: Final saliency map is obtained after saliency assignment based on step 4 followed by map normalization.

It might be observed from Fig. 1, that we extract the feature information and then apply the graph based saliency model to get an intermediate saliency map, which is further refined by dense subgraph computation to obtain the final saliency map. The method constructs the connectivity graph based on image segments or superpixels, unlike Harel et al. [1] which computes the graph based on rectangular regions. Throughout the paper, CIEL*a*b* color space has been used, as Euclidean distances in this color space are perceptually uniform and it has been experimentally found out in [16] to give better results as compared to HSV, RGB and YCbCr spaces. We describe in subsequent sections the individual steps in details.


                        Superpixel Segmentation: The image is segmented using SLIC superpixel segmentation [18]. Firstly, the RGB color image is converted to the CIE L*a*b*, a perceptual uniform color space, which is designed to approximate human vision. The next step consists of creating superpixels using SLIC algorithm which divides the image into smaller regions. A value of 250 pixels per superpixel is used in our experiment. For higher values of pixels per superpixel, the computation time increases and for lower values of it, region boundaries are not preserved well.


                        Feature Extraction: Four feature channels in three different spatial scales (1, 
                           
                              1
                              2
                           
                         and 
                           
                              1
                              4
                           
                        ) of the image are extracted. As the L* channel (a measure of lightness) relates to the intensity of an image, it is considered a feature channel. Similarly, as a* and b* components of the CIEL*a*b* color space correspond to the opponent colors, they are taken as feature channels representing the color aspect of the image. The fourth feature channel represents the compactness aspect of regions in the image. Normalized maps of the 12 (
                           
                              =
                              4
                              ×
                              3
                           
                        ) feature channels are used in this experiment. All maps in this paper are normalized as per Eq. (1). Note here that, we do not use the multi-angle gabor filter based orientation maps, unlike [1]. We rather incorporate compactness as a feature, as most salient objects tend to have compact image regions as well as well defined object boundaries and the compactness measure ensures that the background regions with relatively less compact regions, receive lesser mean region saliency values in further computations. The red-green and the yellow-blue opponent colors feature (used in [1]) are represented by the a* and the b* channels respectively.

                           
                              (1)
                              
                                 
                                    N
                                    o
                                    r
                                    m
                                    M
                                    a
                                    p
                                    
                                       (
                                       
                                          M
                                          i
                                       
                                       )
                                    
                                    =
                                    
                                       
                                          
                                             M
                                             i
                                          
                                          −
                                          
                                             M
                                             
                                                m
                                                i
                                                n
                                             
                                          
                                       
                                       
                                          
                                             M
                                             
                                                m
                                                a
                                                x
                                             
                                          
                                          −
                                          
                                             M
                                             
                                                m
                                                i
                                                n
                                             
                                          
                                       
                                    
                                    ,
                                 
                              
                           
                        where Mi
                         is the feature map value at pixel i. NormMap(Mi
                        ) is the normalized map value, Mmax
                         and Mmin
                         denote the maximum and minimum map intensities respectively. We follow the method in Kim et al. [17] to measure compactness. Firstly, spatial clustering is performed on each of the three feature maps F
                           
                              
                              
                                 L
                                 *
                              
                           
                         , F
                           
                              
                              
                                 a
                                 *
                              
                           
                         and F
                           
                              
                                 
                                 
                                    b
                                    *
                                 
                              
                              ,
                           
                         assuming that a cluster consists of pixels with similar values and geometrical coordinates. Pixel values in each feature map F
                           
                              
                              
                                 L
                                 *
                              
                           
                         , F
                           
                              
                              
                                 a
                                 *
                              
                           
                         and F
                           
                              
                              
                                 b
                                 *
                              
                           
                         are scaled to the range [0, 255] and quantized to the nearest integers. Then, for each integer n, an observation vector tn
                         is defined as in Eq. (2).

                           
                              (2)
                              
                                 
                                    
                                       t
                                       n
                                    
                                    =
                                    
                                       
                                          [
                                          
                                             λ
                                             
                                                x
                                                ,
                                                n
                                             
                                          
                                          ,
                                          
                                             λ
                                             
                                                y
                                                ,
                                                n
                                             
                                          
                                          ,
                                          β
                                          n
                                          ]
                                       
                                       T
                                    
                                    ,
                                    
                                    0
                                    
                                    ≤
                                    
                                    n
                                    
                                    ≤
                                    
                                    255
                                    ,
                                 
                              
                           
                        where λ
                        
                           x, n
                         and λ
                        
                           y, n
                         denote the average x and y coordinates of the pixels with value n, and β is a constant factor for adjusting the scale of a pixel value to that of a pixel position. 
                           
                              β
                              =
                              
                                 
                                    m
                                    a
                                    x
                                    {
                                    W
                                    ,
                                    H
                                    }
                                 
                                 256
                              
                              ,
                           
                         where W and H are the width and height of the input image. These 256 observation vectors are now partitioned into k clusters, {R
                        1, R
                        2, ..., Rk
                        }, using the k-means clustering [20]. The number k of clusters is eight in this paper. Now, the compactness c(Rk
                        ) of each cluster Rk
                         as defined in Eq. (3), is measured as being inversely proportional to the spatial variance of pixel positions in Rk
                        .

                           
                              (3)
                              
                                 
                                    c
                                    
                                       (
                                       
                                          R
                                          k
                                       
                                       )
                                    
                                    =
                                    e
                                    x
                                    p
                                    
                                       (
                                       −
                                       α
                                       .
                                       
                                          
                                             
                                                σ
                                                
                                                   x
                                                   ,
                                                   k
                                                
                                             
                                             +
                                             
                                                σ
                                                
                                                   y
                                                   ,
                                                   k
                                                
                                             
                                          
                                          
                                             
                                                
                                                   W
                                                   2
                                                
                                                +
                                                
                                                   H
                                                   2
                                                
                                             
                                          
                                       
                                       )
                                    
                                    ,
                                 
                              
                           
                        where σ
                        
                           x, k
                         and σ
                        
                           y, k
                         are the standard deviations of the x and y coordinates of pixels in Rk
                        , and α is empirically set to 10. However, to ignore small outliers, c(Rk
                        ) is set to 0 when the number of pixels in Rk
                         is less than 3% of the image size. This way we get three compactness maps from feature maps F
                           
                              
                                 
                                 
                                    L
                                    *
                                 
                              
                              ,
                           
                         F
                           
                              
                              
                                 a
                                 *
                              
                           
                         and F
                           
                              
                              
                                 b
                                 *
                              
                           
                         respectively. By taking the square root of the sum of squares of the three compactness maps we obtain the final compactness map as in Eq. (4)
after normalization.

                           
                              (4)
                              
                                 
                                    
                                       
                                       
                                       
                                          
                                             c
                                             o
                                             m
                                             p
                                             a
                                             c
                                             t
                                             M
                                             a
                                             p
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             
                                             =
                                             
                                                
                                                   c
                                                   o
                                                   m
                                                   p
                                                   a
                                                   c
                                                   t
                                                   M
                                                   a
                                                   
                                                      p
                                                      
                                                         
                                                            L
                                                            *
                                                         
                                                      
                                                      2
                                                   
                                                   +
                                                   c
                                                   o
                                                   m
                                                   p
                                                   a
                                                   c
                                                   t
                                                   M
                                                   a
                                                   
                                                      p
                                                      
                                                         
                                                            a
                                                            *
                                                         
                                                      
                                                      2
                                                   
                                                   +
                                                   c
                                                   o
                                                   m
                                                   p
                                                   a
                                                   c
                                                   t
                                                   M
                                                   a
                                                   
                                                      p
                                                      
                                                         
                                                            b
                                                            *
                                                         
                                                      
                                                      2
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

Now a segmented region ri
                         obtained by SLIC superpixel method, is assigned a compactness value ci
                        , which is the average compactness of the pixels within that region or superpixel.

This section shows the procedures followed to obtain different graphs and the associated saliency maps.

After obtaining the segmented image regions by SLIC superpixel approach, we proceed to create a graph Gimage
                            by considering segmented image regions as nodes and distance (Euclidean distance and feature space distance) between the regions as edges of the graph as follows: The edge weight 
                              
                                 
                                    w
                                    
                                       c
                                       o
                                       m
                                       b
                                       i
                                       n
                                       e
                                       d
                                    
                                    
                                       i
                                       m
                                       a
                                       g
                                       e
                                    
                                 
                                 
                                    (
                                    i
                                    ,
                                    j
                                    )
                                 
                              
                            connecting node i (representing region ri
                           ) and node j (representing region rj
                           ) is taken as the product of combined feature distance of the considered feature values (intensity or color component values) represented by weight 
                              
                                 
                                    w
                                    
                                       f
                                       e
                                       a
                                       t
                                       u
                                       r
                                       e
                                    
                                    
                                       i
                                       m
                                       a
                                       g
                                       e
                                    
                                 
                                 
                                    (
                                    i
                                    ,
                                    j
                                    )
                                 
                              
                            in Eq. (6), spatial distance (Euclidean distance) between the segmented regions represented by weight 
                              
                                 
                                    w
                                    
                                       s
                                       p
                                       a
                                       t
                                       i
                                       a
                                       l
                                    
                                    
                                       i
                                       m
                                       a
                                       g
                                       e
                                    
                                 
                                 
                                    (
                                    i
                                    ,
                                    j
                                    )
                                 
                              
                            in Eq. (7) and compactness weight, 
                              
                                 
                                    w
                                    
                                       c
                                       o
                                       m
                                       p
                                       a
                                       c
                                       t
                                       n
                                       e
                                       s
                                       s
                                    
                                    
                                       i
                                       m
                                       a
                                       g
                                       e
                                    
                                 
                                 
                                    (
                                    i
                                    ,
                                    j
                                    )
                                 
                              
                            in Eq. (8), which varies according to the compactness of ri
                            and rj
                           . We followed our base model GBVS [1], to formulate the combined weight as the product of different weights.

                              
                                 (5)
                                 
                                    
                                       
                                          I
                                          
                                             i
                                             m
                                             a
                                             g
                                             e
                                          
                                       
                                       =
                                       
                                          
                                             [
                                             
                                                I
                                                
                                                   L
                                                   *
                                                
                                             
                                             ,
                                             
                                                I
                                                
                                                   a
                                                   *
                                                
                                             
                                             ,
                                             
                                                I
                                                
                                                   b
                                                   *
                                                
                                             
                                             ]
                                          
                                          T
                                       
                                       ,
                                    
                                 
                              
                           where I
                              
                                 
                                    
                                    
                                       L
                                       *
                                    
                                 
                                 ,
                              
                            I
                              
                                 
                                 
                                    a
                                    *
                                 
                              
                            and I
                              
                                 
                                 
                                    b
                                    *
                                 
                              
                           are the normalized feature intensity maps corresponding to L*, a* and b* components of the image, respectively and Iimage
                            is a vector containing these three feature maps.

                              
                                 (6)
                                 
                                    
                                       
                                          w
                                          
                                             f
                                             e
                                             a
                                             t
                                             u
                                             r
                                             e
                                          
                                          
                                             i
                                             m
                                             a
                                             g
                                             e
                                          
                                       
                                       
                                          (
                                          i
                                          ,
                                          j
                                          )
                                       
                                       =
                                       
                                          
                                             
                                                ∑
                                                
                                                   k
                                                   =
                                                   1
                                                
                                                3
                                             
                                             
                                                
                                                   (
                                                   
                                                      I
                                                      
                                                         i
                                                         ,
                                                         k
                                                      
                                                      
                                                         i
                                                         m
                                                         a
                                                         g
                                                         e
                                                      
                                                   
                                                   −
                                                   
                                                      I
                                                      
                                                         j
                                                         ,
                                                         k
                                                      
                                                      
                                                         i
                                                         m
                                                         a
                                                         g
                                                         e
                                                      
                                                   
                                                   )
                                                
                                                2
                                             
                                          
                                       
                                       ,
                                    
                                 
                              
                           where 
                              
                                 I
                                 
                                    i
                                    ,
                                    k
                                 
                                 
                                    i
                                    m
                                    a
                                    g
                                    e
                                 
                              
                            and 
                              
                                 I
                                 
                                    j
                                    ,
                                    k
                                 
                                 
                                    i
                                    m
                                    a
                                    g
                                    e
                                 
                              
                            are the mean intensity values of the feature channel k (k = 1, 2 and 3 for L*, a* and b* channels respectively) considered for nodes (superpixels) i and j respectively.

                              
                                 (7)
                                 
                                    
                                       
                                          w
                                          
                                             s
                                             p
                                             a
                                             t
                                             i
                                             a
                                             l
                                          
                                          
                                             i
                                             m
                                             a
                                             g
                                             e
                                          
                                       
                                       
                                          (
                                          i
                                          ,
                                          j
                                          )
                                       
                                       =
                                       1
                                       −
                                       
                                          (
                                          
                                             
                                                
                                                   
                                                      
                                                         (
                                                         
                                                            x
                                                            i
                                                         
                                                         −
                                                         
                                                            x
                                                            j
                                                         
                                                         )
                                                      
                                                      2
                                                   
                                                   +
                                                   
                                                      
                                                         (
                                                         
                                                            y
                                                            i
                                                         
                                                         −
                                                         
                                                            y
                                                            j
                                                         
                                                         )
                                                      
                                                      2
                                                   
                                                
                                             
                                             D
                                          
                                          )
                                       
                                       ,
                                    
                                 
                              
                           where xn
                            and yn
                            represent the centroids or the mean x and y coordinate values of a node n representing a region rn
                            respectively and D is the diagonal length of the image.

                              
                                 (8)
                                 
                                    
                                       
                                          w
                                          
                                             c
                                             o
                                             m
                                             p
                                             a
                                             c
                                             t
                                             n
                                             e
                                             s
                                             s
                                          
                                          
                                             i
                                             m
                                             a
                                             g
                                             e
                                          
                                       
                                       
                                          (
                                          i
                                          ,
                                          j
                                          )
                                       
                                       =
                                       
                                          (
                                          1
                                          +
                                          
                                             
                                                
                                                   |
                                                
                                                
                                                   c
                                                   i
                                                
                                                −
                                                
                                                   c
                                                   j
                                                
                                                
                                                   |
                                                
                                             
                                             2
                                          
                                          )
                                       
                                       ,
                                    
                                 
                              
                           where ci
                            and cj
                            represent the compactness of the regions ri
                            and rj
                            , as explained in the previous section. The compactness weight factor 
                              
                                 w
                                 
                                    c
                                    o
                                    m
                                    p
                                    a
                                    c
                                    t
                                    n
                                    e
                                    s
                                    s
                                 
                                 
                                    i
                                    m
                                    a
                                    g
                                    e
                                 
                              
                            is modeled as followed in [17]. This compactness term increases weight w(i, j) , when ri
                            has a low compactness value and rj
                            has a high compactness value or vice-versa, thus putting more emphasis on the transition from a less compact object to a more compact object, because a more compact object is generally regarded as more salient.

                              
                                 (9)
                                 
                                    
                                       
                                          w
                                          
                                             c
                                             o
                                             m
                                             b
                                             i
                                             n
                                             e
                                             d
                                          
                                          
                                             i
                                             m
                                             a
                                             g
                                             e
                                          
                                       
                                       
                                          (
                                          i
                                          ,
                                          j
                                          )
                                       
                                       =
                                       
                                          w
                                          
                                             f
                                             e
                                             a
                                             t
                                             u
                                             r
                                             e
                                          
                                          
                                             i
                                             m
                                             a
                                             g
                                             e
                                          
                                       
                                       
                                          (
                                          i
                                          ,
                                          j
                                          )
                                       
                                       .
                                       
                                          w
                                          
                                             s
                                             p
                                             a
                                             t
                                             i
                                             a
                                             l
                                          
                                          
                                             i
                                             m
                                             a
                                             g
                                             e
                                          
                                       
                                       
                                          (
                                          i
                                          ,
                                          j
                                          )
                                       
                                       .
                                       
                                          w
                                          
                                             c
                                             o
                                             m
                                             p
                                             a
                                             c
                                             t
                                             n
                                             e
                                             s
                                             s
                                          
                                          
                                             i
                                             m
                                             a
                                             g
                                             e
                                          
                                       
                                       
                                          (
                                          i
                                          ,
                                          j
                                          )
                                       
                                    
                                 
                              
                           
                        


                           
                              
                                 w
                                 
                                    c
                                    o
                                    m
                                    b
                                    i
                                    n
                                    e
                                    d
                                 
                                 
                                    i
                                    m
                                    a
                                    g
                                    e
                                 
                              
                            represents the final edge weight between the nodes i and j.

We use the graph based visual saliency (GBVS) method in [1] to generate a saliency map, MGBVS
                            from the graph Gimage
                           . Based on the graph structure, we derive an N × N transition matrix TP, where N is the number of nodes in the graph Gimage
                           . The element TP(i, j), which is proportional to the graph weight w(i, j), is the probability with which a random walker at node i transits to node j. To obtain TP, we first form an N × N matrix A, whose (i, j)th element is 
                              
                                 A
                                 (
                                 i
                                 ,
                                 j
                                 )
                                 =
                                 w
                                 (
                                 i
                                 ,
                                 j
                                 )
                              
                           . The degree of a node is calculated as the sum of the weights of all outgoing edges. The degree matrix W of the graph Gimage
                            is a diagonal matrix, whose ith diagonal element is the degree of node i, as computed in Eq. (10).

                              
                                 (10)
                                 
                                    
                                       W
                                       
                                          (
                                          i
                                          ,
                                          i
                                          )
                                       
                                       =
                                       
                                          ∑
                                          j
                                       
                                       w
                                       
                                          (
                                          i
                                          ,
                                          j
                                          )
                                       
                                    
                                 
                              
                           
                        

The sum of the elements in each column of TP should be 1, since the sum of the transition probabilities for a node should be 1. Hence, we obtain the transition matrix TP as:

                              
                                 (11)
                                 
                                    
                                       T
                                       P
                                       =
                                       A
                                       
                                          W
                                          
                                             −
                                             1
                                          
                                       
                                       .
                                    
                                 
                              
                           
                        

The movements of the random walker form a Markov chain [51] with the transition matrix TP. Notice here that, the equilibrium distribution of Markov chain exists and is unique because the chain is ergodic (aperiodic, irreducible, and positive recurrent), which can be attributed to the fact that the underlying graph Gimage
                            has a finite number of nodes and is fully connected by construction. The unique equilibrium (or stationary) distribution π of the Markov chain satisfies Eq. (12).

                              
                                 (12)
                                 
                                    
                                       π
                                       =
                                       T
                                       P
                                       ·
                                       π
                                    
                                 
                              
                           
                        

The equilibrium distribution of this chain reflects the fraction of time a random walker would spend at each node/state if he were to walk forever. In such a distribution, large values are assigned to nodes that are highly dissimilar to the surrounding nodes. Thus, the walker at node i moves to node j with a high probability when the edge weight w(i, j) is large. Transition probabilities (TP) form an activation measure which is derived from pairwise contrast in pixel intensities as well as spatial distance between the pixels [1]. Here, instead of considering pixels, we group pixels into superpixels and then consider transition probabilities for the nodes (each of which represents a superpixel) as being equal to the equilibrium state probabilities attained on the Markov chain formed on the graph with edge weight, 
                              
                                 w
                                 
                                    c
                                    o
                                    m
                                    b
                                    i
                                    n
                                    e
                                    d
                                 
                                 
                                    i
                                    m
                                    a
                                    g
                                    e
                                 
                              
                           . Thus, transition probabilities for all nodes at equilibrium distribution are obtained. A node with higher equilibrium transition probability represents a more salient region as compared to another node with lesser probability. Fig. 2
                            shows how different equilibrium transition probabilities are assigned to segmented regions (six segments shown for convenience) and the obtained graph based saliency map.

Now, let P(m, n) be a pixel (m and n being the pixel coordinates) which is grouped under a superpixel corresponding to node i. Let 
                              
                                 
                                    p
                                    i
                                 
                                 =
                                 π
                                 
                                    (
                                    i
                                    )
                                 
                                 ,
                              
                            where π(i) is the ith element of the stationary distribution π. π(i) is the probability that the random walker stays at node i in the equilibrium condition. Let pmax
                            and pmin
                            denote the maximum and minimum values of π over all nodes respectively. For each pixel of the image, its saliency value in the map MGBVS
                            is calculated as in Eq. (13).

                              
                                 (13)
                                 
                                    
                                       
                                          M
                                          
                                             G
                                             B
                                             V
                                             S
                                          
                                       
                                       
                                          (
                                          m
                                          ,
                                          n
                                          )
                                       
                                       =
                                       
                                          
                                             (
                                             
                                                
                                                   
                                                      p
                                                      i
                                                   
                                                   −
                                                   
                                                      p
                                                      
                                                         m
                                                         i
                                                         n
                                                      
                                                   
                                                
                                                
                                                   
                                                      p
                                                      
                                                         m
                                                         a
                                                         x
                                                      
                                                   
                                                   −
                                                   
                                                      p
                                                      
                                                         m
                                                         i
                                                         n
                                                      
                                                   
                                                
                                             
                                             )
                                          
                                          2
                                       
                                    
                                 
                              
                           
                        

In Eq. (13), the map values are obtained by probability normalization followed by squaring, to highlight conspicuity. This generates the pixelwise saliency map MGBVS
                            from graph Gimage
                           . The salient regions are made more salient and the non-salient regions are adequately suppressed. Thus we get the GBVS saliency map MGBVS
                            by the above method of Markov random walk on the connectivity graph Gimage
                           .

Next, the graph GGBVS
                            is constructed based on the saliency map MGBVS
                           . To generate the graph GGBVS
                           , we follow a similar procedure as followed for constructing the graph Gimage
                           . Similar to the graph Gimage
                           , the graph GGBVS
                            is a fully
                            connected graph as we consider all possible edges in the graph construction. The same segmented regions as obtained by SLIC segmentation in case of Gimage
                            construction, are considered over the saliency map MGBVS
                            for creation of graph GGBVS
                           . The mean saliency value of each region in map MGBVS
                            is computed by averaging the saliency values in the region. Ii
                           
                           
                              GBVS
                            and Ij
                           
                           
                              GBVS
                            are the computed mean saliency values of regions ri
                            and rj
                            respectively, in the map MGBVS
                           . The weight 
                              
                                 
                                    w
                                    
                                       c
                                       o
                                       m
                                       b
                                       i
                                       n
                                       e
                                       d
                                    
                                    
                                       G
                                       B
                                       V
                                       S
                                    
                                 
                                 
                                    (
                                    i
                                    ,
                                    j
                                    )
                                 
                              
                            of the edge connecting node i and node j (corresponding to regions ri
                            and rj
                            respectively) is calculated based on spatial similarity, feature similarity and compactness similarity between the two segmented regions, as shown in Eq. (16). As the edge weight 
                              
                                 w
                                 
                                    c
                                    o
                                    m
                                    p
                                    a
                                    c
                                    t
                                    n
                                    e
                                    s
                                    s
                                 
                                 
                                    i
                                    m
                                    a
                                    g
                                    e
                                 
                              
                            is calculated based on a separate clustering procedure as described previously in Eq. (8), the same edge weight which accounts for region compactness is used. Fig. 3 illustrates the followed procedure.


                           Eqs. 14 and 15 compute the different edge weights (feature and spatial respectively) necessary to construct the graph GGBVS
                           .

                              
                                 (14)
                                 
                                    
                                       
                                          w
                                          
                                             f
                                             e
                                             a
                                             t
                                             u
                                             r
                                             e
                                          
                                          
                                             G
                                             B
                                             V
                                             S
                                          
                                       
                                       
                                          (
                                          i
                                          ,
                                          j
                                          )
                                       
                                       =
                                       
                                          |
                                          
                                             I
                                             
                                                i
                                             
                                             
                                                G
                                                B
                                                V
                                                S
                                             
                                          
                                          −
                                          
                                             I
                                             
                                                j
                                             
                                             
                                                G
                                                B
                                                V
                                                S
                                             
                                          
                                          |
                                       
                                    
                                 
                              
                           where Ii
                           
                           
                              GBVS
                            and Ij
                           
                           
                              GBVS
                            are the mean saliency values of regions ri
                            and rj
                            respectively, in the map MGBVS
                           .

                              
                                 (15)
                                 
                                    
                                       
                                          w
                                          
                                             s
                                             p
                                             a
                                             t
                                             i
                                             a
                                             l
                                          
                                          
                                             G
                                             B
                                             V
                                             S
                                          
                                       
                                       
                                          (
                                          i
                                          ,
                                          j
                                          )
                                       
                                       =
                                       1
                                       −
                                       
                                          (
                                          
                                             
                                                
                                                   
                                                      
                                                         (
                                                         
                                                            x
                                                            i
                                                         
                                                         −
                                                         
                                                            x
                                                            j
                                                         
                                                         )
                                                      
                                                      2
                                                   
                                                   +
                                                   
                                                      
                                                         (
                                                         
                                                            y
                                                            i
                                                         
                                                         −
                                                         
                                                            y
                                                            j
                                                         
                                                         )
                                                      
                                                      2
                                                   
                                                
                                             
                                             D
                                          
                                          )
                                       
                                    
                                 
                              
                           where (xn, yn
                           ) represents the centroid of a node n representing a region rn
                            and D is the diagonal length of the image. 
                              
                                 
                                    w
                                    
                                       s
                                       p
                                       a
                                       t
                                       i
                                       a
                                       l
                                    
                                    
                                       G
                                       B
                                       V
                                       S
                                    
                                 
                                 
                                    (
                                    i
                                    ,
                                    j
                                    )
                                 
                              
                            is similar to 
                              
                                 
                                    w
                                    
                                       s
                                       p
                                       a
                                       t
                                       i
                                       a
                                       l
                                    
                                    
                                       i
                                       m
                                       a
                                       g
                                       e
                                    
                                 
                                 
                                    (
                                    i
                                    ,
                                    j
                                    )
                                 
                              
                            in Eq. (7).

                              
                                 (16)
                                 
                                    
                                       
                                          w
                                          
                                             c
                                             o
                                             m
                                             b
                                             i
                                             n
                                             e
                                             d
                                          
                                          
                                             G
                                             B
                                             V
                                             S
                                          
                                       
                                       
                                          (
                                          i
                                          ,
                                          j
                                          )
                                       
                                       =
                                       
                                          w
                                          
                                             f
                                             e
                                             a
                                             t
                                             u
                                             r
                                             e
                                          
                                          
                                             G
                                             B
                                             V
                                             S
                                          
                                       
                                       
                                          (
                                          i
                                          ,
                                          j
                                          )
                                       
                                       .
                                       
                                          w
                                          
                                             s
                                             p
                                             a
                                             t
                                             i
                                             a
                                             l
                                          
                                          
                                             G
                                             B
                                             V
                                             S
                                          
                                       
                                       
                                          (
                                          i
                                          ,
                                          j
                                          )
                                       
                                       .
                                       
                                          w
                                          
                                             c
                                             o
                                             m
                                             p
                                             a
                                             c
                                             t
                                             n
                                             e
                                             s
                                             s
                                          
                                          
                                             G
                                             B
                                             V
                                             S
                                          
                                       
                                       
                                          (
                                          i
                                          ,
                                          j
                                          )
                                       
                                    
                                 
                              
                           Thus, the graph GGBVS
                            is constructed. The graph GGBVS
                           , based on the saliency map MGBVS
                           , is a fully connected graph or a clique. So, in order to determine the density of this graph to compute its k-dense subgraph, we need to threshold the edges to form a sparse graph whose weights will be above a certain threshold. To determine the required threshold for each graph we use the entropy based thresholding method followed in [2] .

First we select an edge-weight threshold T, which is varied between the minimum and the maximum edge weight in the graph GGBVS
                        . Next taking this threshold T, we form two sets of edges, one set SD
                         representing discarded set of edges and the other set, SS
                         the selected set of edges. Let wi
                         be the weight of an edge Ei
                        . For a particular threshold T, the ratio of summation of weights for SD
                         to the weights for the set SD
                         ∪ SS, r is calculated as in Eq. (17).

                           
                              (17)
                              
                                 
                                    r
                                    =
                                    
                                       
                                          
                                             ∑
                                             
                                                
                                                   w
                                                   i
                                                
                                                ⩽
                                                T
                                             
                                          
                                          
                                             w
                                             i
                                          
                                       
                                       
                                          
                                             ∑
                                             i
                                          
                                          
                                             w
                                             i
                                          
                                       
                                    
                                 
                              
                           
                        
                     

Edge-weight entropy En of discarded and selected set of edges is defined as:

                           
                              (18)
                              
                                 
                                    E
                                    n
                                    =
                                    −
                                    r
                                    log
                                    (
                                    r
                                    )
                                    −
                                    (
                                    1
                                    −
                                    r
                                    )
                                    log
                                    (
                                    1
                                    −
                                    r
                                    )
                                 
                              
                           
                        
                     

Edge-weight entropy En varies with threshold T. The threshold for which edge-weight entropy is maximum is chosen as the edge-weight threshold Tmax
                        . Note here that, r is a non-decreasing function of T and En attains the maximum value at only one particular value of r, which corresponds to threshold Tmax
                        . Specifically, 
                           
                              r
                              =
                              0.5
                              +
                              
                                 
                                    
                                       4
                                       +
                                       
                                          e
                                          2
                                       
                                    
                                 
                                 
                                    2
                                    e
                                 
                              
                           
                         when 
                           
                              
                                 
                                    ∂
                                    E
                                    n
                                 
                                 
                                    ∂
                                    r
                                 
                              
                              =
                              0
                           
                        . Fig. 4 shows the variation of the mean entropy, Enmean
                         of all images in the ASD dataset [15]. In our experiment, we sampled the mean entropy value, Enmean
                         at a threshold interval of 0.05, starting from 
                           
                              
                                 T
                                 i
                              
                              =
                              0.10
                           
                         and ending with 
                           
                              
                                 T
                                 f
                              
                              =
                              0.95
                           
                        . A threshold value, 
                           
                              
                                 T
                                 
                                    m
                                    a
                                    x
                                    E
                                    n
                                 
                              
                              =
                              a
                              r
                              g
                              m
                              a
                              
                                 x
                                 T
                              
                              
                                 (
                                 E
                                 
                                    n
                                    
                                       m
                                       e
                                       a
                                       n
                                    
                                 
                                 )
                              
                              =
                              0.40
                           
                         was found to yield the highest mean entropy, 
                           
                              E
                              
                                 n
                                 
                                    m
                                    e
                                    a
                                    n
                                 
                              
                              =
                              0.654
                           
                         on the ASD dataset [15]. Note here that, 
                           
                              
                                 T
                                 
                                    m
                                    a
                                    x
                                    E
                                    n
                                 
                              
                              =
                              0.40
                           
                         shown in Fig. 4 , indicates the threshold value which yields the highest mean entropy on all images in the ASD dataset [15], whereas the threshold T used for an individual image depends on the maximum entropy value En obtained for that particular image.

After thresholding the graph GGBVS
                         with threshold Tmax
                        , we get a modified thresholded sparse graph 
                           
                              G
                              
                                 G
                                 B
                                 V
                                 S
                              
                              
                                 t
                                 h
                                 r
                                 e
                                 s
                                 h
                              
                           
                        . In this paper, we apply dense subgraph computation to a graph to refine out nodes with high degrees. This ensures that we choose the most salient regions, as node degree is directly proportional to region saliency. But a fully connected graph has all nodes with the same degree. Thus in this case, dense subgraph computation treats all nodes with equal importance and selects all nodes for inclusion in dense subgraph set. To circumvent this, we threshold the graph to eliminate weak edges based on the entropy Eq. (18) and allow edges above a certain threshold value (a threshold that maximizes the entropy value) to participate in the dense subgraph computation.

Now we intend to find the k-dense subgraph (DkS) from the graph 
                           
                              G
                              
                                 G
                                 B
                                 V
                                 S
                              
                              
                                 t
                                 h
                                 r
                                 e
                                 s
                                 h
                              
                           
                         following the procedures used in [4]. The density dG
                         of a graph G(V, E) is its average degree. That is 
                           
                              
                                 d
                                 G
                              
                              =
                              
                                 2
                                 |
                                 E
                                 |
                              
                              /
                              
                                 |
                                 V
                                 |
                              
                           
                         . Having discussed about the density of a graph, we define densest subgraph as a subgraph of maximum density on a given graph. The objective of the dense k-subgraph problem is to find the maximum density subgraph on exactly k vertices. The problem is NP-hard, by reduction from Clique. Therefore an approximation algorithm for the problem is considered. On any input (G, k), the algorithm returns a subgraph of size k whose average degree is within a factor of at most nδ
                         from the optimum solution, where n is the number of vertices in the input graph G, and 
                           
                              δ
                              <
                              
                                 1
                                 3
                              
                           
                         is some universal constant. Specifically, for every graph G and every 1 ≤ k ≤ n, 
                           
                              A
                              
                                 (
                                 G
                                 ,
                                 k
                                 )
                              
                              ≥
                              
                                 
                                    
                                       d
                                       *
                                    
                                    
                                       (
                                       G
                                       ,
                                       k
                                       )
                                    
                                 
                                 
                                    2
                                    ·
                                    
                                       n
                                       
                                          1
                                          /
                                          3
                                       
                                    
                                 
                              
                              ,
                           
                         where A(G, k) is the density of the k-dense subgraph approximated with an algorithm A and d
                        *(G, k) is the density of the actual k-dense subgraph in graph G.

We compute the dense subgraph with k nodes (as defined by the user) on the thresholded graph we obtained in the previous section, 
                           
                              G
                              
                                 G
                                 B
                                 V
                                 S
                              
                              
                                 t
                                 h
                                 r
                                 e
                                 s
                                 h
                              
                           
                         following the procedures mentioned in [4]. The dense k-subgraph problem has an input a graph 
                           
                              G
                              =
                              G
                              (
                              V
                              ,
                              E
                              )
                           
                         (on n vertices) and a parameter k. The output is Gdense
                        , a subgraph of G induced on k vertices, such that Gdense
                         is of maximum density and the density of which is denoted by 
                           
                              d
                              
                                 G
                                 ,
                                 k
                              
                              *
                           
                        . Let us assume that G has at least k/2 edges. Fig. 5
                        (c) shows the sparse graph formed after thresholding the clique obtained by taking segmented region centroids (Fig. 5(b)) as nodes, with edge weights assigned according to methods described in Section 3.2. Fig. 5(d) shows the dense subgraph generated on the segmented regions of the image.

We compute the dense subgraph, Gdense
                         from the thresholded graph 
                           
                              G
                              
                                 G
                                 B
                                 V
                                 S
                              
                              
                                 t
                                 h
                                 r
                                 e
                                 s
                                 h
                              
                           
                         based on the algorithm A (which selects the best of three different procedures) followed in [4].

The first procedure A
                        1 (Procedure 1 in [4]) selects k/2 edges randomly from all edges in the graph 
                           
                              G
                              
                                 G
                                 B
                                 V
                                 S
                              
                              
                                 t
                                 h
                                 r
                                 e
                                 s
                                 h
                              
                           
                         and then returns the set of vertices VS
                        1 incident with these edges, adding arbitrary vertices to this set if its size is smaller than k.

The second procedure A
                        2 (Procedure 2 in [4]) is a greedy approach which computes a vertex set VS
                        2, giving direct preference to nodes with high degrees.

The third procedure A
                        3 (Procedure 3 in [4]) first calculates length-2 walks for all nodes, sorts them and then computes a vertex set VS
                        3 based on the densest subgraph induced on the set S over all nodes.

Finally, the algorithm outputs the densest of the three subgraphs (represented by vertex sets VS
                        1, VS
                        2 and VS
                        3) obtained by the three procedures. Let the densest subgraph obtained be Gdense
                         and Sdense
                         represent the set of vertices in the densest subgraph, Gdense
                         with k nodes.

Now we compute the map, Mdense
                         from the dense subgraph, Gdense
                         obtained in the previous step as follows:


                        Step 1: Let, set Sdense
                         = 
                           
                              {
                              
                                 V
                                 1
                              
                              ,
                              
                                 V
                                 2
                              
                              ,
                              …
                              ,
                              
                                 V
                                 k
                              
                              }
                           
                         denotes the set of vertices in dense subgraph set, and Mdense
                        (m, n) the saliency value at a pixel P(m, n) (m and n being the pixel coordinates) which is grouped under a superpixel corresponding to vertex i.


                        Step 2: For each pixel of the image, the presence of vertex i corresponding to the pixel, is checked in the set Sdense
                        . If found, the degree of vertex i, Deg(Veri
                        ) is compared with the mean vertex degree and saliency value assignment is done as showed in Eq. (19). If vertex i is not found in set Sdense
                        , the saliency value at the pixel, Mdense
                        (m, n) is assigned a value zero.


                        Step 3: The final saliency map, Mfinal
                         is generated after normalizing the dense subgraph map, Mdense
                         according to Eq. (1), i.e 
                           
                              
                                 M
                                 
                                    f
                                    i
                                    n
                                    a
                                    l
                                 
                              
                              =
                              N
                              o
                              r
                              m
                              M
                              a
                              p
                              
                                 (
                                 
                                    M
                                    
                                       d
                                       e
                                       n
                                       s
                                       e
                                    
                                 
                                 )
                              
                              .
                           
                        
                        
                           
                              (19)
                              
                                 
                                    
                                       M
                                       
                                          d
                                          e
                                          n
                                          s
                                          e
                                       
                                    
                                    
                                       (
                                       m
                                       ,
                                       n
                                       )
                                    
                                    =
                                    
                                       {
                                       
                                          
                                             
                                                
                                                   
                                                      (
                                                      
                                                         
                                                            D
                                                            e
                                                            g
                                                            (
                                                            V
                                                            e
                                                            r
                                                            
                                                               t
                                                               i
                                                            
                                                            )
                                                         
                                                         
                                                            m
                                                            a
                                                            
                                                               x
                                                               
                                                                  ∀
                                                                  i
                                                               
                                                            
                                                            D
                                                            e
                                                            g
                                                            
                                                               (
                                                               V
                                                               e
                                                               
                                                                  r
                                                                  i
                                                               
                                                               )
                                                            
                                                         
                                                      
                                                      )
                                                   
                                                   
                                                      (
                                                      1
                                                      /
                                                      γ
                                                      )
                                                   
                                                
                                             
                                             
                                                
                                                   i
                                                   ∈
                                                   
                                                      S
                                                      
                                                         d
                                                         e
                                                         n
                                                         s
                                                         e
                                                      
                                                   
                                                   ,
                                                
                                             
                                          
                                          
                                             
                                             
                                                
                                                   D
                                                   e
                                                   g
                                                   
                                                      (
                                                      V
                                                      e
                                                      
                                                         r
                                                         i
                                                      
                                                      )
                                                   
                                                   >
                                                   m
                                                   e
                                                   a
                                                   
                                                      n
                                                      
                                                         ∀
                                                         i
                                                      
                                                   
                                                   D
                                                   e
                                                   g
                                                   
                                                      (
                                                      V
                                                      e
                                                      
                                                         r
                                                         i
                                                      
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      (
                                                      
                                                         
                                                            D
                                                            e
                                                            g
                                                            (
                                                            V
                                                            e
                                                            r
                                                            
                                                               t
                                                               i
                                                            
                                                            )
                                                         
                                                         
                                                            m
                                                            a
                                                            
                                                               x
                                                               
                                                                  ∀
                                                                  i
                                                               
                                                            
                                                            D
                                                            e
                                                            g
                                                            
                                                               (
                                                               V
                                                               e
                                                               
                                                                  r
                                                                  i
                                                               
                                                               )
                                                            
                                                         
                                                      
                                                      )
                                                   
                                                   γ
                                                
                                             
                                             
                                                
                                                   i
                                                   ∈
                                                   
                                                      S
                                                      
                                                         d
                                                         e
                                                         n
                                                         s
                                                         e
                                                      
                                                   
                                                   ,
                                                
                                             
                                          
                                          
                                             
                                             
                                                
                                                   D
                                                   e
                                                   g
                                                   
                                                      (
                                                      V
                                                      e
                                                      
                                                         r
                                                         i
                                                      
                                                      )
                                                   
                                                   ≤
                                                   m
                                                   e
                                                   a
                                                   
                                                      n
                                                      
                                                         ∀
                                                         i
                                                      
                                                   
                                                   D
                                                   e
                                                   g
                                                   
                                                      (
                                                      V
                                                      e
                                                      
                                                         r
                                                         i
                                                      
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             
                                          
                                          
                                             
                                                0
                                             
                                             
                                                
                                                   i
                                                   ∉
                                                   
                                                      S
                                                      
                                                         d
                                                         e
                                                         n
                                                         s
                                                         e
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

From Eq. (19), it may be observed that vertices of the graph included in the dense subgraph set Sdense
                         are given priority based on their degrees in the subgraph found. The map enhancement factor, γ (γ >1) in the final saliency map computation suppresses the saliency value of pixels in regions that correspond to nodes with low degrees. On the other hand, pixels corresponding to nodes with relatively high degrees, closer to the maximum degree in the dense subgraph set Gdense
                         are assigned greater saliency values. A pixel corresponding to a node (a segmented region) not included in the dense subgraph set is assigned a value zero. Saliency value of a segmented region is directly proportional to the corresponding node degree. Therefore, saliency values of nodes with lower degrees than the mean degree, which contribute to non-salient regions, are suppressed and values of nodes with degrees higher than the mean degree, which contribute to salient regions, are enhanced. This ensures that sufficient contrast is generated in the saliency map and the salient regions may be easily distinguished from the non-salient portions. The variation of saliency values with varying node degrees is shown in Fig. 7
                        . The final saliency map, Mfinal
                         is obtained after normalizing the map Mdense
                        . Fig. 6
                         depicts the flow of the proposed method in detailed steps. The graphs Gimage
                         and GGBVS
                         have been shown to be constructed by the multiplication of the respective feature, spatial and compactness edge-weights.

In this section, we demonstrate how multiple salient regions can be extracted using the proposed method. Fig. 8(b) shows the graph GGBVS
                         constructed from the input image in Fig. 8(a). In the example shown, 
                           
                              N
                              =
                              44
                           
                         is the total number of graph nodes, and the value of the parameter 
                           
                              k
                              =
                              28
                           
                        . The green colored nodes correspond to nodes with high degrees (degree ≥ 5). Procedure 1, which is a naive method, randomly selects 14 edges (
                           
                              k
                              /
                              2
                              =
                              14
                           
                        ) and then includes the set of vertices incident with these edges, adding arbitrary vertices to this set if its size is smaller than k (
                           
                              =
                              14
                           
                        ). For procedure 2, the first fourteen (
                           
                              k
                              /
                              2
                              =
                              14
                           
                        ) nodes (green colored) to be included in the dense subgraph set, are selected based on node degree values. The nodes with the highest number of neighbors in the already selected set of 14 nodes (marked in green), are the remaining nodes to be included in the 28-dense subgraph. Procedure 3 followed in the algorithm may also be analyzed along similar lines. This way, the vertex sets VS
                        1, VS
                        2 and VS
                        3 are formed from procedures 1, 2 and 3 respectively. We get the final dense subgraph (nodes and edges marked in red) in Fig. 8(c) with 28 nodes as the densest among these three sets. This corresponds to three separate region clusters, which are detected as salient regions by the algorithm. Fig. 8(d) shows the saliency map obtained by the dense subgraph computed in Fig. 8(c). It may be noted here that, the nodes with high degrees are not localized in image space, as shown in the example. Correspondingly, the dense subgraph algorithm finds separate dense subgraphs at all image locations, where the node degrees are high. This property of the algorithm enables our model to detect multiple salient regions in an image effectively.

We used the following datasets in our experiment.

                           
                              •
                              Test datasets:

                                    
                                       •
                                       
                                          Single salient object dataset: We used images from the popular MSRA dataset [26], which is the largest object dataset containing 20,000 images in set A and 5000 images in set B. Achanta [15] created a dataset containing 1000 accurate object-contour based human-labeled ground truths corresponding to 1000 images selected from the set B of MSRA salient object dataset. We use the ASD dataset [15], created by Achanta as it enables easy quantitative evaluation. To evaluate our method on a slightly more complex dataset, we also use the PASCAL-S dataset for evaluation. The PASCAL-S dataset is derived from the validation set of PASCAL VOC 2010 [54] segmentation challenge and contains 850 natural images surrounded by complex background.


                                          Multiple salient object dataset: To demonstrate the efficacy of our model to images with multiple salient objects, we tested the results on the SED2 dataset [25], as it contains 100 images, each with two salient objects. Pixelwise ground truth annotations for salient objects in all 100 images are provided. The CAS model [22] was not compared on this dataset, due to lack of author provided results or executable code. The results obtained by running the source codes of the methods (which are made available in their respective websites) or using author provided data, were used for comparison.

Validation dataset: There are two main parameters
                                  in the proposed method:

                                    
                                       •
                                       The k value in k-dense subgraph, which selects the participation of nodes in dense subgraph in determining the saliency values of regions, and

The map enhancement factor, γ, to adjust the quality of saliency maps.

To choose these parameters, we used a small validation dataset consisting of 200 images randomly chosen from set A of MSRA dataset [26] and pixel accurate salient object labeling obtained from data used in [8].

We compared our model with eight other well known models, on the test dataset. These are:

                           
                              •
                              Graph based saliency model (GB) [1] (graph based)

Frequency tuned saliency model (FT) [15] (frequency based)

Maximum Symmetric Surround saliency model (MSSS) [19] (symmetric surround based)

Global contrast model (HC, RC) [8] (region based)

Over-segmentation model (OS) [21] (region segmentation based)

Contrast-Aware Saliency model (CAS) [22] (region based)

Low rank matrix recovery model (LR) [23] (region based)

Simple prior combination model (SDSP) [27] (prior combination based)

Principle Component Analysis model (PCA) [45] (region based)

Graph based Manifold Ranking model (MR) [28] (graph based)

We set the number of superpixel nodes, 
                           
                              η
                              =
                              250
                           
                         for all test images, as discussed in Section 3. As discussed in the previous section, we used set A of MSRA dataset [26] as the validation set to choose the parameters k and the map enhancement factor, γ. We calculated the F-measure values (as in Eq. (20)) on this validation set, for 0.1η ≤ k ≤ 1.0η (η being the total number of superpixels) and plotted the result as shown in Fig. 9. 
                           
                              k
                              =
                              0.8
                              η
                           
                         yielded the highest F-measure value (Fα
                         = 0.614). The saliency maps with varying k values are shown in Fig. 11
                        . It may be observed that, saliency maps corresponding to k = 80%η, resemble the ground truth data better than other values of k. Unwanted image patches appear for other k values. For lower values of k, not all salient regions get detected and for higher values, unwanted background regions are labeled as salient regions.

Similarly, we calculated the F-measure values for varying map enhancement factor, γ on this dataset, taking 
                           
                              k
                              =
                              0.8
                              η
                           
                        . However, no significant improvement in F-measure values was observed with increasing γ. This is due to the fact that F-measure is based on binarized maps and non-salient regions with relatively low saliency values are still assigned zero value in the binarized map, as γ value is decreased. Fig. 10 shows the impact of varying the value of γ on the generated saliency maps. We observe that salient regions become more prominent and stand out from the non-salient background portions with increasing γ value. However saliency maps cease to improve much with γ > 3. This observation led us to select 
                           
                              γ
                              =
                              3
                           
                        .


                        Figs. 12
                        , 13
                         and 14
                         show the qualitative comparison of results obtained by the proposed method with other well known models considered in this paper.


                        Fig. 15
                         compares the base model, GBVS [1] with the two stage saliency maps MGBVS
                         and Mfinal
                         we obtain in this paper. It may be observed that the blurred saliency maps of the GBVS algorithm get significant improvement after implementation of dense subgraph computation. Our model operates on image regions or superpixels and refines the region based GBVS algorithm as compared to base model [1], which operates at pixel level resulting in smooth transition from salient to non-salient portions (column (b)). Region compactness incorporated in the algorithm helps to preserve object boundaries, overcoming this limitation. The background image regions which get detected as salient by the region based GBVS algorithm (maps in column (c)) are eliminated to a great extent in the saliency maps (column (e)) refined by k-dense subgraph algorithm.

The quantitative evaluation of the algorithm is carried out based on precision, recall, F-measure and Mean Absolute Error. Precision is a measure of accuracy and is calculated as ratio of number of pixels jointly predicted salient by binarized saliency map and ground truth image and the number of pixels predicted salient by the binarized saliency map. Recall is a measure of completeness and is calculated as the ratio of number of pixels jointly predicted salient by binarized saliency map and ground truth and the number of pixels predicted salient by the ground truth image. F-measure is an overall performance measurement indicator which is computed as the weighted harmonic mean between the precision and recall values. It is defined as:

                           
                              (20)
                              
                                 
                                    
                                       F
                                       α
                                    
                                    =
                                    
                                       
                                          (
                                          1
                                          +
                                          α
                                          )
                                          ·
                                          P
                                          r
                                          e
                                          c
                                          i
                                          s
                                          i
                                          o
                                          n
                                          ·
                                          R
                                          e
                                          c
                                          a
                                          l
                                          l
                                       
                                       
                                          α
                                          ·
                                          P
                                          r
                                          e
                                          c
                                          i
                                          s
                                          i
                                          o
                                          n
                                          +
                                          R
                                          e
                                          c
                                          a
                                          l
                                          l
                                       
                                    
                                 
                              
                           
                        where the coefficient α is set to 1 to indicate equal importance of precision and recall.

After normalizing the final saliency map, Mfinal
                         to an 8-bit grayscale image, we threshold the map in the range Tf
                         ∈ [0, 255], to get 256 binarized maps corresponding to each threshold value in this range. Different precision-recall pairs are obtained for each of the 256 maps, and a precision-recall curve is drawn. The average precision-recall curves are generated by averaging the results from all the 1000 test images from the ASD dataset [15] (in Fig. 16
                        (a)), 100 images from the SED2 dataset (in Fig. 16(b)) and 850 images from the PASCAL-S dataset (in Fig. 16(c)) respectively. Furthermore, to evaluate the applicability of saliency maps for salient object detection more explicitly, we used an image dependent adaptive threshold (Ta
                        ) to segment objects in the image, as followed in [15]. A fixed threshold value in standard thresholding technique, does not always correctly demarcate the salient region from the background. Adaptive thresholding overcomes this limitation. We set the threshold Ta
                         as twice the mean saliency value of the saliency map. Using this adaptive threshold, we obtain the binarized versions of the saliency maps, for all models. The binarized saliency maps are then compared to the ground truth images to compute the metrics of precision, recall, and F-measure for all models compared, as shown in Fig. 17
                        . These metrics are first computed on all the test images individually and then averaged over the whole dataset to obtain the overall performance in terms of average precision-recall curve and overall F-measure.

As neither precision nor recall measures consider the number of pixels correctly marked as non-salient (i.e true negative saliency assignments), we follow Perazzi et al. [24] to evaluate the Mean Absolute Error (MAE) for the models compared. MAE between an unbinarized saliency map S and the binary ground truth G for all image pixels IP
                         is calculated as in Eq. (21).

                           
                              (21)
                              
                                 
                                    M
                                    A
                                    E
                                    =
                                    
                                       1
                                       
                                          |
                                          I
                                          |
                                       
                                    
                                    
                                       ∑
                                       P
                                    
                                    
                                       |
                                       S
                                       
                                          (
                                          
                                             I
                                             P
                                          
                                          )
                                       
                                       −
                                       G
                                       
                                          (
                                          
                                             I
                                             P
                                          
                                          )
                                       
                                       |
                                    
                                    ,
                                 
                              
                           
                        
                     

where, |I| is the number of image pixels.

For all methods, we considered the final saliency maps and compared them to the binary ground truth data to obtain the average MAE on the used dataset. Results of average MAE evaluation on compared methods have been shown in Fig. 18
                        .

@&#EVALUATION@&#

From Fig. 17, it is clear that the proposed method scores generally higher precision, recall and F-measure than previously proposed methods used for comparison. The MR method [28] scores better in terms of precision rate as compared to our model on all three datasets, but our method outperforms it in terms of recall rate and overall F-measure value. On the PASCAL-S dataset [32], the RC [19] and the SDSP [27] methods also have a slight edge over our method in terms of precision rate, but their recall rates and overall F-measure values are significantly lower than that of the proposed method.

It is observed that our algorithm, in general, achieves better recall values than precision. A high recall value of an algorithm indicates that most of the relevant results are detected by it. In an experiment conducted in [54], it was found that object region based saliency models can easily yield high precision values. However, a high recall value is generally achieved only by conducting the object segmentation operations either before or after the saliency computation. The high recall values of the algorithm thus helps our model to yield high quality object segmentations. Objectness estimation is another major application of a high recall saliency detection algorithm. Objectness is generally measured by constructing a small set of bounding boxes to improve efficiency of the classical sliding window pipeline. High recall at such a set of bounding box proposals is often a major target.

Average MAE, which provides a better estimate of dissimilarity between the saliency map and ground truth (as evaluated in Fig. 18), shows that our method outperforms the existing models by a fair margin, for all the three datasets. The MR method [28] performs comparable to our method on the ASD [15] and the PASCAL-S [32] datasets. On the SED2 dataset [25] however, average MAE of the RC method [8] is most comparable to our method.

The method proposed is based on the graph based visual saliency model (GB [1]) upon which it improvises to extract salient regions using a graph theoretic model. There is a significant rise in F-measure value as compared to the GB model (24.5% i.e from 63.1 to 87.6% on the ASD dataset [15], 23.5% i.e from 45.4 to 68.9% on the SED2 dataset [25] and 21.4% i.e from 37.3 to 58.7% on the PASCAL-S dataset [32]).

From the qualitative comparison in Fig. 12, it is observed that models in columns (e) and (h) yield saliency maps with sufficient contrast between salient and non-salient regions, however background regions are still highlighted. On the other hand, the over-segmentation model [21] (column (f)) generates low contrast maps and thus not suitable for object segmentation. The saliency maps generated by the MR method [28] generally have nice contrast. However, undesired background regions are highlighted for some images, such as in rows 5 and 7 or incomplete saliency detection is observed such as in row 4. The proposed model generates saliency maps which are quite similar to the desired results of salient object segmentation. The salient regions get more uniformly highlighted with proper suppression of the background regions, as compared to the other methods. In Fig. 13, similar observations may be made regarding object shape retention of multiple objects in our saliency maps, in column (h), though the method fails for the image in row 7, due to prominence of background region. The global contrast model [8] (column (e)) generates comparable maps, however for some images does not highlight multiple objects as salient, as may be observed in row 6 (only the right cow is highlighted). Similarly, the MR method [28] fails to highlight the left cow (in row 6) and the left shell (in row 5). For the PASCAL-S dataset [32] (Fig. 14), our method clearly highlights the salient regions better than other models. For instance, in rows 3 and 6, almost all other methods fail to clearly demarcate the entire salient image region or stress inadequate image portions as being salient, as in row 2 (only bird neck has more saliency value). Our saliency model suppresses the non-salient regions effectively and generates high-resolution saliency maps with well preserved shape information due to the compactness factor incorporated in the algorithm. Thus it is inherently advantageous for object segmentation tasks.

In addition to the saliency prediction accuracy, we compare the execution time of different methods. The computational cost of the compared methods on a 2.39 GHZ Intel(R) Core i3 CPU with 4 GB RAM, are summarized in Table 1. The software platform was Matlab R2013a. Table 1 shows the average execution time taken by each saliency detection method for processing an image on the SED2 dataset [25]. The computational costs of different saliency detection methods vary greatly, as seen from Table 1. The proposed method has lesser execution time than the LR [23], PCA [52] and CAS [22] methods. Other methods run faster than the proposed method, but their saliency detection accuracies are quite lower than the method proposed as evident from Section 4.4.

As shown in the previous section, the proposed model outperforms the compared saliency models on both qualitative and quantitative evaluation. However, some difficult images are still challenging for the model proposed as well as other compared models. If an image contains a part of background regions, which are visually salient against the major part of background such as row 8 in Fig. 12 and rows 6 and 7 in Fig. 13, the salient object is not properly highlighted or the nearby background regions are erroneously highlighted in the generated saliency maps. The proposed model, as well as other compared saliency models, are yet to be effective to handle such challenging cases. Also as the proposed algorithm uses intensity, color, and compact features to determine saliency, it may fail to detect irregular shape in a visual information scene, since all objects have the same intensity/color and similar compactness values.

In this article, we have presented a new method for salient region detection. The proposed method takes the saliency results of the previously proposed graph based saliency detection method, applies it on segmented image found by the SLIC superpixel segmentation algorithm and introduces the k-dense subgraph finding problem to that of saliency detection to improve the extraction of salient parts in a visual information scene.

Future research scope by this approach may include implementing better dense subgraph finding algorithms and selection of features used to construct graph. The method proposed is based on global image features only. Local image features and contrast information, if considered in future work, may further enhance the salient region detection ability of the algorithm proposed. Shape and orientation information can also be included as a feature to address the issues of irregular shape detection. We will attempt to incorporate these changes and also generalize the proposed work in video saliency detection, in our future work. However, based on the experiments using image data sets labeled with ground truth salient region, the method followed here has been shown to provide better region based saliency maps as compared to ten well known saliency detection methods and is capable of segmenting objects from an image effectively.

@&#REFERENCES@&#

