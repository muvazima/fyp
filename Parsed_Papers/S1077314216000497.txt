@&#MAIN-TITLE@&#Cosegmentation of multiple image groups

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           In this paper, we propose a multi-group image cosegmentation framework.


                        
                        
                           
                           The multi-group cosegmentation task is formulated as an energy minimization problem.


                        
                        
                           
                           We adapt the Expectation-Maximization algorithm (EM) to solve the optimization.


                        
                        
                           
                           We apply the proposed framework on three practical scenarios, including image complexity based cosegmentation, multiple training group cosegmentation and multiple noise image group cosegmentation.


                        
                        
                           
                           The experimental results show that the proposed method is able to achieve larger IOU values and better precision, compared with the state-of-the-art cosegmentation methods.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Image segmentation

Cosegmentation

Multiple group cosegmentation

@&#ABSTRACT@&#


               
               
                  The existing cosegmentation methods focus on exploiting inter-image information to extract a common object from a single image group. Observing that in many practical scenarios there often exist multiple image groups with distinct characteristics but related to the same common object, in this paper we propose a multi-group image cosegmentation framework, which not only discoveries inter-image information within each image group, but also transfers inter-group information among different image groups so as to produce more accurate object priors. Particularly, the multi-group cosegmentation task is formulated as an energy minimization problem, where we employ Markov random field
(MRF) segmentation model and the dense correspondence model in the model design and adapt the Expectation-Maximization
algorithm (EM) to solve the optimization. We apply the proposed framework on three practical scenarios including image complexity based cosegmentation, multiple training group cosegmentation and multiple noise image group cosegmentation. Experimental results on four benchmark datasets demonstrate that the proposed multi-group image cosegmentation framework is able to discover more accurate object priors and outperform state-of-the-art single-group image cosegmentation methods.
               
            

@&#INTRODUCTION@&#

Image segmentation is a fundamental problem in computer vision. Despite decades of studies, it is still challenging to achieve object-level/semantic segmentation, due to the existence of the semantic gap [1]. The existing segmentation methods can be roughly classified into three categories: unsupervised segmentation [2–4], supervised segmentation [5–7], and weakly supervised segmentation [8,9]. Unsupervised methods typically segment an image into homogeneous regions in an automatic manner, which often leads to over-segmentation such as superpixels instead of semantic regions. Supervised methods learn object priors from manually labelled pixel data, and use them to label new images. Although supervised methods can achieve superior performance for certain object classes, they require huge efforts for constructing pixel-level training labels. On the contrary, weakly supervised methods make use of coarse or partial annotations for object segmentation.

Cosegmentation can be considered as one type of weakly supervised segmentation techniques, which aims at extracting common objects from multiple images [10–12]. Based on the assumption that “there exist common objects among the images”, cosegmentation accomplishes the segmentation by enforcing the foreground regions from different images to be consistent. Cosegmentation is extremely challenging when dealing with large variations of common objects and the interferences of complex backgrounds. In the past several years, many cosegmentation methods have been proposed, which usually add a certain foreground consistency constraint into conventional segmentation models to achieve the common object extraction, such as graphcut based cosegmentation [11,13–15], random walker based cosegmentation [16], active contours based cosegmentation [17], discriminative clustering based cosegmentation [18], and heat diffusion based cosegmentation [19].

Although the existing cosegmentation methods have been successfully demonstrated in some scenarios, they focus on the cosegmentation of a single image group, where the intra-group consistency is used to extract common objects. However, in many practical scenarios, there often exist multiple image groups with different characteristics but related to the same general object. For example, (1) For a given large-scale image, the images can be classified into several image subgroups, such as simple image group and complex image group. (2) Many training datasets for one general object often contain image groups of multiple classes, such as multiple types of “face” in face recognition and multiple kinds of “bird” species in image classification. (3) The Internet images of an object (e.g., “car”) may be retrieved from several web engines such as Google and Flickr, which naturally results in the generation of several image groups with distinct characteristics according to the searching engines. The common existence of image groups naturally brings up the questions: How to do cosegmentation when there exist multiple image groups with distinct characteristics? How to use the segmentation of one group to help another group?
                  

Intuitively, there are two straightforward solutions: one is to cosegment each image group independently; the other is to merge all the image groups into one and then use the existing cosegmentation technique to solve it. However, these straightforward solutions ignore the subtle prior information among the image groups, which could be very helpful for the cosegmentation as illustrated in the following examples.

                        
                           •
                           The in-between group information can provide a more accurate object prior and make the model more robust to the background interferences. For example, in the top row of Fig. 1(Top), Shiny Cowbird has very smooth texture (just black), which can be easily cosegmented within this group even with complex background. The segmentation results can then be used to help the cosegmentation of Swainson Warbler group that has complicated texture, as shown in the bottom row of Fig. 1(Top).

Multiple group cosegmentation can simplify cosegmentation in terms of object prior generation and computational cost. For example, based on some image complexity analysis, we can classify the image group into two subgroups: simple image subgroup and complex image subgroup, as shown in Fig. 1(Bottom), where the object prior can be easily and accurately generated from the simple image subgroup instead of from the entire group. Then, the obtained object prior can be used to help cosegment of the complex image subgroup. In addition, since the size of the simple image subgroup is smaller than the original image group, it will also reduce the time cost of the cosegmentation significantly.

The inter-group information could also help on removing noise images. Here, the noise images are refer to those without containing. For example, the images of an object retrieved from Google and Flickr are likely to contain independent noise images. By comparing among different groups, we can easily figure out the noise images.

In this paper, we propose a framework for multi-group image cosegmentation which utilizes the inter-group information to improve the cosegmentation performance, and can be used in many applications, such as image classification, object detection and object recognition. Particularly, we formulate multi-group image cosegmentation as an energy minimization problem, where our overall energy function consists of three terms: a conventional single image segmentation term that enforces foreground and background to be smooth and discriminatory, a conventional single group term that enforces the consistency between image pairs from the same group, and a novel multiple group term that enforces the consistency between image pairs from different image groups through transferring structure information between image groups. Hidden variables are also introduced to select useful image pairs within a group and across the groups. Finally, the EM algorithm is adapted to solve the energy minimization. We apply the proposed model on three practical scenarios (image complexity based cosegmentation, multiple training group cosegmentation and multiple noise image group cosegmentation) and four benchmark datasets (ICoseg, Caltech-UCSD Birds 200, Cat-Dog and Noise Image dataset). The experimental results show that the proposed method is able to achieve larger IOU values and better precision, compared with the state-of-the-art cosegmentation methods.

The rest of this paper is organized as follows. We introduce the related work in Section 2, and present the proposed framework in Section 3. The experimental results are provided in Section 4. Finally, we draw the conclusions in Section 5.

@&#RELATED WORK@&#

The existing cosegmentation methods typically extract common objects from a group of images by adding the foreground consistency constraint into the energy function of the conventional segmentation models, which can be generally represented as

                        
                           (1)
                           
                              
                                 E
                                 =
                                 
                                    ∑
                                    
                                       i
                                       ∈
                                       
                                          Ω
                                          I
                                       
                                    
                                 
                                 
                                    E
                                    
                                       i
                                       m
                                       a
                                       g
                                       e
                                    
                                 
                                 
                                    (
                                    
                                       I
                                       i
                                    
                                    )
                                 
                                 +
                                 
                                    ∑
                                    
                                       (
                                       i
                                       ,
                                       j
                                       )
                                       ∈
                                       C
                                    
                                 
                                 
                                    E
                                    
                                       g
                                       l
                                       o
                                       b
                                       a
                                       l
                                    
                                 
                                 
                                    (
                                    
                                       I
                                       i
                                    
                                    ,
                                    
                                       I
                                       j
                                    
                                    )
                                 
                              
                           
                        
                     where Ii
                      is the ith image in an image group, 
                        
                           
                              Ω
                              I
                           
                           =
                           
                              ⋃
                              
                                 i
                                 =
                                 1
                              
                              N
                           
                           
                              I
                              i
                           
                        
                      is the image set, (Ii, Ij
                     ) is a pair of images, 
                        C
                      is a cosegmentation relation between images, Eimage
                      is the conventional single image segmentation term (single term) to ensure the segment smoothness, and Eglobal
                      is the multiple image term (global term) to enforce the foreground consistency. The cosegmentation is then achieved by minimizing (1). Since adding the global term usually makes the energy minimization of (1) difficult, it is critical to appropriately design the single term and the global term for easy minimization. Several efficient single and global terms have been designed in the existing methods. For example, Markov random field segmentation [11,13–15] , random walker segmentation [16], heat diffusion segmentation [20,21], and active contours segmentation have been used for Eimage
                     , while ℓ1 norm [11], ℓ2 norm [13] and reward measurement [14] have been proposed for Eglobal
                      to trade off between accurate foreground similarity measurement and simple model minimization. In general, non-linear region similarity measurements are more accurate to measure the foreground consistency, but at the cost of more difficult energy minimization and more likely local minimum solution. In contrast, linear region similarity measurements can result in simple model optimization, although they are not as accurate as non-linear region similarity measurements.

Recently, more strategies have been introduced to evaluate the global term Eglobal
                     , such as the region similarity evaluation by clustering output [18,22], the random forest based objectness evaluation model [23], the matric rank for scale-invariant objects [24], the second order graph matching method [25], the co-saliency model [26], the graph transduction learning method [27] and the consistent functional maps [28]. Note that all these methods are still based on the general model of (1). In other words, they only focus on single image group cosegmentation, where the inter-group level information has not been explored.

There are a few cosegmentation methods that involve multiple image groups, which partially motivated us. In particular, Kim et al. [29] proposed a web photo streams based cosegmentation, which tries to extract common objects from multiple web photo streams. Their method focuses on extracting multiple classes of objects from streams by skillfully incorporating the photo storylines, which can improve the classification accuracy via the iteration of segmentation and classification. However, their method is essentially similar to combining the photo streams into a single image group, which does not sufficiently use the group level information in the cosegmentation. Meng et al. [30] recently proposed a feature adaptive cosegmentation method, which tries to adaptively learn the feature model for a given image group based on automatic division of simple and complex subgroups. Since it focuses on the feature learning, its cosegmentation is still within one group.

Denoting multiple image groups as I
                        
                           i
                        , we aim at extracting the common objects 
                           
                              ω
                              j
                              i
                           
                         from each given image 
                           
                              
                                 I
                                 j
                                 i
                              
                              ,
                           
                         where 
                           
                              I
                              j
                              i
                           
                         refers to the jth image in the ith image group I
                        
                           i
                        . Without lose of generality, let’s consider two image groups for simplicity: 
                           
                              
                                 I
                                 0
                              
                              =
                              
                                 {
                                 
                                    I
                                    1
                                    0
                                 
                                 ,
                                 …
                                 ,
                                 
                                    I
                                    
                                       N
                                       0
                                    
                                    0
                                 
                                 }
                              
                           
                         and 
                           
                              
                                 I
                                 1
                              
                              =
                              
                                 {
                                 
                                    I
                                    1
                                    1
                                 
                                 ,
                                 …
                                 ,
                                 
                                    I
                                    
                                       N
                                       1
                                    
                                    1
                                 
                                 }
                              
                              ,
                           
                         where Ni
                         is the number of images in group i, i ∈ {0, 1}. Denoting 
                           
                              
                                 w
                                 0
                              
                              =
                              
                                 {
                                 
                                    ω
                                    1
                                    0
                                 
                                 ,
                                 …
                                 ,
                                 
                                    ω
                                    
                                       N
                                       0
                                    
                                    0
                                 
                                 }
                              
                           
                         and 
                           
                              
                                 w
                                 1
                              
                              =
                              
                                 {
                                 
                                    ω
                                    1
                                    1
                                 
                                 ,
                                 …
                                 ,
                                 
                                    ω
                                    
                                       N
                                       1
                                    
                                    1
                                 
                                 }
                              
                           
                         as the set of the common object regions 
                           
                              
                                 ω
                                 j
                                 i
                              
                              ,
                           
                         the goal becomes extracting w
                        0 and w
                        1 from I
                        0 and I
                        1, respectively.

As illustrated in Fig. 2, our basic idea is to combine the single-image consistency, the single-group consistency and the multi-group consistency whenever it is necessary so as to achieve better common object extraction. We formulate the problem as an energy minimization problem with the overall energy function:

                           
                              (2)
                              
                                 
                                    E
                                    =
                                    
                                       ∑
                                       
                                          i
                                          =
                                          0
                                       
                                       1
                                    
                                    
                                       α
                                       i
                                    
                                    
                                       E
                                       S
                                    
                                    
                                       (
                                       
                                          w
                                          i
                                       
                                       )
                                    
                                    +
                                    
                                       β
                                       i
                                    
                                    
                                       E
                                       M
                                    
                                    
                                       (
                                       
                                          w
                                          i
                                       
                                       ,
                                       
                                          w
                                          
                                             1
                                             −
                                             i
                                          
                                       
                                       )
                                    
                                    +
                                    
                                       γ
                                       i
                                    
                                    
                                       E
                                       I
                                    
                                    
                                       (
                                       
                                          w
                                          i
                                       
                                       )
                                    
                                    ,
                                 
                              
                           
                        where ES
                         is the single group term that enforces the consistency between image pairs from the same group, EM
                         is the multiple group term that enforces the consistency between image pairs from different image groups, EI
                         is the single image segmentation term that enforces foreground and background to be smooth and discriminatory, and αi, βi
                         and γi
                         are tradeoff factors. In the following, we describe the three terms in detail.

Given a foreground set w
                              
                                 i
                               with Ni
                               foregrounds, ES
                              (w
                              
                                 i
                              ) is used to evaluate the consistencies between its elements. Particularly, in our model we evaluate the consistency by the sum of the similarities between each pair of images, i.e.,

                                 
                                    (3)
                                    
                                       
                                          
                                             E
                                             S
                                          
                                          
                                             (
                                             
                                                w
                                                i
                                             
                                             )
                                          
                                          =
                                          
                                             ∑
                                             
                                                (
                                                k
                                                ,
                                                l
                                                )
                                                ,
                                                k
                                                ≠
                                                l
                                             
                                          
                                          
                                             z
                                             
                                                s
                                                g
                                             
                                          
                                          
                                             (
                                             k
                                             ,
                                             l
                                             )
                                          
                                          S
                                          
                                             (
                                             
                                                ω
                                                k
                                                i
                                             
                                             ,
                                             
                                                ω
                                                l
                                                i
                                             
                                             )
                                          
                                       
                                    
                                 
                              with the similarity function defined as

                                 
                                    (4)
                                    
                                       
                                          S
                                          
                                             (
                                             
                                                ω
                                                k
                                                i
                                             
                                             ,
                                             
                                                ω
                                                l
                                                i
                                             
                                             )
                                          
                                          =
                                          
                                             ∑
                                             
                                                p
                                                ∈
                                                
                                                   ω
                                                   k
                                                   i
                                                
                                             
                                          
                                          −
                                          log
                                          
                                             (
                                             P
                                             
                                                (
                                                p
                                                |
                                                
                                                   F
                                                   
                                                      ω
                                                      l
                                                      i
                                                   
                                                
                                                )
                                             
                                             )
                                          
                                          ,
                                       
                                    
                                 
                              where 
                                 
                                    P
                                    (
                                    p
                                    |
                                    
                                       F
                                       
                                          ω
                                          l
                                          i
                                       
                                    
                                    )
                                 
                               is the probability of pixel p of foreground 
                                 
                                    ω
                                    k
                                    i
                                 
                               belonging to the Gaussian Mixture Model (GMM) feature model 
                                 
                                    F
                                    
                                       ω
                                       l
                                       i
                                    
                                 
                               of foreground 
                                 
                                    
                                       ω
                                       l
                                       i
                                    
                                    ,
                                 
                               (k, l) represents foreground pair 
                                 
                                    (
                                    
                                       ω
                                       
                                          k
                                       
                                       i
                                    
                                    ,
                                    
                                       ω
                                       
                                          l
                                       
                                       i
                                    
                                    )
                                 
                               in set w
                              
                                 i
                              , and z
                              
                                 sg
                              (k, l) is a hidden binary variable to indicate whether 
                                 
                                    ω
                                    
                                       k
                                    
                                    i
                                 
                               and 
                                 
                                    ω
                                    
                                       l
                                    
                                    i
                                 
                               are paired or not with 1 for pairing and 0 for not pairing. Note that (4) is essentially the GMM similarity measurement that has been widely used in MRF models. There are also many other similarity measurements such as ℓ1-norm [11], ℓ2-norm [13], which could also be adopted here. The reason we choose the GMM similarity measurement is that it is a linear measurement, which leads to simple energy minimization. The introduce of z
                              
                                 sg
                              (k, l) in (3) is to create useful image pairs for consistency enforcement and avoid bringing in bad image pairs that might deteriorate the performance. All these hidden variables together form a matrix z
                              
                                 sg
                               with size Ni
                               × Ni
                              .

The multiple group term transfers foreground information among the image groups. Here, we define it as

                                 
                                    (5)
                                    
                                       
                                          
                                             E
                                             M
                                          
                                          
                                             (
                                             
                                                w
                                                i
                                             
                                             ,
                                             
                                                w
                                                
                                                   1
                                                   −
                                                   i
                                                
                                             
                                             )
                                          
                                          =
                                          
                                             ∑
                                             
                                                (
                                                k
                                                ,
                                                l
                                                )
                                             
                                          
                                          
                                             z
                                             
                                                s
                                                m
                                             
                                          
                                          
                                             (
                                             k
                                             ,
                                             l
                                             )
                                          
                                          
                                             S
                                             m
                                          
                                          
                                             (
                                             
                                                
                                                   ω
                                                
                                                k
                                                i
                                             
                                             ,
                                             
                                                
                                                   ω
                                                
                                                l
                                                
                                                   1
                                                   −
                                                   i
                                                
                                             
                                             )
                                          
                                          ,
                                       
                                    
                                 
                              where (k, l) represents a foreground pair of 
                                 
                                    (
                                    
                                       ω
                                       k
                                       i
                                    
                                    ,
                                    
                                       ω
                                       l
                                       
                                          1
                                          −
                                          i
                                       
                                    
                                    )
                                 
                               from the two different foreground sets, z
                              
                                 sm
                              (k, l) is the hidden binary variable to indicate whether 
                                 
                                    ω
                                    
                                       k
                                    
                                    i
                                 
                               and 
                                 
                                    ω
                                    
                                       l
                                    
                                    
                                       1
                                       −
                                       i
                                    
                                 
                               from different image groups are paired or not, similar to z
                              
                                 sg
                              (k, l), and Sm
                               is the similarity measurement between foreground pair (
                                 
                                    
                                       
                                          ω
                                       
                                       k
                                       i
                                    
                                    ,
                                    
                                       
                                          ω
                                       
                                       l
                                       
                                          1
                                          −
                                          i
                                       
                                    
                                 
                              ). All z
                              
                                 sm
                              (k, l) together form a matrix z
                              
                                 sm
                               with size 
                                 
                                    
                                       N
                                       i
                                    
                                    ×
                                    
                                       N
                                       
                                          1
                                          −
                                          i
                                       
                                    
                                 
                              .

Different from the similarity measurement S defined in (4), for the image pair similarity at group level we often want to transfer structure information such as shape from one group (e.g. simple group) to the other (e.g. complex group). Thus, we define the group-level similarity measurement as

                                 
                                    (6)
                                    
                                       
                                          
                                             S
                                             m
                                          
                                          
                                             (
                                             
                                                
                                                   ω
                                                
                                                k
                                                i
                                             
                                             ,
                                             
                                                
                                                   ω
                                                
                                                l
                                                
                                                   1
                                                   −
                                                   i
                                                
                                             
                                             )
                                          
                                          =
                                          
                                             ∑
                                             
                                                p
                                                ∈
                                                
                                                   ω
                                                   k
                                                   i
                                                
                                             
                                          
                                          
                                             
                                                ∥
                                                
                                                   f
                                                   
                                                      k
                                                   
                                                   i
                                                
                                                
                                                   (
                                                   p
                                                   )
                                                
                                                −
                                                
                                                   f
                                                   
                                                      l
                                                   
                                                   
                                                      1
                                                      −
                                                      i
                                                   
                                                
                                                
                                                   (
                                                   p
                                                   +
                                                   v
                                                   
                                                      (
                                                      p
                                                      )
                                                   
                                                   )
                                                
                                                ∥
                                             
                                             1
                                          
                                          ,
                                       
                                    
                                 
                              where 
                                 
                                    f
                                    
                                       k
                                    
                                    i
                                 
                               and 
                                 
                                    f
                                    
                                       l
                                    
                                    
                                       1
                                       −
                                       i
                                    
                                 
                               are the features of images 
                                 
                                    I
                                    
                                       k
                                    
                                    i
                                 
                               and 
                                 
                                    
                                       I
                                       
                                          l
                                       
                                       
                                          1
                                          −
                                          i
                                       
                                    
                                    ,
                                 
                               respectively, 
                                 
                                    p
                                    +
                                    v
                                    (
                                    p
                                    )
                                 
                               is a pixel in image 
                                 
                                    I
                                    
                                       l
                                    
                                    
                                       1
                                       −
                                       i
                                    
                                 
                               corresponding to pixel p in image 
                                 
                                    
                                       I
                                       
                                          k
                                       
                                       i
                                    
                                    ,
                                 
                               and v(p) is the flow vector of pixel p. We use the SIFT flow method [31] to obtain the flow vector set v. The feature 
                                 
                                    f
                                    
                                       k
                                    
                                    i
                                 
                               could be dense SIFT, color, or other features, depending on the applications.

The single image term is to ensure the smoothness of the segmentation and the distinction of the foreground and the background. Following common MRF segmentation models, EI
                              (w
                              
                                 i
                              ) is defined as

                                 
                                    (7)
                                    
                                       
                                          
                                             E
                                             I
                                          
                                          
                                             (
                                             
                                                w
                                                i
                                             
                                             )
                                          
                                          =
                                          
                                             ∑
                                             
                                                k
                                                =
                                                1
                                             
                                             
                                                N
                                                i
                                             
                                          
                                          S
                                          
                                             (
                                             
                                                ω
                                                k
                                                i
                                             
                                             ,
                                             
                                                ω
                                                k
                                                i
                                             
                                             )
                                          
                                          +
                                          S
                                          
                                             (
                                             
                                                
                                                   ω
                                                   ¯
                                                
                                                k
                                                i
                                             
                                             ,
                                             
                                                
                                                   ω
                                                   ¯
                                                
                                                k
                                                i
                                             
                                             )
                                          
                                          +
                                          V
                                          
                                             (
                                             
                                                ω
                                                k
                                                i
                                             
                                             )
                                          
                                       
                                    
                                 
                              where S is the same as that in (4), 
                                 
                                    
                                       
                                          ω
                                          ¯
                                       
                                       k
                                       i
                                    
                                    =
                                    
                                       {
                                       p
                                       |
                                       p
                                       ∈
                                       
                                          
                                             Ω
                                          
                                          k
                                          i
                                       
                                       ,
                                       p
                                       ∉
                                       
                                          ω
                                          k
                                          i
                                       
                                       }
                                    
                                 
                               is the background, 
                                 
                                    
                                       Ω
                                    
                                    k
                                    i
                                 
                               is the pixel set of image 
                                 
                                    
                                       I
                                       k
                                       i
                                    
                                    ,
                                 
                               and 
                                 
                                    V
                                    (
                                    
                                       ω
                                       k
                                       i
                                    
                                    )
                                 
                               is the smoothness term regularizing the segment mask 
                                 
                                    ω
                                    k
                                    i
                                 
                              . We select V as the pairwise term in the common MRF segmentation model [11]. The first two terms in (7) are essentially the data terms, respectively measuring how well foreground and background pixels match the foreground and background GMM feature models of the image itself.

We now present our solution to the optimization problem of (2). Considering there are hidden variables in (2), we adapt the EM to find the solution, which consists of two alternatively iterative steps: E-step and M-step. In the E-step, we update the hidden variables 
                           
                              z
                              
                                 s
                                 g
                              
                              i
                           
                         and 
                           
                              z
                              
                                 s
                                 m
                              
                              i
                           
                         based on the feature consistency of the segments, while in the M-step we refine the segments based on the updated hidden variables. In the following, we describe the two steps in detail.

In the E-step, we update z by the K nearest-neighbor search. Given the segmentation results in the tth iteration, we represent each segment by a feature such as color histogram feature and dense SIFT based Bag-of-Words feature. Then, for each segment ω, we calculate its K nearest neighbors denoted as N(ω). For a segment pair (ω and ωk
                           ), we set the corresponding hidden variable 
                              
                                 z
                                 =
                                 1
                              
                            if ωk
                            ∈ N(ω); otherwise, 
                              
                                 z
                                 =
                                 0
                              
                           . In this way, we update z
                           
                              sg
                            and z
                           
                              sm, respectively when the images are in the same group or different groups.

The nearest neighbors are usually searched based on a certain distance metric such as Euclidean distance or chi-square distance. We observe that these distances may not handle the region interferences very well. For example, in the left side of Fig. 3, the current foreground contains 
                              
                                 A
                                 +
                                 B
                                 ,
                              
                            where A is the object region we want while B is the noise region. Directly using those common distance metrics might find the nearest neighbors that contain both A and B such as the middle of Fig. 3 and exclude the ideal neighbors such as the right side of Fig. 3. To avoid such cases, we measure the dissimilarity between two foregrounds as

                              
                                 (8)
                                 
                                    
                                       D
                                       
                                          (
                                          ω
                                          ,
                                          
                                             ω
                                             k
                                          
                                          )
                                       
                                       =
                                       
                                          1
                                          
                                             
                                                |
                                             
                                             
                                                ω
                                                k
                                             
                                             
                                                |
                                             
                                          
                                       
                                       
                                          ∑
                                          
                                             q
                                             ∈
                                             
                                                ω
                                                k
                                             
                                          
                                       
                                       
                                          min
                                          
                                             p
                                             ∈
                                             ω
                                          
                                       
                                       d
                                       
                                          (
                                          f
                                          
                                             (
                                             p
                                             )
                                          
                                          ,
                                          f
                                          
                                             (
                                             q
                                             )
                                          
                                          )
                                       
                                       ,
                                    
                                 
                              
                           where f(p) is the feature representation of pixel p and d is the Euclidean distance. In this way, the foreground in the right side of Fig. 3 will have a small measurement to that in the left side of Fig. 3. To speed up the process, we compute the measurement in (8) based on superpixels obtained by the simple linear iterative clustering (SLIC) superpixel generation method [32] (with the desired number of superpixels set as 300).

In the M-step, we fix z
                           
                              sg
                            and z
                           
                              sm
                           , and want to refine w
                           0 and w
                           1 by minimizing (2). However, directly minimizing (2) is difficult since it involves two image groups and each image group contains multiple images. To make the problem trackable, we propose to solve each image segmentation separately by fixing the foregrounds of other images as constants. In this way, we divide the minimization problem into many sub-minimization problems. The energy function of each sub-minimization problem becomes

                              
                                 (9)
                                 
                                    
                                       
                                          
                                             
                                                E
                                                k
                                                i
                                             
                                          
                                          
                                             =
                                          
                                          
                                             
                                                
                                                   α
                                                   i
                                                
                                                
                                                   ∑
                                                   
                                                      l
                                                      ,
                                                      l
                                                      ≠
                                                      k
                                                   
                                                
                                                
                                                   z
                                                   
                                                      s
                                                      g
                                                   
                                                   i
                                                
                                                
                                                   (
                                                   k
                                                   ,
                                                   l
                                                   )
                                                
                                                S
                                                
                                                   (
                                                   
                                                      ω
                                                      k
                                                      i
                                                   
                                                   ,
                                                   
                                                      ω
                                                      l
                                                      i
                                                   
                                                   )
                                                
                                                +
                                                
                                                   β
                                                   i
                                                
                                                
                                                   ∑
                                                   l
                                                
                                                
                                                   z
                                                   
                                                      s
                                                      m
                                                   
                                                   i
                                                
                                                
                                                   (
                                                   k
                                                   ,
                                                   l
                                                   )
                                                
                                                
                                                   S
                                                   m
                                                
                                                
                                                   (
                                                   
                                                      ω
                                                      k
                                                      i
                                                   
                                                   ,
                                                   
                                                      ω
                                                      l
                                                      
                                                         1
                                                         −
                                                         i
                                                      
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                       
                                          
                                          
                                          
                                             
                                                +
                                                
                                                   γ
                                                   i
                                                
                                                
                                                   [
                                                   S
                                                   
                                                      (
                                                      
                                                         ω
                                                         k
                                                         i
                                                      
                                                      ,
                                                      
                                                         ω
                                                         k
                                                         i
                                                      
                                                      )
                                                   
                                                   +
                                                   S
                                                   
                                                      (
                                                      
                                                         
                                                            ω
                                                            ¯
                                                         
                                                         k
                                                         i
                                                      
                                                      ,
                                                      
                                                         
                                                            ω
                                                            ¯
                                                         
                                                         k
                                                         i
                                                      
                                                      )
                                                   
                                                   +
                                                   V
                                                   
                                                      (
                                                      
                                                         ω
                                                         k
                                                         i
                                                      
                                                      )
                                                   
                                                   ]
                                                
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           Since the similarity measurements S and Sm
                            are designed as linear measurement, the energy in (9) is submodular. Hence, (9) can be efficiently minimized by the classical graphcut algorithm [33]. By solving the sub-minimization problem in (9) one by one, we then update all 
                              
                                 ω
                                 j
                                 i
                              
                           .


                           Algorithm 1 summarizes the proposed EM based solution. Note that the input includes two 2 × 2 matrices M
                           1 and M
                           2, which are used to specify the propagation relationship and the similarity features so as to accommodate different application scenarios. Specifically, if we want to use the foreground information of the jth group for the cosegmentation of the ith group, we set 
                              
                                 
                                    M
                                    1
                                 
                                 
                                    (
                                    i
                                    ,
                                    j
                                    )
                                 
                                 =
                                 1
                              
                           ; otherwise, we set 
                              
                                 
                                    M
                                    1
                                 
                                 
                                    (
                                    i
                                    ,
                                    j
                                    )
                                 
                                 =
                                 0
                              
                           . The diagonal elements M
                           1(i, i) are always set to 1. M
                           2 is to specify the features used in the propagation. In this research, we mainly consider color and SIFT features. We set M
                           2(i, j) to 0 or 1 to respectively indicate color or SIFT feature used in the information transfer from group j to group i. Note that M
                           2(i, i) specifies the transfer feature used within group i. Based on M
                           1 and M
                           2, we can easily design the transfer direction and the corresponding feature used in the transfer.
                        

For the initialization, we set the initial region 
                              
                                 
                                    w
                                    0
                                    i
                                 
                                 ,
                                 i
                                 =
                                 1
                                 ,
                                 2
                              
                            as the rectangles with a fixed distance of 0.1 × W (W is the image width) to the image boundary. 
                              
                                 z
                                 
                                    s
                                    g
                                 
                                 0
                              
                            is set as zero matrix with one on the diagonal, and 
                              
                                 z
                                 
                                    s
                                    m
                                 
                                 0
                              
                            is set as zero matrix. The M-step and the E-step are run iteratively until the stop condition is met, i.e., reaching the maximum number of iterations Nstop
                           . Typically, the EM algorithm converges in four iterations and thus we set 
                              
                                 
                                    N
                                    
                                       s
                                       t
                                       o
                                       p
                                    
                                 
                                 =
                                 4
                              
                           .

@&#EXPERIMENTS@&#

In this section, we verify the proposed method via three cosegmentation applications: image complexity based group cosegmentation, multiple training group cosegmentation and multiple noise image group cosegmentation. We use four benchmark datasets, including ICoseg [34], Caltech-UCSD Birds 200 [35], Cat–Dog [36] and Noise Image dataset [37].

Here, we consider the scenario of extracting a common object from a given single image group with large number of images, where some images are of simple background while others have complex background, which are difficult to segment. Following the image complexity analysis in [30], we can divide the given image group into a simple image subgroup and a complex image subgroup. For the simple image subgroup, we can easily extract the object out by using the single image group cosegmentation (setting βi
                         in (2) to 0). Then, for the complex image subgroup we perform the multiple image group cosegmetnation using our proposed framework, where the prior information generated from the simple image subgroup is transferred to help co-segment the complex image subgroup.

We test this scenario on the ICoseg dataset [34]. Color feature is selected for the information transfer between the simple subgroup and the complex subgroup. Fig. 4
                         shows some segmentation results of the images with complex backgrounds from the three classes cheetah, elephant and panda2. We can see that the proposed method can extract the common objects from interfered backgrounds, which is largely due to the accurate object prior provided by the simple subgroup.

We next objectively evaluate the proposed method by the intersection-over-union (IOU) metric, which is defined as the ratio of the intersection area of the segment and the ground-truth to their union. We use the average of the IOU results over all the classes of the ICoseg dataset to verify the performance. The average IOU values of the proposed method and the existing methods on ICoseg dataset are shown in the second column of Table 1
                        , where we also compare the methods of our framework without and with the multiple group term, denoted as Ours+s and Ours+m, respectively. Note that the IOU results of the existing methods are directly extracted from [37]. It can be seen that our proposed method with the multiple group term achieves the best performance with the highest IOU value of 0.7086 on the ICoseg dataset. Note that some image classes in ICoseg only contain small number of images (smaller than ten), which is not suitable for the simple and complex group division. Thus, for these small classes, only single image group cosegmentation of the proposed method is performed.


                        Fig. 5
                         further gives some visual comparison among different methods. We can see that the results of the single group based methods often obtain large noise regions, such as the meadow in the Liverpool class (the first two columns). This is mainly because these noise regions repeatedly appear in the image group, which are then being considered as part of the foregrounds. In contrast, our proposed group-level cosegmentation method can successfully remove those noise regions due to the more accurate prior extracted from the simple image subgroup.

We also list out the detailed IOU results of Ours+s and Ours+m on each class of the ICoseg dataset in Table 2
                         for detailed comparisons. It can be seen that Ours+m achieves larger IOU values for most of the classes since it is likely to generate more accurate object prior. However, for some classes such as Souwester, the IOU result of Ours+m is worse than that of Ours+s. This is because there are some object variations that might only exist in the complex image subgroup but not in the simple image subgroup, for which the simple subgroup cannot provide a good object prior.

In this subsection, we consider the scenario of given a training collection of a general object such as bird or cat, where there already exist some groupings according to the type of the species. Some subspecies can be easily extracted according to a certain feature while segmenting the others is challenging due to the complicated texture of the object. For such dataset, we apply the single-group image cosegmentation (Ours+s) using either color or SIFT feature on one selected group that can be easily segmented, and then apply our multi-group image cosegmentation (Ours+m) on other groups using SIFT feature to transfer the object prior from the easy group to each of the other groups.

For this scenario, we test the proposed method on two classification datasets: Cat–Dog dataset and Caltech-UCSD Bird dataset. The Cat–Dog dataset contains 12 subspecies of cats with about 200 images per class, and we use all the classes. In the Bird dataset, there are 200 species of birds with about 30 images per class. We select 13 continuous classes from number 026 (Bronzed Cowbird) to 038 (Great Crested Flycatcher) for verification. Considering some easy group has relatively large number of images, when applying the multi-group cosegmentation, the image matching between groups becomes very time-consuming. In order to reduce the computational cost, only a small number of images are used as the easy group to help cosegment other groups. Specifically, in the Cat–Dog dataset, the Bombay cat group with 23 images is used as the easy group, and for UCB-Bird dataset, we select a part of 029 American Crow with 18 images as the easy group.


                        Figs. 6
                         and 7
                        
                         show the segmentation results of some difficult groups in the Cat–Dog dataset and the Bird dataset using our proposed method. Here, we give examples of the images with interfered backgrounds. We can see that the proposed method can locate the objects from these complicated backgrounds, such as the cat in the indoor scene.

The average IOU results of ours method Ours+m, Ours+s and the existing methods on these two datasets are shown in the third and fourth columns of Table 1 with the detailed results on individual classes listed in Tables 3
                         and 4
                        , respectively. For the methods in [18,20] 
                        
                           1
                        
                        
                           1
                           
                              http://www.cs.cmu.edu/~gunhee/r_seg_submod.html
                           
                         and [22] 
                        
                           2
                        
                        
                           2
                           
                              http://ai.stanford.edu/~ajoulin/index.php?page=coseg
                           
                        , the source codes released by the authors are used. Furthermore, we implement the method in [37] with MATLAB code. Note that we only compare with the co-segmentation method [20] and [37] that can handle large-scale datasets on the Cat–Dog dataset, since each class in Cat–Dog dataset contains about 200 images, which would result in large computational cost for other co-segmentation methods.

It can be seen that our single group version significantly outperforms the existing methods. This is mainly because several new strategies are incorporated to improve the single image group cosegmentation performance, such as dynamically re-neighboring across images, selecting new neighbors and simultaneously considering the segmentation on multiple images and single image. These strategies lead to the significant performance gains, especially when the dataset is challenging.

Meanwhile, it can also be seen that our multiple group version can further improve the IOU values over the single group version, which achieves the best overall performance. Note that the IOU values of Ours+m are smaller than Ours+s for some classes such as class 34 in Table 3. This is mainly because the birds contain many variations, which may interfere the object matching and lead to the performance degradation in these classes.

In this experiment, we intend to demonstrate that our multi-group cosegmentation can help on removing noise or irrelevant images from a given internet image collection of a general object, which for example could be the search results of multiple search engines, such as Google and Bing. We can divide the image collection into multiple groups according to its sources, i.e., the used search engines. By assuming the noise images are different from different sources, we can easily remove the noise images in one group by checking whether the noise images appear in another group or not. Such a noise removing method is much simpler than the one proposed in [37].

For demonstration purpose, we construct a noise dataset from the one in [37] to illustrate our idea. Specifically, we add different objects into a common object image set so as to form two different groups. For example, we respectively add a number of face and bird images into the car image set to form two different car groups. Note that for each group, we allow the repetition of the noise images, which cannot be handled by [37].

Some example results of the proposed method are shown in Fig. 8, where the top and bottom rows correspond to the results of the two different groups. We can see that the proposed method can delete the noise images successfully, as evident by no segmentation mask in those noise images. Since it is not meaningful to calculate IOU with empty segmentation mask, here we use the precision value as the evaluation metric, which is defined as the ratio of the number of correctly labelled pixels to the total number of pixels. The precision results of the proposed method are given in the last column of Table 1 with detailed results in Table 5, which shows the significant improvement by using the proposed multiple group cosegmentation.

@&#CONCLUSIONS@&#

In this paper, we have proposed a multi-group image cosegmentation framework, which is formulated as an energy minimization problem. The proposed energy model consists of three terms: the single image segmentation term, the single group term and the multiple group term, which, together with the hidden variables, can effectively discover and utilize the appropriate foreground consistency within an image, within a group and across different groups. The proposed model is minimized by the EM algorithm incorporated with the adopted K-nearest neighbor search and the graphcut algorithm. The experiments on three practical cosegmentation tasks and four benchmark image datasets have demonstrated the usefulness of utilizing inter-group information.

@&#ACKNOWLEDGMENTS@&#

This work was supported in part by the Major State Basic Research Development Program of China (973 Program 2015CB351804), NSFC (No. 61271289), the Singapore National Research Foundation under its IDM Futures Funding Initiative and administered by the Interactive & Digital Media Programme Office, Media Development Authority, the Ph.D. Programs Foundation of Ministry of Education of China (No. 20110185110002), by The Program for Young Scholars Innovative Research Team of Sichuan Province, China (No. 2014TD0006), and by the research start-up funding of UESTC (No. A03012023601005).

@&#REFERENCES@&#

