@&#MAIN-TITLE@&#A soft-decision based two-layered scheduling approach for uncertain steelmaking-continuous casting process


@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We model the SCC scheduling problem as an MIP model with interval variables.


                        
                        
                           
                           We propose the soft decision concept for uncertain SCC environments.


                        
                        
                           
                           We present a two-layered solution framework to solve the model.


                        
                        
                           
                           Experiments show the superiority of the method under uncertain situations.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Steelmaking

Continuous casting

Uncertainty

Scheduling

Soft decision

@&#ABSTRACT@&#


               
               
                  Strong uncertainties is a key challenge for the application of scheduling algorithms in real-world production environments, since the optimized schedule at a time often turns to be deteriorated or even infeasible during its execution due to a large majority of unexpected events. This paper studies the uncertain scheduling problem arising from the steelmaking-continuous casting (SCC) process and develops a soft-decision based two-layered approach (SDA) to cope with the challenge. In our approach, traditional scheduling decisions, i.e. the beginning time and assigned machine for each job at each stage, are replaced with soft scheduling decisions in order to provide more flexibility towards unexpected events. Furthermore, all unexpected events are classified into two categories in terms of the impact degree on scheduling: critical events and non-critical events. In the two-layered solution framework, the upper layer is the offline optimization layer for handling critical events, in which a particle swarm optimization algorithm is proposed for generating soft scheduling decisions; while the lower layer is the online dispatching layer for handling non-critical events, where a dispatching heuristic is designed to decide in real time which charge and when to process after a machine becomes available, with the guidance of the soft schedule given by the upper layer. Computational experiments on randomly generated SCC scheduling instances and practical production data demonstrate that the proposed soft-decision based approach can obtain significantly better solutions compared to other methods under strongly uncertain SCC production environments.
               
            

@&#INTRODUCTION@&#

@&#BACKGROUND@&#

Production scheduling is a complex decision-making process that plays an important role in most of production systems, especially in complex and capital-intensive industries such as iron and steel, wafer fabrication, automobile, etc. Effective scheduling can significantly improve throughput, customer satisfaction, inventory costs, bottleneck utilization, and other key performance indices for enterprises. The iron and steel industry is a typical capital-intensive industry, which is essential to many important industries in the world, such as automobile, construction, aircraft and ship manufacturing (Tang, Liu, Rong, & Yang, 2001; Tang, Luh, Liu, & Fang, 2002). This paper investigates a challenging scheduling problem arising from real-life steelmaking-continuous casting process in the iron and steel industry. The steelmaking-continuous casting (SCC) process mainly includes stages of steelmaking, refining and casting (Tang & Liu, 2007; Xuan & Tang, 2007), as shown in Fig. 1
                        .

The SCC production process we studied is briefly described as follows. Firstly, undesired substances in the molten iron, such as silicon, phosphorus and carbon, are partially removed through injections of oxygen in a basic oxygen furnace (BOF) of the steel-making stage. The molten steel processed together in a BOF is called a charge, a basic unit of the SCC production. Secondly, molten steel is poured into a transfer ladle and then transported to a refining furnace by a crane where it is de-slagged and de-sulphurized (Missbauer, Hauber, & Stadler, 2009). In this processing stage, high-precision adjustment for the chemical compositions of the steel is carried out so as to produce specific steel grades. There are two types of refining furnaces, including ladle furnaces (LF), Ruhrstahl-Hausen vacuum refining furnaces (RH). Finally, graded liquid steel from the refining furnace is taken to a continuous caster (CC) which can process multiple charges consecutively in the form of a cast or a batch. In this stage, the ladle is raised onto a turret that rotates the ladle on the casting position above the tundish. Liquid steel flows out from the tundish and into the crystallizer. At the bottom of the caster, the steel is completely solidified into blooms, slabs or billets with the required rolling lengths (Tang et al., 2002; Xuan & Tang, 2007).

Each charge is defined by the corresponding steel grade and the gauges of products that the charge will be used to produce (Atighehchian, Bijari, & Tarkesh, 2009). There is a special constraint with SCC process that, charges at the casting stage need to be consecutively cast one by one on the same intermediate ladle and on the same caster without any idle time of the caster. Such a group of charges forms a cast or a batch. This is because charges in the same cast share a common tundish, and when a cast ends production or is interrupted, the current common tundish will be disassembled from the continuous caster, and cannot be used any more. If charges in a cast are not processed consecutively, we call that a cast interruption happens. Therefore, it is an important task to improve the life span of tundishes so as to decrease the unit cost of each charge in the process of planning and scheduling. Besides that, as the temperature of hot metal will cool down quickly in steel ladle, it is necessary to reduce the waiting time of charges before each stage so as to save energy.

Generally, the factory planning level releases a production plan every day for the SCC shop and the hot-rolling shop based on customer orders. In the production plan, detailed information of casts are given including the number of charges in each cast, the processing route, steel grade and estimated processing times of each charge and some technique constraints. Generally, two main steps need to be done in the planning level (Tang, Wang, & Chen, 2014): order batching (to form charges) and charge batching (to form casts). In some SCC plants, even the allocation of casts to continuous casters and sequence of casts are also given in the SCC production plan in order that the plan can be coordinated with hot rolling plan (hot charging to save energy) (Missbauer et al., 2009). There are a large number of researches focused on the field of production planning for the SCC process, details can be found in Tang, Wang, and Chen (2014), and Tang and Wang (2008).

Given the production plan for the SCC shop, one needs to make out a timetable plan (i.e. the starting times and the assigned machines for each charge at each processing stage) for a given scheduling period (usually a shift or a day), this problem is often termed as the static scheduling problem in literature. During the execution of the timetable plan, some unpredicted real-time events may happen and thus cause the initially good timetable plan to become poor and even infeasible. Tang et al. (Tang, Zhao, & Liu, 2014) have summarized some typical unexpected events such as machine breakdown, operator illness, job cancellation, arrival of urgent charges, etc. It is necessary to adjust the timetable plan in this case, and this problem is usually termed as the dynamic scheduling problem in literature. Lastly, due to the presence of uncertainty (e.g. uncertain charge arriving time, processing time and transportation time, short-term machine failure), the timetable plan cannot be executed precisely, therefore in practice, one needs to decide in real time based on the timetable plan which charge and when to process when a machine becomes available, and this problem is often termed as the real-time scheduling problem. A typical schedule of the SCC process in practice, also known as “Gantt diagram”, is shown in Fig. 2
                        .

@&#LITERATURE REVIEW@&#

Efficient scheduling of the SCC process can bring considerable improvement for criterions such as Cast Interruption Ratio (CIR) and Average Weighted wait Time of charges (AWT), therefore decreasing the overall production cost and improving productivity. Much research effort has been focused on the static SCC scheduling problem since the late 1990s, most of which in literature formulate a mathematical model for the SCC scheduling problem, usually an MIP model, and then suggest a customized solution procedure. Harjunkoski and Grossmann (2001) propose a decomposition scheme that generates smaller programs that can often be solved to global optimality. In their approach the original SCC problem is split into subproblems in a natural way using the special features of steelmaking and avoiding the need for expressing the highly complex rules as explicit constraints. Tan, Huang, and Liu (2013) investigate a steelmaking process scheduling problem with variable electricity price (SMSPVEP), and present a decomposition approach. Tang, Liu, Rong, and Yang (2000) present a mathematical model for solving SCC production scheduling problem. The model is developed as a non-linear model based on actual production situations, considering both punctual delivery and production operation continuity. It is then converted into a linear programming model which can be solved using standard software packages. Tang, Guan, and Hu (2010) develop two different models to describe the practical SCC scheduling problems with converters and transporters, and propose a heuristic algorithm and a taboo search algorithm to solve the models, respectively. Atighehchian et al. (2009) propose a hybrid scheduling algorithm for the SCC problem, which is based on combination of ant colony optimization (ACO) and non-linear optimization methods. Xuan and Tang (2007) formulate the SCC scheduling problem as a hybrid flow shop (HFS) with batch production at the last stage, and then establish an integer programming model as well as a batch decoupling based Lagrangian relaxation algorithm for this problem. Mao, Pan, Pang, and Chai (2014
                        ) formulate the SCC scheduling problem as an MIP model, and propose a novel Lagrangian relaxation approach for solving SCC static scheduling problem, which outperforms traditional Lagrangian approach in terms of solution quality and running time.

Also, some researchers have proposed dynamic scheduling methods for the SCC process which are used to generate a new schedule when some unexpected events happen. Tang et al. (2014) study a dynamic scheduling problem in SCC production where the assignment, sequencing, and timetable of a set of existing and new jobs (charges) among various production stages are re-optimized for the new environment when unforeseen changes occur in the production system. They propose an improved differential evolution (DE) algorithm to solve it. Yu and Pan (2012) study the SCC rescheduling problem in response to the case of operation time delay, and propose a novel multi-objective nonlinear programming model and a three-stage rescheduling method including the batches splitting (BS), forward scheduling method (FSM) and backward scheduling method (BSM). Ouelhadj, Petrovica, Cowling, and Meiselsc (2004) solve the SCC scheduling problem by a multi-agent based approach, where a negotiation protocol is proposed for inter-agent cooperation. The purpose of this protocol is to allow the agents to cooperate and coordinate their local schedules in order to find globally near-optimal robust schedules, while minimizing the disruption caused by the occurrence of unexpected real-time events.

Dispatching rules are frequently used for real-time scheduling in practice (Metan, Sabuncuogl, & Pierreval, 2010). However, conventional dispatching rules in literature, such as SPT (shortest processing time), EDD (earliest duedate), CR (critical ratio), are difficult to be applied to the SCC real-time scheduling problem due to the strong constraints of continuous casting of charges in a cast. Also, dispatching rules tend to be myopic as most of them only incorporate job-related and machine-related local production information (Ouelhadj & Petrovic, 2009). Therefore, little effort in literature has been focused in developing effective dispatching rules for the SCC process.

@&#MOTIVATION@&#

As described above, most of the SCC scheduling problems studied in literature are deterministic. However, there exist a lot of various unexpected events including fluctuations of arriving times, processing times and transportation times, machine breakdowns, charge reworks, etc. Generally, these unexpected events can be classified into two categories in terms of the impact degree on the scheduling:

                           
                              •
                              
                                 Critical events: which are defined as events that may cause the initial schedule to be extremely worse or infeasible, thus have a greater impact on the scheduling. Such events include arrivals of new casts released by the enterprise planning level, long-term machine breakdown, charge-hold and charge reworks due to quality considerations, charge cancellations or change of processing routes, etc. For instance, if a long-term machine breakdown happens, then all of operations that have been assigned to this machine need to be moved to other machines in the same stage, therefore the initial schedule turns to be infeasible and needs to be re-optimized.


                                 Non-critical events: which are defined as events that would not greatly change the feasibility and the performance of the initial schedule, thus have a less impact on the scheduling. Such events include slight fluctuations of processing times, transportation times and arriving times, short-term machine failure and charge-hold (which can also be regarded as fluctuations of processing times of charges), etc.

Generally, the number of non-critical events is much larger than that of critical events. In both static and dynamic scheduling approaches in literature, a timetable plan, which is generated manually or by a scheduling algorithm, is given as the final scheduling decision released to the shop floor. Usually in practice, when critical events happen, the timetable plan is often re-generated and released since the initial plan does not work; however, when non-critical events happen, schedulers tend to give real-time decisions themselves by slightly modifying the initial “rigid” timetable plan. We argue that the timetable plan is rigid in the sense that it fixes detailed starting times and assigned machines for each charge at each stage, without providing additional solutions on what should be done if some of the timetable plan cannot be executed due to the presence of a large amount of real-time events of the shop floor. Although dynamic scheduling methods can be used when non-critical events happen, however, in this case schedulers have to frequently adjust the timetable plan as real-life SCC process is strongly uncertain, which deteriorates the performance of the initial timetable plan and easily leads to serious production instability. Therefore, existing rigid-decision based methods in literature are difficult to guarantee that the schedule is good or feasible for a comparatively long time under strongly uncertain production environment. This motivates us to design some better form of decisions in the scheduling algorithm to accommodate with the strongly uncertain nature of the SCC process.

In this paper, instead of using the conventional rigid timetable plan as scheduling decisions, we propose a novel concept of soft decision (or soft schedule) to be used as decision variables of the optimization model. The inherent idea of this concept is to find some feature value for dynamic production control under uncertain environment. In our approach, the soft decision consists of two parts: (1) in-process workload of each cast, and (2) the processing sequence of casts. The in-process workload of each cast is a control variable for each cast, balancing between average wait time of charges in the cast and probability of cast interruption during execution, and the sequence of casts represents priorities of casts. Based on the concept of soft decision, we present a two-layered approach to solve the SCC scheduling problem. The upper layer is the offline optimization layer, in which a novel particle swarm optimization algorithm is presented to solve the uncertain SCC scheduling problem and generate soft schedules for the problem, while the lower layer is the online dispatching layer, in which a fast heuristic is designed and used to decide in real time which charge and when to process when a machine becomes available during the execution of the soft schedule. To further improve the efficiency and effectiveness of our approach, a knowledge based population initialization method and an adaptive particle moving mechanism are presented in the particle swarm optimization algorithm.

In literature of job shop scheduling with the presence of uncertainty, there exist three approaches: complete reactive scheduling, robust proactive scheduling and predictive-reactive scheduling (Ouelhadj & Petrovic, 2009). In complete reactive scheduling, no firm schedules are generated in advance, such as priority dispatching rules, however, they do not perform well under complex production environments as decisions are made locally in real-time. Robust proactive scheduling approach focuses on generating predictive schedules while considering unexpected disturbances. This approach is often criticized as real-time information is not utilized in dispatching jobs. Predictive-reactive scheduling is the most popular approach to cope with uncertainty in literature. In this approach, a firm schedule is generated in advance, and schedules are revised during the execution of the initial schedule.

Our approach belongs to predictive-reactive approaches in dynamic scheduling literature. However, different from existing predictive-reactive approaches for production scheduling, we use the soft decision specially designed for the SCC process as decision variables in generating an initial schedule. Rather than fixing assignments of charges to machines and starting times of charges at each stage in the schedule, the soft schedule gives only some characteristics that the consequent online dispatching procedure needs to satisfy, therefore by this method it is possible to provide more flexibility towards unexpected disruptions in real-world production environments.

This paper is organized as follows. Section 2 formulates the SCC scheduling problem, Section 3 illustrates the proposed soft-decision based algorithm in detail, including the solution framework, the inherent idea of designing soft decision, the offline optimization algorithm and the online dispatching heuristic, experimental results are provided in Section 4. Conclusions and future work are given in Section 5.

The uncertain SCC scheduling problem studied in this paper arises from the practical SCC production environment. In this problem, one is expected to decide in real time which charge and when to process whenever a machine gets available. In this section, we model this problem as a stochastic optimization problem with the objective of minimizing the total weighted waiting time and the probability of cast interruption, which are the most significant objectives in real-life SCC process. In the model, n unfinished charges are formed into B casts at the stage of continuous caster. Charges in the same cast have the same processing route and corresponding processing times. A transportation time is occurred when a charge is transported from an upstream machine to a downstream machine. In this paper we assume that charges can be transferred to a target machine with a transportation time (which can be represented as a random number) whenever needed. This hypothesis is reasonable since transportation of charges is usually not the bottleneck of the overall SCC production line. Each charge and machine has a release time, if the charge is being processed, then the release time is its expected completion time, which is also the release time of the corresponding machine. All charges visit three stages in the same direction, i.e. firstly visit BOF, and then LF, finally CC. In this model, the processing time and the transportation time of charges between machines in the SCC shop cannot be accurately determined in advance due to the inherent complexity of the SCC production, therefore, they are modelled as stochastic variables. Also, since the production speed of the upstream iron smelting factory is not constant and the transportation vehicles are not available all the time, the arrival time of charges is also modelled as stochastic variables. The detailed notations are described as follows.


                        
                           
                              •
                              
                                 h: index of cast, 
                                    
                                       h
                                       =
                                       1
                                       ,
                                       2
                                       ,
                                       ⋯
                                    
                                 , |CS|, where CS is the set of unfinished casts.


                                 i: index of charge, 
                                    
                                       i
                                       =
                                       1
                                       ,
                                       2
                                       ,
                                       ⋯
                                    
                                 , |LS|, where LS is the set of unfinished charges.


                                 l: index of machine, 
                                    
                                       l
                                       =
                                       1
                                       ,
                                       2
                                       ,
                                       ⋯
                                    
                                 , |MS|, where MS is the set of all available machines.


                                 CS
                                 1: set of casts that have started processing on a continuous caster.


                                 CS
                                 2: set of casts that have started processing on a BOF, but have not started processing on a continuous caster.


                                 CS
                                 3: set of casts that have not started processing on a BOF.


                                 mh
                                 : index of assigned continuous caster for cast h, h ∈ CS
                                 1.


                                 ri
                                 : release time of charge i, which is a random number over interval 
                                    
                                       [
                                       
                                          
                                             
                                                r
                                                i
                                             
                                             ̲
                                          
                                          ,
                                          
                                             
                                                r
                                                ¯
                                             
                                             i
                                          
                                       
                                       ]
                                    
                                 .


                                 hi
                                 : index of cast of charge i, hi
                                  ∈ CS;


                                 mrl
                                 : release time of machine l, which is a random number over interval 
                                    
                                       [
                                       
                                          
                                             
                                                m
                                                
                                                   r
                                                   l
                                                
                                             
                                             ̲
                                          
                                          ,
                                          
                                             
                                                
                                                   m
                                                   r
                                                
                                                ¯
                                             
                                             l
                                          
                                       
                                       ]
                                    
                                 .

(i, k): index of an operation, which represents the k-th processing stage of charge i, 
                                    
                                       k
                                       =
                                       1
                                       ,
                                       
                                       2
                                       ,
                                       ⋯
                                       ,
                                       
                                       
                                          n
                                          i
                                       
                                    
                                 , where ni
                                  is the total number of unfinished processing stages of charge i.


                                 p
                                 
                                    i, k
                                 : processing time of operation (i, k), which is a random number over interval 
                                    
                                       [
                                       
                                          
                                             p
                                             ̲
                                          
                                          
                                             i
                                             ,
                                             k
                                          
                                       
                                       ,
                                       
                                          
                                             p
                                             ¯
                                          
                                          
                                             i
                                             ,
                                             k
                                          
                                       
                                       ]
                                    
                                 . Under our assumption, the processing time is independent with machines.


                                 MS
                                 
                                    i, k
                                 : set of machines on which operation (i, k) can be processed.


                                 tr(l
                                 1, l
                                 2): transportation time between machine l
                                 1 and l
                                 2, which is a random number over interval
                                    
                                       
                                       [
                                       
                                          
                                             
                                                t
                                                r
                                             
                                             ̲
                                          
                                          
                                             (
                                             
                                                
                                                   l
                                                   1
                                                
                                                ,
                                                
                                                   l
                                                   2
                                                
                                             
                                             )
                                          
                                          ,
                                          
                                             
                                                t
                                                r
                                             
                                             ¯
                                          
                                          
                                             (
                                             
                                                
                                                   l
                                                   1
                                                
                                                ,
                                                
                                                   l
                                                   2
                                                
                                             
                                             )
                                          
                                       
                                       ]
                                    
                                 .


                                 Sh
                                 : set of charges belonging to cast h.

(h, j): the j–th charge in cast h.


                                 lh
                                 : index of continuous caster corresponding to cast h, h ∈ CS
                                 1.


                                 w
                                 1, w
                                 2, w
                                 3: weights of waiting times of BOF, LF and CC stage, which satisfies w
                                 1 < w
                                 2 < w
                                 3.


                                 Al
                                 : set of operations assigned to machine l.


                        
                           
                              •
                              
                                 x
                                 
                                    i, k
                                 : the machine to which operation (i, k) is assigned.


                                 st
                                 
                                    i, k
                                 : the starting time of operation (i, k).


                        
                           
                              •
                              Every operation can only be processed after its precedent operation of the same charge has been completed.
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      s
                                                      
                                                         t
                                                         
                                                            i
                                                            ,
                                                            k
                                                            +
                                                            1
                                                         
                                                      
                                                      ≥
                                                      s
                                                      
                                                         t
                                                         
                                                            i
                                                            ,
                                                            k
                                                         
                                                      
                                                      +
                                                      
                                                         p
                                                         
                                                            i
                                                            ,
                                                            k
                                                         
                                                      
                                                      +
                                                      t
                                                      r
                                                      
                                                         (
                                                         
                                                            
                                                               x
                                                               
                                                                  i
                                                                  ,
                                                                  k
                                                               
                                                            
                                                            ,
                                                            
                                                               x
                                                               
                                                                  i
                                                                  ,
                                                                  k
                                                                  +
                                                                  1
                                                               
                                                            
                                                         
                                                         )
                                                      
                                                      
                                                      i
                                                      ∈
                                                      L
                                                      S
                                                      ,
                                                      
                                                      k
                                                      =
                                                      1
                                                      ,
                                                      2
                                                      ,
                                                      ⋯
                                                      ,
                                                      
                                                         n
                                                         i
                                                      
                                                      −
                                                      1
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      s
                                                      
                                                         t
                                                         
                                                            i
                                                            ,
                                                            1
                                                         
                                                      
                                                      ≥
                                                      
                                                         r
                                                         i
                                                      
                                                      
                                                      i
                                                      ∈
                                                      L
                                                      S
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              

A machine can at most process one charge at a time.
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      s
                                                      
                                                         t
                                                         
                                                            i
                                                            1
                                                            ,
                                                            k
                                                            1
                                                         
                                                      
                                                      ≥
                                                      s
                                                      
                                                         t
                                                         
                                                            i
                                                            2
                                                            ,
                                                            k
                                                            2
                                                         
                                                      
                                                      +
                                                      
                                                         p
                                                         
                                                            i
                                                            2
                                                            ,
                                                            k
                                                            2
                                                         
                                                      
                                                      
                                                         
                                                         V
                                                         
                                                      
                                                      s
                                                      
                                                         t
                                                         
                                                            i
                                                            2
                                                            ,
                                                            k
                                                            2
                                                         
                                                      
                                                      ≥
                                                      s
                                                      
                                                         t
                                                         
                                                            i
                                                            1
                                                            ,
                                                            k
                                                            1
                                                         
                                                      
                                                      +
                                                      
                                                         p
                                                         
                                                            i
                                                            1
                                                            ,
                                                            k
                                                            1
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         (
                                                         
                                                            i
                                                            1
                                                            ,
                                                            k
                                                            1
                                                         
                                                         )
                                                      
                                                      ∈
                                                      
                                                         A
                                                         l
                                                      
                                                      ,
                                                      
                                                         (
                                                         
                                                            i
                                                            2
                                                            ,
                                                            k
                                                            2
                                                         
                                                         )
                                                      
                                                      ∈
                                                      
                                                         A
                                                         l
                                                      
                                                      ,
                                                      
                                                      
                                                         (
                                                         
                                                            i
                                                            1
                                                            ,
                                                            k
                                                            1
                                                         
                                                         )
                                                      
                                                      ≠
                                                      
                                                         (
                                                         
                                                            i
                                                            2
                                                            ,
                                                            k
                                                            2
                                                         
                                                         )
                                                      
                                                      ,
                                                      
                                                      l
                                                      ∈
                                                      M
                                                      S
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              

Machines are available only after its release time.
                                    
                                       
                                          
                                             s
                                             
                                                t
                                                
                                                   i
                                                   ,
                                                   k
                                                
                                             
                                             ≥
                                             m
                                             
                                                r
                                                l
                                             
                                             
                                             
                                             
                                                (
                                                
                                                   i
                                                   ,
                                                   k
                                                
                                                )
                                             
                                             ∈
                                             
                                                A
                                                l
                                             
                                             ,
                                             
                                             l
                                             ∈
                                             M
                                             S
                                          
                                       
                                    
                                 
                              

Continuous casting constraint: charges in the same cast need to be processed consecutively on a particular caster without interruption. If the cast is being processed on a continuous caster, then the next charge should be processed on this caster exactly after the current charge ends. In real-life environments, however, this constraint cannot be satisfied all the time due to the uncertainties. Hence, it is a soft constraint and we also include it in the objective function.

                                    
                                       
                                          
                                             s
                                             
                                                t
                                                
                                                   
                                                      (
                                                      
                                                         h
                                                         ,
                                                         j
                                                         +
                                                         1
                                                      
                                                      )
                                                   
                                                   ,
                                                   
                                                      n
                                                      
                                                         (
                                                         
                                                            h
                                                            ,
                                                            j
                                                            +
                                                            1
                                                         
                                                         )
                                                      
                                                   
                                                
                                             
                                             
                                             =
                                             
                                             s
                                             
                                                t
                                                
                                                   
                                                      (
                                                      
                                                         h
                                                         ,
                                                         j
                                                      
                                                      )
                                                   
                                                   ,
                                                   
                                                      n
                                                      
                                                         (
                                                         
                                                            h
                                                            ,
                                                            j
                                                         
                                                         )
                                                      
                                                   
                                                
                                             
                                             
                                             +
                                             
                                             
                                                p
                                                
                                                   (
                                                   
                                                      h
                                                      ,
                                                      j
                                                   
                                                   )
                                                
                                             
                                             
                                             
                                             
                                             j
                                             
                                             =
                                             
                                             1
                                             ,
                                             2
                                             ,
                                             ⋯
                                             ,
                                             
                                                |
                                                
                                                   S
                                                   h
                                                
                                                |
                                             
                                             ,
                                             h
                                             ∈
                                             C
                                             
                                                S
                                                2
                                             
                                             ∪
                                             C
                                             
                                                S
                                                3
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             s
                                             
                                                t
                                                
                                                   
                                                      (
                                                      
                                                         h
                                                         ,
                                                         j
                                                         +
                                                         1
                                                      
                                                      )
                                                   
                                                   ,
                                                   
                                                      n
                                                      
                                                         (
                                                         
                                                            h
                                                            ,
                                                            j
                                                            +
                                                            1
                                                         
                                                         )
                                                      
                                                   
                                                
                                             
                                             =
                                             s
                                             
                                                t
                                                
                                                   
                                                      (
                                                      
                                                         h
                                                         ,
                                                         j
                                                      
                                                      )
                                                   
                                                   ,
                                                   
                                                      n
                                                      
                                                         (
                                                         
                                                            h
                                                            ,
                                                            j
                                                         
                                                         )
                                                      
                                                   
                                                
                                             
                                             +
                                             
                                                p
                                                
                                                   (
                                                   
                                                      h
                                                      ,
                                                      j
                                                   
                                                   )
                                                
                                             
                                             
                                             
                                             
                                             j
                                             =
                                             1
                                             ,
                                             2
                                             ,
                                             ⋯
                                             ,
                                             
                                                |
                                                
                                                   S
                                                   h
                                                
                                                |
                                             
                                             ,
                                             h
                                             ∈
                                             C
                                             
                                                S
                                                1
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             s
                                             
                                                t
                                                
                                                   
                                                      (
                                                      
                                                         h
                                                         ,
                                                         1
                                                      
                                                      )
                                                   
                                                   ,
                                                   
                                                      n
                                                      
                                                         (
                                                         
                                                            h
                                                            ,
                                                            1
                                                         
                                                         )
                                                      
                                                   
                                                
                                             
                                             =
                                             m
                                             
                                                r
                                                
                                                   l
                                                   h
                                                
                                             
                                             
                                             
                                             h
                                             ∈
                                             C
                                             
                                                S
                                                1
                                             
                                          
                                       
                                    
                                 
                              

In real-world environments, schedulers are required to avoid cast interruptions, as well as to decrease waiting times of high-temperature charges at each stage. Therefore, the above two aspects are considered as two conflicting objectives in this model.

                           
                              •
                              Minimize average weighted sum of waiting times at three stages:

                                    
                                       
                                          
                                             
                                                
                                                   AWT
                                                
                                                
                                                   =
                                                
                                                
                                                   
                                                      
                                                         1
                                                         
                                                            |
                                                            
                                                               L
                                                               S
                                                            
                                                            |
                                                         
                                                      
                                                      
                                                         (
                                                         
                                                            
                                                               ∑
                                                               
                                                                  
                                                                     (
                                                                     
                                                                        i
                                                                        ,
                                                                        k
                                                                     
                                                                     )
                                                                  
                                                                  ∈
                                                                  B
                                                                  O
                                                                  F
                                                               
                                                            
                                                            
                                                               
                                                                  w
                                                                  1
                                                               
                                                               
                                                                  (
                                                                  
                                                                     s
                                                                     
                                                                        t
                                                                        
                                                                           i
                                                                           ,
                                                                           k
                                                                        
                                                                     
                                                                     −
                                                                     
                                                                        r
                                                                        i
                                                                     
                                                                  
                                                                  )
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                
                                                
                                                   
                                                      
                                                      +
                                                      
                                                         ∑
                                                         
                                                            
                                                               (
                                                               
                                                                  i
                                                                  ,
                                                                  k
                                                               
                                                               )
                                                            
                                                            ∈
                                                            L
                                                            F
                                                         
                                                      
                                                      
                                                         w
                                                         2
                                                      
                                                      
                                                         (
                                                         
                                                            s
                                                            
                                                               t
                                                               
                                                                  i
                                                                  ,
                                                                  k
                                                               
                                                            
                                                            −
                                                            s
                                                            
                                                               t
                                                               
                                                                  i
                                                                  ,
                                                                  k
                                                                  −
                                                                  1
                                                               
                                                            
                                                            −
                                                            
                                                               p
                                                               
                                                                  i
                                                                  ,
                                                                  k
                                                                  −
                                                                  1
                                                               
                                                            
                                                         
                                                         )
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                
                                                
                                                   
                                                      
                                                      
                                                         +
                                                         
                                                            ∑
                                                            
                                                               
                                                                  (
                                                                  
                                                                     i
                                                                     ,
                                                                     k
                                                                  
                                                                  )
                                                               
                                                               ∈
                                                               C
                                                               C
                                                            
                                                         
                                                         
                                                            
                                                               w
                                                               3
                                                            
                                                            
                                                               (
                                                               
                                                                  s
                                                                  
                                                                     t
                                                                     
                                                                        i
                                                                        ,
                                                                        k
                                                                     
                                                                  
                                                                  −
                                                                  s
                                                                  
                                                                     t
                                                                     
                                                                        i
                                                                        ,
                                                                        k
                                                                        −
                                                                        1
                                                                     
                                                                  
                                                                  −
                                                                  
                                                                     p
                                                                     
                                                                        i
                                                                        ,
                                                                        k
                                                                        −
                                                                        1
                                                                     
                                                                  
                                                               
                                                               )
                                                            
                                                         
                                                         )
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              

where the symbol “BOF” represents the set of operations to be processed on BOF machines, so are “LF” and “CC”, w
                        1, w
                        2 and w
                        3 represent penalty coefficients of waiting time at different stages, generally w
                        1 < w
                        2 < w
                        3.

                           
                              •
                              Minimize probability of cast interruption:
                                    
                                       
                                          
                                             CIR
                                             =
                                             p
                                             
                                                (
                                                
                                                   c
                                                   i
                                                
                                                )
                                             
                                          
                                       
                                    
                                 
                              

The deterministic SCC scheduling problem is often regarded as a complicated form of hybrid flow shop (HFS) scheduling problems in literature because of its additional constraints, stochastic variables and more complex scheduling objectives (Xuan & Tang, 2007). It has been shown that the two stage HFS scheduling problems with the makespan criterion are NP-Complete (Gupta, 1988).

A key challenge of scheduling real-world SCC processes is how to deal with unexpected events that occur frequently. The existence of unexpected events may deteriorate the initial schedule, or even make it infeasible during the execution of the initial schedule. In our approach, unexpected events in the SCC process are classified into two categories: critical events and non-critical events. Critical events include arrivals of new casts released by the enterprise planning level, long-term machine failure and charge-hold, and other events that may cause the initial schedule to be extremely worse or infeasible, while non-critical events include fluctuations of processing times, transportation times and arriving times, short-term machine failure and charge-hold (which can also be regarded as fluctuations of processing times of charges). Generally, when critical events happen, schedulers need to generate a new timetable plan which may be a modified version of the initial plan or a fully-new one, while in the case of non-critical events, schedulers often have to continue with the initial timetable plan due to the high occurrence frequency of these events. Traditional timetable plan based approaches do not perform well due to the rigid nature of decision variables.

Our approach deals with this uncertain situation by introducing soft decision (or soft schedule) to replace the traditional timetable plan. In a soft schedule, some characteristic variables rather than the rigid variables of the timetable plan are given, which will be described in detail in Section 3.2. Under this assumption, a soft schedule is more like a dispatching heuristic which is capable to provide operational decisions incorporating real-time information. Furthermore, we present a two-layered framework based on the popular predictive-reactive idea to handle with uncertainties in job shop scheduling literature. The upper layer is the offline optimization layer, in which a soft schedule is generated and released to the lower layer when some critical events happen, and the lower layer is the online dispatching layer, where a dispatching heuristic is designed to decide in real time which charge and when to process, based on the soft schedule given by the upper layer and the real-time production information. The two-layered solution framework is shown in Fig. 3
                         as below.

In our scheme, the soft schedule is re-generated once a critical event happens. Non-critical disruptions, such as uncertain arrivals of charges, fluctuations of processing times and transportation times, short-term machine failure and charge-hold, would not greatly influence the feasibility and the performance of the soft schedule, thus, the soft schedule remains unchanged when non-critical events happen. As above critical events would not happen very frequently in real-world SCC production lines, the soft schedule is able to keep stable for a long period of time with the presence of frequent disruptions. This is the most significant advantage of our approach. The idea of the proposed method is also applicable for other similar SCC scheduling problems, since minimizing the number of cast interruptions and minimizing the total waiting times of charges are the most significant objectives in the SCC scheduling problems.

As illustrated in Section 1, rigid-decision based approaches are difficult to perform well under uncertain production environments with the presence of frequent unpredicted disruptions, this motivates us to design a new formulation of schedule for uncertain SCC scheduling problems. In our approach, we present the concept of soft decisions or soft schedules to cope with this situation. Generally, a decision or a schedule is “soft” means that it provides flexibility in response to unexpected disruptions, while traditional timetable based schedule is not “soft” since it fixes the starting times and assigned machines for each charge at each processing stage.

Generally, there are three principles when designing a good form of soft decision for uncertain SCC scheduling environments. (1) Starting times or assigned machines for specific operations should not be fixed in advance, since the best values of these variables are easily influenced by real-time events (e.g. fluctuations of processing times and arriving times of charges) that are unknown at the time of offline optimization. (2) The soft schedule should indicate some key features that are significantly influential to the overall performance criterions. (3) The soft schedule should be relatively stable during the scheduling period, i.e. once we obtain a soft schedule at a time, it should be effective and need not be frequently repaired when non-critical events happen during the execution of the schedule.

Since the goal of scheduling SCC production process is to decrease the weighted sum of waiting times of charges while minimizing the probability of cast interruptions, assume that we do not consider unexpected disruptions in the model, then charges would be scheduled as later as they can in the optimal timetable plan so as to minimize the cost of total waiting times since w
                        1 < w
                        2 < w
                        3. On the other hand, if we are required to avoid cast interruption with probability 1 under uncertain environments without considering the objective of minimizing the weighted sum of waiting times of charges, then we need to design a schedule with large waiting times of charges in each cast so as to ensure an enough margin to meet the worst case of fluctuations of processing times, transportation times etc. Therefore, considering two conflicting objectives, the best schedule should be a compromise between the above two extreme situations, and there exists some features by which the two conflicting objectives can be well balanced for the SCC production process. In this paper we use the concept of cast workload to achieve this goal. The cast workload is defined as the total amount of in-process workload for a cast, and the in-process workload of a cast means the workload of charges that have already begun processing on a BOF machine and have not finished on a CC machine. The essential idea behind this definition is that, since processing routes of different charges in a cast are identical, the optimal value of the cast workload is not directly related with the refining stage. However, casts with refining or without refining will probably have different cast workload values, as casts with refining have a longer processing route and naturally will have a larger cast workload value in terms of optimization. We denote the cast workload of cast h at time t as cwh
                        (t), which is defined as below.

                           
                              
                                 
                                    
                                       
                                          
                                             c
                                             
                                                w
                                                
                                                   h
                                                   ,
                                                   i
                                                
                                             
                                             
                                                (
                                                t
                                                )
                                             
                                          
                                       
                                       
                                          =
                                       
                                       
                                          
                                             
                                             
                                                {
                                                
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     f
                                                                     
                                                                        i
                                                                        ,
                                                                        
                                                                           n
                                                                           i
                                                                        
                                                                     
                                                                  
                                                                  
                                                                     (
                                                                     t
                                                                     )
                                                                  
                                                               
                                                               
                                                                  p
                                                                  
                                                                     i
                                                                     ,
                                                                     
                                                                        n
                                                                        i
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            i
                                                            f
                                                            
                                                            o
                                                            p
                                                            e
                                                            r
                                                            a
                                                            t
                                                            i
                                                            o
                                                            n
                                                            
                                                            (
                                                            
                                                               i
                                                               ,
                                                               
                                                                  n
                                                                  i
                                                               
                                                            
                                                            )
                                                            
                                                            i
                                                            s
                                                            
                                                            b
                                                            e
                                                            i
                                                            n
                                                            g
                                                            
                                                            p
                                                            r
                                                            o
                                                            c
                                                            e
                                                            s
                                                            s
                                                            e
                                                            d
                                                            
                                                            o
                                                            n
                                                            
                                                            C
                                                            C
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     p
                                                                     
                                                                        i
                                                                        ,
                                                                        1
                                                                     
                                                                  
                                                                  
                                                                  −
                                                                  
                                                                  
                                                                     f
                                                                     
                                                                        i
                                                                        ,
                                                                        1
                                                                     
                                                                  
                                                                  
                                                                     (
                                                                     t
                                                                     )
                                                                  
                                                               
                                                               
                                                                  p
                                                                  
                                                                     i
                                                                     ,
                                                                     1
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            i
                                                            f
                                                            
                                                            o
                                                            p
                                                            e
                                                            r
                                                            a
                                                            t
                                                            i
                                                            o
                                                            n
                                                            
                                                            (
                                                            
                                                               i
                                                               ,
                                                               1
                                                            
                                                            )
                                                            
                                                            i
                                                            s
                                                            
                                                            b
                                                            e
                                                            i
                                                            n
                                                            g
                                                            
                                                            p
                                                            r
                                                            o
                                                            c
                                                            e
                                                            s
                                                            s
                                                            e
                                                            d
                                                            
                                                            o
                                                            n
                                                            
                                                            B
                                                            O
                                                            F
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         1
                                                      
                                                      
                                                         
                                                            e
                                                            l
                                                            s
                                                            e
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             c
                                             
                                                w
                                                h
                                             
                                             
                                                (
                                                t
                                                )
                                             
                                          
                                       
                                       
                                          =
                                       
                                       
                                          
                                             
                                                ∑
                                                
                                                   i
                                                   ∈
                                                   
                                                      S
                                                      h
                                                   
                                                   
                                                      (
                                                      t
                                                      )
                                                   
                                                
                                             
                                             c
                                             
                                                w
                                                
                                                   h
                                                   ,
                                                   i
                                                
                                             
                                             
                                                (
                                                t
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where cw
                        
                           h, i
                        (t) is the workload of charge i in cast h at time t, f
                        
                           i, k
                        (t) is the remaining processing time of operation (i, k) at time t, Sh
                        (t) is the set of work-in-process charges in cast h at time t, and ni
                         is the total number of operations of charge i. Note that for a charge that is being processed on a BOF machine or a CC machine, the corresponding workload value may not be an integer number under the above definition. Fig. 4
                         gives an example to illustrate the workload value of a charge over time, where p
                        BOF, p
                        CC represent the processing times of this charge on the BOF stage and the CC stage, respectively.

As is shown in Fig. 4, at time A, the charge begins to be processed at the BOF stage, and the workload value of this charge, denoted as cwi
                        , begins to grow from 0. At time B, the charge finishes its processing at the BOF stage and cwi
                         grows to 1. At time C, the charge begins to be processed at the CC stage and cwi
                         begins to decrease from 1 and reaches 0 at time D where the charge finishes processing at the CC stage. The cast workload is the total sum of workload of charges that belong to this cast. In the optimal schedule of the deterministic case of the SCC scheduling problem studied in this paper, due to the existence of continuous casting constraints, the cast workload curve takes on a similar pattern with Fig. 4. An example is given in Fig. 5
                         to demonstrate cast workload curves in an optimal schedule of a small SCC instance, where there exist 3 BOF machines, 2 LF machines and 2 CC machines, and each cast includes 8 identical charges.

Furthermore, Fig. 6
                         shows the cast workload curves of different casts over time from a real-life SCC plant. Some charges need not to go through LF machines in their processing routes. We select data from two typical cases, where in the first case charges are scheduled and dispatched well, while in the second case the production scheduling is not good and a cast interruption happens.

It can be seen that in the first case, the cast workload value remains stable or slightly changed in the middle phase of each curve (corresponding to each cast), while in the second case, the cast workload seems to be obviously fluctuating in the middle phase. Extensive analysis on a long period of production data also shows a similar behavior. Hence, we can conclude that the cast workload is a significant feature for real-world steel-making continuous-casting production environment, as it reflects, for a given cast, the probability of cast interruption and the penalty of total weighted waiting time of charges, i.e. the larger the cast workload value, the smaller the probability of cast interruption, and the larger the total weighted waiting time of charges, and vice versa. Hence, it can be inferred from the above cases that in well-scheduled circumstances, the cast workload of each cast is in a stable status in its middle phase during the production. Therefore, if we know in advance the best value of cast workload for each cast, it would be easy to decide in real time when to process a charge under uncertain production environment.

However, it is hard to determine the best cast workload value for to-be-scheduled casts, since it depends on the processing route, the processing times at each stage, the arriving speed of charges, and characteristics of production environment for each cast. Therefore, we take the cast workload values as soft decision variables in the offline optimization algorithm. Besides, since the processing sequence (or priority) of casts is also very influential to the overall scheduling performance, as it determines the starting sequence of charges at each stage, the sequence of casts is also included into the soft schedule.

The studied problem in Section 2 belongs to the field of nonlinear, mixed (involving discrete and continuous variables simultaneously), and stochastic optimization. To our knowledge, no analytical methods can be used to solve this problem. Particle swarm optimization (PSO), which was first introduced by Kennedy and Eberhart (1995), is an efficient optimization tool for complex optimization problems and has gained much attention in recent years (AlRashidi & El-Hawary, 2009; Kulkarni & Venayagamoorthy, 2011). PSO is a population-based algorithm that starts with a randomly generated population and then improves the performance of population through iterations of searching operators. Each member of the population is called a particle, each particle moves around in the search space, taking the advantage of its own experience and the experience of some other particles to guide the search. Fig. 7 illustrates the basic procedure of a standard PSO algorithm used in offline optimization layer. Each iteration consists of three basic steps: particle moving, velocity updating, and swarm evaluation. For a given optimization problem, PSO keeps improving the particles until no improvement can be made or a pre-determined number of iterations is reached. PSO has become a candidate for solving many complex optimization applications due to its high-performance and flexibility to specific problem characteristics (Kennedy & Eberhart, 2001).

Compared with other evolutionary algorithms like genetic algorithm (GA), the main advantages of PSO are its simplicity, robustness in controlling parameters and its high computational efficiency (Eberhart & Shi, 1998), as it incorporates only moving operators in searching an optimum. It also has a flexible and well-balanced mechanism by local search and global search to improve the performance of optimization (Abido, 2002). The PSO algorithm and its variants have been successfully applied to different optimization areas such as production planning and scheduling (Liu, Wang, & Jin, 2007; Tang & Wang, 2010), distribution state estimation (Naka, Genji, Yura, & Fukuyama, 2003), reactive power dispatching (Zhao, Guo, & Cao, 2005), and electromagnetic devices design (Ho, Yang, Ni, & Wong, 2006).

In uncertain production environments, once some critical events happen such as new casts from the factory planning level are released, long-term machine failure, the soft schedule needs to be re-generated immediately. Hence, to improve the efficiency and effectiveness of the solution procedure, we present a knowledge based population initialization method to improve the initial performance of the population, and a new adaptive particle moving mechanism for PSO to balance between exploitation and exploration. Also, multiple simulations are needed to evaluate the performance of a specific schedule under stochastic environments. The following sections will illustrate details of the PSO algorithm used in the offline optimization layer.

Each solution of PSO is represented with the following form:

                              
                                 
                                    
                                       {
                                       
                                          p
                                          
                                             r
                                             1
                                          
                                          ,
                                          p
                                          
                                             r
                                             2
                                          
                                          ,
                                          ⋯
                                          ,
                                          p
                                          
                                             r
                                             
                                                |
                                                
                                                   C
                                                   S
                                                
                                                |
                                             
                                          
                                          
                                             |
                                             c
                                          
                                          
                                             w
                                             1
                                          
                                          ,
                                          c
                                          
                                             w
                                             2
                                          
                                          ,
                                          ⋯
                                          ,
                                          c
                                          
                                             w
                                             
                                                |
                                                
                                                   C
                                                   S
                                                
                                                |
                                             
                                          
                                          
                                       
                                       }
                                    
                                 
                              
                           where pr
                           1, pr
                           2, ⋅⋅⋅, pr
                           |CS| are priorities of casts in the set CS, cwh
                            is the cast workload of cast h. Under above solution representation scheme, the problem turns to be a hybrid optimization problem.

We use a simulation-based approach to evaluate a given soft schedule. Since the soft schedule presented in this paper does not give assignments of charges to machines and starting times of charges at each stage, we design a knowledge-based dispatching heuristic, which are used to determine the above decisions in the process of decoding a soft schedule and also used in online dispatching in real time.

In solution evaluation, the simulation proceeds in a time-driven manner, that is, all of simulation events are executed in an ascending order of corresponding timestamps. The evaluation process is demonstrated in detail as below.


                           
                              Solution evaluation procedure
                           
                           
                              
                                 
                                    Step 1:
                                 
                                 execute simulation in a time-driven manner, where random variables in the model are sampled during the simulation process. When a machine is available at a time, the dispatching heuristic described in Section 3.4 is used to make the decision of which charge to process or not. If no charge is selected, then generate a new event to select an operation at the next timestamp.

if a cast interruption happens when executing simulation, then the simulation is terminated, else if the simulation ends normally without cast interruption, then calculate the average weighted sum of waiting times of charges as the objective value.

Step 3: repeat step 1 and step 2 for a predetermined number of simulation runs, and calculate the probability of cast interruption and the average weighed sum of waiting times by:

                                       
                                          
                                             
                                                p
                                                
                                                   (
                                                   
                                                      c
                                                      i
                                                   
                                                   )
                                                
                                                =
                                                
                                                   
                                                      n
                                                      
                                                         c
                                                         i
                                                      
                                                   
                                                   n
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                AWT
                                                =
                                                
                                                   
                                                      
                                                         ∑
                                                         
                                                            i
                                                            =
                                                            1
                                                         
                                                         
                                                            n
                                                            −
                                                            
                                                               n
                                                               
                                                                  c
                                                                  i
                                                               
                                                            
                                                         
                                                      
                                                      t
                                                      
                                                         w
                                                         i
                                                      
                                                   
                                                   
                                                      n
                                                      −
                                                      
                                                         n
                                                         
                                                            c
                                                            i
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    where n is the total number of simulations for the given soft schedule, nci
                                     is the number of simulations where at least one cast interruption happens, and twi
                                     is the weighed sum of waiting times of the i-th simulation. According to the law of large numbers, p(ci) will converge to the actual probability of cast interruption when n is large enough. Note that simulations where at least one cast is interrupted are not counted in the calculation of AWT.

Each individual consists of two parts: (1) cast workload values, and (2) sequence of casts. In order to generate good and diversified population, we propose a history data based initialization method for generating a particle as follows.


                           
                              Swarm 
                              initialization 
                              procedure
                           
                           
                              
                                 
                                    Step 1:
                                 
                                 considering that the best value of cast workload may be different for different casts, we classify historical casts that were well scheduled, into four categories according to the following two attributes:

                                       
                                          (1)
                                          
                                             Type of processing route. There are two options of this attribute for a given cast: the first is going through LF stage, the second is not.


                                             Processing difficulty. There are two options of this attribute for a given cast: easy and hard. “Easy” means there is little uncertainty in processing each charge of the cast, i.e. the processing time is controllable. On the contrary, “hard” means there are many unpredicted factors influencing the production of the cast.

for casts in each category, calculate the maximum and the minimum of their cast workload values, denoted as cw
                                    
                                       i, max
                                     and 
                                       
                                          c
                                          
                                             w
                                             
                                                i
                                                ,
                                                m
                                                i
                                                n
                                             
                                          
                                          ,
                                          
                                          i
                                          =
                                          1
                                          ,
                                          
                                          2
                                          ,
                                          
                                          3
                                          ,
                                          
                                          4
                                          
                                       
                                    where i is index of categories.

generate initial cast workload of cast j values by the following formula:

                                       
                                          
                                             
                                                c
                                                
                                                   w
                                                   j
                                                
                                                =
                                                r
                                                
                                                
                                                a
                                                n
                                                d
                                                
                                                
                                                
                                                   [
                                                   
                                                      c
                                                      
                                                         w
                                                         
                                                            i
                                                            (
                                                            j
                                                            )
                                                            ,
                                                            m
                                                            i
                                                            n
                                                         
                                                      
                                                      ,
                                                      c
                                                      
                                                         w
                                                         
                                                            i
                                                            (
                                                            j
                                                            )
                                                            ,
                                                            m
                                                            a
                                                            x
                                                         
                                                      
                                                   
                                                   ]
                                                
                                             
                                          
                                       
                                    where i(j) represents the category index of cast j, r  
                                    and  [a, b] represents a random value uniformly distributed over interval [a, b].

determine the initial cast sequence by following rules:

                                       
                                          (1)
                                          Casts that are being processed on a CC machine are most prior.

Casts that have begun to be processed on a BOF machine are secondly prior.

Casts that have not begun to be processed on a BOF machine are thirdly prior.

Randomly determine the sequence if two casts are in the same level of priority.

assume the velocities of a particle is represented as
                                       
                                          
                                          
                                             V
                                             c
                                          
                                          =
                                          
                                             {
                                             
                                                
                                                   v
                                                   
                                                      s
                                                      e
                                                      q
                                                   
                                                
                                                ,
                                                
                                                   v
                                                   1
                                                
                                                ,
                                                
                                                   v
                                                   2
                                                
                                                ,
                                                ⋯
                                                ,
                                                
                                                   v
                                                   
                                                      |
                                                      
                                                         C
                                                         S
                                                      
                                                      |
                                                   
                                                
                                             
                                             }
                                          
                                       
                                    , where vseq
                                     is velocity of cast priority sequence, and vk
                                     is velocity of cast workload of cast 
                                       
                                          k
                                          
                                          (
                                          
                                             k
                                             =
                                             1
                                             ,
                                             2
                                             ,
                                             ⋯
                                             ,
                                             |
                                             
                                                C
                                                S
                                             
                                             |
                                          
                                          )
                                       
                                    . For velocities of each particle, generate a uniformly distributed random value over interval (0, 1) as the initial value of vseq
                                    , and a uniformly distributed random value over interval
                                       
                                          
                                          (
                                          
                                             −
                                             1
                                             ,
                                             
                                             1
                                          
                                          )
                                       
                                     as the initial value of vk
                                    .

The initial swarm is generated by repeating through step 1 to step 5 for N times.

Generally, we need to move particles to their personal-best and global-best with a given probability in each iteration of the PSO algorithm. Since the individual consists of two parts, i.e. cast workload values and sequence of casts, we propose a particle-moving method in which two parts are updated separately. Assume the current particle is 
                              
                                 
                                    P
                                    c
                                 
                                 =
                                 
                                    {
                                    
                                       p
                                       
                                          r
                                          1
                                          c
                                       
                                       ,
                                       p
                                       
                                          r
                                          2
                                          c
                                       
                                       ,
                                       ⋯
                                       ,
                                       p
                                       
                                          r
                                          
                                             |
                                             
                                                C
                                                S
                                             
                                             |
                                          
                                          c
                                       
                                       
                                          |
                                          c
                                       
                                       
                                          w
                                          1
                                          c
                                       
                                       ,
                                       c
                                       
                                          w
                                          2
                                          c
                                       
                                       ,
                                       ⋯
                                       ,
                                       c
                                       
                                          w
                                          
                                             |
                                             
                                                C
                                                S
                                             
                                             |
                                          
                                          c
                                       
                                       
                                    
                                    }
                                 
                              
                           , the objective particle is
                              
                                 
                                 
                                    P
                                    o
                                 
                                 =
                                 
                                    {
                                    
                                       p
                                       
                                          r
                                          1
                                          o
                                       
                                       ,
                                       p
                                       
                                          r
                                          2
                                          o
                                       
                                       ,
                                       ⋯
                                       ,
                                       p
                                       
                                          r
                                          
                                             |
                                             
                                                C
                                                S
                                             
                                             |
                                          
                                          o
                                       
                                       
                                          |
                                          c
                                       
                                       
                                          w
                                          1
                                          o
                                       
                                       ,
                                       c
                                       
                                          w
                                          2
                                          o
                                       
                                       ,
                                       ⋯
                                       ,
                                       c
                                       
                                          w
                                          
                                             |
                                             
                                                C
                                                S
                                             
                                             |
                                          
                                          o
                                       
                                       
                                    
                                    }
                                 
                              
                           , and the velocity of the current particle is
                              
                                 
                                 
                                    V
                                    c
                                 
                                 =
                                 
                                    {
                                    
                                       
                                          v
                                          
                                             s
                                             e
                                             q
                                          
                                       
                                       ,
                                       
                                          v
                                          1
                                       
                                       ,
                                       
                                          v
                                          2
                                       
                                       ,
                                       ⋯
                                       ,
                                       
                                          v
                                          
                                             |
                                             
                                                C
                                                S
                                             
                                             |
                                          
                                       
                                    
                                    }
                                 
                              
                           , where vseq
                            is the velocity of casts priority sequence, and vk
                            represents the velocity of the k-th cast of cast workload, then the particle's position is updated by the following procedure. Note that vk
                            may be a negative value.


                           
                              Position-
                              updating 
                              procedure
                           
                           
                              
                                 
                                    Step 1:
                                 
                                 randomly select a substring from the cast priority sequence of Po
                                     with length |CS| · vseq
                                     · γ, where γ is a coefficient and γ ∈ (0, 1).

take the selected substring as the value of the same position in the new particle
                                       
                                          
                                          
                                             P
                                             c
                                             
                                                n
                                                e
                                                w
                                             
                                          
                                       
                                    .

replace other positions in
                                       
                                          
                                          
                                             P
                                             c
                                             
                                                n
                                                e
                                                w
                                             
                                          
                                       
                                     with the remaining values of priority sequence in Pc
                                     without changing their relative order.

using the following formula to generate new values of cast workload for each cast:

                                       
                                          
                                             
                                                c
                                                
                                                   w
                                                   k
                                                   
                                                      n
                                                      e
                                                      w
                                                   
                                                
                                                =
                                                c
                                                
                                                   w
                                                   k
                                                   c
                                                
                                                +
                                                
                                                   v
                                                   k
                                                
                                                ,
                                                
                                                k
                                                =
                                                1
                                                ,
                                                2
                                                ,
                                                ⋯
                                                ,
                                                
                                                   |
                                                   
                                                      C
                                                      S
                                                   
                                                   |
                                                
                                             
                                          
                                       
                                    For velocity updating, we propose a method incorporating simulation data of the search process. Let WT
                                    
                                       k, t
                                     be the total waiting time of operations of cast k corresponding to solution Pc
                                     at iteration t, and 
                                       
                                          W
                                          
                                             T
                                             t
                                             
                                                a
                                                v
                                                g
                                             
                                          
                                       
                                     be the average total waiting time of operations of all casts corresponding to solution Pc
                                     at iteration t, velocities of cast priority sequence 
                                       
                                          v
                                          
                                             s
                                             e
                                             q
                                          
                                          c
                                       
                                     and each cast 
                                       
                                          v
                                          k
                                          c
                                       
                                     are updated by the following formula:

                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         v
                                                         
                                                            s
                                                            e
                                                            q
                                                         
                                                         
                                                            n
                                                            e
                                                            w
                                                         
                                                      
                                                   
                                                   
                                                      =
                                                   
                                                   
                                                      
                                                         
                                                            ω
                                                            t
                                                         
                                                         ·
                                                         
                                                            v
                                                            
                                                               s
                                                               e
                                                               q
                                                            
                                                            c
                                                         
                                                         +
                                                         
                                                            c
                                                            1
                                                         
                                                         ·
                                                         r
                                                      
                                                   
                                                
                                                
                                                   
                                                      
                                                         v
                                                         k
                                                         
                                                            n
                                                            e
                                                            w
                                                         
                                                      
                                                   
                                                   
                                                      =
                                                   
                                                   
                                                      
                                                         
                                                            ω
                                                            t
                                                         
                                                         ·
                                                         
                                                            v
                                                            k
                                                            c
                                                         
                                                         ·
                                                         1
                                                         
                                                            (
                                                            
                                                               W
                                                               
                                                                  T
                                                                  t
                                                                  
                                                                     a
                                                                     v
                                                                     g
                                                                  
                                                               
                                                               −
                                                               W
                                                               
                                                                  T
                                                                  
                                                                     k
                                                                     ,
                                                                     t
                                                                  
                                                               
                                                               >
                                                               0
                                                            
                                                            )
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                   
                                                   
                                                      
                                                         +
                                                         
                                                         
                                                            c
                                                            2
                                                         
                                                         ·
                                                         r
                                                         ,
                                                         
                                                         k
                                                         =
                                                         1
                                                         ,
                                                         2
                                                         ,
                                                         ⋯
                                                         ,
                                                         
                                                            |
                                                            
                                                               C
                                                               S
                                                            
                                                            |
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    where ωt
                                     is inertia weight,
                                       
                                          
                                          
                                             v
                                             
                                                s
                                                e
                                                q
                                             
                                             
                                                n
                                                e
                                                w
                                             
                                          
                                       
                                     is the velocity of cast priority sequence in the next generation, 
                                       
                                          v
                                          k
                                          
                                             n
                                             e
                                             w
                                          
                                       
                                     is the velocity of cast k in the next generation, 1( · ) is an indicator function, c
                                    1, c
                                    2 are control parameters and r is a random real number uniformly distributed over interval (−1, 1). The inertia weight is updated by: 
                                       
                                          
                                             ω
                                             
                                                t
                                                +
                                                1
                                             
                                          
                                          =
                                          
                                             ω
                                             t
                                          
                                          ·
                                          β
                                       
                                    , where β is the decrement factor to control the convergence speed of the algorithm.

As is shown in Section 3.1, the online dispatching layer decides in real time which charge and when to process after a machine becomes available, based on the soft schedule given by the upper layer and the real-time production information of charges, machines and operations. The inherent idea of the online dispatching heuristic is to dispatch charges such that the difference between the actual cast workload of each cast calculated from real-time production information and the expected cast workload given by the soft schedule is minimized.

The detailed heuristic is described as shown below.


                        
                           Online 
                           dispatching 
                           heuristic
                        
                        
                           
                              (1)
                              Dispatching heuristic for BOF stage:

                                    
                                       (a)
                                       For each charge 
                                             
                                                h
                                                ∈
                                                C
                                                
                                                   S
                                                   1
                                                
                                                ∪
                                                C
                                                
                                                   S
                                                   2
                                                
                                             
                                           in the buffer at time t, compute the difference, denoted as d
                                          
                                             h, t
                                          , between the actual cast workload cw
                                          
                                             h, t
                                           of the charge and cwh
                                           given by the soft schedule:
                                             
                                                
                                                   
                                                      
                                                         d
                                                         
                                                            h
                                                            ,
                                                            t
                                                         
                                                      
                                                      =
                                                      c
                                                      
                                                         w
                                                         
                                                            h
                                                            ,
                                                            t
                                                         
                                                      
                                                      −
                                                      c
                                                      
                                                         w
                                                         h
                                                      
                                                   
                                                
                                             
                                          
                                       

For the charge with the minimum d
                                          
                                             h, t
                                          :

                                             
                                                i.
                                                If d
                                                   
                                                      h, t
                                                    < 0, then select the current charge to be processed on the machine.

If d
                                                   
                                                      h, t
                                                    ≥ 0, then go to step d).

For each arrived charge h ∈ CS
                                          3, select the charge of which the cast is with the highest priority in the soft schedule.

Dispatching heuristic for LF stage:

                                    
                                       (a)
                                       For each charge h ∈ CS
                                          1 in the buffer at time t, select the charge with the earliest arrive time.

Dispatching heuristic for CC stage:

                                    
                                       i.
                                       If the current cast h has not finished at time t, i.e. there still exist a charge of cast h which has not been processed on a CC machine, then select the charge from Sh
                                           with the earliest arrive time to process.

If cast h has not finished at time t and no charge in the buffer belongs to the cast, then a cast interruption occurs.

If the current cast h just finishes processing at time t, then:

                                             
                                                •
                                                If there does not exist a charge in the buffer available for selection, i.e., all of casts corresponding to charges in the buffer are being processed in the CC stage, then do not select a charge and the current CC machine remains idle.

If there exist some charges in the buffer available for selection, then for the corresponding casts (denoted as CScc
                                                   ) of these charges, calculate the difference (denoted as d
                                                   
                                                      h, t
                                                   ) between the actual cast workload cw
                                                   
                                                      h, t
                                                    of the charge and cwh
                                                    in the soft solution:
                                                      
                                                         
                                                            
                                                               
                                                                  d
                                                                  
                                                                     h
                                                                     ,
                                                                     t
                                                                  
                                                               
                                                               =
                                                               c
                                                               
                                                                  w
                                                                  
                                                                     h
                                                                     ,
                                                                     t
                                                                  
                                                               
                                                               −
                                                               c
                                                               
                                                                  w
                                                                  h
                                                               
                                                            
                                                         
                                                      
                                                   
                                                

For the charge with the maximum d
                                                   
                                                      h, t
                                                   , denoted as
                                                      
                                                         
                                                         
                                                            d
                                                            
                                                               h
                                                               ,
                                                               t
                                                            
                                                            
                                                               m
                                                               a
                                                               x
                                                            
                                                         
                                                      
                                                   , if 
                                                      
                                                         
                                                            d
                                                            
                                                               h
                                                               ,
                                                               t
                                                            
                                                            
                                                               m
                                                               a
                                                               x
                                                            
                                                         
                                                         >
                                                         δ
                                                      
                                                    where δ is the threshold value, then select the charge to be processed on the current CC machine, else do not select a charge to process, and the machine remain idle.

In this section, we give results of the numerical experiments to compare the proposed algorithm with other related methods in literature for solving uncertain SCC scheduling problems under different production environments.

We use two classes of typical SCC scheduling instances to test our algorithm as described below, where the generation method for instances of Class I are mostly used in literature, while instances of Class II are directly taken from real-life SCC production environments.

                           
                              
                                 
                                    Class I:
                              
                              Short-term SCC scheduling instances. Each instance of this class corresponds to a problem of generating a schedule for a short period of time (often a shift or at most a day). Hence, the number of charges in each instance is comparatively small (tens to a hundred in most cases), and only non-critical events are considered in this case. Also, the offline optimization algorithm will be run only once at the beginning of the period to generate a soft schedule based on the overall information of a specified instance, while the online dispatching heuristic will be used multiple times whenever a dispatching decision needs to be made during the simulation, with the guidance of the soft schedule given by the offline optimization algorithm.

Long-term SCC scheduling instances. Each instance of this class corresponds to a long period of time (often several days) in real-world environments. The number of charges of each instance in this class is large (often hundreds to a thousand totally), and both critical and non-critical events are considered during the simulation. When critical events happen during the simulation, the offline optimization algorithm is used to generate a new soft schedule, while in the case of non-critical events, the soft schedule is not updated. At the same time, the online dispatching heuristic is also run in real-time whenever a dispatching decision needs to be made. Note that since information of future charges is not known at the beginning of the period, it is impossible, and unnecessary, to make a thorough schedule that covers all future charges in the period.

Traditional SCC scheduling algorithms in literature are often tested on instances similar with Class I, i.e. given an instance or a set of instances, the scheduling algorithm is run only once for each instance (usually with a simulation model), after that, based on the simulation data, some expected performance measures are calculated for evaluation. The above approach is frequently used in evaluating the performance of a candidate algorithm, however, in real-world environments, the above expected performance measures often cannot be achieved in practice due to a large number of unexpected disruptions. This is the motivation for designing test instances of Class II. In Class II, instead of using expected performance measures obtained by a single run of an algorithm, we construct an underlying simulation model to approximate behaviors of a real SCC production line. In this simulation model, the testing algorithm is triggered to run for generating a new schedule once a critical event happens, thus multiple runs of the algorithm are needed during the given period as critical events would probably happen multiple times. After the simulation ends, the final performance measures are obtained based on multiple runs of the algorithm for evaluation. The comparison of the two evaluation methods are shown in Fig. 8.
                     

In both classes of instances, arriving times, processing times and transportation times of charges are stochastic. Class I includes 15 sets of randomly generated instances, and Class II includes 5 instances, which are generated by directly taking the practical production data at 5 different periods of a large SCC shop from a large steel plant in China. Each period is about 7–10 days long, consisting of totally 100 casts and around 900 charges, 3 CC machines, 2 LF refining machines and 3 BOF machines.

In generating instances of Class I, the numbers of BOF, LF and CC machines are generated by randomly choosing an integer number from intervals (Atighehchian et al., 2009; Tang & Liu, 2007; Tang et al., 2001; Xuan & Tang, 2007), and (Missbauer et al., 2009; Xuan & Tang, 2007), respectively. The number of casts is a uniformly distributed number over interval (Harjunkoski & Grossmann, 2001; Kennedy & Eberhart, 1995), and the number of charges in a cast is an integer uniformly distributed over interval (Missbauer et al., 2009; Yu & Pan, 2012). The processing time of different stages and transportation time between different stages satisfy: p
                        
                           i, BOF
                         ∼ U[28, 35], p
                        
                           i, LF
                         ∼ U[20, 40], p
                        
                           i, CC
                         ∼ U[30, 40] and tri
                         ∼ U[3, 10]. The interval between arriving times of two consecutively arriving charges satisfies: Δr ∼ U (Missbauer et al., 2009; Yu & Pan, 2012). All time units of these variables are minutes. Also, since some casts do not go through the LF stage in real-world environments, the probability of going through LF is set as 0.7 for each charge. Instances of Class I and Class II are available at http://pan.baidu.com/s/1nt1FgfR. Note that the above stochastic variables in both classes of instances are not known until the corresponding simulation events, such as cast arrival or charge processing, happen in the process of simulation, and in the offline optimization algorithm, only mathematical expectations of these stochastic variables are used.

In all experiments, since the cost of cast interruption is much larger than that of charges’ waiting time, the coefficients in the objective function are set as follows:
                           
                              
                              
                                 α
                                 1
                              
                              =
                              1
                              ,
                              
                              
                                 α
                                 2
                              
                              =
                              200
                           
                        . The value of α
                        1 and α
                        2 is determined based on estimation of the cost of a new tundish and the cost of improving the temperature of a charge. Note that these coefficients may be different for different SCC shops and different periods.

The performance of the proposed SDA partially depends on its parameters including swarm size N, number of simulation runs for evaluating a soft schedule n, control parameters c
                        1, c
                        2, initial inertia weight ω
                        0, and decrement factor β. Suitable values of these parameters have to be determined to enhance the performance of the algorithm. We have made experiments on comparing different parameter combinations based on parameter selection instructions suggested in literature (Parsopoulos & Vrahatis, 2007; Shi & Eberhart, 1998), and the above parameters are set as follows:
                           
                              
                              N
                              =
                              40
                              ,
                              
                              n
                              =
                              10
                              ,
                              
                              
                                 c
                                 1
                              
                              =
                              0.1
                              ,
                              
                                 c
                                 2
                              
                              =
                              0.1
                              ,
                              
                              
                                 ω
                                 0
                              
                              =
                              1
                              ,
                              β
                              =
                              0.98
                           
                        . Besides that, a stopping criterion of 40 iterations is used in SDA for all parameter settings in the experiments on instances of both Class I and Class II.

Three different methods in literature are chosen for comparison on solving both classes of instances described above. These methods include:

                           
                              (1)
                              HANO (Atighehchian et al., 2009). HANO
                                  is a representative algorithm proposed for solving deterministic SCC scheduling problems by combining ant-colony optimization and non-linear programming techniques, which has been proven to be very efficient on SCC scheduling problems compared to a Genetic Algorithm and a heuristic algorithm used at a real steel company.

PIDE (Tang et al., 2014). PIDE is an improved differential evolution algorithm specially designed for dynamic scheduling of SCC process. The algorithm re-optimizes the assignment, sequencing, and timetable of a set of existing and new charges for the new environment when unforeseen disruptions occur. It adopts a memory scheme and an external archive scheme in the modified mutation strategy, as well as an incremental mechanism in the initialization procedure, to improve the efficiency of the DE algorithm. This algorithm is tested to be effective under rescheduling situations of SCC process.

CPLEX (https://www-304.ibm.com/ibm/university/academic/pub/page/ban_ilog_programming, 2014.7.2). CPLEX is the most famous commercial solver for solving mathematical programming problems, and has been used broadly in different industrial optimization fields. In our experiments, the SCC scheduling model is developed by OPL (Optimization Programming Language) and solved by CPLEX 12.6 (Academic version) downloaded from http://www.ibm.com.

Among three algorithms, HANO and CPLEX are designed for solving static scheduling problems, and PIDE is for solving SCC rescheduling problems with consideration of the current schedule. However, all of the above three algorithms are designed to generate only a timetable plan for each run, i.e. without a dispatching method under uncertain environments, therefore, in experiments on Class I and Class II, each of these algorithms is used as an offline optimization algorithm in the solution framework to generate a timetable plan. And due to unexpected disruptions in the simulation, we design an online dispatching strategy in this case to determine when and which charge to process once a machine gets idle based on the timetable plan generated above. The dispatching strategy is described as follows: the allocated machine for each charge and the sequence of charges at each stage are strictly the same with that of the generated timetable plan, but the start time of a charge is not later than the maximum of its arriving time from the upstream stage and its planned start time in the corresponding timetable plan. In other words, a charge is taken to be processed if and only if it has arrived and the current timestamp in the simulation is larger than or equal to its starting time given by the timetable plan. In addition, since in HANO the cast sequence is regarded as an input parameter, when solving each instance by HANO, the cast sequence is obtained from the best solution of SDA.

Based on the above assumptions, we have implemented the above three comparison algorithms and SDA using C# language, where CPLEX 12.6 is used as a dynamic library. All of experiments are done on a computer with 4 gigabytes RAM and two 2.8 gigahertz CPU cores. In these experiments, 20 independent trials are carried out for each instance and each algorithm. Table 1 shows the average values (AVGAWT and AVGCIR) and the standard deviations (STDAWT and STDCIR) of the above 20 independent runs for each instance in Class I, where the best result for each instance among four algorithms is marked in boldface. The average running time (ART) of each algorithm is also listed in the table, where the time unit is second. In these experiments, the stopping criterion of HANO is that the solution cannot be improved within 100 sequential iterations, and the stopping criterion of CPLEX and PIDE is a fixed time interval (150 seconds) and a fixed iterations (100), respectively.

Clearly in Table 1, on randomly generated SCC scheduling instances in Class I, SDA outperforms HANO, CPLEX and PIDE on almost all of instances with respect to the average and standard deviation value of CIR, and gives similar results with the best algorithms (CPLEX and PIDE) among three comparison algorithms in all of instances with respect to the average and standard deviation value of AWT. It can be concluded that the two criterions are well balanced in SDA toward uncertain situations, while comparison algorithms are intended to optimize AWT without providing enough allowance of waiting time to prevent cast interruptions under uncertain situations. Also, the running time of four algorithms is close and can be accepted in practice. This demonstrates the superior performance of SDA under uncertain production environments.


                        Table 2 shows experimental results of SDA and the other three approaches on instances in Class II. Also, the real production performance indicators (AWT and the number of cast interruptions), which is calculated based on real-life production data, are also listed in Table 2 for comparison. In each experiment for a given instance in this case, each offline optimization algorithm (PIDE, CPLEX and SDA) will be run multiple times and generate a schedule for execution at each time. The run of offline optimization algorithms will be triggered by critical events defined in Section 3.1. When one of the above events occurs, a soft schedule is generated at each time by SDA, while a timetable plan is generated at each time by PIDE or CPLEX. Also, for each instance in Class II, if a cast interruption occurs, the remaining charges of the interrupted cast will be grouped into a new cast in the simulation, and a new schedule will be generated by one of the offline optimization algorithms.

In Table 2, nci
                         denotes the number of cast interruptions during 10 days’ simulation of PIDE, SDA and CPLEX, PSH denotes practical scheduling heuristic in the SCC shop, and nrci
                         represents the number of cast interruptions obtained from real-life production data of the SCC shop. From Table 2 we can see that considerable improvements of two performance indicators are obtained by SDA on real uncertain scheduling environments compared to other two algorithms and the scheduling heuristic in practice in terms of nci
                        , and SDA also performs similarly with the best algorithm (PIDE) of the other three methods. Also, PSH performs better than PIDE and CPLEX with respect to the number of cast interruptions, and worse than them with respect to AWTAVG, in average. This illustrates that schedulers are more inclined to decrease the number of cast interruptions in practice, as the cast interruptions is more influential to the production cost and stability.

Furthermore, we have made experiments on problems with different level of uncertainty in order to test the proposed algorithm comprehensively, where HANO is taken for comparison. In these experiments, we define a concept named “uncertainty level δ” to represent whether the problem is strongly uncertain or not. As many stochastic variables are introduced in the problem formulation in Section 2, without loss of generosity we assume that the interval of a stochastic variable is [Vmin, Vmax
                        ] where the stochastic variable V may represent processing time, transportation time or arriving time. Then, we generate the SCC scheduling problems with different uncertainty level by sampling stochastic variables from the corresponding interval [Vmin
                         · δ, Vmax
                         · δ]. Table 3 shows the experimental results of the two algorithms on problems 1# to 3# of Class I with different uncertainty level. Other parameter settings are the same as that in Section 4.1.

It can be seen in Table 3 that, when δ ≥ 0.4, SDA performs significantly better in most problems (10 out of 12 with respect to AWT, 12 out of 12 with respect to CIR) with different uncertainty level. While for problems with δ ≤ 0.2, HANO is capable to give superior solution in most cases (5 out of 6 with respect to the weighted sum of AWT and CIR) as it incorporates deterministic nonlinear programming techniques to optimize the starting times of operations in the timetable plan. Therefore, it can be concluded that SDA is more suitable for SCC scheduling problems with a stronger uncertainty level.

As mentioned in Section 3, the SDA algorithm has two main improvement strategies: (1) knowledge-based swarm initialization, and (2) adaptive updating of positions and velocities. In this section, we analyze two improvement strategies by making experiments with different configurations of SDA on some typical SCC scheduling problems.

SDA uses the knowledge based swarm initialization method where historical production data is incorporated to calculate the maximum and minimum value of cast workload, and human knowledge is also used to initialize the priority sequence of casts. Generally in PSO, individuals are often generated randomly from its value space. In this section we test the proposed SDA and SDA with random swarm initialization method (denoted as SDA-RSI) to analyze the performance of knowledge based swarm initialization method in SDA.


                           Fig. 9 lists the convergence curve of fitness values (y-axis) versus iterations (x-axis) during the solution process of SDA and SDA-RSI on instances 1#–6#. Experiments on other instances present similar behavior with diagrams shown above. To be concise, we only list the convergence curve of total production cost F (which is the weighted sum of AWT and CIR) for each instance. The diagrams show that the performance of initial swarm of SDA is much better than that of SDA-RSI, and also SDA performs better in most cases than SDA-RSI with respect to the final objective value obtained by two algorithms. Therefore, it can be concluded that compared to SDA-RSI, SDA is more suitable to solve the studied problem, especially in case that CPU time is limited.

In SDA, an adaptive updating method is used to guide the search process of the offline optimization algorithm, which is designed to improve effectiveness and efficiency of PSO algorithm according to features of the studied SCC scheduling problem. In this section, we test our APSO algorithm with the standard PSO presented in AlRashidi and El-Hawary (2009) under the framework proposed in this paper for solving the SCC scheduling problem, and the corresponding parameter settings of the standard PSO are the same with that in Section 4.1. Table 4 lists the experimental results of two algorithms (denoted as SDA-APSO and SDA-SPSO) on instances of Class I.

It can be seen that in Table 4, SDA-APSO is more powerful in searching for better solutions of the studied problem with given parameter settings. In detail, values of CIR of SDA-SPSO are better than that of HANO for the same problem instance, and are close with that of SDA-APSO, while for AWT, SDA-APSO performs better than SDA-SPSO in most cases (14 out of 15). This may be explained by that both algorithms have adopted the soft decision based approach, while SDA-APSO is better in exploring the solution space, as it incorporates feedback information from solutions obtained at earlier iterations.

@&#CONCLUSIONS AND FUTURE WORK@&#

The real-life scheduling of SCC production is a complex industrial optimization problem, especially under strongly uncertain production environments. Unlike traditional approaches that use rigid-decision based methods to find an optimized timetable plan, this paper adopts a new concept of soft decision in order to discover and represent the underlying production scheduling strategies under strongly uncertain environments. Based on the analysis of production data, we take the cast workload and the priority sequence of casts as the formulation of the soft decision. Furthermore, we develop a two-layered optimization framework to optimize the soft decision and the online dispatching heuristic. The upper layer is the offline optimization layer, in which a particle swarm optimization algorithm is proposed to optimize the soft schedule. The lower layer is the online dispatching layer, where a dispatching heuristic is designed to decide in real time which charge and when to process after a machine gets available, based on the soft schedule given by the upper layer and the real-time production data. Computational experiments on randomly generated stochastic instances and the practical production data demonstrate the performance of the proposed soft-decision based algorithm.

The idea of our approach is also instructive for solving other similar scheduling problems under uncertain environments, as dealing with a large number of unexpected disruptions is always a key issue in designing the corresponding scheduling algorithms. In these situations, we argue that, by converting the rigid decision variables into soft decision variables, the original problem can be reformulated into a new problem and the corresponding solution of the new problem is capable to provide more flexibility in uncertain environments. In other words, by reformulating the original problem into a soft-decision based problem, we try to obtain some scheduling strategies that remain changeless under uncertain environments.

Future work includes the following two aspects. First, deploy the proposed algorithm at a large SCC production line to verify its effectiveness in solving real-life problems and extend the proposed method to solve other type of scheduling problems under uncertain environments, in which determining the form of soft decision based on problem features is the key step. Second, since the time to run the offline optimization algorithm is very important to the overall performance of our approach, it is interesting to further study the best opportunity to trigger the offline optimization algorithm.

@&#ACKNOWLEDGMENTS@&#

This work is partially supported by the National Natural Science Foundation of China (Nos. 61104172, 61025018, 51375038, 60834004), the National Key Basic Research and Development Program of China (2009CB320602) and the National Science and Technology Major Projects (No. 2011ZX02504). The authors would like to thank the Computer & Information Center in ShaSteel Group for cooperation in numerical experiments and applications of this research. Also, the authors would like to thank anonymous referees for their constructive comments and suggestions to improve this paper.

@&#REFERENCES@&#

